commit 6e97c8460005ac9a814138970cb7fefa845ab6af
Author: Alexey Polovinkin <apolov@algostrategies.com>
Date:   Tue Dec 21 11:17:56 2021 +0000

    Gitlab tool publication

diff --git a/bin/gitlab b/bin/gitlab
new file mode 120000
index 000000000..4cdf0ebca
--- /dev/null
+++ b/bin/gitlab
@@ -0,0 +1 @@
+../build/release/gitlab
\ No newline at end of file
diff --git a/cpp/gen/command_gen.cpp b/cpp/gen/command_gen.cpp
index 329b91eb3..f9ef6ec0b 100644
--- a/cpp/gen/command_gen.cpp
+++ b/cpp/gen/command_gen.cpp
@@ -152,6 +152,24 @@ const char* command::value_ToCstr(const command::FieldId& parent) {
         case command_FieldId_perf_secs     : ret = "perf_secs";  break;
         case command_FieldId_pertest_timeout: ret = "pertest_timeout";  break;
         case command_FieldId_capture       : ret = "capture";  break;
+        case command_FieldId_issue         : ret = "issue";  break;
+        case command_FieldId_server        : ret = "server";  break;
+        case command_FieldId_project       : ret = "project";  break;
+        case command_FieldId_auth_token    : ret = "auth_token";  break;
+        case command_FieldId_mrlist        : ret = "mrlist";  break;
+        case command_FieldId_mergereq      : ret = "mergereq";  break;
+        case command_FieldId_ilist         : ret = "ilist";  break;
+        case command_FieldId_istart        : ret = "istart";  break;
+        case command_FieldId_iadd          : ret = "iadd";  break;
+        case command_FieldId_ic            : ret = "ic";  break;
+        case command_FieldId_iclose        : ret = "iclose";  break;
+        case command_FieldId_iassignto     : ret = "iassignto";  break;
+        case command_FieldId_title         : ret = "title";  break;
+        case command_FieldId_description   : ret = "description";  break;
+        case command_FieldId_gitdir        : ret = "gitdir";  break;
+        case command_FieldId_assignee      : ret = "assignee";  break;
+        case command_FieldId_ulist         : ret = "ulist";  break;
+        case command_FieldId_mraccept      : ret = "mraccept";  break;
         case command_FieldId_complooo      : ret = "complooo";  break;
         case command_FieldId_args          : ret = "args";  break;
         case command_FieldId_manywin       : ret = "manywin";  break;
@@ -250,6 +268,9 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR2('d','b'): {
                     value_SetEnum(parent,command_FieldId_db); ret = true; break;
                 }
+                case LE_STR2('i','c'): {
+                    value_SetEnum(parent,command_FieldId_ic); ret = true; break;
+                }
                 case LE_STR2('i','n'): {
                     value_SetEnum(parent,command_FieldId_in); ret = true; break;
                 }
@@ -347,6 +368,9 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR4('h','a','s','h'): {
                     value_SetEnum(parent,command_FieldId_hash); ret = true; break;
                 }
+                case LE_STR4('i','a','d','d'): {
+                    value_SetEnum(parent,command_FieldId_iadd); ret = true; break;
+                }
                 case LE_STR4('i','f','f','y'): {
                     value_SetEnum(parent,command_FieldId_iffy); ret = true; break;
                 }
@@ -439,6 +463,12 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR5('f','s','t','e','p'): {
                     value_SetEnum(parent,command_FieldId_fstep); ret = true; break;
                 }
+                case LE_STR5('i','l','i','s','t'): {
+                    value_SetEnum(parent,command_FieldId_ilist); ret = true; break;
+                }
+                case LE_STR5('i','s','s','u','e'): {
+                    value_SetEnum(parent,command_FieldId_issue); ret = true; break;
+                }
                 case LE_STR5('l','o','o','s','e'): {
                     value_SetEnum(parent,command_FieldId_loose); ret = true; break;
                 }
@@ -472,12 +502,18 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR5('s','t','a','r','t'): {
                     value_SetEnum(parent,command_FieldId_start); ret = true; break;
                 }
+                case LE_STR5('t','i','t','l','e'): {
+                    value_SetEnum(parent,command_FieldId_title); ret = true; break;
+                }
                 case LE_STR5('t','r','a','c','e'): {
                     value_SetEnum(parent,command_FieldId_trace); ret = true; break;
                 }
                 case LE_STR5('t','r','u','n','c'): {
                     value_SetEnum(parent,command_FieldId_trunc); ret = true; break;
                 }
+                case LE_STR5('u','l','i','s','t'): {
+                    value_SetEnum(parent,command_FieldId_ulist); ret = true; break;
+                }
                 case LE_STR5('u','n','a','m','e'): {
                     value_SetEnum(parent,command_FieldId_uname); ret = true; break;
                 }
@@ -522,6 +558,12 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR6('g','c','o','n','s','t'): {
                     value_SetEnum(parent,command_FieldId_gconst); ret = true; break;
                 }
+                case LE_STR6('g','i','t','d','i','r'): {
+                    value_SetEnum(parent,command_FieldId_gitdir); ret = true; break;
+                }
+                case LE_STR6('i','c','l','o','s','e'): {
+                    value_SetEnum(parent,command_FieldId_iclose); ret = true; break;
+                }
                 case LE_STR6('i','n','_','d','i','r'): {
                     value_SetEnum(parent,command_FieldId_in_dir); ret = true; break;
                 }
@@ -531,9 +573,15 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR6('i','n','s','e','r','t'): {
                     value_SetEnum(parent,command_FieldId_insert); ret = true; break;
                 }
+                case LE_STR6('i','s','t','a','r','t'): {
+                    value_SetEnum(parent,command_FieldId_istart); ret = true; break;
+                }
                 case LE_STR6('m','a','x','e','r','r'): {
                     value_SetEnum(parent,command_FieldId_maxerr); ret = true; break;
                 }
+                case LE_STR6('m','r','l','i','s','t'): {
+                    value_SetEnum(parent,command_FieldId_mrlist); ret = true; break;
+                }
                 case LE_STR6('n','o','f','o','r','k'): {
                     value_SetEnum(parent,command_FieldId_nofork); ret = true; break;
                 }
@@ -564,6 +612,9 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR6('s','e','l','e','c','t'): {
                     value_SetEnum(parent,command_FieldId_select); ret = true; break;
                 }
+                case LE_STR6('s','e','r','v','e','r'): {
+                    value_SetEnum(parent,command_FieldId_server); ret = true; break;
+                }
                 case LE_STR6('s','u','b','s','e','t'): {
                     value_SetEnum(parent,command_FieldId_subset); ret = true; break;
                 }
@@ -662,6 +713,9 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR7('p','r','e','p','r','o','c'): {
                     value_SetEnum(parent,command_FieldId_preproc); ret = true; break;
                 }
+                case LE_STR7('p','r','o','j','e','c','t'): {
+                    value_SetEnum(parent,command_FieldId_project); ret = true; break;
+                }
                 case LE_STR7('r','e','f','t','y','p','e'): {
                     value_SetEnum(parent,command_FieldId_reftype); ret = true; break;
                 }
@@ -700,6 +754,9 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
         }
         case 8: {
             switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('a','s','s','i','g','n','e','e'): {
+                    value_SetEnum(parent,command_FieldId_assignee); ret = true; break;
+                }
                 case LE_STR8('c','o','m','p','i','l','e','r'): {
                     value_SetEnum(parent,command_FieldId_compiler); ret = true; break;
                 }
@@ -724,6 +781,12 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                 case LE_STR8('m','a','x','g','r','o','u','p'): {
                     value_SetEnum(parent,command_FieldId_maxgroup); ret = true; break;
                 }
+                case LE_STR8('m','e','r','g','e','r','e','q'): {
+                    value_SetEnum(parent,command_FieldId_mergereq); ret = true; break;
+                }
+                case LE_STR8('m','r','a','c','c','e','p','t'): {
+                    value_SetEnum(parent,command_FieldId_mraccept); ret = true; break;
+                }
                 case LE_STR8('n','e','x','t','f','i','l','e'): {
                     value_SetEnum(parent,command_FieldId_nextfile); ret = true; break;
                 }
@@ -760,6 +823,10 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
                     if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,command_FieldId_checkable); ret = true; break; }
                     break;
                 }
+                case LE_STR8('i','a','s','s','i','g','n','t'): {
+                    if (memcmp(rhs.elems+8,"o",1)==0) { value_SetEnum(parent,command_FieldId_iassignto); ret = true; break; }
+                    break;
+                }
                 case LE_STR8('m','a','x','p','a','c','k','e'): {
                     if (memcmp(rhs.elems+8,"t",1)==0) { value_SetEnum(parent,command_FieldId_maxpacket); ret = true; break; }
                     break;
@@ -785,6 +852,10 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
         }
         case 10: {
             switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('a','u','t','h','_','t','o','k'): {
+                    if (memcmp(rhs.elems+8,"en",2)==0) { value_SetEnum(parent,command_FieldId_auth_token); ret = true; break; }
+                    break;
+                }
                 case LE_STR8('c','a','t','c','h','t','h','r'): {
                     if (memcmp(rhs.elems+8,"ow",2)==0) { value_SetEnum(parent,command_FieldId_catchthrow); ret = true; break; }
                     break;
@@ -798,6 +869,10 @@ bool command::value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) {
         }
         case 11: {
             switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('d','e','s','c','r','i','p','t'): {
+                    if (memcmp(rhs.elems+8,"ion",3)==0) { value_SetEnum(parent,command_FieldId_description); ret = true; break; }
+                    break;
+                }
                 case LE_STR8('i','g','n','o','r','e','Q','u'): {
                     if (memcmp(rhs.elems+8,"ote",3)==0) { value_SetEnum(parent,command_FieldId_ignoreQuote); ret = true; break; }
                     break;
@@ -6754,6 +6829,566 @@ void command::bash_proc_Uninit(command::bash_proc& parent) {
     bash_Kill(parent); // kill child, ensure forward progress
 }
 
+// --- command.gitlab.issue.Print
+// Print back to string
+void command::issue_Print(command::gitlab& parent, algo::cstring &out) {
+    Regx_Print(parent.issue, out);
+}
+
+// --- command.gitlab.issue.ReadStrptrMaybe
+// Read Regx from string
+// Convert string to field. Return success value
+bool command::issue_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) {
+    Regx_ReadSql(parent.issue, in, true);
+    bool retval = true;// !parent.issue.parseerror; -- TODO: uncomment
+    return retval;
+}
+
+// --- command.gitlab.assignee.Print
+// Print back to string
+void command::assignee_Print(command::gitlab& parent, algo::cstring &out) {
+    Regx_Print(parent.assignee, out);
+}
+
+// --- command.gitlab.assignee.ReadStrptrMaybe
+// Read Regx from string
+// Convert string to field. Return success value
+bool command::assignee_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) {
+    Regx_ReadSql(parent.assignee, in, true);
+    bool retval = true;// !parent.assignee.parseerror; -- TODO: uncomment
+    return retval;
+}
+
+// --- command.gitlab..ReadFieldMaybe
+bool command::gitlab_ReadFieldMaybe(command::gitlab &parent, algo::strptr field, algo::strptr strval) {
+    command::FieldId field_id;
+    (void)value_SetStrptrMaybe(field_id,field);
+    bool retval = true; // default is no error
+    switch(field_id) {
+        case command_FieldId_in: retval = algo::cstring_ReadStrptrMaybe(parent.in, strval); break;
+        case command_FieldId_issue: retval = issue_ReadStrptrMaybe(parent, strval); break;
+        case command_FieldId_server: retval = algo::cstring_ReadStrptrMaybe(parent.server, strval); break;
+        case command_FieldId_project: retval = algo::cstring_ReadStrptrMaybe(parent.project, strval); break;
+        case command_FieldId_auth_token: retval = algo::cstring_ReadStrptrMaybe(parent.auth_token, strval); break;
+        case command_FieldId_mrlist: retval = bool_ReadStrptrMaybe(parent.mrlist, strval); break;
+        case command_FieldId_mergereq: retval = bool_ReadStrptrMaybe(parent.mergereq, strval); break;
+        case command_FieldId_ilist: retval = bool_ReadStrptrMaybe(parent.ilist, strval); break;
+        case command_FieldId_istart: retval = bool_ReadStrptrMaybe(parent.istart, strval); break;
+        case command_FieldId_t: retval = bool_ReadStrptrMaybe(parent.t, strval); break;
+        case command_FieldId_iadd: retval = bool_ReadStrptrMaybe(parent.iadd, strval); break;
+        case command_FieldId_ic: retval = bool_ReadStrptrMaybe(parent.ic, strval); break;
+        case command_FieldId_iclose: retval = bool_ReadStrptrMaybe(parent.iclose, strval); break;
+        case command_FieldId_iassignto: retval = algo::Smallstr50_ReadStrptrMaybe(parent.iassignto, strval); break;
+        case command_FieldId_title: retval = algo::cstring_ReadStrptrMaybe(parent.title, strval); break;
+        case command_FieldId_description: retval = algo::cstring_ReadStrptrMaybe(parent.description, strval); break;
+        case command_FieldId_comment: retval = algo::cstring_ReadStrptrMaybe(parent.comment, strval); break;
+        case command_FieldId_gitdir: retval = algo::cstring_ReadStrptrMaybe(parent.gitdir, strval); break;
+        case command_FieldId_assignee: retval = assignee_ReadStrptrMaybe(parent, strval); break;
+        case command_FieldId_ulist: retval = bool_ReadStrptrMaybe(parent.ulist, strval); break;
+        case command_FieldId_mraccept: retval = algo::cstring_ReadStrptrMaybe(parent.mraccept, strval); break;
+        default: break;
+    }
+    if (!retval) {
+        algo_lib::AppendErrtext("attr",field);
+    }
+    return retval;
+}
+
+// --- command.gitlab..ReadTupleMaybe
+// Read fields of command::gitlab from attributes of ascii tuple TUPLE
+bool command::gitlab_ReadTupleMaybe(command::gitlab &parent, algo::Tuple &tuple) {
+    bool retval = true;
+    int anon_idx = 0;
+    ind_beg(algo::Tuple_attrs_curs,attr,tuple) {
+        if (ch_N(attr.name) == 0) {
+            attr.name = gitlab_GetAnon(parent, anon_idx++);
+        }
+        retval = gitlab_ReadFieldMaybe(parent, attr.name, attr.value);
+        if (!retval) {
+            break;
+        }
+    }ind_end;
+    return retval;
+}
+
+// --- command.gitlab..Init
+// Set all fields to initial values.
+void command::gitlab_Init(command::gitlab& parent) {
+    parent.in = algo::strptr("data");
+    Regx_ReadSql(parent.issue, "", true);
+    parent.server = algo::strptr("gitlab.lon.algo");
+    parent.project = algo::strptr("myproject");
+    parent.auth_token = algo::strptr("");
+    parent.mrlist = bool(false);
+    parent.mergereq = bool(false);
+    parent.ilist = bool(false);
+    parent.istart = bool(false);
+    parent.t = bool(false);
+    parent.iadd = bool(false);
+    parent.ic = bool(false);
+    parent.iclose = bool(false);
+    parent.iassignto = algo::strptr("");
+    parent.title = algo::strptr("");
+    parent.description = algo::strptr("");
+    parent.comment = algo::strptr("");
+    parent.gitdir = algo::strptr("");
+    Regx_ReadSql(parent.assignee, "", true);
+    parent.ulist = bool(false);
+    parent.mraccept = algo::strptr("");
+}
+
+// --- command.gitlab..PrintArgv
+// print command-line args of command::gitlab to string  -- cprint:command.gitlab.Argv
+void command::gitlab_PrintArgv(command::gitlab & row, algo::cstring &str) {
+    algo::tempstr temp;
+    (void)temp;
+    (void)row;
+    (void)str;
+    if (!(row.in == "data")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.in, temp);
+        str << " -in:";
+        strptr_PrintBash(temp,str);
+    }
+    ch_RemoveAll(temp);
+    command::issue_Print(const_cast<command::gitlab&>(row), temp);
+    str << " ";
+    strptr_PrintBash(temp,str);
+    if (!(row.server == "gitlab.lon.algo")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.server, temp);
+        str << " -server:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.project == "myproject")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.project, temp);
+        str << " -project:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.auth_token == "")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.auth_token, temp);
+        str << " -auth_token:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.mrlist == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.mrlist, temp);
+        str << " -mrlist:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.mergereq == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.mergereq, temp);
+        str << " -mergereq:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.ilist == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.ilist, temp);
+        str << " -ilist:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.istart == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.istart, temp);
+        str << " -istart:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.t == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.t, temp);
+        str << " -t:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.iadd == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.iadd, temp);
+        str << " -iadd:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.ic == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.ic, temp);
+        str << " -ic:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.iclose == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.iclose, temp);
+        str << " -iclose:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.iassignto == "")) {
+        ch_RemoveAll(temp);
+        Smallstr50_Print(row.iassignto, temp);
+        str << " -iassignto:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.title == "")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.title, temp);
+        str << " -title:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.description == "")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.description, temp);
+        str << " -description:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.comment == "")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.comment, temp);
+        str << " -comment:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.gitdir == "")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.gitdir, temp);
+        str << " -gitdir:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.assignee.expr == "")) {
+        ch_RemoveAll(temp);
+        command::assignee_Print(const_cast<command::gitlab&>(row), temp);
+        str << " -assignee:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.ulist == false)) {
+        ch_RemoveAll(temp);
+        bool_Print(row.ulist, temp);
+        str << " -ulist:";
+        strptr_PrintBash(temp,str);
+    }
+    if (!(row.mraccept == "")) {
+        ch_RemoveAll(temp);
+        cstring_Print(row.mraccept, temp);
+        str << " -mraccept:";
+        strptr_PrintBash(temp,str);
+    }
+}
+
+// --- command.gitlab..ToCmdline
+// Convenience function that returns a full command line
+// Assume command is in a directory called bin
+tempstr command::gitlab_ToCmdline(command::gitlab & row) {
+    tempstr ret;
+    ret << "bin/gitlab ";
+    gitlab_PrintArgv(row, ret);
+    // inherit less intense verbose, debug options
+    for (int i = 1; i < algo_lib::_db.cmdline.verbose; i++) {
+        ret << " -verbose";
+    }
+    for (int i = 1; i < algo_lib::_db.cmdline.debug; i++) {
+        ret << " -debug";
+    }
+    return ret;
+}
+
+// --- command.gitlab..GetAnon
+algo::strptr command::gitlab_GetAnon(command::gitlab &parent, i32 idx) {
+    (void)parent;//only to avoid -Wunused-parameter
+    switch(idx) {
+        case(0): return strptr("issue", 5);
+        default: return algo::strptr();
+    }
+}
+
+// --- command.gitlab_proc.gitlab.Start
+// Start subprocess
+// If subprocess already running, do nothing. Otherwise, start it
+int command::gitlab_Start(command::gitlab_proc& parent) {
+    int retval = 0;
+    if (parent.pid == 0) {
+        verblog(gitlab_ToCmdline(parent)); // maybe print command
+#ifdef WIN32
+        algo_lib::ResolveExecFname(parent.path);
+        tempstr cmdline(gitlab_ToCmdline(parent));
+        parent.pid = dospawn(Zeroterm(parent.path),Zeroterm(cmdline),parent.timeout,parent.fstdin,parent.fstdout,parent.fstderr);
+#else
+        parent.pid = fork();
+        if (parent.pid == 0) { // child
+            algo_lib::DieWithParent();
+            if (parent.timeout > 0) {
+                alarm(parent.timeout);
+            }
+            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdin , 0);
+            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstdout, 1);
+            if (retval==0) retval=algo_lib::ApplyRedirect(parent.fstderr, 2);
+            if (retval==0) retval= gitlab_Execv(parent);
+            if (retval != 0) { // if start fails, print error
+                int err=errno;
+                prerr("command.gitlab_execv"
+                <<Keyval("errno",err)
+                <<Keyval("errstr",strerror(err))
+                <<Keyval("comment","Execv failed"));
+            }
+            _exit(127); // if failed to start, exit anyway
+        } else if (parent.pid == -1) {
+            retval = errno; // failed to fork
+        }
+#endif
+    }
+    parent.status = parent.pid > 0 ? 0 : -1; // if didn't start, set error status
+    return retval;
+}
+
+// --- command.gitlab_proc.gitlab.StartRead
+// Start subprocess & Read output
+algo::Fildes command::gitlab_StartRead(command::gitlab_proc& parent, algo_lib::FFildes &read) {
+    int pipefd[2];
+    int rc=pipe(pipefd);
+    (void)rc;
+    read.fd.value = pipefd[0];
+    parent.fstdout  << ">&" << pipefd[1];
+    gitlab_Start(parent);
+    (void)close(pipefd[1]);
+    return read.fd;
+}
+
+// --- command.gitlab_proc.gitlab.Kill
+// Kill subprocess and wait
+void command::gitlab_Kill(command::gitlab_proc& parent) {
+    if (parent.pid != 0) {
+        kill(parent.pid,9);
+        gitlab_Wait(parent);
+    }
+}
+
+// --- command.gitlab_proc.gitlab.Wait
+// Wait for subprocess to return
+void command::gitlab_Wait(command::gitlab_proc& parent) {
+    if (parent.pid > 0) {
+        int wait_flags = 0;
+        int wait_status = 0;
+        int rc = -1;
+        do {
+            // really wait for subprocess to exit
+            rc = waitpid(parent.pid,&wait_status,wait_flags);
+        } while (rc==-1 && errno==EINTR);
+        if (rc == parent.pid) {
+            parent.status = wait_status;
+            parent.pid = 0;
+        }
+    }
+}
+
+// --- command.gitlab_proc.gitlab.Exec
+// Start + Wait
+// Execute subprocess and return exit code
+int command::gitlab_Exec(command::gitlab_proc& parent) {
+    gitlab_Start(parent);
+    gitlab_Wait(parent);
+    return parent.status;
+}
+
+// --- command.gitlab_proc.gitlab.ExecX
+// Start + Wait, throw exception on error
+// Execute subprocess; throw human-readable exception on error
+void command::gitlab_ExecX(command::gitlab_proc& parent) {
+    int rc = gitlab_Exec(parent);
+    vrfy(rc==0, tempstr() << "algo_lib.exec" << Keyval("cmd",gitlab_ToCmdline(parent))
+    << Keyval("comment",algo::DescribeWaitStatus(parent.status)));
+}
+
+// --- command.gitlab_proc.gitlab.Execv
+// Call execv()
+// Call execv with specified parameters -- cprint:gitlab.Argv
+int command::gitlab_Execv(command::gitlab_proc& parent) {
+    char *argv[42+2]; // start of first arg (future pointer)
+    algo::tempstr temp;
+    int n_argv=0;
+    argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+    temp << parent.path;
+    ch_Alloc(temp) = 0;// NUL term for pathname
+
+    if (parent.cmd.in != "data") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-in:";
+        cstring_Print(parent.cmd.in, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.issue.expr != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-issue:";
+        command::issue_Print(parent.cmd, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.server != "gitlab.lon.algo") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-server:";
+        cstring_Print(parent.cmd.server, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.project != "myproject") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-project:";
+        cstring_Print(parent.cmd.project, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.auth_token != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-auth_token:";
+        cstring_Print(parent.cmd.auth_token, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.mrlist != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-mrlist:";
+        bool_Print(parent.cmd.mrlist, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.mergereq != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-mergereq:";
+        bool_Print(parent.cmd.mergereq, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.ilist != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-ilist:";
+        bool_Print(parent.cmd.ilist, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.istart != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-istart:";
+        bool_Print(parent.cmd.istart, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.t != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-t:";
+        bool_Print(parent.cmd.t, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.iadd != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-iadd:";
+        bool_Print(parent.cmd.iadd, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.ic != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-ic:";
+        bool_Print(parent.cmd.ic, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.iclose != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-iclose:";
+        bool_Print(parent.cmd.iclose, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.iassignto != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-iassignto:";
+        Smallstr50_Print(parent.cmd.iassignto, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.title != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-title:";
+        cstring_Print(parent.cmd.title, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.description != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-description:";
+        cstring_Print(parent.cmd.description, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.comment != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-comment:";
+        cstring_Print(parent.cmd.comment, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.gitdir != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-gitdir:";
+        cstring_Print(parent.cmd.gitdir, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.assignee.expr != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-assignee:";
+        command::assignee_Print(parent.cmd, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.ulist != false) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-ulist:";
+        bool_Print(parent.cmd.ulist, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+
+    if (parent.cmd.mraccept != "") {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-mraccept:";
+        cstring_Print(parent.cmd.mraccept, temp);
+        ch_Alloc(temp) = 0;// NUL term for this arg
+    }
+    for (int i=0; i+1 < algo_lib::_db.cmdline.verbose; i++) {
+        argv[n_argv++] = (char*)(int_ptr)ch_N(temp);// future pointer
+        temp << "-verbose";
+        ch_Alloc(temp) = 0;
+    }
+    argv[n_argv] = NULL; // last pointer
+    while (n_argv>0) { // shift pointers
+        argv[--n_argv] += (u64)temp.ch_elems;
+    }
+    // if parent.path is relative, search for it in PATH
+    algo_lib::ResolveExecFname(parent.path);
+    return execv(Zeroterm(parent.path),argv);
+}
+
+// --- command.gitlab_proc.gitlab.ToCmdline
+algo::tempstr command::gitlab_ToCmdline(command::gitlab_proc& parent) {
+    algo::tempstr retval;
+    retval << parent.path << " ";
+    command::gitlab_PrintArgv(parent.cmd,retval);
+    if (ch_N(parent.fstdin)) {
+        retval << " " << parent.fstdin;
+    }
+    if (ch_N(parent.fstdout)) {
+        retval << " " << parent.fstdout;
+    }
+    if (ch_N(parent.fstderr)) {
+        retval << " 2" << parent.fstderr;
+    }
+    return retval;
+}
+
+// --- command.gitlab_proc..Uninit
+void command::gitlab_proc_Uninit(command::gitlab_proc& parent) {
+    command::gitlab_proc &row = parent; (void)row;
+
+    // command.gitlab_proc.gitlab.Uninit (Exec)  //
+    gitlab_Kill(parent); // kill child, ensure forward progress
+}
+
 // --- command.lib_ctype..ReadFieldMaybe
 bool command::lib_ctype_ReadFieldMaybe(command::lib_ctype &parent, algo::strptr field, algo::strptr strval) {
     command::FieldId field_id;
@@ -10548,6 +11183,28 @@ inline static void command::SizeCheck() {
     algo_assert(_offset_of(command::bash_proc,timeout) == 84);
     algo_assert(_offset_of(command::bash_proc,status) == 88);
     algo_assert(sizeof(command::bash_proc) == 96);
+    algo_assert(_offset_of(command::gitlab,in) == 0);
+    algo_assert(_offset_of(command::gitlab,issue) == 16);
+    algo_assert(_offset_of(command::gitlab,server) == 112);
+    algo_assert(_offset_of(command::gitlab,project) == 128);
+    algo_assert(_offset_of(command::gitlab,auth_token) == 144);
+    algo_assert(_offset_of(command::gitlab,mrlist) == 160);
+    algo_assert(_offset_of(command::gitlab,mergereq) == 161);
+    algo_assert(_offset_of(command::gitlab,ilist) == 162);
+    algo_assert(_offset_of(command::gitlab,istart) == 163);
+    algo_assert(_offset_of(command::gitlab,t) == 164);
+    algo_assert(_offset_of(command::gitlab,iadd) == 165);
+    algo_assert(_offset_of(command::gitlab,ic) == 166);
+    algo_assert(_offset_of(command::gitlab,iclose) == 167);
+    algo_assert(_offset_of(command::gitlab,iassignto) == 168);
+    algo_assert(_offset_of(command::gitlab,title) == 224);
+    algo_assert(_offset_of(command::gitlab,description) == 240);
+    algo_assert(_offset_of(command::gitlab,comment) == 256);
+    algo_assert(_offset_of(command::gitlab,gitdir) == 272);
+    algo_assert(_offset_of(command::gitlab,assignee) == 288);
+    algo_assert(_offset_of(command::gitlab,ulist) == 384);
+    algo_assert(_offset_of(command::gitlab,mraccept) == 392);
+    algo_assert(sizeof(command::gitlab) == 408);
     algo_assert(_offset_of(command::lib_ctype,in) == 0);
     algo_assert(sizeof(command::lib_ctype) == 16);
     algo_assert(_offset_of(command::lib_exec,dry_run) == 0);
diff --git a/cpp/gen/dev_gen.cpp b/cpp/gen/dev_gen.cpp
index e2d18ef68..ea70cdc9e 100644
--- a/cpp/gen/dev_gen.cpp
+++ b/cpp/gen/dev_gen.cpp
@@ -89,6 +89,7 @@ const char *dev_Target_target_atf_norm     = "atf_norm";
 const char *dev_Target_target_atf_nrun     = "atf_nrun";
 const char *dev_Target_target_atf_unit     = "atf_unit";
 const char *dev_Target_target_bash2html    = "bash2html";
+const char *dev_Target_target_gitlab       = "gitlab";
 const char *dev_Target_target_lib_ctype    = "lib_ctype";
 const char *dev_Target_target_lib_exec     = "lib_exec";
 const char *dev_Target_target_lib_git      = "lib_git";
@@ -445,6 +446,9 @@ const char* dev::value_ToCstr(const dev::FieldId& parent) {
         case dev_FieldId_author            : ret = "author";  break;
         case dev_FieldId_compver           : ret = "compver";  break;
         case dev_FieldId_package           : ret = "package";  break;
+        case dev_FieldId_gitlab_project    : ret = "gitlab_project";  break;
+        case dev_FieldId_url               : ret = "url";  break;
+        case dev_FieldId_gitlab_project_id : ret = "gitlab_project_id";  break;
         case dev_FieldId_htmlentity        : ret = "htmlentity";  break;
         case dev_FieldId_code              : ret = "code";  break;
         case dev_FieldId_include           : ret = "include";  break;
@@ -550,6 +554,9 @@ bool dev::value_SetStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
                 case LE_STR3('s','y','s'): {
                     value_SetEnum(parent,dev_FieldId_sys); ret = true; break;
                 }
+                case LE_STR3('u','r','l'): {
+                    value_SetEnum(parent,dev_FieldId_url); ret = true; break;
+                }
             }
             break;
         }
@@ -786,6 +793,24 @@ bool dev::value_SetStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
             }
             break;
         }
+        case 14: {
+            switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('g','i','t','l','a','b','_','p'): {
+                    if (memcmp(rhs.elems+8,"roject",6)==0) { value_SetEnum(parent,dev_FieldId_gitlab_project); ret = true; break; }
+                    break;
+                }
+            }
+            break;
+        }
+        case 17: {
+            switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('g','i','t','l','a','b','_','p'): {
+                    if (memcmp(rhs.elems+8,"roject_id",9)==0) { value_SetEnum(parent,dev_FieldId_gitlab_project_id); ret = true; break; }
+                    break;
+                }
+            }
+            break;
+        }
     }
     return ret;
 }
@@ -929,6 +954,55 @@ void dev::Gitinfo_Print(dev::Gitinfo & row, algo::cstring &str) {
     PrintAttrSpaceReset(str,"comment", temp);
 }
 
+// --- dev.GitlabProject..ReadFieldMaybe
+bool dev::GitlabProject_ReadFieldMaybe(dev::GitlabProject &parent, algo::strptr field, algo::strptr strval) {
+    dev::FieldId field_id;
+    (void)value_SetStrptrMaybe(field_id,field);
+    bool retval = true; // default is no error
+    switch(field_id) {
+        case dev_FieldId_gitlab_project: retval = algo::Smallstr50_ReadStrptrMaybe(parent.gitlab_project, strval); break;
+        case dev_FieldId_url: retval = algo::Smallstr200_ReadStrptrMaybe(parent.url, strval); break;
+        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
+        case dev_FieldId_gitlab_project_id: retval = u32_ReadStrptrMaybe(parent.gitlab_project_id, strval); break;
+        default: break;
+    }
+    if (!retval) {
+        algo_lib::AppendErrtext("attr",field);
+    }
+    return retval;
+}
+
+// --- dev.GitlabProject..ReadStrptrMaybe
+// Read fields of dev::GitlabProject from an ascii string.
+// The format of the string is an ssim Tuple
+bool dev::GitlabProject_ReadStrptrMaybe(dev::GitlabProject &parent, algo::strptr in_str) {
+    bool retval = true;
+    retval = algo::StripTypeTag(in_str, "dev.gitlab_project") || algo::StripTypeTag(in_str, "dev.GitlabProject");
+    ind_beg(algo::Attr_curs, attr, in_str) {
+        retval = retval && GitlabProject_ReadFieldMaybe(parent, attr.name, attr.value);
+    }ind_end;
+    return retval;
+}
+
+// --- dev.GitlabProject..Print
+// print string representation of dev::GitlabProject to string LHS, no header -- cprint:dev.GitlabProject.String
+void dev::GitlabProject_Print(dev::GitlabProject & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "dev.gitlab_project";
+
+    algo::Smallstr50_Print(row.gitlab_project, temp);
+    PrintAttrSpaceReset(str,"gitlab_project", temp);
+
+    algo::Smallstr200_Print(row.url, temp);
+    PrintAttrSpaceReset(str,"url", temp);
+
+    algo::Comment_Print(row.comment, temp);
+    PrintAttrSpaceReset(str,"comment", temp);
+
+    u32_Print(row.gitlab_project_id, temp);
+    PrintAttrSpaceReset(str,"gitlab_project_id", temp);
+}
+
 // --- dev.Htmlentity..ReadFieldMaybe
 bool dev::Htmlentity_ReadFieldMaybe(dev::Htmlentity &parent, algo::strptr field, algo::strptr strval) {
     dev::FieldId field_id;
diff --git a/cpp/gen/dmmeta_gen.cpp b/cpp/gen/dmmeta_gen.cpp
index 99a262199..2b2d9421a 100644
--- a/cpp/gen/dmmeta_gen.cpp
+++ b/cpp/gen/dmmeta_gen.cpp
@@ -60,6 +60,7 @@ const char *dmmeta_Ns_ns_bash2html    = "bash2html";
 const char *dmmeta_Ns_ns_command      = "command";
 const char *dmmeta_Ns_ns_dev          = "dev";
 const char *dmmeta_Ns_ns_dmmeta       = "dmmeta";
+const char *dmmeta_Ns_ns_gitlab       = "gitlab";
 const char *dmmeta_Ns_ns_ietf         = "ietf";
 const char *dmmeta_Ns_ns_lib_ctype    = "lib_ctype";
 const char *dmmeta_Ns_ns_lib_exec     = "lib_exec";
@@ -145,29 +146,30 @@ const char *dmmeta_Sorttype_sorttype_InsertionSort   = "InsertionSort";
 const char *dmmeta_Sorttype_sorttype_HeapSort        = "HeapSort";
 
 // compile-time string constants for dmmeta.Ssimfile.ssimfile
-const char *dmmeta_Ssimfile_ssimfile_amcdb_bltin       = "amcdb.bltin";
-const char *dmmeta_Ssimfile_ssimfile_amcdb_curs        = "amcdb.curs";
-const char *dmmeta_Ssimfile_ssimfile_amcdb_gen         = "amcdb.gen";
-const char *dmmeta_Ssimfile_ssimfile_amcdb_tclass      = "amcdb.tclass";
-const char *dmmeta_Ssimfile_ssimfile_amcdb_tcursor     = "amcdb.tcursor";
-const char *dmmeta_Ssimfile_ssimfile_amcdb_tfunc       = "amcdb.tfunc";
-const char *dmmeta_Ssimfile_ssimfile_atfdb_amctest     = "atfdb.amctest";
-const char *dmmeta_Ssimfile_ssimfile_atfdb_normcheck   = "atfdb.normcheck";
-const char *dmmeta_Ssimfile_ssimfile_atfdb_unittest    = "atfdb.unittest";
-const char *dmmeta_Ssimfile_ssimfile_dev_arch          = "dev.arch";
-const char *dmmeta_Ssimfile_ssimfile_dev_badline       = "dev.badline";
-const char *dmmeta_Ssimfile_ssimfile_dev_builddir      = "dev.builddir";
-const char *dmmeta_Ssimfile_ssimfile_dev_cfg           = "dev.cfg";
-const char *dmmeta_Ssimfile_ssimfile_dev_compiler      = "dev.compiler";
-const char *dmmeta_Ssimfile_ssimfile_dev_gitfile       = "dev.gitfile";
-const char *dmmeta_Ssimfile_ssimfile_dev_gitinfo       = "dev.gitinfo";
-const char *dmmeta_Ssimfile_ssimfile_dev_htmlentity    = "dev.htmlentity";
-const char *dmmeta_Ssimfile_ssimfile_dev_license       = "dev.license";
-const char *dmmeta_Ssimfile_ssimfile_dev_linelim       = "dev.linelim";
-const char *dmmeta_Ssimfile_ssimfile_dev_noindent      = "dev.noindent";
-const char *dmmeta_Ssimfile_ssimfile_dev_opt_type      = "dev.opt_type";
-const char *dmmeta_Ssimfile_ssimfile_dev_readme        = "dev.readme";
-const char *dmmeta_Ssimfile_ssimfile_dev_sandbox       = "dev.sandbox";
+const char *dmmeta_Ssimfile_ssimfile_amcdb_bltin          = "amcdb.bltin";
+const char *dmmeta_Ssimfile_ssimfile_amcdb_curs           = "amcdb.curs";
+const char *dmmeta_Ssimfile_ssimfile_amcdb_gen            = "amcdb.gen";
+const char *dmmeta_Ssimfile_ssimfile_amcdb_tclass         = "amcdb.tclass";
+const char *dmmeta_Ssimfile_ssimfile_amcdb_tcursor        = "amcdb.tcursor";
+const char *dmmeta_Ssimfile_ssimfile_amcdb_tfunc          = "amcdb.tfunc";
+const char *dmmeta_Ssimfile_ssimfile_atfdb_amctest        = "atfdb.amctest";
+const char *dmmeta_Ssimfile_ssimfile_atfdb_normcheck      = "atfdb.normcheck";
+const char *dmmeta_Ssimfile_ssimfile_atfdb_unittest       = "atfdb.unittest";
+const char *dmmeta_Ssimfile_ssimfile_dev_arch             = "dev.arch";
+const char *dmmeta_Ssimfile_ssimfile_dev_badline          = "dev.badline";
+const char *dmmeta_Ssimfile_ssimfile_dev_builddir         = "dev.builddir";
+const char *dmmeta_Ssimfile_ssimfile_dev_cfg              = "dev.cfg";
+const char *dmmeta_Ssimfile_ssimfile_dev_compiler         = "dev.compiler";
+const char *dmmeta_Ssimfile_ssimfile_dev_gitfile          = "dev.gitfile";
+const char *dmmeta_Ssimfile_ssimfile_dev_gitinfo          = "dev.gitinfo";
+const char *dmmeta_Ssimfile_ssimfile_dev_gitlab_project   = "dev.gitlab_project";
+const char *dmmeta_Ssimfile_ssimfile_dev_htmlentity       = "dev.htmlentity";
+const char *dmmeta_Ssimfile_ssimfile_dev_license          = "dev.license";
+const char *dmmeta_Ssimfile_ssimfile_dev_linelim          = "dev.linelim";
+const char *dmmeta_Ssimfile_ssimfile_dev_noindent         = "dev.noindent";
+const char *dmmeta_Ssimfile_ssimfile_dev_opt_type         = "dev.opt_type";
+const char *dmmeta_Ssimfile_ssimfile_dev_readme           = "dev.readme";
+const char *dmmeta_Ssimfile_ssimfile_dev_sandbox          = "dev.sandbox";
 
 const char *dmmeta_Ssimfile_ssimfile_dev_scriptfile        = "dev.scriptfile";
 const char *dmmeta_Ssimfile_ssimfile_dev_srcfile           = "dev.srcfile";
diff --git a/cpp/gen/gitlab_gen.cpp b/cpp/gen/gitlab_gen.cpp
new file mode 100644
index 000000000..7b415bf7f
--- /dev/null
+++ b/cpp/gen/gitlab_gen.cpp
@@ -0,0 +1,3249 @@
+//
+// cpp/gen/gitlab_gen.cpp
+// Generated by AMC
+//
+// (C) AlgoEngineering LLC 2008-2013
+// (C) NYSE | Intercontinental Exchange 2013-2016
+//
+
+
+#include "include/algo.h"  // hard-coded include
+#include "include/gen/gitlab_gen.h"
+#include "include/gen/gitlab_gen.inl.h"
+#include "include/gen/command_gen.h"
+#include "include/gen/command_gen.inl.h"
+#include "include/gen/algo_gen.h"
+#include "include/gen/algo_gen.inl.h"
+#include "include/gen/lib_json_gen.h"
+#include "include/gen/lib_json_gen.inl.h"
+#include "include/gen/dev_gen.h"
+#include "include/gen/dev_gen.inl.h"
+#include "include/gen/lib_prot_gen.h"
+#include "include/gen/lib_prot_gen.inl.h"
+#include "include/gen/algo_lib_gen.h"
+#include "include/gen/algo_lib_gen.inl.h"
+//#pragma endinclude
+
+// Instantiate all libraries linked into this executable,
+// in dependency order
+lib_json::FDb   lib_json::_db;    // dependency found via dev.targdep
+algo_lib::FDb   algo_lib::_db;    // dependency found via dev.targdep
+gitlab::FDb     gitlab::_db;      // dependency found via dev.targdep
+
+namespace gitlab {
+const char *gitlab_help =
+"gitlab: Gitlab command line interface\n"
+"Usage: gitlab [options]\n"
+"    -in           string  Input directory or filename, - for stdin. default: \"data\"\n"
+"    [issue]       string  Issue id (e.g. myproject.33, 33 or %)\n"
+"    -server       string  (config) GitLab server host. default: \"gitlab.lon.algo\"\n"
+"    -project      string  (config) Project to use. default: \"myproject\"\n"
+"    -auth_token   string  (config) GitLab auth token\n"
+"    -mrlist               (action) Show list of merge requests. default: false\n"
+"    -mergereq             (action) Push current branch to origin, create merge request. default: false\n"
+"    -ilist                (action) Show list of issues matching regx. default: false\n"
+"    -istart               (action) Start working on the specified issue. default: false\n"
+"    -t                    Tree view: expand issue description. default: false\n"
+"    -iadd                 (action) Add new issue. default: false\n"
+"    -ic                   (action) Add issue comment. default: false\n"
+"    -iclose               (action) Close issue. default: false\n"
+"    -iassignto    string  (action) Assign issue to user\n"
+"    -title        string  (with -iadd), skip editor and use argument as title\n"
+"    -description  string  (with -iadd -title), use argument as description\n"
+"    -comment      string  (with -ic), skip editor and use argument as comment\n"
+"    -gitdir       string  (setup) Change directory of dit repository\n"
+"    -assignee     string  Filter assignee. Default=current user only\n"
+"    -ulist                (action) List users. default: false\n"
+"    -mraccept     string  (action) Accept merge request\n"
+"    -verbose              Enable verbose mode\n"
+"    -debug                Enable debug mode\n"
+"    -version              Show version information\n"
+"    -sig                  Print SHA1 signatures for dispatches\n"
+"    -help                 Print this screen and exit\n"
+;
+
+
+const char *gitlab_syntax =
+"-in:string=\"data\"\n"
+" [issue]:string=\n"
+" -server:string=\"gitlab.lon.algo\"\n"
+" -project:string=\"myproject\"\n"
+" -auth_token:string=\n"
+" -mrlist:flag\n"
+" -mergereq:flag\n"
+" -ilist:flag\n"
+" -istart:flag\n"
+" -t:flag\n"
+" -iadd:flag\n"
+" -ic:flag\n"
+" -iclose:flag\n"
+" -iassignto:string=\n"
+" -title:string=\n"
+" -description:string=\n"
+" -comment:string=\n"
+" -gitdir:string=\n"
+" -assignee:string=\n"
+" -ulist:flag\n"
+" -mraccept:string=\n"
+;
+} // namespace gitlab
+namespace gitlab {
+    // Load statically available data into tables, register tables and database.
+    static void          InitReflection();
+    static bool          project_InputMaybe(dev::GitlabProject &elem) __attribute__((nothrow));
+    // find trace by row id (used to implement reflection)
+    static algo::ImrowPtr trace_RowidFind(int t) __attribute__((nothrow));
+    // Function return 1
+    static i32           trace_N() __attribute__((__warn_unused_result__, nothrow, pure));
+    static void          SizeCheck();
+} // end namespace gitlab
+
+// --- gitlab.trace..Print
+// print string representation of gitlab::trace to string LHS, no header -- cprint:gitlab.trace.String
+void gitlab::trace_Print(gitlab::trace & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.trace";
+    (void)row;//only to avoid -Wunused-parameter
+}
+
+// --- gitlab.FDb._db.MainArgs
+// Main function
+void gitlab::MainArgs(int argc, char **argv) {
+    Argtuple argtuple;
+    Argtuple_ReadArgv(argtuple, argc,argv,gitlab_syntax, gitlab_help);
+    vrfy(gitlab_ReadTupleMaybe(gitlab::_db.cmdline, argtuple.tuple),"where:read_cmdline");
+    vrfy(gitlab::LoadTuplesMaybe(gitlab::_db.cmdline.in)
+    ,tempstr()<<"where:load_input  "<<algo_lib::DetachBadTags());
+    gitlab::Main(); // call through to user-defined main
+}
+
+// --- gitlab.FDb._db.MainLoop
+// Main loop.
+void gitlab::MainLoop() {
+    algo::SchedTime time(algo::get_cycles());
+    algo_lib::_db.clock          = time;
+    do {
+        algo_lib::_db.next_loop.value = algo_lib::_db.limit;
+        algo_lib::Step(); // dependent namespace specified via (dev.targdep)
+    } while (algo_lib::_db.next_loop < algo_lib::_db.limit);
+}
+
+// --- gitlab.FDb._db.Step
+// Main step
+void gitlab::Step() {
+}
+
+// --- gitlab.FDb._db.InitReflection
+// Load statically available data into tables, register tables and database.
+static void gitlab::InitReflection() {
+    algo_lib::imdb_InsertMaybe(algo::Imdb("gitlab", gitlab::InsertStrptrMaybe, NULL, gitlab::MainLoop, NULL, algo::Comment()));
+
+    algo::Imtable t_trace;
+    t_trace.imtable         = "gitlab.trace";
+    t_trace.ssimfile        = "";
+    t_trace.size            = sizeof(gitlab::trace);
+    t_trace.comment.value   = "";
+    t_trace.c_RowidFind     = trace_RowidFind;
+    t_trace.NItems          = trace_N;
+    t_trace.Print           = (algo::ImrowPrintFcn)gitlab::trace_Print;
+    algo_lib::imtable_InsertMaybe(t_trace);
+
+
+    // -- load signatures of existing dispatches --
+    algo_lib::InsertStrptrMaybe("dmmeta.Dispsigcheck  dispsig:'gitlab.Input'  signature:'cd941ad82205e82576bcadd62546d69d72cdbca6'");
+}
+
+// --- gitlab.FDb._db.StaticCheck
+void gitlab::StaticCheck() {
+    algo_assert(_offset_of(gitlab::FieldId, value) + sizeof(((gitlab::FieldId*)0)->value) == sizeof(gitlab::FieldId));
+}
+
+// --- gitlab.FDb._db.InsertStrptrMaybe
+// Parse strptr into known type and add to database.
+// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
+bool gitlab::InsertStrptrMaybe(algo::strptr str) {
+    bool retval = true;
+    gitlab::TableId table_id(-1);
+    value_SetStrptrMaybe(table_id, algo::GetTypeTag(str));
+    switch (value_GetEnum(table_id)) {
+        case gitlab_TableId_dev_GitlabProject: { // finput:gitlab.FDb.project
+            dev::GitlabProject elem;
+            retval = dev::GitlabProject_ReadStrptrMaybe(elem, str);
+            retval = retval && project_InputMaybe(elem);
+            break;
+        }
+        default:
+        retval = algo_lib::InsertStrptrMaybe(str);
+        break;
+    } //switch
+    if (!retval) {
+        algo_lib::NoteInsertErr(str); // increment error counter
+    }
+    return retval;
+}
+
+// --- gitlab.FDb._db.LoadTuplesMaybe
+// Load all finputs from given directory.
+bool gitlab::LoadTuplesMaybe(algo::strptr root) {
+    bool retval = true;
+    static const char *ssimfiles[] = {
+        "dev.gitlab_project"
+        , NULL};
+        retval = algo_lib::DoLoadTuples(root, gitlab::InsertStrptrMaybe, ssimfiles, true);
+        return retval;
+}
+
+// --- gitlab.FDb._db.LoadSsimfileMaybe
+// Load specified ssimfile.
+bool gitlab::LoadSsimfileMaybe(algo::strptr fname) {
+    bool retval = true;
+    if (FileQ(fname)) {
+        retval = algo_lib::LoadTuplesFile(fname, gitlab::InsertStrptrMaybe, true);
+    }
+    return retval;
+}
+
+// --- gitlab.FDb._db.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::_db_XrefMaybe() {
+    bool retval = true;
+    return retval;
+}
+
+// --- gitlab.FDb.project.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FProject& gitlab::project_Alloc() {
+    gitlab::FProject* row = project_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.project  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.project.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FProject* gitlab::project_AllocMaybe() {
+    gitlab::FProject *row = (gitlab::FProject*)project_AllocMem();
+    if (row) {
+        new (row) gitlab::FProject; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.project.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FProject* gitlab::project_InsertMaybe(const dev::GitlabProject &value) {
+    gitlab::FProject *row = &project_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    project_CopyIn(*row,const_cast<dev::GitlabProject&>(value));
+    bool ok = project_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        project_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.project.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::project_AllocMem() {
+    u64 new_nelems     = _db.project_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FProject*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.project_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FProject*)algo_lib::malloc_AllocMem(sizeof(gitlab::FProject) * (u64(1)<<bsr));
+            _db.project_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.project_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.project.RemoveAll
+// Remove all elements from Lary
+void gitlab::project_RemoveAll() {
+    for (u64 n = _db.project_n; n>0; ) {
+        n--;
+        project_qFind(u64(n)).~FProject(); // destroy last element
+        _db.project_n = n;
+    }
+}
+
+// --- gitlab.FDb.project.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::project_RemoveLast() {
+    u64 n = _db.project_n;
+    if (n > 0) {
+        n -= 1;
+        project_qFind(u64(n)).~FProject();
+        _db.project_n = n;
+    }
+}
+
+// --- gitlab.FDb.project.InputMaybe
+static bool gitlab::project_InputMaybe(dev::GitlabProject &elem) {
+    bool retval = true;
+    retval = project_InsertMaybe(elem);
+    return retval;
+}
+
+// --- gitlab.FDb.project.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::project_XrefMaybe(gitlab::FProject &row) {
+    bool retval = true;
+    (void)row;
+    // insert project into index ind_project
+    if (true) { // user-defined insert condition
+        bool success = ind_project_InsertMaybe(row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_project"; // check for duplicate key
+            return false;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_project.Find
+// Find row by key. Return NULL if not found.
+gitlab::FProject* gitlab::ind_project_Find(const algo::strptr& key) {
+    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_project_buckets_n - 1);
+    gitlab::FProject* *e = &_db.ind_project_buckets_elems[index];
+    gitlab::FProject* ret=NULL;
+    do {
+        ret       = *e;
+        bool done = !ret || (*ret).gitlab_project == key;
+        if (done) break;
+        e         = &ret->ind_project_next;
+    } while (true);
+    return ret;
+}
+
+// --- gitlab.FDb.ind_project.FindX
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FProject& gitlab::ind_project_FindX(const algo::strptr& key) {
+    gitlab::FProject* ret = ind_project_Find(key);
+    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_project  key:'"<<key<<"'  comment:'key not found'");
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_project.GetOrCreate
+// Find row by key. If not found, create and x-reference a new row with with this key.
+gitlab::FProject& gitlab::ind_project_GetOrCreate(const algo::strptr& key) {
+    gitlab::FProject* ret = ind_project_Find(key);
+    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
+        ret         = &project_Alloc();
+        (*ret).gitlab_project = key;
+        bool good = project_XrefMaybe(*ret);
+        if (!good) {
+            project_RemoveLast(); // delete offending row, any existing xrefs are cleared
+            ret = NULL;
+        }
+    }
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_project.InsertMaybe
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool gitlab::ind_project_InsertMaybe(gitlab::FProject& row) {
+    ind_project_Reserve(1);
+    bool retval = true; // if already in hash, InsertMaybe returns true
+    if (LIKELY(row.ind_project_next == (gitlab::FProject*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.gitlab_project) & (_db.ind_project_buckets_n - 1);
+        gitlab::FProject* *prev = &_db.ind_project_buckets_elems[index];
+        do {
+            gitlab::FProject* ret = *prev;
+            if (!ret) { // exit condition 1: reached the end of the list
+                break;
+            }
+            if ((*ret).gitlab_project == row.gitlab_project) { // exit condition 2: found matching key
+                retval = false;
+                break;
+            }
+            prev = &ret->ind_project_next;
+        } while (true);
+        if (retval) {
+            row.ind_project_next = *prev;
+            _db.ind_project_n++;
+            *prev = &row;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_project.Remove
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void gitlab::ind_project_Remove(gitlab::FProject& row) {
+    if (LIKELY(row.ind_project_next != (gitlab::FProject*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.gitlab_project) & (_db.ind_project_buckets_n - 1);
+        gitlab::FProject* *prev = &_db.ind_project_buckets_elems[index]; // addr of pointer to current element
+        while (gitlab::FProject *next = *prev) {                          // scan the collision chain for our element
+            if (next == &row) {        // found it?
+                *prev = next->ind_project_next; // unlink (singly linked list)
+                _db.ind_project_n--;
+                row.ind_project_next = (gitlab::FProject*)-1;// not-in-hash
+                break;
+            }
+            prev = &next->ind_project_next;
+        }
+    }
+}
+
+// --- gitlab.FDb.ind_project.Reserve
+// Reserve enough room in the hash for N more elements. Return success code.
+void gitlab::ind_project_Reserve(int n) {
+    u32 old_nbuckets = _db.ind_project_buckets_n;
+    u32 new_nelems   = _db.ind_project_n + n;
+    // # of elements has to be roughly equal to the number of buckets
+    if (new_nelems > old_nbuckets) {
+        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
+        u32 old_size = old_nbuckets * sizeof(gitlab::FProject*);
+        u32 new_size = new_nbuckets * sizeof(gitlab::FProject*);
+        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
+        // means new memory will have to be allocated anyway
+        gitlab::FProject* *new_buckets = (gitlab::FProject**)algo_lib::malloc_AllocMem(new_size);
+        if (UNLIKELY(!new_buckets)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_project");
+        }
+        memset(new_buckets, 0, new_size); // clear pointers
+        // rehash all entries
+        for (int i = 0; i < _db.ind_project_buckets_n; i++) {
+            gitlab::FProject* elem = _db.ind_project_buckets_elems[i];
+            while (elem) {
+                gitlab::FProject &row        = *elem;
+                gitlab::FProject* next       = row.ind_project_next;
+                u32 index          = algo::Smallstr50_Hash(0, row.gitlab_project) & (new_nbuckets-1);
+                row.ind_project_next     = new_buckets[index];
+                new_buckets[index] = &row;
+                elem               = next;
+            }
+        }
+        // free old array
+        algo_lib::malloc_FreeMem(_db.ind_project_buckets_elems, old_size);
+        _db.ind_project_buckets_elems = new_buckets;
+        _db.ind_project_buckets_n = new_nbuckets;
+    }
+}
+
+// --- gitlab.FDb.ind_issue.Find
+// Find row by key. Return NULL if not found.
+gitlab::FIssue* gitlab::ind_issue_Find(const algo::strptr& key) {
+    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_issue_buckets_n - 1);
+    gitlab::FIssue* *e = &_db.ind_issue_buckets_elems[index];
+    gitlab::FIssue* ret=NULL;
+    do {
+        ret       = *e;
+        bool done = !ret || (*ret).issue == key;
+        if (done) break;
+        e         = &ret->ind_issue_next;
+    } while (true);
+    return ret;
+}
+
+// --- gitlab.FDb.ind_issue.FindX
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FIssue& gitlab::ind_issue_FindX(const algo::strptr& key) {
+    gitlab::FIssue* ret = ind_issue_Find(key);
+    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_issue  key:'"<<key<<"'  comment:'key not found'");
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_issue.InsertMaybe
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool gitlab::ind_issue_InsertMaybe(gitlab::FIssue& row) {
+    ind_issue_Reserve(1);
+    bool retval = true; // if already in hash, InsertMaybe returns true
+    if (LIKELY(row.ind_issue_next == (gitlab::FIssue*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.issue) & (_db.ind_issue_buckets_n - 1);
+        gitlab::FIssue* *prev = &_db.ind_issue_buckets_elems[index];
+        do {
+            gitlab::FIssue* ret = *prev;
+            if (!ret) { // exit condition 1: reached the end of the list
+                break;
+            }
+            if ((*ret).issue == row.issue) { // exit condition 2: found matching key
+                retval = false;
+                break;
+            }
+            prev = &ret->ind_issue_next;
+        } while (true);
+        if (retval) {
+            row.ind_issue_next = *prev;
+            _db.ind_issue_n++;
+            *prev = &row;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_issue.Remove
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void gitlab::ind_issue_Remove(gitlab::FIssue& row) {
+    if (LIKELY(row.ind_issue_next != (gitlab::FIssue*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.issue) & (_db.ind_issue_buckets_n - 1);
+        gitlab::FIssue* *prev = &_db.ind_issue_buckets_elems[index]; // addr of pointer to current element
+        while (gitlab::FIssue *next = *prev) {                          // scan the collision chain for our element
+            if (next == &row) {        // found it?
+                *prev = next->ind_issue_next; // unlink (singly linked list)
+                _db.ind_issue_n--;
+                row.ind_issue_next = (gitlab::FIssue*)-1;// not-in-hash
+                break;
+            }
+            prev = &next->ind_issue_next;
+        }
+    }
+}
+
+// --- gitlab.FDb.ind_issue.Reserve
+// Reserve enough room in the hash for N more elements. Return success code.
+void gitlab::ind_issue_Reserve(int n) {
+    u32 old_nbuckets = _db.ind_issue_buckets_n;
+    u32 new_nelems   = _db.ind_issue_n + n;
+    // # of elements has to be roughly equal to the number of buckets
+    if (new_nelems > old_nbuckets) {
+        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
+        u32 old_size = old_nbuckets * sizeof(gitlab::FIssue*);
+        u32 new_size = new_nbuckets * sizeof(gitlab::FIssue*);
+        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
+        // means new memory will have to be allocated anyway
+        gitlab::FIssue* *new_buckets = (gitlab::FIssue**)algo_lib::malloc_AllocMem(new_size);
+        if (UNLIKELY(!new_buckets)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_issue");
+        }
+        memset(new_buckets, 0, new_size); // clear pointers
+        // rehash all entries
+        for (int i = 0; i < _db.ind_issue_buckets_n; i++) {
+            gitlab::FIssue* elem = _db.ind_issue_buckets_elems[i];
+            while (elem) {
+                gitlab::FIssue &row        = *elem;
+                gitlab::FIssue* next       = row.ind_issue_next;
+                u32 index          = algo::Smallstr50_Hash(0, row.issue) & (new_nbuckets-1);
+                row.ind_issue_next     = new_buckets[index];
+                new_buckets[index] = &row;
+                elem               = next;
+            }
+        }
+        // free old array
+        algo_lib::malloc_FreeMem(_db.ind_issue_buckets_elems, old_size);
+        _db.ind_issue_buckets_elems = new_buckets;
+        _db.ind_issue_buckets_n = new_nbuckets;
+    }
+}
+
+// --- gitlab.FDb.issue.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FIssue& gitlab::issue_Alloc() {
+    gitlab::FIssue* row = issue_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.issue  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.issue.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FIssue* gitlab::issue_AllocMaybe() {
+    gitlab::FIssue *row = (gitlab::FIssue*)issue_AllocMem();
+    if (row) {
+        new (row) gitlab::FIssue; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.issue.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FIssue* gitlab::issue_InsertMaybe(const gitlab::Issue &value) {
+    gitlab::FIssue *row = &issue_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    issue_CopyIn(*row,const_cast<gitlab::Issue&>(value));
+    bool ok = issue_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        issue_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.issue.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::issue_AllocMem() {
+    u64 new_nelems     = _db.issue_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FIssue*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.issue_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FIssue*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssue) * (u64(1)<<bsr));
+            _db.issue_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.issue_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.issue.RemoveAll
+// Remove all elements from Lary
+void gitlab::issue_RemoveAll() {
+    for (u64 n = _db.issue_n; n>0; ) {
+        n--;
+        issue_qFind(u64(n)).~FIssue(); // destroy last element
+        _db.issue_n = n;
+    }
+}
+
+// --- gitlab.FDb.issue.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::issue_RemoveLast() {
+    u64 n = _db.issue_n;
+    if (n > 0) {
+        n -= 1;
+        issue_qFind(u64(n)).~FIssue();
+        _db.issue_n = n;
+    }
+}
+
+// --- gitlab.FDb.issue.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::issue_XrefMaybe(gitlab::FIssue &row) {
+    bool retval = true;
+    (void)row;
+    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
+    if (UNLIKELY(!p_project)) {
+        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_project" << Keyval("key", project_Get(row));
+        return false;
+    }
+    // issue: save pointer to project
+    if (true) { // user-defined insert condition
+        row.p_project = p_project;
+    }
+    // insert issue into index c_issue
+    if (true) { // user-defined insert condition
+        c_issue_Insert(*p_project, row);
+    }
+    // insert issue into index ind_issue
+    if (true) { // user-defined insert condition
+        bool success = ind_issue_InsertMaybe(row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_issue"; // check for duplicate key
+            return false;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.issue_note.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FIssueNote& gitlab::issue_note_Alloc() {
+    gitlab::FIssueNote* row = issue_note_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.issue_note  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.issue_note.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FIssueNote* gitlab::issue_note_AllocMaybe() {
+    gitlab::FIssueNote *row = (gitlab::FIssueNote*)issue_note_AllocMem();
+    if (row) {
+        new (row) gitlab::FIssueNote; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.issue_note.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FIssueNote* gitlab::issue_note_InsertMaybe(const gitlab::IssueNote &value) {
+    gitlab::FIssueNote *row = &issue_note_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    issue_note_CopyIn(*row,const_cast<gitlab::IssueNote&>(value));
+    bool ok = issue_note_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        issue_note_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.issue_note.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::issue_note_AllocMem() {
+    u64 new_nelems     = _db.issue_note_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FIssueNote*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.issue_note_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FIssueNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueNote) * (u64(1)<<bsr));
+            _db.issue_note_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.issue_note_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.issue_note.RemoveAll
+// Remove all elements from Lary
+void gitlab::issue_note_RemoveAll() {
+    for (u64 n = _db.issue_note_n; n>0; ) {
+        n--;
+        issue_note_qFind(u64(n)).~FIssueNote(); // destroy last element
+        _db.issue_note_n = n;
+    }
+}
+
+// --- gitlab.FDb.issue_note.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::issue_note_RemoveLast() {
+    u64 n = _db.issue_note_n;
+    if (n > 0) {
+        n -= 1;
+        issue_note_qFind(u64(n)).~FIssueNote();
+        _db.issue_note_n = n;
+    }
+}
+
+// --- gitlab.FDb.issue_note.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::issue_note_XrefMaybe(gitlab::FIssueNote &row) {
+    bool retval = true;
+    (void)row;
+    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(issue_Get(row));
+    if (UNLIKELY(!p_issue)) {
+        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_issue" << Keyval("key", issue_Get(row));
+        return false;
+    }
+    // issue_note: save pointer to issue
+    if (true) { // user-defined insert condition
+        row.p_issue = p_issue;
+    }
+    // insert issue_note into index ind_issue_note
+    if (true) { // user-defined insert condition
+        bool success = ind_issue_note_InsertMaybe(row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_issue_note"; // check for duplicate key
+            return false;
+        }
+    }
+    // insert issue_note into index c_issue_note
+    if (true) { // user-defined insert condition
+        c_issue_note_Insert(*p_issue, row);
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_issue_note.Find
+// Find row by key. Return NULL if not found.
+gitlab::FIssueNote* gitlab::ind_issue_note_Find(const algo::strptr& key) {
+    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_issue_note_buckets_n - 1);
+    gitlab::FIssueNote* *e = &_db.ind_issue_note_buckets_elems[index];
+    gitlab::FIssueNote* ret=NULL;
+    do {
+        ret       = *e;
+        bool done = !ret || (*ret).issue_note == key;
+        if (done) break;
+        e         = &ret->ind_issue_note_next;
+    } while (true);
+    return ret;
+}
+
+// --- gitlab.FDb.ind_issue_note.FindX
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FIssueNote& gitlab::ind_issue_note_FindX(const algo::strptr& key) {
+    gitlab::FIssueNote* ret = ind_issue_note_Find(key);
+    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_issue_note  key:'"<<key<<"'  comment:'key not found'");
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_issue_note.InsertMaybe
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool gitlab::ind_issue_note_InsertMaybe(gitlab::FIssueNote& row) {
+    ind_issue_note_Reserve(1);
+    bool retval = true; // if already in hash, InsertMaybe returns true
+    if (LIKELY(row.ind_issue_note_next == (gitlab::FIssueNote*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.issue_note) & (_db.ind_issue_note_buckets_n - 1);
+        gitlab::FIssueNote* *prev = &_db.ind_issue_note_buckets_elems[index];
+        do {
+            gitlab::FIssueNote* ret = *prev;
+            if (!ret) { // exit condition 1: reached the end of the list
+                break;
+            }
+            if ((*ret).issue_note == row.issue_note) { // exit condition 2: found matching key
+                retval = false;
+                break;
+            }
+            prev = &ret->ind_issue_note_next;
+        } while (true);
+        if (retval) {
+            row.ind_issue_note_next = *prev;
+            _db.ind_issue_note_n++;
+            *prev = &row;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_issue_note.Remove
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void gitlab::ind_issue_note_Remove(gitlab::FIssueNote& row) {
+    if (LIKELY(row.ind_issue_note_next != (gitlab::FIssueNote*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.issue_note) & (_db.ind_issue_note_buckets_n - 1);
+        gitlab::FIssueNote* *prev = &_db.ind_issue_note_buckets_elems[index]; // addr of pointer to current element
+        while (gitlab::FIssueNote *next = *prev) {                          // scan the collision chain for our element
+            if (next == &row) {        // found it?
+                *prev = next->ind_issue_note_next; // unlink (singly linked list)
+                _db.ind_issue_note_n--;
+                row.ind_issue_note_next = (gitlab::FIssueNote*)-1;// not-in-hash
+                break;
+            }
+            prev = &next->ind_issue_note_next;
+        }
+    }
+}
+
+// --- gitlab.FDb.ind_issue_note.Reserve
+// Reserve enough room in the hash for N more elements. Return success code.
+void gitlab::ind_issue_note_Reserve(int n) {
+    u32 old_nbuckets = _db.ind_issue_note_buckets_n;
+    u32 new_nelems   = _db.ind_issue_note_n + n;
+    // # of elements has to be roughly equal to the number of buckets
+    if (new_nelems > old_nbuckets) {
+        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
+        u32 old_size = old_nbuckets * sizeof(gitlab::FIssueNote*);
+        u32 new_size = new_nbuckets * sizeof(gitlab::FIssueNote*);
+        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
+        // means new memory will have to be allocated anyway
+        gitlab::FIssueNote* *new_buckets = (gitlab::FIssueNote**)algo_lib::malloc_AllocMem(new_size);
+        if (UNLIKELY(!new_buckets)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_issue_note");
+        }
+        memset(new_buckets, 0, new_size); // clear pointers
+        // rehash all entries
+        for (int i = 0; i < _db.ind_issue_note_buckets_n; i++) {
+            gitlab::FIssueNote* elem = _db.ind_issue_note_buckets_elems[i];
+            while (elem) {
+                gitlab::FIssueNote &row        = *elem;
+                gitlab::FIssueNote* next       = row.ind_issue_note_next;
+                u32 index          = algo::Smallstr50_Hash(0, row.issue_note) & (new_nbuckets-1);
+                row.ind_issue_note_next     = new_buckets[index];
+                new_buckets[index] = &row;
+                elem               = next;
+            }
+        }
+        // free old array
+        algo_lib::malloc_FreeMem(_db.ind_issue_note_buckets_elems, old_size);
+        _db.ind_issue_note_buckets_elems = new_buckets;
+        _db.ind_issue_note_buckets_n = new_nbuckets;
+    }
+}
+
+// --- gitlab.FDb.issue_description.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FIssueDescription& gitlab::issue_description_Alloc() {
+    gitlab::FIssueDescription* row = issue_description_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.issue_description  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.issue_description.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FIssueDescription* gitlab::issue_description_AllocMaybe() {
+    gitlab::FIssueDescription *row = (gitlab::FIssueDescription*)issue_description_AllocMem();
+    if (row) {
+        new (row) gitlab::FIssueDescription; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.issue_description.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FIssueDescription* gitlab::issue_description_InsertMaybe(const gitlab::IssueDescription &value) {
+    gitlab::FIssueDescription *row = &issue_description_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    issue_description_CopyIn(*row,const_cast<gitlab::IssueDescription&>(value));
+    bool ok = issue_description_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        issue_description_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.issue_description.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::issue_description_AllocMem() {
+    u64 new_nelems     = _db.issue_description_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FIssueDescription*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.issue_description_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FIssueDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueDescription) * (u64(1)<<bsr));
+            _db.issue_description_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.issue_description_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.issue_description.RemoveAll
+// Remove all elements from Lary
+void gitlab::issue_description_RemoveAll() {
+    for (u64 n = _db.issue_description_n; n>0; ) {
+        n--;
+        issue_description_qFind(u64(n)).~FIssueDescription(); // destroy last element
+        _db.issue_description_n = n;
+    }
+}
+
+// --- gitlab.FDb.issue_description.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::issue_description_RemoveLast() {
+    u64 n = _db.issue_description_n;
+    if (n > 0) {
+        n -= 1;
+        issue_description_qFind(u64(n)).~FIssueDescription();
+        _db.issue_description_n = n;
+    }
+}
+
+// --- gitlab.FDb.issue_description.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::issue_description_XrefMaybe(gitlab::FIssueDescription &row) {
+    bool retval = true;
+    (void)row;
+    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(row.issue);
+    if (UNLIKELY(!p_issue)) {
+        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_issue" << Keyval("key", row.issue);
+        return false;
+    }
+    // issue_description: save pointer to issue
+    if (true) { // user-defined insert condition
+        row.p_issue = p_issue;
+    }
+    // insert issue_description into index c_issue_description
+    if (true) { // user-defined insert condition
+        bool success = c_issue_description_InsertMaybe(*p_issue, row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FIssue.c_issue_description"; // check for duplicate key
+            return false;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_mr.Find
+// Find row by key. Return NULL if not found.
+gitlab::FMr* gitlab::ind_mr_Find(const algo::strptr& key) {
+    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_mr_buckets_n - 1);
+    gitlab::FMr* *e = &_db.ind_mr_buckets_elems[index];
+    gitlab::FMr* ret=NULL;
+    do {
+        ret       = *e;
+        bool done = !ret || (*ret).mr == key;
+        if (done) break;
+        e         = &ret->ind_mr_next;
+    } while (true);
+    return ret;
+}
+
+// --- gitlab.FDb.ind_mr.FindX
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FMr& gitlab::ind_mr_FindX(const algo::strptr& key) {
+    gitlab::FMr* ret = ind_mr_Find(key);
+    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_mr  key:'"<<key<<"'  comment:'key not found'");
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_mr.InsertMaybe
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool gitlab::ind_mr_InsertMaybe(gitlab::FMr& row) {
+    ind_mr_Reserve(1);
+    bool retval = true; // if already in hash, InsertMaybe returns true
+    if (LIKELY(row.ind_mr_next == (gitlab::FMr*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.mr) & (_db.ind_mr_buckets_n - 1);
+        gitlab::FMr* *prev = &_db.ind_mr_buckets_elems[index];
+        do {
+            gitlab::FMr* ret = *prev;
+            if (!ret) { // exit condition 1: reached the end of the list
+                break;
+            }
+            if ((*ret).mr == row.mr) { // exit condition 2: found matching key
+                retval = false;
+                break;
+            }
+            prev = &ret->ind_mr_next;
+        } while (true);
+        if (retval) {
+            row.ind_mr_next = *prev;
+            _db.ind_mr_n++;
+            *prev = &row;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_mr.Remove
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void gitlab::ind_mr_Remove(gitlab::FMr& row) {
+    if (LIKELY(row.ind_mr_next != (gitlab::FMr*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.mr) & (_db.ind_mr_buckets_n - 1);
+        gitlab::FMr* *prev = &_db.ind_mr_buckets_elems[index]; // addr of pointer to current element
+        while (gitlab::FMr *next = *prev) {                          // scan the collision chain for our element
+            if (next == &row) {        // found it?
+                *prev = next->ind_mr_next; // unlink (singly linked list)
+                _db.ind_mr_n--;
+                row.ind_mr_next = (gitlab::FMr*)-1;// not-in-hash
+                break;
+            }
+            prev = &next->ind_mr_next;
+        }
+    }
+}
+
+// --- gitlab.FDb.ind_mr.Reserve
+// Reserve enough room in the hash for N more elements. Return success code.
+void gitlab::ind_mr_Reserve(int n) {
+    u32 old_nbuckets = _db.ind_mr_buckets_n;
+    u32 new_nelems   = _db.ind_mr_n + n;
+    // # of elements has to be roughly equal to the number of buckets
+    if (new_nelems > old_nbuckets) {
+        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
+        u32 old_size = old_nbuckets * sizeof(gitlab::FMr*);
+        u32 new_size = new_nbuckets * sizeof(gitlab::FMr*);
+        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
+        // means new memory will have to be allocated anyway
+        gitlab::FMr* *new_buckets = (gitlab::FMr**)algo_lib::malloc_AllocMem(new_size);
+        if (UNLIKELY(!new_buckets)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_mr");
+        }
+        memset(new_buckets, 0, new_size); // clear pointers
+        // rehash all entries
+        for (int i = 0; i < _db.ind_mr_buckets_n; i++) {
+            gitlab::FMr* elem = _db.ind_mr_buckets_elems[i];
+            while (elem) {
+                gitlab::FMr &row        = *elem;
+                gitlab::FMr* next       = row.ind_mr_next;
+                u32 index          = algo::Smallstr50_Hash(0, row.mr) & (new_nbuckets-1);
+                row.ind_mr_next     = new_buckets[index];
+                new_buckets[index] = &row;
+                elem               = next;
+            }
+        }
+        // free old array
+        algo_lib::malloc_FreeMem(_db.ind_mr_buckets_elems, old_size);
+        _db.ind_mr_buckets_elems = new_buckets;
+        _db.ind_mr_buckets_n = new_nbuckets;
+    }
+}
+
+// --- gitlab.FDb.mr.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FMr& gitlab::mr_Alloc() {
+    gitlab::FMr* row = mr_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.mr  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.mr.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FMr* gitlab::mr_AllocMaybe() {
+    gitlab::FMr *row = (gitlab::FMr*)mr_AllocMem();
+    if (row) {
+        new (row) gitlab::FMr; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.mr.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FMr* gitlab::mr_InsertMaybe(const gitlab::Mr &value) {
+    gitlab::FMr *row = &mr_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    mr_CopyIn(*row,const_cast<gitlab::Mr&>(value));
+    bool ok = mr_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        mr_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.mr.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::mr_AllocMem() {
+    u64 new_nelems     = _db.mr_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FMr*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.mr_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FMr*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMr) * (u64(1)<<bsr));
+            _db.mr_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.mr_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.mr.RemoveAll
+// Remove all elements from Lary
+void gitlab::mr_RemoveAll() {
+    for (u64 n = _db.mr_n; n>0; ) {
+        n--;
+        mr_qFind(u64(n)).~FMr(); // destroy last element
+        _db.mr_n = n;
+    }
+}
+
+// --- gitlab.FDb.mr.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::mr_RemoveLast() {
+    u64 n = _db.mr_n;
+    if (n > 0) {
+        n -= 1;
+        mr_qFind(u64(n)).~FMr();
+        _db.mr_n = n;
+    }
+}
+
+// --- gitlab.FDb.mr.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::mr_XrefMaybe(gitlab::FMr &row) {
+    bool retval = true;
+    (void)row;
+    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
+    if (UNLIKELY(!p_project)) {
+        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_project" << Keyval("key", project_Get(row));
+        return false;
+    }
+    // mr: save pointer to project
+    if (true) { // user-defined insert condition
+        row.p_project = p_project;
+    }
+    // insert mr into index c_mr
+    if (true) { // user-defined insert condition
+        c_mr_Insert(*p_project, row);
+    }
+    // insert mr into index ind_mr
+    if (true) { // user-defined insert condition
+        bool success = ind_mr_InsertMaybe(row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_mr"; // check for duplicate key
+            return false;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.mr_note.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FMrNote& gitlab::mr_note_Alloc() {
+    gitlab::FMrNote* row = mr_note_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.mr_note  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.mr_note.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FMrNote* gitlab::mr_note_AllocMaybe() {
+    gitlab::FMrNote *row = (gitlab::FMrNote*)mr_note_AllocMem();
+    if (row) {
+        new (row) gitlab::FMrNote; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.mr_note.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FMrNote* gitlab::mr_note_InsertMaybe(const gitlab::MrNote &value) {
+    gitlab::FMrNote *row = &mr_note_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    mr_note_CopyIn(*row,const_cast<gitlab::MrNote&>(value));
+    bool ok = mr_note_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        mr_note_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.mr_note.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::mr_note_AllocMem() {
+    u64 new_nelems     = _db.mr_note_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FMrNote*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.mr_note_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FMrNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrNote) * (u64(1)<<bsr));
+            _db.mr_note_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.mr_note_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.mr_note.RemoveAll
+// Remove all elements from Lary
+void gitlab::mr_note_RemoveAll() {
+    for (u64 n = _db.mr_note_n; n>0; ) {
+        n--;
+        mr_note_qFind(u64(n)).~FMrNote(); // destroy last element
+        _db.mr_note_n = n;
+    }
+}
+
+// --- gitlab.FDb.mr_note.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::mr_note_RemoveLast() {
+    u64 n = _db.mr_note_n;
+    if (n > 0) {
+        n -= 1;
+        mr_note_qFind(u64(n)).~FMrNote();
+        _db.mr_note_n = n;
+    }
+}
+
+// --- gitlab.FDb.mr_note.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::mr_note_XrefMaybe(gitlab::FMrNote &row) {
+    bool retval = true;
+    (void)row;
+    gitlab::FMr* p_mr = gitlab::ind_mr_Find(mr_Get(row));
+    if (UNLIKELY(!p_mr)) {
+        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_mr" << Keyval("key", mr_Get(row));
+        return false;
+    }
+    // mr_note: save pointer to mr
+    if (true) { // user-defined insert condition
+        row.p_mr = p_mr;
+    }
+    // insert mr_note into index ind_mr_note
+    if (true) { // user-defined insert condition
+        bool success = ind_mr_note_InsertMaybe(row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_mr_note"; // check for duplicate key
+            return false;
+        }
+    }
+    // insert mr_note into index c_mr_note
+    if (true) { // user-defined insert condition
+        c_mr_note_Insert(*p_mr, row);
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_mr_note.Find
+// Find row by key. Return NULL if not found.
+gitlab::FMrNote* gitlab::ind_mr_note_Find(const algo::strptr& key) {
+    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_mr_note_buckets_n - 1);
+    gitlab::FMrNote* *e = &_db.ind_mr_note_buckets_elems[index];
+    gitlab::FMrNote* ret=NULL;
+    do {
+        ret       = *e;
+        bool done = !ret || (*ret).mr_note == key;
+        if (done) break;
+        e         = &ret->ind_mr_note_next;
+    } while (true);
+    return ret;
+}
+
+// --- gitlab.FDb.ind_mr_note.FindX
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FMrNote& gitlab::ind_mr_note_FindX(const algo::strptr& key) {
+    gitlab::FMrNote* ret = ind_mr_note_Find(key);
+    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_mr_note  key:'"<<key<<"'  comment:'key not found'");
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_mr_note.InsertMaybe
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool gitlab::ind_mr_note_InsertMaybe(gitlab::FMrNote& row) {
+    ind_mr_note_Reserve(1);
+    bool retval = true; // if already in hash, InsertMaybe returns true
+    if (LIKELY(row.ind_mr_note_next == (gitlab::FMrNote*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.mr_note) & (_db.ind_mr_note_buckets_n - 1);
+        gitlab::FMrNote* *prev = &_db.ind_mr_note_buckets_elems[index];
+        do {
+            gitlab::FMrNote* ret = *prev;
+            if (!ret) { // exit condition 1: reached the end of the list
+                break;
+            }
+            if ((*ret).mr_note == row.mr_note) { // exit condition 2: found matching key
+                retval = false;
+                break;
+            }
+            prev = &ret->ind_mr_note_next;
+        } while (true);
+        if (retval) {
+            row.ind_mr_note_next = *prev;
+            _db.ind_mr_note_n++;
+            *prev = &row;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_mr_note.Remove
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void gitlab::ind_mr_note_Remove(gitlab::FMrNote& row) {
+    if (LIKELY(row.ind_mr_note_next != (gitlab::FMrNote*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.mr_note) & (_db.ind_mr_note_buckets_n - 1);
+        gitlab::FMrNote* *prev = &_db.ind_mr_note_buckets_elems[index]; // addr of pointer to current element
+        while (gitlab::FMrNote *next = *prev) {                          // scan the collision chain for our element
+            if (next == &row) {        // found it?
+                *prev = next->ind_mr_note_next; // unlink (singly linked list)
+                _db.ind_mr_note_n--;
+                row.ind_mr_note_next = (gitlab::FMrNote*)-1;// not-in-hash
+                break;
+            }
+            prev = &next->ind_mr_note_next;
+        }
+    }
+}
+
+// --- gitlab.FDb.ind_mr_note.Reserve
+// Reserve enough room in the hash for N more elements. Return success code.
+void gitlab::ind_mr_note_Reserve(int n) {
+    u32 old_nbuckets = _db.ind_mr_note_buckets_n;
+    u32 new_nelems   = _db.ind_mr_note_n + n;
+    // # of elements has to be roughly equal to the number of buckets
+    if (new_nelems > old_nbuckets) {
+        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
+        u32 old_size = old_nbuckets * sizeof(gitlab::FMrNote*);
+        u32 new_size = new_nbuckets * sizeof(gitlab::FMrNote*);
+        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
+        // means new memory will have to be allocated anyway
+        gitlab::FMrNote* *new_buckets = (gitlab::FMrNote**)algo_lib::malloc_AllocMem(new_size);
+        if (UNLIKELY(!new_buckets)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_mr_note");
+        }
+        memset(new_buckets, 0, new_size); // clear pointers
+        // rehash all entries
+        for (int i = 0; i < _db.ind_mr_note_buckets_n; i++) {
+            gitlab::FMrNote* elem = _db.ind_mr_note_buckets_elems[i];
+            while (elem) {
+                gitlab::FMrNote &row        = *elem;
+                gitlab::FMrNote* next       = row.ind_mr_note_next;
+                u32 index          = algo::Smallstr50_Hash(0, row.mr_note) & (new_nbuckets-1);
+                row.ind_mr_note_next     = new_buckets[index];
+                new_buckets[index] = &row;
+                elem               = next;
+            }
+        }
+        // free old array
+        algo_lib::malloc_FreeMem(_db.ind_mr_note_buckets_elems, old_size);
+        _db.ind_mr_note_buckets_elems = new_buckets;
+        _db.ind_mr_note_buckets_n = new_nbuckets;
+    }
+}
+
+// --- gitlab.FDb.mr_description.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FMrDescription& gitlab::mr_description_Alloc() {
+    gitlab::FMrDescription* row = mr_description_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.mr_description  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.mr_description.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FMrDescription* gitlab::mr_description_AllocMaybe() {
+    gitlab::FMrDescription *row = (gitlab::FMrDescription*)mr_description_AllocMem();
+    if (row) {
+        new (row) gitlab::FMrDescription; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.mr_description.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FMrDescription* gitlab::mr_description_InsertMaybe(const gitlab::MrDescription &value) {
+    gitlab::FMrDescription *row = &mr_description_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    mr_description_CopyIn(*row,const_cast<gitlab::MrDescription&>(value));
+    bool ok = mr_description_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        mr_description_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.mr_description.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::mr_description_AllocMem() {
+    u64 new_nelems     = _db.mr_description_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FMrDescription*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.mr_description_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FMrDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrDescription) * (u64(1)<<bsr));
+            _db.mr_description_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.mr_description_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.mr_description.RemoveAll
+// Remove all elements from Lary
+void gitlab::mr_description_RemoveAll() {
+    for (u64 n = _db.mr_description_n; n>0; ) {
+        n--;
+        mr_description_qFind(u64(n)).~FMrDescription(); // destroy last element
+        _db.mr_description_n = n;
+    }
+}
+
+// --- gitlab.FDb.mr_description.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::mr_description_RemoveLast() {
+    u64 n = _db.mr_description_n;
+    if (n > 0) {
+        n -= 1;
+        mr_description_qFind(u64(n)).~FMrDescription();
+        _db.mr_description_n = n;
+    }
+}
+
+// --- gitlab.FDb.mr_description.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::mr_description_XrefMaybe(gitlab::FMrDescription &row) {
+    bool retval = true;
+    (void)row;
+    gitlab::FMr* p_mr = gitlab::ind_mr_Find(row.mr);
+    if (UNLIKELY(!p_mr)) {
+        algo_lib::ResetErrtext() << "gitlab.bad_xref  index:gitlab.FDb.ind_mr" << Keyval("key", row.mr);
+        return false;
+    }
+    // mr_description: save pointer to mr
+    if (true) { // user-defined insert condition
+        row.p_mr = p_mr;
+    }
+    // insert mr_description into index c_mr_description
+    if (true) { // user-defined insert condition
+        bool success = c_mr_description_InsertMaybe(*p_mr, row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FMr.c_mr_description"; // check for duplicate key
+            return false;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.user.Alloc
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FUser& gitlab::user_Alloc() {
+    gitlab::FUser* row = user_AllocMaybe();
+    if (UNLIKELY(row == NULL)) {
+        FatalErrorExit("gitlab.out_of_mem  field:gitlab.FDb.user  comment:'Alloc failed'");
+    }
+    return *row;
+}
+
+// --- gitlab.FDb.user.AllocMaybe
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FUser* gitlab::user_AllocMaybe() {
+    gitlab::FUser *row = (gitlab::FUser*)user_AllocMem();
+    if (row) {
+        new (row) gitlab::FUser; // call constructor
+    }
+    return row;
+}
+
+// --- gitlab.FDb.user.InsertMaybe
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FUser* gitlab::user_InsertMaybe(const gitlab::User &value) {
+    gitlab::FUser *row = &user_Alloc(); // if out of memory, process dies. if input error, return NULL.
+    user_CopyIn(*row,const_cast<gitlab::User&>(value));
+    bool ok = user_XrefMaybe(*row); // this may return false
+    if (!ok) {
+        user_RemoveLast(); // delete offending row, any existing xrefs are cleared
+        row = NULL; // forget this ever happened
+    }
+    return row;
+}
+
+// --- gitlab.FDb.user.AllocMem
+// Allocate space for one element. If no memory available, return NULL.
+void* gitlab::user_AllocMem() {
+    u64 new_nelems     = _db.user_n+1;
+    // compute level and index on level
+    u64 bsr   = algo::u64_BitScanReverse(new_nelems);
+    u64 base  = u64(1)<<bsr;
+    u64 index = new_nelems-base;
+    void *ret = NULL;
+    // if level doesn't exist yet, create it
+    gitlab::FUser*  lev   = NULL;
+    if (bsr < 32) {
+        lev = _db.user_lary[bsr];
+        if (!lev) {
+            lev=(gitlab::FUser*)algo_lib::malloc_AllocMem(sizeof(gitlab::FUser) * (u64(1)<<bsr));
+            _db.user_lary[bsr] = lev;
+        }
+    }
+    // allocate element from this level
+    if (lev) {
+        _db.user_n = new_nelems;
+        ret = lev + index;
+    }
+    return ret;
+}
+
+// --- gitlab.FDb.user.RemoveAll
+// Remove all elements from Lary
+void gitlab::user_RemoveAll() {
+    for (u64 n = _db.user_n; n>0; ) {
+        n--;
+        user_qFind(u64(n)).~FUser(); // destroy last element
+        _db.user_n = n;
+    }
+}
+
+// --- gitlab.FDb.user.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::user_RemoveLast() {
+    u64 n = _db.user_n;
+    if (n > 0) {
+        n -= 1;
+        user_qFind(u64(n)).~FUser();
+        _db.user_n = n;
+    }
+}
+
+// --- gitlab.FDb.user.XrefMaybe
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool gitlab::user_XrefMaybe(gitlab::FUser &row) {
+    bool retval = true;
+    (void)row;
+    // insert user into index ind_user
+    if (true) { // user-defined insert condition
+        bool success = ind_user_InsertMaybe(row);
+        if (UNLIKELY(!success)) {
+            ch_RemoveAll(algo_lib::_db.errtext);
+            algo_lib::_db.errtext << "gitlab.duplicate_key  xref:gitlab.FDb.ind_user"; // check for duplicate key
+            return false;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_user.Find
+// Find row by key. Return NULL if not found.
+gitlab::FUser* gitlab::ind_user_Find(const algo::strptr& key) {
+    u32 index = algo::Smallstr50_Hash(0, key) & (_db.ind_user_buckets_n - 1);
+    gitlab::FUser* *e = &_db.ind_user_buckets_elems[index];
+    gitlab::FUser* ret=NULL;
+    do {
+        ret       = *e;
+        bool done = !ret || (*ret).user == key;
+        if (done) break;
+        e         = &ret->ind_user_next;
+    } while (true);
+    return ret;
+}
+
+// --- gitlab.FDb.ind_user.FindX
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FUser& gitlab::ind_user_FindX(const algo::strptr& key) {
+    gitlab::FUser* ret = ind_user_Find(key);
+    vrfy(ret, tempstr() << "gitlab.key_error  table:ind_user  key:'"<<key<<"'  comment:'key not found'");
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_user.GetOrCreate
+// Find row by key. If not found, create and x-reference a new row with with this key.
+gitlab::FUser& gitlab::ind_user_GetOrCreate(const algo::strptr& key) {
+    gitlab::FUser* ret = ind_user_Find(key);
+    if (!ret) { //  if memory alloc fails, process dies; if insert fails, function returns NULL.
+        ret         = &user_Alloc();
+        (*ret).user = key;
+        bool good = user_XrefMaybe(*ret);
+        if (!good) {
+            user_RemoveLast(); // delete offending row, any existing xrefs are cleared
+            ret = NULL;
+        }
+    }
+    return *ret;
+}
+
+// --- gitlab.FDb.ind_user.InsertMaybe
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool gitlab::ind_user_InsertMaybe(gitlab::FUser& row) {
+    ind_user_Reserve(1);
+    bool retval = true; // if already in hash, InsertMaybe returns true
+    if (LIKELY(row.ind_user_next == (gitlab::FUser*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.user) & (_db.ind_user_buckets_n - 1);
+        gitlab::FUser* *prev = &_db.ind_user_buckets_elems[index];
+        do {
+            gitlab::FUser* ret = *prev;
+            if (!ret) { // exit condition 1: reached the end of the list
+                break;
+            }
+            if ((*ret).user == row.user) { // exit condition 2: found matching key
+                retval = false;
+                break;
+            }
+            prev = &ret->ind_user_next;
+        } while (true);
+        if (retval) {
+            row.ind_user_next = *prev;
+            _db.ind_user_n++;
+            *prev = &row;
+        }
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.ind_user.Remove
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void gitlab::ind_user_Remove(gitlab::FUser& row) {
+    if (LIKELY(row.ind_user_next != (gitlab::FUser*)-1)) {// check if in hash already
+        u32 index = algo::Smallstr50_Hash(0, row.user) & (_db.ind_user_buckets_n - 1);
+        gitlab::FUser* *prev = &_db.ind_user_buckets_elems[index]; // addr of pointer to current element
+        while (gitlab::FUser *next = *prev) {                          // scan the collision chain for our element
+            if (next == &row) {        // found it?
+                *prev = next->ind_user_next; // unlink (singly linked list)
+                _db.ind_user_n--;
+                row.ind_user_next = (gitlab::FUser*)-1;// not-in-hash
+                break;
+            }
+            prev = &next->ind_user_next;
+        }
+    }
+}
+
+// --- gitlab.FDb.ind_user.Reserve
+// Reserve enough room in the hash for N more elements. Return success code.
+void gitlab::ind_user_Reserve(int n) {
+    u32 old_nbuckets = _db.ind_user_buckets_n;
+    u32 new_nelems   = _db.ind_user_n + n;
+    // # of elements has to be roughly equal to the number of buckets
+    if (new_nelems > old_nbuckets) {
+        int new_nbuckets = i32_Max(algo::BumpToPow2(new_nelems), u32(4));
+        u32 old_size = old_nbuckets * sizeof(gitlab::FUser*);
+        u32 new_size = new_nbuckets * sizeof(gitlab::FUser*);
+        // allocate new array. we don't use Realloc since copying is not needed and factor of 2 probably
+        // means new memory will have to be allocated anyway
+        gitlab::FUser* *new_buckets = (gitlab::FUser**)algo_lib::malloc_AllocMem(new_size);
+        if (UNLIKELY(!new_buckets)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FDb.ind_user");
+        }
+        memset(new_buckets, 0, new_size); // clear pointers
+        // rehash all entries
+        for (int i = 0; i < _db.ind_user_buckets_n; i++) {
+            gitlab::FUser* elem = _db.ind_user_buckets_elems[i];
+            while (elem) {
+                gitlab::FUser &row        = *elem;
+                gitlab::FUser* next       = row.ind_user_next;
+                u32 index          = algo::Smallstr50_Hash(0, row.user) & (new_nbuckets-1);
+                row.ind_user_next     = new_buckets[index];
+                new_buckets[index] = &row;
+                elem               = next;
+            }
+        }
+        // free old array
+        algo_lib::malloc_FreeMem(_db.ind_user_buckets_elems, old_size);
+        _db.ind_user_buckets_elems = new_buckets;
+        _db.ind_user_buckets_n = new_nbuckets;
+    }
+}
+
+// --- gitlab.FDb.trace.RowidFind
+// find trace by row id (used to implement reflection)
+static algo::ImrowPtr gitlab::trace_RowidFind(int t) {
+    return algo::ImrowPtr(t==0 ? u64(&_db.trace) : u64(0));
+}
+
+// --- gitlab.FDb.trace.N
+// Function return 1
+inline static i32 gitlab::trace_N() {
+    return 1;
+}
+
+// --- gitlab.FDb..Init
+// Set all fields to initial values.
+void gitlab::FDb_Init() {
+    _db.auth_file_name = algo::strptr(".gitlab_auth");
+    _db.usrmsg_no_token = algo::strptr("Please supply personal access token via -auth_token option (could be done once). Visit <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html> for directions. Token scope shall be 'api', i.e. whole GitLab API.");
+    // initialize LAry project (gitlab.FDb.project)
+    _db.project_n = 0;
+    memset(_db.project_lary, 0, sizeof(_db.project_lary)); // zero out all level pointers
+    gitlab::FProject* project_first = (gitlab::FProject*)algo_lib::malloc_AllocMem(sizeof(gitlab::FProject) * (u64(1)<<4));
+    if (!project_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.project_lary[i]  = project_first;
+        project_first    += 1ULL<<i;
+    }
+    _db.project_id = u32(0);
+    // initialize hash table for gitlab::FProject;
+    _db.ind_project_n             	= 0; // (gitlab.FDb.ind_project)
+    _db.ind_project_buckets_n     	= 4; // (gitlab.FDb.ind_project)
+    _db.ind_project_buckets_elems 	= (gitlab::FProject**)algo_lib::malloc_AllocMem(sizeof(gitlab::FProject*)*_db.ind_project_buckets_n); // initial buckets (gitlab.FDb.ind_project)
+    if (!_db.ind_project_buckets_elems) {
+        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_project)
+    }
+    memset(_db.ind_project_buckets_elems, 0, sizeof(gitlab::FProject*)*_db.ind_project_buckets_n); // (gitlab.FDb.ind_project)
+    // initialize hash table for gitlab::FIssue;
+    _db.ind_issue_n             	= 0; // (gitlab.FDb.ind_issue)
+    _db.ind_issue_buckets_n     	= 4; // (gitlab.FDb.ind_issue)
+    _db.ind_issue_buckets_elems 	= (gitlab::FIssue**)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssue*)*_db.ind_issue_buckets_n); // initial buckets (gitlab.FDb.ind_issue)
+    if (!_db.ind_issue_buckets_elems) {
+        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_issue)
+    }
+    memset(_db.ind_issue_buckets_elems, 0, sizeof(gitlab::FIssue*)*_db.ind_issue_buckets_n); // (gitlab.FDb.ind_issue)
+    // initialize LAry issue (gitlab.FDb.issue)
+    _db.issue_n = 0;
+    memset(_db.issue_lary, 0, sizeof(_db.issue_lary)); // zero out all level pointers
+    gitlab::FIssue* issue_first = (gitlab::FIssue*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssue) * (u64(1)<<4));
+    if (!issue_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.issue_lary[i]  = issue_first;
+        issue_first    += 1ULL<<i;
+    }
+    // initialize LAry issue_note (gitlab.FDb.issue_note)
+    _db.issue_note_n = 0;
+    memset(_db.issue_note_lary, 0, sizeof(_db.issue_note_lary)); // zero out all level pointers
+    gitlab::FIssueNote* issue_note_first = (gitlab::FIssueNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueNote) * (u64(1)<<4));
+    if (!issue_note_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.issue_note_lary[i]  = issue_note_first;
+        issue_note_first    += 1ULL<<i;
+    }
+    // initialize hash table for gitlab::FIssueNote;
+    _db.ind_issue_note_n             	= 0; // (gitlab.FDb.ind_issue_note)
+    _db.ind_issue_note_buckets_n     	= 4; // (gitlab.FDb.ind_issue_note)
+    _db.ind_issue_note_buckets_elems 	= (gitlab::FIssueNote**)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueNote*)*_db.ind_issue_note_buckets_n); // initial buckets (gitlab.FDb.ind_issue_note)
+    if (!_db.ind_issue_note_buckets_elems) {
+        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_issue_note)
+    }
+    memset(_db.ind_issue_note_buckets_elems, 0, sizeof(gitlab::FIssueNote*)*_db.ind_issue_note_buckets_n); // (gitlab.FDb.ind_issue_note)
+    // initialize LAry issue_description (gitlab.FDb.issue_description)
+    _db.issue_description_n = 0;
+    memset(_db.issue_description_lary, 0, sizeof(_db.issue_description_lary)); // zero out all level pointers
+    gitlab::FIssueDescription* issue_description_first = (gitlab::FIssueDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FIssueDescription) * (u64(1)<<4));
+    if (!issue_description_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.issue_description_lary[i]  = issue_description_first;
+        issue_description_first    += 1ULL<<i;
+    }
+    // initialize hash table for gitlab::FMr;
+    _db.ind_mr_n             	= 0; // (gitlab.FDb.ind_mr)
+    _db.ind_mr_buckets_n     	= 4; // (gitlab.FDb.ind_mr)
+    _db.ind_mr_buckets_elems 	= (gitlab::FMr**)algo_lib::malloc_AllocMem(sizeof(gitlab::FMr*)*_db.ind_mr_buckets_n); // initial buckets (gitlab.FDb.ind_mr)
+    if (!_db.ind_mr_buckets_elems) {
+        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_mr)
+    }
+    memset(_db.ind_mr_buckets_elems, 0, sizeof(gitlab::FMr*)*_db.ind_mr_buckets_n); // (gitlab.FDb.ind_mr)
+    // initialize LAry mr (gitlab.FDb.mr)
+    _db.mr_n = 0;
+    memset(_db.mr_lary, 0, sizeof(_db.mr_lary)); // zero out all level pointers
+    gitlab::FMr* mr_first = (gitlab::FMr*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMr) * (u64(1)<<4));
+    if (!mr_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.mr_lary[i]  = mr_first;
+        mr_first    += 1ULL<<i;
+    }
+    // initialize LAry mr_note (gitlab.FDb.mr_note)
+    _db.mr_note_n = 0;
+    memset(_db.mr_note_lary, 0, sizeof(_db.mr_note_lary)); // zero out all level pointers
+    gitlab::FMrNote* mr_note_first = (gitlab::FMrNote*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrNote) * (u64(1)<<4));
+    if (!mr_note_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.mr_note_lary[i]  = mr_note_first;
+        mr_note_first    += 1ULL<<i;
+    }
+    // initialize hash table for gitlab::FMrNote;
+    _db.ind_mr_note_n             	= 0; // (gitlab.FDb.ind_mr_note)
+    _db.ind_mr_note_buckets_n     	= 4; // (gitlab.FDb.ind_mr_note)
+    _db.ind_mr_note_buckets_elems 	= (gitlab::FMrNote**)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrNote*)*_db.ind_mr_note_buckets_n); // initial buckets (gitlab.FDb.ind_mr_note)
+    if (!_db.ind_mr_note_buckets_elems) {
+        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_mr_note)
+    }
+    memset(_db.ind_mr_note_buckets_elems, 0, sizeof(gitlab::FMrNote*)*_db.ind_mr_note_buckets_n); // (gitlab.FDb.ind_mr_note)
+    // initialize LAry mr_description (gitlab.FDb.mr_description)
+    _db.mr_description_n = 0;
+    memset(_db.mr_description_lary, 0, sizeof(_db.mr_description_lary)); // zero out all level pointers
+    gitlab::FMrDescription* mr_description_first = (gitlab::FMrDescription*)algo_lib::malloc_AllocMem(sizeof(gitlab::FMrDescription) * (u64(1)<<4));
+    if (!mr_description_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.mr_description_lary[i]  = mr_description_first;
+        mr_description_first    += 1ULL<<i;
+    }
+    // initialize LAry user (gitlab.FDb.user)
+    _db.user_n = 0;
+    memset(_db.user_lary, 0, sizeof(_db.user_lary)); // zero out all level pointers
+    gitlab::FUser* user_first = (gitlab::FUser*)algo_lib::malloc_AllocMem(sizeof(gitlab::FUser) * (u64(1)<<4));
+    if (!user_first) {
+        FatalErrorExit("out of memory");
+    }
+    for (int i = 0; i < 4; i++) {
+        _db.user_lary[i]  = user_first;
+        user_first    += 1ULL<<i;
+    }
+    // initialize hash table for gitlab::FUser;
+    _db.ind_user_n             	= 0; // (gitlab.FDb.ind_user)
+    _db.ind_user_buckets_n     	= 4; // (gitlab.FDb.ind_user)
+    _db.ind_user_buckets_elems 	= (gitlab::FUser**)algo_lib::malloc_AllocMem(sizeof(gitlab::FUser*)*_db.ind_user_buckets_n); // initial buckets (gitlab.FDb.ind_user)
+    if (!_db.ind_user_buckets_elems) {
+        FatalErrorExit("out of memory"); // (gitlab.FDb.ind_user)
+    }
+    memset(_db.ind_user_buckets_elems, 0, sizeof(gitlab::FUser*)*_db.ind_user_buckets_n); // (gitlab.FDb.ind_user)
+
+    gitlab::InitReflection();
+}
+
+// --- gitlab.FDb..Uninit
+void gitlab::FDb_Uninit() {
+    gitlab::FDb &row = _db; (void)row;
+
+    // gitlab.FDb.ind_user.Uninit (Thash)  //
+    // skip destruction of ind_user in global scope
+
+    // gitlab.FDb.user.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.mr_description.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.ind_mr_note.Uninit (Thash)  //
+    // skip destruction of ind_mr_note in global scope
+
+    // gitlab.FDb.mr_note.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.mr.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.ind_mr.Uninit (Thash)  //
+    // skip destruction of ind_mr in global scope
+
+    // gitlab.FDb.issue_description.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.ind_issue_note.Uninit (Thash)  //
+    // skip destruction of ind_issue_note in global scope
+
+    // gitlab.FDb.issue_note.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.issue.Uninit (Lary)  //
+    // skip destruction in global scope
+
+    // gitlab.FDb.ind_issue.Uninit (Thash)  //
+    // skip destruction of ind_issue in global scope
+
+    // gitlab.FDb.ind_project.Uninit (Thash)  //
+    // skip destruction of ind_project in global scope
+
+    // gitlab.FDb.project.Uninit (Lary)  //
+    // skip destruction in global scope
+}
+
+// --- gitlab.FHttp.request_header.Alloc
+// Reserve space. Insert element at the end
+// The new element is initialized to a default value
+algo::cstring& gitlab::request_header_Alloc(gitlab::FHttp& parent) {
+    request_header_Reserve(parent, 1);
+    int n  = parent.request_header_n;
+    int at = n;
+    algo::cstring *elems = parent.request_header_elems;
+    new (elems + at) algo::cstring(); // construct new element, default initializer
+    parent.request_header_n = n+1;
+    return elems[at];
+}
+
+// --- gitlab.FHttp.request_header.AllocAt
+// Reserve space for new element, reallocating the array if necessary
+// Insert new element at specified index. Index must be in range or a fatal error occurs.
+algo::cstring& gitlab::request_header_AllocAt(gitlab::FHttp& parent, int at) {
+    request_header_Reserve(parent, 1);
+    int n  = parent.request_header_n;
+    if (UNLIKELY(u64(at) >= u64(n+1))) {
+        FatalErrorExit("gitlab.bad_alloc_at  field:gitlab.FHttp.request_header  comment:'index out of range'");
+    }
+    algo::cstring *elems = parent.request_header_elems;
+    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
+    new (elems + at) algo::cstring(); // construct element, default initializer
+    parent.request_header_n = n+1;
+    return elems[at];
+}
+
+// --- gitlab.FHttp.request_header.AllocN
+// Reserve space. Insert N elements at the end of the array, return pointer to array
+algo::aryptr<algo::cstring> gitlab::request_header_AllocN(gitlab::FHttp& parent, int n_elems) {
+    request_header_Reserve(parent, n_elems);
+    int old_n  = parent.request_header_n;
+    int new_n = old_n + n_elems;
+    algo::cstring *elems = parent.request_header_elems;
+    for (int i = old_n; i < new_n; i++) {
+        new (elems + i) algo::cstring(); // construct new element, default initialize
+    }
+    parent.request_header_n = new_n;
+    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
+}
+
+// --- gitlab.FHttp.request_header.Remove
+// Remove item by index. If index outside of range, do nothing.
+void gitlab::request_header_Remove(gitlab::FHttp& parent, u32 i) {
+    u32 lim = parent.request_header_n;
+    algo::cstring *elems = parent.request_header_elems;
+    if (i < lim) {
+        elems[i].~cstring(); // destroy element
+        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
+        parent.request_header_n = lim - 1;
+    }
+}
+
+// --- gitlab.FHttp.request_header.RemoveAll
+void gitlab::request_header_RemoveAll(gitlab::FHttp& parent) {
+    u32 n = parent.request_header_n;
+    while (n > 0) {
+        n -= 1;
+        parent.request_header_elems[n].~cstring();
+        parent.request_header_n = n;
+    }
+}
+
+// --- gitlab.FHttp.request_header.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::request_header_RemoveLast(gitlab::FHttp& parent) {
+    u64 n = parent.request_header_n;
+    if (n > 0) {
+        n -= 1;
+        request_header_qFind(parent, u64(n)).~cstring();
+        parent.request_header_n = n;
+    }
+}
+
+// --- gitlab.FHttp.request_header.AbsReserve
+// Make sure N elements fit in array. Process dies if out of memory
+void gitlab::request_header_AbsReserve(gitlab::FHttp& parent, int n) {
+    u32 old_max  = parent.request_header_max;
+    if (n > i32(old_max)) {
+        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
+        void *new_mem = algo_lib::malloc_ReallocMem(parent.request_header_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
+        if (UNLIKELY(!new_mem)) {
+            FatalErrorExit("gitlab.tary_nomem  field:gitlab.FHttp.request_header  comment:'out of memory'");
+        }
+        parent.request_header_elems = (algo::cstring*)new_mem;
+        parent.request_header_max = new_max;
+    }
+}
+
+// --- gitlab.FHttp.request_header.Setary
+// Copy contents of RHS to PARENT.
+void gitlab::request_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) {
+    request_header_RemoveAll(parent);
+    int nnew = rhs.request_header_n;
+    request_header_Reserve(parent, nnew); // reserve space
+    for (int i = 0; i < nnew; i++) { // copy elements over
+        new (parent.request_header_elems + i) algo::cstring(request_header_qFind(rhs, i));
+        parent.request_header_n = i + 1;
+    }
+}
+
+// --- gitlab.FHttp.request_method.ToCstr
+// Convert numeric value of field to one of predefined string constants.
+// If string is found, return a static C string. Otherwise, return NULL.
+const char* gitlab::request_method_ToCstr(const gitlab::FHttp& parent) {
+    const char *ret = NULL;
+    switch(request_method_GetEnum(parent)) {
+        case gitlab_FHttp_request_method_GET: ret = "GET";  break;
+        case gitlab_FHttp_request_method_POST: ret = "POST";  break;
+        case gitlab_FHttp_request_method_PUT: ret = "PUT";  break;
+    }
+    return ret;
+}
+
+// --- gitlab.FHttp.request_method.Print
+// Convert request_method to a string. First, attempt conversion to a known string.
+// If no string matches, print request_method as a numeric value.
+void gitlab::request_method_Print(const gitlab::FHttp& parent, algo::cstring &lhs) {
+    const char *strval = request_method_ToCstr(parent);
+    if (strval) {
+        lhs << strval;
+    } else {
+        lhs << parent.request_method;
+    }
+}
+
+// --- gitlab.FHttp.request_method.SetStrptrMaybe
+// Convert string to field.
+// If the string is invalid, do not modify field and return false.
+// In case of success, return true
+bool gitlab::request_method_SetStrptrMaybe(gitlab::FHttp& parent, algo::strptr rhs) {
+    bool ret = false;
+    switch (elems_N(rhs)) {
+        case 3: {
+            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
+                case LE_STR3('G','E','T'): {
+                    request_method_SetEnum(parent,gitlab_FHttp_request_method_GET); ret = true; break;
+                }
+                case LE_STR3('P','U','T'): {
+                    request_method_SetEnum(parent,gitlab_FHttp_request_method_PUT); ret = true; break;
+                }
+            }
+            break;
+        }
+        case 4: {
+            switch (u64(algo::ReadLE32(rhs.elems))) {
+                case LE_STR4('P','O','S','T'): {
+                    request_method_SetEnum(parent,gitlab_FHttp_request_method_POST); ret = true; break;
+                }
+            }
+            break;
+        }
+    }
+    return ret;
+}
+
+// --- gitlab.FHttp.request_method.SetStrptr
+// Convert string to field.
+// If the string is invalid, set numeric value to DFLT
+void gitlab::request_method_SetStrptr(gitlab::FHttp& parent, algo::strptr rhs, gitlab_FHttp_request_method_Enum dflt) {
+    if (!request_method_SetStrptrMaybe(parent,rhs)) request_method_SetEnum(parent,dflt);
+}
+
+// --- gitlab.FHttp.response_header.Alloc
+// Reserve space. Insert element at the end
+// The new element is initialized to a default value
+algo::cstring& gitlab::response_header_Alloc(gitlab::FHttp& parent) {
+    response_header_Reserve(parent, 1);
+    int n  = parent.response_header_n;
+    int at = n;
+    algo::cstring *elems = parent.response_header_elems;
+    new (elems + at) algo::cstring(); // construct new element, default initializer
+    parent.response_header_n = n+1;
+    return elems[at];
+}
+
+// --- gitlab.FHttp.response_header.AllocAt
+// Reserve space for new element, reallocating the array if necessary
+// Insert new element at specified index. Index must be in range or a fatal error occurs.
+algo::cstring& gitlab::response_header_AllocAt(gitlab::FHttp& parent, int at) {
+    response_header_Reserve(parent, 1);
+    int n  = parent.response_header_n;
+    if (UNLIKELY(u64(at) >= u64(n+1))) {
+        FatalErrorExit("gitlab.bad_alloc_at  field:gitlab.FHttp.response_header  comment:'index out of range'");
+    }
+    algo::cstring *elems = parent.response_header_elems;
+    memmove(elems + at + 1, elems + at, (n - at) * sizeof(algo::cstring));
+    new (elems + at) algo::cstring(); // construct element, default initializer
+    parent.response_header_n = n+1;
+    return elems[at];
+}
+
+// --- gitlab.FHttp.response_header.AllocN
+// Reserve space. Insert N elements at the end of the array, return pointer to array
+algo::aryptr<algo::cstring> gitlab::response_header_AllocN(gitlab::FHttp& parent, int n_elems) {
+    response_header_Reserve(parent, n_elems);
+    int old_n  = parent.response_header_n;
+    int new_n = old_n + n_elems;
+    algo::cstring *elems = parent.response_header_elems;
+    for (int i = old_n; i < new_n; i++) {
+        new (elems + i) algo::cstring(); // construct new element, default initialize
+    }
+    parent.response_header_n = new_n;
+    return algo::aryptr<algo::cstring>(elems + old_n, n_elems);
+}
+
+// --- gitlab.FHttp.response_header.Remove
+// Remove item by index. If index outside of range, do nothing.
+void gitlab::response_header_Remove(gitlab::FHttp& parent, u32 i) {
+    u32 lim = parent.response_header_n;
+    algo::cstring *elems = parent.response_header_elems;
+    if (i < lim) {
+        elems[i].~cstring(); // destroy element
+        memmove(elems + i, elems + (i + 1), sizeof(algo::cstring) * (lim - (i + 1)));
+        parent.response_header_n = lim - 1;
+    }
+}
+
+// --- gitlab.FHttp.response_header.RemoveAll
+void gitlab::response_header_RemoveAll(gitlab::FHttp& parent) {
+    u32 n = parent.response_header_n;
+    while (n > 0) {
+        n -= 1;
+        parent.response_header_elems[n].~cstring();
+        parent.response_header_n = n;
+    }
+}
+
+// --- gitlab.FHttp.response_header.RemoveLast
+// Delete last element of array. Do nothing if array is empty.
+void gitlab::response_header_RemoveLast(gitlab::FHttp& parent) {
+    u64 n = parent.response_header_n;
+    if (n > 0) {
+        n -= 1;
+        response_header_qFind(parent, u64(n)).~cstring();
+        parent.response_header_n = n;
+    }
+}
+
+// --- gitlab.FHttp.response_header.AbsReserve
+// Make sure N elements fit in array. Process dies if out of memory
+void gitlab::response_header_AbsReserve(gitlab::FHttp& parent, int n) {
+    u32 old_max  = parent.response_header_max;
+    if (n > i32(old_max)) {
+        u32 new_max  = i32_Max(i32_Max(old_max * 2, n), 4);
+        void *new_mem = algo_lib::malloc_ReallocMem(parent.response_header_elems, old_max * sizeof(algo::cstring), new_max * sizeof(algo::cstring));
+        if (UNLIKELY(!new_mem)) {
+            FatalErrorExit("gitlab.tary_nomem  field:gitlab.FHttp.response_header  comment:'out of memory'");
+        }
+        parent.response_header_elems = (algo::cstring*)new_mem;
+        parent.response_header_max = new_max;
+    }
+}
+
+// --- gitlab.FHttp.response_header.Setary
+// Copy contents of RHS to PARENT.
+void gitlab::response_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) {
+    response_header_RemoveAll(parent);
+    int nnew = rhs.response_header_n;
+    response_header_Reserve(parent, nnew); // reserve space
+    for (int i = 0; i < nnew; i++) { // copy elements over
+        new (parent.response_header_elems + i) algo::cstring(response_header_qFind(rhs, i));
+        parent.response_header_n = i + 1;
+    }
+}
+
+// --- gitlab.FHttp..Init
+// Set all fields to initial values.
+void gitlab::FHttp_Init(gitlab::FHttp& parent) {
+    parent.request_header_elems 	= 0; // (gitlab.FHttp.request_header)
+    parent.request_header_n     	= 0; // (gitlab.FHttp.request_header)
+    parent.request_header_max   	= 0; // (gitlab.FHttp.request_header)
+    parent.response_status_code = u32(0);
+    parent.request_method = u32(gitlab_FHttp_request_method_GET);
+    parent.response_header_elems 	= 0; // (gitlab.FHttp.response_header)
+    parent.response_header_n     	= 0; // (gitlab.FHttp.response_header)
+    parent.response_header_max   	= 0; // (gitlab.FHttp.response_header)
+    parent.response_content_type_json = bool(false);
+    parent.request_body_sent_bytes = u32(0);
+}
+
+// --- gitlab.FHttp..Uninit
+void gitlab::FHttp_Uninit(gitlab::FHttp& parent) {
+    gitlab::FHttp &row = parent; (void)row;
+
+    // gitlab.FHttp.response_header.Uninit (Tary)  //Array of request headers
+    // remove all elements from gitlab.FHttp.response_header
+    response_header_RemoveAll(parent);
+    // free memory for Tary gitlab.FHttp.response_header
+    algo_lib::malloc_FreeMem(parent.response_header_elems, sizeof(algo::cstring)*parent.response_header_max); // (gitlab.FHttp.response_header)
+
+    // gitlab.FHttp.request_header.Uninit (Tary)  //Array of request headers
+    // remove all elements from gitlab.FHttp.request_header
+    request_header_RemoveAll(parent);
+    // free memory for Tary gitlab.FHttp.request_header
+    algo_lib::malloc_FreeMem(parent.request_header_elems, sizeof(algo::cstring)*parent.request_header_max); // (gitlab.FHttp.request_header)
+}
+
+// --- gitlab.FHttp..Print
+// print string representation of gitlab::FHttp to string LHS, no header -- cprint:gitlab.FHttp.String
+void gitlab::FHttp_Print(gitlab::FHttp & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.FHttp";
+
+    algo::cstring_Print(row.request_uri, temp);
+    PrintAttrSpaceReset(str,"request_uri", temp);
+
+    algo::cstring_Print(row.request_content_type, temp);
+    PrintAttrSpaceReset(str,"request_content_type", temp);
+
+    algo::cstring_Print(row.request_body, temp);
+    PrintAttrSpaceReset(str,"request_body", temp);
+
+    algo::cstring_Print(row.response_status_line, temp);
+    PrintAttrSpaceReset(str,"response_status_line", temp);
+
+    u32_Print(row.response_status_code, temp);
+    PrintAttrSpaceReset(str,"response_status_code", temp);
+
+    gitlab::request_method_Print(row, temp);
+    PrintAttrSpaceReset(str,"request_method", temp);
+
+    algo::cstring_Print(row.response_reason_phrase, temp);
+    PrintAttrSpaceReset(str,"response_reason_phrase", temp);
+
+    algo::cstring_Print(row.response_content_type, temp);
+    PrintAttrSpaceReset(str,"response_content_type", temp);
+
+    algo::cstring_Print(row.response_body, temp);
+    PrintAttrSpaceReset(str,"response_body", temp);
+
+    bool_Print(row.response_content_type_json, temp);
+    PrintAttrSpaceReset(str,"response_content_type_json", temp);
+
+    lib_json::FParser_Print(row.response_json_parser, temp);
+    PrintAttrSpaceReset(str,"response_json_parser", temp);
+
+    u32_Print(row.request_body_sent_bytes, temp);
+    PrintAttrSpaceReset(str,"request_body_sent_bytes", temp);
+}
+
+// --- gitlab.FIssue.base.CopyOut
+// Copy fields out of row
+void gitlab::issue_CopyOut(gitlab::FIssue &row, gitlab::Issue &out) {
+    out.issue = row.issue;
+    out.assignee = row.assignee;
+    out.title = row.title;
+}
+
+// --- gitlab.FIssue.base.CopyIn
+// Copy fields in to row
+void gitlab::issue_CopyIn(gitlab::FIssue &row, gitlab::Issue &in) {
+    row.issue = in.issue;
+    row.assignee = in.assignee;
+    row.title = in.title;
+}
+
+// --- gitlab.FIssue.project.Get
+algo::Smallstr50 gitlab::project_Get(gitlab::FIssue& issue) {
+    algo::Smallstr50 ret(algo::Pathcomp(issue.issue, ".RL"));
+    return ret;
+}
+
+// --- gitlab.FIssue.iid.Get
+u32 gitlab::iid_Get(gitlab::FIssue& issue) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(issue.issue, ".RR"));
+    return ret;
+}
+
+// --- gitlab.FIssue.c_issue_note.Insert
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void gitlab::c_issue_note_Insert(gitlab::FIssue& issue, gitlab::FIssueNote& row) {
+    if (bool_Update(row.issue_c_issue_note_in_ary,true)) {
+        // reserve space
+        c_issue_note_Reserve(issue, 1);
+        u32 n  = issue.c_issue_note_n;
+        u32 at = n;
+        gitlab::FIssueNote* *elems = issue.c_issue_note_elems;
+        elems[at] = &row;
+        issue.c_issue_note_n = n+1;
+
+    }
+}
+
+// --- gitlab.FIssue.c_issue_note.InsertMaybe
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool gitlab::c_issue_note_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueNote& row) {
+    bool retval = !row.issue_c_issue_note_in_ary;
+    c_issue_note_Insert(issue,row); // check is performed in _Insert again
+    return retval;
+}
+
+// --- gitlab.FIssue.c_issue_note.Remove
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void gitlab::c_issue_note_Remove(gitlab::FIssue& issue, gitlab::FIssueNote& row) {
+    if (bool_Update(row.issue_c_issue_note_in_ary,false)) {
+        int lim = issue.c_issue_note_n;
+        gitlab::FIssueNote* *elems = issue.c_issue_note_elems;
+        // search backward, so that most recently added element is found first.
+        // if found, shift array.
+        for (int i = lim-1; i>=0; i--) {
+            gitlab::FIssueNote* elem = elems[i]; // fetch element
+            if (elem == &row) {
+                int j = i + 1;
+                size_t nbytes = sizeof(gitlab::FIssueNote*) * (lim - j);
+                memmove(elems + i, elems + j, nbytes);
+                issue.c_issue_note_n = lim - 1;
+                break;
+            }
+        }
+    }
+}
+
+// --- gitlab.FIssue.c_issue_note.Reserve
+// Reserve space in index for N more elements;
+void gitlab::c_issue_note_Reserve(gitlab::FIssue& issue, u32 n) {
+    u32 old_max = issue.c_issue_note_max;
+    if (UNLIKELY(issue.c_issue_note_n + n > old_max)) {
+        u32 new_max  = u32_Max(4, old_max * 2);
+        u32 old_size = old_max * sizeof(gitlab::FIssueNote*);
+        u32 new_size = new_max * sizeof(gitlab::FIssueNote*);
+        void *new_mem = algo_lib::malloc_ReallocMem(issue.c_issue_note_elems, old_size, new_size);
+        if (UNLIKELY(!new_mem)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FIssue.c_issue_note");
+        }
+        issue.c_issue_note_elems = (gitlab::FIssueNote**)new_mem;
+        issue.c_issue_note_max = new_max;
+    }
+}
+
+// --- gitlab.FIssue..Init
+// Set all fields to initial values.
+void gitlab::FIssue_Init(gitlab::FIssue& issue) {
+    issue.p_project = NULL;
+    issue.c_issue_note_elems = NULL; // (gitlab.FIssue.c_issue_note)
+    issue.c_issue_note_n = 0; // (gitlab.FIssue.c_issue_note)
+    issue.c_issue_note_max = 0; // (gitlab.FIssue.c_issue_note)
+    issue.c_issue_description = NULL;
+    issue.select = bool(false);
+    issue.project_c_issue_in_ary = bool(false);
+    issue.ind_issue_next = (gitlab::FIssue*)-1; // (gitlab.FDb.ind_issue) not-in-hash
+}
+
+// --- gitlab.FIssue..Uninit
+void gitlab::FIssue_Uninit(gitlab::FIssue& issue) {
+    gitlab::FIssue &row = issue; (void)row;
+    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
+    if (p_project)  {
+        c_issue_Remove(*p_project, row);// remove issue from index c_issue
+    }
+    ind_issue_Remove(row); // remove issue from index ind_issue
+
+    // gitlab.FIssue.c_issue_note.Uninit (Ptrary)  //
+    algo_lib::malloc_FreeMem(issue.c_issue_note_elems, sizeof(gitlab::FIssueNote*)*issue.c_issue_note_max); // (gitlab.FIssue.c_issue_note)
+}
+
+// --- gitlab.FIssue..Print
+// print string representation of gitlab::FIssue to string LHS, no header -- cprint:gitlab.FIssue.String
+void gitlab::FIssue_Print(gitlab::FIssue & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.FIssue";
+
+    algo::Smallstr50_Print(row.issue, temp);
+    PrintAttrSpaceReset(str,"issue", temp);
+
+    algo::Smallstr50_Print(row.assignee, temp);
+    PrintAttrSpaceReset(str,"assignee", temp);
+
+    algo::cstring_Print(row.title, temp);
+    PrintAttrSpaceReset(str,"title", temp);
+
+    u64_PrintHex(u64((const gitlab::FIssueDescription*)row.c_issue_description), temp, 8, true);
+    PrintAttrSpaceReset(str,"c_issue_description", temp);
+
+    bool_Print(row.select, temp);
+    PrintAttrSpaceReset(str,"select", temp);
+
+    bool_Print(row.project_c_issue_in_ary, temp);
+    PrintAttrSpaceReset(str,"project_c_issue_in_ary", temp);
+}
+
+// --- gitlab.FIssueDescription.base.CopyOut
+// Copy fields out of row
+void gitlab::issue_description_CopyOut(gitlab::FIssueDescription &row, gitlab::IssueDescription &out) {
+    out.issue = row.issue;
+    out.description = row.description;
+}
+
+// --- gitlab.FIssueDescription.base.CopyIn
+// Copy fields in to row
+void gitlab::issue_description_CopyIn(gitlab::FIssueDescription &row, gitlab::IssueDescription &in) {
+    row.issue = in.issue;
+    row.description = in.description;
+}
+
+// --- gitlab.FIssueDescription..Uninit
+void gitlab::FIssueDescription_Uninit(gitlab::FIssueDescription& issue_description) {
+    gitlab::FIssueDescription &row = issue_description; (void)row;
+    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(row.issue);
+    if (p_issue)  {
+        c_issue_description_Remove(*p_issue, row);// remove issue_description from index c_issue_description
+    }
+}
+
+// --- gitlab.FIssueNote.base.CopyOut
+// Copy fields out of row
+void gitlab::issue_note_CopyOut(gitlab::FIssueNote &row, gitlab::IssueNote &out) {
+    out.issue_note = row.issue_note;
+    out.body = row.body;
+}
+
+// --- gitlab.FIssueNote.base.CopyIn
+// Copy fields in to row
+void gitlab::issue_note_CopyIn(gitlab::FIssueNote &row, gitlab::IssueNote &in) {
+    row.issue_note = in.issue_note;
+    row.body = in.body;
+}
+
+// --- gitlab.FIssueNote.issue.Get
+algo::Smallstr50 gitlab::issue_Get(gitlab::FIssueNote& issue_note) {
+    algo::Smallstr50 ret(algo::Pathcomp(issue_note.issue_note, ".RL"));
+    return ret;
+}
+
+// --- gitlab.FIssueNote.id.Get
+u32 gitlab::id_Get(gitlab::FIssueNote& issue_note) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(issue_note.issue_note, ".RR"));
+    return ret;
+}
+
+// --- gitlab.FIssueNote..Uninit
+void gitlab::FIssueNote_Uninit(gitlab::FIssueNote& issue_note) {
+    gitlab::FIssueNote &row = issue_note; (void)row;
+    ind_issue_note_Remove(row); // remove issue_note from index ind_issue_note
+    gitlab::FIssue* p_issue = gitlab::ind_issue_Find(issue_Get(row));
+    if (p_issue)  {
+        c_issue_note_Remove(*p_issue, row);// remove issue_note from index c_issue_note
+    }
+}
+
+// --- gitlab.FMr.base.CopyOut
+// Copy fields out of row
+void gitlab::mr_CopyOut(gitlab::FMr &row, gitlab::Mr &out) {
+    out.mr = row.mr;
+    out.title = row.title;
+    out.source_branch = row.source_branch;
+    out.pipeline_status = row.pipeline_status;
+}
+
+// --- gitlab.FMr.base.CopyIn
+// Copy fields in to row
+void gitlab::mr_CopyIn(gitlab::FMr &row, gitlab::Mr &in) {
+    row.mr = in.mr;
+    row.title = in.title;
+    row.source_branch = in.source_branch;
+    row.pipeline_status = in.pipeline_status;
+}
+
+// --- gitlab.FMr.project.Get
+algo::Smallstr50 gitlab::project_Get(gitlab::FMr& mr) {
+    algo::Smallstr50 ret(algo::Pathcomp(mr.mr, ".RL"));
+    return ret;
+}
+
+// --- gitlab.FMr.iid.Get
+u32 gitlab::iid_Get(gitlab::FMr& mr) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(mr.mr, ".RR"));
+    return ret;
+}
+
+// --- gitlab.FMr.c_mr_note.Insert
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void gitlab::c_mr_note_Insert(gitlab::FMr& mr, gitlab::FMrNote& row) {
+    if (bool_Update(row.mr_c_mr_note_in_ary,true)) {
+        // reserve space
+        c_mr_note_Reserve(mr, 1);
+        u32 n  = mr.c_mr_note_n;
+        u32 at = n;
+        gitlab::FMrNote* *elems = mr.c_mr_note_elems;
+        elems[at] = &row;
+        mr.c_mr_note_n = n+1;
+
+    }
+}
+
+// --- gitlab.FMr.c_mr_note.InsertMaybe
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool gitlab::c_mr_note_InsertMaybe(gitlab::FMr& mr, gitlab::FMrNote& row) {
+    bool retval = !row.mr_c_mr_note_in_ary;
+    c_mr_note_Insert(mr,row); // check is performed in _Insert again
+    return retval;
+}
+
+// --- gitlab.FMr.c_mr_note.Remove
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void gitlab::c_mr_note_Remove(gitlab::FMr& mr, gitlab::FMrNote& row) {
+    if (bool_Update(row.mr_c_mr_note_in_ary,false)) {
+        int lim = mr.c_mr_note_n;
+        gitlab::FMrNote* *elems = mr.c_mr_note_elems;
+        // search backward, so that most recently added element is found first.
+        // if found, shift array.
+        for (int i = lim-1; i>=0; i--) {
+            gitlab::FMrNote* elem = elems[i]; // fetch element
+            if (elem == &row) {
+                int j = i + 1;
+                size_t nbytes = sizeof(gitlab::FMrNote*) * (lim - j);
+                memmove(elems + i, elems + j, nbytes);
+                mr.c_mr_note_n = lim - 1;
+                break;
+            }
+        }
+    }
+}
+
+// --- gitlab.FMr.c_mr_note.Reserve
+// Reserve space in index for N more elements;
+void gitlab::c_mr_note_Reserve(gitlab::FMr& mr, u32 n) {
+    u32 old_max = mr.c_mr_note_max;
+    if (UNLIKELY(mr.c_mr_note_n + n > old_max)) {
+        u32 new_max  = u32_Max(4, old_max * 2);
+        u32 old_size = old_max * sizeof(gitlab::FMrNote*);
+        u32 new_size = new_max * sizeof(gitlab::FMrNote*);
+        void *new_mem = algo_lib::malloc_ReallocMem(mr.c_mr_note_elems, old_size, new_size);
+        if (UNLIKELY(!new_mem)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FMr.c_mr_note");
+        }
+        mr.c_mr_note_elems = (gitlab::FMrNote**)new_mem;
+        mr.c_mr_note_max = new_max;
+    }
+}
+
+// --- gitlab.FMr..Init
+// Set all fields to initial values.
+void gitlab::FMr_Init(gitlab::FMr& mr) {
+    mr.p_project = NULL;
+    mr.c_mr_note_elems = NULL; // (gitlab.FMr.c_mr_note)
+    mr.c_mr_note_n = 0; // (gitlab.FMr.c_mr_note)
+    mr.c_mr_note_max = 0; // (gitlab.FMr.c_mr_note)
+    mr.c_mr_description = NULL;
+    mr.project_c_mr_in_ary = bool(false);
+    mr.ind_mr_next = (gitlab::FMr*)-1; // (gitlab.FDb.ind_mr) not-in-hash
+}
+
+// --- gitlab.FMr..Uninit
+void gitlab::FMr_Uninit(gitlab::FMr& mr) {
+    gitlab::FMr &row = mr; (void)row;
+    gitlab::FProject* p_project = gitlab::ind_project_Find(project_Get(row));
+    if (p_project)  {
+        c_mr_Remove(*p_project, row);// remove mr from index c_mr
+    }
+    ind_mr_Remove(row); // remove mr from index ind_mr
+
+    // gitlab.FMr.c_mr_note.Uninit (Ptrary)  //
+    algo_lib::malloc_FreeMem(mr.c_mr_note_elems, sizeof(gitlab::FMrNote*)*mr.c_mr_note_max); // (gitlab.FMr.c_mr_note)
+}
+
+// --- gitlab.FMr..Print
+// print string representation of gitlab::FMr to string LHS, no header -- cprint:gitlab.FMr.String
+void gitlab::FMr_Print(gitlab::FMr & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.FMr";
+
+    algo::Smallstr50_Print(row.mr, temp);
+    PrintAttrSpaceReset(str,"mr", temp);
+
+    algo::cstring_Print(row.title, temp);
+    PrintAttrSpaceReset(str,"title", temp);
+
+    algo::cstring_Print(row.source_branch, temp);
+    PrintAttrSpaceReset(str,"source_branch", temp);
+
+    algo::Smallstr20_Print(row.pipeline_status, temp);
+    PrintAttrSpaceReset(str,"pipeline_status", temp);
+
+    u64_PrintHex(u64((const gitlab::FMrDescription*)row.c_mr_description), temp, 8, true);
+    PrintAttrSpaceReset(str,"c_mr_description", temp);
+
+    bool_Print(row.project_c_mr_in_ary, temp);
+    PrintAttrSpaceReset(str,"project_c_mr_in_ary", temp);
+}
+
+// --- gitlab.FMrDescription.base.CopyOut
+// Copy fields out of row
+void gitlab::mr_description_CopyOut(gitlab::FMrDescription &row, gitlab::MrDescription &out) {
+    out.mr = row.mr;
+    out.description = row.description;
+}
+
+// --- gitlab.FMrDescription.base.CopyIn
+// Copy fields in to row
+void gitlab::mr_description_CopyIn(gitlab::FMrDescription &row, gitlab::MrDescription &in) {
+    row.mr = in.mr;
+    row.description = in.description;
+}
+
+// --- gitlab.FMrDescription..Uninit
+void gitlab::FMrDescription_Uninit(gitlab::FMrDescription& mr_description) {
+    gitlab::FMrDescription &row = mr_description; (void)row;
+    gitlab::FMr* p_mr = gitlab::ind_mr_Find(row.mr);
+    if (p_mr)  {
+        c_mr_description_Remove(*p_mr, row);// remove mr_description from index c_mr_description
+    }
+}
+
+// --- gitlab.FMrNote.base.CopyOut
+// Copy fields out of row
+void gitlab::mr_note_CopyOut(gitlab::FMrNote &row, gitlab::MrNote &out) {
+    out.mr_note = row.mr_note;
+    out.body = row.body;
+}
+
+// --- gitlab.FMrNote.base.CopyIn
+// Copy fields in to row
+void gitlab::mr_note_CopyIn(gitlab::FMrNote &row, gitlab::MrNote &in) {
+    row.mr_note = in.mr_note;
+    row.body = in.body;
+}
+
+// --- gitlab.FMrNote.mr.Get
+algo::Smallstr50 gitlab::mr_Get(gitlab::FMrNote& mr_note) {
+    algo::Smallstr50 ret(algo::Pathcomp(mr_note.mr_note, ".RL"));
+    return ret;
+}
+
+// --- gitlab.FMrNote.id.Get
+u32 gitlab::id_Get(gitlab::FMrNote& mr_note) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(mr_note.mr_note, ".RR"));
+    return ret;
+}
+
+// --- gitlab.FMrNote..Uninit
+void gitlab::FMrNote_Uninit(gitlab::FMrNote& mr_note) {
+    gitlab::FMrNote &row = mr_note; (void)row;
+    ind_mr_note_Remove(row); // remove mr_note from index ind_mr_note
+    gitlab::FMr* p_mr = gitlab::ind_mr_Find(mr_Get(row));
+    if (p_mr)  {
+        c_mr_note_Remove(*p_mr, row);// remove mr_note from index c_mr_note
+    }
+}
+
+// --- gitlab.FProject.base.CopyOut
+// Copy fields out of row
+void gitlab::project_CopyOut(gitlab::FProject &row, dev::GitlabProject &out) {
+    out.gitlab_project = row.gitlab_project;
+    out.url = row.url;
+    out.comment = row.comment;
+    out.gitlab_project_id = row.gitlab_project_id;
+}
+
+// --- gitlab.FProject.base.CopyIn
+// Copy fields in to row
+void gitlab::project_CopyIn(gitlab::FProject &row, dev::GitlabProject &in) {
+    row.gitlab_project = in.gitlab_project;
+    row.url = in.url;
+    row.comment = in.comment;
+    row.gitlab_project_id = in.gitlab_project_id;
+}
+
+// --- gitlab.FProject.c_issue.Insert
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void gitlab::c_issue_Insert(gitlab::FProject& project, gitlab::FIssue& row) {
+    if (bool_Update(row.project_c_issue_in_ary,true)) {
+        // reserve space
+        c_issue_Reserve(project, 1);
+        u32 n  = project.c_issue_n;
+        u32 at = n;
+        gitlab::FIssue* *elems = project.c_issue_elems;
+        elems[at] = &row;
+        project.c_issue_n = n+1;
+
+    }
+}
+
+// --- gitlab.FProject.c_issue.InsertMaybe
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool gitlab::c_issue_InsertMaybe(gitlab::FProject& project, gitlab::FIssue& row) {
+    bool retval = !row.project_c_issue_in_ary;
+    c_issue_Insert(project,row); // check is performed in _Insert again
+    return retval;
+}
+
+// --- gitlab.FProject.c_issue.Remove
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void gitlab::c_issue_Remove(gitlab::FProject& project, gitlab::FIssue& row) {
+    if (bool_Update(row.project_c_issue_in_ary,false)) {
+        int lim = project.c_issue_n;
+        gitlab::FIssue* *elems = project.c_issue_elems;
+        // search backward, so that most recently added element is found first.
+        // if found, shift array.
+        for (int i = lim-1; i>=0; i--) {
+            gitlab::FIssue* elem = elems[i]; // fetch element
+            if (elem == &row) {
+                int j = i + 1;
+                size_t nbytes = sizeof(gitlab::FIssue*) * (lim - j);
+                memmove(elems + i, elems + j, nbytes);
+                project.c_issue_n = lim - 1;
+                break;
+            }
+        }
+    }
+}
+
+// --- gitlab.FProject.c_issue.Reserve
+// Reserve space in index for N more elements;
+void gitlab::c_issue_Reserve(gitlab::FProject& project, u32 n) {
+    u32 old_max = project.c_issue_max;
+    if (UNLIKELY(project.c_issue_n + n > old_max)) {
+        u32 new_max  = u32_Max(4, old_max * 2);
+        u32 old_size = old_max * sizeof(gitlab::FIssue*);
+        u32 new_size = new_max * sizeof(gitlab::FIssue*);
+        void *new_mem = algo_lib::malloc_ReallocMem(project.c_issue_elems, old_size, new_size);
+        if (UNLIKELY(!new_mem)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FProject.c_issue");
+        }
+        project.c_issue_elems = (gitlab::FIssue**)new_mem;
+        project.c_issue_max = new_max;
+    }
+}
+
+// --- gitlab.FProject.c_mr.Insert
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void gitlab::c_mr_Insert(gitlab::FProject& project, gitlab::FMr& row) {
+    if (bool_Update(row.project_c_mr_in_ary,true)) {
+        // reserve space
+        c_mr_Reserve(project, 1);
+        u32 n  = project.c_mr_n;
+        u32 at = n;
+        gitlab::FMr* *elems = project.c_mr_elems;
+        elems[at] = &row;
+        project.c_mr_n = n+1;
+
+    }
+}
+
+// --- gitlab.FProject.c_mr.InsertMaybe
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool gitlab::c_mr_InsertMaybe(gitlab::FProject& project, gitlab::FMr& row) {
+    bool retval = !row.project_c_mr_in_ary;
+    c_mr_Insert(project,row); // check is performed in _Insert again
+    return retval;
+}
+
+// --- gitlab.FProject.c_mr.Remove
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void gitlab::c_mr_Remove(gitlab::FProject& project, gitlab::FMr& row) {
+    if (bool_Update(row.project_c_mr_in_ary,false)) {
+        int lim = project.c_mr_n;
+        gitlab::FMr* *elems = project.c_mr_elems;
+        // search backward, so that most recently added element is found first.
+        // if found, shift array.
+        for (int i = lim-1; i>=0; i--) {
+            gitlab::FMr* elem = elems[i]; // fetch element
+            if (elem == &row) {
+                int j = i + 1;
+                size_t nbytes = sizeof(gitlab::FMr*) * (lim - j);
+                memmove(elems + i, elems + j, nbytes);
+                project.c_mr_n = lim - 1;
+                break;
+            }
+        }
+    }
+}
+
+// --- gitlab.FProject.c_mr.Reserve
+// Reserve space in index for N more elements;
+void gitlab::c_mr_Reserve(gitlab::FProject& project, u32 n) {
+    u32 old_max = project.c_mr_max;
+    if (UNLIKELY(project.c_mr_n + n > old_max)) {
+        u32 new_max  = u32_Max(4, old_max * 2);
+        u32 old_size = old_max * sizeof(gitlab::FMr*);
+        u32 new_size = new_max * sizeof(gitlab::FMr*);
+        void *new_mem = algo_lib::malloc_ReallocMem(project.c_mr_elems, old_size, new_size);
+        if (UNLIKELY(!new_mem)) {
+            FatalErrorExit("gitlab.out_of_memory  field:gitlab.FProject.c_mr");
+        }
+        project.c_mr_elems = (gitlab::FMr**)new_mem;
+        project.c_mr_max = new_max;
+    }
+}
+
+// --- gitlab.FProject..Uninit
+void gitlab::FProject_Uninit(gitlab::FProject& project) {
+    gitlab::FProject &row = project; (void)row;
+    ind_project_Remove(row); // remove project from index ind_project
+
+    // gitlab.FProject.c_mr.Uninit (Ptrary)  //
+    algo_lib::malloc_FreeMem(project.c_mr_elems, sizeof(gitlab::FMr*)*project.c_mr_max); // (gitlab.FProject.c_mr)
+
+    // gitlab.FProject.c_issue.Uninit (Ptrary)  //
+    algo_lib::malloc_FreeMem(project.c_issue_elems, sizeof(gitlab::FIssue*)*project.c_issue_max); // (gitlab.FProject.c_issue)
+}
+
+// --- gitlab.FUser.base.CopyOut
+// Copy fields out of row
+void gitlab::user_CopyOut(gitlab::FUser &row, gitlab::User &out) {
+    out.user = row.user;
+    out.id = row.id;
+    out.name = row.name;
+}
+
+// --- gitlab.FUser.base.CopyIn
+// Copy fields in to row
+void gitlab::user_CopyIn(gitlab::FUser &row, gitlab::User &in) {
+    row.user = in.user;
+    row.id = in.id;
+    row.name = in.name;
+}
+
+// --- gitlab.FUser..Uninit
+void gitlab::FUser_Uninit(gitlab::FUser& user) {
+    gitlab::FUser &row = user; (void)row;
+    ind_user_Remove(row); // remove user from index ind_user
+}
+
+// --- gitlab.FieldId.value.ToCstr
+// Convert numeric value of field to one of predefined string constants.
+// If string is found, return a static C string. Otherwise, return NULL.
+const char* gitlab::value_ToCstr(const gitlab::FieldId& parent) {
+    const char *ret = NULL;
+    switch(value_GetEnum(parent)) {
+        case gitlab_FieldId_value          : ret = "value";  break;
+    }
+    return ret;
+}
+
+// --- gitlab.FieldId.value.Print
+// Convert value to a string. First, attempt conversion to a known string.
+// If no string matches, print value as a numeric value.
+void gitlab::value_Print(const gitlab::FieldId& parent, algo::cstring &lhs) {
+    const char *strval = value_ToCstr(parent);
+    if (strval) {
+        lhs << strval;
+    } else {
+        lhs << parent.value;
+    }
+}
+
+// --- gitlab.FieldId.value.SetStrptrMaybe
+// Convert string to field.
+// If the string is invalid, do not modify field and return false.
+// In case of success, return true
+bool gitlab::value_SetStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) {
+    bool ret = false;
+    switch (elems_N(rhs)) {
+        case 5: {
+            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
+                case LE_STR5('v','a','l','u','e'): {
+                    value_SetEnum(parent,gitlab_FieldId_value); ret = true; break;
+                }
+            }
+            break;
+        }
+    }
+    return ret;
+}
+
+// --- gitlab.FieldId.value.SetStrptr
+// Convert string to field.
+// If the string is invalid, set numeric value to DFLT
+void gitlab::value_SetStrptr(gitlab::FieldId& parent, algo::strptr rhs, gitlab_FieldIdEnum dflt) {
+    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
+}
+
+// --- gitlab.FieldId.value.ReadStrptrMaybe
+// Convert string to field. Return success value
+bool gitlab::value_ReadStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) {
+    bool retval = false;
+    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
+    if (!retval) { // didn't work? try reading as underlying type
+        retval = i32_ReadStrptrMaybe(parent.value,rhs);
+    }
+    return retval;
+}
+
+// --- gitlab.FieldId..ReadStrptrMaybe
+// Read fields of gitlab::FieldId from an ascii string.
+// The format of the string is the format of the gitlab::FieldId's only field
+bool gitlab::FieldId_ReadStrptrMaybe(gitlab::FieldId &parent, algo::strptr in_str) {
+    bool retval = true;
+    retval = retval && gitlab::value_ReadStrptrMaybe(parent, in_str);
+    return retval;
+}
+
+// --- gitlab.FieldId..Print
+// print string representation of gitlab::FieldId to string LHS, no header -- cprint:gitlab.FieldId.String
+void gitlab::FieldId_Print(gitlab::FieldId & row, algo::cstring &str) {
+    gitlab::value_Print(row, str);
+}
+
+// --- gitlab.Issue.project.Get
+algo::Smallstr50 gitlab::project_Get(gitlab::Issue& parent) {
+    algo::Smallstr50 ret(algo::Pathcomp(parent.issue, ".RL"));
+    return ret;
+}
+
+// --- gitlab.Issue.iid.Get
+u32 gitlab::iid_Get(gitlab::Issue& parent) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.issue, ".RR"));
+    return ret;
+}
+
+// --- gitlab.Issue..Concat_project_iid
+tempstr gitlab::Issue_Concat_project_iid( const algo::strptr& project ,u32 iid ) {
+    return tempstr() << project <<'.'<< iid ;
+}
+
+// --- gitlab.Issue..Print
+// print string representation of gitlab::Issue to string LHS, no header -- cprint:gitlab.Issue.String
+void gitlab::Issue_Print(gitlab::Issue & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.Issue";
+
+    algo::Smallstr50_Print(row.issue, temp);
+    PrintAttrSpaceReset(str,"issue", temp);
+
+    algo::Smallstr50_Print(row.assignee, temp);
+    PrintAttrSpaceReset(str,"assignee", temp);
+
+    algo::cstring_Print(row.title, temp);
+    PrintAttrSpaceReset(str,"title", temp);
+}
+
+// --- gitlab.IssueDescription..Print
+// print string representation of gitlab::IssueDescription to string LHS, no header -- cprint:gitlab.IssueDescription.String
+void gitlab::IssueDescription_Print(gitlab::IssueDescription & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.IssueDescription";
+
+    algo::Smallstr50_Print(row.issue, temp);
+    PrintAttrSpaceReset(str,"issue", temp);
+
+    algo::cstring_Print(row.description, temp);
+    PrintAttrSpaceReset(str,"description", temp);
+}
+
+// --- gitlab.IssueNote.issue.Get
+algo::Smallstr50 gitlab::issue_Get(gitlab::IssueNote& parent) {
+    algo::Smallstr50 ret(algo::Pathcomp(parent.issue_note, ".RL"));
+    return ret;
+}
+
+// --- gitlab.IssueNote.id.Get
+u32 gitlab::id_Get(gitlab::IssueNote& parent) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.issue_note, ".RR"));
+    return ret;
+}
+
+// --- gitlab.IssueNote..Concat_issue_id
+tempstr gitlab::IssueNote_Concat_issue_id( const algo::strptr& issue ,u32 id ) {
+    return tempstr() << issue <<'.'<< id ;
+}
+
+// --- gitlab.IssueNote..Print
+// print string representation of gitlab::IssueNote to string LHS, no header -- cprint:gitlab.IssueNote.String
+void gitlab::IssueNote_Print(gitlab::IssueNote & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.IssueNote";
+
+    algo::Smallstr50_Print(row.issue_note, temp);
+    PrintAttrSpaceReset(str,"issue_note", temp);
+
+    algo::cstring_Print(row.body, temp);
+    PrintAttrSpaceReset(str,"body", temp);
+}
+
+// --- gitlab.Mr.project.Get
+algo::Smallstr50 gitlab::project_Get(gitlab::Mr& parent) {
+    algo::Smallstr50 ret(algo::Pathcomp(parent.mr, ".RL"));
+    return ret;
+}
+
+// --- gitlab.Mr.iid.Get
+u32 gitlab::iid_Get(gitlab::Mr& parent) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.mr, ".RR"));
+    return ret;
+}
+
+// --- gitlab.Mr..Concat_project_iid
+tempstr gitlab::Mr_Concat_project_iid( const algo::strptr& project ,u32 iid ) {
+    return tempstr() << project <<'.'<< iid ;
+}
+
+// --- gitlab.Mr..Print
+// print string representation of gitlab::Mr to string LHS, no header -- cprint:gitlab.Mr.String
+void gitlab::Mr_Print(gitlab::Mr & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.Mr";
+
+    algo::Smallstr50_Print(row.mr, temp);
+    PrintAttrSpaceReset(str,"mr", temp);
+
+    algo::cstring_Print(row.title, temp);
+    PrintAttrSpaceReset(str,"title", temp);
+
+    algo::cstring_Print(row.source_branch, temp);
+    PrintAttrSpaceReset(str,"source_branch", temp);
+
+    algo::Smallstr20_Print(row.pipeline_status, temp);
+    PrintAttrSpaceReset(str,"pipeline_status", temp);
+}
+
+// --- gitlab.MrDescription..Print
+// print string representation of gitlab::MrDescription to string LHS, no header -- cprint:gitlab.MrDescription.String
+void gitlab::MrDescription_Print(gitlab::MrDescription & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.MrDescription";
+
+    algo::Smallstr50_Print(row.mr, temp);
+    PrintAttrSpaceReset(str,"mr", temp);
+
+    algo::cstring_Print(row.description, temp);
+    PrintAttrSpaceReset(str,"description", temp);
+}
+
+// --- gitlab.MrNote.mr.Get
+algo::Smallstr50 gitlab::mr_Get(gitlab::MrNote& parent) {
+    algo::Smallstr50 ret(algo::Pathcomp(parent.mr_note, ".RL"));
+    return ret;
+}
+
+// --- gitlab.MrNote.id.Get
+u32 gitlab::id_Get(gitlab::MrNote& parent) {
+    u32 ret;
+    ret = 0; // default value
+    (void)u32_ReadStrptrMaybe(ret, algo::Pathcomp(parent.mr_note, ".RR"));
+    return ret;
+}
+
+// --- gitlab.MrNote..Concat_mr_id
+tempstr gitlab::MrNote_Concat_mr_id( const algo::strptr& mr ,u32 id ) {
+    return tempstr() << mr <<'.'<< id ;
+}
+
+// --- gitlab.MrNote..Print
+// print string representation of gitlab::MrNote to string LHS, no header -- cprint:gitlab.MrNote.String
+void gitlab::MrNote_Print(gitlab::MrNote & row, algo::cstring &str) {
+    algo::tempstr temp;
+    str << "gitlab.MrNote";
+
+    algo::Smallstr50_Print(row.mr_note, temp);
+    PrintAttrSpaceReset(str,"mr_note", temp);
+
+    algo::cstring_Print(row.body, temp);
+    PrintAttrSpaceReset(str,"body", temp);
+}
+
+// --- gitlab.TableId.value.ToCstr
+// Convert numeric value of field to one of predefined string constants.
+// If string is found, return a static C string. Otherwise, return NULL.
+const char* gitlab::value_ToCstr(const gitlab::TableId& parent) {
+    const char *ret = NULL;
+    switch(value_GetEnum(parent)) {
+        case gitlab_TableId_dev_GitlabProject: ret = "dev.GitlabProject";  break;
+    }
+    return ret;
+}
+
+// --- gitlab.TableId.value.Print
+// Convert value to a string. First, attempt conversion to a known string.
+// If no string matches, print value as a numeric value.
+void gitlab::value_Print(const gitlab::TableId& parent, algo::cstring &lhs) {
+    const char *strval = value_ToCstr(parent);
+    if (strval) {
+        lhs << strval;
+    } else {
+        lhs << parent.value;
+    }
+}
+
+// --- gitlab.TableId.value.SetStrptrMaybe
+// Convert string to field.
+// If the string is invalid, do not modify field and return false.
+// In case of success, return true
+bool gitlab::value_SetStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) {
+    bool ret = false;
+    switch (elems_N(rhs)) {
+        case 17: {
+            switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('d','e','v','.','G','i','t','l'): {
+                    if (memcmp(rhs.elems+8,"abProject",9)==0) { value_SetEnum(parent,gitlab_TableId_dev_GitlabProject); ret = true; break; }
+                    break;
+                }
+            }
+            break;
+        }
+        case 18: {
+            switch (algo::ReadLE64(rhs.elems)) {
+                case LE_STR8('d','e','v','.','g','i','t','l'): {
+                    if (memcmp(rhs.elems+8,"ab_project",10)==0) { value_SetEnum(parent,gitlab_TableId_dev_gitlab_project); ret = true; break; }
+                    break;
+                }
+            }
+            break;
+        }
+    }
+    return ret;
+}
+
+// --- gitlab.TableId.value.SetStrptr
+// Convert string to field.
+// If the string is invalid, set numeric value to DFLT
+void gitlab::value_SetStrptr(gitlab::TableId& parent, algo::strptr rhs, gitlab_TableIdEnum dflt) {
+    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
+}
+
+// --- gitlab.TableId.value.ReadStrptrMaybe
+// Convert string to field. Return success value
+bool gitlab::value_ReadStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) {
+    bool retval = false;
+    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
+    if (!retval) { // didn't work? try reading as underlying type
+        retval = i32_ReadStrptrMaybe(parent.value,rhs);
+    }
+    return retval;
+}
+
+// --- gitlab.TableId..ReadStrptrMaybe
+// Read fields of gitlab::TableId from an ascii string.
+// The format of the string is the format of the gitlab::TableId's only field
+bool gitlab::TableId_ReadStrptrMaybe(gitlab::TableId &parent, algo::strptr in_str) {
+    bool retval = true;
+    retval = retval && gitlab::value_ReadStrptrMaybe(parent, in_str);
+    return retval;
+}
+
+// --- gitlab.TableId..Print
+// print string representation of gitlab::TableId to string LHS, no header -- cprint:gitlab.TableId.String
+void gitlab::TableId_Print(gitlab::TableId & row, algo::cstring &str) {
+    gitlab::value_Print(row, str);
+}
+
+// --- gitlab...main
+int main(int argc, char **argv) {
+    try {
+        lib_json::FDb_Init();
+        algo_lib::FDb_Init();
+        gitlab::FDb_Init();
+        algo_lib::_db.argc = argc;
+        algo_lib::_db.argv = argv;
+        algo_lib::IohookInit();
+        gitlab::MainArgs(algo_lib::_db.argc,algo_lib::_db.argv); // dmmeta.main:gitlab
+    } catch(algo_lib::ErrorX &x) {
+        prerr("gitlab.error  " << x); // there may be additional hints in DetachBadTags
+        algo_lib::_db.exit_code = 1;
+    }
+    if (algo_lib::_db.last_signal) {
+        algo_lib::_db.exit_code = 1;
+    }
+    try {
+        gitlab::FDb_Uninit();
+        algo_lib::FDb_Uninit();
+        lib_json::FDb_Uninit();
+    } catch(algo_lib::ErrorX &) {
+        // don't print anything, might crash
+        algo_lib::_db.exit_code = 1;
+    }
+    // only the lower 1 byte makes it to the outside world
+    (void)i32_UpdateMin(algo_lib::_db.exit_code,255);
+    return algo_lib::_db.exit_code;
+}
+
+// --- gitlab...SizeCheck
+inline static void gitlab::SizeCheck() {
+}
diff --git a/cpp/gitlab.cpp b/cpp/gitlab.cpp
new file mode 100644
index 000000000..e03d3c9af
--- /dev/null
+++ b/cpp/gitlab.cpp
@@ -0,0 +1,1119 @@
+//
+// Target: gitlab (exe) -- Gitlab command line interface
+// Exceptions: yes
+// Source: cpp/gitlab.cpp
+//
+
+#include "include/algo.h"
+#include "include/gitlab.h"
+
+#include <curl/curl.h>
+
+// -----------------------------------------------------------------------------
+
+// Clear all response fields for request reuse case
+static void ClearResponse(gitlab::FHttp &http) {
+    http.response_status_line = strptr();
+    http.response_status_code = 0;
+    http.response_reason_phrase = strptr();
+    response_header_RemoveAll(http);
+    http.response_content_type = strptr();
+    http.response_body = strptr();
+    http.response_content_type_json = false;
+
+    // ugly hack as operator= is forbidden,
+    // Uninit and Init calls do not deal with child structures
+    http.response_json_parser.~FParser(); // call destructor
+    new (&http.response_json_parser) lib_json::FParser(); // call placement new
+}
+
+// -----------------------------------------------------------------------------
+
+// Curl write callback fuction
+static size_t CurlWrite(char *ptr, size_t size, size_t nmemb, void *userdata) {
+    vrfy_(userdata);
+    gitlab::FHttp &http = *(gitlab::FHttp *)userdata;
+    strptr chunk(ptr,size*nmemb);
+    if (http.response_content_type_json) {
+        JsonParse(http.response_json_parser,chunk);
+    } else {
+        http.response_body << chunk;
+    }
+    return size*nmemb;
+}
+
+// -----------------------------------------------------------------------------
+
+// Curl header calback function, also called for status line
+static size_t CurlHeader(char *ptr, size_t size, size_t nmemb, void *userdata) {
+    vrfy_(userdata);
+    gitlab::FHttp &http = *(gitlab::FHttp *)userdata;
+    strptr header(ptr,size*nmemb);
+    if (!http.response_status_line.ch_n || http.response_status_code == 100) {
+        // store status line
+        http.response_status_line = Trimmed(header);
+        // parse status line
+        algo::StringIter it(http.response_status_line);
+        GetWordCharf(it); //skip HTTP-Version
+        TryParseU32(it,http.response_status_code); // Status-Code
+        http.response_reason_phrase = Trimmed(it.Rest());// Reason-Phrase
+    } else {
+        // add header
+        response_header_Alloc(http) = Trimmed(header);
+        // check content-type
+        strptr name = Trimmed(Pathcomp(header,":LL"));
+        strptr value = Trimmed(Pathcomp(header,":LR"));
+        if (!CompareNoCase(name,"Content-Type")) {
+            http.response_content_type = value;
+            http.response_content_type_json = !CompareNoCase(value,"application/json");
+        }
+    }
+    return size*nmemb;
+}
+
+// -----------------------------------------------------------------------------
+
+// Curl header calback function, also called for status line
+static size_t CurlRead(char *ptr, size_t size, size_t nmemb, void *userdata) {
+    vrfy_(userdata);
+    gitlab::FHttp &http = *(gitlab::FHttp *)userdata;
+    u32 requested_bytes = size*nmemb;
+    u32 available_bytes = http.request_body.ch_n-http.request_body_sent_bytes;
+    u32 returned_bytes  = u32_Min(available_bytes,requested_bytes);
+    memcpy(ptr,http.request_body.ch_elems+http.request_body_sent_bytes,returned_bytes);
+    http.request_body_sent_bytes+=returned_bytes;
+    return returned_bytes;
+}
+
+// -----------------------------------------------------------------------------
+
+#define curl_vrfy_(res)                                                 \
+    do {                                                                \
+        CURLcode res_copy(res);                                         \
+        vrfy(res_copy==CURLE_OK,tempstr()<<(#res)<<": "<<curl_easy_strerror(res_copy)); \
+    } while (0)
+
+// -----------------------------------------------------------------------------
+
+static void CurlExec(gitlab::FHttp &http) {
+    ClearResponse(http);
+
+    // Form headers:
+    // note, curl does not copy values for itself,
+    // so keep this structure unchanged!
+    curl_slist *hdr(NULL);
+    ind_beg(gitlab::FHttp_request_header_curs,rh,http){
+        vrfy_(hdr=curl_slist_append(hdr,Zeroterm(rh)));
+    }ind_end;
+
+    CURL *curl;
+    vrfy_(curl = curl_easy_init());
+
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_HTTPHEADER,hdr));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_URL, Zeroterm(http.request_uri)));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L));
+    if (algo_lib::_db.cmdline.debug) {
+        curl_vrfy_(curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L));
+    }
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWrite));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_WRITEDATA, &http));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, CurlHeader));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_HEADERDATA, &http));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_READFUNCTION, CurlRead));
+    curl_vrfy_(curl_easy_setopt(curl, CURLOPT_READDATA, &http));
+    switch (http.request_method) {
+    case gitlab_FHttp_request_method_GET:
+        // this is the default
+        break;
+    case gitlab_FHttp_request_method_POST:
+        curl_vrfy_(curl_easy_setopt(curl, CURLOPT_POST, 1L));
+        break;
+    case gitlab_FHttp_request_method_PUT:
+        curl_vrfy_(curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L));
+        break;
+    default:
+        vrfy(0,tempstr()<<"Unsupported HTTP method: " << http.request_method);
+    }
+
+    curl_vrfy_(curl_easy_perform(curl));
+
+    curl_slist_free_all(hdr);
+    curl_easy_cleanup(curl);
+
+    // print debug output
+    if (algo_lib::_db.cmdline.debug) {
+        // params
+        dbglog(http);
+        // headers
+        ind_beg(gitlab::FHttp_response_header_curs,rh,http){
+            dbglog(rh);
+        }ind_end;
+        // json
+        if (http.response_json_parser.root_node) {
+            cstring out;
+            JsonSerialize(http.response_json_parser.root_node,out,true);
+            dbglog(out);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------------
+
+static tempstr GetResponseHeaderValue(gitlab::FHttp &http, strptr search_name) {
+    tempstr out;
+    ind_beg(gitlab::FHttp_response_header_curs,hdr,http) {
+        strptr name = Trimmed(Pathcomp(hdr,":LL"));
+        if (StrEqual(name,search_name,false)) {
+            out = Trimmed(Pathcomp(hdr,":LR"));
+            break;
+        }
+    }ind_end;
+    return out;
+}
+
+// -----------------------------------------------------------------------------
+
+// Manage environment variables: USER,HOME,EDITOR
+static void Main_ManageEnv() {
+    gitlab::_db.unix_user = getenv("USER");
+    gitlab::_db.home = getenv("HOME");
+    gitlab::_db.editor = getenv("EDITOR");
+
+    bool need_editor = gitlab::_db.cmdline.iadd;
+
+    vrfy(gitlab::_db.unix_user.ch_n,"Your USER environment variable has not been set");
+    vrfy(gitlab::_db.home.ch_n,"Your HOME environment variable has not been set");
+    vrfy(!need_editor || gitlab::_db.editor.ch_n, "Your environment variable EDITOR has not been set");
+}
+
+// -----------------------------------------------------------------------------
+
+// Prepare authorization header:
+// Manage -auth_token option, $HOME/.auth_token file.
+
+static void Main_ManageAuth() {
+    // auth token
+    gitlab::_db.auth_file = DirFileJoin(gitlab::_db.home, gitlab::_db.auth_file_name);
+    gitlab::_db.auth_token = Trimmed(gitlab::_db.cmdline.auth_token);
+    if (gitlab::_db.cmdline.auth_token.ch_n) {
+        // case where token is supplied via command line
+        vrfy_(StringToFile(gitlab::_db.auth_token,gitlab::_db.auth_file,algo::FileFlags(),false));
+        errno_vrfy_(!chmod(Zeroterm(gitlab::_db.auth_file),0600));
+    } else if (FileQ(gitlab::_db.auth_file)) {
+        // case where token is read from file
+        gitlab::_db.auth_token = Trimmed(FileToString(gitlab::_db.auth_file));
+    }
+    vrfy(gitlab::_db.auth_token.ch_n, gitlab::_db.usrmsg_no_token);
+    // prepare http authorization header
+    gitlab::_db.http_auth_header << "Authorization: Bearer " << gitlab::_db.auth_token;
+}
+
+// -----------------------------------------------------------------------------
+
+// prepare API URI as base to add resource parts:
+// process server option
+static void Main_ManageServer() {
+    gitlab::_db.rest_api << "https://" << gitlab::_db.cmdline.server << "/api/v4";
+}
+
+// -----------------------------------------------------------------------------
+
+// Get numeric project id
+static void Main_ManageProject() {
+    gitlab::FProject *project = gitlab::ind_project_Find(gitlab::_db.cmdline.project);
+    vrfy(project, tempstr() << "Can't find project:" << gitlab::_db.cmdline.project);
+    gitlab::_db.project_id = project->gitlab_project_id;
+}
+
+// -----------------------------------------------------------------------------
+
+static void LoadIssueNotes(gitlab::FIssue &issue) {
+    cstring page("1");
+    do {
+        // prepare REST request
+        gitlab::FHttp http;
+        http.request_uri << gitlab::_db.rest_api
+                         << "/projects/" << gitlab::_db.project_id
+                         <<"/issues/" << iid_Get(issue)
+                         << "/notes?per_page=100&page="<<page;
+        request_header_Alloc(http) << gitlab::_db.http_auth_header;
+        request_header_Alloc(http) << "Accept: application/json";
+
+        // execute request
+        CurlExec(http);
+
+        // prechecks on output
+        vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+             << http.response_status_line);
+        vrfy_(http.response_json_parser.root_node);
+        vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_array);
+
+        // load into database
+        ind_beg(lib_json::node_c_child_curs,issue_obj,*http.response_json_parser.root_node){
+            vrfy_(issue_obj.type == lib_json_FNode_type_object);
+
+            gitlab::IssueNote note;
+            note.issue_note = gitlab::Issue_Concat_project_iid(issue.issue, u32_Get(&issue_obj,"id"));
+            note.body = strptr_Get(&issue_obj,"body");
+
+            vrfy_(gitlab::issue_note_InsertMaybe(note));
+        }ind_end;
+        page = GetResponseHeaderValue(http,"x-next-page");
+    } while (page != "");
+}
+
+// -----------------------------------------------------------------------------
+
+// load specific issue
+static gitlab::FIssue *LoadIssueMaybe(u32 iid) {
+    // prepare REST request
+    gitlab::FHttp http;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/issues/" << iid;
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+    request_header_Alloc(http) << "Accept: application/json";
+
+    // execute request
+    CurlExec(http);
+
+    if (http.response_status_code == 404) {
+        return NULL;
+    }
+
+    // prechecks on output
+    vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+    vrfy_(http.response_json_parser.root_node);
+    lib_json::FNode &issue_obj = *http.response_json_parser.root_node;
+    vrfy_(issue_obj.type == lib_json_FNode_type_object);
+
+    gitlab::Issue issue;
+    issue.issue = tempstr() << gitlab::_db.cmdline.project << "." << u32_Get(&issue_obj,"iid");
+    issue.title = strptr_Get(&issue_obj,"title");
+
+    gitlab::FIssue *fissue = gitlab::issue_InsertMaybe(issue);
+    vrfy_(fissue);
+
+    gitlab::IssueDescription issue_description;
+    issue_description.issue = issue.issue;
+    issue_description.description = strptr_Get(&issue_obj,"description");
+
+    vrfy_(gitlab::issue_description_InsertMaybe(issue_description));
+
+    return fissue;
+}
+
+// -----------------------------------------------------------------------------
+
+// Read list of issues from gitlab
+// and populate _db.issue, _db.issue_desecription tables
+static void Main_LoadIssueList() {
+    cstring page("1");
+    do {
+        // prepare REST request
+        gitlab::FHttp http;
+        http.request_uri << gitlab::_db.rest_api
+                         << "/projects/" << gitlab::_db.project_id
+                         << "/issues?state=opened&per_page=100&page="<<page;
+        request_header_Alloc(http) << gitlab::_db.http_auth_header;
+        request_header_Alloc(http) << "Accept: application/json";
+
+        // execute request
+        CurlExec(http);
+
+        // prechecks on output
+        vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+             << http.response_status_line);
+        vrfy_(http.response_json_parser.root_node);
+        vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_array);
+
+        // load into database
+        ind_beg(lib_json::node_c_child_curs,issue_obj,*http.response_json_parser.root_node){
+            vrfy_(issue_obj.type == lib_json_FNode_type_object);
+
+            gitlab::Issue issue;
+            issue.issue = gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project, u32_Get(&issue_obj,"iid"));
+            issue.assignee = strptr_Get(&issue_obj,"assignee.username");
+            issue.title = strptr_Get(&issue_obj,"title");
+
+            vrfy_(gitlab::issue_InsertMaybe(issue));
+
+            gitlab::IssueDescription issue_description;
+            issue_description.issue = issue.issue;
+            issue_description.description = strptr_Get(&issue_obj,"description");
+
+            vrfy_(gitlab::issue_description_InsertMaybe(issue_description));
+        }ind_end;
+        page = GetResponseHeaderValue(http,"x-next-page");
+    } while (page != "");
+}
+
+// -----------------------------------------------------------------------------
+
+// Display contents of _db.issue, _db.issue_description, _db.issue_note tables
+// In column view (default) or tree view
+static void Main_ShowIssueList() {
+    // mark selected issues
+    int nmatch=0;
+    ind_beg(gitlab::_db_issue_curs, issue, gitlab::_db) {
+        issue.select = algo_lib::Regx_Match(gitlab::_db.cmdline.issue, issue.issue)
+            || EndsWithQ(issue.issue, gitlab::_db.cmdline.issue.expr);
+        // if -assignee and -issue were ommitted,
+        // filter issues to include only unassigned ones, and ones assigned to current user
+        // otherwise, match assignee as a regular regx
+        if (gitlab::_db.cmdline.assignee.expr == "" && gitlab::_db.cmdline.issue.expr == "") {
+            issue.select = issue.select && (issue.assignee=="" || issue.assignee==gitlab::_db.unix_user);
+        } else if (gitlab::_db.cmdline.assignee.expr != "") {
+            issue.select = issue.select &&  Regx_Match(gitlab::_db.cmdline.assignee, issue.assignee);
+        }
+        nmatch += issue.select;
+    }ind_end;
+
+    // load comments for selected issues
+    ind_beg(gitlab::_db_issue_curs, issue, gitlab::_db) {
+        if (gitlab::_db.cmdline.t && issue.select) {
+            LoadIssueNotes(issue);
+        }
+    }ind_end;
+
+    if (gitlab::_db.cmdline.t) {
+        // tree view
+        ind_beg(gitlab::_db_issue_curs, issue, gitlab::_db) if (issue.select) {
+            gitlab::Issue out;
+            issue_CopyOut(issue,out);
+            prlog(out);
+            cstring str;
+            str << "\n";
+            InsertIndent(str,issue.c_issue_description->description,1);
+            str << "\n";
+
+            ind_beg(gitlab::issue_c_issue_note_curs, note, issue){
+                InsertIndent(str,tempstr() << "gitlab.issue_note issue_note:" << note.issue_note,2);
+                str << "\n\n";
+                InsertIndent(str,note.body,3);
+                str << "\n";
+            }ind_end;
+
+            prlog(str);
+        }ind_end;
+    } else {
+        cstring out;
+        out << "ISSUE\tASSIGNEE\tTITLE\n";
+        ind_beg(gitlab::_db_issue_curs, issue, gitlab::_db) if (issue.select) {
+            out << issue.issue
+                << "\t" << issue.assignee
+                << "\t" << issue.title
+                << eol;
+        }ind_end;
+        prlog(Tabulated(out,"\t"));
+    }
+}
+
+// -----------------------------------------------------------------------------
+
+// Load merge request for particular branch
+static u32 CountMrForBranch(strptr branch) {
+    u32 count = 0;
+    cstring page("1");
+    do {
+        // prepare REST request
+        gitlab::FHttp http;
+        http.request_uri << gitlab::_db.rest_api
+                         << "/projects/" << gitlab::_db.project_id
+                         << "/merge_requests/"
+                         << "?source_branch=" << branch
+                         << "&state=opened&per_page=100&page="<<page;
+        request_header_Alloc(http) << gitlab::_db.http_auth_header;
+        request_header_Alloc(http) << "Accept: application/json";
+
+        // execute request
+        CurlExec(http);
+
+        // prechecks on output
+        vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+             << http.response_status_line);
+        vrfy_(http.response_json_parser.root_node);
+        vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_array);
+
+        ind_beg(lib_json::node_c_child_curs,mr_obj,*http.response_json_parser.root_node){
+            vrfy_(mr_obj.type == lib_json_FNode_type_object);
+#if 0 // -- for future
+            gitlab::Mr mr;
+            mr.mr = tempstr() << gitlab::Issue_Concat_project_iid(_db.cmdline.project, u32_Get(&mr_obj,"iid"));
+            mr.title = strptr_Get(&mr_obj,"title");
+
+            vrfy_(gitlab::mr_InsertMaybe(mr));
+
+            gitlab::MrDescription mr_description;
+            mr_description.mr = mr.mr;
+            mr_description.description = strptr_Get(&mr_obj,"description");
+
+            vrfy_(gitlab::mr_description_InsertMaybe(mr_description));
+#endif
+            ++count;
+        }ind_end;
+        page = GetResponseHeaderValue(http,"x-next-page");
+    } while (page != "");
+
+    return count;
+}
+
+// when getting one mr, there much more information than in getting mr list
+static void LoadMrDetails(gitlab::FMr &mr) {
+    // prepare REST request
+    gitlab::FHttp http;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/merge_requests/" << iid_Get(mr);
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+    request_header_Alloc(http) << "Accept: application/json";
+
+    // execute request
+    CurlExec(http);
+
+    // prechecks on output
+    vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+
+    lib_json::FNode &mr_obj = *http.response_json_parser.root_node;
+    mr.source_branch = strptr_Get(&mr_obj,"source_branch");
+    mr.pipeline_status = strptr_Get(&mr_obj,"head_pipeline.status");
+}
+
+// load list of merge requests
+static void Main_LoadMrList() {
+    cstring page("1");
+    do {
+        // prepare REST request
+        gitlab::FHttp http;
+        http.request_uri << gitlab::_db.rest_api
+                         << "/projects/" << gitlab::_db.project_id
+                         << "/merge_requests?view=simple&state=opened&per_page=100&page="<<page;
+        request_header_Alloc(http) << gitlab::_db.http_auth_header;
+        request_header_Alloc(http) << "Accept: application/json";
+
+        // execute request
+        CurlExec(http);
+
+        // prechecks on output
+        vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+             << http.response_status_line);
+        vrfy_(http.response_json_parser.root_node);
+        vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_array);
+
+        // format output
+        ind_beg(lib_json::node_c_child_curs,mr_obj,*http.response_json_parser.root_node){
+            vrfy_(mr_obj.type == lib_json_FNode_type_object);
+            u32 iid = u32_Get(&mr_obj,"iid");
+            strptr title = strptr_Get(&mr_obj,"title");
+            gitlab::Mr mr;
+            mr.mr = gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project, iid);
+            mr.title = title;
+            gitlab::mr_InsertMaybe(mr);
+        }ind_end;
+
+        // load details
+        ind_beg(gitlab::_db_mr_curs, mr, gitlab::_db) {
+            LoadMrDetails(mr);
+        }ind_end;
+        page = GetResponseHeaderValue(http,"x-next-page");
+    } while (page != "");
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoShowMrList() {
+    cstring out;
+    out << "MR\tS-BRANCH\tPIPELINE\tTITLE\n";
+    ind_beg(gitlab::_db_mr_curs, mr, gitlab::_db) {
+        out << mr.mr
+            << "\t" << mr.source_branch
+            << "\t" << mr.pipeline_status
+            << "\t" << mr.title
+            << eol;
+    }ind_end;
+    prlog(Tabulated(out,"\t"));
+}
+
+// -----------------------------------------------------------------------------
+
+static u32 GetCurrentUserId() {
+    // prepare REST request
+    gitlab::FHttp http;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/user";
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+    request_header_Alloc(http) << "Accept: application/json";
+
+    // execute request
+    CurlExec(http);
+
+    // prechecks on output
+    vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+
+    lib_json::FNode &user_obj = *http.response_json_parser.root_node;
+    u32 current_user_id = u32_Get(&user_obj,"id");
+    vrfy_(current_user_id>0);
+    return current_user_id;;
+}
+
+// -----------------------------------------------------------------------------
+
+// Function length exception - for now keep it as is --
+// it is quite linear and understandable.
+// For further, I separete edit, execution, and printing parts
+static void Main_DoIssueAdd() {
+    u32 current_user_id = GetCurrentUserId();
+
+    cstring file;
+    cstring title(gitlab::_db.cmdline.title);
+    cstring description(gitlab::_db.cmdline.description);
+    if (!title.ch_n) {
+        vrfy_(gitlab::_db.editor.ch_n);
+        file = DirFileJoin(gitlab::_db.home,".gitlab_issue");
+        if (!FileQ(file)) {
+            cstring tpl;
+            tpl <<
+                "WIP: The first line is issue title\n"
+                "\n"
+                "Subsequent lines are issue description.\n"
+                "\n"
+                "Keep WIP: if writing has not yet been finished,"
+                " you can save, exit, and continue later.\n"
+                "\n"
+                "Once finished, remove WIP: to submit the issue.\n";
+
+            vrfy_(StringToFile(tpl,file,algo::FileFlags(),false));
+        }
+        cstring cmdline;
+
+        cmdline << gitlab::_db.editor << " " << file;
+        SysCmd(cmdline, FailokQ(false), DryrunQ(false));
+
+        cstring text(Trimmed(FileToString(file)));
+        title = Trimmed(Pathcomp(text,"\nLL"));
+        description = Trimmed(Pathcomp(text,"\nLR"));
+    }
+    vrfy(title.ch_n,"Issue title is empty");
+    // allow empty description
+    //vrfy(description.ch_n,"Issue description is empty");
+
+    if (StartsWithQ(title,"WIP:")) {
+        prlog("Issue has not been submitted, you can continue composing it.");
+        return;
+    }
+
+    // prepare REST request
+    gitlab::FHttp http;
+
+    http.request_method = gitlab_FHttp_request_method_POST;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/issues";
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+    request_header_Alloc(http) << "Accept: application/json";
+    request_header_Alloc(http) << "Content-Type: application/json";
+
+    lib_json::FNode &obj = lib_json::NewObjectNode(NULL);
+    lib_json::NewStringNode(&obj,"title",title);
+    lib_json::NewStringNode(&obj,"description",description);
+    lib_json::NewNumberNode(&obj,"assignee_id",tempstr()<<current_user_id);
+    lib_json::JsonSerialize(&obj,http.request_body);
+
+    // execute request
+    CurlExec(http);
+
+    vrfy(http.response_status_code == 201, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+
+    // consider operation successful, remove file
+    if (file.ch_n) {
+        unlink(Zeroterm(file));
+    }
+
+    // fill data from response
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+    lib_json::FNode &issue_obj = *http.response_json_parser.root_node;
+
+    // print result
+    gitlab::Issue issue;
+    issue.issue = tempstr() << gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project, u32_Get(&issue_obj,"iid"));
+    issue.title = strptr_Get(&issue_obj,"title");
+    issue.assignee = strptr_Get(&issue_obj,"assignee.username");
+    prlog(issue);
+    cstring str;
+    str << "\n";
+    InsertIndent(str,strptr_Get(&issue_obj,"description"),1);
+    str << "\n";
+    prlog(str);
+
+    // Assign command line argument to make possible further operations in one shot
+    gitlab::_db.cmdline.issue.expr = issue.issue;
+}
+
+// -----------------------------------------------------------------------------
+
+static tempstr GitCmd(strptr gitcmd) {
+    tempstr cmd("git");
+    if (gitlab::_db.cmdline.gitdir.ch_n) {
+        cmd << " -C " << gitlab::_db.cmdline.gitdir;
+    }
+    cmd << " " << gitcmd;
+    return cmd;
+}
+
+// -----------------------------------------------------------------------------
+
+// Interpret -issue argument as a number, or specific issue id
+// gitlab -issue 33           --> return 33
+// gitlab -issue myproject.33 --> return 33
+// gitlab -issue %            --> return 0
+int gitlab::IssueArgNumber() {
+    strptr expr = Pathcomp(_db.cmdline.issue.expr, ".RR");
+    i32 ret=0;
+    i32_ReadStrptrMaybe(ret,expr);
+    return ret;
+}
+
+// -----------------------------------------------------------------------------
+
+// same for mr
+int gitlab::MrNumber(strptr in) {
+    strptr expr = Pathcomp(in, ".RR");
+    i32 ret=0;
+    i32_ReadStrptrMaybe(ret,expr);
+    return ret;
+}
+
+// -----------------------------------------------------------------------------
+
+u32 gitlab::GetUserId(strptr user) {
+    gitlab::FUser *fuser = gitlab::ind_user_Find(user);
+    return fuser ? fuser->id : 0;
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoIssueCommentAdd() {
+    cstring body(gitlab::_db.cmdline.comment);
+    bool use_editor = !body.ch_n;
+    int issuenum = gitlab::IssueArgNumber();
+    cstring file = DirFileJoin(gitlab::_db.home,".gitlab_issue_note");
+    if (use_editor) {
+        vrfy_(gitlab::_db.editor.ch_n);
+        cstring cmdline;
+        cmdline << gitlab::_db.editor << " " << file;
+        SysCmd(cmdline, FailokQ(false), DryrunQ(false));
+
+        body = Trimmed(FileToString(file,algo::FileFlags()));
+        vrfy(body.ch_n,"Issue note is empty");
+
+        if (StartsWithQ(body,"WIP:")) {
+            prlog("Issue note has not been submitted, you can continue composing it.");
+            return;
+        }
+    }
+
+    // prepare REST request
+    gitlab::FHttp http;
+
+    http.request_method = gitlab_FHttp_request_method_POST;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/issues/" << issuenum
+                     << "/notes";
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+    request_header_Alloc(http) << "Accept: application/json";
+    request_header_Alloc(http) << "Content-Type: application/json";
+
+    lib_json::FNode &obj = lib_json::NewObjectNode(NULL);
+    lib_json::NewStringNode(&obj,"body",body);
+    lib_json::JsonSerialize(&obj,http.request_body);
+
+    // execute request
+    CurlExec(http);
+
+    vrfy(http.response_status_code == 201, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+
+    // consider operation successful, remove file
+    if (use_editor) {
+        unlink(Zeroterm(file));
+    }
+
+    // fill data from response
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+    lib_json::FNode &issue_obj = *http.response_json_parser.root_node;
+
+    // print result
+    cstring issue_note;
+    issue_note << gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project,u32_Get(&issue_obj,"noteable_iid"))
+               << "."
+               << u32_Get(&issue_obj,"id");
+    cstring str;
+    InsertIndent(str,tempstr() << "gitlab.issue_note issue_note:" << issue_note,2);
+    str << "\n\n";
+    InsertIndent(str,strptr_Get(&issue_obj,"body"),3);
+    str << "\n";
+    prlog(str);
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoIssueClose() {
+    int issuenum = gitlab::IssueArgNumber();
+
+    // prepare REST request
+    gitlab::FHttp http;
+
+    http.request_method = gitlab_FHttp_request_method_PUT;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/issues/" << issuenum
+                     << "?state_event=close";
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+
+    // execute request
+    CurlExec(http);
+    vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+    lib_json::FNode &issue_obj = *http.response_json_parser.root_node;
+    strptr state = strptr_Get(&issue_obj,"state");
+
+    tempstr issue = gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project,issuenum);
+    vrfy(state == "closed", tempstr() << Keyval("issue",issue) << Keyval("state",state));
+    prlog("gitlab.success" << Keyval("issue",issue) << Keyval("state",state));
+}
+
+// -----------------------------------------------------------------------------
+
+static void LoadUsers() {
+    cstring page("1");
+    do {
+        // prepare REST request
+        gitlab::FHttp http;
+        http.request_uri << gitlab::_db.rest_api
+                         << "/users?active=true&per_page=100&page="<<page;
+        request_header_Alloc(http) << gitlab::_db.http_auth_header;
+        request_header_Alloc(http) << "Accept: application/json";
+
+        // execute request
+        CurlExec(http);
+
+        // prechecks on output
+        vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+             << http.response_status_line);
+        vrfy_(http.response_json_parser.root_node);
+        vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_array);
+
+        ind_beg(lib_json::node_c_child_curs,user_obj,*http.response_json_parser.root_node){
+            vrfy_(user_obj.type == lib_json_FNode_type_object);
+            gitlab::User user;
+            user.user = strptr_Get(&user_obj,"username");
+            user.id = u32_Get(&user_obj,"id");
+            user.name = strptr_Get(&user_obj,"name");
+            gitlab::user_InsertMaybe(user);
+        }ind_end;
+        page = GetResponseHeaderValue(http,"x-next-page");
+    } while (page != "");
+}
+
+// -----------------------------------------------------------------------------
+
+static void MaybeLoadUserList() {
+    if (!gitlab::user_N()) {
+        LoadUsers();
+    }
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_ShowUserList() {
+    cstring out;
+    out << "USER\tID\tNAME\n";
+    ind_beg(gitlab::_db_user_curs, user, gitlab::_db) {
+        out << user.user
+            << "\t" << user.id
+            << "\t" << user.name
+            << eol;
+    }ind_end;
+    prlog(Tabulated(out,"\t"));
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoIssueAssign() {
+    int issuenum = gitlab::IssueArgNumber();
+
+    u32 assignee_id = gitlab::GetUserId(gitlab::_db.cmdline.iassignto);
+    vrfy(assignee_id, tempstr() << "User " << gitlab::_db.cmdline.iassignto << " does not exist, see -ulist");
+
+    // prepare REST request
+    gitlab::FHttp http;
+
+    http.request_method = gitlab_FHttp_request_method_PUT;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/issues/" << issuenum
+                     << "?assignee_id=" << assignee_id;
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+
+    // execute request
+    CurlExec(http);
+    vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+    lib_json::FNode &issue_obj = *http.response_json_parser.root_node;
+    u32 id = u32_Get(&issue_obj,"assignee.id");
+    strptr username = strptr_Get(&issue_obj,"assignee.username");
+
+    tempstr issue = gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project,issuenum);
+    vrfy(id == assignee_id, tempstr() << Keyval("issue",issue) << Keyval("assignee",username));
+    prlog("gitlab.success" << Keyval("issue",issue) << Keyval("assignee",username));
+}
+
+// -----------------------------------------------------------------------------
+
+static void AssertGitWorkDirClean() {
+    bool clean = !SysCmd(GitCmd("update-index --refresh >/dev/null"), FailokQ(true), DryrunQ(false))
+        && !SysCmd(GitCmd("diff-index --quiet HEAD --"), FailokQ(true), DryrunQ(false));
+    vrfy(clean,"Working directory is not clean");
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoIssueStart() {
+    vrfy_(gitlab::_db.unix_user.ch_n);
+    vrfy(gitlab::_db.cmdline.issue.expr != "", "Please specify issue ID");
+    int issuenum = gitlab::IssueArgNumber();
+    tempstr issuekey = gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project, issuenum);
+    gitlab::FIssue *issue = LoadIssueMaybe(issuenum);
+    vrfy(issue,tempstr() << "Issue does not exist: " << issuekey);
+
+    cstring commit_comment;
+    commit_comment << "Issue #" << issuenum << " " << issue->title
+                   << "\n\n" << issue->c_issue_description->description;
+
+    AssertGitWorkDirClean();
+
+    SysCmd(GitCmd("fetch"), FailokQ(false), DryrunQ(false), algo_EchoQ_true);
+    tempstr co_cmd;
+    co_cmd << "checkout --no-track -b " << issuekey << " origin/master";
+    SysCmd(GitCmd(co_cmd), FailokQ(false), DryrunQ(false), algo_EchoQ_true);
+
+    // strptr_ToBash is broken, so using temp file
+    algo_lib::FTempfile tempfile;
+    TempfileInitX(tempfile,"gitlab");
+    StringToFile(commit_comment,tempfile.filename);
+    tempstr cmt_cmd;
+    cmt_cmd << "commit --allow-empty -F " << GetFullPath(tempfile.filename);
+    SysCmd(GitCmd(cmt_cmd), FailokQ(true), DryrunQ(false), algo_EchoQ_true);
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoMergeReq() {
+    AssertGitWorkDirClean();
+
+    // git branch --show-current doesn't work on older gits
+    cstring branch(SysEval(GitCmd("rev-parse --symbolic-full-name HEAD"), FailokQ(false), 1024));
+    // convert refs/heads/XX -> XX
+    // (use temp string to avoid assigning substrin to itself)
+    branch = tempstr() << Pathcomp(Trimmed(branch),"/RR");
+    vrfy_(branch != "master");
+    SysCmd(GitCmd("push origin HEAD -f"), FailokQ(false), DryrunQ(false), algo_EchoQ_true);
+    int n_mr = CountMrForBranch(branch);
+
+    if (n_mr) {
+        prlog("Merge request is already existing for this branch.");
+        prlog("No worry, branch has updated in merge request.");
+        return;
+    }
+
+    cstring head_meta(SysEval(GitCmd("show --quiet --pretty=medium"), FailokQ(false), 64*1024));
+
+    LineBuf linebuf;
+    algo::memptr data=strptr_ToMemptr(head_meta);
+    strptr line;
+    LinebufBegin(linebuf,data,false);
+
+    vrfy_(LinebufNext(linebuf,line)); // commit
+    vrfy_(LinebufNext(linebuf,line)); // author
+    vrfy_(LinebufNext(linebuf,line)); // date
+    vrfy(LinebufNext(linebuf,line) && !elems_N(line),tempstr() << "{{"<<line<<"}}"); // empty line
+
+    vrfy(LinebufNext(linebuf,line) && elems_N(line), "First line of commit message is empty!");
+    vrfy(FindChar(line,'#')!=-1,"First line of commit messsage does not contain issue reference (#NNN)")
+
+        strptr title(Trimmed(line));
+    dbglog("TITILE: "<<title);
+
+    // skip empty
+    while (LinebufNext(linebuf,line) && !elems_N(Trimmed(line))) {}
+
+    // need to keep format transparent so skip 4 space chars
+    cstring description;
+    description << RestFrom(line,4) << "\n";
+    while (LinebufNext(linebuf,line)) {
+        description << RestFrom(line,4) << "\n";
+    }
+    //    description << "\nReviewers: @alexei"; //
+    dbglog("DESCRIPTION:");
+    dbglog(description);
+
+    //
+    // submit
+    //
+
+    // prepare REST request
+    gitlab::FHttp http;
+
+    http.request_method = gitlab_FHttp_request_method_POST;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/merge_requests";
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+    request_header_Alloc(http) << "Accept: application/json";
+    request_header_Alloc(http) << "Content-Type: application/json";
+
+    lib_json::FNode &obj = lib_json::NewObjectNode(NULL);
+    lib_json::NewStringNode(&obj,"source_branch",branch);
+    lib_json::NewStringNode(&obj,"target_branch","master");
+    lib_json::NewStringNode(&obj,"title",title);
+    lib_json::NewStringNode(&obj,"description",description);
+    lib_json::JsonSerialize(&obj,http.request_body);
+
+    // execute request
+    CurlExec(http);
+
+    vrfy(http.response_status_code == 201, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+
+    // fill data from response
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+    lib_json::FNode &mr_obj = *http.response_json_parser.root_node;
+
+    // print result
+    gitlab::Mr mr;
+    mr.mr = gitlab::Issue_Concat_project_iid(gitlab::_db.cmdline.project, u32_Get(&mr_obj,"iid"));
+    mr.title = strptr_Get(&mr_obj,"title");
+    prlog(mr);
+    cstring str;
+    str << "\n";
+    InsertIndent(str,strptr_Get(&mr_obj,"description"),1);
+    str << "\n";
+    prlog(str);
+}
+
+// -----------------------------------------------------------------------------
+
+static void Main_DoMrAccept() {
+    int mrnum = gitlab::MrNumber(gitlab::_db.cmdline.mraccept);
+
+    // prepare REST request
+    gitlab::FHttp http;
+
+    http.request_method = gitlab_FHttp_request_method_PUT;
+    http.request_uri << gitlab::_db.rest_api
+                     << "/projects/" << gitlab::_db.project_id
+                     << "/merge_requests/" << mrnum
+                     << "/merge";
+    request_header_Alloc(http) << gitlab::_db.http_auth_header;
+
+    // execute request
+    CurlExec(http);
+
+    tempstr mr = gitlab::Mr_Concat_project_iid(gitlab::_db.cmdline.project,mrnum);
+
+    vrfy(http.response_status_code != 405,  tempstr() << Keyval("mr",mr)
+         << Keyval("reason","Merge request can not be accepted"));
+    vrfy(http.response_status_code != 406, tempstr() << Keyval("mr",mr)
+         << Keyval("reason","Branch can not be merged"));
+
+    vrfy(http.response_status_code == 200, tempstr() << "Server request has failed:"
+         << http.response_status_line);
+
+    vrfy_(http.response_json_parser.root_node);
+    vrfy_(http.response_json_parser.root_node->type == lib_json_FNode_type_object);
+    lib_json::FNode &issue_obj = *http.response_json_parser.root_node;
+    strptr state = strptr_Get(&issue_obj,"state");
+
+    vrfy(state == "merged", tempstr() << Keyval("mr",mr) << Keyval("state",state));
+    prlog("gitlab.success" << Keyval("mr",mr) << Keyval("state",state));
+}
+
+// -----------------------------------------------------------------------------
+
+void gitlab::Main() {
+    Main_ManageEnv();
+    Main_ManageAuth();
+    Main_ManageServer();
+    Main_ManageProject();
+
+    // Default -> display issue list
+    if (!(_db.cmdline.iadd  || _db.cmdline.ic || _db.cmdline.istart || _db.cmdline.mrlist || _db.cmdline.mergereq
+          || _db.cmdline.iclose || _db.cmdline.ulist || _db.cmdline.iassignto != ""
+          || _db.cmdline.mraccept != "")) {
+        _db.cmdline.ilist = true;
+    }
+
+    if (gitlab::_db.cmdline.ilist) {
+        Main_LoadIssueList();
+        Main_ShowIssueList();
+    }
+
+    if (gitlab::_db.cmdline.iadd) {
+        MaybeLoadUserList();
+        Main_DoIssueAdd();
+    }
+
+    if (gitlab::_db.cmdline.ic) {
+        Main_DoIssueCommentAdd();
+    }
+
+    if (gitlab::_db.cmdline.istart) {
+        Main_DoIssueStart();
+    }
+
+    if (gitlab::_db.cmdline.mrlist) {
+        Main_LoadMrList();
+        Main_DoShowMrList();
+    }
+
+    if (gitlab::_db.cmdline.mergereq) {
+        Main_DoMergeReq();
+    }
+
+    if (gitlab::_db.cmdline.iclose) {
+        Main_DoIssueClose();
+    }
+
+    if (gitlab::_db.cmdline.ulist) {
+        MaybeLoadUserList();
+        Main_ShowUserList();
+    }
+
+    if (gitlab::_db.cmdline.iassignto != "") {
+        MaybeLoadUserList();
+        Main_DoIssueAssign();
+    }
+
+    if (gitlab::_db.cmdline.mraccept != "") {
+        Main_DoMrAccept();
+    }
+}
diff --git a/data/dev/gitfile.ssim b/data/dev/gitfile.ssim
index d3a3a2b76..fac994677 100644
--- a/data/dev/gitfile.ssim
+++ b/data/dev/gitfile.ssim
@@ -67,6 +67,7 @@ dev.gitfile  gitfile:bin/git-rebase-origin
 dev.gitfile  gitfile:bin/git-recent-branches
 dev.gitfile  gitfile:bin/git-rollback-file
 dev.gitfile  gitfile:bin/git-update-config
+dev.gitfile  gitfile:bin/gitlab
 dev.gitfile  gitfile:bin/grephunk
 dev.gitfile  gitfile:bin/hilite
 dev.gitfile  gitfile:bin/hilite-error
@@ -306,6 +307,7 @@ dev.gitfile  gitfile:cpp/gen/bash2html_gen.cpp
 dev.gitfile  gitfile:cpp/gen/command_gen.cpp
 dev.gitfile  gitfile:cpp/gen/dev_gen.cpp
 dev.gitfile  gitfile:cpp/gen/dmmeta_gen.cpp
+dev.gitfile  gitfile:cpp/gen/gitlab_gen.cpp
 dev.gitfile  gitfile:cpp/gen/ietf_gen.cpp
 dev.gitfile  gitfile:cpp/gen/lib_ctype_gen.cpp
 dev.gitfile  gitfile:cpp/gen/lib_exec_gen.cpp
@@ -326,6 +328,7 @@ dev.gitfile  gitfile:cpp/gen/src_lim_gen.cpp
 dev.gitfile  gitfile:cpp/gen/ssim2csv_gen.cpp
 dev.gitfile  gitfile:cpp/gen/ssim2mysql_gen.cpp
 dev.gitfile  gitfile:cpp/gen/strconv_gen.cpp
+dev.gitfile  gitfile:cpp/gitlab.cpp
 dev.gitfile  gitfile:cpp/lib/algo/arg.cpp
 dev.gitfile  gitfile:cpp/lib/algo/backtrace.cpp
 dev.gitfile  gitfile:cpp/lib/algo/cpu_hz.cpp
@@ -387,6 +390,7 @@ dev.gitfile  gitfile:data/dev/cfg.ssim
 dev.gitfile  gitfile:data/dev/compiler.ssim
 dev.gitfile  gitfile:data/dev/gitfile.ssim
 dev.gitfile  gitfile:data/dev/gitinfo.ssim
+dev.gitfile  gitfile:data/dev/gitlab_project.ssim
 dev.gitfile  gitfile:data/dev/htmlentity.ssim
 dev.gitfile  gitfile:data/dev/license.ssim
 dev.gitfile  gitfile:data/dev/linelim.ssim
@@ -585,6 +589,8 @@ dev.gitfile  gitfile:include/gen/dev_gen.h
 dev.gitfile  gitfile:include/gen/dev_gen.inl.h
 dev.gitfile  gitfile:include/gen/dmmeta_gen.h
 dev.gitfile  gitfile:include/gen/dmmeta_gen.inl.h
+dev.gitfile  gitfile:include/gen/gitlab_gen.h
+dev.gitfile  gitfile:include/gen/gitlab_gen.inl.h
 dev.gitfile  gitfile:include/gen/ietf_gen.h
 dev.gitfile  gitfile:include/gen/ietf_gen.inl.h
 dev.gitfile  gitfile:include/gen/lib_ctype_gen.h
@@ -625,6 +631,7 @@ dev.gitfile  gitfile:include/gen/ssim2mysql_gen.h
 dev.gitfile  gitfile:include/gen/ssim2mysql_gen.inl.h
 dev.gitfile  gitfile:include/gen/strconv_gen.h
 dev.gitfile  gitfile:include/gen/strconv_gen.inl.h
+dev.gitfile  gitfile:include/gitlab.h
 dev.gitfile  gitfile:include/lib/lib_ctype.h
 dev.gitfile  gitfile:include/lib/lib_exec.h
 dev.gitfile  gitfile:include/lib/lib_iconv.h
diff --git a/data/dev/gitlab_project.ssim b/data/dev/gitlab_project.ssim
new file mode 100644
index 000000000..d07996c44
--- /dev/null
+++ b/data/dev/gitlab_project.ssim
@@ -0,0 +1 @@
+dev.gitlab_project  gitlab_project:myproject  url:http://gitlab.mycomany.com/userorgroup/myproject  comment:""  gitlab_project_id:0
diff --git a/data/dev/linelim.ssim b/data/dev/linelim.ssim
index 6e6623699..c2c66076e 100644
--- a/data/dev/linelim.ssim
+++ b/data/dev/linelim.ssim
@@ -120,6 +120,7 @@ dev.linelim  gitfile:cpp/atf/unit/string.cpp  nlongline:0  longestline:120  nbad
 dev.linelim  gitfile:cpp/atf/unit/time.cpp  nlongline:2  longestline:138  nbadws:0  maxws:16  nlongfunc:0  longestfunc:60  nmysteryfunc:10  badness:*************************
 dev.linelim  gitfile:cpp/atf/unit/tuple.cpp  nlongline:0  longestline:120  nbadws:1  maxws:26  nlongfunc:0  longestfunc:60  nmysteryfunc:5  badness:..........................
 dev.linelim  gitfile:cpp/bash2html.cpp  nlongline:10  longestline:125  nbadws:0  maxws:16  nlongfunc:2  longestfunc:92  nmysteryfunc:1  badness:...........
+dev.linelim  gitfile:cpp/gitlab.cpp  nlongline:0  longestline:120  nbadws:0  maxws:16  nlongfunc:4  longestfunc:92  nmysteryfunc:2  badness:..................
 dev.linelim  gitfile:cpp/lib/algo/backtrace.cpp  nlongline:6  longestline:150  nbadws:1  maxws:20  nlongfunc:0  longestfunc:60  nmysteryfunc:2  badness:............
 dev.linelim  gitfile:cpp/lib/algo/file.cpp  nlongline:0  longestline:120  nbadws:1  maxws:20  nlongfunc:0  longestfunc:60  nmysteryfunc:12  badness:******************************
 dev.linelim  gitfile:cpp/lib/algo/fmt.cpp  nlongline:2  longestline:124  nbadws:3  maxws:24  nlongfunc:1  longestfunc:92  nmysteryfunc:48  badness:******************************
diff --git a/data/dev/targdep.ssim b/data/dev/targdep.ssim
index c7eb966fd..399261559 100644
--- a/data/dev/targdep.ssim
+++ b/data/dev/targdep.ssim
@@ -33,6 +33,10 @@ dev.targdep  targdep:atf_unit.lib_json  comment:""
 dev.targdep  targdep:atf_unit.lib_sql  comment:""
 dev.targdep  targdep:bash2html.algo_lib  comment:""
 dev.targdep  targdep:bash2html.lib_prot  comment:""
+dev.targdep  targdep:gitlab.algo_lib  comment:""
+dev.targdep  targdep:gitlab.algo_pch  comment:""
+dev.targdep  targdep:gitlab.lib_json  comment:""
+dev.targdep  targdep:gitlab.lib_prot  comment:""
 dev.targdep  targdep:lib_ctype.algo_lib  comment:""
 dev.targdep  targdep:lib_ctype.lib_prot  comment:""
 dev.targdep  targdep:lib_exec.algo_lib  comment:""
diff --git a/data/dev/target.ssim b/data/dev/target.ssim
index 216fdde23..272563783 100644
--- a/data/dev/target.ssim
+++ b/data/dev/target.ssim
@@ -15,6 +15,7 @@ dev.target  target:atf_norm  license:GPL  compat:%-%.%-%
 dev.target  target:atf_nrun  license:""  compat:%-%.%-%
 dev.target  target:atf_unit  license:GPL  compat:%-%.%-%
 dev.target  target:bash2html  license:""  compat:%-%.%-%
+dev.target  target:gitlab  license:""  compat:Linux-%.%-%
 dev.target  target:lib_ctype  license:GPL  compat:%-%.%-%
 dev.target  target:lib_exec  license:GPL  compat:%-%.%-%
 dev.target  target:lib_git  license:GPL  compat:%-%.%-%
diff --git a/data/dev/targsrc.ssim b/data/dev/targsrc.ssim
index e281be667..f5b9ea859 100644
--- a/data/dev/targsrc.ssim
+++ b/data/dev/targsrc.ssim
@@ -262,6 +262,11 @@ dev.targsrc  targsrc:bash2html/cpp/gen/bash2html_gen.cpp  comment:""
 dev.targsrc  targsrc:bash2html/include/bash2html.h  comment:""
 dev.targsrc  targsrc:bash2html/include/gen/bash2html_gen.h  comment:""
 dev.targsrc  targsrc:bash2html/include/gen/bash2html_gen.inl.h  comment:""
+dev.targsrc  targsrc:gitlab/cpp/gen/gitlab_gen.cpp  comment:""
+dev.targsrc  targsrc:gitlab/cpp/gitlab.cpp  comment:""
+dev.targsrc  targsrc:gitlab/include/gen/gitlab_gen.h  comment:""
+dev.targsrc  targsrc:gitlab/include/gen/gitlab_gen.inl.h  comment:""
+dev.targsrc  targsrc:gitlab/include/gitlab.h  comment:""
 dev.targsrc  targsrc:lib_ctype/cpp/gen/lib_ctype_gen.cpp  comment:""
 dev.targsrc  targsrc:lib_ctype/cpp/lib/lib_ctype.cpp  comment:""
 dev.targsrc  targsrc:lib_ctype/include/gen/lib_ctype_gen.h  comment:""
diff --git a/data/dev/targsyslib.ssim b/data/dev/targsyslib.ssim
index b39c4919f..664990e3e 100644
--- a/data/dev/targsyslib.ssim
+++ b/data/dev/targsyslib.ssim
@@ -4,5 +4,6 @@ dev.targsyslib  targsyslib:algo_lib.m  uname:Linux  comment:""
 dev.targsyslib  targsyslib:algo_lib.stdc++  uname:"(Linux|Darwin)"  comment:""
 dev.targsyslib  targsyslib:amc.crypto  uname:"(Linux|Darwin|FreeBSD)"  comment:""
 dev.targsyslib  targsyslib:amc.ssl  uname:"(Linux|Darwin)"  comment:""
+dev.targsyslib  targsyslib:gitlab.curl  uname:"(Linux|Darwin|FreeBSD)"  comment:""
 dev.targsyslib  targsyslib:lib_mysql.mariadb  uname:CYGWIN_NT  comment:""
 dev.targsyslib  targsyslib:lib_mysql.mysqlclient  uname:"(Linux|Darwin|FreeBSD)"  comment:""
diff --git a/data/dmmeta/anonfld.ssim b/data/dmmeta/anonfld.ssim
index eba83f8c9..58dd4ab63 100644
--- a/data/dmmeta/anonfld.ssim
+++ b/data/dmmeta/anonfld.ssim
@@ -65,6 +65,7 @@ dmmeta.anonfld  field:command.atf_norm.normcheck  comment:""
 dmmeta.anonfld  field:command.atf_nrun.ncmd  comment:""
 dmmeta.anonfld  field:command.atf_unit.unittest  comment:""
 dmmeta.anonfld  field:command.bash_proc.bash  comment:""
+dmmeta.anonfld  field:command.gitlab.issue  comment:""
 dmmeta.anonfld  field:command.mdbg.args  comment:""
 dmmeta.anonfld  field:command.mdbg.target  comment:""
 dmmeta.anonfld  field:command.mysql2ssim.tables  comment:""
diff --git a/data/dmmeta/cfmt.ssim b/data/dmmeta/cfmt.ssim
index 78f79171c..58e8028d2 100644
--- a/data/dmmeta/cfmt.ssim
+++ b/data/dmmeta/cfmt.ssim
@@ -321,6 +321,7 @@ dmmeta.cfmt  cfmt:command.atf_nrun.Argv  printfmt:Tuple  read:Y  print:Y  sep:""
 dmmeta.cfmt  cfmt:command.atf_unit.Argv  printfmt:Auto  read:Y  print:Y  sep:""  genop:N  comment:""
 dmmeta.cfmt  cfmt:command.bash.ArgvGnu  printfmt:Auto  read:N  print:Y  sep:""  genop:N  comment:""
 dmmeta.cfmt  cfmt:command.bash2html.Argv  printfmt:Tuple  read:Y  print:Y  sep:""  genop:N  comment:""
+dmmeta.cfmt  cfmt:command.gitlab.Argv  printfmt:Tuple  read:Y  print:Y  sep:""  genop:N  comment:""
 dmmeta.cfmt  cfmt:command.lib_ctype.Argv  printfmt:Tuple  read:Y  print:Y  sep:""  genop:N  comment:""
 dmmeta.cfmt  cfmt:command.lib_exec.Argv  printfmt:Auto  read:Y  print:Y  sep:""  genop:N  comment:""
 dmmeta.cfmt  cfmt:command.mdbg.Argv  printfmt:Auto  read:Y  print:Y  sep:""  genop:N  comment:""
@@ -342,6 +343,7 @@ dmmeta.cfmt  cfmt:dev.Cfg.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop
 dmmeta.cfmt  cfmt:dev.Compiler.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:N  comment:""
 dmmeta.cfmt  cfmt:dev.Gitfile.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:dev.Gitinfo.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:N  comment:""
+dmmeta.cfmt  cfmt:dev.GitlabProject.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:dev.Htmlentity.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:dev.Include.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:dev.License.String  printfmt:Tuple  read:Y  print:Y  sep:""  genop:Y  comment:""
@@ -477,6 +479,15 @@ dmmeta.cfmt  cfmt:double.Json  printfmt:Extern  read:N  print:Y  sep:""  genop:Y
 dmmeta.cfmt  cfmt:double.String  printfmt:Extern  read:Y  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:float.Json  printfmt:Extern  read:N  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:float.String  printfmt:Extern  read:Y  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.FHttp.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.FIssue.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.FMr.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.Issue.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.IssueDescription.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.IssueNote.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.Mr.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.MrDescription.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
+dmmeta.cfmt  cfmt:gitlab.MrNote.String  printfmt:Tuple  read:N  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:i16.Json  printfmt:Extern  read:N  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:i16.String  printfmt:Extern  read:Y  print:Y  sep:""  genop:Y  comment:""
 dmmeta.cfmt  cfmt:i32.Json  printfmt:Extern  read:N  print:Y  sep:""  genop:Y  comment:""
diff --git a/data/dmmeta/ctype.ssim b/data/dmmeta/ctype.ssim
index 91eb9d771..5de29297a 100644
--- a/data/dmmeta/ctype.ssim
+++ b/data/dmmeta/ctype.ssim
@@ -596,6 +596,7 @@ dmmeta.ctype  ctype:command.atf_unit  comment:""
 dmmeta.ctype  ctype:command.bash  comment:"One way of invoking the shell"
 dmmeta.ctype  ctype:command.bash2html  comment:""
 dmmeta.ctype  ctype:command.bash_proc  comment:"Shell subprocess"
+dmmeta.ctype  ctype:command.gitlab  comment:""
 dmmeta.ctype  ctype:command.lib_ctype  comment:""
 dmmeta.ctype  ctype:command.lib_exec  comment:""
 dmmeta.ctype  ctype:command.mdbg  comment:""
@@ -615,6 +616,7 @@ dmmeta.ctype  ctype:dev.Cfg  comment:""
 dmmeta.ctype  ctype:dev.Compiler  comment:""
 dmmeta.ctype  ctype:dev.Gitfile  comment:""
 dmmeta.ctype  ctype:dev.Gitinfo  comment:""
+dmmeta.ctype  ctype:dev.GitlabProject  comment:"Gitlab project"
 dmmeta.ctype  ctype:dev.Htmlentity  comment:""
 dmmeta.ctype  ctype:dev.Include  comment:"A site where one file includes another"
 dmmeta.ctype  ctype:dev.License  comment:""
@@ -749,6 +751,23 @@ dmmeta.ctype  ctype:dmmeta.Usertracefld  comment:""
 dmmeta.ctype  ctype:dmmeta.Xref  comment:X-reference
 dmmeta.ctype  ctype:double  comment:""
 dmmeta.ctype  ctype:float  comment:""
+dmmeta.ctype  ctype:gitlab.FDb  comment:""
+dmmeta.ctype  ctype:gitlab.FHttp  comment:"HTTP request"
+dmmeta.ctype  ctype:gitlab.FIssue  comment:""
+dmmeta.ctype  ctype:gitlab.FIssueDescription  comment:""
+dmmeta.ctype  ctype:gitlab.FIssueNote  comment:""
+dmmeta.ctype  ctype:gitlab.FMr  comment:""
+dmmeta.ctype  ctype:gitlab.FMrDescription  comment:""
+dmmeta.ctype  ctype:gitlab.FMrNote  comment:""
+dmmeta.ctype  ctype:gitlab.FProject  comment:""
+dmmeta.ctype  ctype:gitlab.FUser  comment:""
+dmmeta.ctype  ctype:gitlab.Issue  comment:"Gitlab project issue"
+dmmeta.ctype  ctype:gitlab.IssueDescription  comment:"Issue description"
+dmmeta.ctype  ctype:gitlab.IssueNote  comment:"Issue note"
+dmmeta.ctype  ctype:gitlab.Mr  comment:"Gitlab project mr"
+dmmeta.ctype  ctype:gitlab.MrDescription  comment:"Mr description"
+dmmeta.ctype  ctype:gitlab.MrNote  comment:"Mr note"
+dmmeta.ctype  ctype:gitlab.User  comment:""
 dmmeta.ctype  ctype:i16  comment:""
 dmmeta.ctype  ctype:i32  comment:""
 dmmeta.ctype  ctype:i64  comment:""
diff --git a/data/dmmeta/ctypelen.ssim b/data/dmmeta/ctypelen.ssim
index 61a0d8516..060893cca 100644
--- a/data/dmmeta/ctypelen.ssim
+++ b/data/dmmeta/ctypelen.ssim
@@ -579,6 +579,7 @@ dmmeta.ctypelen  ctype:command.atf_unit  len:160  alignment:8  padbytes:16
 dmmeta.ctypelen  ctype:command.bash  len:16  alignment:8  padbytes:0
 dmmeta.ctypelen  ctype:command.bash2html  len:24  alignment:8  padbytes:7
 dmmeta.ctypelen  ctype:command.bash_proc  len:96  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:command.gitlab  len:408  alignment:8  padbytes:11
 dmmeta.ctypelen  ctype:command.lib_ctype  len:16  alignment:8  padbytes:0
 dmmeta.ctypelen  ctype:command.lib_exec  len:12  alignment:4  padbytes:5
 dmmeta.ctypelen  ctype:command.mdbg  len:152  alignment:8  padbytes:11
@@ -598,6 +599,7 @@ dmmeta.ctypelen  ctype:dev.Cfg  len:211  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dev.Compiler  len:530  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dev.Gitfile  len:202  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dev.Gitinfo  len:352  alignment:1  padbytes:0
+dmmeta.ctypelen  ctype:dev.GitlabProject  len:412  alignment:4  padbytes:2
 dmmeta.ctypelen  ctype:dev.Htmlentity  len:208  alignment:4  padbytes:0
 dmmeta.ctypelen  ctype:dev.Include  len:355  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dev.License  len:204  alignment:1  padbytes:0
@@ -730,6 +732,23 @@ dmmeta.ctypelen  ctype:dmmeta.Tracerec  len:204  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dmmeta.Typefld  len:254  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dmmeta.Usertracefld  len:254  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:dmmeta.Xref  len:556  alignment:1  padbytes:0
+dmmeta.ctypelen  ctype:gitlab.FDb  len:2768  alignment:8  padbytes:35
+dmmeta.ctypelen  ctype:gitlab.FHttp  len:264  alignment:8  padbytes:11
+dmmeta.ctypelen  ctype:gitlab.FIssue  len:168  alignment:8  padbytes:6
+dmmeta.ctypelen  ctype:gitlab.FIssueDescription  len:80  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:gitlab.FIssueNote  len:96  alignment:8  padbytes:11
+dmmeta.ctypelen  ctype:gitlab.FMr  len:160  alignment:8  padbytes:13
+dmmeta.ctypelen  ctype:gitlab.FMrDescription  len:80  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:gitlab.FMrNote  len:96  alignment:8  padbytes:11
+dmmeta.ctypelen  ctype:gitlab.FProject  len:456  alignment:8  padbytes:6
+dmmeta.ctypelen  ctype:gitlab.FUser  len:80  alignment:8  padbytes:0
+dmmeta.ctypelen  ctype:gitlab.Issue  len:120  alignment:8  padbytes:0
+dmmeta.ctypelen  ctype:gitlab.IssueDescription  len:72  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:gitlab.IssueNote  len:72  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:gitlab.Mr  len:112  alignment:8  padbytes:6
+dmmeta.ctypelen  ctype:gitlab.MrDescription  len:72  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:gitlab.MrNote  len:72  alignment:8  padbytes:4
+dmmeta.ctypelen  ctype:gitlab.User  len:72  alignment:8  padbytes:0
 dmmeta.ctypelen  ctype:ietf.Ipport  len:6  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:ietf.Ipv4  len:4  alignment:1  padbytes:0
 dmmeta.ctypelen  ctype:ietf.Ipv4Addr  len:4  alignment:1  padbytes:0
diff --git a/data/dmmeta/dispsig.ssim b/data/dmmeta/dispsig.ssim
index f1ef82c38..a55ae5754 100644
--- a/data/dmmeta/dispsig.ssim
+++ b/data/dmmeta/dispsig.ssim
@@ -12,6 +12,7 @@ dmmeta.dispsig  dispsig:atf_amc.Input  signature:3b9943558be9b03e79fade60297ec50
 dmmeta.dispsig  dispsig:atf_amc.Msgs  signature:f80a13e46fff2c18de1f4dbbbb11703d07c170d2
 dmmeta.dispsig  dispsig:atf_amc.Ssimfiles  signature:9a25d87b6ed236e8b6794b21dc308f66286505af
 dmmeta.dispsig  dispsig:atf_norm.Input  signature:3c2fccbb207224c170fcfd01c0692912424c20aa
+dmmeta.dispsig  dispsig:gitlab.Input  signature:cd941ad82205e82576bcadd62546d69d72cdbca6
 dmmeta.dispsig  dispsig:lib_ctype.Input  signature:ab81c986e2e85d3e267eb18d62976fdef0a8ff70
 dmmeta.dispsig  dispsig:mdbg.Input  signature:a39a7508119d6dc51451d2cda9f120fd888b1184
 dmmeta.dispsig  dispsig:orgfile.Input  signature:dadfcf8accbcc44f5e5443f439ac4024afc89edf
diff --git a/data/dmmeta/fcmdline.ssim b/data/dmmeta/fcmdline.ssim
index 7dfdecc9c..5b2b0dd90 100644
--- a/data/dmmeta/fcmdline.ssim
+++ b/data/dmmeta/fcmdline.ssim
@@ -13,6 +13,7 @@ dmmeta.fcmdline  field:atf_norm.FDb.cmdline  read:Y  comment:""
 dmmeta.fcmdline  field:atf_nrun.FDb.cmdline  read:Y  comment:""
 dmmeta.fcmdline  field:atf_unit.FDb.cmdline  read:Y  comment:""
 dmmeta.fcmdline  field:bash2html.FDb.cmdline  read:Y  comment:""
+dmmeta.fcmdline  field:gitlab.FDb.cmdline  read:Y  comment:""
 dmmeta.fcmdline  field:lib_exec.FDb.cmdline  read:Y  comment:""
 dmmeta.fcmdline  field:mdbg.FDb.cmdline  read:Y  comment:""
 dmmeta.fcmdline  field:mysql2ssim.FDb.cmdline  read:Y  comment:""
diff --git a/data/dmmeta/fconst.ssim b/data/dmmeta/fconst.ssim
index b6f377ce8..67822f60d 100644
--- a/data/dmmeta/fconst.ssim
+++ b/data/dmmeta/fconst.ssim
@@ -70,6 +70,9 @@ dmmeta.fconst  fconst:atf_amc.TypeBE32en.value/val1  value:0x12345678  comment:"
 dmmeta.fconst  fconst:atf_amc.TypeBE32en.value/val2  value:0xabcdef01  comment:""
 dmmeta.fconst  fconst:atf_amc.Typefconst.value/strval1  value:1  comment:""
 dmmeta.fconst  fconst:atf_amc.Typefconst.value/strval2  value:2  comment:""
+dmmeta.fconst  fconst:gitlab.FHttp.request_method/GET  value:0  comment:GET
+dmmeta.fconst  fconst:gitlab.FHttp.request_method/POST  value:1  comment:POST
+dmmeta.fconst  fconst:gitlab.FHttp.request_method/PUT  value:2  comment:PUT
 dmmeta.fconst  fconst:lib_json.FNode.type/null  value:0  comment:""
 dmmeta.fconst  fconst:lib_json.FNode.type/false  value:1  comment:""
 dmmeta.fconst  fconst:lib_json.FNode.type/true  value:2  comment:""
diff --git a/data/dmmeta/field.ssim b/data/dmmeta/field.ssim
index 627dae26a..7a4f98634 100644
--- a/data/dmmeta/field.ssim
+++ b/data/dmmeta/field.ssim
@@ -2153,6 +2153,27 @@ dmmeta.field  field:command.bash.c  arg:algo.cstring  reftype:Val  dflt:'""'  co
 dmmeta.field  field:command.bash2html.in  arg:algo.cstring  reftype:Val  dflt:'"data"'  comment:"Input directory or filename, - for stdin"
 dmmeta.field  field:command.bash2html.test  arg:bool  reftype:Val  dflt:""  comment:"Produce Test Output"
 dmmeta.field  field:command.bash_proc.bash  arg:command.bash  reftype:Exec  dflt:'"bash"'  comment:"Must be bash to support $'' for string quoting"
+dmmeta.field  field:command.gitlab.in  arg:algo.cstring  reftype:Val  dflt:'"data"'  comment:"Input directory or filename, - for stdin"
+dmmeta.field  field:command.gitlab.issue  arg:algo.cstring  reftype:RegxSql  dflt:'""'  comment:"Issue id (e.g. myproject.33, 33 or %)"
+dmmeta.field  field:command.gitlab.server  arg:algo.cstring  reftype:Val  dflt:'"gitlab.lon.algo"'  comment:"(config) GitLab server host"
+dmmeta.field  field:command.gitlab.project  arg:algo.cstring  reftype:Val  dflt:'"myproject"'  comment:"(config) Project to use"
+dmmeta.field  field:command.gitlab.auth_token  arg:algo.cstring  reftype:Val  dflt:'""'  comment:"(config) GitLab auth token"
+dmmeta.field  field:command.gitlab.mrlist  arg:bool  reftype:Val  dflt:""  comment:"(action) Show list of merge requests"
+dmmeta.field  field:command.gitlab.mergereq  arg:bool  reftype:Val  dflt:""  comment:"(action) Push current branch to origin, create merge request"
+dmmeta.field  field:command.gitlab.ilist  arg:bool  reftype:Val  dflt:""  comment:"(action) Show list of issues matching regx"
+dmmeta.field  field:command.gitlab.istart  arg:bool  reftype:Val  dflt:""  comment:"(action) Start working on the specified issue"
+dmmeta.field  field:command.gitlab.t  arg:bool  reftype:Val  dflt:""  comment:"Tree view: expand issue description"
+dmmeta.field  field:command.gitlab.iadd  arg:bool  reftype:Val  dflt:""  comment:"(action) Add new issue"
+dmmeta.field  field:command.gitlab.ic  arg:bool  reftype:Val  dflt:""  comment:"(action) Add issue comment"
+dmmeta.field  field:command.gitlab.iclose  arg:bool  reftype:Val  dflt:""  comment:"(action) Close issue"
+dmmeta.field  field:command.gitlab.iassignto  arg:gitlab.User  reftype:Pkey  dflt:'""'  comment:"(action) Assign issue to user"
+dmmeta.field  field:command.gitlab.title  arg:algo.cstring  reftype:Val  dflt:'""'  comment:"(with -iadd), skip editor and use argument as title"
+dmmeta.field  field:command.gitlab.description  arg:algo.cstring  reftype:Val  dflt:'""'  comment:"(with -iadd -title), use argument as description"
+dmmeta.field  field:command.gitlab.comment  arg:algo.cstring  reftype:Val  dflt:'""'  comment:"(with -ic), skip editor and use argument as comment"
+dmmeta.field  field:command.gitlab.gitdir  arg:algo.cstring  reftype:Val  dflt:'""'  comment:"(setup) Change directory of dit repository"
+dmmeta.field  field:command.gitlab.assignee  arg:algo.cstring  reftype:RegxSql  dflt:'""'  comment:"Filter assignee. Default=current user only"
+dmmeta.field  field:command.gitlab.ulist  arg:bool  reftype:Val  dflt:""  comment:"(action) List users"
+dmmeta.field  field:command.gitlab.mraccept  arg:algo.cstring  reftype:Val  dflt:'""'  comment:"(action) Accept merge request"
 dmmeta.field  field:command.lib_ctype.in  arg:algo.cstring  reftype:Val  dflt:'"data"'  comment:"Input directory or filename, - for stdin"
 dmmeta.field  field:command.lib_exec.dry_run  arg:bool  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:command.lib_exec.q  arg:bool  reftype:Val  dflt:true  comment:"Do not print node name"
@@ -2275,6 +2296,10 @@ dmmeta.field  field:dev.Gitinfo.cfg  arg:algo.Smallstr40  reftype:Val  dflt:""
 dmmeta.field  field:dev.Gitinfo.compver  arg:algo.Smallstr20  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:dev.Gitinfo.package  arg:algo.Smallstr40  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:dev.Gitinfo.comment  arg:algo.Comment  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:dev.GitlabProject.gitlab_project  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:dev.GitlabProject.url  arg:algo.Smallstr200  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:dev.GitlabProject.comment  arg:algo.Comment  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:dev.GitlabProject.gitlab_project_id  arg:u32  reftype:Val  dflt:""  comment:"Numeric project ID on gitlab server, displayed on project overview Web page"
 dmmeta.field  field:dev.Htmlentity.htmlentity  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:dev.Htmlentity.code  arg:i32  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:dev.Htmlentity.comment  arg:algo.Comment  reftype:Val  dflt:""  comment:""
@@ -2757,6 +2782,93 @@ dmmeta.field  field:dmmeta.Xref.ns  arg:dmmeta.Ns  reftype:Pkey  dflt:""  commen
 dmmeta.field  field:dmmeta.Xref.via  arg:algo.Smallstr200  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:dmmeta.Xref.viafld  arg:dmmeta.Field  reftype:Pkey  dflt:""  comment:""
 dmmeta.field  field:dmmeta.Xref.keyfld  arg:dmmeta.Field  reftype:Pkey  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.cmdline  arg:command.gitlab  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb._db  arg:gitlab.FDb  reftype:Global  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.home  arg:algo.cstring  reftype:Val  dflt:""  comment:"User's HOME directory"
+dmmeta.field  field:gitlab.FDb.unix_user  arg:algo.cstring  reftype:Val  dflt:""  comment:"UNIX user login name"
+dmmeta.field  field:gitlab.FDb.auth_file_name  arg:algo.cstring  reftype:Val  dflt:'".gitlab_auth"'  comment:"Basename of the file where to store GitLab auth token"
+dmmeta.field  field:gitlab.FDb.auth_token  arg:algo.cstring  reftype:Val  dflt:""  comment:"GitLab auth token"
+dmmeta.field  field:gitlab.FDb.auth_file  arg:algo.cstring  reftype:Val  dflt:""  comment:"File where to store gitlab auth token"
+dmmeta.field  field:gitlab.FDb.usrmsg_no_token  arg:algo.cstring  reftype:Val  dflt:"\"Please supply personal access token via -auth_token option (could be done once). Visit <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html> for directions. Token scope shall be 'api', i.e. whole GitLab API.\""  comment:"Message to show if no auth token"
+dmmeta.field  field:gitlab.FDb.http_auth_header  arg:algo.cstring  reftype:Val  dflt:""  comment:"Ready-made HTTP authorization header"
+dmmeta.field  field:gitlab.FDb.rest_api  arg:algo.cstring  reftype:Val  dflt:""  comment:"Base URI of server REST API"
+dmmeta.field  field:gitlab.FDb.project  arg:gitlab.FProject  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.project_id  arg:u32  reftype:Val  dflt:""  comment:"Numeric project ID on gitlab server"
+dmmeta.field  field:gitlab.FDb.ind_project  arg:gitlab.FProject  reftype:Thash  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.ind_issue  arg:gitlab.FIssue  reftype:Thash  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.issue  arg:gitlab.FIssue  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.issue_note  arg:gitlab.FIssueNote  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.ind_issue_note  arg:gitlab.FIssueNote  reftype:Thash  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.issue_description  arg:gitlab.FIssueDescription  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.editor  arg:algo.cstring  reftype:Val  dflt:""  comment:"Command line to invoke editor"
+dmmeta.field  field:gitlab.FDb.ind_mr  arg:gitlab.FMr  reftype:Thash  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.mr  arg:gitlab.FMr  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.mr_note  arg:gitlab.FMrNote  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.ind_mr_note  arg:gitlab.FMrNote  reftype:Thash  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.mr_description  arg:gitlab.FMrDescription  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.user  arg:gitlab.FUser  reftype:Lary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FDb.ind_user  arg:gitlab.FUser  reftype:Thash  dflt:""  comment:""
+dmmeta.field  field:gitlab.FHttp.request_uri  arg:algo.cstring  reftype:Val  dflt:""  comment:"URI of requested resource"
+dmmeta.field  field:gitlab.FHttp.request_header  arg:algo.cstring  reftype:Tary  dflt:""  comment:"Array of request headers"
+dmmeta.field  field:gitlab.FHttp.request_content_type  arg:algo.cstring  reftype:Val  dflt:""  comment:"Request content type"
+dmmeta.field  field:gitlab.FHttp.request_body  arg:algo.cstring  reftype:Val  dflt:""  comment:"Request body"
+dmmeta.field  field:gitlab.FHttp.response_status_line  arg:algo.cstring  reftype:Val  dflt:""  comment:"Status line"
+dmmeta.field  field:gitlab.FHttp.response_status_code  arg:u32  reftype:Val  dflt:""  comment:"Numeric status code"
+dmmeta.field  field:gitlab.FHttp.request_method  arg:u32  reftype:Val  dflt:gitlab_FHttp_request_method_GET  comment:"Request method"
+dmmeta.field  field:gitlab.FHttp.response_reason_phrase  arg:algo.cstring  reftype:Val  dflt:""  comment:"Status message"
+dmmeta.field  field:gitlab.FHttp.response_header  arg:algo.cstring  reftype:Tary  dflt:""  comment:"Array of request headers"
+dmmeta.field  field:gitlab.FHttp.response_content_type  arg:algo.cstring  reftype:Val  dflt:""  comment:"Response content type"
+dmmeta.field  field:gitlab.FHttp.response_body  arg:algo.cstring  reftype:Val  dflt:""  comment:"Response body"
+dmmeta.field  field:gitlab.FHttp.response_content_type_json  arg:bool  reftype:Val  dflt:""  comment:"Flag if response is JSON"
+dmmeta.field  field:gitlab.FHttp.response_json_parser  arg:lib_json.FParser  reftype:Val  dflt:""  comment:"Json parser to parse response body on the fly"
+dmmeta.field  field:gitlab.FHttp.request_body_sent_bytes  arg:u32  reftype:Val  dflt:""  comment:"Sent bytes in request body"
+dmmeta.field  field:gitlab.FIssue.base  arg:gitlab.Issue  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssue.p_project  arg:gitlab.FProject  reftype:Upptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssue.c_issue_note  arg:gitlab.FIssueNote  reftype:Ptrary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssue.c_issue_description  arg:gitlab.FIssueDescription  reftype:Ptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssue.select  arg:bool  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssueDescription.base  arg:gitlab.IssueDescription  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssueDescription.p_issue  arg:gitlab.FIssue  reftype:Upptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssueNote.base  arg:gitlab.IssueNote  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FIssueNote.p_issue  arg:gitlab.FIssue  reftype:Upptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMr.base  arg:gitlab.Mr  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMr.p_project  arg:gitlab.FProject  reftype:Upptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMr.c_mr_note  arg:gitlab.FMrNote  reftype:Ptrary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMr.c_mr_description  arg:gitlab.FMrDescription  reftype:Ptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMrDescription.base  arg:gitlab.MrDescription  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMrDescription.p_mr  arg:gitlab.FMr  reftype:Upptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMrNote.base  arg:gitlab.MrNote  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FMrNote.p_mr  arg:gitlab.FMr  reftype:Upptr  dflt:""  comment:""
+dmmeta.field  field:gitlab.FProject.base  arg:dev.GitlabProject  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.FProject.c_issue  arg:gitlab.FIssue  reftype:Ptrary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FProject.c_mr  arg:gitlab.FMr  reftype:Ptrary  dflt:""  comment:""
+dmmeta.field  field:gitlab.FUser.base  arg:gitlab.User  reftype:Base  dflt:""  comment:""
+dmmeta.field  field:gitlab.Issue.project  arg:dev.GitlabProject  reftype:Pkey  dflt:""  comment:"Project portion of issue"
+dmmeta.field  field:gitlab.Issue.issue  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:"Identifier. must be in form project.iid"
+dmmeta.field  field:gitlab.Issue.assignee  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:"User the issue is assigned to"
+dmmeta.field  field:gitlab.Issue.iid  arg:u32  reftype:Val  dflt:""  comment:"Iid portion of issue"
+dmmeta.field  field:gitlab.Issue.title  arg:algo.cstring  reftype:Val  dflt:""  comment:"Issue title"
+dmmeta.field  field:gitlab.IssueDescription.issue  arg:gitlab.Issue  reftype:Pkey  dflt:""  comment:""
+dmmeta.field  field:gitlab.IssueDescription.description  arg:algo.cstring  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:gitlab.IssueNote.issue_note  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:"Identifier. must be in form issue.id"
+dmmeta.field  field:gitlab.IssueNote.issue  arg:gitlab.Issue  reftype:Pkey  dflt:""  comment:"Issue portion of issue note"
+dmmeta.field  field:gitlab.IssueNote.id  arg:u32  reftype:Val  dflt:""  comment:"Id portion of issue note"
+dmmeta.field  field:gitlab.IssueNote.body  arg:algo.cstring  reftype:Val  dflt:""  comment:"Body of issue note"
+dmmeta.field  field:gitlab.Mr.project  arg:dev.GitlabProject  reftype:Pkey  dflt:""  comment:"Project portion of mr"
+dmmeta.field  field:gitlab.Mr.mr  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:"Identifier. must be in form project.iid"
+dmmeta.field  field:gitlab.Mr.iid  arg:u32  reftype:Val  dflt:""  comment:"Iid portion of mr"
+dmmeta.field  field:gitlab.Mr.title  arg:algo.cstring  reftype:Val  dflt:""  comment:"Mr title"
+dmmeta.field  field:gitlab.Mr.source_branch  arg:algo.cstring  reftype:Val  dflt:""  comment:"Source branch"
+dmmeta.field  field:gitlab.Mr.pipeline_status  arg:algo.Smallstr20  reftype:Val  dflt:""  comment:"Pipeline status"
+dmmeta.field  field:gitlab.MrDescription.mr  arg:gitlab.Mr  reftype:Pkey  dflt:""  comment:""
+dmmeta.field  field:gitlab.MrDescription.description  arg:algo.cstring  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:gitlab.MrNote.mr_note  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:"Identifier. must be in form mr.id"
+dmmeta.field  field:gitlab.MrNote.mr  arg:gitlab.Mr  reftype:Pkey  dflt:""  comment:"Mr portion of mr note"
+dmmeta.field  field:gitlab.MrNote.id  arg:u32  reftype:Val  dflt:""  comment:"Id portion of mr note"
+dmmeta.field  field:gitlab.MrNote.body  arg:algo.cstring  reftype:Val  dflt:""  comment:"Body of mr note"
+dmmeta.field  field:gitlab.User.user  arg:algo.Smallstr50  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:gitlab.User.id  arg:u32  reftype:Val  dflt:""  comment:""
+dmmeta.field  field:gitlab.User.name  arg:algo.cstring  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:ietf.Ipport.ip  arg:ietf.Ipv4  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:ietf.Ipport.port  arg:u16  reftype:Val  dflt:""  comment:""
 dmmeta.field  field:ietf.Ipv4.ipv4  arg:u32  reftype:Val  dflt:""  comment:"IP address. First octet in bits 24..32"
diff --git a/data/dmmeta/finput.ssim b/data/dmmeta/finput.ssim
index f3752c4e8..bdfa7078b 100644
--- a/data/dmmeta/finput.ssim
+++ b/data/dmmeta/finput.ssim
@@ -157,6 +157,7 @@ dmmeta.finput  field:atf_norm.FDb.readme  extrn:N  update:N  strict:Y  comment:"
 dmmeta.finput  field:atf_norm.FDb.scriptfile  extrn:N  update:N  strict:Y  comment:""
 dmmeta.finput  field:atf_norm.FDb.ssimfile  extrn:N  update:N  strict:Y  comment:""
 dmmeta.finput  field:atf_norm.FDb.targsrc  extrn:N  update:N  strict:Y  comment:""
+dmmeta.finput  field:gitlab.FDb.project  extrn:N  update:N  strict:Y  comment:""
 dmmeta.finput  field:lib_ctype.FDb.cdflt  extrn:N  update:N  strict:Y  comment:""
 dmmeta.finput  field:lib_ctype.FDb.cfmt  extrn:N  update:N  strict:Y  comment:""
 dmmeta.finput  field:lib_ctype.FDb.cppfunc  extrn:N  update:N  strict:Y  comment:""
diff --git a/data/dmmeta/floadtuples.ssim b/data/dmmeta/floadtuples.ssim
index 0b0277f51..e14edc14b 100644
--- a/data/dmmeta/floadtuples.ssim
+++ b/data/dmmeta/floadtuples.ssim
@@ -11,6 +11,7 @@ dmmeta.floadtuples  field:command.atf_norm.in  comment:""
 dmmeta.floadtuples  field:command.atf_nrun.in  comment:""
 dmmeta.floadtuples  field:command.atf_unit.data_dir  comment:""
 dmmeta.floadtuples  field:command.bash2html.in  comment:""
+dmmeta.floadtuples  field:command.gitlab.in  comment:""
 dmmeta.floadtuples  field:command.lib_ctype.in  comment:""
 dmmeta.floadtuples  field:command.mdbg.in  comment:""
 dmmeta.floadtuples  field:command.ntup.in  comment:""
diff --git a/data/dmmeta/main.ssim b/data/dmmeta/main.ssim
index 574cf3cfd..bf471f531 100644
--- a/data/dmmeta/main.ssim
+++ b/data/dmmeta/main.ssim
@@ -12,6 +12,7 @@ dmmeta.main  ns:atf_norm  ismodule:N
 dmmeta.main  ns:atf_nrun  ismodule:N
 dmmeta.main  ns:atf_unit  ismodule:N
 dmmeta.main  ns:bash2html  ismodule:N
+dmmeta.main  ns:gitlab  ismodule:N
 dmmeta.main  ns:mdbg  ismodule:N
 dmmeta.main  ns:mysql2ssim  ismodule:N
 dmmeta.main  ns:ntup  ismodule:N
diff --git a/data/dmmeta/ns.ssim b/data/dmmeta/ns.ssim
index 418d59fdb..6cf20d3b1 100644
--- a/data/dmmeta/ns.ssim
+++ b/data/dmmeta/ns.ssim
@@ -22,6 +22,7 @@ dmmeta.ns  ns:bash2html  nstype:exe  comment:"Convert bash output and colours to
 dmmeta.ns  ns:command  nstype:protocol  comment:"Command line descriptions"
 dmmeta.ns  ns:dev  nstype:ssimdb  comment:"Tables supporting compilation of programs"
 dmmeta.ns  ns:dmmeta  nstype:ssimdb  comment:"Tables holding metadata (data model meta)"
+dmmeta.ns  ns:gitlab  nstype:exe  comment:"Gitlab command line interface"
 dmmeta.ns  ns:ietf  nstype:protocol  comment:"Some IETF structs"
 dmmeta.ns  ns:lib_ctype  nstype:lib  comment:"Helpful library for reading/writing ctypes as text tuples"
 dmmeta.ns  ns:lib_exec  nstype:lib  comment:"Build and run a dag of subprocesses with N parallel jobs"
diff --git a/data/dmmeta/nsx.ssim b/data/dmmeta/nsx.ssim
index 7c4ad44ee..4187d268d 100644
--- a/data/dmmeta/nsx.ssim
+++ b/data/dmmeta/nsx.ssim
@@ -20,6 +20,7 @@ dmmeta.nsx  ns:bash2html  genthrow:Y  correct_getorcreate:Y  pool:algo_lib.FDb.m
 dmmeta.nsx  ns:command  genthrow:Y  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:N  pack:N  fldoffset_asserts:Y  comment:""
 dmmeta.nsx  ns:dev  genthrow:N  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:N  pack:N  fldoffset_asserts:N  comment:""
 dmmeta.nsx  ns:dmmeta  genthrow:N  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:N  pack:N  fldoffset_asserts:N  comment:""
+dmmeta.nsx  ns:gitlab  genthrow:Y  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:Y  pack:N  fldoffset_asserts:N  comment:""
 dmmeta.nsx  ns:ietf  genthrow:N  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:N  pack:Y  fldoffset_asserts:Y  comment:""
 dmmeta.nsx  ns:lib_ctype  genthrow:Y  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:Y  pack:N  fldoffset_asserts:N  comment:""
 dmmeta.nsx  ns:lib_exec  genthrow:N  correct_getorcreate:Y  pool:algo_lib.FDb.malloc  sortxref:N  pack:N  fldoffset_asserts:N  comment:""
diff --git a/data/dmmeta/ptrary.ssim b/data/dmmeta/ptrary.ssim
index e55fa6812..cafaa0175 100644
--- a/data/dmmeta/ptrary.ssim
+++ b/data/dmmeta/ptrary.ssim
@@ -65,6 +65,10 @@ dmmeta.ptrary  field:amc_vis.FDb.c_linklist  unique:Y
 dmmeta.ptrary  field:atf_amc.FCascdel.c_child_ptrary  unique:Y
 dmmeta.ptrary  field:atf_amc.FDb.c_typek  unique:Y
 dmmeta.ptrary  field:atf_amc.FUnitSort.c_ptrary  unique:N
+dmmeta.ptrary  field:gitlab.FIssue.c_issue_note  unique:Y
+dmmeta.ptrary  field:gitlab.FMr.c_mr_note  unique:Y
+dmmeta.ptrary  field:gitlab.FProject.c_issue  unique:Y
+dmmeta.ptrary  field:gitlab.FProject.c_mr  unique:Y
 dmmeta.ptrary  field:lib_ctype.FCtype.c_cfmt  unique:Y
 dmmeta.ptrary  field:lib_ctype.FCtype.c_field  unique:Y
 dmmeta.ptrary  field:lib_exec.FSyscmd.c_next  unique:Y
diff --git a/data/dmmeta/ssimfile.ssim b/data/dmmeta/ssimfile.ssim
index 1778bbee7..8425de53b 100644
--- a/data/dmmeta/ssimfile.ssim
+++ b/data/dmmeta/ssimfile.ssim
@@ -14,6 +14,7 @@ dmmeta.ssimfile  ssimfile:dev.cfg  ctype:dev.Cfg
 dmmeta.ssimfile  ssimfile:dev.compiler  ctype:dev.Compiler
 dmmeta.ssimfile  ssimfile:dev.gitfile  ctype:dev.Gitfile
 dmmeta.ssimfile  ssimfile:dev.gitinfo  ctype:dev.Gitinfo
+dmmeta.ssimfile  ssimfile:dev.gitlab_project  ctype:dev.GitlabProject
 dmmeta.ssimfile  ssimfile:dev.htmlentity  ctype:dev.Htmlentity
 dmmeta.ssimfile  ssimfile:dev.license  ctype:dev.License
 dmmeta.ssimfile  ssimfile:dev.linelim  ctype:dev.Linelim
diff --git a/data/dmmeta/ssimsort.ssim b/data/dmmeta/ssimsort.ssim
index 488ebfb57..ae0348472 100644
--- a/data/dmmeta/ssimsort.ssim
+++ b/data/dmmeta/ssimsort.ssim
@@ -12,6 +12,7 @@ dmmeta.ssimsort  ssimfile:dev.cfg  sortfld:dev.Cfg.cfg  comment:""
 dmmeta.ssimsort  ssimfile:dev.compiler  sortfld:dev.Compiler.compiler  comment:""
 dmmeta.ssimsort  ssimfile:dev.gitfile  sortfld:dev.Gitfile.gitfile  comment:""
 dmmeta.ssimsort  ssimfile:dev.gitinfo  sortfld:dev.Gitinfo.gitinfo  comment:""
+dmmeta.ssimsort  ssimfile:dev.gitlab_project  sortfld:dev.GitlabProject.gitlab_project  comment:""
 dmmeta.ssimsort  ssimfile:dev.htmlentity  sortfld:dev.Htmlentity.htmlentity  comment:""
 dmmeta.ssimsort  ssimfile:dev.license  sortfld:dev.License.license  comment:""
 dmmeta.ssimsort  ssimfile:dev.linelim  sortfld:dev.Linelim.gitfile  comment:""
diff --git a/data/dmmeta/substr.ssim b/data/dmmeta/substr.ssim
index ea644dae8..79f32080b 100644
--- a/data/dmmeta/substr.ssim
+++ b/data/dmmeta/substr.ssim
@@ -90,5 +90,13 @@ dmmeta.substr  field:dmmeta.Xref.keyfld  expr:/RR  srcfield:dmmeta.Xref.via
 dmmeta.substr  field:dmmeta.Xref.name  expr:.RR  srcfield:dmmeta.Xref.field
 dmmeta.substr  field:dmmeta.Xref.ns  expr:.LL  srcfield:dmmeta.Xref.field
 dmmeta.substr  field:dmmeta.Xref.viafld  expr:/LL  srcfield:dmmeta.Xref.via
+dmmeta.substr  field:gitlab.Issue.iid  expr:.RR  srcfield:gitlab.Issue.issue
+dmmeta.substr  field:gitlab.Issue.project  expr:.RL  srcfield:gitlab.Issue.issue
+dmmeta.substr  field:gitlab.IssueNote.id  expr:.RR  srcfield:gitlab.IssueNote.issue_note
+dmmeta.substr  field:gitlab.IssueNote.issue  expr:.RL  srcfield:gitlab.IssueNote.issue_note
+dmmeta.substr  field:gitlab.Mr.iid  expr:.RR  srcfield:gitlab.Mr.mr
+dmmeta.substr  field:gitlab.Mr.project  expr:.RL  srcfield:gitlab.Mr.mr
+dmmeta.substr  field:gitlab.MrNote.id  expr:.RR  srcfield:gitlab.MrNote.mr_note
+dmmeta.substr  field:gitlab.MrNote.mr  expr:.RL  srcfield:gitlab.MrNote.mr_note
 dmmeta.substr  field:ssim2mysql.FColumn.name  expr:.RR  srcfield:ssim2mysql.FColumn.column
 dmmeta.substr  field:ssim2mysql.FColumn.ssimfile  expr:.RL  srcfield:ssim2mysql.FColumn.column
diff --git a/data/dmmeta/tary.ssim b/data/dmmeta/tary.ssim
index a7ca833d8..d9080a1f7 100644
--- a/data/dmmeta/tary.ssim
+++ b/data/dmmeta/tary.ssim
@@ -31,6 +31,8 @@ dmmeta.tary  field:atf_unit.FPerfSort.index  aliased:N  comment:""
 dmmeta.tary  field:atf_unit.FPerfSort.orig  aliased:N  comment:""
 dmmeta.tary  field:atf_unit.FPerfSort.sorted  aliased:Y  comment:""
 dmmeta.tary  field:atf_unit.ShStreamAry.shstream  aliased:N  comment:""
+dmmeta.tary  field:gitlab.FHttp.request_header  aliased:N  comment:""
+dmmeta.tary  field:gitlab.FHttp.response_header  aliased:N  comment:""
 dmmeta.tary  field:mysql2ssim.FDb.in_tables  aliased:N  comment:""
 dmmeta.tary  field:mysql2ssim.FDb.table_names  aliased:N  comment:""
 dmmeta.tary  field:mysql2ssim.FTobltin.vals  aliased:N  comment:""
diff --git a/data/dmmeta/thash.ssim b/data/dmmeta/thash.ssim
index 5c2b1b2ab..533dccf8e 100644
--- a/data/dmmeta/thash.ssim
+++ b/data/dmmeta/thash.ssim
@@ -93,6 +93,12 @@ dmmeta.thash  field:atf_norm.FDb.ind_scriptfile  hashfld:dev.Scriptfile.gitfile
 dmmeta.thash  field:atf_norm.FDb.ind_ssimfile  hashfld:dmmeta.Ssimfile.ssimfile  unique:Y  comment:""
 dmmeta.thash  field:atf_nrun.FDb.ind_running  hashfld:atf_nrun.FEntry.pid  unique:Y  comment:""
 dmmeta.thash  field:atf_unit.FDb.ind_unittest  hashfld:atfdb.Unittest.unittest  unique:Y  comment:""
+dmmeta.thash  field:gitlab.FDb.ind_issue  hashfld:gitlab.Issue.issue  unique:Y  comment:""
+dmmeta.thash  field:gitlab.FDb.ind_issue_note  hashfld:gitlab.IssueNote.issue_note  unique:Y  comment:""
+dmmeta.thash  field:gitlab.FDb.ind_mr  hashfld:gitlab.Mr.mr  unique:Y  comment:""
+dmmeta.thash  field:gitlab.FDb.ind_mr_note  hashfld:gitlab.MrNote.mr_note  unique:Y  comment:""
+dmmeta.thash  field:gitlab.FDb.ind_project  hashfld:dev.GitlabProject.gitlab_project  unique:Y  comment:""
+dmmeta.thash  field:gitlab.FDb.ind_user  hashfld:gitlab.User.user  unique:Y  comment:""
 dmmeta.thash  field:lib_ctype.FDb.ind_cfmt  hashfld:dmmeta.Cfmt.cfmt  unique:Y  comment:""
 dmmeta.thash  field:lib_ctype.FDb.ind_ctype  hashfld:dmmeta.Ctype.ctype  unique:Y  comment:""
 dmmeta.thash  field:lib_ctype.FDb.ind_fconst  hashfld:dmmeta.Fconst.fconst  unique:Y  comment:""
diff --git a/data/dmmeta/tracerec.ssim b/data/dmmeta/tracerec.ssim
index 06b833657..c749e893c 100644
--- a/data/dmmeta/tracerec.ssim
+++ b/data/dmmeta/tracerec.ssim
@@ -13,6 +13,7 @@ dmmeta.tracerec  tracerec:atf_norm.trace  comment:""
 dmmeta.tracerec  tracerec:atf_nrun.trace  comment:""
 dmmeta.tracerec  tracerec:atf_unit.trace  comment:""
 dmmeta.tracerec  tracerec:bash2html.trace  comment:""
+dmmeta.tracerec  tracerec:gitlab.trace  comment:""
 dmmeta.tracerec  tracerec:lib_ctype.trace  comment:""
 dmmeta.tracerec  tracerec:lib_exec.trace  comment:""
 dmmeta.tracerec  tracerec:lib_git.trace  comment:""
diff --git a/data/dmmeta/xref.ssim b/data/dmmeta/xref.ssim
index 17956fce7..72dbbb18f 100644
--- a/data/dmmeta/xref.ssim
+++ b/data/dmmeta/xref.ssim
@@ -395,6 +395,24 @@ dmmeta.xref  field:atf_nrun.FDb.ind_running  inscond:false  via:""
 dmmeta.xref  field:atf_nrun.FDb.zd_todo  inscond:false  via:""
 dmmeta.xref  field:atf_unit.FDb.tr_number  inscond:true  via:""
 dmmeta.xref  field:atf_unit.FDb.ind_unittest  inscond:true  via:""
+dmmeta.xref  field:gitlab.FIssue.p_project  inscond:true  via:gitlab.FDb.ind_project/gitlab.Issue.project
+dmmeta.xref  field:gitlab.FProject.c_issue  inscond:true  via:gitlab.FDb.ind_project/gitlab.Issue.project
+dmmeta.xref  field:gitlab.FMr.p_project  inscond:true  via:gitlab.FDb.ind_project/gitlab.Mr.project
+dmmeta.xref  field:gitlab.FProject.c_mr  inscond:true  via:gitlab.FDb.ind_project/gitlab.Mr.project
+dmmeta.xref  field:gitlab.FDb.ind_project  inscond:true  via:""
+dmmeta.xref  field:gitlab.FDb.ind_issue  inscond:true  via:""
+dmmeta.xref  field:gitlab.FDb.ind_issue_note  inscond:true  via:""
+dmmeta.xref  field:gitlab.FDb.ind_mr  inscond:true  via:""
+dmmeta.xref  field:gitlab.FDb.ind_mr_note  inscond:true  via:""
+dmmeta.xref  field:gitlab.FDb.ind_user  inscond:true  via:""
+dmmeta.xref  field:gitlab.FIssue.c_issue_note  inscond:true  via:gitlab.FDb.ind_issue/gitlab.IssueNote.issue
+dmmeta.xref  field:gitlab.FIssue.c_issue_description  inscond:true  via:gitlab.FDb.ind_issue/gitlab.IssueDescription.issue
+dmmeta.xref  field:gitlab.FIssueDescription.p_issue  inscond:true  via:gitlab.FDb.ind_issue/gitlab.IssueDescription.issue
+dmmeta.xref  field:gitlab.FIssueNote.p_issue  inscond:true  via:gitlab.FDb.ind_issue/gitlab.IssueNote.issue
+dmmeta.xref  field:gitlab.FMr.c_mr_note  inscond:true  via:gitlab.FDb.ind_mr/gitlab.MrNote.mr
+dmmeta.xref  field:gitlab.FMr.c_mr_description  inscond:true  via:gitlab.FDb.ind_mr/gitlab.MrDescription.mr
+dmmeta.xref  field:gitlab.FMrDescription.p_mr  inscond:true  via:gitlab.FDb.ind_mr/gitlab.MrDescription.mr
+dmmeta.xref  field:gitlab.FMrNote.p_mr  inscond:true  via:gitlab.FDb.ind_mr/gitlab.MrNote.mr
 dmmeta.xref  field:lib_ctype.FDb.ind_fconst  inscond:true  via:""
 dmmeta.xref  field:lib_ctype.FDb.ind_fconst_key  inscond:false  via:""
 dmmeta.xref  field:lib_ctype.FDb.ind_ssimfile  inscond:true  via:""
diff --git a/include/gen/command_gen.h b/include/gen/command_gen.h
index a8507f3b2..97f18db16 100644
--- a/include/gen/command_gen.h
+++ b/include/gen/command_gen.h
@@ -141,62 +141,80 @@ enum command_FieldIdEnum {                    // command.FieldId.value
     ,command_FieldId_perf_secs         = 124
     ,command_FieldId_pertest_timeout   = 125
     ,command_FieldId_capture           = 126
-    ,command_FieldId_complooo          = 127
-    ,command_FieldId_args              = 128
-    ,command_FieldId_manywin           = 129
-    ,command_FieldId_root              = 130
-    ,command_FieldId_attach            = 131
-    ,command_FieldId_catchthrow        = 132
-    ,command_FieldId_tui               = 133
-    ,command_FieldId_bcmd              = 134
-    ,command_FieldId_emacs             = 135
-    ,command_FieldId_follow_child      = 136
-    ,command_FieldId_py                = 137
-    ,command_FieldId_writessimfile     = 138
-    ,command_FieldId_url               = 139
-    ,command_FieldId_tables            = 140
-    ,command_FieldId_nologo            = 141
-    ,command_FieldId_baddbok           = 142
-    ,command_FieldId_typetag           = 143
-    ,command_FieldId_move              = 144
-    ,command_FieldId_dedup             = 145
-    ,command_FieldId_commit            = 146
-    ,command_FieldId_undo              = 147
-    ,command_FieldId_hash              = 148
-    ,command_FieldId_targsrc           = 149
-    ,command_FieldId_name              = 150
-    ,command_FieldId_body              = 151
-    ,command_FieldId_func              = 152
-    ,command_FieldId_nextfile          = 153
-    ,command_FieldId_other             = 154
-    ,command_FieldId_updateproto       = 155
-    ,command_FieldId_listfunc          = 156
-    ,command_FieldId_iffy              = 157
-    ,command_FieldId_gen               = 158
-    ,command_FieldId_showloc           = 159
-    ,command_FieldId_showstatic        = 160
-    ,command_FieldId_showsortkey       = 161
-    ,command_FieldId_sortname          = 162
-    ,command_FieldId_baddecl           = 163
-    ,command_FieldId_update_authors    = 164
-    ,command_FieldId_indent            = 165
-    ,command_FieldId_linelim           = 166
-    ,command_FieldId_strayfile         = 167
-    ,command_FieldId_badchar           = 168
-    ,command_FieldId_badline           = 169
-    ,command_FieldId_expand            = 170
-    ,command_FieldId_ignoreQuote       = 171
-    ,command_FieldId_maxpacket         = 172
-    ,command_FieldId_db                = 173
-    ,command_FieldId_createdb          = 174
-    ,command_FieldId_str               = 175
-    ,command_FieldId_tocamelcase       = 176
-    ,command_FieldId_tolowerunder      = 177
-    ,command_FieldId_pathcomp          = 178
-    ,command_FieldId_value             = 179
+    ,command_FieldId_issue             = 127
+    ,command_FieldId_server            = 128
+    ,command_FieldId_project           = 129
+    ,command_FieldId_auth_token        = 130
+    ,command_FieldId_mrlist            = 131
+    ,command_FieldId_mergereq          = 132
+    ,command_FieldId_ilist             = 133
+    ,command_FieldId_istart            = 134
+    ,command_FieldId_iadd              = 135
+    ,command_FieldId_ic                = 136
+    ,command_FieldId_iclose            = 137
+    ,command_FieldId_iassignto         = 138
+    ,command_FieldId_title             = 139
+    ,command_FieldId_description       = 140
+    ,command_FieldId_gitdir            = 141
+    ,command_FieldId_assignee          = 142
+    ,command_FieldId_ulist             = 143
+    ,command_FieldId_mraccept          = 144
+    ,command_FieldId_complooo          = 145
+    ,command_FieldId_args              = 146
+    ,command_FieldId_manywin           = 147
+    ,command_FieldId_root              = 148
+    ,command_FieldId_attach            = 149
+    ,command_FieldId_catchthrow        = 150
+    ,command_FieldId_tui               = 151
+    ,command_FieldId_bcmd              = 152
+    ,command_FieldId_emacs             = 153
+    ,command_FieldId_follow_child      = 154
+    ,command_FieldId_py                = 155
+    ,command_FieldId_writessimfile     = 156
+    ,command_FieldId_url               = 157
+    ,command_FieldId_tables            = 158
+    ,command_FieldId_nologo            = 159
+    ,command_FieldId_baddbok           = 160
+    ,command_FieldId_typetag           = 161
+    ,command_FieldId_move              = 162
+    ,command_FieldId_dedup             = 163
+    ,command_FieldId_commit            = 164
+    ,command_FieldId_undo              = 165
+    ,command_FieldId_hash              = 166
+    ,command_FieldId_targsrc           = 167
+    ,command_FieldId_name              = 168
+    ,command_FieldId_body              = 169
+    ,command_FieldId_func              = 170
+    ,command_FieldId_nextfile          = 171
+    ,command_FieldId_other             = 172
+    ,command_FieldId_updateproto       = 173
+    ,command_FieldId_listfunc          = 174
+    ,command_FieldId_iffy              = 175
+    ,command_FieldId_gen               = 176
+    ,command_FieldId_showloc           = 177
+    ,command_FieldId_showstatic        = 178
+    ,command_FieldId_showsortkey       = 179
+    ,command_FieldId_sortname          = 180
+    ,command_FieldId_baddecl           = 181
+    ,command_FieldId_update_authors    = 182
+    ,command_FieldId_indent            = 183
+    ,command_FieldId_linelim           = 184
+    ,command_FieldId_strayfile         = 185
+    ,command_FieldId_badchar           = 186
+    ,command_FieldId_badline           = 187
+    ,command_FieldId_expand            = 188
+    ,command_FieldId_ignoreQuote       = 189
+    ,command_FieldId_maxpacket         = 190
+    ,command_FieldId_db                = 191
+    ,command_FieldId_createdb          = 192
+    ,command_FieldId_str               = 193
+    ,command_FieldId_tocamelcase       = 194
+    ,command_FieldId_tolowerunder      = 195
+    ,command_FieldId_pathcomp          = 196
+    ,command_FieldId_value             = 197
 };
 
-enum { command_FieldIdEnum_N = 180 };
+enum { command_FieldIdEnum_N = 198 };
 
 namespace command { struct FieldId; }
 namespace command { struct Protocol; }
@@ -231,6 +249,8 @@ namespace command { struct bash; }
 namespace command { struct bash2html; }
 namespace command { struct bash2html_proc; }
 namespace command { struct bash_proc; }
+namespace command { struct gitlab; }
+namespace command { struct gitlab_proc; }
 namespace command { struct lib_ctype; }
 namespace command { struct lib_exec; }
 namespace command { struct mdbg; }
@@ -1459,6 +1479,99 @@ algo::tempstr        bash_ToCmdline(command::bash_proc& parent) __attribute__((n
 void                 bash_proc_Init(command::bash_proc& parent);
 void                 bash_proc_Uninit(command::bash_proc& parent) __attribute__((nothrow));
 
+// --- command.gitlab
+// access: command.gitlab_proc.gitlab (Exec)
+struct gitlab { // command.gitlab
+    algo::cstring      in;            //   "data"  Input directory or filename, - for stdin
+    algo_lib::Regx     issue;         //   ""  Regx of algo::cstring
+    algo::cstring      server;        //   "gitlab.lon.algo"  (config) GitLab server host
+    algo::cstring      project;       //   "myproject"  (config) Project to use
+    algo::cstring      auth_token;    //   ""  (config) GitLab auth token
+    bool               mrlist;        //   false  (action) Show list of merge requests
+    bool               mergereq;      //   false  (action) Push current branch to origin, create merge request
+    bool               ilist;         //   false  (action) Show list of issues matching regx
+    bool               istart;        //   false  (action) Start working on the specified issue
+    bool               t;             //   false  Tree view: expand issue description
+    bool               iadd;          //   false  (action) Add new issue
+    bool               ic;            //   false  (action) Add issue comment
+    bool               iclose;        //   false  (action) Close issue
+    algo::Smallstr50   iassignto;     //   ""  (action) Assign issue to user
+    algo::cstring      title;         //   ""  (with -iadd), skip editor and use argument as title
+    algo::cstring      description;   //   ""  (with -iadd -title), use argument as description
+    algo::cstring      comment;       //   ""  (with -ic), skip editor and use argument as comment
+    algo::cstring      gitdir;        //   ""  (setup) Change directory of dit repository
+    algo_lib::Regx     assignee;      //   ""  Regx of algo::cstring
+    bool               ulist;         //   false  (action) List users
+    algo::cstring      mraccept;      //   ""  (action) Accept merge request
+    gitlab();
+};
+
+// Print back to string
+void                 issue_Print(command::gitlab& parent, algo::cstring &out) __attribute__((nothrow));
+// Read Regx from string
+// Convert string to field. Return success value
+bool                 issue_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) __attribute__((nothrow));
+
+// Print back to string
+void                 assignee_Print(command::gitlab& parent, algo::cstring &out) __attribute__((nothrow));
+// Read Regx from string
+// Convert string to field. Return success value
+bool                 assignee_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) __attribute__((nothrow));
+
+bool                 gitlab_ReadFieldMaybe(command::gitlab &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
+// Read fields of command::gitlab from attributes of ascii tuple TUPLE
+bool                 gitlab_ReadTupleMaybe(command::gitlab &parent, algo::Tuple &tuple) __attribute__((nothrow));
+// Set all fields to initial values.
+void                 gitlab_Init(command::gitlab& parent);
+// print command-line args of command::gitlab to string  -- cprint:command.gitlab.Argv
+void                 gitlab_PrintArgv(command::gitlab & row, algo::cstring &str) __attribute__((nothrow));
+// Convenience function that returns a full command line
+// Assume command is in a directory called bin
+tempstr              gitlab_ToCmdline(command::gitlab & row) __attribute__((nothrow));
+algo::strptr         gitlab_GetAnon(command::gitlab &parent, i32 idx) __attribute__((nothrow));
+
+// --- command.gitlab_proc
+struct gitlab_proc { // command.gitlab_proc: Subprocess: Gitlab command line interface
+    algo::cstring     path;      //   "bin/gitlab"  path for executable
+    command::gitlab   cmd;       // command line for child process
+    algo::cstring     fstdin;    // redirect for stdin
+    algo::cstring     fstdout;   // redirect for stdout
+    algo::cstring     fstderr;   // redirect for stderr
+    pid_t             pid;       //   0  pid of running child process
+    i32               timeout;   //   0  optional timeout for child process
+    i32               status;    //   0  last exit status of child process
+    gitlab_proc();
+    ~gitlab_proc();
+private:
+    // reftype of command.gitlab_proc.gitlab prohibits copy
+    gitlab_proc(const gitlab_proc&){ /*disallow copy constructor */}
+    void operator =(const gitlab_proc&){ /*disallow direct assignment */}
+};
+
+// Start subprocess
+// If subprocess already running, do nothing. Otherwise, start it
+int                  gitlab_Start(command::gitlab_proc& parent) __attribute__((nothrow));
+// Start subprocess & Read output
+algo::Fildes         gitlab_StartRead(command::gitlab_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
+// Kill subprocess and wait
+void                 gitlab_Kill(command::gitlab_proc& parent);
+// Wait for subprocess to return
+void                 gitlab_Wait(command::gitlab_proc& parent) __attribute__((nothrow));
+// Start + Wait
+// Execute subprocess and return exit code
+int                  gitlab_Exec(command::gitlab_proc& parent) __attribute__((nothrow));
+// Start + Wait, throw exception on error
+// Execute subprocess; throw human-readable exception on error
+void                 gitlab_ExecX(command::gitlab_proc& parent);
+// Call execv()
+// Call execv with specified parameters -- cprint:gitlab.Argv
+int                  gitlab_Execv(command::gitlab_proc& parent) __attribute__((nothrow));
+algo::tempstr        gitlab_ToCmdline(command::gitlab_proc& parent) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 gitlab_proc_Init(command::gitlab_proc& parent);
+void                 gitlab_proc_Uninit(command::gitlab_proc& parent) __attribute__((nothrow));
+
 // --- command.lib_ctype
 struct lib_ctype { // command.lib_ctype
     algo::cstring   in;   //   "data"  Input directory or filename, - for stdin
diff --git a/include/gen/command_gen.inl.h b/include/gen/command_gen.inl.h
index c39df0fd9..d2e7d8f4a 100644
--- a/include/gen/command_gen.inl.h
+++ b/include/gen/command_gen.inl.h
@@ -394,6 +394,27 @@ inline void command::bash_proc_Init(command::bash_proc& parent) {
     parent.timeout = i32(0);
     parent.status = i32(0);
 }
+inline command::gitlab::gitlab() {
+    command::gitlab_Init(*this);
+}
+
+inline command::gitlab_proc::gitlab_proc() {
+    command::gitlab_proc_Init(*this);
+}
+
+inline command::gitlab_proc::~gitlab_proc() {
+    command::gitlab_proc_Uninit(*this);
+}
+
+
+// --- command.gitlab_proc..Init
+// Set all fields to initial values.
+inline void command::gitlab_proc_Init(command::gitlab_proc& parent) {
+    parent.path = algo::strptr("bin/gitlab");
+    parent.pid = pid_t(0);
+    parent.timeout = i32(0);
+    parent.status = i32(0);
+}
 inline command::lib_ctype::lib_ctype() {
     command::lib_ctype_Init(*this);
 }
diff --git a/include/gen/dev_gen.h b/include/gen/dev_gen.h
index 3cabea32a..8cd9b8202 100644
--- a/include/gen/dev_gen.h
+++ b/include/gen/dev_gen.h
@@ -57,79 +57,82 @@ extern const char *  dev_Compiler_compiler_gPP_9;     // g++-9      fconst:dev.C
 
 // --- dev_FieldIdEnum
 
-enum dev_FieldIdEnum {                // dev.FieldId.value
-     dev_FieldId_arch           = 0
-    ,dev_FieldId_comment        = 1
-    ,dev_FieldId_badline        = 2
-    ,dev_FieldId_expr           = 3
-    ,dev_FieldId_targsrc_regx   = 4
-    ,dev_FieldId_builddir       = 5
-    ,dev_FieldId_uname          = 6
-    ,dev_FieldId_compiler       = 7
-    ,dev_FieldId_cfg            = 8
-    ,dev_FieldId_suffix         = 9
-    ,dev_FieldId_ranlib         = 10
-    ,dev_FieldId_ar             = 11
-    ,dev_FieldId_link           = 12
-    ,dev_FieldId_libext         = 13
-    ,dev_FieldId_exeext         = 14
-    ,dev_FieldId_pchext         = 15
-    ,dev_FieldId_objext         = 16
-    ,dev_FieldId_rc             = 17
-    ,dev_FieldId_gitfile        = 18
-    ,dev_FieldId_ext            = 19
-    ,dev_FieldId_gitinfo        = 20
-    ,dev_FieldId_author         = 21
-    ,dev_FieldId_compver        = 22
-    ,dev_FieldId_package        = 23
-    ,dev_FieldId_htmlentity     = 24
-    ,dev_FieldId_code           = 25
-    ,dev_FieldId_include        = 26
-    ,dev_FieldId_srcfile        = 27
-    ,dev_FieldId_filename       = 28
-    ,dev_FieldId_sys            = 29
-    ,dev_FieldId_license        = 30
-    ,dev_FieldId_nlongline      = 31
-    ,dev_FieldId_longestline    = 32
-    ,dev_FieldId_nbadws         = 33
-    ,dev_FieldId_maxws          = 34
-    ,dev_FieldId_nlongfunc      = 35
-    ,dev_FieldId_longestfunc    = 36
-    ,dev_FieldId_nmysteryfunc   = 37
-    ,dev_FieldId_badness        = 38
-    ,dev_FieldId_opt_type       = 39
-    ,dev_FieldId_sep            = 40
-    ,dev_FieldId_inl            = 41
-    ,dev_FieldId_sandbox        = 42
-    ,dev_FieldId_args           = 43
-    ,dev_FieldId_syscmd         = 44
-    ,dev_FieldId_execkey        = 45
-    ,dev_FieldId_command        = 46
-    ,dev_FieldId_pid            = 47
-    ,dev_FieldId_status         = 48
-    ,dev_FieldId_nprereq        = 49
-    ,dev_FieldId_fail_prereq    = 50
-    ,dev_FieldId_completed      = 51
-    ,dev_FieldId_maxtime        = 52
-    ,dev_FieldId_syscmddep      = 53
-    ,dev_FieldId_child          = 54
-    ,dev_FieldId_parent         = 55
-    ,dev_FieldId_syslib         = 56
-    ,dev_FieldId_targdep        = 57
-    ,dev_FieldId_target         = 58
-    ,dev_FieldId_compat         = 59
-    ,dev_FieldId_targsrc        = 60
-    ,dev_FieldId_src            = 61
-    ,dev_FieldId_targsyslib     = 62
-    ,dev_FieldId_timefmt        = 63
-    ,dev_FieldId_dirname        = 64
-    ,dev_FieldId_tool_opt       = 65
-    ,dev_FieldId_opt            = 66
-    ,dev_FieldId_sortfld        = 67
-    ,dev_FieldId_value          = 68
+enum dev_FieldIdEnum {                     // dev.FieldId.value
+     dev_FieldId_arch                = 0
+    ,dev_FieldId_comment             = 1
+    ,dev_FieldId_badline             = 2
+    ,dev_FieldId_expr                = 3
+    ,dev_FieldId_targsrc_regx        = 4
+    ,dev_FieldId_builddir            = 5
+    ,dev_FieldId_uname               = 6
+    ,dev_FieldId_compiler            = 7
+    ,dev_FieldId_cfg                 = 8
+    ,dev_FieldId_suffix              = 9
+    ,dev_FieldId_ranlib              = 10
+    ,dev_FieldId_ar                  = 11
+    ,dev_FieldId_link                = 12
+    ,dev_FieldId_libext              = 13
+    ,dev_FieldId_exeext              = 14
+    ,dev_FieldId_pchext              = 15
+    ,dev_FieldId_objext              = 16
+    ,dev_FieldId_rc                  = 17
+    ,dev_FieldId_gitfile             = 18
+    ,dev_FieldId_ext                 = 19
+    ,dev_FieldId_gitinfo             = 20
+    ,dev_FieldId_author              = 21
+    ,dev_FieldId_compver             = 22
+    ,dev_FieldId_package             = 23
+    ,dev_FieldId_gitlab_project      = 24
+    ,dev_FieldId_url                 = 25
+    ,dev_FieldId_gitlab_project_id   = 26
+    ,dev_FieldId_htmlentity          = 27
+    ,dev_FieldId_code                = 28
+    ,dev_FieldId_include             = 29
+    ,dev_FieldId_srcfile             = 30
+    ,dev_FieldId_filename            = 31
+    ,dev_FieldId_sys                 = 32
+    ,dev_FieldId_license             = 33
+    ,dev_FieldId_nlongline           = 34
+    ,dev_FieldId_longestline         = 35
+    ,dev_FieldId_nbadws              = 36
+    ,dev_FieldId_maxws               = 37
+    ,dev_FieldId_nlongfunc           = 38
+    ,dev_FieldId_longestfunc         = 39
+    ,dev_FieldId_nmysteryfunc        = 40
+    ,dev_FieldId_badness             = 41
+    ,dev_FieldId_opt_type            = 42
+    ,dev_FieldId_sep                 = 43
+    ,dev_FieldId_inl                 = 44
+    ,dev_FieldId_sandbox             = 45
+    ,dev_FieldId_args                = 46
+    ,dev_FieldId_syscmd              = 47
+    ,dev_FieldId_execkey             = 48
+    ,dev_FieldId_command             = 49
+    ,dev_FieldId_pid                 = 50
+    ,dev_FieldId_status              = 51
+    ,dev_FieldId_nprereq             = 52
+    ,dev_FieldId_fail_prereq         = 53
+    ,dev_FieldId_completed           = 54
+    ,dev_FieldId_maxtime             = 55
+    ,dev_FieldId_syscmddep           = 56
+    ,dev_FieldId_child               = 57
+    ,dev_FieldId_parent              = 58
+    ,dev_FieldId_syslib              = 59
+    ,dev_FieldId_targdep             = 60
+    ,dev_FieldId_target              = 61
+    ,dev_FieldId_compat              = 62
+    ,dev_FieldId_targsrc             = 63
+    ,dev_FieldId_src                 = 64
+    ,dev_FieldId_targsyslib          = 65
+    ,dev_FieldId_timefmt             = 66
+    ,dev_FieldId_dirname             = 67
+    ,dev_FieldId_tool_opt            = 68
+    ,dev_FieldId_opt                 = 69
+    ,dev_FieldId_sortfld             = 70
+    ,dev_FieldId_value               = 71
 };
 
-enum { dev_FieldIdEnum_N = 69 };
+enum { dev_FieldIdEnum_N = 72 };
 
 extern const char *  dev_Target_target_;             //               fconst:dev.Target.target/
 extern const char *  dev_Target_target_abt;          // abt           fconst:dev.Target.target/abt
@@ -148,6 +151,7 @@ extern const char *  dev_Target_target_atf_norm;     // atf_norm      fconst:dev
 extern const char *  dev_Target_target_atf_nrun;     // atf_nrun      fconst:dev.Target.target/atf_nrun
 extern const char *  dev_Target_target_atf_unit;     // atf_unit      fconst:dev.Target.target/atf_unit
 extern const char *  dev_Target_target_bash2html;    // bash2html     fconst:dev.Target.target/bash2html
+extern const char *  dev_Target_target_gitlab;       // gitlab        fconst:dev.Target.target/gitlab
 extern const char *  dev_Target_target_lib_ctype;    // lib_ctype     fconst:dev.Target.target/lib_ctype
 extern const char *  dev_Target_target_lib_exec;     // lib_exec      fconst:dev.Target.target/lib_exec
 extern const char *  dev_Target_target_lib_git;      // lib_git       fconst:dev.Target.target/lib_git
@@ -174,6 +178,7 @@ namespace dev { struct Compiler; }
 namespace dev { struct FieldId; }
 namespace dev { struct Gitfile; }
 namespace dev { struct Gitinfo; }
+namespace dev { struct GitlabProject; }
 namespace dev { struct Htmlentity; }
 namespace dev { struct Include; }
 namespace dev { struct License; }
@@ -202,6 +207,7 @@ namespace dev {
     typedef algo::Smallstr50 CompilerPkey;
     typedef algo::Smallstr200 GitfilePkey;
     typedef algo::Smallstr40 GitinfoPkey;
+    typedef algo::Smallstr50 GitlabProjectPkey;
     typedef algo::Smallstr50 HtmlentityPkey;
     typedef algo::Smallstr200 IncludePkey;
     typedef algo::Smallstr50 LicensePkey;
@@ -410,6 +416,24 @@ bool                 Gitinfo_ReadStrptrMaybe(dev::Gitinfo &parent, algo::strptr
 // print string representation of dev::Gitinfo to string LHS, no header -- cprint:dev.Gitinfo.String
 void                 Gitinfo_Print(dev::Gitinfo & row, algo::cstring &str) __attribute__((nothrow));
 
+// --- dev.GitlabProject
+struct GitlabProject { // dev.GitlabProject: Gitlab project
+    algo::Smallstr50    gitlab_project;      //
+    algo::Smallstr200   url;                 //
+    algo::Comment       comment;             //
+    u32                 gitlab_project_id;   //   0  Numeric project ID on gitlab server, displayed on project overview Web page
+    GitlabProject();
+};
+
+bool                 GitlabProject_ReadFieldMaybe(dev::GitlabProject &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
+// Read fields of dev::GitlabProject from an ascii string.
+// The format of the string is an ssim Tuple
+bool                 GitlabProject_ReadStrptrMaybe(dev::GitlabProject &parent, algo::strptr in_str);
+// Set all fields to initial values.
+void                 GitlabProject_Init(dev::GitlabProject& parent);
+// print string representation of dev::GitlabProject to string LHS, no header -- cprint:dev.GitlabProject.String
+void                 GitlabProject_Print(dev::GitlabProject & row, algo::cstring &str) __attribute__((nothrow));
+
 // --- dev.Htmlentity
 struct Htmlentity { // dev.Htmlentity
     algo::Smallstr50   htmlentity;   //
@@ -829,6 +853,7 @@ namespace algo {
 inline algo::cstring &operator <<(algo::cstring &str, const dev::Badline &row);// cfmt:dev.Badline.String
 inline algo::cstring &operator <<(algo::cstring &str, const dev::FieldId &row);// cfmt:dev.FieldId.String
 inline algo::cstring &operator <<(algo::cstring &str, const dev::Gitfile &row);// cfmt:dev.Gitfile.String
+inline algo::cstring &operator <<(algo::cstring &str, const dev::GitlabProject &row);// cfmt:dev.GitlabProject.String
 inline algo::cstring &operator <<(algo::cstring &str, const dev::Htmlentity &row);// cfmt:dev.Htmlentity.String
 inline algo::cstring &operator <<(algo::cstring &str, const dev::Include &row);// cfmt:dev.Include.String
 inline algo::cstring &operator <<(algo::cstring &str, const dev::License &row);// cfmt:dev.License.String
diff --git a/include/gen/dev_gen.inl.h b/include/gen/dev_gen.inl.h
index 533d801f2..97210f3bc 100644
--- a/include/gen/dev_gen.inl.h
+++ b/include/gen/dev_gen.inl.h
@@ -117,6 +117,16 @@ inline dev::Gitinfo::Gitinfo(const algo::strptr&            in_gitinfo
 inline dev::Gitinfo::Gitinfo() {
 }
 
+inline dev::GitlabProject::GitlabProject() {
+    dev::GitlabProject_Init(*this);
+}
+
+
+// --- dev.GitlabProject..Init
+// Set all fields to initial values.
+inline void dev::GitlabProject_Init(dev::GitlabProject& parent) {
+    parent.gitlab_project_id = u32(0);
+}
 inline dev::Htmlentity::Htmlentity() {
     dev::Htmlentity_Init(*this);
 }
@@ -334,6 +344,11 @@ inline algo::cstring &algo::operator <<(algo::cstring &str, const dev::Gitfile &
     return str;
 }
 
+inline algo::cstring &algo::operator <<(algo::cstring &str, const dev::GitlabProject &row) {// cfmt:dev.GitlabProject.String
+    dev::GitlabProject_Print(const_cast<dev::GitlabProject&>(row), str);
+    return str;
+}
+
 inline algo::cstring &algo::operator <<(algo::cstring &str, const dev::Htmlentity &row) {// cfmt:dev.Htmlentity.String
     dev::Htmlentity_Print(const_cast<dev::Htmlentity&>(row), str);
     return str;
diff --git a/include/gen/dmmeta_gen.h b/include/gen/dmmeta_gen.h
index 79b9b54bd..9f2e90d8e 100644
--- a/include/gen/dmmeta_gen.h
+++ b/include/gen/dmmeta_gen.h
@@ -220,6 +220,7 @@ extern const char *  dmmeta_Ns_ns_bash2html;    // bash2html     fconst:dmmeta.N
 extern const char *  dmmeta_Ns_ns_command;      // command       fconst:dmmeta.Ns.ns/command
 extern const char *  dmmeta_Ns_ns_dev;          // dev           fconst:dmmeta.Ns.ns/dev
 extern const char *  dmmeta_Ns_ns_dmmeta;       // dmmeta        fconst:dmmeta.Ns.ns/dmmeta
+extern const char *  dmmeta_Ns_ns_gitlab;       // gitlab        fconst:dmmeta.Ns.ns/gitlab
 extern const char *  dmmeta_Ns_ns_ietf;         // ietf          fconst:dmmeta.Ns.ns/ietf
 extern const char *  dmmeta_Ns_ns_lib_ctype;    // lib_ctype     fconst:dmmeta.Ns.ns/lib_ctype
 extern const char *  dmmeta_Ns_ns_lib_exec;     // lib_exec      fconst:dmmeta.Ns.ns/lib_exec
@@ -388,6 +389,7 @@ extern const char *  dmmeta_Ssimfile_ssimfile_dev_cfg;               // dev.cfg
 extern const char *  dmmeta_Ssimfile_ssimfile_dev_compiler;          // dev.compiler           fconst:dmmeta.Ssimfile.ssimfile/dev.compiler
 extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitfile;           // dev.gitfile            fconst:dmmeta.Ssimfile.ssimfile/dev.gitfile
 extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitinfo;           // dev.gitinfo            fconst:dmmeta.Ssimfile.ssimfile/dev.gitinfo
+extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitlab_project;    // dev.gitlab_project     fconst:dmmeta.Ssimfile.ssimfile/dev.gitlab_project
 extern const char *  dmmeta_Ssimfile_ssimfile_dev_htmlentity;        // dev.htmlentity         fconst:dmmeta.Ssimfile.ssimfile/dev.htmlentity
 extern const char *  dmmeta_Ssimfile_ssimfile_dev_license;           // dev.license            fconst:dmmeta.Ssimfile.ssimfile/dev.license
 extern const char *  dmmeta_Ssimfile_ssimfile_dev_linelim;           // dev.linelim            fconst:dmmeta.Ssimfile.ssimfile/dev.linelim
diff --git a/include/gen/gitlab_gen.h b/include/gen/gitlab_gen.h
new file mode 100644
index 000000000..72f430920
--- /dev/null
+++ b/include/gen/gitlab_gen.h
@@ -0,0 +1,1418 @@
+//
+// include/gen/gitlab_gen.h
+// Generated by AMC
+//
+// (C) AlgoEngineering LLC 2008-2013
+// (C) NYSE | Intercontinental Exchange 2013-2016
+//
+
+
+#pragma once
+#include "include/gen/command_gen.h"
+#include "include/gen/algo_gen.h"
+#include "include/gen/lib_json_gen.h"
+#include "include/gen/dev_gen.h"
+//#pragma endinclude
+
+// --- gitlab_FHttp_request_method_Enum
+
+enum gitlab_FHttp_request_method_Enum {        // gitlab.FHttp.request_method
+     gitlab_FHttp_request_method_GET     = 0   // GET
+    ,gitlab_FHttp_request_method_POST    = 1   // POST
+    ,gitlab_FHttp_request_method_PUT     = 2   // PUT
+};
+
+enum { gitlab_FHttp_request_method_Enum_N = 3 };
+
+
+// --- gitlab_FieldIdEnum
+
+enum gitlab_FieldIdEnum {        // gitlab.FieldId.value
+     gitlab_FieldId_value   = 0
+};
+
+enum { gitlab_FieldIdEnum_N = 1 };
+
+
+// --- gitlab_TableIdEnum
+
+enum gitlab_TableIdEnum {                      // gitlab.TableId.value
+     gitlab_TableId_dev_GitlabProject    = 0   // dev.GitlabProject -> gitlab.FProject
+    ,gitlab_TableId_dev_gitlab_project   = 0   // dev.gitlab_project -> gitlab.FProject
+};
+
+enum { gitlab_TableIdEnum_N = 2 };
+
+namespace gitlab { struct Issue; }
+namespace gitlab { struct FProject; }
+namespace gitlab { struct IssueDescription; }
+namespace gitlab { struct FIssue; }
+namespace gitlab { struct IssueNote; }
+namespace gitlab { struct Mr; }
+namespace gitlab { struct MrDescription; }
+namespace gitlab { struct FMr; }
+namespace gitlab { struct MrNote; }
+namespace gitlab { struct User; }
+namespace gitlab { struct trace; }
+namespace gitlab { struct FDb; }
+namespace gitlab { struct FHttp; }
+namespace gitlab { struct FIssueDescription; }
+namespace gitlab { struct FIssueNote; }
+namespace gitlab { struct FMrDescription; }
+namespace gitlab { struct FMrNote; }
+namespace gitlab { struct FUser; }
+namespace gitlab { struct FieldId; }
+namespace gitlab { struct TableId; }
+namespace gitlab { struct _db_project_curs; }
+namespace gitlab { struct _db_ind_project_curs; }
+namespace gitlab { struct _db_ind_issue_curs; }
+namespace gitlab { struct _db_issue_curs; }
+namespace gitlab { struct _db_issue_note_curs; }
+namespace gitlab { struct _db_ind_issue_note_curs; }
+namespace gitlab { struct _db_issue_description_curs; }
+namespace gitlab { struct _db_ind_mr_curs; }
+namespace gitlab { struct _db_mr_curs; }
+namespace gitlab { struct _db_mr_note_curs; }
+namespace gitlab { struct _db_ind_mr_note_curs; }
+namespace gitlab { struct _db_mr_description_curs; }
+namespace gitlab { struct _db_user_curs; }
+namespace gitlab { struct _db_ind_user_curs; }
+namespace gitlab { struct FHttp_request_header_curs; }
+namespace gitlab { struct FHttp_response_header_curs; }
+namespace gitlab { struct issue_c_issue_note_curs; }
+namespace gitlab { struct mr_c_mr_note_curs; }
+namespace gitlab { struct project_c_issue_curs; }
+namespace gitlab { struct project_c_mr_curs; }
+namespace gitlab {
+    typedef algo::Smallstr50 IssuePkey;
+    typedef algo::Smallstr50 MrPkey;
+    typedef algo::Smallstr50 UserPkey;
+}//pkey typedefs
+namespace gitlab {
+extern const char *gitlab_help;
+extern const char *gitlab_syntax;
+extern FDb _db;
+
+// --- gitlab.trace
+#pragma pack(push,1)
+struct trace { // gitlab.trace
+    trace();
+};
+#pragma pack(pop)
+
+// print string representation of gitlab::trace to string LHS, no header -- cprint:gitlab.trace.String
+void                 trace_Print(gitlab::trace & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.FDb
+// create: gitlab.FDb._db (Global)
+struct FDb { // gitlab.FDb
+    command::gitlab              cmdline;                        //
+    algo::cstring                home;                           // User's HOME directory
+    algo::cstring                unix_user;                      // UNIX user login name
+    algo::cstring                auth_file_name;                 //   ".gitlab_auth"  Basename of the file where to store GitLab auth token
+    algo::cstring                auth_token;                     // GitLab auth token
+    algo::cstring                auth_file;                      // File where to store gitlab auth token
+    algo::cstring                usrmsg_no_token;                //   "Please supply personal access token via -auth_token option (could be done once). Visit <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html> for directions. Token scope shall be 'api', i.e. whole GitLab API."  Message to show if no auth token
+    algo::cstring                http_auth_header;               // Ready-made HTTP authorization header
+    algo::cstring                rest_api;                       // Base URI of server REST API
+    gitlab::FProject*            project_lary[32];               // level array
+    i32                          project_n;                      // number of elements in array
+    u32                          project_id;                     //   0  Numeric project ID on gitlab server
+    gitlab::FProject**           ind_project_buckets_elems;      // pointer to bucket array
+    i32                          ind_project_buckets_n;          // number of elements in bucket array
+    i32                          ind_project_n;                  // number of elements in the hash table
+    gitlab::FIssue**             ind_issue_buckets_elems;        // pointer to bucket array
+    i32                          ind_issue_buckets_n;            // number of elements in bucket array
+    i32                          ind_issue_n;                    // number of elements in the hash table
+    gitlab::FIssue*              issue_lary[32];                 // level array
+    i32                          issue_n;                        // number of elements in array
+    gitlab::FIssueNote*          issue_note_lary[32];            // level array
+    i32                          issue_note_n;                   // number of elements in array
+    gitlab::FIssueNote**         ind_issue_note_buckets_elems;   // pointer to bucket array
+    i32                          ind_issue_note_buckets_n;       // number of elements in bucket array
+    i32                          ind_issue_note_n;               // number of elements in the hash table
+    gitlab::FIssueDescription*   issue_description_lary[32];     // level array
+    i32                          issue_description_n;            // number of elements in array
+    algo::cstring                editor;                         // Command line to invoke editor
+    gitlab::FMr**                ind_mr_buckets_elems;           // pointer to bucket array
+    i32                          ind_mr_buckets_n;               // number of elements in bucket array
+    i32                          ind_mr_n;                       // number of elements in the hash table
+    gitlab::FMr*                 mr_lary[32];                    // level array
+    i32                          mr_n;                           // number of elements in array
+    gitlab::FMrNote*             mr_note_lary[32];               // level array
+    i32                          mr_note_n;                      // number of elements in array
+    gitlab::FMrNote**            ind_mr_note_buckets_elems;      // pointer to bucket array
+    i32                          ind_mr_note_buckets_n;          // number of elements in bucket array
+    i32                          ind_mr_note_n;                  // number of elements in the hash table
+    gitlab::FMrDescription*      mr_description_lary[32];        // level array
+    i32                          mr_description_n;               // number of elements in array
+    gitlab::FUser*               user_lary[32];                  // level array
+    i32                          user_n;                         // number of elements in array
+    gitlab::FUser**              ind_user_buckets_elems;         // pointer to bucket array
+    i32                          ind_user_buckets_n;             // number of elements in bucket array
+    i32                          ind_user_n;                     // number of elements in the hash table
+    gitlab::trace                trace;                          //
+};
+
+// Main function
+void                 MainArgs(int argc, char **argv);
+// Main loop.
+void                 MainLoop();
+// Main step
+void                 Step();
+// Main function
+void                 Main();
+void                 StaticCheck();
+// Parse strptr into known type and add to database.
+// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
+bool                 InsertStrptrMaybe(algo::strptr str);
+// Load all finputs from given directory.
+bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
+// Load specified ssimfile.
+bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 _db_XrefMaybe();
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FProject&    project_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FProject*    project_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FProject*    project_InsertMaybe(const dev::GitlabProject &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                project_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 project_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FProject*    project_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FProject*    project_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  project_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 project_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 project_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FProject&    project_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 project_XrefMaybe(gitlab::FProject &row);
+
+// Return true if hash is empty
+bool                 ind_project_EmptyQ() __attribute__((nothrow));
+// Find row by key. Return NULL if not found.
+gitlab::FProject*    ind_project_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FProject&    ind_project_FindX(const algo::strptr& key);
+// Find row by key. If not found, create and x-reference a new row with with this key.
+gitlab::FProject&    ind_project_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
+// Return number of items in the hash
+i32                  ind_project_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool                 ind_project_InsertMaybe(gitlab::FProject& row) __attribute__((nothrow));
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void                 ind_project_Remove(gitlab::FProject& row) __attribute__((nothrow));
+// Reserve enough room in the hash for N more elements. Return success code.
+void                 ind_project_Reserve(int n) __attribute__((nothrow));
+
+// Return true if hash is empty
+bool                 ind_issue_EmptyQ() __attribute__((nothrow));
+// Find row by key. Return NULL if not found.
+gitlab::FIssue*      ind_issue_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FIssue&      ind_issue_FindX(const algo::strptr& key);
+// Return number of items in the hash
+i32                  ind_issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool                 ind_issue_InsertMaybe(gitlab::FIssue& row) __attribute__((nothrow));
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void                 ind_issue_Remove(gitlab::FIssue& row) __attribute__((nothrow));
+// Reserve enough room in the hash for N more elements. Return success code.
+void                 ind_issue_Reserve(int n) __attribute__((nothrow));
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FIssue&      issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FIssue*      issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FIssue*      issue_InsertMaybe(const gitlab::Issue &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                issue_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 issue_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FIssue*      issue_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FIssue*      issue_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 issue_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 issue_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FIssue&      issue_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 issue_XrefMaybe(gitlab::FIssue &row);
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FIssueNote&  issue_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FIssueNote*  issue_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FIssueNote*  issue_note_InsertMaybe(const gitlab::IssueNote &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                issue_note_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 issue_note_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FIssueNote*  issue_note_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FIssueNote*  issue_note_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  issue_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 issue_note_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 issue_note_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FIssueNote&  issue_note_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 issue_note_XrefMaybe(gitlab::FIssueNote &row);
+
+// Return true if hash is empty
+bool                 ind_issue_note_EmptyQ() __attribute__((nothrow));
+// Find row by key. Return NULL if not found.
+gitlab::FIssueNote*  ind_issue_note_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FIssueNote&  ind_issue_note_FindX(const algo::strptr& key);
+// Return number of items in the hash
+i32                  ind_issue_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool                 ind_issue_note_InsertMaybe(gitlab::FIssueNote& row) __attribute__((nothrow));
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void                 ind_issue_note_Remove(gitlab::FIssueNote& row) __attribute__((nothrow));
+// Reserve enough room in the hash for N more elements. Return success code.
+void                 ind_issue_note_Reserve(int n) __attribute__((nothrow));
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FIssueDescription& issue_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FIssueDescription* issue_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FIssueDescription* issue_description_InsertMaybe(const gitlab::IssueDescription &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                issue_description_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 issue_description_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FIssueDescription* issue_description_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FIssueDescription* issue_description_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  issue_description_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 issue_description_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 issue_description_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FIssueDescription& issue_description_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 issue_description_XrefMaybe(gitlab::FIssueDescription &row);
+
+// Return true if hash is empty
+bool                 ind_mr_EmptyQ() __attribute__((nothrow));
+// Find row by key. Return NULL if not found.
+gitlab::FMr*         ind_mr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FMr&         ind_mr_FindX(const algo::strptr& key);
+// Return number of items in the hash
+i32                  ind_mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool                 ind_mr_InsertMaybe(gitlab::FMr& row) __attribute__((nothrow));
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void                 ind_mr_Remove(gitlab::FMr& row) __attribute__((nothrow));
+// Reserve enough room in the hash for N more elements. Return success code.
+void                 ind_mr_Reserve(int n) __attribute__((nothrow));
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FMr&         mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FMr*         mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FMr*         mr_InsertMaybe(const gitlab::Mr &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                mr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 mr_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FMr*         mr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FMr*         mr_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 mr_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 mr_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FMr&         mr_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 mr_XrefMaybe(gitlab::FMr &row);
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FMrNote&     mr_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FMrNote*     mr_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FMrNote*     mr_note_InsertMaybe(const gitlab::MrNote &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                mr_note_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 mr_note_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FMrNote*     mr_note_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FMrNote*     mr_note_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  mr_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 mr_note_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 mr_note_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FMrNote&     mr_note_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 mr_note_XrefMaybe(gitlab::FMrNote &row);
+
+// Return true if hash is empty
+bool                 ind_mr_note_EmptyQ() __attribute__((nothrow));
+// Find row by key. Return NULL if not found.
+gitlab::FMrNote*     ind_mr_note_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FMrNote&     ind_mr_note_FindX(const algo::strptr& key);
+// Return number of items in the hash
+i32                  ind_mr_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool                 ind_mr_note_InsertMaybe(gitlab::FMrNote& row) __attribute__((nothrow));
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void                 ind_mr_note_Remove(gitlab::FMrNote& row) __attribute__((nothrow));
+// Reserve enough room in the hash for N more elements. Return success code.
+void                 ind_mr_note_Reserve(int n) __attribute__((nothrow));
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FMrDescription& mr_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FMrDescription* mr_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FMrDescription* mr_description_InsertMaybe(const gitlab::MrDescription &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                mr_description_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 mr_description_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FMrDescription* mr_description_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FMrDescription* mr_description_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  mr_description_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 mr_description_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 mr_description_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FMrDescription& mr_description_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 mr_description_XrefMaybe(gitlab::FMrDescription &row);
+
+// Allocate memory for new default row.
+// If out of memory, process is killed.
+gitlab::FUser&       user_Alloc() __attribute__((__warn_unused_result__, nothrow));
+// Allocate memory for new element. If out of memory, return NULL.
+gitlab::FUser*       user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+// Create new row from struct.
+// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
+gitlab::FUser*       user_InsertMaybe(const gitlab::User &value) __attribute__((nothrow));
+// Allocate space for one element. If no memory available, return NULL.
+void*                user_AllocMem() __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 user_EmptyQ() __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FUser*       user_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+gitlab::FUser*       user_Last() __attribute__((nothrow, pure));
+// Return number of items in the pool
+i32                  user_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove all elements from Lary
+void                 user_RemoveAll() __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 user_RemoveLast() __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+gitlab::FUser&       user_qFind(u64 t) __attribute__((nothrow));
+// Insert row into all appropriate indices. If error occurs, store error
+// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
+bool                 user_XrefMaybe(gitlab::FUser &row);
+
+// Return true if hash is empty
+bool                 ind_user_EmptyQ() __attribute__((nothrow));
+// Find row by key. Return NULL if not found.
+gitlab::FUser*       ind_user_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
+// Look up row by key and return reference. Throw exception if not found
+gitlab::FUser&       ind_user_FindX(const algo::strptr& key);
+// Find row by key. If not found, create and x-reference a new row with with this key.
+gitlab::FUser&       ind_user_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
+// Return number of items in the hash
+i32                  ind_user_N() __attribute__((__warn_unused_result__, nothrow, pure));
+// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
+bool                 ind_user_InsertMaybe(gitlab::FUser& row) __attribute__((nothrow));
+// Remove reference to element from hash index. If element is not in hash, do nothing
+void                 ind_user_Remove(gitlab::FUser& row) __attribute__((nothrow));
+// Reserve enough room in the hash for N more elements. Return success code.
+void                 ind_user_Reserve(int n) __attribute__((nothrow));
+
+// cursor points to valid item
+void                 _db_project_curs_Reset(_db_project_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_project_curs_ValidQ(_db_project_curs &curs);
+// proceed to next item
+void                 _db_project_curs_Next(_db_project_curs &curs);
+// item access
+gitlab::FProject&    _db_project_curs_Access(_db_project_curs &curs);
+// cursor points to valid item
+void                 _db_issue_curs_Reset(_db_issue_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_issue_curs_ValidQ(_db_issue_curs &curs);
+// proceed to next item
+void                 _db_issue_curs_Next(_db_issue_curs &curs);
+// item access
+gitlab::FIssue&      _db_issue_curs_Access(_db_issue_curs &curs);
+// cursor points to valid item
+void                 _db_issue_note_curs_Reset(_db_issue_note_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_issue_note_curs_ValidQ(_db_issue_note_curs &curs);
+// proceed to next item
+void                 _db_issue_note_curs_Next(_db_issue_note_curs &curs);
+// item access
+gitlab::FIssueNote&  _db_issue_note_curs_Access(_db_issue_note_curs &curs);
+// cursor points to valid item
+void                 _db_issue_description_curs_Reset(_db_issue_description_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_issue_description_curs_ValidQ(_db_issue_description_curs &curs);
+// proceed to next item
+void                 _db_issue_description_curs_Next(_db_issue_description_curs &curs);
+// item access
+gitlab::FIssueDescription& _db_issue_description_curs_Access(_db_issue_description_curs &curs);
+// cursor points to valid item
+void                 _db_mr_curs_Reset(_db_mr_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_mr_curs_ValidQ(_db_mr_curs &curs);
+// proceed to next item
+void                 _db_mr_curs_Next(_db_mr_curs &curs);
+// item access
+gitlab::FMr&         _db_mr_curs_Access(_db_mr_curs &curs);
+// cursor points to valid item
+void                 _db_mr_note_curs_Reset(_db_mr_note_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_mr_note_curs_ValidQ(_db_mr_note_curs &curs);
+// proceed to next item
+void                 _db_mr_note_curs_Next(_db_mr_note_curs &curs);
+// item access
+gitlab::FMrNote&     _db_mr_note_curs_Access(_db_mr_note_curs &curs);
+// cursor points to valid item
+void                 _db_mr_description_curs_Reset(_db_mr_description_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_mr_description_curs_ValidQ(_db_mr_description_curs &curs);
+// proceed to next item
+void                 _db_mr_description_curs_Next(_db_mr_description_curs &curs);
+// item access
+gitlab::FMrDescription& _db_mr_description_curs_Access(_db_mr_description_curs &curs);
+// cursor points to valid item
+void                 _db_user_curs_Reset(_db_user_curs &curs, gitlab::FDb &parent);
+// cursor points to valid item
+bool                 _db_user_curs_ValidQ(_db_user_curs &curs);
+// proceed to next item
+void                 _db_user_curs_Next(_db_user_curs &curs);
+// item access
+gitlab::FUser&       _db_user_curs_Access(_db_user_curs &curs);
+// Set all fields to initial values.
+void                 FDb_Init();
+void                 FDb_Uninit() __attribute__((nothrow));
+
+// --- gitlab.FHttp
+struct FHttp { // gitlab.FHttp: HTTP request
+    algo::cstring       request_uri;                  // URI of requested resource
+    algo::cstring*      request_header_elems;         // pointer to elements
+    u32                 request_header_n;             // number of elements in array
+    u32                 request_header_max;           // max. capacity of array before realloc
+    algo::cstring       request_content_type;         // Request content type
+    algo::cstring       request_body;                 // Request body
+    algo::cstring       response_status_line;         // Status line
+    u32                 response_status_code;         //   0  Numeric status code
+    u32                 request_method;               //   gitlab_FHttp_request_method_GET  Request method
+    algo::cstring       response_reason_phrase;       // Status message
+    algo::cstring*      response_header_elems;        // pointer to elements
+    u32                 response_header_n;            // number of elements in array
+    u32                 response_header_max;          // max. capacity of array before realloc
+    algo::cstring       response_content_type;        // Response content type
+    algo::cstring       response_body;                // Response body
+    bool                response_content_type_json;   //   false  Flag if response is JSON
+    lib_json::FParser   response_json_parser;         // Json parser to parse response body on the fly
+    u32                 request_body_sent_bytes;      //   0  Sent bytes in request body
+    FHttp();
+    ~FHttp();
+private:
+    // reftype of gitlab.FHttp.request_header prohibits copy
+    // reftype of gitlab.FHttp.response_header prohibits copy
+    // value field gitlab.FHttp.response_json_parser is not copiable
+    // ... and several other reasons
+    FHttp(const FHttp&){ /*disallow copy constructor */}
+    void operator =(const FHttp&){ /*disallow direct assignment */}
+};
+
+// Reserve space. Insert element at the end
+// The new element is initialized to a default value
+algo::cstring&       request_header_Alloc(gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow));
+// Reserve space for new element, reallocating the array if necessary
+// Insert new element at specified index. Index must be in range or a fatal error occurs.
+algo::cstring&       request_header_AllocAt(gitlab::FHttp& parent, int at) __attribute__((__warn_unused_result__, nothrow));
+// Reserve space. Insert N elements at the end of the array, return pointer to array
+algo::aryptr<algo::cstring> request_header_AllocN(gitlab::FHttp& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 request_header_EmptyQ(gitlab::FHttp& parent) __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+algo::cstring*       request_header_Find(gitlab::FHttp& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return array pointer by value
+algo::aryptr<algo::cstring> request_header_Getary(gitlab::FHttp& parent) __attribute__((nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+algo::cstring*       request_header_Last(gitlab::FHttp& parent) __attribute__((nothrow, pure));
+// Return max. number of items in the array
+i32                  request_header_Max(gitlab::FHttp& parent) __attribute__((nothrow));
+// Return number of items in the array
+i32                  request_header_N(const gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove item by index. If index outside of range, do nothing.
+void                 request_header_Remove(gitlab::FHttp& parent, u32 i) __attribute__((nothrow));
+void                 request_header_RemoveAll(gitlab::FHttp& parent) __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 request_header_RemoveLast(gitlab::FHttp& parent) __attribute__((nothrow));
+// Make sure N *more* elements will fit in array. Process dies if out of memory
+void                 request_header_Reserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
+// Make sure N elements fit in array. Process dies if out of memory
+void                 request_header_AbsReserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
+// Copy contents of RHS to PARENT.
+void                 request_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+algo::cstring&       request_header_qFind(gitlab::FHttp& parent, u64 t) __attribute__((nothrow));
+// Return reference to last element of array. No bounds checking
+algo::cstring&       request_header_qLast(gitlab::FHttp& parent) __attribute__((nothrow));
+// Return row id of specified element
+u64                  request_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) __attribute__((nothrow));
+
+// Get value of field as enum type
+gitlab_FHttp_request_method_Enum request_method_GetEnum(const gitlab::FHttp& parent) __attribute__((nothrow));
+// Set value of field from enum type.
+void                 request_method_SetEnum(gitlab::FHttp& parent, gitlab_FHttp_request_method_Enum rhs) __attribute__((nothrow));
+// Convert numeric value of field to one of predefined string constants.
+// If string is found, return a static C string. Otherwise, return NULL.
+const char*          request_method_ToCstr(const gitlab::FHttp& parent) __attribute__((nothrow));
+// Convert request_method to a string. First, attempt conversion to a known string.
+// If no string matches, print request_method as a numeric value.
+void                 request_method_Print(const gitlab::FHttp& parent, algo::cstring &lhs) __attribute__((nothrow));
+// Convert string to field.
+// If the string is invalid, do not modify field and return false.
+// In case of success, return true
+bool                 request_method_SetStrptrMaybe(gitlab::FHttp& parent, algo::strptr rhs) __attribute__((nothrow));
+// Convert string to field.
+// If the string is invalid, set numeric value to DFLT
+void                 request_method_SetStrptr(gitlab::FHttp& parent, algo::strptr rhs, gitlab_FHttp_request_method_Enum dflt) __attribute__((nothrow));
+
+// Reserve space. Insert element at the end
+// The new element is initialized to a default value
+algo::cstring&       response_header_Alloc(gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow));
+// Reserve space for new element, reallocating the array if necessary
+// Insert new element at specified index. Index must be in range or a fatal error occurs.
+algo::cstring&       response_header_AllocAt(gitlab::FHttp& parent, int at) __attribute__((__warn_unused_result__, nothrow));
+// Reserve space. Insert N elements at the end of the array, return pointer to array
+algo::aryptr<algo::cstring> response_header_AllocN(gitlab::FHttp& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
+// Return true if index is empty
+bool                 response_header_EmptyQ(gitlab::FHttp& parent) __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+algo::cstring*       response_header_Find(gitlab::FHttp& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
+// Return array pointer by value
+algo::aryptr<algo::cstring> response_header_Getary(gitlab::FHttp& parent) __attribute__((nothrow));
+// Return pointer to last element of array, or NULL if array is empty
+algo::cstring*       response_header_Last(gitlab::FHttp& parent) __attribute__((nothrow, pure));
+// Return max. number of items in the array
+i32                  response_header_Max(gitlab::FHttp& parent) __attribute__((nothrow));
+// Return number of items in the array
+i32                  response_header_N(const gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow, pure));
+// Remove item by index. If index outside of range, do nothing.
+void                 response_header_Remove(gitlab::FHttp& parent, u32 i) __attribute__((nothrow));
+void                 response_header_RemoveAll(gitlab::FHttp& parent) __attribute__((nothrow));
+// Delete last element of array. Do nothing if array is empty.
+void                 response_header_RemoveLast(gitlab::FHttp& parent) __attribute__((nothrow));
+// Make sure N *more* elements will fit in array. Process dies if out of memory
+void                 response_header_Reserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
+// Make sure N elements fit in array. Process dies if out of memory
+void                 response_header_AbsReserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
+// Copy contents of RHS to PARENT.
+void                 response_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) __attribute__((nothrow));
+// 'quick' Access row by row id. No bounds checking.
+algo::cstring&       response_header_qFind(gitlab::FHttp& parent, u64 t) __attribute__((nothrow));
+// Return reference to last element of array. No bounds checking
+algo::cstring&       response_header_qLast(gitlab::FHttp& parent) __attribute__((nothrow));
+// Return row id of specified element
+u64                  response_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) __attribute__((nothrow));
+
+// proceed to next item
+void                 FHttp_request_header_curs_Next(FHttp_request_header_curs &curs);
+void                 FHttp_request_header_curs_Reset(FHttp_request_header_curs &curs, gitlab::FHttp &parent);
+// cursor points to valid item
+bool                 FHttp_request_header_curs_ValidQ(FHttp_request_header_curs &curs);
+// item access
+algo::cstring&       FHttp_request_header_curs_Access(FHttp_request_header_curs &curs);
+// proceed to next item
+void                 FHttp_response_header_curs_Next(FHttp_response_header_curs &curs);
+void                 FHttp_response_header_curs_Reset(FHttp_response_header_curs &curs, gitlab::FHttp &parent);
+// cursor points to valid item
+bool                 FHttp_response_header_curs_ValidQ(FHttp_response_header_curs &curs);
+// item access
+algo::cstring&       FHttp_response_header_curs_Access(FHttp_response_header_curs &curs);
+// Set all fields to initial values.
+void                 FHttp_Init(gitlab::FHttp& parent);
+void                 FHttp_Uninit(gitlab::FHttp& parent) __attribute__((nothrow));
+// print string representation of gitlab::FHttp to string LHS, no header -- cprint:gitlab.FHttp.String
+void                 FHttp_Print(gitlab::FHttp & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.FIssue
+// create: gitlab.FDb.issue (Lary)
+// global access: ind_issue (Thash)
+// access: gitlab.FIssueDescription.p_issue (Upptr)
+// access: gitlab.FIssueNote.p_issue (Upptr)
+// access: gitlab.FProject.c_issue (Ptrary)
+struct FIssue { // gitlab.FIssue
+    gitlab::FIssue*              ind_issue_next;           // hash next
+    algo::Smallstr50             issue;                    // Identifier. must be in form project.iid
+    algo::Smallstr50             assignee;                 // User the issue is assigned to
+    algo::cstring                title;                    // Issue title
+    gitlab::FProject*            p_project;                // reference to parent row
+    gitlab::FIssueNote**         c_issue_note_elems;       // array of pointers
+    u32                          c_issue_note_n;           // array of pointers
+    u32                          c_issue_note_max;         // capacity of allocated array
+    gitlab::FIssueDescription*   c_issue_description;      // optional pointer
+    bool                         select;                   //   false
+    bool                         project_c_issue_in_ary;   //   false  membership flag
+private:
+    friend gitlab::FIssue&      issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FIssue*      issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 issue_RemoveAll() __attribute__((nothrow));
+    friend void                 issue_RemoveLast() __attribute__((nothrow));
+    FIssue();
+    ~FIssue();
+    FIssue(const FIssue&){ /*disallow copy constructor */}
+    void operator =(const FIssue&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 issue_CopyOut(gitlab::FIssue &row, gitlab::Issue &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 issue_CopyIn(gitlab::FIssue &row, gitlab::Issue &in) __attribute__((nothrow));
+
+algo::Smallstr50     project_Get(gitlab::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  iid_Get(gitlab::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));
+
+// Return true if index is empty
+bool                 c_issue_note_EmptyQ(gitlab::FIssue& issue) __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FIssueNote*  c_issue_note_Find(gitlab::FIssue& issue, u32 t) __attribute__((__warn_unused_result__, nothrow));
+// Return array of pointers
+algo::aryptr<gitlab::FIssueNote*> c_issue_note_Getary(gitlab::FIssue& issue) __attribute__((nothrow));
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void                 c_issue_note_Insert(gitlab::FIssue& issue, gitlab::FIssueNote& row) __attribute__((nothrow));
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool                 c_issue_note_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueNote& row) __attribute__((nothrow));
+// Return number of items in the pointer array
+i32                  c_issue_note_N(const gitlab::FIssue& issue) __attribute__((__warn_unused_result__, nothrow, pure));
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void                 c_issue_note_Remove(gitlab::FIssue& issue, gitlab::FIssueNote& row) __attribute__((nothrow));
+// Empty the index. (The rows are not deleted)
+void                 c_issue_note_RemoveAll(gitlab::FIssue& issue) __attribute__((nothrow));
+// Reserve space in index for N more elements;
+void                 c_issue_note_Reserve(gitlab::FIssue& issue, u32 n) __attribute__((nothrow));
+
+// Insert row into pointer index. Return final membership status.
+bool                 c_issue_description_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueDescription& row) __attribute__((nothrow));
+// Remove element from index. If element is not in index, do nothing.
+void                 c_issue_description_Remove(gitlab::FIssue& issue, gitlab::FIssueDescription& row) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 FIssue_Init(gitlab::FIssue& issue);
+void                 issue_c_issue_note_curs_Reset(issue_c_issue_note_curs &curs, gitlab::FIssue &parent);
+// cursor points to valid item
+bool                 issue_c_issue_note_curs_ValidQ(issue_c_issue_note_curs &curs);
+// proceed to next item
+void                 issue_c_issue_note_curs_Next(issue_c_issue_note_curs &curs);
+// item access
+gitlab::FIssueNote&  issue_c_issue_note_curs_Access(issue_c_issue_note_curs &curs);
+void                 FIssue_Uninit(gitlab::FIssue& issue) __attribute__((nothrow));
+// print string representation of gitlab::FIssue to string LHS, no header -- cprint:gitlab.FIssue.String
+void                 FIssue_Print(gitlab::FIssue & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.FIssueDescription
+// create: gitlab.FDb.issue_description (Lary)
+// access: gitlab.FIssue.c_issue_description (Ptr)
+struct FIssueDescription { // gitlab.FIssueDescription
+    algo::Smallstr50   issue;         //
+    algo::cstring      description;   //
+    gitlab::FIssue*    p_issue;       // reference to parent row
+private:
+    friend gitlab::FIssueDescription& issue_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FIssueDescription* issue_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 issue_description_RemoveAll() __attribute__((nothrow));
+    friend void                 issue_description_RemoveLast() __attribute__((nothrow));
+    FIssueDescription();
+    ~FIssueDescription();
+    FIssueDescription(const FIssueDescription&){ /*disallow copy constructor */}
+    void operator =(const FIssueDescription&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 issue_description_CopyOut(gitlab::FIssueDescription &row, gitlab::IssueDescription &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 issue_description_CopyIn(gitlab::FIssueDescription &row, gitlab::IssueDescription &in) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 FIssueDescription_Init(gitlab::FIssueDescription& issue_description);
+void                 FIssueDescription_Uninit(gitlab::FIssueDescription& issue_description) __attribute__((nothrow));
+
+// --- gitlab.FIssueNote
+// create: gitlab.FDb.issue_note (Lary)
+// global access: ind_issue_note (Thash)
+// access: gitlab.FIssue.c_issue_note (Ptrary)
+struct FIssueNote { // gitlab.FIssueNote
+    gitlab::FIssueNote*   ind_issue_note_next;         // hash next
+    algo::Smallstr50      issue_note;                  // Identifier. must be in form issue.id
+    algo::cstring         body;                        // Body of issue note
+    gitlab::FIssue*       p_issue;                     // reference to parent row
+    bool                  issue_c_issue_note_in_ary;   //   false  membership flag
+private:
+    friend gitlab::FIssueNote&  issue_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FIssueNote*  issue_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 issue_note_RemoveAll() __attribute__((nothrow));
+    friend void                 issue_note_RemoveLast() __attribute__((nothrow));
+    FIssueNote();
+    ~FIssueNote();
+    FIssueNote(const FIssueNote&){ /*disallow copy constructor */}
+    void operator =(const FIssueNote&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 issue_note_CopyOut(gitlab::FIssueNote &row, gitlab::IssueNote &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 issue_note_CopyIn(gitlab::FIssueNote &row, gitlab::IssueNote &in) __attribute__((nothrow));
+
+algo::Smallstr50     issue_Get(gitlab::FIssueNote& issue_note) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  id_Get(gitlab::FIssueNote& issue_note) __attribute__((__warn_unused_result__, nothrow));
+
+// Set all fields to initial values.
+void                 FIssueNote_Init(gitlab::FIssueNote& issue_note);
+void                 FIssueNote_Uninit(gitlab::FIssueNote& issue_note) __attribute__((nothrow));
+
+// --- gitlab.FMr
+// create: gitlab.FDb.mr (Lary)
+// global access: ind_mr (Thash)
+// access: gitlab.FMrDescription.p_mr (Upptr)
+// access: gitlab.FMrNote.p_mr (Upptr)
+// access: gitlab.FProject.c_mr (Ptrary)
+struct FMr { // gitlab.FMr
+    gitlab::FMr*              ind_mr_next;           // hash next
+    algo::Smallstr50          mr;                    // Identifier. must be in form project.iid
+    algo::cstring             title;                 // Mr title
+    algo::cstring             source_branch;         // Source branch
+    algo::Smallstr20          pipeline_status;       // Pipeline status
+    gitlab::FProject*         p_project;             // reference to parent row
+    gitlab::FMrNote**         c_mr_note_elems;       // array of pointers
+    u32                       c_mr_note_n;           // array of pointers
+    u32                       c_mr_note_max;         // capacity of allocated array
+    gitlab::FMrDescription*   c_mr_description;      // optional pointer
+    bool                      project_c_mr_in_ary;   //   false  membership flag
+private:
+    friend gitlab::FMr&         mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FMr*         mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 mr_RemoveAll() __attribute__((nothrow));
+    friend void                 mr_RemoveLast() __attribute__((nothrow));
+    FMr();
+    ~FMr();
+    FMr(const FMr&){ /*disallow copy constructor */}
+    void operator =(const FMr&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 mr_CopyOut(gitlab::FMr &row, gitlab::Mr &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 mr_CopyIn(gitlab::FMr &row, gitlab::Mr &in) __attribute__((nothrow));
+
+algo::Smallstr50     project_Get(gitlab::FMr& mr) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  iid_Get(gitlab::FMr& mr) __attribute__((__warn_unused_result__, nothrow));
+
+// Return true if index is empty
+bool                 c_mr_note_EmptyQ(gitlab::FMr& mr) __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FMrNote*     c_mr_note_Find(gitlab::FMr& mr, u32 t) __attribute__((__warn_unused_result__, nothrow));
+// Return array of pointers
+algo::aryptr<gitlab::FMrNote*> c_mr_note_Getary(gitlab::FMr& mr) __attribute__((nothrow));
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void                 c_mr_note_Insert(gitlab::FMr& mr, gitlab::FMrNote& row) __attribute__((nothrow));
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool                 c_mr_note_InsertMaybe(gitlab::FMr& mr, gitlab::FMrNote& row) __attribute__((nothrow));
+// Return number of items in the pointer array
+i32                  c_mr_note_N(const gitlab::FMr& mr) __attribute__((__warn_unused_result__, nothrow, pure));
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void                 c_mr_note_Remove(gitlab::FMr& mr, gitlab::FMrNote& row) __attribute__((nothrow));
+// Empty the index. (The rows are not deleted)
+void                 c_mr_note_RemoveAll(gitlab::FMr& mr) __attribute__((nothrow));
+// Reserve space in index for N more elements;
+void                 c_mr_note_Reserve(gitlab::FMr& mr, u32 n) __attribute__((nothrow));
+
+// Insert row into pointer index. Return final membership status.
+bool                 c_mr_description_InsertMaybe(gitlab::FMr& mr, gitlab::FMrDescription& row) __attribute__((nothrow));
+// Remove element from index. If element is not in index, do nothing.
+void                 c_mr_description_Remove(gitlab::FMr& mr, gitlab::FMrDescription& row) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 FMr_Init(gitlab::FMr& mr);
+void                 mr_c_mr_note_curs_Reset(mr_c_mr_note_curs &curs, gitlab::FMr &parent);
+// cursor points to valid item
+bool                 mr_c_mr_note_curs_ValidQ(mr_c_mr_note_curs &curs);
+// proceed to next item
+void                 mr_c_mr_note_curs_Next(mr_c_mr_note_curs &curs);
+// item access
+gitlab::FMrNote&     mr_c_mr_note_curs_Access(mr_c_mr_note_curs &curs);
+void                 FMr_Uninit(gitlab::FMr& mr) __attribute__((nothrow));
+// print string representation of gitlab::FMr to string LHS, no header -- cprint:gitlab.FMr.String
+void                 FMr_Print(gitlab::FMr & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.FMrDescription
+// create: gitlab.FDb.mr_description (Lary)
+// access: gitlab.FMr.c_mr_description (Ptr)
+struct FMrDescription { // gitlab.FMrDescription
+    algo::Smallstr50   mr;            //
+    algo::cstring      description;   //
+    gitlab::FMr*       p_mr;          // reference to parent row
+private:
+    friend gitlab::FMrDescription& mr_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FMrDescription* mr_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 mr_description_RemoveAll() __attribute__((nothrow));
+    friend void                 mr_description_RemoveLast() __attribute__((nothrow));
+    FMrDescription();
+    ~FMrDescription();
+    FMrDescription(const FMrDescription&){ /*disallow copy constructor */}
+    void operator =(const FMrDescription&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 mr_description_CopyOut(gitlab::FMrDescription &row, gitlab::MrDescription &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 mr_description_CopyIn(gitlab::FMrDescription &row, gitlab::MrDescription &in) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 FMrDescription_Init(gitlab::FMrDescription& mr_description);
+void                 FMrDescription_Uninit(gitlab::FMrDescription& mr_description) __attribute__((nothrow));
+
+// --- gitlab.FMrNote
+// create: gitlab.FDb.mr_note (Lary)
+// global access: ind_mr_note (Thash)
+// access: gitlab.FMr.c_mr_note (Ptrary)
+struct FMrNote { // gitlab.FMrNote
+    gitlab::FMrNote*   ind_mr_note_next;      // hash next
+    algo::Smallstr50   mr_note;               // Identifier. must be in form mr.id
+    algo::cstring      body;                  // Body of mr note
+    gitlab::FMr*       p_mr;                  // reference to parent row
+    bool               mr_c_mr_note_in_ary;   //   false  membership flag
+private:
+    friend gitlab::FMrNote&     mr_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FMrNote*     mr_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 mr_note_RemoveAll() __attribute__((nothrow));
+    friend void                 mr_note_RemoveLast() __attribute__((nothrow));
+    FMrNote();
+    ~FMrNote();
+    FMrNote(const FMrNote&){ /*disallow copy constructor */}
+    void operator =(const FMrNote&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 mr_note_CopyOut(gitlab::FMrNote &row, gitlab::MrNote &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 mr_note_CopyIn(gitlab::FMrNote &row, gitlab::MrNote &in) __attribute__((nothrow));
+
+algo::Smallstr50     mr_Get(gitlab::FMrNote& mr_note) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  id_Get(gitlab::FMrNote& mr_note) __attribute__((__warn_unused_result__, nothrow));
+
+// Set all fields to initial values.
+void                 FMrNote_Init(gitlab::FMrNote& mr_note);
+void                 FMrNote_Uninit(gitlab::FMrNote& mr_note) __attribute__((nothrow));
+
+// --- gitlab.FProject
+// create: gitlab.FDb.project (Lary)
+// global access: ind_project (Thash)
+// access: gitlab.FIssue.p_project (Upptr)
+// access: gitlab.FMr.p_project (Upptr)
+struct FProject { // gitlab.FProject
+    gitlab::FProject*   ind_project_next;    // hash next
+    algo::Smallstr50    gitlab_project;      //
+    algo::Smallstr200   url;                 //
+    algo::Comment       comment;             //
+    u32                 gitlab_project_id;   //   0  Numeric project ID on gitlab server, displayed on project overview Web page
+    gitlab::FIssue**    c_issue_elems;       // array of pointers
+    u32                 c_issue_n;           // array of pointers
+    u32                 c_issue_max;         // capacity of allocated array
+    gitlab::FMr**       c_mr_elems;          // array of pointers
+    u32                 c_mr_n;              // array of pointers
+    u32                 c_mr_max;            // capacity of allocated array
+private:
+    friend gitlab::FProject&    project_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FProject*    project_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 project_RemoveAll() __attribute__((nothrow));
+    friend void                 project_RemoveLast() __attribute__((nothrow));
+    FProject();
+    ~FProject();
+    FProject(const FProject&){ /*disallow copy constructor */}
+    void operator =(const FProject&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 project_CopyOut(gitlab::FProject &row, dev::GitlabProject &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 project_CopyIn(gitlab::FProject &row, dev::GitlabProject &in) __attribute__((nothrow));
+
+// Return true if index is empty
+bool                 c_issue_EmptyQ(gitlab::FProject& project) __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FIssue*      c_issue_Find(gitlab::FProject& project, u32 t) __attribute__((__warn_unused_result__, nothrow));
+// Return array of pointers
+algo::aryptr<gitlab::FIssue*> c_issue_Getary(gitlab::FProject& project) __attribute__((nothrow));
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void                 c_issue_Insert(gitlab::FProject& project, gitlab::FIssue& row) __attribute__((nothrow));
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool                 c_issue_InsertMaybe(gitlab::FProject& project, gitlab::FIssue& row) __attribute__((nothrow));
+// Return number of items in the pointer array
+i32                  c_issue_N(const gitlab::FProject& project) __attribute__((__warn_unused_result__, nothrow, pure));
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void                 c_issue_Remove(gitlab::FProject& project, gitlab::FIssue& row) __attribute__((nothrow));
+// Empty the index. (The rows are not deleted)
+void                 c_issue_RemoveAll(gitlab::FProject& project) __attribute__((nothrow));
+// Reserve space in index for N more elements;
+void                 c_issue_Reserve(gitlab::FProject& project, u32 n) __attribute__((nothrow));
+
+// Return true if index is empty
+bool                 c_mr_EmptyQ(gitlab::FProject& project) __attribute__((nothrow));
+// Look up row by row id. Return NULL if out of range
+gitlab::FMr*         c_mr_Find(gitlab::FProject& project, u32 t) __attribute__((__warn_unused_result__, nothrow));
+// Return array of pointers
+algo::aryptr<gitlab::FMr*> c_mr_Getary(gitlab::FProject& project) __attribute__((nothrow));
+// Insert pointer to row into array. Row must not already be in array.
+// If pointer is already in the array, it may be inserted twice.
+void                 c_mr_Insert(gitlab::FProject& project, gitlab::FMr& row) __attribute__((nothrow));
+// Insert pointer to row in array.
+// If row is already in the array, do nothing.
+// Return value: whether element was inserted into array.
+bool                 c_mr_InsertMaybe(gitlab::FProject& project, gitlab::FMr& row) __attribute__((nothrow));
+// Return number of items in the pointer array
+i32                  c_mr_N(const gitlab::FProject& project) __attribute__((__warn_unused_result__, nothrow, pure));
+// Find element using linear scan. If element is in array, remove, otherwise do nothing
+void                 c_mr_Remove(gitlab::FProject& project, gitlab::FMr& row) __attribute__((nothrow));
+// Empty the index. (The rows are not deleted)
+void                 c_mr_RemoveAll(gitlab::FProject& project) __attribute__((nothrow));
+// Reserve space in index for N more elements;
+void                 c_mr_Reserve(gitlab::FProject& project, u32 n) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 FProject_Init(gitlab::FProject& project);
+void                 project_c_issue_curs_Reset(project_c_issue_curs &curs, gitlab::FProject &parent);
+// cursor points to valid item
+bool                 project_c_issue_curs_ValidQ(project_c_issue_curs &curs);
+// proceed to next item
+void                 project_c_issue_curs_Next(project_c_issue_curs &curs);
+// item access
+gitlab::FIssue&      project_c_issue_curs_Access(project_c_issue_curs &curs);
+void                 project_c_mr_curs_Reset(project_c_mr_curs &curs, gitlab::FProject &parent);
+// cursor points to valid item
+bool                 project_c_mr_curs_ValidQ(project_c_mr_curs &curs);
+// proceed to next item
+void                 project_c_mr_curs_Next(project_c_mr_curs &curs);
+// item access
+gitlab::FMr&         project_c_mr_curs_Access(project_c_mr_curs &curs);
+void                 FProject_Uninit(gitlab::FProject& project) __attribute__((nothrow));
+
+// --- gitlab.FUser
+// create: gitlab.FDb.user (Lary)
+// global access: ind_user (Thash)
+struct FUser { // gitlab.FUser
+    gitlab::FUser*     ind_user_next;   // hash next
+    algo::Smallstr50   user;            //
+    u32                id;              //   0
+    algo::cstring      name;            //
+private:
+    friend gitlab::FUser&       user_Alloc() __attribute__((__warn_unused_result__, nothrow));
+    friend gitlab::FUser*       user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
+    friend void                 user_RemoveAll() __attribute__((nothrow));
+    friend void                 user_RemoveLast() __attribute__((nothrow));
+    FUser();
+    ~FUser();
+    FUser(const FUser&){ /*disallow copy constructor */}
+    void operator =(const FUser&){ /*disallow direct assignment */}
+};
+
+// Copy fields out of row
+void                 user_CopyOut(gitlab::FUser &row, gitlab::User &out) __attribute__((nothrow));
+// Copy fields in to row
+void                 user_CopyIn(gitlab::FUser &row, gitlab::User &in) __attribute__((nothrow));
+
+// Set all fields to initial values.
+void                 FUser_Init(gitlab::FUser& user);
+void                 FUser_Uninit(gitlab::FUser& user) __attribute__((nothrow));
+
+// --- gitlab.FieldId
+#pragma pack(push,1)
+struct FieldId { // gitlab.FieldId: Field read helper
+    i32   value;   //   -1
+    inline operator gitlab_FieldIdEnum() const;
+    explicit FieldId(i32                            in_value);
+    FieldId(gitlab_FieldIdEnum arg);
+    FieldId();
+};
+#pragma pack(pop)
+
+// Get value of field as enum type
+gitlab_FieldIdEnum   value_GetEnum(const gitlab::FieldId& parent) __attribute__((nothrow));
+// Set value of field from enum type.
+void                 value_SetEnum(gitlab::FieldId& parent, gitlab_FieldIdEnum rhs) __attribute__((nothrow));
+// Convert numeric value of field to one of predefined string constants.
+// If string is found, return a static C string. Otherwise, return NULL.
+const char*          value_ToCstr(const gitlab::FieldId& parent) __attribute__((nothrow));
+// Convert value to a string. First, attempt conversion to a known string.
+// If no string matches, print value as a numeric value.
+void                 value_Print(const gitlab::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
+// Convert string to field.
+// If the string is invalid, do not modify field and return false.
+// In case of success, return true
+bool                 value_SetStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
+// Convert string to field.
+// If the string is invalid, set numeric value to DFLT
+void                 value_SetStrptr(gitlab::FieldId& parent, algo::strptr rhs, gitlab_FieldIdEnum dflt) __attribute__((nothrow));
+// Convert string to field. Return success value
+bool                 value_ReadStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
+
+// Read fields of gitlab::FieldId from an ascii string.
+// The format of the string is the format of the gitlab::FieldId's only field
+bool                 FieldId_ReadStrptrMaybe(gitlab::FieldId &parent, algo::strptr in_str);
+// Set all fields to initial values.
+void                 FieldId_Init(gitlab::FieldId& parent);
+// print string representation of gitlab::FieldId to string LHS, no header -- cprint:gitlab.FieldId.String
+void                 FieldId_Print(gitlab::FieldId & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.Issue
+// access: gitlab.FIssue.base (Base)
+struct Issue { // gitlab.Issue: Gitlab project issue
+    algo::Smallstr50   issue;      // Identifier. must be in form project.iid
+    algo::Smallstr50   assignee;   // User the issue is assigned to
+    algo::cstring      title;      // Issue title
+    Issue();
+};
+
+algo::Smallstr50     project_Get(gitlab::Issue& parent) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  iid_Get(gitlab::Issue& parent) __attribute__((__warn_unused_result__, nothrow));
+
+tempstr              Issue_Concat_project_iid( const algo::strptr& project ,u32 iid );
+// print string representation of gitlab::Issue to string LHS, no header -- cprint:gitlab.Issue.String
+void                 Issue_Print(gitlab::Issue & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.IssueDescription
+// access: gitlab.FIssueDescription.base (Base)
+struct IssueDescription { // gitlab.IssueDescription: Issue description
+    algo::Smallstr50   issue;         //
+    algo::cstring      description;   //
+    IssueDescription();
+};
+
+// print string representation of gitlab::IssueDescription to string LHS, no header -- cprint:gitlab.IssueDescription.String
+void                 IssueDescription_Print(gitlab::IssueDescription & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.IssueNote
+// access: gitlab.FIssueNote.base (Base)
+struct IssueNote { // gitlab.IssueNote: Issue note
+    algo::Smallstr50   issue_note;   // Identifier. must be in form issue.id
+    algo::cstring      body;         // Body of issue note
+    IssueNote();
+};
+
+algo::Smallstr50     issue_Get(gitlab::IssueNote& parent) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  id_Get(gitlab::IssueNote& parent) __attribute__((__warn_unused_result__, nothrow));
+
+tempstr              IssueNote_Concat_issue_id( const algo::strptr& issue ,u32 id );
+// print string representation of gitlab::IssueNote to string LHS, no header -- cprint:gitlab.IssueNote.String
+void                 IssueNote_Print(gitlab::IssueNote & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.Mr
+// access: gitlab.FMr.base (Base)
+struct Mr { // gitlab.Mr: Gitlab project mr
+    algo::Smallstr50   mr;                // Identifier. must be in form project.iid
+    algo::cstring      title;             // Mr title
+    algo::cstring      source_branch;     // Source branch
+    algo::Smallstr20   pipeline_status;   // Pipeline status
+    Mr();
+};
+
+algo::Smallstr50     project_Get(gitlab::Mr& parent) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  iid_Get(gitlab::Mr& parent) __attribute__((__warn_unused_result__, nothrow));
+
+tempstr              Mr_Concat_project_iid( const algo::strptr& project ,u32 iid );
+// print string representation of gitlab::Mr to string LHS, no header -- cprint:gitlab.Mr.String
+void                 Mr_Print(gitlab::Mr & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.MrDescription
+// access: gitlab.FMrDescription.base (Base)
+struct MrDescription { // gitlab.MrDescription: Mr description
+    algo::Smallstr50   mr;            //
+    algo::cstring      description;   //
+    MrDescription();
+};
+
+// print string representation of gitlab::MrDescription to string LHS, no header -- cprint:gitlab.MrDescription.String
+void                 MrDescription_Print(gitlab::MrDescription & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.MrNote
+// access: gitlab.FMrNote.base (Base)
+struct MrNote { // gitlab.MrNote: Mr note
+    algo::Smallstr50   mr_note;   // Identifier. must be in form mr.id
+    algo::cstring      body;      // Body of mr note
+    MrNote();
+};
+
+algo::Smallstr50     mr_Get(gitlab::MrNote& parent) __attribute__((__warn_unused_result__, nothrow));
+
+u32                  id_Get(gitlab::MrNote& parent) __attribute__((__warn_unused_result__, nothrow));
+
+tempstr              MrNote_Concat_mr_id( const algo::strptr& mr ,u32 id );
+// print string representation of gitlab::MrNote to string LHS, no header -- cprint:gitlab.MrNote.String
+void                 MrNote_Print(gitlab::MrNote & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.TableId
+struct TableId { // gitlab.TableId: Index of table in this namespace
+    i32   value;   //   -1  index of table
+    inline operator gitlab_TableIdEnum() const;
+    explicit TableId(i32                            in_value);
+    TableId(gitlab_TableIdEnum arg);
+    TableId();
+};
+
+// Get value of field as enum type
+gitlab_TableIdEnum   value_GetEnum(const gitlab::TableId& parent) __attribute__((nothrow));
+// Set value of field from enum type.
+void                 value_SetEnum(gitlab::TableId& parent, gitlab_TableIdEnum rhs) __attribute__((nothrow));
+// Convert numeric value of field to one of predefined string constants.
+// If string is found, return a static C string. Otherwise, return NULL.
+const char*          value_ToCstr(const gitlab::TableId& parent) __attribute__((nothrow));
+// Convert value to a string. First, attempt conversion to a known string.
+// If no string matches, print value as a numeric value.
+void                 value_Print(const gitlab::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
+// Convert string to field.
+// If the string is invalid, do not modify field and return false.
+// In case of success, return true
+bool                 value_SetStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
+// Convert string to field.
+// If the string is invalid, set numeric value to DFLT
+void                 value_SetStrptr(gitlab::TableId& parent, algo::strptr rhs, gitlab_TableIdEnum dflt) __attribute__((nothrow));
+// Convert string to field. Return success value
+bool                 value_ReadStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
+
+// Read fields of gitlab::TableId from an ascii string.
+// The format of the string is the format of the gitlab::TableId's only field
+bool                 TableId_ReadStrptrMaybe(gitlab::TableId &parent, algo::strptr in_str);
+// Set all fields to initial values.
+void                 TableId_Init(gitlab::TableId& parent);
+// print string representation of gitlab::TableId to string LHS, no header -- cprint:gitlab.TableId.String
+void                 TableId_Print(gitlab::TableId & row, algo::cstring &str) __attribute__((nothrow));
+
+// --- gitlab.User
+// access: gitlab.FUser.base (Base)
+struct User { // gitlab.User
+    algo::Smallstr50   user;   //
+    u32                id;     //   0
+    algo::cstring      name;   //
+    User();
+};
+
+// Set all fields to initial values.
+void                 User_Init(gitlab::User& parent);
+
+struct _db_project_curs {// cursor
+    typedef gitlab::FProject ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_project_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_issue_curs {// cursor
+    typedef gitlab::FIssue ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_issue_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_issue_note_curs {// cursor
+    typedef gitlab::FIssueNote ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_issue_note_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_issue_description_curs {// cursor
+    typedef gitlab::FIssueDescription ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_issue_description_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_mr_curs {// cursor
+    typedef gitlab::FMr ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_mr_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_mr_note_curs {// cursor
+    typedef gitlab::FMrNote ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_mr_note_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_mr_description_curs {// cursor
+    typedef gitlab::FMrDescription ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_mr_description_curs(){ parent=NULL; index=0; }
+};
+
+
+struct _db_user_curs {// cursor
+    typedef gitlab::FUser ChildType;
+    gitlab::FDb *parent;
+    i64 index;
+    _db_user_curs(){ parent=NULL; index=0; }
+};
+
+
+struct FHttp_request_header_curs {// cursor
+    typedef algo::cstring ChildType;
+    algo::cstring* elems;
+    int n_elems;
+    int index;
+    FHttp_request_header_curs() { elems=NULL; n_elems=0; index=0; }
+};
+
+
+struct FHttp_response_header_curs {// cursor
+    typedef algo::cstring ChildType;
+    algo::cstring* elems;
+    int n_elems;
+    int index;
+    FHttp_response_header_curs() { elems=NULL; n_elems=0; index=0; }
+};
+
+
+struct issue_c_issue_note_curs {// cursor
+    typedef gitlab::FIssueNote ChildType;
+    gitlab::FIssueNote** elems;
+    u32 n_elems;
+    u32 index;
+    issue_c_issue_note_curs() { elems=NULL; n_elems=0; index=0; }
+};
+
+
+struct mr_c_mr_note_curs {// cursor
+    typedef gitlab::FMrNote ChildType;
+    gitlab::FMrNote** elems;
+    u32 n_elems;
+    u32 index;
+    mr_c_mr_note_curs() { elems=NULL; n_elems=0; index=0; }
+};
+
+
+struct project_c_issue_curs {// cursor
+    typedef gitlab::FIssue ChildType;
+    gitlab::FIssue** elems;
+    u32 n_elems;
+    u32 index;
+    project_c_issue_curs() { elems=NULL; n_elems=0; index=0; }
+};
+
+
+struct project_c_mr_curs {// cursor
+    typedef gitlab::FMr ChildType;
+    gitlab::FMr** elems;
+    u32 n_elems;
+    u32 index;
+    project_c_mr_curs() { elems=NULL; n_elems=0; index=0; }
+};
+
+int                  main(int argc, char **argv);
+} // end namespace gitlab
+namespace algo {
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::trace &row);// cfmt:gitlab.trace.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FHttp &row);// cfmt:gitlab.FHttp.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FIssue &row);// cfmt:gitlab.FIssue.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FMr &row);// cfmt:gitlab.FMr.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FieldId &row);// cfmt:gitlab.FieldId.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::Issue &row);// cfmt:gitlab.Issue.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::IssueDescription &row);// cfmt:gitlab.IssueDescription.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::IssueNote &row);// cfmt:gitlab.IssueNote.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::Mr &row);// cfmt:gitlab.Mr.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::MrDescription &row);// cfmt:gitlab.MrDescription.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::MrNote &row);// cfmt:gitlab.MrNote.String
+inline algo::cstring &operator <<(algo::cstring &str, const gitlab::TableId &row);// cfmt:gitlab.TableId.String
+}
diff --git a/include/gen/gitlab_gen.inl.h b/include/gen/gitlab_gen.inl.h
new file mode 100644
index 000000000..8df0b728f
--- /dev/null
+++ b/include/gen/gitlab_gen.inl.h
@@ -0,0 +1,1396 @@
+//
+// include/gen/gitlab_gen.inl.h
+// Generated by AMC
+//
+// (C) AlgoEngineering LLC 2008-2013
+// (C) NYSE | Intercontinental Exchange 2013-2016
+//
+
+
+#pragma once
+#include "include/gen/command_gen.inl.h"
+#include "include/gen/algo_gen.inl.h"
+#include "include/gen/lib_json_gen.inl.h"
+#include "include/gen/dev_gen.inl.h"
+//#pragma endinclude
+inline gitlab::trace::trace() {
+}
+
+
+// --- gitlab.FDb.project.EmptyQ
+// Return true if index is empty
+inline bool gitlab::project_EmptyQ() {
+    return _db.project_n == 0;
+}
+
+// --- gitlab.FDb.project.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FProject* gitlab::project_Find(u64 t) {
+    gitlab::FProject *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.project_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.project_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.project.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FProject* gitlab::project_Last() {
+    return project_Find(u64(_db.project_n-1));
+}
+
+// --- gitlab.FDb.project.N
+// Return number of items in the pool
+inline i32 gitlab::project_N() {
+    return _db.project_n;
+}
+
+// --- gitlab.FDb.project.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FProject& gitlab::project_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.project_lary[bsr][index];
+}
+
+// --- gitlab.FDb.ind_project.EmptyQ
+// Return true if hash is empty
+inline bool gitlab::ind_project_EmptyQ() {
+    return _db.ind_project_n == 0;
+}
+
+// --- gitlab.FDb.ind_project.N
+// Return number of items in the hash
+inline i32 gitlab::ind_project_N() {
+    return _db.ind_project_n;
+}
+
+// --- gitlab.FDb.ind_issue.EmptyQ
+// Return true if hash is empty
+inline bool gitlab::ind_issue_EmptyQ() {
+    return _db.ind_issue_n == 0;
+}
+
+// --- gitlab.FDb.ind_issue.N
+// Return number of items in the hash
+inline i32 gitlab::ind_issue_N() {
+    return _db.ind_issue_n;
+}
+
+// --- gitlab.FDb.issue.EmptyQ
+// Return true if index is empty
+inline bool gitlab::issue_EmptyQ() {
+    return _db.issue_n == 0;
+}
+
+// --- gitlab.FDb.issue.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FIssue* gitlab::issue_Find(u64 t) {
+    gitlab::FIssue *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.issue_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.issue_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.issue.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FIssue* gitlab::issue_Last() {
+    return issue_Find(u64(_db.issue_n-1));
+}
+
+// --- gitlab.FDb.issue.N
+// Return number of items in the pool
+inline i32 gitlab::issue_N() {
+    return _db.issue_n;
+}
+
+// --- gitlab.FDb.issue.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FIssue& gitlab::issue_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.issue_lary[bsr][index];
+}
+
+// --- gitlab.FDb.issue_note.EmptyQ
+// Return true if index is empty
+inline bool gitlab::issue_note_EmptyQ() {
+    return _db.issue_note_n == 0;
+}
+
+// --- gitlab.FDb.issue_note.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FIssueNote* gitlab::issue_note_Find(u64 t) {
+    gitlab::FIssueNote *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.issue_note_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.issue_note_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.issue_note.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FIssueNote* gitlab::issue_note_Last() {
+    return issue_note_Find(u64(_db.issue_note_n-1));
+}
+
+// --- gitlab.FDb.issue_note.N
+// Return number of items in the pool
+inline i32 gitlab::issue_note_N() {
+    return _db.issue_note_n;
+}
+
+// --- gitlab.FDb.issue_note.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FIssueNote& gitlab::issue_note_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.issue_note_lary[bsr][index];
+}
+
+// --- gitlab.FDb.ind_issue_note.EmptyQ
+// Return true if hash is empty
+inline bool gitlab::ind_issue_note_EmptyQ() {
+    return _db.ind_issue_note_n == 0;
+}
+
+// --- gitlab.FDb.ind_issue_note.N
+// Return number of items in the hash
+inline i32 gitlab::ind_issue_note_N() {
+    return _db.ind_issue_note_n;
+}
+
+// --- gitlab.FDb.issue_description.EmptyQ
+// Return true if index is empty
+inline bool gitlab::issue_description_EmptyQ() {
+    return _db.issue_description_n == 0;
+}
+
+// --- gitlab.FDb.issue_description.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FIssueDescription* gitlab::issue_description_Find(u64 t) {
+    gitlab::FIssueDescription *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.issue_description_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.issue_description_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.issue_description.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FIssueDescription* gitlab::issue_description_Last() {
+    return issue_description_Find(u64(_db.issue_description_n-1));
+}
+
+// --- gitlab.FDb.issue_description.N
+// Return number of items in the pool
+inline i32 gitlab::issue_description_N() {
+    return _db.issue_description_n;
+}
+
+// --- gitlab.FDb.issue_description.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FIssueDescription& gitlab::issue_description_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.issue_description_lary[bsr][index];
+}
+
+// --- gitlab.FDb.ind_mr.EmptyQ
+// Return true if hash is empty
+inline bool gitlab::ind_mr_EmptyQ() {
+    return _db.ind_mr_n == 0;
+}
+
+// --- gitlab.FDb.ind_mr.N
+// Return number of items in the hash
+inline i32 gitlab::ind_mr_N() {
+    return _db.ind_mr_n;
+}
+
+// --- gitlab.FDb.mr.EmptyQ
+// Return true if index is empty
+inline bool gitlab::mr_EmptyQ() {
+    return _db.mr_n == 0;
+}
+
+// --- gitlab.FDb.mr.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FMr* gitlab::mr_Find(u64 t) {
+    gitlab::FMr *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.mr_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.mr_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.mr.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FMr* gitlab::mr_Last() {
+    return mr_Find(u64(_db.mr_n-1));
+}
+
+// --- gitlab.FDb.mr.N
+// Return number of items in the pool
+inline i32 gitlab::mr_N() {
+    return _db.mr_n;
+}
+
+// --- gitlab.FDb.mr.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FMr& gitlab::mr_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.mr_lary[bsr][index];
+}
+
+// --- gitlab.FDb.mr_note.EmptyQ
+// Return true if index is empty
+inline bool gitlab::mr_note_EmptyQ() {
+    return _db.mr_note_n == 0;
+}
+
+// --- gitlab.FDb.mr_note.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FMrNote* gitlab::mr_note_Find(u64 t) {
+    gitlab::FMrNote *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.mr_note_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.mr_note_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.mr_note.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FMrNote* gitlab::mr_note_Last() {
+    return mr_note_Find(u64(_db.mr_note_n-1));
+}
+
+// --- gitlab.FDb.mr_note.N
+// Return number of items in the pool
+inline i32 gitlab::mr_note_N() {
+    return _db.mr_note_n;
+}
+
+// --- gitlab.FDb.mr_note.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FMrNote& gitlab::mr_note_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.mr_note_lary[bsr][index];
+}
+
+// --- gitlab.FDb.ind_mr_note.EmptyQ
+// Return true if hash is empty
+inline bool gitlab::ind_mr_note_EmptyQ() {
+    return _db.ind_mr_note_n == 0;
+}
+
+// --- gitlab.FDb.ind_mr_note.N
+// Return number of items in the hash
+inline i32 gitlab::ind_mr_note_N() {
+    return _db.ind_mr_note_n;
+}
+
+// --- gitlab.FDb.mr_description.EmptyQ
+// Return true if index is empty
+inline bool gitlab::mr_description_EmptyQ() {
+    return _db.mr_description_n == 0;
+}
+
+// --- gitlab.FDb.mr_description.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FMrDescription* gitlab::mr_description_Find(u64 t) {
+    gitlab::FMrDescription *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.mr_description_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.mr_description_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.mr_description.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FMrDescription* gitlab::mr_description_Last() {
+    return mr_description_Find(u64(_db.mr_description_n-1));
+}
+
+// --- gitlab.FDb.mr_description.N
+// Return number of items in the pool
+inline i32 gitlab::mr_description_N() {
+    return _db.mr_description_n;
+}
+
+// --- gitlab.FDb.mr_description.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FMrDescription& gitlab::mr_description_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.mr_description_lary[bsr][index];
+}
+
+// --- gitlab.FDb.user.EmptyQ
+// Return true if index is empty
+inline bool gitlab::user_EmptyQ() {
+    return _db.user_n == 0;
+}
+
+// --- gitlab.FDb.user.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FUser* gitlab::user_Find(u64 t) {
+    gitlab::FUser *retval = NULL;
+    if (LIKELY(u64(t) < u64(_db.user_n))) {
+        u64 x = t + 1;
+        u64 bsr   = algo::u64_BitScanReverse(x);
+        u64 base  = u64(1)<<bsr;
+        u64 index = x-base;
+        retval = &_db.user_lary[bsr][index];
+    }
+    return retval;
+}
+
+// --- gitlab.FDb.user.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline gitlab::FUser* gitlab::user_Last() {
+    return user_Find(u64(_db.user_n-1));
+}
+
+// --- gitlab.FDb.user.N
+// Return number of items in the pool
+inline i32 gitlab::user_N() {
+    return _db.user_n;
+}
+
+// --- gitlab.FDb.user.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline gitlab::FUser& gitlab::user_qFind(u64 t) {
+    u64 x = t + 1;
+    u64 bsr   = algo::u64_BitScanReverse(x);
+    u64 base  = u64(1)<<bsr;
+    u64 index = x-base;
+    return _db.user_lary[bsr][index];
+}
+
+// --- gitlab.FDb.ind_user.EmptyQ
+// Return true if hash is empty
+inline bool gitlab::ind_user_EmptyQ() {
+    return _db.ind_user_n == 0;
+}
+
+// --- gitlab.FDb.ind_user.N
+// Return number of items in the hash
+inline i32 gitlab::ind_user_N() {
+    return _db.ind_user_n;
+}
+
+// --- gitlab.FDb.project_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_project_curs_Reset(_db_project_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.project_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_project_curs_ValidQ(_db_project_curs &curs) {
+    return curs.index < _db.project_n;
+}
+
+// --- gitlab.FDb.project_curs.Next
+// proceed to next item
+inline void gitlab::_db_project_curs_Next(_db_project_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.project_curs.Access
+// item access
+inline gitlab::FProject& gitlab::_db_project_curs_Access(_db_project_curs &curs) {
+    return project_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.issue_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_issue_curs_Reset(_db_issue_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.issue_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_issue_curs_ValidQ(_db_issue_curs &curs) {
+    return curs.index < _db.issue_n;
+}
+
+// --- gitlab.FDb.issue_curs.Next
+// proceed to next item
+inline void gitlab::_db_issue_curs_Next(_db_issue_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.issue_curs.Access
+// item access
+inline gitlab::FIssue& gitlab::_db_issue_curs_Access(_db_issue_curs &curs) {
+    return issue_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.issue_note_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_issue_note_curs_Reset(_db_issue_note_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.issue_note_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_issue_note_curs_ValidQ(_db_issue_note_curs &curs) {
+    return curs.index < _db.issue_note_n;
+}
+
+// --- gitlab.FDb.issue_note_curs.Next
+// proceed to next item
+inline void gitlab::_db_issue_note_curs_Next(_db_issue_note_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.issue_note_curs.Access
+// item access
+inline gitlab::FIssueNote& gitlab::_db_issue_note_curs_Access(_db_issue_note_curs &curs) {
+    return issue_note_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.issue_description_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_issue_description_curs_Reset(_db_issue_description_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.issue_description_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_issue_description_curs_ValidQ(_db_issue_description_curs &curs) {
+    return curs.index < _db.issue_description_n;
+}
+
+// --- gitlab.FDb.issue_description_curs.Next
+// proceed to next item
+inline void gitlab::_db_issue_description_curs_Next(_db_issue_description_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.issue_description_curs.Access
+// item access
+inline gitlab::FIssueDescription& gitlab::_db_issue_description_curs_Access(_db_issue_description_curs &curs) {
+    return issue_description_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.mr_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_mr_curs_Reset(_db_mr_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.mr_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_mr_curs_ValidQ(_db_mr_curs &curs) {
+    return curs.index < _db.mr_n;
+}
+
+// --- gitlab.FDb.mr_curs.Next
+// proceed to next item
+inline void gitlab::_db_mr_curs_Next(_db_mr_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.mr_curs.Access
+// item access
+inline gitlab::FMr& gitlab::_db_mr_curs_Access(_db_mr_curs &curs) {
+    return mr_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.mr_note_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_mr_note_curs_Reset(_db_mr_note_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.mr_note_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_mr_note_curs_ValidQ(_db_mr_note_curs &curs) {
+    return curs.index < _db.mr_note_n;
+}
+
+// --- gitlab.FDb.mr_note_curs.Next
+// proceed to next item
+inline void gitlab::_db_mr_note_curs_Next(_db_mr_note_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.mr_note_curs.Access
+// item access
+inline gitlab::FMrNote& gitlab::_db_mr_note_curs_Access(_db_mr_note_curs &curs) {
+    return mr_note_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.mr_description_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_mr_description_curs_Reset(_db_mr_description_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.mr_description_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_mr_description_curs_ValidQ(_db_mr_description_curs &curs) {
+    return curs.index < _db.mr_description_n;
+}
+
+// --- gitlab.FDb.mr_description_curs.Next
+// proceed to next item
+inline void gitlab::_db_mr_description_curs_Next(_db_mr_description_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.mr_description_curs.Access
+// item access
+inline gitlab::FMrDescription& gitlab::_db_mr_description_curs_Access(_db_mr_description_curs &curs) {
+    return mr_description_qFind(u64(curs.index));
+}
+
+// --- gitlab.FDb.user_curs.Reset
+// cursor points to valid item
+inline void gitlab::_db_user_curs_Reset(_db_user_curs &curs, gitlab::FDb &parent) {
+    curs.parent = &parent;
+    curs.index = 0;
+}
+
+// --- gitlab.FDb.user_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::_db_user_curs_ValidQ(_db_user_curs &curs) {
+    return curs.index < _db.user_n;
+}
+
+// --- gitlab.FDb.user_curs.Next
+// proceed to next item
+inline void gitlab::_db_user_curs_Next(_db_user_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FDb.user_curs.Access
+// item access
+inline gitlab::FUser& gitlab::_db_user_curs_Access(_db_user_curs &curs) {
+    return user_qFind(u64(curs.index));
+}
+inline gitlab::FHttp::FHttp() {
+    gitlab::FHttp_Init(*this);
+}
+
+inline gitlab::FHttp::~FHttp() {
+    gitlab::FHttp_Uninit(*this);
+}
+
+
+// --- gitlab.FHttp.request_header.EmptyQ
+// Return true if index is empty
+inline bool gitlab::request_header_EmptyQ(gitlab::FHttp& parent) {
+    return parent.request_header_n == 0;
+}
+
+// --- gitlab.FHttp.request_header.Find
+// Look up row by row id. Return NULL if out of range
+inline algo::cstring* gitlab::request_header_Find(gitlab::FHttp& parent, u64 t) {
+    u64 idx = t;
+    u64 lim = parent.request_header_n;
+    if (idx >= lim) return NULL;
+    return parent.request_header_elems + idx;
+}
+
+// --- gitlab.FHttp.request_header.Getary
+// Return array pointer by value
+inline algo::aryptr<algo::cstring> gitlab::request_header_Getary(gitlab::FHttp& parent) {
+    return algo::aryptr<algo::cstring>(parent.request_header_elems, parent.request_header_n);
+}
+
+// --- gitlab.FHttp.request_header.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline algo::cstring* gitlab::request_header_Last(gitlab::FHttp& parent) {
+    return request_header_Find(parent, u64(parent.request_header_n-1));
+}
+
+// --- gitlab.FHttp.request_header.Max
+// Return max. number of items in the array
+inline i32 gitlab::request_header_Max(gitlab::FHttp& parent) {
+    (void)parent;
+    return parent.request_header_max;
+}
+
+// --- gitlab.FHttp.request_header.N
+// Return number of items in the array
+inline i32 gitlab::request_header_N(const gitlab::FHttp& parent) {
+    return parent.request_header_n;
+}
+
+// --- gitlab.FHttp.request_header.Reserve
+// Make sure N *more* elements will fit in array. Process dies if out of memory
+inline void gitlab::request_header_Reserve(gitlab::FHttp& parent, int n) {
+    u32 new_n = parent.request_header_n + n;
+    if (UNLIKELY(new_n > parent.request_header_max)) {
+        request_header_AbsReserve(parent, new_n);
+    }
+}
+
+// --- gitlab.FHttp.request_header.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline algo::cstring& gitlab::request_header_qFind(gitlab::FHttp& parent, u64 t) {
+    return parent.request_header_elems[t];
+}
+
+// --- gitlab.FHttp.request_header.qLast
+// Return reference to last element of array. No bounds checking
+inline algo::cstring& gitlab::request_header_qLast(gitlab::FHttp& parent) {
+    return request_header_qFind(parent, u64(parent.request_header_n-1));
+}
+
+// --- gitlab.FHttp.request_header.rowid_Get
+// Return row id of specified element
+inline u64 gitlab::request_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) {
+    u64 id = &elem - parent.request_header_elems;
+    return u64(id);
+}
+
+// --- gitlab.FHttp.request_method.GetEnum
+// Get value of field as enum type
+inline gitlab_FHttp_request_method_Enum gitlab::request_method_GetEnum(const gitlab::FHttp& parent) {
+    return gitlab_FHttp_request_method_Enum(parent.request_method);
+}
+
+// --- gitlab.FHttp.request_method.SetEnum
+// Set value of field from enum type.
+inline void gitlab::request_method_SetEnum(gitlab::FHttp& parent, gitlab_FHttp_request_method_Enum rhs) {
+    parent.request_method = u32(rhs);
+}
+
+// --- gitlab.FHttp.response_header.EmptyQ
+// Return true if index is empty
+inline bool gitlab::response_header_EmptyQ(gitlab::FHttp& parent) {
+    return parent.response_header_n == 0;
+}
+
+// --- gitlab.FHttp.response_header.Find
+// Look up row by row id. Return NULL if out of range
+inline algo::cstring* gitlab::response_header_Find(gitlab::FHttp& parent, u64 t) {
+    u64 idx = t;
+    u64 lim = parent.response_header_n;
+    if (idx >= lim) return NULL;
+    return parent.response_header_elems + idx;
+}
+
+// --- gitlab.FHttp.response_header.Getary
+// Return array pointer by value
+inline algo::aryptr<algo::cstring> gitlab::response_header_Getary(gitlab::FHttp& parent) {
+    return algo::aryptr<algo::cstring>(parent.response_header_elems, parent.response_header_n);
+}
+
+// --- gitlab.FHttp.response_header.Last
+// Return pointer to last element of array, or NULL if array is empty
+inline algo::cstring* gitlab::response_header_Last(gitlab::FHttp& parent) {
+    return response_header_Find(parent, u64(parent.response_header_n-1));
+}
+
+// --- gitlab.FHttp.response_header.Max
+// Return max. number of items in the array
+inline i32 gitlab::response_header_Max(gitlab::FHttp& parent) {
+    (void)parent;
+    return parent.response_header_max;
+}
+
+// --- gitlab.FHttp.response_header.N
+// Return number of items in the array
+inline i32 gitlab::response_header_N(const gitlab::FHttp& parent) {
+    return parent.response_header_n;
+}
+
+// --- gitlab.FHttp.response_header.Reserve
+// Make sure N *more* elements will fit in array. Process dies if out of memory
+inline void gitlab::response_header_Reserve(gitlab::FHttp& parent, int n) {
+    u32 new_n = parent.response_header_n + n;
+    if (UNLIKELY(new_n > parent.response_header_max)) {
+        response_header_AbsReserve(parent, new_n);
+    }
+}
+
+// --- gitlab.FHttp.response_header.qFind
+// 'quick' Access row by row id. No bounds checking.
+inline algo::cstring& gitlab::response_header_qFind(gitlab::FHttp& parent, u64 t) {
+    return parent.response_header_elems[t];
+}
+
+// --- gitlab.FHttp.response_header.qLast
+// Return reference to last element of array. No bounds checking
+inline algo::cstring& gitlab::response_header_qLast(gitlab::FHttp& parent) {
+    return response_header_qFind(parent, u64(parent.response_header_n-1));
+}
+
+// --- gitlab.FHttp.response_header.rowid_Get
+// Return row id of specified element
+inline u64 gitlab::response_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) {
+    u64 id = &elem - parent.response_header_elems;
+    return u64(id);
+}
+
+// --- gitlab.FHttp.request_header_curs.Next
+// proceed to next item
+inline void gitlab::FHttp_request_header_curs_Next(FHttp_request_header_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FHttp.request_header_curs.Reset
+inline void gitlab::FHttp_request_header_curs_Reset(FHttp_request_header_curs &curs, gitlab::FHttp &parent) {
+    curs.elems = parent.request_header_elems;
+    curs.n_elems = parent.request_header_n;
+    curs.index = 0;
+}
+
+// --- gitlab.FHttp.request_header_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::FHttp_request_header_curs_ValidQ(FHttp_request_header_curs &curs) {
+    return curs.index < curs.n_elems;
+}
+
+// --- gitlab.FHttp.request_header_curs.Access
+// item access
+inline algo::cstring& gitlab::FHttp_request_header_curs_Access(FHttp_request_header_curs &curs) {
+    return curs.elems[curs.index];
+}
+
+// --- gitlab.FHttp.response_header_curs.Next
+// proceed to next item
+inline void gitlab::FHttp_response_header_curs_Next(FHttp_response_header_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FHttp.response_header_curs.Reset
+inline void gitlab::FHttp_response_header_curs_Reset(FHttp_response_header_curs &curs, gitlab::FHttp &parent) {
+    curs.elems = parent.response_header_elems;
+    curs.n_elems = parent.response_header_n;
+    curs.index = 0;
+}
+
+// --- gitlab.FHttp.response_header_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::FHttp_response_header_curs_ValidQ(FHttp_response_header_curs &curs) {
+    return curs.index < curs.n_elems;
+}
+
+// --- gitlab.FHttp.response_header_curs.Access
+// item access
+inline algo::cstring& gitlab::FHttp_response_header_curs_Access(FHttp_response_header_curs &curs) {
+    return curs.elems[curs.index];
+}
+inline gitlab::FIssue::FIssue() {
+    gitlab::FIssue_Init(*this);
+}
+
+inline gitlab::FIssue::~FIssue() {
+    gitlab::FIssue_Uninit(*this);
+}
+
+
+// --- gitlab.FIssue.c_issue_note.EmptyQ
+// Return true if index is empty
+inline bool gitlab::c_issue_note_EmptyQ(gitlab::FIssue& issue) {
+    return issue.c_issue_note_n == 0;
+}
+
+// --- gitlab.FIssue.c_issue_note.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FIssueNote* gitlab::c_issue_note_Find(gitlab::FIssue& issue, u32 t) {
+    gitlab::FIssueNote *retval = NULL;
+    u64 idx = t;
+    u64 lim = issue.c_issue_note_n;
+    if (idx < lim) {
+        retval = issue.c_issue_note_elems[idx];
+    }
+    return retval;
+}
+
+// --- gitlab.FIssue.c_issue_note.Getary
+// Return array of pointers
+inline algo::aryptr<gitlab::FIssueNote*> gitlab::c_issue_note_Getary(gitlab::FIssue& issue) {
+    return algo::aryptr<gitlab::FIssueNote*>(issue.c_issue_note_elems, issue.c_issue_note_n);
+}
+
+// --- gitlab.FIssue.c_issue_note.N
+// Return number of items in the pointer array
+inline i32 gitlab::c_issue_note_N(const gitlab::FIssue& issue) {
+    return issue.c_issue_note_n;
+}
+
+// --- gitlab.FIssue.c_issue_note.RemoveAll
+// Empty the index. (The rows are not deleted)
+inline void gitlab::c_issue_note_RemoveAll(gitlab::FIssue& issue) {
+    for (u32 i = 0; i < issue.c_issue_note_n; i++) {
+        // mark all elements as not-in-array
+        issue.c_issue_note_elems[i]->issue_c_issue_note_in_ary = false;
+    }
+    issue.c_issue_note_n = 0;
+}
+
+// --- gitlab.FIssue.c_issue_description.InsertMaybe
+// Insert row into pointer index. Return final membership status.
+inline bool gitlab::c_issue_description_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueDescription& row) {
+    gitlab::FIssueDescription* ptr = issue.c_issue_description;
+    bool retval = (ptr == NULL) | (ptr == &row);
+    if (retval) {
+        issue.c_issue_description = &row;
+    }
+    return retval;
+}
+
+// --- gitlab.FIssue.c_issue_description.Remove
+// Remove element from index. If element is not in index, do nothing.
+inline void gitlab::c_issue_description_Remove(gitlab::FIssue& issue, gitlab::FIssueDescription& row) {
+    gitlab::FIssueDescription *ptr = issue.c_issue_description;
+    if (LIKELY(ptr == &row)) {
+        issue.c_issue_description = NULL;
+    }
+}
+
+// --- gitlab.FIssue.c_issue_note_curs.Reset
+inline void gitlab::issue_c_issue_note_curs_Reset(issue_c_issue_note_curs &curs, gitlab::FIssue &parent) {
+    curs.elems = parent.c_issue_note_elems;
+    curs.n_elems = parent.c_issue_note_n;
+    curs.index = 0;
+}
+
+// --- gitlab.FIssue.c_issue_note_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::issue_c_issue_note_curs_ValidQ(issue_c_issue_note_curs &curs) {
+    return curs.index < curs.n_elems;
+}
+
+// --- gitlab.FIssue.c_issue_note_curs.Next
+// proceed to next item
+inline void gitlab::issue_c_issue_note_curs_Next(issue_c_issue_note_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FIssue.c_issue_note_curs.Access
+// item access
+inline gitlab::FIssueNote& gitlab::issue_c_issue_note_curs_Access(issue_c_issue_note_curs &curs) {
+    return *curs.elems[curs.index];
+}
+inline gitlab::FIssueDescription::FIssueDescription() {
+    gitlab::FIssueDescription_Init(*this);
+}
+
+inline gitlab::FIssueDescription::~FIssueDescription() {
+    gitlab::FIssueDescription_Uninit(*this);
+}
+
+
+// --- gitlab.FIssueDescription..Init
+// Set all fields to initial values.
+inline void gitlab::FIssueDescription_Init(gitlab::FIssueDescription& issue_description) {
+    issue_description.p_issue = NULL;
+}
+inline gitlab::FIssueNote::FIssueNote() {
+    gitlab::FIssueNote_Init(*this);
+}
+
+inline gitlab::FIssueNote::~FIssueNote() {
+    gitlab::FIssueNote_Uninit(*this);
+}
+
+
+// --- gitlab.FIssueNote..Init
+// Set all fields to initial values.
+inline void gitlab::FIssueNote_Init(gitlab::FIssueNote& issue_note) {
+    issue_note.p_issue = NULL;
+    issue_note.issue_c_issue_note_in_ary = bool(false);
+    issue_note.ind_issue_note_next = (gitlab::FIssueNote*)-1; // (gitlab.FDb.ind_issue_note) not-in-hash
+}
+inline gitlab::FMr::FMr() {
+    gitlab::FMr_Init(*this);
+}
+
+inline gitlab::FMr::~FMr() {
+    gitlab::FMr_Uninit(*this);
+}
+
+
+// --- gitlab.FMr.c_mr_note.EmptyQ
+// Return true if index is empty
+inline bool gitlab::c_mr_note_EmptyQ(gitlab::FMr& mr) {
+    return mr.c_mr_note_n == 0;
+}
+
+// --- gitlab.FMr.c_mr_note.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FMrNote* gitlab::c_mr_note_Find(gitlab::FMr& mr, u32 t) {
+    gitlab::FMrNote *retval = NULL;
+    u64 idx = t;
+    u64 lim = mr.c_mr_note_n;
+    if (idx < lim) {
+        retval = mr.c_mr_note_elems[idx];
+    }
+    return retval;
+}
+
+// --- gitlab.FMr.c_mr_note.Getary
+// Return array of pointers
+inline algo::aryptr<gitlab::FMrNote*> gitlab::c_mr_note_Getary(gitlab::FMr& mr) {
+    return algo::aryptr<gitlab::FMrNote*>(mr.c_mr_note_elems, mr.c_mr_note_n);
+}
+
+// --- gitlab.FMr.c_mr_note.N
+// Return number of items in the pointer array
+inline i32 gitlab::c_mr_note_N(const gitlab::FMr& mr) {
+    return mr.c_mr_note_n;
+}
+
+// --- gitlab.FMr.c_mr_note.RemoveAll
+// Empty the index. (The rows are not deleted)
+inline void gitlab::c_mr_note_RemoveAll(gitlab::FMr& mr) {
+    for (u32 i = 0; i < mr.c_mr_note_n; i++) {
+        // mark all elements as not-in-array
+        mr.c_mr_note_elems[i]->mr_c_mr_note_in_ary = false;
+    }
+    mr.c_mr_note_n = 0;
+}
+
+// --- gitlab.FMr.c_mr_description.InsertMaybe
+// Insert row into pointer index. Return final membership status.
+inline bool gitlab::c_mr_description_InsertMaybe(gitlab::FMr& mr, gitlab::FMrDescription& row) {
+    gitlab::FMrDescription* ptr = mr.c_mr_description;
+    bool retval = (ptr == NULL) | (ptr == &row);
+    if (retval) {
+        mr.c_mr_description = &row;
+    }
+    return retval;
+}
+
+// --- gitlab.FMr.c_mr_description.Remove
+// Remove element from index. If element is not in index, do nothing.
+inline void gitlab::c_mr_description_Remove(gitlab::FMr& mr, gitlab::FMrDescription& row) {
+    gitlab::FMrDescription *ptr = mr.c_mr_description;
+    if (LIKELY(ptr == &row)) {
+        mr.c_mr_description = NULL;
+    }
+}
+
+// --- gitlab.FMr.c_mr_note_curs.Reset
+inline void gitlab::mr_c_mr_note_curs_Reset(mr_c_mr_note_curs &curs, gitlab::FMr &parent) {
+    curs.elems = parent.c_mr_note_elems;
+    curs.n_elems = parent.c_mr_note_n;
+    curs.index = 0;
+}
+
+// --- gitlab.FMr.c_mr_note_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::mr_c_mr_note_curs_ValidQ(mr_c_mr_note_curs &curs) {
+    return curs.index < curs.n_elems;
+}
+
+// --- gitlab.FMr.c_mr_note_curs.Next
+// proceed to next item
+inline void gitlab::mr_c_mr_note_curs_Next(mr_c_mr_note_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FMr.c_mr_note_curs.Access
+// item access
+inline gitlab::FMrNote& gitlab::mr_c_mr_note_curs_Access(mr_c_mr_note_curs &curs) {
+    return *curs.elems[curs.index];
+}
+inline gitlab::FMrDescription::FMrDescription() {
+    gitlab::FMrDescription_Init(*this);
+}
+
+inline gitlab::FMrDescription::~FMrDescription() {
+    gitlab::FMrDescription_Uninit(*this);
+}
+
+
+// --- gitlab.FMrDescription..Init
+// Set all fields to initial values.
+inline void gitlab::FMrDescription_Init(gitlab::FMrDescription& mr_description) {
+    mr_description.p_mr = NULL;
+}
+inline gitlab::FMrNote::FMrNote() {
+    gitlab::FMrNote_Init(*this);
+}
+
+inline gitlab::FMrNote::~FMrNote() {
+    gitlab::FMrNote_Uninit(*this);
+}
+
+
+// --- gitlab.FMrNote..Init
+// Set all fields to initial values.
+inline void gitlab::FMrNote_Init(gitlab::FMrNote& mr_note) {
+    mr_note.p_mr = NULL;
+    mr_note.mr_c_mr_note_in_ary = bool(false);
+    mr_note.ind_mr_note_next = (gitlab::FMrNote*)-1; // (gitlab.FDb.ind_mr_note) not-in-hash
+}
+inline gitlab::FProject::FProject() {
+    gitlab::FProject_Init(*this);
+}
+
+inline gitlab::FProject::~FProject() {
+    gitlab::FProject_Uninit(*this);
+}
+
+
+// --- gitlab.FProject.c_issue.EmptyQ
+// Return true if index is empty
+inline bool gitlab::c_issue_EmptyQ(gitlab::FProject& project) {
+    return project.c_issue_n == 0;
+}
+
+// --- gitlab.FProject.c_issue.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FIssue* gitlab::c_issue_Find(gitlab::FProject& project, u32 t) {
+    gitlab::FIssue *retval = NULL;
+    u64 idx = t;
+    u64 lim = project.c_issue_n;
+    if (idx < lim) {
+        retval = project.c_issue_elems[idx];
+    }
+    return retval;
+}
+
+// --- gitlab.FProject.c_issue.Getary
+// Return array of pointers
+inline algo::aryptr<gitlab::FIssue*> gitlab::c_issue_Getary(gitlab::FProject& project) {
+    return algo::aryptr<gitlab::FIssue*>(project.c_issue_elems, project.c_issue_n);
+}
+
+// --- gitlab.FProject.c_issue.N
+// Return number of items in the pointer array
+inline i32 gitlab::c_issue_N(const gitlab::FProject& project) {
+    return project.c_issue_n;
+}
+
+// --- gitlab.FProject.c_issue.RemoveAll
+// Empty the index. (The rows are not deleted)
+inline void gitlab::c_issue_RemoveAll(gitlab::FProject& project) {
+    for (u32 i = 0; i < project.c_issue_n; i++) {
+        // mark all elements as not-in-array
+        project.c_issue_elems[i]->project_c_issue_in_ary = false;
+    }
+    project.c_issue_n = 0;
+}
+
+// --- gitlab.FProject.c_mr.EmptyQ
+// Return true if index is empty
+inline bool gitlab::c_mr_EmptyQ(gitlab::FProject& project) {
+    return project.c_mr_n == 0;
+}
+
+// --- gitlab.FProject.c_mr.Find
+// Look up row by row id. Return NULL if out of range
+inline gitlab::FMr* gitlab::c_mr_Find(gitlab::FProject& project, u32 t) {
+    gitlab::FMr *retval = NULL;
+    u64 idx = t;
+    u64 lim = project.c_mr_n;
+    if (idx < lim) {
+        retval = project.c_mr_elems[idx];
+    }
+    return retval;
+}
+
+// --- gitlab.FProject.c_mr.Getary
+// Return array of pointers
+inline algo::aryptr<gitlab::FMr*> gitlab::c_mr_Getary(gitlab::FProject& project) {
+    return algo::aryptr<gitlab::FMr*>(project.c_mr_elems, project.c_mr_n);
+}
+
+// --- gitlab.FProject.c_mr.N
+// Return number of items in the pointer array
+inline i32 gitlab::c_mr_N(const gitlab::FProject& project) {
+    return project.c_mr_n;
+}
+
+// --- gitlab.FProject.c_mr.RemoveAll
+// Empty the index. (The rows are not deleted)
+inline void gitlab::c_mr_RemoveAll(gitlab::FProject& project) {
+    for (u32 i = 0; i < project.c_mr_n; i++) {
+        // mark all elements as not-in-array
+        project.c_mr_elems[i]->project_c_mr_in_ary = false;
+    }
+    project.c_mr_n = 0;
+}
+
+// --- gitlab.FProject..Init
+// Set all fields to initial values.
+inline void gitlab::FProject_Init(gitlab::FProject& project) {
+    project.gitlab_project_id = u32(0);
+    project.c_issue_elems = NULL; // (gitlab.FProject.c_issue)
+    project.c_issue_n = 0; // (gitlab.FProject.c_issue)
+    project.c_issue_max = 0; // (gitlab.FProject.c_issue)
+    project.c_mr_elems = NULL; // (gitlab.FProject.c_mr)
+    project.c_mr_n = 0; // (gitlab.FProject.c_mr)
+    project.c_mr_max = 0; // (gitlab.FProject.c_mr)
+    project.ind_project_next = (gitlab::FProject*)-1; // (gitlab.FDb.ind_project) not-in-hash
+}
+
+// --- gitlab.FProject.c_issue_curs.Reset
+inline void gitlab::project_c_issue_curs_Reset(project_c_issue_curs &curs, gitlab::FProject &parent) {
+    curs.elems = parent.c_issue_elems;
+    curs.n_elems = parent.c_issue_n;
+    curs.index = 0;
+}
+
+// --- gitlab.FProject.c_issue_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::project_c_issue_curs_ValidQ(project_c_issue_curs &curs) {
+    return curs.index < curs.n_elems;
+}
+
+// --- gitlab.FProject.c_issue_curs.Next
+// proceed to next item
+inline void gitlab::project_c_issue_curs_Next(project_c_issue_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FProject.c_issue_curs.Access
+// item access
+inline gitlab::FIssue& gitlab::project_c_issue_curs_Access(project_c_issue_curs &curs) {
+    return *curs.elems[curs.index];
+}
+
+// --- gitlab.FProject.c_mr_curs.Reset
+inline void gitlab::project_c_mr_curs_Reset(project_c_mr_curs &curs, gitlab::FProject &parent) {
+    curs.elems = parent.c_mr_elems;
+    curs.n_elems = parent.c_mr_n;
+    curs.index = 0;
+}
+
+// --- gitlab.FProject.c_mr_curs.ValidQ
+// cursor points to valid item
+inline bool gitlab::project_c_mr_curs_ValidQ(project_c_mr_curs &curs) {
+    return curs.index < curs.n_elems;
+}
+
+// --- gitlab.FProject.c_mr_curs.Next
+// proceed to next item
+inline void gitlab::project_c_mr_curs_Next(project_c_mr_curs &curs) {
+    curs.index++;
+}
+
+// --- gitlab.FProject.c_mr_curs.Access
+// item access
+inline gitlab::FMr& gitlab::project_c_mr_curs_Access(project_c_mr_curs &curs) {
+    return *curs.elems[curs.index];
+}
+inline gitlab::FUser::FUser() {
+    gitlab::FUser_Init(*this);
+}
+
+inline gitlab::FUser::~FUser() {
+    gitlab::FUser_Uninit(*this);
+}
+
+
+// --- gitlab.FUser..Init
+// Set all fields to initial values.
+inline void gitlab::FUser_Init(gitlab::FUser& user) {
+    user.id = u32(0);
+    user.ind_user_next = (gitlab::FUser*)-1; // (gitlab.FDb.ind_user) not-in-hash
+}
+inline gitlab::FieldId::FieldId(i32                            in_value)
+    : value(in_value)
+{
+}
+inline gitlab::FieldId::FieldId(gitlab_FieldIdEnum arg) { this->value = i32(arg); }
+inline gitlab::FieldId::FieldId() {
+    gitlab::FieldId_Init(*this);
+}
+
+
+// --- gitlab.FieldId.value.GetEnum
+// Get value of field as enum type
+inline gitlab_FieldIdEnum gitlab::value_GetEnum(const gitlab::FieldId& parent) {
+    return gitlab_FieldIdEnum(parent.value);
+}
+
+// --- gitlab.FieldId.value.SetEnum
+// Set value of field from enum type.
+inline void gitlab::value_SetEnum(gitlab::FieldId& parent, gitlab_FieldIdEnum rhs) {
+    parent.value = i32(rhs);
+}
+
+// --- gitlab.FieldId.value.Cast
+inline gitlab::FieldId::operator gitlab_FieldIdEnum () const {
+    return gitlab_FieldIdEnum((*this).value);
+}
+
+// --- gitlab.FieldId..Init
+// Set all fields to initial values.
+inline void gitlab::FieldId_Init(gitlab::FieldId& parent) {
+    parent.value = i32(-1);
+}
+inline gitlab::Issue::Issue() {
+}
+
+inline gitlab::IssueDescription::IssueDescription() {
+}
+
+inline gitlab::IssueNote::IssueNote() {
+}
+
+inline gitlab::Mr::Mr() {
+}
+
+inline gitlab::MrDescription::MrDescription() {
+}
+
+inline gitlab::MrNote::MrNote() {
+}
+
+inline gitlab::TableId::TableId(i32                            in_value)
+    : value(in_value)
+{
+}
+inline gitlab::TableId::TableId(gitlab_TableIdEnum arg) { this->value = i32(arg); }
+inline gitlab::TableId::TableId() {
+    gitlab::TableId_Init(*this);
+}
+
+
+// --- gitlab.TableId.value.GetEnum
+// Get value of field as enum type
+inline gitlab_TableIdEnum gitlab::value_GetEnum(const gitlab::TableId& parent) {
+    return gitlab_TableIdEnum(parent.value);
+}
+
+// --- gitlab.TableId.value.SetEnum
+// Set value of field from enum type.
+inline void gitlab::value_SetEnum(gitlab::TableId& parent, gitlab_TableIdEnum rhs) {
+    parent.value = i32(rhs);
+}
+
+// --- gitlab.TableId.value.Cast
+inline gitlab::TableId::operator gitlab_TableIdEnum () const {
+    return gitlab_TableIdEnum((*this).value);
+}
+
+// --- gitlab.TableId..Init
+// Set all fields to initial values.
+inline void gitlab::TableId_Init(gitlab::TableId& parent) {
+    parent.value = i32(-1);
+}
+inline gitlab::User::User() {
+    gitlab::User_Init(*this);
+}
+
+
+// --- gitlab.User..Init
+// Set all fields to initial values.
+inline void gitlab::User_Init(gitlab::User& parent) {
+    parent.id = u32(0);
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::trace &row) {// cfmt:gitlab.trace.String
+    gitlab::trace_Print(const_cast<gitlab::trace&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FHttp &row) {// cfmt:gitlab.FHttp.String
+    gitlab::FHttp_Print(const_cast<gitlab::FHttp&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FIssue &row) {// cfmt:gitlab.FIssue.String
+    gitlab::FIssue_Print(const_cast<gitlab::FIssue&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FMr &row) {// cfmt:gitlab.FMr.String
+    gitlab::FMr_Print(const_cast<gitlab::FMr&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FieldId &row) {// cfmt:gitlab.FieldId.String
+    gitlab::FieldId_Print(const_cast<gitlab::FieldId&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::Issue &row) {// cfmt:gitlab.Issue.String
+    gitlab::Issue_Print(const_cast<gitlab::Issue&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::IssueDescription &row) {// cfmt:gitlab.IssueDescription.String
+    gitlab::IssueDescription_Print(const_cast<gitlab::IssueDescription&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::IssueNote &row) {// cfmt:gitlab.IssueNote.String
+    gitlab::IssueNote_Print(const_cast<gitlab::IssueNote&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::Mr &row) {// cfmt:gitlab.Mr.String
+    gitlab::Mr_Print(const_cast<gitlab::Mr&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::MrDescription &row) {// cfmt:gitlab.MrDescription.String
+    gitlab::MrDescription_Print(const_cast<gitlab::MrDescription&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::MrNote &row) {// cfmt:gitlab.MrNote.String
+    gitlab::MrNote_Print(const_cast<gitlab::MrNote&>(row), str);
+    return str;
+}
+
+inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::TableId &row) {// cfmt:gitlab.TableId.String
+    gitlab::TableId_Print(const_cast<gitlab::TableId&>(row), str);
+    return str;
+}
diff --git a/include/gitlab.h b/include/gitlab.h
new file mode 100644
index 000000000..2f4792494
--- /dev/null
+++ b/include/gitlab.h
@@ -0,0 +1,31 @@
+//
+// Target: gitlab (exe) -- Gitlab command line interface
+// Exceptions: yes
+// Header: include/gitlab.h
+//
+
+#include "include/gen/gitlab_gen.h"
+#include "include/gen/gitlab_gen.inl.h"
+
+namespace gitlab { // update-hdr
+    // Dear human:
+    //     Text from here to the closing curly brace was produced by scanning
+    //     source files. Editing this text is futile.
+    //     To refresh the contents of this section, run 'update-hdr'.
+    //     To convert this section to a hand-written section, remove the word 'update-hdr' from namespace line.
+
+    // -------------------------------------------------------------------
+    // cpp/gitlab.cpp
+    //
+
+    // Interpret -issue argument as a number, or specific issue id
+    // gitlab -issue 33           --> return 33
+    // gitlab -issue myproject.33 --> return 33
+    // gitlab -issue %            --> return 0
+    int IssueArgNumber();
+
+    // same for mr
+    int MrNumber(strptr in);
+    u32 GetUserId(strptr user);
+    void Main();
+}
