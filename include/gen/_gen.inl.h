//
// include/gen/_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//



// --- pad_byte..Init
// Set all fields to initial values.
inline void pad_byte_Init(pad_byte& parent) {
    parent.value = u8(0);
}

// --- bool..Hash
inline u32 bool_Hash(u32 prev, bool rhs) {
    prev = _mm_crc32_u8(prev,rhs);
    return prev;
}

// --- bool..Lt
inline bool bool_Lt(bool lhs, bool rhs) {
    return lhs < rhs;
}

// --- bool..Cmp
inline i32 bool_Cmp(bool lhs, bool rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- bool..Eq
inline bool bool_Eq(bool lhs, bool rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- bool..Update
// Set value. Return true if new value is different from old value.
inline bool bool_Update(bool &lhs, bool rhs) {
    bool ret = !bool_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- char..Hash
inline u32 char_Hash(u32 prev, char rhs) {
    prev = _mm_crc32_u8(prev,rhs);
    return prev;
}

// --- char..Lt
inline bool char_Lt(char lhs, char rhs) {
    return lhs < rhs;
}

// --- char..Cmp
inline i32 char_Cmp(char lhs, char rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- char..Eq
inline bool char_Eq(char lhs, char rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- char..Update
// Set value. Return true if new value is different from old value.
inline bool char_Update(char &lhs, char rhs) {
    bool ret = !char_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- double..Hash
inline u32 double_Hash(u32 prev, double rhs) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
    u64 val0 = *(u64*)((u8*)&rhs + 0);
    prev = _mm_crc32_u64(prev, val0);
#pragma GCC diagnostic pop
    return prev;
}

// --- double..Lt
inline bool double_Lt(double lhs, double rhs) {
    return lhs < rhs;
}

// --- double..Cmp
inline i32 double_Cmp(double lhs, double rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- double..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool double_UpdateMax(double &lhs, double rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- double..Min
// Return the lesser of two values
inline double double_Min(double lhs, double rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- double..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool double_UpdateMin(double &lhs, double rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- double..Max
// Return the greater of two values
inline double double_Max(double lhs, double rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- double..Eq
inline bool double_Eq(double lhs, double rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- double..Update
// Set value. Return true if new value is different from old value.
inline bool double_Update(double &lhs, double rhs) {
    bool ret = !double_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- float..Hash
inline u32 float_Hash(u32 prev, float rhs) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
    u32 val0 = *(u32*)((u8*)&rhs + 0);
    prev = _mm_crc32_u32(prev, val0);
#pragma GCC diagnostic pop
    return prev;
}

// --- float..Lt
inline bool float_Lt(float lhs, float rhs) {
    return lhs < rhs;
}

// --- float..Cmp
inline i32 float_Cmp(float lhs, float rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- float..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool float_UpdateMax(float &lhs, float rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- float..Min
// Return the lesser of two values
inline float float_Min(float lhs, float rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- float..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool float_UpdateMin(float &lhs, float rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- float..Max
// Return the greater of two values
inline float float_Max(float lhs, float rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- float..Eq
inline bool float_Eq(float lhs, float rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- float..Update
// Set value. Return true if new value is different from old value.
inline bool float_Update(float &lhs, float rhs) {
    bool ret = !float_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- i16..Hash
inline u32 i16_Hash(u32 prev, i16 rhs) {
    prev = _mm_crc32_u16(prev,rhs);
    return prev;
}

// --- i16..Lt
inline bool i16_Lt(i16 lhs, i16 rhs) {
    return lhs < rhs;
}

// --- i16..Cmp
inline i32 i16_Cmp(i16 lhs, i16 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- i16..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool i16_UpdateMax(i16 &lhs, i16 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i16..Min
// Return the lesser of two values
inline i16 i16_Min(i16 lhs, i16 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- i16..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool i16_UpdateMin(i16 &lhs, i16 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i16..Max
// Return the greater of two values
inline i16 i16_Max(i16 lhs, i16 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- i16..Eq
inline bool i16_Eq(i16 lhs, i16 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- i16..Update
// Set value. Return true if new value is different from old value.
inline bool i16_Update(i16 &lhs, i16 rhs) {
    bool ret = !i16_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- i32..Hash
inline u32 i32_Hash(u32 prev, i32 rhs) {
    prev = _mm_crc32_u32(prev,rhs);
    return prev;
}

// --- i32..Lt
inline bool i32_Lt(i32 lhs, i32 rhs) {
    return lhs < rhs;
}

// --- i32..Cmp
inline i32 i32_Cmp(i32 lhs, i32 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- i32..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool i32_UpdateMax(i32 &lhs, i32 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i32..Min
// Return the lesser of two values
inline i32 i32_Min(i32 lhs, i32 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- i32..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool i32_UpdateMin(i32 &lhs, i32 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i32..Max
// Return the greater of two values
inline i32 i32_Max(i32 lhs, i32 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- i32..Eq
inline bool i32_Eq(i32 lhs, i32 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- i32..Update
// Set value. Return true if new value is different from old value.
inline bool i32_Update(i32 &lhs, i32 rhs) {
    bool ret = !i32_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- i64..Hash
inline u32 i64_Hash(u32 prev, i64 rhs) {
    prev = _mm_crc32_u64(prev,rhs);
    return prev;
}

// --- i64..Lt
inline bool i64_Lt(i64 lhs, i64 rhs) {
    return lhs < rhs;
}

// --- i64..Cmp
inline i32 i64_Cmp(i64 lhs, i64 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- i64..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool i64_UpdateMax(i64 &lhs, i64 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i64..Min
// Return the lesser of two values
inline i64 i64_Min(i64 lhs, i64 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- i64..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool i64_UpdateMin(i64 &lhs, i64 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i64..Max
// Return the greater of two values
inline i64 i64_Max(i64 lhs, i64 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- i64..Eq
inline bool i64_Eq(i64 lhs, i64 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- i64..Update
// Set value. Return true if new value is different from old value.
inline bool i64_Update(i64 &lhs, i64 rhs) {
    bool ret = !i64_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- i8..Hash
inline u32 i8_Hash(u32 prev, i8 rhs) {
    prev = _mm_crc32_u8(prev,rhs);
    return prev;
}

// --- i8..Lt
inline bool i8_Lt(i8 lhs, i8 rhs) {
    return lhs < rhs;
}

// --- i8..Cmp
inline i32 i8_Cmp(i8 lhs, i8 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- i8..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool i8_UpdateMax(i8 &lhs, i8 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i8..Min
// Return the lesser of two values
inline i8 i8_Min(i8 lhs, i8 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- i8..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool i8_UpdateMin(i8 &lhs, i8 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- i8..Max
// Return the greater of two values
inline i8 i8_Max(i8 lhs, i8 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- i8..Eq
inline bool i8_Eq(i8 lhs, i8 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- i8..Update
// Set value. Return true if new value is different from old value.
inline bool i8_Update(i8 &lhs, i8 rhs) {
    bool ret = !i8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- u8..Hash
inline u32 u8_Hash(u32 prev, u8 rhs) {
    prev = _mm_crc32_u8(prev,rhs);
    return prev;
}

// --- u8..Lt
inline bool u8_Lt(u8 lhs, u8 rhs) {
    return lhs < rhs;
}

// --- u8..Cmp
inline i32 u8_Cmp(u8 lhs, u8 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- u8..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool u8_UpdateMax(u8 &lhs, u8 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u8..Min
// Return the lesser of two values
inline u8 u8_Min(u8 lhs, u8 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- u8..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool u8_UpdateMin(u8 &lhs, u8 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u8..Max
// Return the greater of two values
inline u8 u8_Max(u8 lhs, u8 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- u8..Eq
inline bool u8_Eq(u8 lhs, u8 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- u8..Update
// Set value. Return true if new value is different from old value.
inline bool u8_Update(u8 &lhs, u8 rhs) {
    bool ret = !u8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- u128..Hash
inline u32 u128_Hash(u32 prev, u128 rhs) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
    u64 val0 = *(u64*)((u8*)&rhs + 0);
    prev = _mm_crc32_u64(prev, val0);
    u64 val8 = *(u64*)((u8*)&rhs + 8);
    prev = _mm_crc32_u64(prev, val8);
#pragma GCC diagnostic pop
    return prev;
}

// --- u128..Lt
inline bool u128_Lt(u128 lhs, u128 rhs) {
    return lhs < rhs;
}

// --- u128..Cmp
inline i32 u128_Cmp(u128 lhs, u128 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- u128..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool u128_UpdateMax(u128 &lhs, u128 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u128..Min
// Return the lesser of two values
inline u128 u128_Min(u128 lhs, u128 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- u128..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool u128_UpdateMin(u128 &lhs, u128 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u128..Max
// Return the greater of two values
inline u128 u128_Max(u128 lhs, u128 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- u128..Eq
inline bool u128_Eq(u128 lhs, u128 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- u128..Update
// Set value. Return true if new value is different from old value.
inline bool u128_Update(u128 &lhs, u128 rhs) {
    bool ret = !u128_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- u16..Hash
inline u32 u16_Hash(u32 prev, u16 rhs) {
    prev = _mm_crc32_u16(prev,rhs);
    return prev;
}

// --- u16..Lt
inline bool u16_Lt(u16 lhs, u16 rhs) {
    return lhs < rhs;
}

// --- u16..Cmp
inline i32 u16_Cmp(u16 lhs, u16 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- u16..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool u16_UpdateMax(u16 &lhs, u16 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u16..Min
// Return the lesser of two values
inline u16 u16_Min(u16 lhs, u16 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- u16..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool u16_UpdateMin(u16 &lhs, u16 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u16..Max
// Return the greater of two values
inline u16 u16_Max(u16 lhs, u16 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- u16..Eq
inline bool u16_Eq(u16 lhs, u16 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- u16..Update
// Set value. Return true if new value is different from old value.
inline bool u16_Update(u16 &lhs, u16 rhs) {
    bool ret = !u16_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- u32..Hash
inline u32 u32_Hash(u32 prev, u32 rhs) {
    prev = _mm_crc32_u32(prev,rhs);
    return prev;
}

// --- u32..Lt
inline bool u32_Lt(u32 lhs, u32 rhs) {
    return lhs < rhs;
}

// --- u32..Cmp
inline i32 u32_Cmp(u32 lhs, u32 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- u32..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool u32_UpdateMax(u32 &lhs, u32 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u32..Min
// Return the lesser of two values
inline u32 u32_Min(u32 lhs, u32 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- u32..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool u32_UpdateMin(u32 &lhs, u32 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u32..Max
// Return the greater of two values
inline u32 u32_Max(u32 lhs, u32 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- u32..Eq
inline bool u32_Eq(u32 lhs, u32 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- u32..Update
// Set value. Return true if new value is different from old value.
inline bool u32_Update(u32 &lhs, u32 rhs) {
    bool ret = !u32_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- u64..Hash
inline u32 u64_Hash(u32 prev, u64 rhs) {
    prev = _mm_crc32_u64(prev,rhs);
    return prev;
}

// --- u64..Lt
inline bool u64_Lt(u64 lhs, u64 rhs) {
    return lhs < rhs;
}

// --- u64..Cmp
inline i32 u64_Cmp(u64 lhs, u64 rhs) {
    i32 retval = 0;
    retval = lhs<rhs ? -1 : lhs>rhs;
    return retval;
}

// --- u64..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool u64_UpdateMax(u64 &lhs, u64 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u64..Min
// Return the lesser of two values
inline u64 u64_Min(u64 lhs, u64 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- u64..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool u64_UpdateMin(u64 &lhs, u64 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- u64..Max
// Return the greater of two values
inline u64 u64_Max(u64 lhs, u64 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- u64..Eq
inline bool u64_Eq(u64 lhs, u64 rhs) {
    bool retval = true;
    retval = lhs == rhs;
    return retval;
}

// --- u64..Update
// Set value. Return true if new value is different from old value.
inline bool u64_Update(u64 &lhs, u64 rhs) {
    bool ret = !u64_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const bool &row) {// cfmt:bool.String
    bool_Print(const_cast<bool&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const char &row) {// cfmt:char.String
    char_Print(const_cast<char&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const double &row) {// cfmt:double.String
    double_Print(const_cast<double&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const float &row) {// cfmt:float.String
    float_Print(const_cast<float&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const i16 &row) {// cfmt:i16.String
    i16_Print(const_cast<i16&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const i32 &row) {// cfmt:i32.String
    i32_Print(const_cast<i32&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const i64 &row) {// cfmt:i64.String
    i64_Print(const_cast<i64&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const i8 &row) {// cfmt:i8.String
    i8_Print(const_cast<i8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const u8 &row) {// cfmt:u8.String
    u8_Print(const_cast<u8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const u128 &row) {// cfmt:u128.String
    u128_Print(const_cast<u128&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const u16 &row) {// cfmt:u16.String
    u16_Print(const_cast<u16&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const u32 &row) {// cfmt:u32.String
    u32_Print(const_cast<u32&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const u64 &row) {// cfmt:u64.String
    u64_Print(const_cast<u64&>(row), str);
    return str;
}
