//
// include/gen/kafka_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude

// --- kafka.AclOperationType.value.GetEnum
// Get value of field as enum type
inline kafka_AclOperationTypeEnum kafka::value_GetEnum(const kafka::AclOperationType& parent) {
    return kafka_AclOperationTypeEnum(parent.value);
}

// --- kafka.AclOperationType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::AclOperationType& parent, kafka_AclOperationTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.AclOperationType..Init
// Set all fields to initial values.
inline void kafka::AclOperationType_Init(kafka::AclOperationType& parent) {
    parent.value = u8(0);
}

// --- kafka.AclOperationType..Ctor
inline  kafka::AclOperationType::AclOperationType() {
    kafka::AclOperationType_Init(*this);
}

// --- kafka.AclOperationType..FieldwiseCtor
inline  kafka::AclOperationType::AclOperationType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.AclOperationType..EnumCtor
inline  kafka::AclOperationType::AclOperationType(kafka_AclOperationTypeEnum arg) {
    this->value = u8(arg);
}

// --- kafka.AclOperations.value.Cast
inline  kafka::AclOperations::operator kafka_AclOperationsEnum() const {
    return kafka_AclOperationsEnum((*this).value);
}

// --- kafka.AclOperations.UNKNOWN.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool kafka::UNKNOWN_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- kafka.AclOperations.UNKNOWN.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void kafka::UNKNOWN_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 0;
    i32 t2    = (i32(rhs) & 0x01) << 0;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.ANY.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool kafka::ANY_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- kafka.AclOperations.ANY.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void kafka::ANY_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 1;
    i32 t2    = (i32(rhs) & 0x01) << 1;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.ALL.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool kafka::ALL_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- kafka.AclOperations.ALL.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void kafka::ALL_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 2;
    i32 t2    = (i32(rhs) & 0x01) << 2;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.READ.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool kafka::READ_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- kafka.AclOperations.READ.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void kafka::READ_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 3;
    i32 t2    = (i32(rhs) & 0x01) << 3;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.WRITE.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
inline bool kafka::WRITE_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 4) & 0x01);
}

// --- kafka.AclOperations.WRITE.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
inline void kafka::WRITE_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 4;
    i32 t2    = (i32(rhs) & 0x01) << 4;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.CREATE.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 5.
inline bool kafka::CREATE_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 5) & 0x01);
}

// --- kafka.AclOperations.CREATE.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 5.
inline void kafka::CREATE_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 5;
    i32 t2    = (i32(rhs) & 0x01) << 5;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.DELETE.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
inline bool kafka::DELETE_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 6) & 0x01);
}

// --- kafka.AclOperations.DELETE.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
inline void kafka::DELETE_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 6;
    i32 t2    = (i32(rhs) & 0x01) << 6;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.ALTER.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 7.
inline bool kafka::ALTER_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 7) & 0x01);
}

// --- kafka.AclOperations.ALTER.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 7.
inline void kafka::ALTER_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 7;
    i32 t2    = (i32(rhs) & 0x01) << 7;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.DESCRIBE.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 8.
inline bool kafka::DESCRIBE_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 8) & 0x01);
}

// --- kafka.AclOperations.DESCRIBE.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 8.
inline void kafka::DESCRIBE_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 8;
    i32 t2    = (i32(rhs) & 0x01) << 8;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.CLUSTER_ACTION.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 9.
inline bool kafka::CLUSTER_ACTION_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 9) & 0x01);
}

// --- kafka.AclOperations.CLUSTER_ACTION.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 9.
inline void kafka::CLUSTER_ACTION_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 9;
    i32 t2    = (i32(rhs) & 0x01) << 9;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.DESCRIBE_CONFIGS.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 10.
inline bool kafka::DESCRIBE_CONFIGS_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 10) & 0x01);
}

// --- kafka.AclOperations.DESCRIBE_CONFIGS.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 10.
inline void kafka::DESCRIBE_CONFIGS_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 10;
    i32 t2    = (i32(rhs) & 0x01) << 10;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.ALTER_CONFIGS.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 11.
inline bool kafka::ALTER_CONFIGS_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 11) & 0x01);
}

// --- kafka.AclOperations.ALTER_CONFIGS.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 11.
inline void kafka::ALTER_CONFIGS_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 11;
    i32 t2    = (i32(rhs) & 0x01) << 11;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.IDEMPOTENT_WRITE.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 12.
inline bool kafka::IDEMPOTENT_WRITE_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 12) & 0x01);
}

// --- kafka.AclOperations.IDEMPOTENT_WRITE.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 12.
inline void kafka::IDEMPOTENT_WRITE_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 12;
    i32 t2    = (i32(rhs) & 0x01) << 12;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.CREATE_TOKENS.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 13.
inline bool kafka::CREATE_TOKENS_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 13) & 0x01);
}

// --- kafka.AclOperations.CREATE_TOKENS.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 13.
inline void kafka::CREATE_TOKENS_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 13;
    i32 t2    = (i32(rhs) & 0x01) << 13;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.DESCRIBE_TOKENS.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 14.
inline bool kafka::DESCRIBE_TOKENS_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 14) & 0x01);
}

// --- kafka.AclOperations.DESCRIBE_TOKENS.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 14.
inline void kafka::DESCRIBE_TOKENS_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 14;
    i32 t2    = (i32(rhs) & 0x01) << 14;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations.OMITTED.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 31.
inline bool kafka::OMITTED_Get(const kafka::AclOperations& parent) {
    return bool((parent.value >> 31) & 0x01);
}

// --- kafka.AclOperations.OMITTED.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 31.
inline void kafka::OMITTED_Set(kafka::AclOperations& parent, bool rhs) {
    i32 t1    = i32(0x01) << 31;
    i32 t2    = (i32(rhs) & 0x01) << 31;
    parent.value = i32((parent.value & ~t1) | t2);
}

// --- kafka.AclOperations..Ctor
inline  kafka::AclOperations::AclOperations() {
    kafka::AclOperations_Init(*this);
}

// --- kafka.AclOperations..FieldwiseCtor
inline  kafka::AclOperations::AclOperations(i32 in_value)
    : value(in_value)
 {
}

// --- kafka.AclOperations..EnumCtor
inline  kafka::AclOperations::AclOperations(kafka_AclOperationsEnum arg) {
    this->value = i32(arg);
}

// --- kafka.AclPermissionType.value.GetEnum
// Get value of field as enum type
inline kafka_AclPermissionTypeEnum kafka::value_GetEnum(const kafka::AclPermissionType& parent) {
    return kafka_AclPermissionTypeEnum(parent.value);
}

// --- kafka.AclPermissionType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::AclPermissionType& parent, kafka_AclPermissionTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.AclPermissionType..Init
// Set all fields to initial values.
inline void kafka::AclPermissionType_Init(kafka::AclPermissionType& parent) {
    parent.value = u8(0);
}

// --- kafka.AclPermissionType..Ctor
inline  kafka::AclPermissionType::AclPermissionType() {
    kafka::AclPermissionType_Init(*this);
}

// --- kafka.AclPermissionType..FieldwiseCtor
inline  kafka::AclPermissionType::AclPermissionType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.AclPermissionType..EnumCtor
inline  kafka::AclPermissionType::AclPermissionType(kafka_AclPermissionTypeEnum arg) {
    this->value = u8(arg);
}

// --- kafka.CompressionType.value.GetEnum
// Get value of field as enum type
inline kafka_CompressionTypeEnum kafka::value_GetEnum(const kafka::CompressionType& parent) {
    return kafka_CompressionTypeEnum(parent.value);
}

// --- kafka.CompressionType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::CompressionType& parent, kafka_CompressionTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.CompressionType..Init
// Set all fields to initial values.
inline void kafka::CompressionType_Init(kafka::CompressionType& parent) {
    parent.value = u8(0);
}

// --- kafka.CompressionType..Ctor
inline  kafka::CompressionType::CompressionType() {
    kafka::CompressionType_Init(*this);
}

// --- kafka.CompressionType..FieldwiseCtor
inline  kafka::CompressionType::CompressionType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.CompressionType..EnumCtor
inline  kafka::CompressionType::CompressionType(kafka_CompressionTypeEnum arg) {
    this->value = u8(arg);
}

// --- kafka.ConfigSource.value.GetEnum
// Get value of field as enum type
inline kafka_ConfigSourceEnum kafka::value_GetEnum(const kafka::ConfigSource& parent) {
    return kafka_ConfigSourceEnum(parent.value);
}

// --- kafka.ConfigSource.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::ConfigSource& parent, kafka_ConfigSourceEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.ConfigSource..Hash
inline u32 kafka::ConfigSource_Hash(u32 prev, const kafka::ConfigSource& rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- kafka.ConfigSource..EqOp
inline bool kafka::ConfigSource::operator ==(const kafka::ConfigSource &rhs) const {
    return kafka::ConfigSource_Eq(const_cast<kafka::ConfigSource&>(*this),const_cast<kafka::ConfigSource&>(rhs));
}

// --- kafka.ConfigSource..NeOp
inline bool kafka::ConfigSource::operator !=(const kafka::ConfigSource &rhs) const {
    return !kafka::ConfigSource_Eq(const_cast<kafka::ConfigSource&>(*this),const_cast<kafka::ConfigSource&>(rhs));
}

// --- kafka.ConfigSource..Cmp
inline i32 kafka::ConfigSource_Cmp(kafka::ConfigSource& lhs, kafka::ConfigSource& rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- kafka.ConfigSource..Init
// Set all fields to initial values.
inline void kafka::ConfigSource_Init(kafka::ConfigSource& parent) {
    parent.value = u8(0);
}

// --- kafka.ConfigSource..Eq
inline bool kafka::ConfigSource_Eq(kafka::ConfigSource& lhs, kafka::ConfigSource& rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- kafka.ConfigSource..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool kafka::ConfigSource::operator ==(kafka_ConfigSourceEnum rhs) const {
    return kafka_ConfigSourceEnum(value) == rhs;
}

// --- kafka.ConfigSource..Ctor
inline  kafka::ConfigSource::ConfigSource() {
    kafka::ConfigSource_Init(*this);
}

// --- kafka.ConfigSource..FieldwiseCtor
inline  kafka::ConfigSource::ConfigSource(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.ConfigSource..EnumCtor
inline  kafka::ConfigSource::ConfigSource(kafka_ConfigSourceEnum arg) {
    this->value = u8(arg);
}

// --- kafka.ConfigType.value.GetEnum
// Get value of field as enum type
inline kafka_ConfigTypeEnum kafka::value_GetEnum(const kafka::ConfigType& parent) {
    return kafka_ConfigTypeEnum(parent.value);
}

// --- kafka.ConfigType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::ConfigType& parent, kafka_ConfigTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.ConfigType..Hash
inline u32 kafka::ConfigType_Hash(u32 prev, const kafka::ConfigType& rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- kafka.ConfigType..EqOp
inline bool kafka::ConfigType::operator ==(const kafka::ConfigType &rhs) const {
    return kafka::ConfigType_Eq(const_cast<kafka::ConfigType&>(*this),const_cast<kafka::ConfigType&>(rhs));
}

// --- kafka.ConfigType..NeOp
inline bool kafka::ConfigType::operator !=(const kafka::ConfigType &rhs) const {
    return !kafka::ConfigType_Eq(const_cast<kafka::ConfigType&>(*this),const_cast<kafka::ConfigType&>(rhs));
}

// --- kafka.ConfigType..Cmp
inline i32 kafka::ConfigType_Cmp(kafka::ConfigType& lhs, kafka::ConfigType& rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- kafka.ConfigType..Init
// Set all fields to initial values.
inline void kafka::ConfigType_Init(kafka::ConfigType& parent) {
    parent.value = u8(0);
}

// --- kafka.ConfigType..Eq
inline bool kafka::ConfigType_Eq(kafka::ConfigType& lhs, kafka::ConfigType& rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- kafka.ConfigType..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool kafka::ConfigType::operator ==(kafka_ConfigTypeEnum rhs) const {
    return kafka_ConfigTypeEnum(value) == rhs;
}

// --- kafka.ConfigType..Ctor
inline  kafka::ConfigType::ConfigType() {
    kafka::ConfigType_Init(*this);
}

// --- kafka.ConfigType..FieldwiseCtor
inline  kafka::ConfigType::ConfigType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.ConfigType..EnumCtor
inline  kafka::ConfigType::ConfigType(kafka_ConfigTypeEnum arg) {
    this->value = u8(arg);
}

// --- kafka.Error.value.Cast
inline  kafka::Error::operator i16() const {
    return i16((*this).value);
}

// --- kafka.Error..Init
// Set all fields to initial values.
inline void kafka::Error_Init(kafka::Error& parent) {
    parent.value = i16(0);
}

// --- kafka.Error..Ctor
inline  kafka::Error::Error() {
    kafka::Error_Init(*this);
}

// --- kafka.Error..FieldwiseCtor
inline  kafka::Error::Error(i16 in_value)
    : value(in_value)
 {
}

// --- kafka.FieldId.value.GetEnum
// Get value of field as enum type
inline kafka_FieldIdEnum kafka::value_GetEnum(const kafka::FieldId& parent) {
    return kafka_FieldIdEnum(parent.value);
}

// --- kafka.FieldId.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::FieldId& parent, kafka_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- kafka.FieldId.value.Cast
inline  kafka::FieldId::operator kafka_FieldIdEnum() const {
    return kafka_FieldIdEnum((*this).value);
}

// --- kafka.FieldId..Init
// Set all fields to initial values.
inline void kafka::FieldId_Init(kafka::FieldId& parent) {
    parent.value = i32(-1);
}

// --- kafka.FieldId..Ctor
inline  kafka::FieldId::FieldId() {
    kafka::FieldId_Init(*this);
}

// --- kafka.FieldId..FieldwiseCtor
inline  kafka::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- kafka.FieldId..EnumCtor
inline  kafka::FieldId::FieldId(kafka_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- kafka.Frame.size.Get
inline i32 kafka::size_Get(const kafka::Frame& parent) {
    return be32toh(parent.size_be); // read big-endian value from memory
}

// --- kafka.Frame.size.Set
inline void kafka::size_Set(kafka::Frame& parent, i32 rhs) {
    parent.size_be = htobe32(rhs); // write big-endian value to memory
}

// --- kafka.Frame.payload.N
// Return number of elements in varlen field
inline u32 kafka::payload_N(const kafka::Frame& parent) {
    u32 length = i32(size_Get(((kafka::Frame&)parent)) + 4);
    u32 extra_bytes = u32_Max(length,sizeof(kafka::Frame)) - sizeof(kafka::Frame); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u8));
}

// --- kafka.Frame.payload_curs.Reset
inline void kafka::Frame_payload_curs_Reset(Frame_payload_curs &curs, kafka::Frame &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(size_Get(parent) + 4) - sizeof(kafka::Frame);
    curs.index = 0;
}

// --- kafka.Frame.payload_curs.ValidQ
// cursor points to valid item
inline bool kafka::Frame_payload_curs_ValidQ(Frame_payload_curs &curs) {
    bool valid = ssizeof(u8) <= curs.length;
    return valid;
}

// --- kafka.Frame.payload_curs.Next
// proceed to next item
inline void kafka::Frame_payload_curs_Next(Frame_payload_curs &curs) {
    i32 len = i32(sizeof(u8));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- kafka.Frame.payload_curs.Access
// item access
inline u8& kafka::Frame_payload_curs_Access(Frame_payload_curs &curs) {
    return *(u8*)curs.ptr;
}

// --- kafka.Frame..GetMsgLength
// Message length (uses length field)
inline i32 kafka::GetMsgLength(const kafka::Frame& parent) {
    return i32(size_Get(const_cast<kafka::Frame&>(parent)) + 4);
}

// --- kafka.Frame..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr kafka::GetMsgMemptr(const kafka::Frame& row) {
    return algo::memptr((u8*)&row, i32(size_Get(const_cast<kafka::Frame&>(row)) + 4));
}

// --- kafka.Frame..Init
// Set all fields to initial values.
inline void kafka::Frame_Init(kafka::Frame& parent) {
    parent.size_be = htobe32(0); // write big-endian value to memory
}

// --- kafka.Frame..Ctor
inline  kafka::Frame::Frame() {
    kafka::Frame_Init(*this);
}

// --- kafka.Frame_curs..ValidQ
inline bool kafka::Frame_curs_ValidQ(kafka::Frame_curs& curs) {
    return curs.msg != NULL;
}

// --- kafka.Frame_curs..Reset
inline void kafka::Frame_curs_Reset(kafka::Frame_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    kafka::Frame *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(kafka::Frame)) {
        kafka::Frame *ptr = (kafka::Frame*)curs.bytes;
        msglen = i32(size_Get((*ptr)) + 4);
        if (msglen >= ssizeof(kafka::Frame) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- kafka.Frame_curs..Access
inline kafka::Frame*& kafka::Frame_curs_Access(kafka::Frame_curs& curs) {
    return curs.msg;
}

// --- kafka.Frame_curs..Next
inline void kafka::Frame_curs_Next(kafka::Frame_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    kafka::Frame *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(kafka::Frame)) {
        kafka::Frame *ptr = (kafka::Frame*)curs.bytes;
        msglen = i32(size_Get((*ptr)) + 4);
        if (msglen >= ssizeof(kafka::Frame) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- kafka.Frame_curs..Init
// Set all fields to initial values.
inline void kafka::Frame_curs_Init(kafka::Frame_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- kafka.Frame_curs..Ctor
inline  kafka::Frame_curs::Frame_curs() {
    kafka::Frame_curs_Init(*this);
}

// --- kafka.GroupRecordKeyHeader.type.GetEnum
// Get value of field as enum type
inline kafka_GroupRecordKeyHeader_type_Enum kafka::type_GetEnum(const kafka::GroupRecordKeyHeader& parent) {
    return kafka_GroupRecordKeyHeader_type_Enum(parent.type);
}

// --- kafka.GroupRecordKeyHeader.type.SetEnum
// Set value of field from enum type.
inline void kafka::type_SetEnum(kafka::GroupRecordKeyHeader& parent, kafka_GroupRecordKeyHeader_type_Enum rhs) {
    parent.type = i16(rhs);
}

// --- kafka.GroupRecordKeyHeader..Init
// Set all fields to initial values.
inline void kafka::GroupRecordKeyHeader_Init(kafka::GroupRecordKeyHeader& parent) {
    parent.type = i16(0);
    parent.version = i16(0);
}

// --- kafka.GroupRecordKeyHeader..Ctor
inline  kafka::GroupRecordKeyHeader::GroupRecordKeyHeader() {
    kafka::GroupRecordKeyHeader_Init(*this);
}

// --- kafka.GroupRecordKeyHeaderMsgsCase.value.GetEnum
// Get value of field as enum type
inline kafka_GroupRecordKeyHeaderMsgsCaseEnum kafka::value_GetEnum(const kafka::GroupRecordKeyHeaderMsgsCase& parent) {
    return kafka_GroupRecordKeyHeaderMsgsCaseEnum(parent.value);
}

// --- kafka.GroupRecordKeyHeaderMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::GroupRecordKeyHeaderMsgsCase& parent, kafka_GroupRecordKeyHeaderMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- kafka.GroupRecordKeyHeaderMsgsCase.value.Cast
inline  kafka::GroupRecordKeyHeaderMsgsCase::operator kafka_GroupRecordKeyHeaderMsgsCaseEnum() const {
    return kafka_GroupRecordKeyHeaderMsgsCaseEnum((*this).value);
}

// --- kafka.GroupRecordKeyHeaderMsgsCase..Init
// Set all fields to initial values.
inline void kafka::GroupRecordKeyHeaderMsgsCase_Init(kafka::GroupRecordKeyHeaderMsgsCase& parent) {
    parent.value = u32(0);
}

// --- kafka.GroupRecordKeyHeaderMsgsCase..Ctor
inline  kafka::GroupRecordKeyHeaderMsgsCase::GroupRecordKeyHeaderMsgsCase() {
    kafka::GroupRecordKeyHeaderMsgsCase_Init(*this);
}

// --- kafka.GroupRecordKeyHeaderMsgsCase..FieldwiseCtor
inline  kafka::GroupRecordKeyHeaderMsgsCase::GroupRecordKeyHeaderMsgsCase(u32 in_value)
    : value(in_value)
 {
}

// --- kafka.GroupRecordKeyHeaderMsgsCase..EnumCtor
inline  kafka::GroupRecordKeyHeaderMsgsCase::GroupRecordKeyHeaderMsgsCase(kafka_GroupRecordKeyHeaderMsgsCaseEnum arg) {
    this->value = u32(arg);
}

// --- kafka.GroupRecordValueHeader.type.GetEnum
// Get value of field as enum type
inline kafka_GroupRecordValueHeader_type_Enum kafka::type_GetEnum(const kafka::GroupRecordValueHeader& parent) {
    return kafka_GroupRecordValueHeader_type_Enum(parent.type);
}

// --- kafka.GroupRecordValueHeader.type.SetEnum
// Set value of field from enum type.
inline void kafka::type_SetEnum(kafka::GroupRecordValueHeader& parent, kafka_GroupRecordValueHeader_type_Enum rhs) {
    parent.type = i16(rhs);
}

// --- kafka.GroupRecordValueHeader..Init
// Set all fields to initial values.
inline void kafka::GroupRecordValueHeader_Init(kafka::GroupRecordValueHeader& parent) {
    parent.type = i16(0);
    parent.version = i16(0);
}

// --- kafka.GroupRecordValueHeader..Ctor
inline  kafka::GroupRecordValueHeader::GroupRecordValueHeader() {
    kafka::GroupRecordValueHeader_Init(*this);
}

// --- kafka.GroupRecordValueHeaderMsgsCase.value.GetEnum
// Get value of field as enum type
inline kafka_GroupRecordValueHeaderMsgsCaseEnum kafka::value_GetEnum(const kafka::GroupRecordValueHeaderMsgsCase& parent) {
    return kafka_GroupRecordValueHeaderMsgsCaseEnum(parent.value);
}

// --- kafka.GroupRecordValueHeaderMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::GroupRecordValueHeaderMsgsCase& parent, kafka_GroupRecordValueHeaderMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- kafka.GroupRecordValueHeaderMsgsCase.value.Cast
inline  kafka::GroupRecordValueHeaderMsgsCase::operator kafka_GroupRecordValueHeaderMsgsCaseEnum() const {
    return kafka_GroupRecordValueHeaderMsgsCaseEnum((*this).value);
}

// --- kafka.GroupRecordValueHeaderMsgsCase..Init
// Set all fields to initial values.
inline void kafka::GroupRecordValueHeaderMsgsCase_Init(kafka::GroupRecordValueHeaderMsgsCase& parent) {
    parent.value = u32(0);
}

// --- kafka.GroupRecordValueHeaderMsgsCase..Ctor
inline  kafka::GroupRecordValueHeaderMsgsCase::GroupRecordValueHeaderMsgsCase() {
    kafka::GroupRecordValueHeaderMsgsCase_Init(*this);
}

// --- kafka.GroupRecordValueHeaderMsgsCase..FieldwiseCtor
inline  kafka::GroupRecordValueHeaderMsgsCase::GroupRecordValueHeaderMsgsCase(u32 in_value)
    : value(in_value)
 {
}

// --- kafka.GroupRecordValueHeaderMsgsCase..EnumCtor
inline  kafka::GroupRecordValueHeaderMsgsCase::GroupRecordValueHeaderMsgsCase(kafka_GroupRecordValueHeaderMsgsCaseEnum arg) {
    this->value = u32(arg);
}

// --- kafka.GroupState.value.GetEnum
// Get value of field as enum type
inline kafka_GroupStateEnum kafka::value_GetEnum(const kafka::GroupState& parent) {
    return kafka_GroupStateEnum(parent.value);
}

// --- kafka.GroupState.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::GroupState& parent, kafka_GroupStateEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.GroupState..Hash
inline u32 kafka::GroupState_Hash(u32 prev, const kafka::GroupState& rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- kafka.GroupState..EqOp
inline bool kafka::GroupState::operator ==(const kafka::GroupState &rhs) const {
    return kafka::GroupState_Eq(const_cast<kafka::GroupState&>(*this),const_cast<kafka::GroupState&>(rhs));
}

// --- kafka.GroupState..NeOp
inline bool kafka::GroupState::operator !=(const kafka::GroupState &rhs) const {
    return !kafka::GroupState_Eq(const_cast<kafka::GroupState&>(*this),const_cast<kafka::GroupState&>(rhs));
}

// --- kafka.GroupState..Cmp
inline i32 kafka::GroupState_Cmp(kafka::GroupState& lhs, kafka::GroupState& rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- kafka.GroupState..Init
// Set all fields to initial values.
inline void kafka::GroupState_Init(kafka::GroupState& parent) {
    parent.value = u8(5);
}

// --- kafka.GroupState..Eq
inline bool kafka::GroupState_Eq(kafka::GroupState& lhs, kafka::GroupState& rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- kafka.GroupState..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool kafka::GroupState::operator ==(kafka_GroupStateEnum rhs) const {
    return kafka_GroupStateEnum(value) == rhs;
}

// --- kafka.GroupState..Ctor
inline  kafka::GroupState::GroupState() {
    kafka::GroupState_Init(*this);
}

// --- kafka.GroupState..FieldwiseCtor
inline  kafka::GroupState::GroupState(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.GroupState..EnumCtor
inline  kafka::GroupState::GroupState(kafka_GroupStateEnum arg) {
    this->value = u8(arg);
}

// --- kafka.Header..Ctor
inline  kafka::Header::Header() {
}

// --- kafka.OffsetCommitKey.base.Castdown
// Check if kafka::GroupRecordKeyHeader is an instance of OffsetCommitKey by checking the type field
// If it is, return the pointer of target type.
// If not successful, quietly return NULL.
inline kafka::OffsetCommitKey* kafka::OffsetCommitKey_Castdown(kafka::GroupRecordKeyHeader &hdr) {
    bool cond = hdr.type == (1);
    return cond ? reinterpret_cast<kafka::OffsetCommitKey*>(&hdr) : NULL;
}

// --- kafka.OffsetCommitKey.base.Castbase
inline kafka::GroupRecordKeyHeader& kafka::Castbase(kafka::OffsetCommitKey& parent) {
    return reinterpret_cast<kafka::GroupRecordKeyHeader&>(parent);
}

// --- kafka.OffsetCommitKey..Init
// Set all fields to initial values.
inline void kafka::OffsetCommitKey_Init(kafka::OffsetCommitKey& parent) {
    parent.type = i16(1);
    parent.version = i16(0);
    parent.partition = i32(0);
}

// --- kafka.OffsetCommitKey..Ctor
inline  kafka::OffsetCommitKey::OffsetCommitKey() {
    kafka::OffsetCommitKey_Init(*this);
}

// --- kafka.OffsetCommitValue.base.Castdown
// Check if kafka::GroupRecordValueHeader is an instance of OffsetCommitValue by checking the type field
// If it is, return the pointer of target type.
// If not successful, quietly return NULL.
inline kafka::OffsetCommitValue* kafka::OffsetCommitValue_Castdown(kafka::GroupRecordValueHeader &hdr) {
    bool cond = hdr.type == (1);
    return cond ? reinterpret_cast<kafka::OffsetCommitValue*>(&hdr) : NULL;
}

// --- kafka.OffsetCommitValue.base.Castbase
inline kafka::GroupRecordValueHeader& kafka::Castbase(kafka::OffsetCommitValue& parent) {
    return reinterpret_cast<kafka::GroupRecordValueHeader&>(parent);
}

// --- kafka.OffsetCommitValue..Init
// Set all fields to initial values.
inline void kafka::OffsetCommitValue_Init(kafka::OffsetCommitValue& parent) {
    parent.type = i16(1);
    parent.version = i16(0);
    parent.offset = i64(0);
    parent.leader_epoch = i32(-1);
    parent.commit_timestamp = i64(0);
    parent.expire_timestamp = i64(-1);
}

// --- kafka.OffsetCommitValue..Ctor
inline  kafka::OffsetCommitValue::OffsetCommitValue() {
    kafka::OffsetCommitValue_Init(*this);
}

// --- kafka.PatternType.value.GetEnum
// Get value of field as enum type
inline kafka_PatternTypeEnum kafka::value_GetEnum(const kafka::PatternType& parent) {
    return kafka_PatternTypeEnum(parent.value);
}

// --- kafka.PatternType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::PatternType& parent, kafka_PatternTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.PatternType..Hash
inline u32 kafka::PatternType_Hash(u32 prev, const kafka::PatternType& rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- kafka.PatternType..EqOp
inline bool kafka::PatternType::operator ==(const kafka::PatternType &rhs) const {
    return kafka::PatternType_Eq(const_cast<kafka::PatternType&>(*this),const_cast<kafka::PatternType&>(rhs));
}

// --- kafka.PatternType..NeOp
inline bool kafka::PatternType::operator !=(const kafka::PatternType &rhs) const {
    return !kafka::PatternType_Eq(const_cast<kafka::PatternType&>(*this),const_cast<kafka::PatternType&>(rhs));
}

// --- kafka.PatternType..Cmp
inline i32 kafka::PatternType_Cmp(kafka::PatternType& lhs, kafka::PatternType& rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- kafka.PatternType..Init
// Set all fields to initial values.
inline void kafka::PatternType_Init(kafka::PatternType& parent) {
    parent.value = u8(0);
}

// --- kafka.PatternType..Eq
inline bool kafka::PatternType_Eq(kafka::PatternType& lhs, kafka::PatternType& rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- kafka.PatternType..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool kafka::PatternType::operator ==(kafka_PatternTypeEnum rhs) const {
    return kafka_PatternTypeEnum(value) == rhs;
}

// --- kafka.PatternType..Ctor
inline  kafka::PatternType::PatternType() {
    kafka::PatternType_Init(*this);
}

// --- kafka.PatternType..FieldwiseCtor
inline  kafka::PatternType::PatternType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.PatternType..EnumCtor
inline  kafka::PatternType::PatternType(kafka_PatternTypeEnum arg) {
    this->value = u8(arg);
}

// --- kafka.Record.pmask.N
// Return constant 1
inline int kafka::pmask_N(kafka::Record& parent) {
    (void)parent;
    return 1;
}

// --- kafka.Record.pmask.qFind
// Access value
inline u8& kafka::pmask_qFind(kafka::Record& parent, int) {
    return parent.pmask;
}

// --- kafka.Record.pmask.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int kafka::pmask_Nbits(kafka::Record& parent) {
    return pmask_N(parent) * 8;
}

// --- kafka.Record.pmask.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool kafka::pmask_qGetBit(kafka::Record& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = pmask_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- kafka.Record.pmask.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool kafka::pmask_GetBit(kafka::Record& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    bool ret = false;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u8 &elem = pmask_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- kafka.Record.pmask.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool kafka::pmask_BitsEmptyQ(kafka::Record& parent) {
    bool retval = true;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (pmask_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- kafka.Record.pmask.Sum1s
inline u64 kafka::pmask_Sum1s(kafka::Record& parent) {
    u64 sum = 0;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u8_Count1s(pmask_qFind(parent, i));
    }
    return sum;
}

// --- kafka.Record.pmask.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void kafka::pmask_qClearBit(kafka::Record& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u8(1) << shift); // clear bit
}

// --- kafka.Record.pmask.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void kafka::pmask_ClearBit(kafka::Record& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u8 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u8(1) << shift); // clear bit
    }
}

// --- kafka.Record.pmask.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void kafka::pmask_qSetBit(kafka::Record& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u8(1) << shift); // set bit
}

// --- kafka.Record.pmask.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void kafka::pmask_SetBit(kafka::Record& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u8 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem | (u8(1) << shift); // set bit
    }
}

// --- kafka.Record.pmask.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void kafka::pmask_qSetBitVal(kafka::Record& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u8(1) << shift)) | (u8(val) << shift); // insert new value
}

// --- kafka.Record.pmask.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void kafka::pmask_qOrBitVal(kafka::Record& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u8(val) << shift); // Or in val into elem
}

// --- kafka.Record.pmask.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void kafka::pmask_ClearBitsAll(kafka::Record& parent) {
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) = 0;
    }
}

// --- kafka.Record.pmask.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void kafka::pmask_ClearBits(kafka::Record& parent, kafka::Record &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) &= ~pmask_qFind(rhs, i);
    }
}

// --- kafka.Record.pmask.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void kafka::pmask_OrBits(kafka::Record& parent, kafka::Record &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) |= pmask_qFind(rhs, i);
    }
}

// --- kafka.Record.pmask.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 kafka::pmask_Sup(kafka::Record& parent) {
    u64 lim = pmask_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u8 &val = pmask_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 8 + bitidx;
            break;
        }
    }
    return ret;
}

// --- kafka.Record.key.PresentQ
// Return true if the field is marked in the presence mask
inline bool kafka::key_PresentQ(kafka::Record& parent) {
    return pmask_qGetBit(parent, 0);
}

// --- kafka.Record.key.SetPresent
// Set presence bit for this field in the pmask
inline void kafka::key_SetPresent(kafka::Record& parent) {
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- kafka.Record.key.Present_GetBit
// Return field's bit number in the pmask
inline int kafka::key_Present_GetBit(kafka::Record& parent) {
    int retval = 0;
    (void)parent;//only to avoid -Wunused-parameter
    return retval;
}

// --- kafka.Record.key.Set
inline void kafka::key_Set(kafka::Record& parent, const algo::strptr& rhs) {
    parent.key = rhs;
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- kafka.Record.headers.EmptyQ
// Return true if index is empty
inline bool kafka::headers_EmptyQ(kafka::Record& parent) {
    return parent.headers_n == 0;
}

// --- kafka.Record.headers.Find
// Look up row by row id. Return NULL if out of range
inline kafka::Header* kafka::headers_Find(kafka::Record& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.headers_n;
    if (idx >= lim) return NULL;
    return parent.headers_elems + idx;
}

// --- kafka.Record.headers.Getary
// Return array pointer by value
inline algo::aryptr<kafka::Header> kafka::headers_Getary(const kafka::Record& parent) {
    return algo::aryptr<kafka::Header>(parent.headers_elems, parent.headers_n);
}

// --- kafka.Record.headers.Last
// Return pointer to last element of array, or NULL if array is empty
inline kafka::Header* kafka::headers_Last(kafka::Record& parent) {
    return headers_Find(parent, u64(parent.headers_n-1));
}

// --- kafka.Record.headers.Max
// Return max. number of items in the array
inline i32 kafka::headers_Max(kafka::Record& parent) {
    (void)parent;
    return parent.headers_max;
}

// --- kafka.Record.headers.N
// Return number of items in the array
inline i32 kafka::headers_N(const kafka::Record& parent) {
    return parent.headers_n;
}

// --- kafka.Record.headers.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void kafka::headers_Reserve(kafka::Record& parent, int n) {
    u32 new_n = parent.headers_n + n;
    if (UNLIKELY(new_n > parent.headers_max)) {
        headers_AbsReserve(parent, new_n);
    }
}

// --- kafka.Record.headers.qFind
// 'quick' Access row by row id. No bounds checking.
inline kafka::Header& kafka::headers_qFind(kafka::Record& parent, u64 t) {
    return parent.headers_elems[t];
}

// --- kafka.Record.headers.qLast
// Return reference to last element of array. No bounds checking
inline kafka::Header& kafka::headers_qLast(kafka::Record& parent) {
    return headers_qFind(parent, u64(parent.headers_n-1));
}

// --- kafka.Record.headers.rowid_Get
// Return row id of specified element
inline u64 kafka::headers_rowid_Get(kafka::Record& parent, kafka::Header &elem) {
    u64 id = &elem - parent.headers_elems;
    return u64(id);
}

// --- kafka.Record.headers_curs.Next
// proceed to next item
inline void kafka::Record_headers_curs_Next(Record_headers_curs &curs) {
    curs.index++;
}

// --- kafka.Record.headers_curs.Reset
inline void kafka::Record_headers_curs_Reset(Record_headers_curs &curs, kafka::Record &parent) {
    curs.elems = parent.headers_elems;
    curs.n_elems = parent.headers_n;
    curs.index = 0;
}

// --- kafka.Record.headers_curs.ValidQ
// cursor points to valid item
inline bool kafka::Record_headers_curs_ValidQ(Record_headers_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- kafka.Record.headers_curs.Access
// item access
inline kafka::Header& kafka::Record_headers_curs_Access(Record_headers_curs &curs) {
    return curs.elems[curs.index];
}

// --- kafka.Record..Init
// Set all fields to initial values.
inline void kafka::Record_Init(kafka::Record& parent) {
    parent.attributes = u8(0);
    parent.pmask = u8(0);
    parent.timestamp_delta = i64(0);
    parent.offset_delta = i32(0);
    parent.headers_elems 	= 0; // (kafka.Record.headers)
    parent.headers_n     	= 0; // (kafka.Record.headers)
    parent.headers_max   	= 0; // (kafka.Record.headers)
}

// --- kafka.Record..Ctor
inline  kafka::Record::Record() {
    kafka::Record_Init(*this);
}

// --- kafka.Record..Dtor
inline  kafka::Record::~Record() {
    kafka::Record_Uninit(*this);
}

// --- kafka.RecordBatch.records.EmptyQ
// Return true if index is empty
inline bool kafka::records_EmptyQ(kafka::RecordBatch& parent) {
    return parent.records_n == 0;
}

// --- kafka.RecordBatch.records.Find
// Look up row by row id. Return NULL if out of range
inline kafka::Record* kafka::records_Find(kafka::RecordBatch& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.records_n;
    if (idx >= lim) return NULL;
    return parent.records_elems + idx;
}

// --- kafka.RecordBatch.records.Getary
// Return array pointer by value
inline algo::aryptr<kafka::Record> kafka::records_Getary(const kafka::RecordBatch& parent) {
    return algo::aryptr<kafka::Record>(parent.records_elems, parent.records_n);
}

// --- kafka.RecordBatch.records.Last
// Return pointer to last element of array, or NULL if array is empty
inline kafka::Record* kafka::records_Last(kafka::RecordBatch& parent) {
    return records_Find(parent, u64(parent.records_n-1));
}

// --- kafka.RecordBatch.records.Max
// Return max. number of items in the array
inline i32 kafka::records_Max(kafka::RecordBatch& parent) {
    (void)parent;
    return parent.records_max;
}

// --- kafka.RecordBatch.records.N
// Return number of items in the array
inline i32 kafka::records_N(const kafka::RecordBatch& parent) {
    return parent.records_n;
}

// --- kafka.RecordBatch.records.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void kafka::records_Reserve(kafka::RecordBatch& parent, int n) {
    u32 new_n = parent.records_n + n;
    if (UNLIKELY(new_n > parent.records_max)) {
        records_AbsReserve(parent, new_n);
    }
}

// --- kafka.RecordBatch.records.qFind
// 'quick' Access row by row id. No bounds checking.
inline kafka::Record& kafka::records_qFind(kafka::RecordBatch& parent, u64 t) {
    return parent.records_elems[t];
}

// --- kafka.RecordBatch.records.qLast
// Return reference to last element of array. No bounds checking
inline kafka::Record& kafka::records_qLast(kafka::RecordBatch& parent) {
    return records_qFind(parent, u64(parent.records_n-1));
}

// --- kafka.RecordBatch.records.rowid_Get
// Return row id of specified element
inline u64 kafka::records_rowid_Get(kafka::RecordBatch& parent, kafka::Record &elem) {
    u64 id = &elem - parent.records_elems;
    return u64(id);
}

// --- kafka.RecordBatch.records_curs.Next
// proceed to next item
inline void kafka::RecordBatch_records_curs_Next(RecordBatch_records_curs &curs) {
    curs.index++;
}

// --- kafka.RecordBatch.records_curs.Reset
inline void kafka::RecordBatch_records_curs_Reset(RecordBatch_records_curs &curs, kafka::RecordBatch &parent) {
    curs.elems = parent.records_elems;
    curs.n_elems = parent.records_n;
    curs.index = 0;
}

// --- kafka.RecordBatch.records_curs.ValidQ
// cursor points to valid item
inline bool kafka::RecordBatch_records_curs_ValidQ(RecordBatch_records_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- kafka.RecordBatch.records_curs.Access
// item access
inline kafka::Record& kafka::RecordBatch_records_curs_Access(RecordBatch_records_curs &curs) {
    return curs.elems[curs.index];
}

// --- kafka.RecordBatch..Ctor
inline  kafka::RecordBatch::RecordBatch() {
    kafka::RecordBatch_Init(*this);
}

// --- kafka.RecordBatch..Dtor
inline  kafka::RecordBatch::~RecordBatch() {
    kafka::RecordBatch_Uninit(*this);
}

// --- kafka.ResourceType.value.GetEnum
// Get value of field as enum type
inline kafka_ResourceTypeEnum kafka::value_GetEnum(const kafka::ResourceType& parent) {
    return kafka_ResourceTypeEnum(parent.value);
}

// --- kafka.ResourceType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::ResourceType& parent, kafka_ResourceTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.ResourceType..Hash
inline u32 kafka::ResourceType_Hash(u32 prev, const kafka::ResourceType& rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- kafka.ResourceType..EqOp
inline bool kafka::ResourceType::operator ==(const kafka::ResourceType &rhs) const {
    return kafka::ResourceType_Eq(const_cast<kafka::ResourceType&>(*this),const_cast<kafka::ResourceType&>(rhs));
}

// --- kafka.ResourceType..NeOp
inline bool kafka::ResourceType::operator !=(const kafka::ResourceType &rhs) const {
    return !kafka::ResourceType_Eq(const_cast<kafka::ResourceType&>(*this),const_cast<kafka::ResourceType&>(rhs));
}

// --- kafka.ResourceType..Cmp
inline i32 kafka::ResourceType_Cmp(kafka::ResourceType& lhs, kafka::ResourceType& rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- kafka.ResourceType..Init
// Set all fields to initial values.
inline void kafka::ResourceType_Init(kafka::ResourceType& parent) {
    parent.value = u8(0);
}

// --- kafka.ResourceType..Eq
inline bool kafka::ResourceType_Eq(kafka::ResourceType& lhs, kafka::ResourceType& rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- kafka.ResourceType..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool kafka::ResourceType::operator ==(kafka_ResourceTypeEnum rhs) const {
    return kafka_ResourceTypeEnum(value) == rhs;
}

// --- kafka.ResourceType..Ctor
inline  kafka::ResourceType::ResourceType() {
    kafka::ResourceType_Init(*this);
}

// --- kafka.ResourceType..FieldwiseCtor
inline  kafka::ResourceType::ResourceType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.ResourceType..EnumCtor
inline  kafka::ResourceType::ResourceType(kafka_ResourceTypeEnum arg) {
    this->value = u8(arg);
}

// --- kafka.TimestampType.value.GetEnum
// Get value of field as enum type
inline kafka_TimestampTypeEnum kafka::value_GetEnum(const kafka::TimestampType& parent) {
    return kafka_TimestampTypeEnum(parent.value);
}

// --- kafka.TimestampType.value.SetEnum
// Set value of field from enum type.
inline void kafka::value_SetEnum(kafka::TimestampType& parent, kafka_TimestampTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- kafka.TimestampType..Init
// Set all fields to initial values.
inline void kafka::TimestampType_Init(kafka::TimestampType& parent) {
    parent.value = u8(0);
}

// --- kafka.TimestampType..Ctor
inline  kafka::TimestampType::TimestampType() {
    kafka::TimestampType_Init(*this);
}

// --- kafka.TimestampType..FieldwiseCtor
inline  kafka::TimestampType::TimestampType(u8 in_value)
    : value(in_value)
 {
}

// --- kafka.TimestampType..EnumCtor
inline  kafka::TimestampType::TimestampType(kafka_TimestampTypeEnum arg) {
    this->value = u8(arg);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::AclOperationType &row) {// cfmt:kafka.AclOperationType.String
    kafka::AclOperationType_Print(const_cast<kafka::AclOperationType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::AclOperations &row) {// cfmt:kafka.AclOperations.String
    kafka::AclOperations_Print(const_cast<kafka::AclOperations&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::AclPermissionType &row) {// cfmt:kafka.AclPermissionType.String
    kafka::AclPermissionType_Print(const_cast<kafka::AclPermissionType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::CompressionType &row) {// cfmt:kafka.CompressionType.String
    kafka::CompressionType_Print(const_cast<kafka::CompressionType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::ConfigSource &row) {// cfmt:kafka.ConfigSource.String
    kafka::ConfigSource_Print(const_cast<kafka::ConfigSource&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::ConfigType &row) {// cfmt:kafka.ConfigType.String
    kafka::ConfigType_Print(const_cast<kafka::ConfigType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::Error &row) {// cfmt:kafka.Error.String
    kafka::Error_Print(const_cast<kafka::Error&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::FieldId &row) {// cfmt:kafka.FieldId.String
    kafka::FieldId_Print(const_cast<kafka::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::GroupState &row) {// cfmt:kafka.GroupState.String
    kafka::GroupState_Print(const_cast<kafka::GroupState&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::Header &row) {// cfmt:kafka.Header.String
    kafka::Header_Print(const_cast<kafka::Header&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::OffsetCommitKey &row) {// cfmt:kafka.OffsetCommitKey.String
    kafka::OffsetCommitKey_Print(const_cast<kafka::OffsetCommitKey&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::OffsetCommitValue &row) {// cfmt:kafka.OffsetCommitValue.String
    kafka::OffsetCommitValue_Print(const_cast<kafka::OffsetCommitValue&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::PatternType &row) {// cfmt:kafka.PatternType.String
    kafka::PatternType_Print(const_cast<kafka::PatternType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::Record &row) {// cfmt:kafka.Record.String
    kafka::Record_Print(const_cast<kafka::Record&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::RecordBatch &row) {// cfmt:kafka.RecordBatch.String
    kafka::RecordBatch_Print(const_cast<kafka::RecordBatch&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::ResourceType &row) {// cfmt:kafka.ResourceType.String
    kafka::ResourceType_Print(const_cast<kafka::ResourceType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const kafka::TimestampType &row) {// cfmt:kafka.TimestampType.String
    kafka::TimestampType_Print(const_cast<kafka::TimestampType&>(row), str);
    return str;
}
