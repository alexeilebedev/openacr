//
// include/gen/amc_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/amcdb_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/dev_gen.inl.h"
//#pragma endinclude
static amc::FTclass &amc_tclass_Alias      = ((amc::FTclass*)amc::_db.tclass_data)[0];
static amc::FTclass &amc_tclass_Atree      = ((amc::FTclass*)amc::_db.tclass_data)[1];
static amc::FTclass &amc_tclass_Base       = ((amc::FTclass*)amc::_db.tclass_data)[2];
static amc::FTclass &amc_tclass_Bheap      = ((amc::FTclass*)amc::_db.tclass_data)[3];
static amc::FTclass &amc_tclass_Bitfld     = ((amc::FTclass*)amc::_db.tclass_data)[4];
static amc::FTclass &amc_tclass_Bitset     = ((amc::FTclass*)amc::_db.tclass_data)[5];
static amc::FTclass &amc_tclass_Blkpool    = ((amc::FTclass*)amc::_db.tclass_data)[6];
static amc::FTclass &amc_tclass_Charset    = ((amc::FTclass*)amc::_db.tclass_data)[7];
static amc::FTclass &amc_tclass_Cmp        = ((amc::FTclass*)amc::_db.tclass_data)[8];
static amc::FTclass &amc_tclass_Count      = ((amc::FTclass*)amc::_db.tclass_data)[9];
static amc::FTclass &amc_tclass_Cppfunc    = ((amc::FTclass*)amc::_db.tclass_data)[10];
static amc::FTclass &amc_tclass_Cppstack   = ((amc::FTclass*)amc::_db.tclass_data)[11];
static amc::FTclass &amc_tclass_Ctype      = ((amc::FTclass*)amc::_db.tclass_data)[12];
static amc::FTclass &amc_tclass_Dec        = ((amc::FTclass*)amc::_db.tclass_data)[13];
static amc::FTclass &amc_tclass_Delptr     = ((amc::FTclass*)amc::_db.tclass_data)[14];
static amc::FTclass &amc_tclass_Exec       = ((amc::FTclass*)amc::_db.tclass_data)[15];
static amc::FTclass &amc_tclass_Fbuf       = ((amc::FTclass*)amc::_db.tclass_data)[16];
static amc::FTclass &amc_tclass_Fcast      = ((amc::FTclass*)amc::_db.tclass_data)[17];
static amc::FTclass &amc_tclass_Fconst     = ((amc::FTclass*)amc::_db.tclass_data)[18];
static amc::FTclass &amc_tclass_Field      = ((amc::FTclass*)amc::_db.tclass_data)[19];
static amc::FTclass &amc_tclass_Field2     = ((amc::FTclass*)amc::_db.tclass_data)[20];
static amc::FTclass &amc_tclass_Global     = ((amc::FTclass*)amc::_db.tclass_data)[21];
static amc::FTclass &amc_tclass_Hook       = ((amc::FTclass*)amc::_db.tclass_data)[22];
static amc::FTclass &amc_tclass_Inlary     = ((amc::FTclass*)amc::_db.tclass_data)[23];
static amc::FTclass &amc_tclass_Io         = ((amc::FTclass*)amc::_db.tclass_data)[24];
static amc::FTclass &amc_tclass_Lary       = ((amc::FTclass*)amc::_db.tclass_data)[25];
static amc::FTclass &amc_tclass_Llist      = ((amc::FTclass*)amc::_db.tclass_data)[26];
static amc::FTclass &amc_tclass_Lpool      = ((amc::FTclass*)amc::_db.tclass_data)[27];
static amc::FTclass &amc_tclass_Malloc     = ((amc::FTclass*)amc::_db.tclass_data)[28];
static amc::FTclass &amc_tclass_Numstr     = ((amc::FTclass*)amc::_db.tclass_data)[29];
static amc::FTclass &amc_tclass_Opt        = ((amc::FTclass*)amc::_db.tclass_data)[30];
static amc::FTclass &amc_tclass_Pkey       = ((amc::FTclass*)amc::_db.tclass_data)[31];
static amc::FTclass &amc_tclass_Pmask      = ((amc::FTclass*)amc::_db.tclass_data)[32];
static amc::FTclass &amc_tclass_Pool       = ((amc::FTclass*)amc::_db.tclass_data)[33];
static amc::FTclass &amc_tclass_Protocol   = ((amc::FTclass*)amc::_db.tclass_data)[34];
static amc::FTclass &amc_tclass_Ptr        = ((amc::FTclass*)amc::_db.tclass_data)[35];
static amc::FTclass &amc_tclass_Ptrary     = ((amc::FTclass*)amc::_db.tclass_data)[36];
static amc::FTclass &amc_tclass_Regx       = ((amc::FTclass*)amc::_db.tclass_data)[37];
static amc::FTclass &amc_tclass_RegxSql    = ((amc::FTclass*)amc::_db.tclass_data)[38];
static amc::FTclass &amc_tclass_Sbrk       = ((amc::FTclass*)amc::_db.tclass_data)[39];
static amc::FTclass &amc_tclass_Smallstr   = ((amc::FTclass*)amc::_db.tclass_data)[40];
static amc::FTclass &amc_tclass_Sort       = ((amc::FTclass*)amc::_db.tclass_data)[41];
static amc::FTclass &amc_tclass_Step       = ((amc::FTclass*)amc::_db.tclass_data)[42];
static amc::FTclass &amc_tclass_Substr     = ((amc::FTclass*)amc::_db.tclass_data)[43];
static amc::FTclass &amc_tclass_Tary       = ((amc::FTclass*)amc::_db.tclass_data)[44];
static amc::FTclass &amc_tclass_Thash      = ((amc::FTclass*)amc::_db.tclass_data)[45];
static amc::FTclass &amc_tclass_Tpool      = ((amc::FTclass*)amc::_db.tclass_data)[46];
static amc::FTclass &amc_tclass_Upptr      = ((amc::FTclass*)amc::_db.tclass_data)[47];
static amc::FTclass &amc_tclass_Val        = ((amc::FTclass*)amc::_db.tclass_data)[48];
static amc::FTclass &amc_tclass_Varlen     = ((amc::FTclass*)amc::_db.tclass_data)[49];
static amc::FTclass &amc_tclass_ZSListMT   = ((amc::FTclass*)amc::_db.tclass_data)[50];
inline amc::BltinId::BltinId(u8                             in_value)
    : value(in_value)
{
}
inline amc::BltinId::BltinId(amc_BltinIdEnum arg) { this->value = u8(arg); }
inline amc::BltinId::BltinId() {
    amc::BltinId_Init(*this);
}


// --- amc.BltinId.value.GetEnum
// Get value of field as enum type
inline amc_BltinIdEnum amc::value_GetEnum(const amc::BltinId& parent) {
    return amc_BltinIdEnum(parent.value);
}

// --- amc.BltinId.value.SetEnum
// Set value of field from enum type.
inline void amc::value_SetEnum(amc::BltinId& parent, amc_BltinIdEnum rhs) {
    parent.value = u8(rhs);
}

// --- amc.BltinId.value.Cast
inline amc::BltinId::operator amc_BltinIdEnum () const {
    return amc_BltinIdEnum((*this).value);
}

// --- amc.BltinId..Init
// Set all fields to initial values.
inline void amc::BltinId_Init(amc::BltinId& parent) {
    parent.value = u8(0);
}
inline amc::CppkeywordId::CppkeywordId() {
    amc::CppkeywordId_Init(*this);
}


// --- amc.CppkeywordId.id.GetEnum
// Get value of field as enum type
inline amc_CppkeywordIdEnum amc::id_GetEnum(const amc::CppkeywordId& parent) {
    return amc_CppkeywordIdEnum(parent.id);
}

// --- amc.CppkeywordId.id.SetEnum
// Set value of field from enum type.
inline void amc::id_SetEnum(amc::CppkeywordId& parent, amc_CppkeywordIdEnum rhs) {
    parent.id = u32(rhs);
}

// --- amc.CppkeywordId..Init
// Set all fields to initial values.
inline void amc::CppkeywordId_Init(amc::CppkeywordId& parent) {
    parent.id = u32(0);
}
inline amc::Enumstr::Enumstr(i32                            in_len
        ,const algo::strptr&            in_str)
    : len(in_len)
    , str(in_str)
{
}

inline bool amc::Enumstr::operator ==(const amc::Enumstr &rhs) const {
    return amc::Enumstr_Eq(const_cast<amc::Enumstr&>(*this),const_cast<amc::Enumstr&>(rhs));
}

inline bool amc::Enumstr::operator !=(const amc::Enumstr &rhs) const {
    return !amc::Enumstr_Eq(const_cast<amc::Enumstr&>(*this),const_cast<amc::Enumstr&>(rhs));
}

inline bool amc::Enumstr::operator <(const amc::Enumstr &rhs) const {
    return amc::Enumstr_Lt(const_cast<amc::Enumstr&>(*this),const_cast<amc::Enumstr&>(rhs));
}

inline bool amc::Enumstr::operator >(const amc::Enumstr &rhs) const {
    return rhs < *this;
}

inline bool amc::Enumstr::operator <=(const amc::Enumstr &rhs) const {
    return !(rhs < *this);
}

inline bool amc::Enumstr::operator >=(const amc::Enumstr &rhs) const {
    return !(*this < rhs);
}
inline amc::Enumstr::Enumstr() {
    amc::Enumstr_Init(*this);
}


// --- amc.Enumstr.str.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool amc::str_Lt(amc::Enumstr& parent, amc::Enumstr &rhs) {
    return algo::RnullStr8_Lt(parent.str,rhs.str);
}

// --- amc.Enumstr.str.Cmp
// Compare two fields.
inline i32 amc::str_Cmp(amc::Enumstr& parent, amc::Enumstr &rhs) {
    i32 retval = 0;
    retval = algo::RnullStr8_Cmp(parent.str, rhs.str);
    return retval;
}

// --- amc.Enumstr..Hash
inline u32 amc::Enumstr_Hash(u32 prev, const amc::Enumstr & rhs) {
    prev = i32_Hash(prev, rhs.len);
    prev = RnullStr8_Hash(prev, rhs.str);
    return prev;
}

// --- amc.Enumstr..Lt
inline bool amc::Enumstr_Lt(amc::Enumstr & lhs, amc::Enumstr & rhs) {
    return Enumstr_Cmp(lhs,rhs) < 0;
}

// --- amc.Enumstr..Cmp
inline i32 amc::Enumstr_Cmp(amc::Enumstr & lhs, amc::Enumstr & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.len, rhs.len);
    if (retval != 0) {
        return retval;
    }
    retval = str_Cmp(lhs,rhs);
    return retval;
}

// --- amc.Enumstr..Init
// Set all fields to initial values.
inline void amc::Enumstr_Init(amc::Enumstr& parent) {
    parent.len = i32(0);
}

// --- amc.Enumstr..Eq
inline bool amc::Enumstr_Eq(const amc::Enumstr & lhs,const amc::Enumstr & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.len, rhs.len);
    if (!retval) {
        return false;
    }
    retval = algo::RnullStr8_Eq(lhs.str, rhs.str);
    return retval;
}

// --- amc.Enumstr..Update
// Set value. Return true if new value is different from old value.
inline bool amc::Enumstr_Update(amc::Enumstr &lhs, amc::Enumstr & rhs) {
    bool ret = !Enumstr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline amc::FAnonfld::FAnonfld() {
    amc::FAnonfld_Init(*this);
}

inline amc::FAnonfld::~FAnonfld() {
    amc::FAnonfld_Uninit(*this);
}


// --- amc.FAnonfld..Init
// Set all fields to initial values.
inline void amc::FAnonfld_Init(amc::FAnonfld& anonfld) {
    anonfld.anon_idx = i32(0);
}
inline amc::FArgvtype::FArgvtype() {
}

inline amc::FArgvtype::~FArgvtype() {
    amc::FArgvtype_Uninit(*this);
}

inline amc::FBasepool::FBasepool() {
    amc::FBasepool_Init(*this);
}

inline amc::FBasepool::~FBasepool() {
    amc::FBasepool_Uninit(*this);
}


// --- amc.FBasepool..Init
// Set all fields to initial values.
inline void amc::FBasepool_Init(amc::FBasepool& basepool) {
    basepool.p_field = NULL;
    basepool.p_base = NULL;
}
inline amc::FBitfld::FBitfld() {
    amc::FBitfld_Init(*this);
}

inline amc::FBitfld::~FBitfld() {
    amc::FBitfld_Uninit(*this);
}


// --- amc.FBitfld..Init
// Set all fields to initial values.
inline void amc::FBitfld_Init(amc::FBitfld& bitfld) {
    bitfld.offset = i32(0);
    bitfld.width = i32(0);
    bitfld.p_srcfield = NULL;
    bitfld.p_field = NULL;
    bitfld.bh_bitfld_idx = -1; // (amc.FField.bh_bitfld) not-in-heap
}
inline amc::FBltin::FBltin() {
    amc::FBltin_Init(*this);
}

inline amc::FBltin::~FBltin() {
    amc::FBltin_Uninit(*this);
}


// --- amc.FBltin..Init
// Set all fields to initial values.
inline void amc::FBltin_Init(amc::FBltin& bltin) {
    bltin.likeu64 = bool(false);
    bltin.bigendok = bool(false);
    bltin.issigned = bool(false);
    bltin.ind_bltin_next = (amc::FBltin*)-1; // (amc.FDb.ind_bltin) not-in-hash
}
inline amc::FCafter::FCafter() {
    amc::FCafter_Init(*this);
}

inline amc::FCafter::~FCafter() {
    amc::FCafter_Uninit(*this);
}


// --- amc.FCafter..Init
// Set all fields to initial values.
inline void amc::FCafter_Init(amc::FCafter& cafter) {
    cafter.p_after = NULL;
    cafter.zd_cafter_next = (amc::FCafter*)-1; // (amc.FCtype.zd_cafter) not-in-list
    cafter.zd_cafter_prev = NULL; // (amc.FCtype.zd_cafter)
}
inline amc::FCascdel::FCascdel() {
    amc::FCascdel_Init(*this);
}

inline amc::FCascdel::~FCascdel() {
    amc::FCascdel_Uninit(*this);
}


// --- amc.FCascdel..Init
// Set all fields to initial values.
inline void amc::FCascdel_Init(amc::FCascdel& cascdel) {
    cascdel.p_field = NULL;
}
inline amc::FCcmp::FCcmp() {
    amc::FCcmp_Init(*this);
}

inline amc::FCcmp::~FCcmp() {
    amc::FCcmp_Uninit(*this);
}


// --- amc.FCcmp..Init
// Set all fields to initial values.
inline void amc::FCcmp_Init(amc::FCcmp& ccmp) {
    ccmp.extrn = bool(false);
    ccmp.genop = bool(false);
    ccmp.order = bool(false);
    ccmp.minmax = bool(false);
    ccmp.ind_ccmp_next = (amc::FCcmp*)-1; // (amc.FDb.ind_ccmp) not-in-hash
}
inline amc::FCdflt::FCdflt() {
}

inline amc::FCdflt::~FCdflt() {
    amc::FCdflt_Uninit(*this);
}

inline amc::FCextern::FCextern() {
    amc::FCextern_Init(*this);
}

inline amc::FCextern::~FCextern() {
    amc::FCextern_Uninit(*this);
}


// --- amc.FCextern..Init
// Set all fields to initial values.
inline void amc::FCextern_Init(amc::FCextern& cextern) {
    cextern.initmemset = bool(false);
    cextern.isstruct = bool(false);
}
inline amc::FCfmt::FCfmt() {
    amc::FCfmt_Init(*this);
}

inline amc::FCfmt::~FCfmt() {
    amc::FCfmt_Uninit(*this);
}


// --- amc.FCfmt..Init
// Set all fields to initial values.
inline void amc::FCfmt_Init(amc::FCfmt& cfmt) {
    cfmt.read = bool(false);
    cfmt.print = bool(false);
    cfmt.genop = bool(false);
    cfmt.zs_cfmt_next = (amc::FCfmt*)-1; // (amc.FCtype.zs_cfmt) not-in-list
    cfmt.ind_cfmt_next = (amc::FCfmt*)-1; // (amc.FDb.ind_cfmt) not-in-hash
}
inline amc::FCget::FCget() {
    amc::FCget_Init(*this);
}


// --- amc.FCget..Init
// Set all fields to initial values.
inline void amc::FCget_Init(amc::FCget& cget) {
    cget.p_ctype = NULL;
}
inline amc::FCharset::FCharset() {
    amc::FCharset_Init(*this);
}

inline amc::FCharset::~FCharset() {
    amc::FCharset_Uninit(*this);
}


// --- amc.FCharset..Init
// Set all fields to initial values.
inline void amc::FCharset_Init(amc::FCharset& charset) {
    charset.charrange = bool(false);
    charset.calc = bool(false);
}
inline amc::FChash::FChash() {
    amc::FChash_Init(*this);
}

inline amc::FChash::~FChash() {
    amc::FChash_Uninit(*this);
}


// --- amc.FChash..Init
// Set all fields to initial values.
inline void amc::FChash_Init(amc::FChash& chash) {
    chash.ind_chash_next = (amc::FChash*)-1; // (amc.FDb.ind_chash) not-in-hash
}
inline amc::FCppfunc::FCppfunc() {
}

inline amc::FCppfunc::~FCppfunc() {
    amc::FCppfunc_Uninit(*this);
}

inline amc::FCpptype::FCpptype() {
    amc::FCpptype_Init(*this);
}

inline amc::FCpptype::~FCpptype() {
    amc::FCpptype_Uninit(*this);
}


// --- amc.FCpptype..Init
// Set all fields to initial values.
inline void amc::FCpptype_Init(amc::FCpptype& cpptype) {
    cpptype.ctor = bool(false);
    cpptype.dtor = bool(true);
    cpptype.cheap_copy = bool(false);
    cpptype.p_ctype = NULL;
    cpptype.ind_cpptype_next = (amc::FCpptype*)-1; // (amc.FDb.ind_cpptype) not-in-hash
}
inline amc::FCsize::FCsize() {
    amc::FCsize_Init(*this);
}

inline amc::FCsize::~FCsize() {
    amc::FCsize_Uninit(*this);
}


// --- amc.FCsize..Init
// Set all fields to initial values.
inline void amc::FCsize_Init(amc::FCsize& csize) {
    csize.size = u32(0);
    csize.alignment = u32(1);
}
inline amc::FCstr::FCstr() {
    amc::FCstr_Init(*this);
}

inline amc::FCstr::~FCstr() {
    amc::FCstr_Uninit(*this);
}


// --- amc.FCstr..Init
// Set all fields to initial values.
inline void amc::FCstr_Init(amc::FCstr& cstr) {
    cstr.strequiv = bool(false);
}
inline amc::FCtype::FCtype() {
    amc::FCtype_Init(*this);
}

inline amc::FCtype::~FCtype() {
    amc::FCtype_Uninit(*this);
}


// --- amc.FCtype.zs_cfmt.EmptyQ
// Return true if index is empty
inline bool amc::zs_cfmt_EmptyQ(amc::FCtype& ctype) {
    return ctype.zs_cfmt_head == NULL;
}

// --- amc.FCtype.zs_cfmt.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FCfmt* amc::zs_cfmt_First(amc::FCtype& ctype) {
    amc::FCfmt *row = NULL;
    row = ctype.zs_cfmt_head;
    return row;
}

// --- amc.FCtype.zs_cfmt.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_cfmt_InLlistQ(amc::FCfmt& row) {
    bool result = false;
    result = !(row.zs_cfmt_next == (amc::FCfmt*)-1);
    return result;
}

// --- amc.FCtype.zs_cfmt.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FCfmt* amc::zs_cfmt_Last(amc::FCtype& ctype) {
    amc::FCfmt *row = NULL;
    row = ctype.zs_cfmt_tail;
    return row;
}

// --- amc.FCtype.zs_cfmt.Next
// Return pointer to next element in the list
inline amc::FCfmt* amc::zs_cfmt_Next(amc::FCfmt &row) {
    return row.zs_cfmt_next;
}

// --- amc.FCtype.zs_cfmt.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FCfmt& amc::zs_cfmt_qLast(amc::FCtype& ctype) {
    amc::FCfmt *row = NULL;
    row = ctype.zs_cfmt_tail;
    return *row;
}

// --- amc.FCtype.c_bltin.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_bltin_InsertMaybe(amc::FCtype& ctype, amc::FBltin& row) {
    amc::FBltin* ptr = ctype.c_bltin;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_bltin = &row;
    }
    return retval;
}

// --- amc.FCtype.c_bltin.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_bltin_Remove(amc::FCtype& ctype, amc::FBltin& row) {
    amc::FBltin *ptr = ctype.c_bltin;
    if (LIKELY(ptr == &row)) {
        ctype.c_bltin = NULL;
    }
}

// --- amc.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool amc::c_field_EmptyQ(amc::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- amc.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline amc::FField* amc::c_field_Find(amc::FCtype& ctype, u32 t) {
    amc::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- amc.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<amc::FField*> amc::c_field_Getary(amc::FCtype& ctype) {
    return algo::aryptr<amc::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- amc.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 amc::c_field_N(const amc::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- amc.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_field_RemoveAll(amc::FCtype& ctype) {
    ctype.c_field_n = 0;
}

// --- amc.FCtype.c_field.qFind
// Return reference without bounds checking
inline amc::FField& amc::c_field_qFind(amc::FCtype& ctype, u32 idx) {
    return *ctype.c_field_elems[idx];
}

// --- amc.FCtype.c_field.qLast
// Reference to last element without bounds checking
inline amc::FField& amc::c_field_qLast(amc::FCtype& ctype) {
    return *ctype.c_field_elems[ctype.c_field_n-1];
}

// --- amc.FCtype.c_msgtype.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_msgtype_InsertMaybe(amc::FCtype& ctype, amc::FMsgtype& row) {
    amc::FMsgtype* ptr = ctype.c_msgtype;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_msgtype = &row;
    }
    return retval;
}

// --- amc.FCtype.c_msgtype.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_msgtype_Remove(amc::FCtype& ctype, amc::FMsgtype& row) {
    amc::FMsgtype *ptr = ctype.c_msgtype;
    if (LIKELY(ptr == &row)) {
        ctype.c_msgtype = NULL;
    }
}

// --- amc.FCtype.c_varlenfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_varlenfld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) {
    amc::FField* ptr = ctype.c_varlenfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_varlenfld = &row;
    }
    return retval;
}

// --- amc.FCtype.c_varlenfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_varlenfld_Remove(amc::FCtype& ctype, amc::FField& row) {
    amc::FField *ptr = ctype.c_varlenfld;
    if (LIKELY(ptr == &row)) {
        ctype.c_varlenfld = NULL;
    }
}

// --- amc.FCtype.c_optfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_optfld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) {
    amc::FField* ptr = ctype.c_optfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_optfld = &row;
    }
    return retval;
}

// --- amc.FCtype.c_optfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_optfld_Remove(amc::FCtype& ctype, amc::FField& row) {
    amc::FField *ptr = ctype.c_optfld;
    if (LIKELY(ptr == &row)) {
        ctype.c_optfld = NULL;
    }
}

// --- amc.FCtype.c_static.EmptyQ
// Return true if index is empty
inline bool amc::c_static_EmptyQ(amc::FCtype& ctype) {
    return ctype.c_static_n == 0;
}

// --- amc.FCtype.c_static.Find
// Look up row by row id. Return NULL if out of range
inline amc::FStatictuple* amc::c_static_Find(amc::FCtype& ctype, u32 t) {
    amc::FStatictuple *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_static_n;
    if (idx < lim) {
        retval = ctype.c_static_elems[idx];
    }
    return retval;
}

// --- amc.FCtype.c_static.Getary
// Return array of pointers
inline algo::aryptr<amc::FStatictuple*> amc::c_static_Getary(amc::FCtype& ctype) {
    return algo::aryptr<amc::FStatictuple*>(ctype.c_static_elems, ctype.c_static_n);
}

// --- amc.FCtype.c_static.N
// Return number of items in the pointer array
inline i32 amc::c_static_N(const amc::FCtype& ctype) {
    return ctype.c_static_n;
}

// --- amc.FCtype.c_static.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_static_RemoveAll(amc::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_static_n; i++) {
        // mark all elements as not-in-array
        ctype.c_static_elems[i]->ctype_c_static_in_ary = false;
    }
    ctype.c_static_n = 0;
}

// --- amc.FCtype.c_static.qFind
// Return reference without bounds checking
inline amc::FStatictuple& amc::c_static_qFind(amc::FCtype& ctype, u32 idx) {
    return *ctype.c_static_elems[idx];
}

// --- amc.FCtype.c_static.InAryQ
// True if row is in any ptrary instance
inline bool amc::ctype_c_static_InAryQ(amc::FStatictuple& row) {
    return row.ctype_c_static_in_ary;
}

// --- amc.FCtype.c_static.qLast
// Reference to last element without bounds checking
inline amc::FStatictuple& amc::c_static_qLast(amc::FCtype& ctype) {
    return *ctype.c_static_elems[ctype.c_static_n-1];
}

// --- amc.FCtype.c_cpptype.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_cpptype_InsertMaybe(amc::FCtype& ctype, amc::FCpptype& row) {
    amc::FCpptype* ptr = ctype.c_cpptype;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cpptype = &row;
    }
    return retval;
}

// --- amc.FCtype.c_cpptype.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_cpptype_Remove(amc::FCtype& ctype, amc::FCpptype& row) {
    amc::FCpptype *ptr = ctype.c_cpptype;
    if (LIKELY(ptr == &row)) {
        ctype.c_cpptype = NULL;
    }
}

// --- amc.FCtype.c_parent.EmptyQ
// Return true if index is empty
inline bool amc::c_parent_EmptyQ(amc::FCtype& ctype) {
    return ctype.c_parent_n == 0;
}

// --- amc.FCtype.c_parent.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCtype* amc::c_parent_Find(amc::FCtype& ctype, u32 t) {
    amc::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_parent_n;
    if (idx < lim) {
        retval = ctype.c_parent_elems[idx];
    }
    return retval;
}

// --- amc.FCtype.c_parent.Getary
// Return array of pointers
inline algo::aryptr<amc::FCtype*> amc::c_parent_Getary(amc::FCtype& ctype) {
    return algo::aryptr<amc::FCtype*>(ctype.c_parent_elems, ctype.c_parent_n);
}

// --- amc.FCtype.c_parent.N
// Return number of items in the pointer array
inline i32 amc::c_parent_N(const amc::FCtype& ctype) {
    return ctype.c_parent_n;
}

// --- amc.FCtype.c_parent.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_parent_RemoveAll(amc::FCtype& ctype) {
    ctype.c_parent_n = 0;
}

// --- amc.FCtype.c_parent.qFind
// Return reference without bounds checking
inline amc::FCtype& amc::c_parent_qFind(amc::FCtype& ctype, u32 idx) {
    return *ctype.c_parent_elems[idx];
}

// --- amc.FCtype.c_parent.qLast
// Reference to last element without bounds checking
inline amc::FCtype& amc::c_parent_qLast(amc::FCtype& ctype) {
    return *ctype.c_parent_elems[ctype.c_parent_n-1];
}

// --- amc.FCtype.c_ssimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_ssimfile_InsertMaybe(amc::FCtype& ctype, amc::FSsimfile& row) {
    amc::FSsimfile* ptr = ctype.c_ssimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ssimfile = &row;
    }
    return retval;
}

// --- amc.FCtype.c_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_ssimfile_Remove(amc::FCtype& ctype, amc::FSsimfile& row) {
    amc::FSsimfile *ptr = ctype.c_ssimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_ssimfile = NULL;
    }
}

// --- amc.FCtype.c_pack.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_pack_InsertMaybe(amc::FCtype& ctype, amc::FPack& row) {
    amc::FPack* ptr = ctype.c_pack;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_pack = &row;
    }
    return retval;
}

// --- amc.FCtype.c_pack.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_pack_Remove(amc::FCtype& ctype, amc::FPack& row) {
    amc::FPack *ptr = ctype.c_pack;
    if (LIKELY(ptr == &row)) {
        ctype.c_pack = NULL;
    }
}

// --- amc.FCtype.c_lenfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_lenfld_InsertMaybe(amc::FCtype& ctype, amc::FLenfld& row) {
    amc::FLenfld* ptr = ctype.c_lenfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_lenfld = &row;
    }
    return retval;
}

// --- amc.FCtype.c_lenfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_lenfld_Remove(amc::FCtype& ctype, amc::FLenfld& row) {
    amc::FLenfld *ptr = ctype.c_lenfld;
    if (LIKELY(ptr == &row)) {
        ctype.c_lenfld = NULL;
    }
}

// --- amc.FCtype.c_pmaskfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_pmaskfld_InsertMaybe(amc::FCtype& ctype, amc::FPmaskfld& row) {
    amc::FPmaskfld* ptr = ctype.c_pmaskfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_pmaskfld = &row;
    }
    return retval;
}

// --- amc.FCtype.c_pmaskfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_pmaskfld_Remove(amc::FCtype& ctype, amc::FPmaskfld& row) {
    amc::FPmaskfld *ptr = ctype.c_pmaskfld;
    if (LIKELY(ptr == &row)) {
        ctype.c_pmaskfld = NULL;
    }
}

// --- amc.FCtype.c_typefld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_typefld_InsertMaybe(amc::FCtype& ctype, amc::FTypefld& row) {
    amc::FTypefld* ptr = ctype.c_typefld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_typefld = &row;
    }
    return retval;
}

// --- amc.FCtype.c_typefld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_typefld_Remove(amc::FCtype& ctype, amc::FTypefld& row) {
    amc::FTypefld *ptr = ctype.c_typefld;
    if (LIKELY(ptr == &row)) {
        ctype.c_typefld = NULL;
    }
}

// --- amc.FCtype.c_datafld.EmptyQ
// Return true if index is empty
inline bool amc::c_datafld_EmptyQ(amc::FCtype& ctype) {
    return ctype.c_datafld_n == 0;
}

// --- amc.FCtype.c_datafld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FField* amc::c_datafld_Find(amc::FCtype& ctype, u32 t) {
    amc::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_datafld_n;
    if (idx < lim) {
        retval = ctype.c_datafld_elems[idx];
    }
    return retval;
}

// --- amc.FCtype.c_datafld.Getary
// Return array of pointers
inline algo::aryptr<amc::FField*> amc::c_datafld_Getary(amc::FCtype& ctype) {
    return algo::aryptr<amc::FField*>(ctype.c_datafld_elems, ctype.c_datafld_n);
}

// --- amc.FCtype.c_datafld.N
// Return number of items in the pointer array
inline i32 amc::c_datafld_N(const amc::FCtype& ctype) {
    return ctype.c_datafld_n;
}

// --- amc.FCtype.c_datafld.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_datafld_RemoveAll(amc::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_datafld_n; i++) {
        // mark all elements as not-in-array
        ctype.c_datafld_elems[i]->ctype_c_datafld_in_ary = false;
    }
    ctype.c_datafld_n = 0;
}

// --- amc.FCtype.c_datafld.qFind
// Return reference without bounds checking
inline amc::FField& amc::c_datafld_qFind(amc::FCtype& ctype, u32 idx) {
    return *ctype.c_datafld_elems[idx];
}

// --- amc.FCtype.c_datafld.InAryQ
// True if row is in any ptrary instance
inline bool amc::ctype_c_datafld_InAryQ(amc::FField& row) {
    return row.ctype_c_datafld_in_ary;
}

// --- amc.FCtype.c_datafld.qLast
// Reference to last element without bounds checking
inline amc::FField& amc::c_datafld_qLast(amc::FCtype& ctype) {
    return *ctype.c_datafld_elems[ctype.c_datafld_n-1];
}

// --- amc.FCtype.zd_inst.EmptyQ
// Return true if index is empty
inline bool amc::zd_inst_EmptyQ(amc::FCtype& ctype) {
    return ctype.zd_inst_head == NULL;
}

// --- amc.FCtype.zd_inst.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FField* amc::zd_inst_First(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_inst_head;
    return row;
}

// --- amc.FCtype.zd_inst.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zd_inst_InLlistQ(amc::FField& row) {
    bool result = false;
    result = !(row.zd_inst_next == (amc::FField*)-1);
    return result;
}

// --- amc.FCtype.zd_inst.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FField* amc::zd_inst_Last(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_inst_tail;
    return row;
}

// --- amc.FCtype.zd_inst.N
// Return number of items in the linked list
inline i32 amc::zd_inst_N(const amc::FCtype& ctype) {
    return ctype.zd_inst_n;
}

// --- amc.FCtype.zd_inst.Next
// Return pointer to next element in the list
inline amc::FField* amc::zd_inst_Next(amc::FField &row) {
    return row.zd_inst_next;
}

// --- amc.FCtype.zd_inst.Prev
// Return pointer to previous element in the list
inline amc::FField* amc::zd_inst_Prev(amc::FField &row) {
    return row.zd_inst_prev;
}

// --- amc.FCtype.zd_inst.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FField& amc::zd_inst_qLast(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_inst_tail;
    return *row;
}

// --- amc.FCtype.zs_xref.EmptyQ
// Return true if index is empty
inline bool amc::zs_xref_EmptyQ(amc::FCtype& ctype) {
    return ctype.zs_xref_head == NULL;
}

// --- amc.FCtype.zs_xref.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FXref* amc::zs_xref_First(amc::FCtype& ctype) {
    amc::FXref *row = NULL;
    row = ctype.zs_xref_head;
    return row;
}

// --- amc.FCtype.zs_xref.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_xref_InLlistQ(amc::FXref& row) {
    bool result = false;
    result = !(row.zs_xref_next == (amc::FXref*)-1);
    return result;
}

// --- amc.FCtype.zs_xref.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FXref* amc::zs_xref_Last(amc::FCtype& ctype) {
    amc::FXref *row = NULL;
    row = ctype.zs_xref_tail;
    return row;
}

// --- amc.FCtype.zs_xref.N
// Return number of items in the linked list
inline i32 amc::zs_xref_N(const amc::FCtype& ctype) {
    return ctype.zs_xref_n;
}

// --- amc.FCtype.zs_xref.Next
// Return pointer to next element in the list
inline amc::FXref* amc::zs_xref_Next(amc::FXref &row) {
    return row.zs_xref_next;
}

// --- amc.FCtype.zs_xref.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FXref& amc::zs_xref_qLast(amc::FCtype& ctype) {
    amc::FXref *row = NULL;
    row = ctype.zs_xref_tail;
    return *row;
}

// --- amc.FCtype.c_chash.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_chash_InsertMaybe(amc::FCtype& ctype, amc::FChash& row) {
    amc::FChash* ptr = ctype.c_chash;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_chash = &row;
    }
    return retval;
}

// --- amc.FCtype.c_chash.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_chash_Remove(amc::FCtype& ctype, amc::FChash& row) {
    amc::FChash *ptr = ctype.c_chash;
    if (LIKELY(ptr == &row)) {
        ctype.c_chash = NULL;
    }
}

// --- amc.FCtype.c_ccmp.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_ccmp_InsertMaybe(amc::FCtype& ctype, amc::FCcmp& row) {
    amc::FCcmp* ptr = ctype.c_ccmp;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ccmp = &row;
    }
    return retval;
}

// --- amc.FCtype.c_ccmp.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_ccmp_Remove(amc::FCtype& ctype, amc::FCcmp& row) {
    amc::FCcmp *ptr = ctype.c_ccmp;
    if (LIKELY(ptr == &row)) {
        ctype.c_ccmp = NULL;
    }
}

// --- amc.FCtype.c_cstr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_cstr_InsertMaybe(amc::FCtype& ctype, amc::FCstr& row) {
    amc::FCstr* ptr = ctype.c_cstr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cstr = &row;
    }
    return retval;
}

// --- amc.FCtype.c_cstr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_cstr_Remove(amc::FCtype& ctype, amc::FCstr& row) {
    amc::FCstr *ptr = ctype.c_cstr;
    if (LIKELY(ptr == &row)) {
        ctype.c_cstr = NULL;
    }
}

// --- amc.FCtype.c_cextern.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_cextern_InsertMaybe(amc::FCtype& ctype, amc::FCextern& row) {
    amc::FCextern* ptr = ctype.c_cextern;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cextern = &row;
    }
    return retval;
}

// --- amc.FCtype.c_cextern.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_cextern_Remove(amc::FCtype& ctype, amc::FCextern& row) {
    amc::FCextern *ptr = ctype.c_cextern;
    if (LIKELY(ptr == &row)) {
        ctype.c_cextern = NULL;
    }
}

// --- amc.FCtype.c_ffunc.EmptyQ
// Return true if index is empty
inline bool amc::c_ffunc_EmptyQ(amc::FCtype& ctype) {
    return ctype.c_ffunc_n == 0;
}

// --- amc.FCtype.c_ffunc.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFunc* amc::c_ffunc_Find(amc::FCtype& ctype, u32 t) {
    amc::FFunc *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_ffunc_n;
    if (idx < lim) {
        retval = ctype.c_ffunc_elems[idx];
    }
    return retval;
}

// --- amc.FCtype.c_ffunc.Getary
// Return array of pointers
inline algo::aryptr<amc::FFunc*> amc::c_ffunc_Getary(amc::FCtype& ctype) {
    return algo::aryptr<amc::FFunc*>(ctype.c_ffunc_elems, ctype.c_ffunc_n);
}

// --- amc.FCtype.c_ffunc.N
// Return number of items in the pointer array
inline i32 amc::c_ffunc_N(const amc::FCtype& ctype) {
    return ctype.c_ffunc_n;
}

// --- amc.FCtype.c_ffunc.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ffunc_RemoveAll(amc::FCtype& ctype) {
    ctype.c_ffunc_n = 0;
}

// --- amc.FCtype.c_ffunc.qFind
// Return reference without bounds checking
inline amc::FFunc& amc::c_ffunc_qFind(amc::FCtype& ctype, u32 idx) {
    return *ctype.c_ffunc_elems[idx];
}

// --- amc.FCtype.c_ffunc.qLast
// Reference to last element without bounds checking
inline amc::FFunc& amc::c_ffunc_qLast(amc::FCtype& ctype) {
    return *ctype.c_ffunc_elems[ctype.c_ffunc_n-1];
}

// --- amc.FCtype.zd_cafter.EmptyQ
// Return true if index is empty
inline bool amc::zd_cafter_EmptyQ(amc::FCtype& ctype) {
    return ctype.zd_cafter_head == NULL;
}

// --- amc.FCtype.zd_cafter.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FCafter* amc::zd_cafter_First(amc::FCtype& ctype) {
    amc::FCafter *row = NULL;
    row = ctype.zd_cafter_head;
    return row;
}

// --- amc.FCtype.zd_cafter.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zd_cafter_InLlistQ(amc::FCafter& row) {
    bool result = false;
    result = !(row.zd_cafter_next == (amc::FCafter*)-1);
    return result;
}

// --- amc.FCtype.zd_cafter.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FCafter* amc::zd_cafter_Last(amc::FCtype& ctype) {
    amc::FCafter *row = NULL;
    row = ctype.zd_cafter_tail;
    return row;
}

// --- amc.FCtype.zd_cafter.N
// Return number of items in the linked list
inline i32 amc::zd_cafter_N(const amc::FCtype& ctype) {
    return ctype.zd_cafter_n;
}

// --- amc.FCtype.zd_cafter.Next
// Return pointer to next element in the list
inline amc::FCafter* amc::zd_cafter_Next(amc::FCafter &row) {
    return row.zd_cafter_next;
}

// --- amc.FCtype.zd_cafter.Prev
// Return pointer to previous element in the list
inline amc::FCafter* amc::zd_cafter_Prev(amc::FCafter &row) {
    return row.zd_cafter_prev;
}

// --- amc.FCtype.zd_cafter.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FCafter& amc::zd_cafter_qLast(amc::FCtype& ctype) {
    amc::FCafter *row = NULL;
    row = ctype.zd_cafter_tail;
    return *row;
}

// --- amc.FCtype.c_csize.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_csize_InsertMaybe(amc::FCtype& ctype, amc::FCsize& row) {
    amc::FCsize* ptr = ctype.c_csize;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_csize = &row;
    }
    return retval;
}

// --- amc.FCtype.c_csize.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_csize_Remove(amc::FCtype& ctype, amc::FCsize& row) {
    amc::FCsize *ptr = ctype.c_csize;
    if (LIKELY(ptr == &row)) {
        ctype.c_csize = NULL;
    }
}

// --- amc.FCtype.zd_access.EmptyQ
// Return true if index is empty
inline bool amc::zd_access_EmptyQ(amc::FCtype& ctype) {
    return ctype.zd_access_head == NULL;
}

// --- amc.FCtype.zd_access.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FField* amc::zd_access_First(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_access_head;
    return row;
}

// --- amc.FCtype.zd_access.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zd_access_InLlistQ(amc::FField& row) {
    bool result = false;
    result = !(row.zd_access_next == (amc::FField*)-1);
    return result;
}

// --- amc.FCtype.zd_access.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FField* amc::zd_access_Last(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_access_tail;
    return row;
}

// --- amc.FCtype.zd_access.N
// Return number of items in the linked list
inline i32 amc::zd_access_N(const amc::FCtype& ctype) {
    return ctype.zd_access_n;
}

// --- amc.FCtype.zd_access.Next
// Return pointer to next element in the list
inline amc::FField* amc::zd_access_Next(amc::FField &row) {
    return row.zd_access_next;
}

// --- amc.FCtype.zd_access.Prev
// Return pointer to previous element in the list
inline amc::FField* amc::zd_access_Prev(amc::FField &row) {
    return row.zd_access_prev;
}

// --- amc.FCtype.zd_access.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FField& amc::zd_access_qLast(amc::FCtype& ctype) {
    amc::FField *row = NULL;
    row = ctype.zd_access_tail;
    return *row;
}

// --- amc.FCtype.c_cdflt.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_cdflt_InsertMaybe(amc::FCtype& ctype, amc::FCdflt& row) {
    amc::FCdflt* ptr = ctype.c_cdflt;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cdflt = &row;
    }
    return retval;
}

// --- amc.FCtype.c_cdflt.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_cdflt_Remove(amc::FCtype& ctype, amc::FCdflt& row) {
    amc::FCdflt *ptr = ctype.c_cdflt;
    if (LIKELY(ptr == &row)) {
        ctype.c_cdflt = NULL;
    }
}

// --- amc.FCtype.c_argvtype.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_argvtype_InsertMaybe(amc::FCtype& ctype, amc::FArgvtype& row) {
    amc::FArgvtype* ptr = ctype.c_argvtype;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_argvtype = &row;
    }
    return retval;
}

// --- amc.FCtype.c_argvtype.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_argvtype_Remove(amc::FCtype& ctype, amc::FArgvtype& row) {
    amc::FArgvtype *ptr = ctype.c_argvtype;
    if (LIKELY(ptr == &row)) {
        ctype.c_argvtype = NULL;
    }
}

// --- amc.FCtype.c_floadtuples.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_floadtuples_InsertMaybe(amc::FCtype& ctype, amc::FFloadtuples& row) {
    amc::FFloadtuples* ptr = ctype.c_floadtuples;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_floadtuples = &row;
    }
    return retval;
}

// --- amc.FCtype.c_floadtuples.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_floadtuples_Remove(amc::FCtype& ctype, amc::FFloadtuples& row) {
    amc::FFloadtuples *ptr = ctype.c_floadtuples;
    if (LIKELY(ptr == &row)) {
        ctype.c_floadtuples = NULL;
    }
}

// --- amc.FCtype.c_fcurs.EmptyQ
// Return true if index is empty
inline bool amc::c_fcurs_EmptyQ(amc::FCtype& ctype) {
    return ctype.c_fcurs_n == 0;
}

// --- amc.FCtype.c_fcurs.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcurs* amc::c_fcurs_Find(amc::FCtype& ctype, u32 t) {
    amc::FFcurs *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_fcurs_n;
    if (idx < lim) {
        retval = ctype.c_fcurs_elems[idx];
    }
    return retval;
}

// --- amc.FCtype.c_fcurs.Getary
// Return array of pointers
inline algo::aryptr<amc::FFcurs*> amc::c_fcurs_Getary(amc::FCtype& ctype) {
    return algo::aryptr<amc::FFcurs*>(ctype.c_fcurs_elems, ctype.c_fcurs_n);
}

// --- amc.FCtype.c_fcurs.N
// Return number of items in the pointer array
inline i32 amc::c_fcurs_N(const amc::FCtype& ctype) {
    return ctype.c_fcurs_n;
}

// --- amc.FCtype.c_fcurs.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_fcurs_RemoveAll(amc::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_fcurs_n; i++) {
        // mark all elements as not-in-array
        ctype.c_fcurs_elems[i]->ctype_c_fcurs_in_ary = false;
    }
    ctype.c_fcurs_n = 0;
}

// --- amc.FCtype.c_fcurs.qFind
// Return reference without bounds checking
inline amc::FFcurs& amc::c_fcurs_qFind(amc::FCtype& ctype, u32 idx) {
    return *ctype.c_fcurs_elems[idx];
}

// --- amc.FCtype.c_fcurs.InAryQ
// True if row is in any ptrary instance
inline bool amc::ctype_c_fcurs_InAryQ(amc::FFcurs& row) {
    return row.ctype_c_fcurs_in_ary;
}

// --- amc.FCtype.c_fcurs.qLast
// Reference to last element without bounds checking
inline amc::FFcurs& amc::c_fcurs_qLast(amc::FCtype& ctype) {
    return *ctype.c_fcurs_elems[ctype.c_fcurs_n-1];
}

// --- amc.FCtype.c_ctypelen.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_ctypelen_InsertMaybe(amc::FCtype& ctype, amc::FCtypelen& row) {
    amc::FCtypelen* ptr = ctype.c_ctypelen;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ctypelen = &row;
    }
    return retval;
}

// --- amc.FCtype.c_ctypelen.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_ctypelen_Remove(amc::FCtype& ctype, amc::FCtypelen& row) {
    amc::FCtypelen *ptr = ctype.c_ctypelen;
    if (LIKELY(ptr == &row)) {
        ctype.c_ctypelen = NULL;
    }
}

// --- amc.FCtype.c_nossimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_nossimfile_InsertMaybe(amc::FCtype& ctype, amc::FNossimfile& row) {
    amc::FNossimfile* ptr = ctype.c_nossimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_nossimfile = &row;
    }
    return retval;
}

// --- amc.FCtype.c_nossimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_nossimfile_Remove(amc::FCtype& ctype, amc::FNossimfile& row) {
    amc::FNossimfile *ptr = ctype.c_nossimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_nossimfile = NULL;
    }
}

// --- amc.FCtype.zs_cfmt_curs.Reset
// cursor points to valid item
inline void amc::ctype_zs_cfmt_curs_Reset(ctype_zs_cfmt_curs &curs, amc::FCtype &parent) {
    curs.row = parent.zs_cfmt_head;
}

// --- amc.FCtype.zs_cfmt_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_zs_cfmt_curs_ValidQ(ctype_zs_cfmt_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FCtype.zs_cfmt_curs.Next
// proceed to next item
inline void amc::ctype_zs_cfmt_curs_Next(ctype_zs_cfmt_curs &curs) {
    amc::FCfmt *next = (*curs.row).zs_cfmt_next;
    curs.row = next;
}

// --- amc.FCtype.zs_cfmt_curs.Access
// item access
inline amc::FCfmt& amc::ctype_zs_cfmt_curs_Access(ctype_zs_cfmt_curs &curs) {
    return *curs.row;
}

// --- amc.FCtype.c_field_curs.Reset
inline void amc::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, amc::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- amc.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FCtype.c_field_curs.Next
// proceed to next item
inline void amc::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- amc.FCtype.c_field_curs.Access
// item access
inline amc::FField& amc::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FCtype.c_static_curs.Reset
inline void amc::ctype_c_static_curs_Reset(ctype_c_static_curs &curs, amc::FCtype &parent) {
    curs.elems = parent.c_static_elems;
    curs.n_elems = parent.c_static_n;
    curs.index = 0;
}

// --- amc.FCtype.c_static_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_c_static_curs_ValidQ(ctype_c_static_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FCtype.c_static_curs.Next
// proceed to next item
inline void amc::ctype_c_static_curs_Next(ctype_c_static_curs &curs) {
    curs.index++;
}

// --- amc.FCtype.c_static_curs.Access
// item access
inline amc::FStatictuple& amc::ctype_c_static_curs_Access(ctype_c_static_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FCtype.c_parent_curs.Reset
inline void amc::ctype_c_parent_curs_Reset(ctype_c_parent_curs &curs, amc::FCtype &parent) {
    curs.elems = parent.c_parent_elems;
    curs.n_elems = parent.c_parent_n;
    curs.index = 0;
}

// --- amc.FCtype.c_parent_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_c_parent_curs_ValidQ(ctype_c_parent_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FCtype.c_parent_curs.Next
// proceed to next item
inline void amc::ctype_c_parent_curs_Next(ctype_c_parent_curs &curs) {
    curs.index++;
}

// --- amc.FCtype.c_parent_curs.Access
// item access
inline amc::FCtype& amc::ctype_c_parent_curs_Access(ctype_c_parent_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FCtype.c_datafld_curs.Reset
inline void amc::ctype_c_datafld_curs_Reset(ctype_c_datafld_curs &curs, amc::FCtype &parent) {
    curs.elems = parent.c_datafld_elems;
    curs.n_elems = parent.c_datafld_n;
    curs.index = 0;
}

// --- amc.FCtype.c_datafld_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_c_datafld_curs_ValidQ(ctype_c_datafld_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FCtype.c_datafld_curs.Next
// proceed to next item
inline void amc::ctype_c_datafld_curs_Next(ctype_c_datafld_curs &curs) {
    curs.index++;
}

// --- amc.FCtype.c_datafld_curs.Access
// item access
inline amc::FField& amc::ctype_c_datafld_curs_Access(ctype_c_datafld_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FCtype.zd_inst_curs.Reset
// cursor points to valid item
inline void amc::ctype_zd_inst_curs_Reset(ctype_zd_inst_curs &curs, amc::FCtype &parent) {
    curs.row = parent.zd_inst_head;
}

// --- amc.FCtype.zd_inst_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_zd_inst_curs_ValidQ(ctype_zd_inst_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FCtype.zd_inst_curs.Next
// proceed to next item
inline void amc::ctype_zd_inst_curs_Next(ctype_zd_inst_curs &curs) {
    amc::FField *next = (*curs.row).zd_inst_next;
    curs.row = next;
}

// --- amc.FCtype.zd_inst_curs.Access
// item access
inline amc::FField& amc::ctype_zd_inst_curs_Access(ctype_zd_inst_curs &curs) {
    return *curs.row;
}

// --- amc.FCtype.zs_xref_curs.Reset
// cursor points to valid item
inline void amc::ctype_zs_xref_curs_Reset(ctype_zs_xref_curs &curs, amc::FCtype &parent) {
    curs.row = parent.zs_xref_head;
}

// --- amc.FCtype.zs_xref_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_zs_xref_curs_ValidQ(ctype_zs_xref_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FCtype.zs_xref_curs.Next
// proceed to next item
inline void amc::ctype_zs_xref_curs_Next(ctype_zs_xref_curs &curs) {
    amc::FXref *next = (*curs.row).zs_xref_next;
    curs.row = next;
}

// --- amc.FCtype.zs_xref_curs.Access
// item access
inline amc::FXref& amc::ctype_zs_xref_curs_Access(ctype_zs_xref_curs &curs) {
    return *curs.row;
}

// --- amc.FCtype.c_ffunc_curs.Reset
inline void amc::ctype_c_ffunc_curs_Reset(ctype_c_ffunc_curs &curs, amc::FCtype &parent) {
    curs.elems = parent.c_ffunc_elems;
    curs.n_elems = parent.c_ffunc_n;
    curs.index = 0;
}

// --- amc.FCtype.c_ffunc_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_c_ffunc_curs_ValidQ(ctype_c_ffunc_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FCtype.c_ffunc_curs.Next
// proceed to next item
inline void amc::ctype_c_ffunc_curs_Next(ctype_c_ffunc_curs &curs) {
    curs.index++;
}

// --- amc.FCtype.c_ffunc_curs.Access
// item access
inline amc::FFunc& amc::ctype_c_ffunc_curs_Access(ctype_c_ffunc_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FCtype.zd_cafter_curs.Reset
// cursor points to valid item
inline void amc::ctype_zd_cafter_curs_Reset(ctype_zd_cafter_curs &curs, amc::FCtype &parent) {
    curs.row = parent.zd_cafter_head;
}

// --- amc.FCtype.zd_cafter_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_zd_cafter_curs_ValidQ(ctype_zd_cafter_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FCtype.zd_cafter_curs.Next
// proceed to next item
inline void amc::ctype_zd_cafter_curs_Next(ctype_zd_cafter_curs &curs) {
    amc::FCafter *next = (*curs.row).zd_cafter_next;
    curs.row = next;
}

// --- amc.FCtype.zd_cafter_curs.Access
// item access
inline amc::FCafter& amc::ctype_zd_cafter_curs_Access(ctype_zd_cafter_curs &curs) {
    return *curs.row;
}

// --- amc.FCtype.zd_access_curs.Reset
// cursor points to valid item
inline void amc::ctype_zd_access_curs_Reset(ctype_zd_access_curs &curs, amc::FCtype &parent) {
    curs.row = parent.zd_access_head;
}

// --- amc.FCtype.zd_access_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_zd_access_curs_ValidQ(ctype_zd_access_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FCtype.zd_access_curs.Next
// proceed to next item
inline void amc::ctype_zd_access_curs_Next(ctype_zd_access_curs &curs) {
    amc::FField *next = (*curs.row).zd_access_next;
    curs.row = next;
}

// --- amc.FCtype.zd_access_curs.Access
// item access
inline amc::FField& amc::ctype_zd_access_curs_Access(ctype_zd_access_curs &curs) {
    return *curs.row;
}

// --- amc.FCtype.c_fcurs_curs.Reset
inline void amc::ctype_c_fcurs_curs_Reset(ctype_c_fcurs_curs &curs, amc::FCtype &parent) {
    curs.elems = parent.c_fcurs_elems;
    curs.n_elems = parent.c_fcurs_n;
    curs.index = 0;
}

// --- amc.FCtype.c_fcurs_curs.ValidQ
// cursor points to valid item
inline bool amc::ctype_c_fcurs_curs_ValidQ(ctype_c_fcurs_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FCtype.c_fcurs_curs.Next
// proceed to next item
inline void amc::ctype_c_fcurs_curs_Next(ctype_c_fcurs_curs &curs) {
    curs.index++;
}

// --- amc.FCtype.c_fcurs_curs.Access
// item access
inline amc::FFcurs& amc::ctype_c_fcurs_curs_Access(ctype_c_fcurs_curs &curs) {
    return *curs.elems[curs.index];
}
inline amc::FCtypelen::FCtypelen() {
    amc::FCtypelen_Init(*this);
}

inline amc::FCtypelen::~FCtypelen() {
    amc::FCtypelen_Uninit(*this);
}


// --- amc.FCtypelen..Init
// Set all fields to initial values.
inline void amc::FCtypelen_Init(amc::FCtypelen& ctypelen) {
    ctypelen.len = u32(0);
    ctypelen.alignment = i32(0);
    ctypelen.padbytes = i32(0);
    ctypelen._db_c_ctypelen_in_ary = bool(false);
}
inline amc::Genfield::Genfield() {
    amc::Genfield_Init(*this);
}


// --- amc.Genfield..Init
// Set all fields to initial values.
inline void amc::Genfield_Init(amc::Genfield& parent) {
    parent.p_field = NULL;
    parent.p_ctype = NULL;
    parent.p_tfunc = NULL;
}
inline amc::FTclass::FTclass() {
    amc::FTclass_Init(*this);
}

inline amc::FTclass::~FTclass() {
    amc::FTclass_Uninit(*this);
}


// --- amc.FTclass.c_tfunc.EmptyQ
// Return true if index is empty
inline bool amc::c_tfunc_EmptyQ(amc::FTclass& tclass) {
    return tclass.c_tfunc_n == 0;
}

// --- amc.FTclass.c_tfunc.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTfunc* amc::c_tfunc_Find(amc::FTclass& tclass, u32 t) {
    amc::FTfunc *retval = NULL;
    u64 idx = t;
    u64 lim = tclass.c_tfunc_n;
    if (idx < lim) {
        retval = tclass.c_tfunc_elems[idx];
    }
    return retval;
}

// --- amc.FTclass.c_tfunc.Getary
// Return array of pointers
inline algo::aryptr<amc::FTfunc*> amc::c_tfunc_Getary(amc::FTclass& tclass) {
    return algo::aryptr<amc::FTfunc*>(tclass.c_tfunc_elems, tclass.c_tfunc_n);
}

// --- amc.FTclass.c_tfunc.N
// Return number of items in the pointer array
inline i32 amc::c_tfunc_N(const amc::FTclass& tclass) {
    return tclass.c_tfunc_n;
}

// --- amc.FTclass.c_tfunc.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_tfunc_RemoveAll(amc::FTclass& tclass) {
    for (u32 i = 0; i < tclass.c_tfunc_n; i++) {
        // mark all elements as not-in-array
        tclass.c_tfunc_elems[i]->tclass_c_tfunc_in_ary = false;
    }
    tclass.c_tfunc_n = 0;
}

// --- amc.FTclass.c_tfunc.qFind
// Return reference without bounds checking
inline amc::FTfunc& amc::c_tfunc_qFind(amc::FTclass& tclass, u32 idx) {
    return *tclass.c_tfunc_elems[idx];
}

// --- amc.FTclass.c_tfunc.InAryQ
// True if row is in any ptrary instance
inline bool amc::tclass_c_tfunc_InAryQ(amc::FTfunc& row) {
    return row.tclass_c_tfunc_in_ary;
}

// --- amc.FTclass.c_tfunc.qLast
// Reference to last element without bounds checking
inline amc::FTfunc& amc::c_tfunc_qLast(amc::FTclass& tclass) {
    return *tclass.c_tfunc_elems[tclass.c_tfunc_n-1];
}

// --- amc.FTclass.step.Call
// Invoke function by pointer
inline void amc::step_Call(amc::FTclass& tclass) {
    tclass.step();
}

// --- amc.FTclass.c_tfunc_curs.Reset
inline void amc::tclass_c_tfunc_curs_Reset(tclass_c_tfunc_curs &curs, amc::FTclass &parent) {
    curs.elems = parent.c_tfunc_elems;
    curs.n_elems = parent.c_tfunc_n;
    curs.index = 0;
}

// --- amc.FTclass.c_tfunc_curs.ValidQ
// cursor points to valid item
inline bool amc::tclass_c_tfunc_curs_ValidQ(tclass_c_tfunc_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FTclass.c_tfunc_curs.Next
// proceed to next item
inline void amc::tclass_c_tfunc_curs_Next(tclass_c_tfunc_curs &curs) {
    curs.index++;
}

// --- amc.FTclass.c_tfunc_curs.Access
// item access
inline amc::FTfunc& amc::tclass_c_tfunc_curs_Access(tclass_c_tfunc_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FTclass..Init
// Set all fields to initial values.
inline void amc::FTclass_Init(amc::FTclass& tclass) {
    tclass.c_tfunc_elems = NULL; // (amc.FTclass.c_tfunc)
    tclass.c_tfunc_n = 0; // (amc.FTclass.c_tfunc)
    tclass.c_tfunc_max = 0; // (amc.FTclass.c_tfunc)
    tclass.step = NULL;
    tclass.ind_tclass_next = (amc::FTclass*)-1; // (amc.FDb.ind_tclass) not-in-hash
}
inline amc::trace::trace() {
}


// --- amc.FDb.fsort.EmptyQ
// Return true if index is empty
inline bool amc::fsort_EmptyQ() {
    return _db.fsort_n == 0;
}

// --- amc.FDb.fsort.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFsort* amc::fsort_Find(u64 t) {
    amc::FFsort *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fsort_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fsort_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fsort.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFsort* amc::fsort_Last() {
    return fsort_Find(u64(_db.fsort_n-1));
}

// --- amc.FDb.fsort.N
// Return number of items in the pool
inline i32 amc::fsort_N() {
    return _db.fsort_n;
}

// --- amc.FDb.fsort.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFsort& amc::fsort_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fsort_lary[bsr][index];
}

// --- amc.FDb.ind_cfmt.EmptyQ
// Return true if hash is empty
inline bool amc::ind_cfmt_EmptyQ() {
    return _db.ind_cfmt_n == 0;
}

// --- amc.FDb.ind_cfmt.N
// Return number of items in the hash
inline i32 amc::ind_cfmt_N() {
    return _db.ind_cfmt_n;
}

// --- amc.FDb.dispfilter.EmptyQ
// Return true if index is empty
inline bool amc::dispfilter_EmptyQ() {
    return _db.dispfilter_n == 0;
}

// --- amc.FDb.dispfilter.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispfilter* amc::dispfilter_Find(u64 t) {
    amc::FDispfilter *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispfilter_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispfilter_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.dispfilter.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FDispfilter* amc::dispfilter_Last() {
    return dispfilter_Find(u64(_db.dispfilter_n-1));
}

// --- amc.FDb.dispfilter.N
// Return number of items in the pool
inline i32 amc::dispfilter_N() {
    return _db.dispfilter_n;
}

// --- amc.FDb.dispfilter.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FDispfilter& amc::dispfilter_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispfilter_lary[bsr][index];
}

// --- amc.FDb.usertracefld.EmptyQ
// Return true if index is empty
inline bool amc::usertracefld_EmptyQ() {
    return _db.usertracefld_n == 0;
}

// --- amc.FDb.usertracefld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FUsertracefld* amc::usertracefld_Find(u64 t) {
    amc::FUsertracefld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.usertracefld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.usertracefld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.usertracefld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FUsertracefld* amc::usertracefld_Last() {
    return usertracefld_Find(u64(_db.usertracefld_n-1));
}

// --- amc.FDb.usertracefld.N
// Return number of items in the pool
inline i32 amc::usertracefld_N() {
    return _db.usertracefld_n;
}

// --- amc.FDb.usertracefld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FUsertracefld& amc::usertracefld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.usertracefld_lary[bsr][index];
}

// --- amc.FDb.cfmt.EmptyQ
// Return true if index is empty
inline bool amc::cfmt_EmptyQ() {
    return _db.cfmt_n == 0;
}

// --- amc.FDb.cfmt.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCfmt* amc::cfmt_Find(u64 t) {
    amc::FCfmt *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cfmt_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cfmt_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cfmt.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCfmt* amc::cfmt_Last() {
    return cfmt_Find(u64(_db.cfmt_n-1));
}

// --- amc.FDb.cfmt.N
// Return number of items in the pool
inline i32 amc::cfmt_N() {
    return _db.cfmt_n;
}

// --- amc.FDb.cfmt.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCfmt& amc::cfmt_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cfmt_lary[bsr][index];
}

// --- amc.FDb.dispatch.EmptyQ
// Return true if index is empty
inline bool amc::dispatch_EmptyQ() {
    return _db.dispatch_n == 0;
}

// --- amc.FDb.dispatch.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispatch* amc::dispatch_Find(u64 t) {
    amc::FDispatch *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispatch_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispatch_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.dispatch.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FDispatch* amc::dispatch_Last() {
    return dispatch_Find(u64(_db.dispatch_n-1));
}

// --- amc.FDb.dispatch.N
// Return number of items in the pool
inline i32 amc::dispatch_N() {
    return _db.dispatch_n;
}

// --- amc.FDb.dispatch.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FDispatch& amc::dispatch_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispatch_lary[bsr][index];
}

// --- amc.FDb.dispatch_msg.EmptyQ
// Return true if index is empty
inline bool amc::dispatch_msg_EmptyQ() {
    return _db.dispatch_msg_n == 0;
}

// --- amc.FDb.dispatch_msg.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispatchmsg* amc::dispatch_msg_Find(u64 t) {
    amc::FDispatchmsg *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispatch_msg_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispatch_msg_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.dispatch_msg.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FDispatchmsg* amc::dispatch_msg_Last() {
    return dispatch_msg_Find(u64(_db.dispatch_msg_n-1));
}

// --- amc.FDb.dispatch_msg.N
// Return number of items in the pool
inline i32 amc::dispatch_msg_N() {
    return _db.dispatch_msg_n;
}

// --- amc.FDb.dispatch_msg.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FDispatchmsg& amc::dispatch_msg_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispatch_msg_lary[bsr][index];
}

// --- amc.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool amc::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- amc.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCtype* amc::ctype_Find(u64 t) {
    amc::FCtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ctype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCtype* amc::ctype_Last() {
    return ctype_Find(u64(_db.ctype_n-1));
}

// --- amc.FDb.ctype.N
// Return number of items in the pool
inline i32 amc::ctype_N() {
    return _db.ctype_n;
}

// --- amc.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCtype& amc::ctype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- amc.FDb.field.EmptyQ
// Return true if index is empty
inline bool amc::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- amc.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline amc::FField* amc::field_Find(u64 t) {
    amc::FField *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.field_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FField* amc::field_Last() {
    return field_Find(u64(_db.field_n-1));
}

// --- amc.FDb.field.N
// Return number of items in the pool
inline i32 amc::field_N() {
    return _db.field_n;
}

// --- amc.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FField& amc::field_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- amc.FDb.basepool.EmptyQ
// Return true if index is empty
inline bool amc::basepool_EmptyQ() {
    return _db.basepool_n == 0;
}

// --- amc.FDb.basepool.Find
// Look up row by row id. Return NULL if out of range
inline amc::FBasepool* amc::basepool_Find(u64 t) {
    amc::FBasepool *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.basepool_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.basepool_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.basepool.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FBasepool* amc::basepool_Last() {
    return basepool_Find(u64(_db.basepool_n-1));
}

// --- amc.FDb.basepool.N
// Return number of items in the pool
inline i32 amc::basepool_N() {
    return _db.basepool_n;
}

// --- amc.FDb.basepool.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FBasepool& amc::basepool_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.basepool_lary[bsr][index];
}

// --- amc.FDb.llist.EmptyQ
// Return true if index is empty
inline bool amc::llist_EmptyQ() {
    return _db.llist_n == 0;
}

// --- amc.FDb.llist.Find
// Look up row by row id. Return NULL if out of range
inline amc::FLlist* amc::llist_Find(u64 t) {
    amc::FLlist *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.llist_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.llist_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.llist.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FLlist* amc::llist_Last() {
    return llist_Find(u64(_db.llist_n-1));
}

// --- amc.FDb.llist.N
// Return number of items in the pool
inline i32 amc::llist_N() {
    return _db.llist_n;
}

// --- amc.FDb.llist.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FLlist& amc::llist_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.llist_lary[bsr][index];
}

// --- amc.FDb.anonfld.EmptyQ
// Return true if index is empty
inline bool amc::anonfld_EmptyQ() {
    return _db.anonfld_n == 0;
}

// --- amc.FDb.anonfld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FAnonfld* amc::anonfld_Find(u64 t) {
    amc::FAnonfld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.anonfld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.anonfld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.anonfld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FAnonfld* amc::anonfld_Last() {
    return anonfld_Find(u64(_db.anonfld_n-1));
}

// --- amc.FDb.anonfld.N
// Return number of items in the pool
inline i32 amc::anonfld_N() {
    return _db.anonfld_n;
}

// --- amc.FDb.anonfld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FAnonfld& amc::anonfld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.anonfld_lary[bsr][index];
}

// --- amc.FDb.xref.EmptyQ
// Return true if index is empty
inline bool amc::xref_EmptyQ() {
    return _db.xref_n == 0;
}

// --- amc.FDb.xref.Find
// Look up row by row id. Return NULL if out of range
inline amc::FXref* amc::xref_Find(u64 t) {
    amc::FXref *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.xref_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.xref_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.xref.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FXref* amc::xref_Last() {
    return xref_Find(u64(_db.xref_n-1));
}

// --- amc.FDb.xref.N
// Return number of items in the pool
inline i32 amc::xref_N() {
    return _db.xref_n;
}

// --- amc.FDb.xref.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FXref& amc::xref_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.xref_lary[bsr][index];
}

// --- amc.FDb.ns.EmptyQ
// Return true if index is empty
inline bool amc::ns_EmptyQ() {
    return _db.ns_n == 0;
}

// --- amc.FDb.ns.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNs* amc::ns_Find(u64 t) {
    amc::FNs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ns_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ns_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ns.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNs* amc::ns_Last() {
    return ns_Find(u64(_db.ns_n-1));
}

// --- amc.FDb.ns.N
// Return number of items in the pool
inline i32 amc::ns_N() {
    return _db.ns_n;
}

// --- amc.FDb.ns.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNs& amc::ns_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ns_lary[bsr][index];
}

// --- amc.FDb.pnew.EmptyQ
// Return true if index is empty
inline bool amc::pnew_EmptyQ() {
    return _db.pnew_n == 0;
}

// --- amc.FDb.pnew.Find
// Look up row by row id. Return NULL if out of range
inline amc::FPnew* amc::pnew_Find(u64 t) {
    amc::FPnew *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.pnew_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.pnew_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.pnew.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FPnew* amc::pnew_Last() {
    return pnew_Find(u64(_db.pnew_n-1));
}

// --- amc.FDb.pnew.N
// Return number of items in the pool
inline i32 amc::pnew_N() {
    return _db.pnew_n;
}

// --- amc.FDb.pnew.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FPnew& amc::pnew_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.pnew_lary[bsr][index];
}

// --- amc.FDb.fldoffset.EmptyQ
// Return true if index is empty
inline bool amc::fldoffset_EmptyQ() {
    return _db.fldoffset_n == 0;
}

// --- amc.FDb.fldoffset.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFldoffset* amc::fldoffset_Find(u64 t) {
    amc::FFldoffset *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fldoffset_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fldoffset_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fldoffset.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFldoffset* amc::fldoffset_Last() {
    return fldoffset_Find(u64(_db.fldoffset_n-1));
}

// --- amc.FDb.fldoffset.N
// Return number of items in the pool
inline i32 amc::fldoffset_N() {
    return _db.fldoffset_n;
}

// --- amc.FDb.fldoffset.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFldoffset& amc::fldoffset_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fldoffset_lary[bsr][index];
}

// --- amc.FDb.typefld.EmptyQ
// Return true if index is empty
inline bool amc::typefld_EmptyQ() {
    return _db.typefld_n == 0;
}

// --- amc.FDb.typefld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTypefld* amc::typefld_Find(u64 t) {
    amc::FTypefld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.typefld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.typefld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.typefld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTypefld* amc::typefld_Last() {
    return typefld_Find(u64(_db.typefld_n-1));
}

// --- amc.FDb.typefld.N
// Return number of items in the pool
inline i32 amc::typefld_N() {
    return _db.typefld_n;
}

// --- amc.FDb.typefld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTypefld& amc::typefld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.typefld_lary[bsr][index];
}

// --- amc.FDb.lenfld.EmptyQ
// Return true if index is empty
inline bool amc::lenfld_EmptyQ() {
    return _db.lenfld_n == 0;
}

// --- amc.FDb.lenfld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FLenfld* amc::lenfld_Find(u64 t) {
    amc::FLenfld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.lenfld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.lenfld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.lenfld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FLenfld* amc::lenfld_Last() {
    return lenfld_Find(u64(_db.lenfld_n-1));
}

// --- amc.FDb.lenfld.N
// Return number of items in the pool
inline i32 amc::lenfld_N() {
    return _db.lenfld_n;
}

// --- amc.FDb.lenfld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FLenfld& amc::lenfld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.lenfld_lary[bsr][index];
}

// --- amc.FDb.bltin.EmptyQ
// Return true if index is empty
inline bool amc::bltin_EmptyQ() {
    return _db.bltin_n == 0;
}

// --- amc.FDb.bltin.Find
// Look up row by row id. Return NULL if out of range
inline amc::FBltin* amc::bltin_Find(u64 t) {
    amc::FBltin *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.bltin_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.bltin_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.bltin.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FBltin* amc::bltin_Last() {
    return bltin_Find(u64(_db.bltin_n-1));
}

// --- amc.FDb.bltin.N
// Return number of items in the pool
inline i32 amc::bltin_N() {
    return _db.bltin_n;
}

// --- amc.FDb.bltin.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FBltin& amc::bltin_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.bltin_lary[bsr][index];
}

// --- amc.FDb.static_tuple.EmptyQ
// Return true if index is empty
inline bool amc::static_tuple_EmptyQ() {
    return _db.static_tuple_n == 0;
}

// --- amc.FDb.static_tuple.Find
// Look up row by row id. Return NULL if out of range
inline amc::FStatictuple* amc::static_tuple_Find(u64 t) {
    amc::FStatictuple *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.static_tuple_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.static_tuple_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.static_tuple.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FStatictuple* amc::static_tuple_Last() {
    return static_tuple_Find(u64(_db.static_tuple_n-1));
}

// --- amc.FDb.static_tuple.N
// Return number of items in the pool
inline i32 amc::static_tuple_N() {
    return _db.static_tuple_n;
}

// --- amc.FDb.static_tuple.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FStatictuple& amc::static_tuple_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.static_tuple_lary[bsr][index];
}

// --- amc.FDb.msgtype.EmptyQ
// Return true if index is empty
inline bool amc::msgtype_EmptyQ() {
    return _db.msgtype_n == 0;
}

// --- amc.FDb.msgtype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FMsgtype* amc::msgtype_Find(u64 t) {
    amc::FMsgtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.msgtype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.msgtype_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.msgtype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FMsgtype* amc::msgtype_Last() {
    return msgtype_Find(u64(_db.msgtype_n-1));
}

// --- amc.FDb.msgtype.N
// Return number of items in the pool
inline i32 amc::msgtype_N() {
    return _db.msgtype_n;
}

// --- amc.FDb.msgtype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FMsgtype& amc::msgtype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.msgtype_lary[bsr][index];
}

// --- amc.FDb.gconst.EmptyQ
// Return true if index is empty
inline bool amc::gconst_EmptyQ() {
    return _db.gconst_n == 0;
}

// --- amc.FDb.gconst.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGconst* amc::gconst_Find(u64 t) {
    amc::FGconst *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gconst_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gconst_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.gconst.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FGconst* amc::gconst_Last() {
    return gconst_Find(u64(_db.gconst_n-1));
}

// --- amc.FDb.gconst.N
// Return number of items in the pool
inline i32 amc::gconst_N() {
    return _db.gconst_n;
}

// --- amc.FDb.gconst.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FGconst& amc::gconst_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gconst_lary[bsr][index];
}

// --- amc.FDb.gstatic.EmptyQ
// Return true if index is empty
inline bool amc::gstatic_EmptyQ() {
    return _db.gstatic_n == 0;
}

// --- amc.FDb.gstatic.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGstatic* amc::gstatic_Find(u32 t) {
    amc::FGstatic *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gstatic_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gstatic_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.gstatic.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FGstatic* amc::gstatic_Last() {
    return gstatic_Find(u32(_db.gstatic_n-1));
}

// --- amc.FDb.gstatic.N
// Return number of items in the pool
inline i32 amc::gstatic_N() {
    return _db.gstatic_n;
}

// --- amc.FDb.gstatic.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FGstatic& amc::gstatic_qFind(u32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gstatic_lary[bsr][index];
}

// --- amc.FDb.thash.EmptyQ
// Return true if index is empty
inline bool amc::thash_EmptyQ() {
    return _db.thash_n == 0;
}

// --- amc.FDb.thash.Find
// Look up row by row id. Return NULL if out of range
inline amc::FThash* amc::thash_Find(u64 t) {
    amc::FThash *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.thash_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.thash_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.thash.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FThash* amc::thash_Last() {
    return thash_Find(u64(_db.thash_n-1));
}

// --- amc.FDb.thash.N
// Return number of items in the pool
inline i32 amc::thash_N() {
    return _db.thash_n;
}

// --- amc.FDb.thash.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FThash& amc::thash_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.thash_lary[bsr][index];
}

// --- amc.FDb.func.EmptyQ
// Return true if index is empty
inline bool amc::func_EmptyQ() {
    return _db.func_n == 0;
}

// --- amc.FDb.func.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFunc* amc::func_Find(u64 t) {
    amc::FFunc *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.func_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.func_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.func.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFunc* amc::func_Last() {
    return func_Find(u64(_db.func_n-1));
}

// --- amc.FDb.func.N
// Return number of items in the pool
inline i32 amc::func_N() {
    return _db.func_n;
}

// --- amc.FDb.func.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFunc& amc::func_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.func_lary[bsr][index];
}

// --- amc.FDb.smallstr.EmptyQ
// Return true if index is empty
inline bool amc::smallstr_EmptyQ() {
    return _db.smallstr_n == 0;
}

// --- amc.FDb.smallstr.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSmallstr* amc::smallstr_Find(u64 t) {
    amc::FSmallstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.smallstr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.smallstr_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.smallstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FSmallstr* amc::smallstr_Last() {
    return smallstr_Find(u64(_db.smallstr_n-1));
}

// --- amc.FDb.smallstr.N
// Return number of items in the pool
inline i32 amc::smallstr_N() {
    return _db.smallstr_n;
}

// --- amc.FDb.smallstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FSmallstr& amc::smallstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.smallstr_lary[bsr][index];
}

// --- amc.FDb.numstr.EmptyQ
// Return true if index is empty
inline bool amc::numstr_EmptyQ() {
    return _db.numstr_n == 0;
}

// --- amc.FDb.numstr.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNumstr* amc::numstr_Find(u64 t) {
    amc::FNumstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.numstr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.numstr_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.numstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNumstr* amc::numstr_Last() {
    return numstr_Find(u64(_db.numstr_n-1));
}

// --- amc.FDb.numstr.N
// Return number of items in the pool
inline i32 amc::numstr_N() {
    return _db.numstr_n;
}

// --- amc.FDb.numstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNumstr& amc::numstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.numstr_lary[bsr][index];
}

// --- amc.FDb.main.EmptyQ
// Return true if index is empty
inline bool amc::main_EmptyQ() {
    return _db.main_n == 0;
}

// --- amc.FDb.main.Find
// Look up row by row id. Return NULL if out of range
inline amc::FMain* amc::main_Find(u64 t) {
    amc::FMain *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.main_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.main_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.main.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FMain* amc::main_Last() {
    return main_Find(u64(_db.main_n-1));
}

// --- amc.FDb.main.N
// Return number of items in the pool
inline i32 amc::main_N() {
    return _db.main_n;
}

// --- amc.FDb.main.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FMain& amc::main_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.main_lary[bsr][index];
}

// --- amc.FDb.reftype.EmptyQ
// Return true if index is empty
inline bool amc::reftype_EmptyQ() {
    return _db.reftype_n == 0;
}

// --- amc.FDb.reftype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FReftype* amc::reftype_Find(i32 t) {
    amc::FReftype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.reftype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.reftype_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.reftype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FReftype* amc::reftype_Last() {
    return reftype_Find(i32(_db.reftype_n-1));
}

// --- amc.FDb.reftype.N
// Return number of items in the pool
inline i32 amc::reftype_N() {
    return _db.reftype_n;
}

// --- amc.FDb.reftype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FReftype& amc::reftype_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.reftype_lary[bsr][index];
}

// --- amc.FDb.ind_bltin.EmptyQ
// Return true if hash is empty
inline bool amc::ind_bltin_EmptyQ() {
    return _db.ind_bltin_n == 0;
}

// --- amc.FDb.ind_bltin.N
// Return number of items in the hash
inline i32 amc::ind_bltin_N() {
    return _db.ind_bltin_n;
}

// --- amc.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool amc::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- amc.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 amc::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- amc.FDb.ind_dispatch.EmptyQ
// Return true if hash is empty
inline bool amc::ind_dispatch_EmptyQ() {
    return _db.ind_dispatch_n == 0;
}

// --- amc.FDb.ind_dispatch.N
// Return number of items in the hash
inline i32 amc::ind_dispatch_N() {
    return _db.ind_dispatch_n;
}

// --- amc.FDb.ind_func.EmptyQ
// Return true if hash is empty
inline bool amc::ind_func_EmptyQ() {
    return _db.ind_func_n == 0;
}

// --- amc.FDb.ind_func.N
// Return number of items in the hash
inline i32 amc::ind_func_N() {
    return _db.ind_func_n;
}

// --- amc.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool amc::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- amc.FDb.ind_field.N
// Return number of items in the hash
inline i32 amc::ind_field_N() {
    return _db.ind_field_n;
}

// --- amc.FDb.ind_ns.EmptyQ
// Return true if hash is empty
inline bool amc::ind_ns_EmptyQ() {
    return _db.ind_ns_n == 0;
}

// --- amc.FDb.ind_ns.N
// Return number of items in the hash
inline i32 amc::ind_ns_N() {
    return _db.ind_ns_n;
}

// --- amc.FDb.ind_pnew.EmptyQ
// Return true if hash is empty
inline bool amc::ind_pnew_EmptyQ() {
    return _db.ind_pnew_n == 0;
}

// --- amc.FDb.ind_pnew.N
// Return number of items in the hash
inline i32 amc::ind_pnew_N() {
    return _db.ind_pnew_n;
}

// --- amc.FDb.ind_xref.EmptyQ
// Return true if hash is empty
inline bool amc::ind_xref_EmptyQ() {
    return _db.ind_xref_n == 0;
}

// --- amc.FDb.ind_xref.N
// Return number of items in the hash
inline i32 amc::ind_xref_N() {
    return _db.ind_xref_n;
}

// --- amc.FDb.cpptype.EmptyQ
// Return true if index is empty
inline bool amc::cpptype_EmptyQ() {
    return _db.cpptype_n == 0;
}

// --- amc.FDb.cpptype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCpptype* amc::cpptype_Find(u64 t) {
    amc::FCpptype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cpptype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cpptype_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cpptype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCpptype* amc::cpptype_Last() {
    return cpptype_Find(u64(_db.cpptype_n-1));
}

// --- amc.FDb.cpptype.N
// Return number of items in the pool
inline i32 amc::cpptype_N() {
    return _db.cpptype_n;
}

// --- amc.FDb.cpptype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCpptype& amc::cpptype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cpptype_lary[bsr][index];
}

// --- amc.FDb.ind_cpptype.EmptyQ
// Return true if hash is empty
inline bool amc::ind_cpptype_EmptyQ() {
    return _db.ind_cpptype_n == 0;
}

// --- amc.FDb.ind_cpptype.N
// Return number of items in the hash
inline i32 amc::ind_cpptype_N() {
    return _db.ind_cpptype_n;
}

// --- amc.FDb.inlary.EmptyQ
// Return true if index is empty
inline bool amc::inlary_EmptyQ() {
    return _db.inlary_n == 0;
}

// --- amc.FDb.inlary.Find
// Look up row by row id. Return NULL if out of range
inline amc::FInlary* amc::inlary_Find(u64 t) {
    amc::FInlary *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.inlary_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.inlary_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.inlary.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FInlary* amc::inlary_Last() {
    return inlary_Find(u64(_db.inlary_n-1));
}

// --- amc.FDb.inlary.N
// Return number of items in the pool
inline i32 amc::inlary_N() {
    return _db.inlary_n;
}

// --- amc.FDb.inlary.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FInlary& amc::inlary_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.inlary_lary[bsr][index];
}

// --- amc.FDb.ind_inlary.EmptyQ
// Return true if hash is empty
inline bool amc::ind_inlary_EmptyQ() {
    return _db.ind_inlary_n == 0;
}

// --- amc.FDb.ind_inlary.N
// Return number of items in the hash
inline i32 amc::ind_inlary_N() {
    return _db.ind_inlary_n;
}

// --- amc.FDb.tary.EmptyQ
// Return true if index is empty
inline bool amc::tary_EmptyQ() {
    return _db.tary_n == 0;
}

// --- amc.FDb.tary.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTary* amc::tary_Find(u64 t) {
    amc::FTary *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tary_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tary_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.tary.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTary* amc::tary_Last() {
    return tary_Find(u64(_db.tary_n-1));
}

// --- amc.FDb.tary.N
// Return number of items in the pool
inline i32 amc::tary_N() {
    return _db.tary_n;
}

// --- amc.FDb.tary.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTary& amc::tary_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tary_lary[bsr][index];
}

// --- amc.FDb.ind_tary.EmptyQ
// Return true if hash is empty
inline bool amc::ind_tary_EmptyQ() {
    return _db.ind_tary_n == 0;
}

// --- amc.FDb.ind_tary.N
// Return number of items in the hash
inline i32 amc::ind_tary_N() {
    return _db.ind_tary_n;
}

// --- amc.FDb.cppfunc.EmptyQ
// Return true if index is empty
inline bool amc::cppfunc_EmptyQ() {
    return _db.cppfunc_n == 0;
}

// --- amc.FDb.cppfunc.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCppfunc* amc::cppfunc_Find(u64 t) {
    amc::FCppfunc *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cppfunc_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cppfunc_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cppfunc.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCppfunc* amc::cppfunc_Last() {
    return cppfunc_Find(u64(_db.cppfunc_n-1));
}

// --- amc.FDb.cppfunc.N
// Return number of items in the pool
inline i32 amc::cppfunc_N() {
    return _db.cppfunc_n;
}

// --- amc.FDb.cppfunc.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCppfunc& amc::cppfunc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cppfunc_lary[bsr][index];
}

// --- amc.FDb.rowid.EmptyQ
// Return true if index is empty
inline bool amc::rowid_EmptyQ() {
    return _db.rowid_n == 0;
}

// --- amc.FDb.rowid.Find
// Look up row by row id. Return NULL if out of range
inline amc::FRowid* amc::rowid_Find(u64 t) {
    amc::FRowid *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.rowid_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.rowid_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.rowid.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FRowid* amc::rowid_Last() {
    return rowid_Find(u64(_db.rowid_n-1));
}

// --- amc.FDb.rowid.N
// Return number of items in the pool
inline i32 amc::rowid_N() {
    return _db.rowid_n;
}

// --- amc.FDb.rowid.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FRowid& amc::rowid_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.rowid_lary[bsr][index];
}

// --- amc.FDb.ind_rowid.EmptyQ
// Return true if hash is empty
inline bool amc::ind_rowid_EmptyQ() {
    return _db.ind_rowid_n == 0;
}

// --- amc.FDb.ind_rowid.N
// Return number of items in the hash
inline i32 amc::ind_rowid_N() {
    return _db.ind_rowid_n;
}

// --- amc.FDb.cascdel.EmptyQ
// Return true if index is empty
inline bool amc::cascdel_EmptyQ() {
    return _db.cascdel_n == 0;
}

// --- amc.FDb.cascdel.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCascdel* amc::cascdel_Find(u64 t) {
    amc::FCascdel *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cascdel_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cascdel_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cascdel.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCascdel* amc::cascdel_Last() {
    return cascdel_Find(u64(_db.cascdel_n-1));
}

// --- amc.FDb.cascdel.N
// Return number of items in the pool
inline i32 amc::cascdel_N() {
    return _db.cascdel_n;
}

// --- amc.FDb.cascdel.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCascdel& amc::cascdel_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cascdel_lary[bsr][index];
}

// --- amc.FDb.substr.EmptyQ
// Return true if index is empty
inline bool amc::substr_EmptyQ() {
    return _db.substr_n == 0;
}

// --- amc.FDb.substr.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSubstr* amc::substr_Find(u64 t) {
    amc::FSubstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.substr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.substr_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.substr.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FSubstr* amc::substr_Last() {
    return substr_Find(u64(_db.substr_n-1));
}

// --- amc.FDb.substr.N
// Return number of items in the pool
inline i32 amc::substr_N() {
    return _db.substr_n;
}

// --- amc.FDb.substr.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FSubstr& amc::substr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.substr_lary[bsr][index];
}

// --- amc.FDb.bitfld.EmptyQ
// Return true if index is empty
inline bool amc::bitfld_EmptyQ() {
    return _db.bitfld_n == 0;
}

// --- amc.FDb.bitfld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FBitfld* amc::bitfld_Find(u64 t) {
    amc::FBitfld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.bitfld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.bitfld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.bitfld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FBitfld* amc::bitfld_Last() {
    return bitfld_Find(u64(_db.bitfld_n-1));
}

// --- amc.FDb.bitfld.N
// Return number of items in the pool
inline i32 amc::bitfld_N() {
    return _db.bitfld_n;
}

// --- amc.FDb.bitfld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FBitfld& amc::bitfld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.bitfld_lary[bsr][index];
}

// --- amc.FDb.ssimfile.EmptyQ
// Return true if index is empty
inline bool amc::ssimfile_EmptyQ() {
    return _db.ssimfile_n == 0;
}

// --- amc.FDb.ssimfile.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSsimfile* amc::ssimfile_Find(u64 t) {
    amc::FSsimfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ssimfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ssimfile_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ssimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FSsimfile* amc::ssimfile_Last() {
    return ssimfile_Find(u64(_db.ssimfile_n-1));
}

// --- amc.FDb.ssimfile.N
// Return number of items in the pool
inline i32 amc::ssimfile_N() {
    return _db.ssimfile_n;
}

// --- amc.FDb.ssimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FSsimfile& amc::ssimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimfile_lary[bsr][index];
}

// --- amc.FDb.ind_ssimfile.EmptyQ
// Return true if hash is empty
inline bool amc::ind_ssimfile_EmptyQ() {
    return _db.ind_ssimfile_n == 0;
}

// --- amc.FDb.ind_ssimfile.N
// Return number of items in the hash
inline i32 amc::ind_ssimfile_N() {
    return _db.ind_ssimfile_n;
}

// --- amc.FDb.pack.EmptyQ
// Return true if index is empty
inline bool amc::pack_EmptyQ() {
    return _db.pack_n == 0;
}

// --- amc.FDb.pack.Find
// Look up row by row id. Return NULL if out of range
inline amc::FPack* amc::pack_Find(u64 t) {
    amc::FPack *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.pack_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.pack_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.pack.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FPack* amc::pack_Last() {
    return pack_Find(u64(_db.pack_n-1));
}

// --- amc.FDb.pack.N
// Return number of items in the pool
inline i32 amc::pack_N() {
    return _db.pack_n;
}

// --- amc.FDb.pack.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FPack& amc::pack_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.pack_lary[bsr][index];
}

// --- amc.FDb.ind_pack.EmptyQ
// Return true if hash is empty
inline bool amc::ind_pack_EmptyQ() {
    return _db.ind_pack_n == 0;
}

// --- amc.FDb.ind_pack.N
// Return number of items in the hash
inline i32 amc::ind_pack_N() {
    return _db.ind_pack_n;
}

// --- amc.FDb.ind_smallstr.EmptyQ
// Return true if hash is empty
inline bool amc::ind_smallstr_EmptyQ() {
    return _db.ind_smallstr_n == 0;
}

// --- amc.FDb.ind_smallstr.N
// Return number of items in the hash
inline i32 amc::ind_smallstr_N() {
    return _db.ind_smallstr_n;
}

// --- amc.FDb.ptrary.EmptyQ
// Return true if index is empty
inline bool amc::ptrary_EmptyQ() {
    return _db.ptrary_n == 0;
}

// --- amc.FDb.ptrary.Find
// Look up row by row id. Return NULL if out of range
inline amc::FPtrary* amc::ptrary_Find(u64 t) {
    amc::FPtrary *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ptrary_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ptrary_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ptrary.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FPtrary* amc::ptrary_Last() {
    return ptrary_Find(u64(_db.ptrary_n-1));
}

// --- amc.FDb.ptrary.N
// Return number of items in the pool
inline i32 amc::ptrary_N() {
    return _db.ptrary_n;
}

// --- amc.FDb.ptrary.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FPtrary& amc::ptrary_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ptrary_lary[bsr][index];
}

// --- amc.FDb.c_ctype_sorted.EmptyQ
// Return true if index is empty
inline bool amc::c_ctype_sorted_EmptyQ() {
    return _db.c_ctype_sorted_n == 0;
}

// --- amc.FDb.c_ctype_sorted.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCtype* amc::c_ctype_sorted_Find(u32 t) {
    amc::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_ctype_sorted_n;
    if (idx < lim) {
        retval = _db.c_ctype_sorted_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_ctype_sorted.Getary
// Return array of pointers
inline algo::aryptr<amc::FCtype*> amc::c_ctype_sorted_Getary() {
    return algo::aryptr<amc::FCtype*>(_db.c_ctype_sorted_elems, _db.c_ctype_sorted_n);
}

// --- amc.FDb.c_ctype_sorted.N
// Return number of items in the pointer array
inline i32 amc::c_ctype_sorted_N() {
    return _db.c_ctype_sorted_n;
}

// --- amc.FDb.c_ctype_sorted.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ctype_sorted_RemoveAll() {
    _db.c_ctype_sorted_n = 0;
}

// --- amc.FDb.c_ctype_sorted.qFind
// Return reference without bounds checking
inline amc::FCtype& amc::c_ctype_sorted_qFind(u32 idx) {
    return *_db.c_ctype_sorted_elems[idx];
}

// --- amc.FDb.c_ctype_sorted.qLast
// Reference to last element without bounds checking
inline amc::FCtype& amc::c_ctype_sorted_qLast() {
    return *_db.c_ctype_sorted_elems[_db.c_ctype_sorted_n-1];
}

// --- amc.FDb.enumstr.EmptyQ
// Return true if index is empty
inline bool amc::enumstr_EmptyQ() {
    return _db.enumstr_n == 0;
}

// --- amc.FDb.enumstr.Find
// Look up row by row id. Return NULL if out of range
inline amc::FEnumstr* amc::enumstr_Find(u64 t) {
    amc::FEnumstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.enumstr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.enumstr_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.enumstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FEnumstr* amc::enumstr_Last() {
    return enumstr_Find(u64(_db.enumstr_n-1));
}

// --- amc.FDb.enumstr.N
// Return number of items in the pool
inline i32 amc::enumstr_N() {
    return _db.enumstr_n;
}

// --- amc.FDb.enumstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FEnumstr& amc::enumstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.enumstr_lary[bsr][index];
}

// --- amc.FDb.enumstr_len.EmptyQ
// Return true if index is empty
inline bool amc::enumstr_len_EmptyQ() {
    return _db.enumstr_len_n == 0;
}

// --- amc.FDb.enumstr_len.Find
// Look up row by row id. Return NULL if out of range
inline amc::FEnumstrLen* amc::enumstr_len_Find(u64 t) {
    amc::FEnumstrLen *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.enumstr_len_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.enumstr_len_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.enumstr_len.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FEnumstrLen* amc::enumstr_len_Last() {
    return enumstr_len_Find(u64(_db.enumstr_len_n-1));
}

// --- amc.FDb.enumstr_len.N
// Return number of items in the pool
inline i32 amc::enumstr_len_N() {
    return _db.enumstr_len_n;
}

// --- amc.FDb.enumstr_len.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FEnumstrLen& amc::enumstr_len_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.enumstr_len_lary[bsr][index];
}

// --- amc.FDb.bh_enumstr_len.EmptyQ
// Return true if index is empty
inline bool amc::bh_enumstr_len_EmptyQ() {
    return _db.bh_enumstr_len_n == 0;
}

// --- amc.FDb.bh_enumstr_len.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FEnumstrLen* amc::bh_enumstr_len_First() {
    amc::FEnumstrLen *row = NULL;
    if (_db.bh_enumstr_len_n > 0) {
        row = _db.bh_enumstr_len_elems[0];
    }
    return row;
}

// --- amc.FDb.bh_enumstr_len.InBheapQ
// Return true if row is in index, false otherwise
inline bool amc::bh_enumstr_len_InBheapQ(amc::FEnumstrLen& row) {
    bool result = false;
    result = row.bh_enumstr_len_idx != -1;
    return result;
}

// --- amc.FDb.bh_enumstr_len.N
// Return number of items in the heap
inline i32 amc::bh_enumstr_len_N() {
    return _db.bh_enumstr_len_n;
}

// --- amc.FDb.ind_enumstr_len.EmptyQ
// Return true if hash is empty
inline bool amc::ind_enumstr_len_EmptyQ() {
    return _db.ind_enumstr_len_n == 0;
}

// --- amc.FDb.ind_enumstr_len.N
// Return number of items in the hash
inline i32 amc::ind_enumstr_len_N() {
    return _db.ind_enumstr_len_n;
}

// --- amc.FDb.ind_enumstr.EmptyQ
// Return true if hash is empty
inline bool amc::ind_enumstr_EmptyQ() {
    return _db.ind_enumstr_n == 0;
}

// --- amc.FDb.ind_enumstr.N
// Return number of items in the hash
inline i32 amc::ind_enumstr_N() {
    return _db.ind_enumstr_n;
}

// --- amc.FDb.fbitset.EmptyQ
// Return true if index is empty
inline bool amc::fbitset_EmptyQ() {
    return _db.fbitset_n == 0;
}

// --- amc.FDb.fbitset.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFbitset* amc::fbitset_Find(u64 t) {
    amc::FFbitset *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fbitset_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fbitset_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fbitset.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFbitset* amc::fbitset_Last() {
    return fbitset_Find(u64(_db.fbitset_n-1));
}

// --- amc.FDb.fbitset.N
// Return number of items in the pool
inline i32 amc::fbitset_N() {
    return _db.fbitset_n;
}

// --- amc.FDb.fbitset.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFbitset& amc::fbitset_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fbitset_lary[bsr][index];
}

// --- amc.FDb.ind_fbitset.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fbitset_EmptyQ() {
    return _db.ind_fbitset_n == 0;
}

// --- amc.FDb.ind_fbitset.N
// Return number of items in the hash
inline i32 amc::ind_fbitset_N() {
    return _db.ind_fbitset_n;
}

// --- amc.FDb.fcleanup.EmptyQ
// Return true if index is empty
inline bool amc::fcleanup_EmptyQ() {
    return _db.fcleanup_n == 0;
}

// --- amc.FDb.fcleanup.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcleanup* amc::fcleanup_Find(u64 t) {
    amc::FFcleanup *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcleanup_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcleanup_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcleanup.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcleanup* amc::fcleanup_Last() {
    return fcleanup_Find(u64(_db.fcleanup_n-1));
}

// --- amc.FDb.fcleanup.N
// Return number of items in the pool
inline i32 amc::fcleanup_N() {
    return _db.fcleanup_n;
}

// --- amc.FDb.fcleanup.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcleanup& amc::fcleanup_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcleanup_lary[bsr][index];
}

// --- amc.FDb.fdec.EmptyQ
// Return true if index is empty
inline bool amc::fdec_EmptyQ() {
    return _db.fdec_n == 0;
}

// --- amc.FDb.fdec.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFdec* amc::fdec_Find(u64 t) {
    amc::FFdec *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fdec_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fdec_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fdec.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFdec* amc::fdec_Last() {
    return fdec_Find(u64(_db.fdec_n-1));
}

// --- amc.FDb.fdec.N
// Return number of items in the pool
inline i32 amc::fdec_N() {
    return _db.fdec_n;
}

// --- amc.FDb.fdec.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFdec& amc::fdec_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fdec_lary[bsr][index];
}

// --- amc.FDb.ind_fdec.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fdec_EmptyQ() {
    return _db.ind_fdec_n == 0;
}

// --- amc.FDb.ind_fdec.N
// Return number of items in the hash
inline i32 amc::ind_fdec_N() {
    return _db.ind_fdec_n;
}

// --- amc.FDb.ind_reftype.EmptyQ
// Return true if hash is empty
inline bool amc::ind_reftype_EmptyQ() {
    return _db.ind_reftype_n == 0;
}

// --- amc.FDb.ind_reftype.N
// Return number of items in the hash
inline i32 amc::ind_reftype_N() {
    return _db.ind_reftype_n;
}

// --- amc.FDb.fconst.EmptyQ
// Return true if index is empty
inline bool amc::fconst_EmptyQ() {
    return _db.fconst_n == 0;
}

// --- amc.FDb.fconst.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFconst* amc::fconst_Find(u64 t) {
    amc::FFconst *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fconst_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fconst_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fconst.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFconst* amc::fconst_Last() {
    return fconst_Find(u64(_db.fconst_n-1));
}

// --- amc.FDb.fconst.N
// Return number of items in the pool
inline i32 amc::fconst_N() {
    return _db.fconst_n;
}

// --- amc.FDb.fconst.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFconst& amc::fconst_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fconst_lary[bsr][index];
}

// --- amc.FDb.ind_fconst.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fconst_EmptyQ() {
    return _db.ind_fconst_n == 0;
}

// --- amc.FDb.ind_fconst.N
// Return number of items in the hash
inline i32 amc::ind_fconst_N() {
    return _db.ind_fconst_n;
}

// --- amc.FDb.c_ns_sorted.EmptyQ
// Return true if index is empty
inline bool amc::c_ns_sorted_EmptyQ() {
    return _db.c_ns_sorted_n == 0;
}

// --- amc.FDb.c_ns_sorted.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNs* amc::c_ns_sorted_Find(u32 t) {
    amc::FNs *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_ns_sorted_n;
    if (idx < lim) {
        retval = _db.c_ns_sorted_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_ns_sorted.Getary
// Return array of pointers
inline algo::aryptr<amc::FNs*> amc::c_ns_sorted_Getary() {
    return algo::aryptr<amc::FNs*>(_db.c_ns_sorted_elems, _db.c_ns_sorted_n);
}

// --- amc.FDb.c_ns_sorted.N
// Return number of items in the pointer array
inline i32 amc::c_ns_sorted_N() {
    return _db.c_ns_sorted_n;
}

// --- amc.FDb.c_ns_sorted.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ns_sorted_RemoveAll() {
    _db.c_ns_sorted_n = 0;
}

// --- amc.FDb.c_ns_sorted.qFind
// Return reference without bounds checking
inline amc::FNs& amc::c_ns_sorted_qFind(u32 idx) {
    return *_db.c_ns_sorted_elems[idx];
}

// --- amc.FDb.c_ns_sorted.qLast
// Reference to last element without bounds checking
inline amc::FNs& amc::c_ns_sorted_qLast() {
    return *_db.c_ns_sorted_elems[_db.c_ns_sorted_n-1];
}

// --- amc.FDb.finput.EmptyQ
// Return true if index is empty
inline bool amc::finput_EmptyQ() {
    return _db.finput_n == 0;
}

// --- amc.FDb.finput.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFinput* amc::finput_Find(u64 t) {
    amc::FFinput *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.finput_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.finput_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.finput.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFinput* amc::finput_Last() {
    return finput_Find(u64(_db.finput_n-1));
}

// --- amc.FDb.finput.N
// Return number of items in the pool
inline i32 amc::finput_N() {
    return _db.finput_n;
}

// --- amc.FDb.finput.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFinput& amc::finput_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.finput_lary[bsr][index];
}

// --- amc.FDb.foutput.EmptyQ
// Return true if index is empty
inline bool amc::foutput_EmptyQ() {
    return _db.foutput_n == 0;
}

// --- amc.FDb.foutput.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFoutput* amc::foutput_Find(u64 t) {
    amc::FFoutput *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.foutput_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.foutput_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.foutput.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFoutput* amc::foutput_Last() {
    return foutput_Find(u64(_db.foutput_n-1));
}

// --- amc.FDb.foutput.N
// Return number of items in the pool
inline i32 amc::foutput_N() {
    return _db.foutput_n;
}

// --- amc.FDb.foutput.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFoutput& amc::foutput_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.foutput_lary[bsr][index];
}

// --- amc.FDb.fbuf.EmptyQ
// Return true if index is empty
inline bool amc::fbuf_EmptyQ() {
    return _db.fbuf_n == 0;
}

// --- amc.FDb.fbuf.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFbuf* amc::fbuf_Find(u64 t) {
    amc::FFbuf *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fbuf_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fbuf_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fbuf.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFbuf* amc::fbuf_Last() {
    return fbuf_Find(u64(_db.fbuf_n-1));
}

// --- amc.FDb.fbuf.N
// Return number of items in the pool
inline i32 amc::fbuf_N() {
    return _db.fbuf_n;
}

// --- amc.FDb.fbuf.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFbuf& amc::fbuf_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fbuf_lary[bsr][index];
}

// --- amc.FDb.ind_fbuf.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fbuf_EmptyQ() {
    return _db.ind_fbuf_n == 0;
}

// --- amc.FDb.ind_fbuf.N
// Return number of items in the hash
inline i32 amc::ind_fbuf_N() {
    return _db.ind_fbuf_n;
}

// --- amc.FDb.chash.EmptyQ
// Return true if index is empty
inline bool amc::chash_EmptyQ() {
    return _db.chash_n == 0;
}

// --- amc.FDb.chash.Find
// Look up row by row id. Return NULL if out of range
inline amc::FChash* amc::chash_Find(u64 t) {
    amc::FChash *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.chash_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.chash_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.chash.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FChash* amc::chash_Last() {
    return chash_Find(u64(_db.chash_n-1));
}

// --- amc.FDb.chash.N
// Return number of items in the pool
inline i32 amc::chash_N() {
    return _db.chash_n;
}

// --- amc.FDb.chash.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FChash& amc::chash_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.chash_lary[bsr][index];
}

// --- amc.FDb.ind_chash.EmptyQ
// Return true if hash is empty
inline bool amc::ind_chash_EmptyQ() {
    return _db.ind_chash_n == 0;
}

// --- amc.FDb.ind_chash.N
// Return number of items in the hash
inline i32 amc::ind_chash_N() {
    return _db.ind_chash_n;
}

// --- amc.FDb.ccmp.EmptyQ
// Return true if index is empty
inline bool amc::ccmp_EmptyQ() {
    return _db.ccmp_n == 0;
}

// --- amc.FDb.ccmp.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCcmp* amc::ccmp_Find(u64 t) {
    amc::FCcmp *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ccmp_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ccmp_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ccmp.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCcmp* amc::ccmp_Last() {
    return ccmp_Find(u64(_db.ccmp_n-1));
}

// --- amc.FDb.ccmp.N
// Return number of items in the pool
inline i32 amc::ccmp_N() {
    return _db.ccmp_n;
}

// --- amc.FDb.ccmp.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCcmp& amc::ccmp_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ccmp_lary[bsr][index];
}

// --- amc.FDb.ind_ccmp.EmptyQ
// Return true if hash is empty
inline bool amc::ind_ccmp_EmptyQ() {
    return _db.ind_ccmp_n == 0;
}

// --- amc.FDb.ind_ccmp.N
// Return number of items in the hash
inline i32 amc::ind_ccmp_N() {
    return _db.ind_ccmp_n;
}

// --- amc.FDb.fbigend.EmptyQ
// Return true if index is empty
inline bool amc::fbigend_EmptyQ() {
    return _db.fbigend_n == 0;
}

// --- amc.FDb.fbigend.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFbigend* amc::fbigend_Find(u64 t) {
    amc::FFbigend *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fbigend_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fbigend_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fbigend.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFbigend* amc::fbigend_Last() {
    return fbigend_Find(u64(_db.fbigend_n-1));
}

// --- amc.FDb.fbigend.N
// Return number of items in the pool
inline i32 amc::fbigend_N() {
    return _db.fbigend_n;
}

// --- amc.FDb.fbigend.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFbigend& amc::fbigend_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fbigend_lary[bsr][index];
}

// --- amc.FDb.zsl_ctype_pack_tran.EmptyQ
// Return true if index is empty
inline bool amc::zsl_ctype_pack_tran_EmptyQ() {
    return _db.zsl_ctype_pack_tran_head == NULL;
}

// --- amc.FDb.zsl_ctype_pack_tran.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FCtype* amc::zsl_ctype_pack_tran_First() {
    amc::FCtype *row = NULL;
    row = _db.zsl_ctype_pack_tran_head;
    return row;
}

// --- amc.FDb.zsl_ctype_pack_tran.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zsl_ctype_pack_tran_InLlistQ(amc::FCtype& row) {
    bool result = false;
    result = !(row.zsl_ctype_pack_tran_next == (amc::FCtype*)-1);
    return result;
}

// --- amc.FDb.zsl_ctype_pack_tran.Next
// Return pointer to next element in the list
inline amc::FCtype* amc::zsl_ctype_pack_tran_Next(amc::FCtype &row) {
    return row.zsl_ctype_pack_tran_next;
}

// --- amc.FDb.cstr.EmptyQ
// Return true if index is empty
inline bool amc::cstr_EmptyQ() {
    return _db.cstr_n == 0;
}

// --- amc.FDb.cstr.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCstr* amc::cstr_Find(u64 t) {
    amc::FCstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cstr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cstr_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCstr* amc::cstr_Last() {
    return cstr_Find(u64(_db.cstr_n-1));
}

// --- amc.FDb.cstr.N
// Return number of items in the pool
inline i32 amc::cstr_N() {
    return _db.cstr_n;
}

// --- amc.FDb.cstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCstr& amc::cstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cstr_lary[bsr][index];
}

// --- amc.FDb.listtype.EmptyQ
// Return true if index is empty
inline bool amc::listtype_EmptyQ() {
    return _db.listtype_n == 0;
}

// --- amc.FDb.listtype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FListtype* amc::listtype_Find(u64 t) {
    amc::FListtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.listtype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.listtype_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.listtype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FListtype* amc::listtype_Last() {
    return listtype_Find(u64(_db.listtype_n-1));
}

// --- amc.FDb.listtype.N
// Return number of items in the pool
inline i32 amc::listtype_N() {
    return _db.listtype_n;
}

// --- amc.FDb.listtype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FListtype& amc::listtype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.listtype_lary[bsr][index];
}

// --- amc.FDb.ind_listtype.EmptyQ
// Return true if hash is empty
inline bool amc::ind_listtype_EmptyQ() {
    return _db.ind_listtype_n == 0;
}

// --- amc.FDb.ind_listtype.N
// Return number of items in the hash
inline i32 amc::ind_listtype_N() {
    return _db.ind_listtype_n;
}

// --- amc.FDb.fstep.EmptyQ
// Return true if index is empty
inline bool amc::fstep_EmptyQ() {
    return _db.fstep_n == 0;
}

// --- amc.FDb.fstep.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFstep* amc::fstep_Find(u64 t) {
    amc::FFstep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fstep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fstep_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fstep.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFstep* amc::fstep_Last() {
    return fstep_Find(u64(_db.fstep_n-1));
}

// --- amc.FDb.fstep.N
// Return number of items in the pool
inline i32 amc::fstep_N() {
    return _db.fstep_n;
}

// --- amc.FDb.fstep.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFstep& amc::fstep_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fstep_lary[bsr][index];
}

// --- amc.FDb.cextern.EmptyQ
// Return true if index is empty
inline bool amc::cextern_EmptyQ() {
    return _db.cextern_n == 0;
}

// --- amc.FDb.cextern.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCextern* amc::cextern_Find(u64 t) {
    amc::FCextern *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cextern_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cextern_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cextern.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCextern* amc::cextern_Last() {
    return cextern_Find(u64(_db.cextern_n-1));
}

// --- amc.FDb.cextern.N
// Return number of items in the pool
inline i32 amc::cextern_N() {
    return _db.cextern_n;
}

// --- amc.FDb.cextern.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCextern& amc::cextern_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cextern_lary[bsr][index];
}

// --- amc.FDb.fdelay.EmptyQ
// Return true if index is empty
inline bool amc::fdelay_EmptyQ() {
    return _db.fdelay_n == 0;
}

// --- amc.FDb.fdelay.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFdelay* amc::fdelay_Find(u64 t) {
    amc::FFdelay *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fdelay_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fdelay_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fdelay.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFdelay* amc::fdelay_Last() {
    return fdelay_Find(u64(_db.fdelay_n-1));
}

// --- amc.FDb.fdelay.N
// Return number of items in the pool
inline i32 amc::fdelay_N() {
    return _db.fdelay_n;
}

// --- amc.FDb.fdelay.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFdelay& amc::fdelay_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fdelay_lary[bsr][index];
}

// --- amc.FDb.disptrace.EmptyQ
// Return true if index is empty
inline bool amc::disptrace_EmptyQ() {
    return _db.disptrace_n == 0;
}

// --- amc.FDb.disptrace.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDisptrace* amc::disptrace_Find(u64 t) {
    amc::FDisptrace *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.disptrace_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.disptrace_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.disptrace.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FDisptrace* amc::disptrace_Last() {
    return disptrace_Find(u64(_db.disptrace_n-1));
}

// --- amc.FDb.disptrace.N
// Return number of items in the pool
inline i32 amc::disptrace_N() {
    return _db.disptrace_n;
}

// --- amc.FDb.disptrace.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FDisptrace& amc::disptrace_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.disptrace_lary[bsr][index];
}

// --- amc.FDb.ind_fstep.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fstep_EmptyQ() {
    return _db.ind_fstep_n == 0;
}

// --- amc.FDb.ind_fstep.N
// Return number of items in the hash
inline i32 amc::ind_fstep_N() {
    return _db.ind_fstep_n;
}

// --- amc.FDb.tracefld.EmptyQ
// Return true if index is empty
inline bool amc::tracefld_EmptyQ() {
    return _db.tracefld_n == 0;
}

// --- amc.FDb.tracefld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTracefld* amc::tracefld_Find(u64 t) {
    amc::FTracefld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tracefld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tracefld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.tracefld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTracefld* amc::tracefld_Last() {
    return tracefld_Find(u64(_db.tracefld_n-1));
}

// --- amc.FDb.tracefld.N
// Return number of items in the pool
inline i32 amc::tracefld_N() {
    return _db.tracefld_n;
}

// --- amc.FDb.tracefld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTracefld& amc::tracefld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tracefld_lary[bsr][index];
}

// --- amc.FDb.tracerec.EmptyQ
// Return true if index is empty
inline bool amc::tracerec_EmptyQ() {
    return _db.tracerec_n == 0;
}

// --- amc.FDb.tracerec.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTracerec* amc::tracerec_Find(u64 t) {
    amc::FTracerec *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tracerec_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tracerec_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.tracerec.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTracerec* amc::tracerec_Last() {
    return tracerec_Find(u64(_db.tracerec_n-1));
}

// --- amc.FDb.tracerec.N
// Return number of items in the pool
inline i32 amc::tracerec_N() {
    return _db.tracerec_n;
}

// --- amc.FDb.tracerec.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTracerec& amc::tracerec_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tracerec_lary[bsr][index];
}

// --- amc.FDb.dispsig.EmptyQ
// Return true if index is empty
inline bool amc::dispsig_EmptyQ() {
    return _db.dispsig_n == 0;
}

// --- amc.FDb.dispsig.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispsig* amc::dispsig_Find(u64 t) {
    amc::FDispsig *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispsig_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispsig_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.dispsig.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FDispsig* amc::dispsig_Last() {
    return dispsig_Find(u64(_db.dispsig_n-1));
}

// --- amc.FDb.dispsig.N
// Return number of items in the pool
inline i32 amc::dispsig_N() {
    return _db.dispsig_n;
}

// --- amc.FDb.dispsig.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FDispsig& amc::dispsig_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispsig_lary[bsr][index];
}

// --- amc.FDb.c_dispsig_sorted.EmptyQ
// Return true if index is empty
inline bool amc::c_dispsig_sorted_EmptyQ() {
    return _db.c_dispsig_sorted_n == 0;
}

// --- amc.FDb.c_dispsig_sorted.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispsig* amc::c_dispsig_sorted_Find(u32 t) {
    amc::FDispsig *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_dispsig_sorted_n;
    if (idx < lim) {
        retval = _db.c_dispsig_sorted_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_dispsig_sorted.Getary
// Return array of pointers
inline algo::aryptr<amc::FDispsig*> amc::c_dispsig_sorted_Getary() {
    return algo::aryptr<amc::FDispsig*>(_db.c_dispsig_sorted_elems, _db.c_dispsig_sorted_n);
}

// --- amc.FDb.c_dispsig_sorted.N
// Return number of items in the pointer array
inline i32 amc::c_dispsig_sorted_N() {
    return _db.c_dispsig_sorted_n;
}

// --- amc.FDb.c_dispsig_sorted.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_dispsig_sorted_RemoveAll() {
    for (u32 i = 0; i < _db.c_dispsig_sorted_n; i++) {
        // mark all elements as not-in-array
        _db.c_dispsig_sorted_elems[i]->_db_c_dispsig_sorted_in_ary = false;
    }
    _db.c_dispsig_sorted_n = 0;
}

// --- amc.FDb.c_dispsig_sorted.qFind
// Return reference without bounds checking
inline amc::FDispsig& amc::c_dispsig_sorted_qFind(u32 idx) {
    return *_db.c_dispsig_sorted_elems[idx];
}

// --- amc.FDb.c_dispsig_sorted.InAryQ
// True if row is in any ptrary instance
inline bool amc::c_dispsig_sorted_InAryQ(amc::FDispsig& row) {
    return row._db_c_dispsig_sorted_in_ary;
}

// --- amc.FDb.c_dispsig_sorted.qLast
// Reference to last element without bounds checking
inline amc::FDispsig& amc::c_dispsig_sorted_qLast() {
    return *_db.c_dispsig_sorted_elems[_db.c_dispsig_sorted_n-1];
}

// --- amc.FDb.zs_sig_visit.EmptyQ
// Return true if index is empty
inline bool amc::zs_sig_visit_EmptyQ() {
    return _db.zs_sig_visit_head == NULL;
}

// --- amc.FDb.zs_sig_visit.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FCtype* amc::zs_sig_visit_First() {
    amc::FCtype *row = NULL;
    row = _db.zs_sig_visit_head;
    return row;
}

// --- amc.FDb.zs_sig_visit.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_sig_visit_InLlistQ(amc::FCtype& row) {
    bool result = false;
    result = !(row.zs_sig_visit_next == (amc::FCtype*)-1);
    return result;
}

// --- amc.FDb.zs_sig_visit.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FCtype* amc::zs_sig_visit_Last() {
    amc::FCtype *row = NULL;
    row = _db.zs_sig_visit_tail;
    return row;
}

// --- amc.FDb.zs_sig_visit.Next
// Return pointer to next element in the list
inline amc::FCtype* amc::zs_sig_visit_Next(amc::FCtype &row) {
    return row.zs_sig_visit_next;
}

// --- amc.FDb.zs_sig_visit.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FCtype& amc::zs_sig_visit_qLast() {
    amc::FCtype *row = NULL;
    row = _db.zs_sig_visit_tail;
    return *row;
}

// --- amc.FDb.target.EmptyQ
// Return true if index is empty
inline bool amc::target_EmptyQ() {
    return _db.target_n == 0;
}

// --- amc.FDb.target.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTarget* amc::target_Find(u64 t) {
    amc::FTarget *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.target_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.target_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.target.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTarget* amc::target_Last() {
    return target_Find(u64(_db.target_n-1));
}

// --- amc.FDb.target.N
// Return number of items in the pool
inline i32 amc::target_N() {
    return _db.target_n;
}

// --- amc.FDb.target.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTarget& amc::target_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.target_lary[bsr][index];
}

// --- amc.FDb.ind_target.EmptyQ
// Return true if hash is empty
inline bool amc::ind_target_EmptyQ() {
    return _db.ind_target_n == 0;
}

// --- amc.FDb.ind_target.N
// Return number of items in the hash
inline i32 amc::ind_target_N() {
    return _db.ind_target_n;
}

// --- amc.FDb.targdep.EmptyQ
// Return true if index is empty
inline bool amc::targdep_EmptyQ() {
    return _db.targdep_n == 0;
}

// --- amc.FDb.targdep.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTargdep* amc::targdep_Find(u64 t) {
    amc::FTargdep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targdep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targdep_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.targdep.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTargdep* amc::targdep_Last() {
    return targdep_Find(u64(_db.targdep_n-1));
}

// --- amc.FDb.targdep.N
// Return number of items in the pool
inline i32 amc::targdep_N() {
    return _db.targdep_n;
}

// --- amc.FDb.targdep.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTargdep& amc::targdep_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targdep_lary[bsr][index];
}

// --- amc.FDb.dispctx.EmptyQ
// Return true if index is empty
inline bool amc::dispctx_EmptyQ() {
    return _db.dispctx_n == 0;
}

// --- amc.FDb.dispctx.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispctx* amc::dispctx_Find(u64 t) {
    amc::FDispctx *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispctx_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispctx_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.dispctx.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FDispctx* amc::dispctx_Last() {
    return dispctx_Find(u64(_db.dispctx_n-1));
}

// --- amc.FDb.dispctx.N
// Return number of items in the pool
inline i32 amc::dispctx_N() {
    return _db.dispctx_n;
}

// --- amc.FDb.dispctx.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FDispctx& amc::dispctx_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispctx_lary[bsr][index];
}

// --- amc.FDb.pmaskfld.EmptyQ
// Return true if index is empty
inline bool amc::pmaskfld_EmptyQ() {
    return _db.pmaskfld_n == 0;
}

// --- amc.FDb.pmaskfld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FPmaskfld* amc::pmaskfld_Find(u64 t) {
    amc::FPmaskfld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.pmaskfld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.pmaskfld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.pmaskfld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FPmaskfld* amc::pmaskfld_Last() {
    return pmaskfld_Find(u64(_db.pmaskfld_n-1));
}

// --- amc.FDb.pmaskfld.N
// Return number of items in the pool
inline i32 amc::pmaskfld_N() {
    return _db.pmaskfld_n;
}

// --- amc.FDb.pmaskfld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FPmaskfld& amc::pmaskfld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.pmaskfld_lary[bsr][index];
}

// --- amc.FDb.fwddecl.EmptyQ
// Return true if index is empty
inline bool amc::fwddecl_EmptyQ() {
    return _db.fwddecl_n == 0;
}

// --- amc.FDb.fwddecl.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFwddecl* amc::fwddecl_Find(u64 t) {
    amc::FFwddecl *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fwddecl_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fwddecl_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fwddecl.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFwddecl* amc::fwddecl_Last() {
    return fwddecl_Find(u64(_db.fwddecl_n-1));
}

// --- amc.FDb.fwddecl.N
// Return number of items in the pool
inline i32 amc::fwddecl_N() {
    return _db.fwddecl_n;
}

// --- amc.FDb.fwddecl.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFwddecl& amc::fwddecl_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fwddecl_lary[bsr][index];
}

// --- amc.FDb.ind_fwddecl.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fwddecl_EmptyQ() {
    return _db.ind_fwddecl_n == 0;
}

// --- amc.FDb.ind_fwddecl.N
// Return number of items in the hash
inline i32 amc::ind_fwddecl_N() {
    return _db.ind_fwddecl_n;
}

// --- amc.FDb.tfunc.EmptyQ
// Return true if index is empty
inline bool amc::tfunc_EmptyQ() {
    return _db.tfunc_n == 0;
}

// --- amc.FDb.tfunc.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTfunc* amc::tfunc_Find(u64 t) {
    amc::FTfunc *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tfunc_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tfunc_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.tfunc.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTfunc* amc::tfunc_Last() {
    return tfunc_Find(u64(_db.tfunc_n-1));
}

// --- amc.FDb.tfunc.N
// Return number of items in the pool
inline i32 amc::tfunc_N() {
    return _db.tfunc_n;
}

// --- amc.FDb.tfunc.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTfunc& amc::tfunc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tfunc_lary[bsr][index];
}

// --- amc.FDb.ind_tfunc.EmptyQ
// Return true if hash is empty
inline bool amc::ind_tfunc_EmptyQ() {
    return _db.ind_tfunc_n == 0;
}

// --- amc.FDb.ind_tfunc.N
// Return number of items in the hash
inline i32 amc::ind_tfunc_N() {
    return _db.ind_tfunc_n;
}

// --- amc.FDb.gen.EmptyQ
// Return true if index is empty
inline bool amc::gen_EmptyQ() {
    return _db.gen_n == 0;
}

// --- amc.FDb.gen.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGen* amc::gen_Find(u64 t) {
    amc::FGen *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gen_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gen_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.gen.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FGen* amc::gen_Last() {
    return gen_Find(u64(_db.gen_n-1));
}

// --- amc.FDb.gen.N
// Return number of items in the pool
inline i32 amc::gen_N() {
    return _db.gen_n;
}

// --- amc.FDb.gen.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FGen& amc::gen_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gen_lary[bsr][index];
}

// --- amc.FDb.fregx.EmptyQ
// Return true if index is empty
inline bool amc::fregx_EmptyQ() {
    return _db.fregx_n == 0;
}

// --- amc.FDb.fregx.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFregx* amc::fregx_Find(u64 t) {
    amc::FFregx *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fregx_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fregx_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fregx.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFregx* amc::fregx_Last() {
    return fregx_Find(u64(_db.fregx_n-1));
}

// --- amc.FDb.fregx.N
// Return number of items in the pool
inline i32 amc::fregx_N() {
    return _db.fregx_n;
}

// --- amc.FDb.fregx.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFregx& amc::fregx_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fregx_lary[bsr][index];
}

// --- amc.FDb.tclass.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* amc::tclass_AllocMem() {
    void *row = reinterpret_cast<amc::FTclass*>(_db.tclass_data) + _db.tclass_n;
    if (_db.tclass_n == 51) row = NULL;
    if (row) _db.tclass_n++;
    return row;
}

// --- amc.FDb.tclass.EmptyQ
// Return true if index is empty
inline bool amc::tclass_EmptyQ() {
    return _db.tclass_n == 0;
}

// --- amc.FDb.tclass.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTclass* amc::tclass_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.tclass_n;
    return idx < lim ? reinterpret_cast<amc::FTclass*>(_db.tclass_data) + idx : NULL; // unsigned comparison with limit
}

// --- amc.FDb.tclass.Getary
// Return array pointer by value
inline algo::aryptr<amc::FTclass> amc::tclass_Getary() {
    return algo::aryptr<amc::FTclass>(reinterpret_cast<amc::FTclass*>(_db.tclass_data), _db.tclass_n);
}

// --- amc.FDb.tclass.Max
// Return constant 51 -- max. number of items in the pool
inline i32 amc::tclass_Max() {
    return 51;
}

// --- amc.FDb.tclass.N
// Return number of items in the array
inline i32 amc::tclass_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return _db.tclass_n;
}

// --- amc.FDb.tclass.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline amc::FTclass& amc::tclass_qFind(u64 t) {
    u64 idx = t;
    return reinterpret_cast<amc::FTclass*>(_db.tclass_data)[idx];
}

// --- amc.FDb.tclass.rowid_Get
// Compute row id of element given element's address
inline u64 amc::tclass_rowid_Get(amc::FTclass &row) {
    u64 ret = u64(&row - reinterpret_cast<amc::FTclass*>(_db.tclass_data));
    return u64(ret);
}

// --- amc.FDb.ind_tclass.EmptyQ
// Return true if hash is empty
inline bool amc::ind_tclass_EmptyQ() {
    return _db.ind_tclass_n == 0;
}

// --- amc.FDb.ind_tclass.N
// Return number of items in the hash
inline i32 amc::ind_tclass_N() {
    return _db.ind_tclass_n;
}

// --- amc.FDb.fcmp.EmptyQ
// Return true if index is empty
inline bool amc::fcmp_EmptyQ() {
    return _db.fcmp_n == 0;
}

// --- amc.FDb.fcmp.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcmp* amc::fcmp_Find(u64 t) {
    amc::FFcmp *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcmp_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcmp_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcmp.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcmp* amc::fcmp_Last() {
    return fcmp_Find(u64(_db.fcmp_n-1));
}

// --- amc.FDb.fcmp.N
// Return number of items in the pool
inline i32 amc::fcmp_N() {
    return _db.fcmp_n;
}

// --- amc.FDb.fcmp.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcmp& amc::fcmp_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcmp_lary[bsr][index];
}

// --- amc.FDb.fcast.EmptyQ
// Return true if index is empty
inline bool amc::fcast_EmptyQ() {
    return _db.fcast_n == 0;
}

// --- amc.FDb.fcast.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcast* amc::fcast_Find(u64 t) {
    amc::FFcast *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcast_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcast_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcast.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcast* amc::fcast_Last() {
    return fcast_Find(u64(_db.fcast_n-1));
}

// --- amc.FDb.fcast.N
// Return number of items in the pool
inline i32 amc::fcast_N() {
    return _db.fcast_n;
}

// --- amc.FDb.fcast.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcast& amc::fcast_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcast_lary[bsr][index];
}

// --- amc.FDb.noxref.EmptyQ
// Return true if index is empty
inline bool amc::noxref_EmptyQ() {
    return _db.noxref_n == 0;
}

// --- amc.FDb.noxref.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNoxref* amc::noxref_Find(u64 t) {
    amc::FNoxref *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.noxref_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.noxref_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.noxref.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNoxref* amc::noxref_Last() {
    return noxref_Find(u64(_db.noxref_n-1));
}

// --- amc.FDb.noxref.N
// Return number of items in the pool
inline i32 amc::noxref_N() {
    return _db.noxref_n;
}

// --- amc.FDb.noxref.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNoxref& amc::noxref_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.noxref_lary[bsr][index];
}

// --- amc.FDb.nocascdel.EmptyQ
// Return true if index is empty
inline bool amc::nocascdel_EmptyQ() {
    return _db.nocascdel_n == 0;
}

// --- amc.FDb.nocascdel.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNocascdel* amc::nocascdel_Find(u64 t) {
    amc::FNocascdel *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nocascdel_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nocascdel_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nocascdel.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNocascdel* amc::nocascdel_Last() {
    return nocascdel_Find(u64(_db.nocascdel_n-1));
}

// --- amc.FDb.nocascdel.N
// Return number of items in the pool
inline i32 amc::nocascdel_N() {
    return _db.nocascdel_n;
}

// --- amc.FDb.nocascdel.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNocascdel& amc::nocascdel_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nocascdel_lary[bsr][index];
}

// --- amc.FDb.cafter.EmptyQ
// Return true if index is empty
inline bool amc::cafter_EmptyQ() {
    return _db.cafter_n == 0;
}

// --- amc.FDb.cafter.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCafter* amc::cafter_Find(u64 t) {
    amc::FCafter *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cafter_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cafter_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cafter.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCafter* amc::cafter_Last() {
    return cafter_Find(u64(_db.cafter_n-1));
}

// --- amc.FDb.cafter.N
// Return number of items in the pool
inline i32 amc::cafter_N() {
    return _db.cafter_n;
}

// --- amc.FDb.cafter.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCafter& amc::cafter_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cafter_lary[bsr][index];
}

// --- amc.FDb.csize.EmptyQ
// Return true if index is empty
inline bool amc::csize_EmptyQ() {
    return _db.csize_n == 0;
}

// --- amc.FDb.csize.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCsize* amc::csize_Find(u64 t) {
    amc::FCsize *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.csize_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.csize_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.csize.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCsize* amc::csize_Last() {
    return csize_Find(u64(_db.csize_n-1));
}

// --- amc.FDb.csize.N
// Return number of items in the pool
inline i32 amc::csize_N() {
    return _db.csize_n;
}

// --- amc.FDb.csize.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCsize& amc::csize_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.csize_lary[bsr][index];
}

// --- amc.FDb.nsx.EmptyQ
// Return true if index is empty
inline bool amc::nsx_EmptyQ() {
    return _db.nsx_n == 0;
}

// --- amc.FDb.nsx.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNsx* amc::nsx_Find(u64 t) {
    amc::FNsx *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nsx_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nsx_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nsx.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNsx* amc::nsx_Last() {
    return nsx_Find(u64(_db.nsx_n-1));
}

// --- amc.FDb.nsx.N
// Return number of items in the pool
inline i32 amc::nsx_N() {
    return _db.nsx_n;
}

// --- amc.FDb.nsx.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNsx& amc::nsx_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nsx_lary[bsr][index];
}

// --- amc.FDb.fcompact.EmptyQ
// Return true if index is empty
inline bool amc::fcompact_EmptyQ() {
    return _db.fcompact_n == 0;
}

// --- amc.FDb.fcompact.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcompact* amc::fcompact_Find(u64 t) {
    amc::FFcompact *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcompact_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcompact_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcompact.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcompact* amc::fcompact_Last() {
    return fcompact_Find(u64(_db.fcompact_n-1));
}

// --- amc.FDb.fcompact.N
// Return number of items in the pool
inline i32 amc::fcompact_N() {
    return _db.fcompact_n;
}

// --- amc.FDb.fcompact.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcompact& amc::fcompact_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcompact_lary[bsr][index];
}

// --- amc.FDb.findrem.EmptyQ
// Return true if index is empty
inline bool amc::findrem_EmptyQ() {
    return _db.findrem_n == 0;
}

// --- amc.FDb.findrem.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFindrem* amc::findrem_Find(u64 t) {
    amc::FFindrem *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.findrem_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.findrem_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.findrem.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFindrem* amc::findrem_Last() {
    return findrem_Find(u64(_db.findrem_n-1));
}

// --- amc.FDb.findrem.N
// Return number of items in the pool
inline i32 amc::findrem_N() {
    return _db.findrem_n;
}

// --- amc.FDb.findrem.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFindrem& amc::findrem_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.findrem_lary[bsr][index];
}

// --- amc.FDb.fcurs.EmptyQ
// Return true if index is empty
inline bool amc::fcurs_EmptyQ() {
    return _db.fcurs_n == 0;
}

// --- amc.FDb.fcurs.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcurs* amc::fcurs_Find(u64 t) {
    amc::FFcurs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcurs_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcurs_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcurs.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcurs* amc::fcurs_Last() {
    return fcurs_Find(u64(_db.fcurs_n-1));
}

// --- amc.FDb.fcurs.N
// Return number of items in the pool
inline i32 amc::fcurs_N() {
    return _db.fcurs_n;
}

// --- amc.FDb.fcurs.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcurs& amc::fcurs_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcurs_lary[bsr][index];
}

// --- amc.FDb.cdflt.EmptyQ
// Return true if index is empty
inline bool amc::cdflt_EmptyQ() {
    return _db.cdflt_n == 0;
}

// --- amc.FDb.cdflt.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCdflt* amc::cdflt_Find(u64 t) {
    amc::FCdflt *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cdflt_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cdflt_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cdflt.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCdflt* amc::cdflt_Last() {
    return cdflt_Find(u64(_db.cdflt_n-1));
}

// --- amc.FDb.cdflt.N
// Return number of items in the pool
inline i32 amc::cdflt_N() {
    return _db.cdflt_n;
}

// --- amc.FDb.cdflt.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCdflt& amc::cdflt_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cdflt_lary[bsr][index];
}

// --- amc.FDb.argvtype.EmptyQ
// Return true if index is empty
inline bool amc::argvtype_EmptyQ() {
    return _db.argvtype_n == 0;
}

// --- amc.FDb.argvtype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FArgvtype* amc::argvtype_Find(u64 t) {
    amc::FArgvtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.argvtype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.argvtype_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.argvtype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FArgvtype* amc::argvtype_Last() {
    return argvtype_Find(u64(_db.argvtype_n-1));
}

// --- amc.FDb.argvtype.N
// Return number of items in the pool
inline i32 amc::argvtype_N() {
    return _db.argvtype_n;
}

// --- amc.FDb.argvtype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FArgvtype& amc::argvtype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.argvtype_lary[bsr][index];
}

// --- amc.FDb.fcmdline.EmptyQ
// Return true if index is empty
inline bool amc::fcmdline_EmptyQ() {
    return _db.fcmdline_n == 0;
}

// --- amc.FDb.fcmdline.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcmdline* amc::fcmdline_Find(u64 t) {
    amc::FFcmdline *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcmdline_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcmdline_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcmdline.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcmdline* amc::fcmdline_Last() {
    return fcmdline_Find(u64(_db.fcmdline_n-1));
}

// --- amc.FDb.fcmdline.N
// Return number of items in the pool
inline i32 amc::fcmdline_N() {
    return _db.fcmdline_n;
}

// --- amc.FDb.fcmdline.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcmdline& amc::fcmdline_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcmdline_lary[bsr][index];
}

// --- amc.FDb.ind_main.EmptyQ
// Return true if hash is empty
inline bool amc::ind_main_EmptyQ() {
    return _db.ind_main_n == 0;
}

// --- amc.FDb.ind_main.N
// Return number of items in the hash
inline i32 amc::ind_main_N() {
    return _db.ind_main_n;
}

// --- amc.FDb.floadtuples.EmptyQ
// Return true if index is empty
inline bool amc::floadtuples_EmptyQ() {
    return _db.floadtuples_n == 0;
}

// --- amc.FDb.floadtuples.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFloadtuples* amc::floadtuples_Find(u64 t) {
    amc::FFloadtuples *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.floadtuples_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.floadtuples_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.floadtuples.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFloadtuples* amc::floadtuples_Last() {
    return floadtuples_Find(u64(_db.floadtuples_n-1));
}

// --- amc.FDb.floadtuples.N
// Return number of items in the pool
inline i32 amc::floadtuples_N() {
    return _db.floadtuples_n;
}

// --- amc.FDb.floadtuples.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFloadtuples& amc::floadtuples_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.floadtuples_lary[bsr][index];
}

// --- amc.FDb.fcmap.EmptyQ
// Return true if index is empty
inline bool amc::fcmap_EmptyQ() {
    return _db.fcmap_n == 0;
}

// --- amc.FDb.fcmap.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFcmap* amc::fcmap_Find(u64 t) {
    amc::FFcmap *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fcmap_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fcmap_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fcmap.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFcmap* amc::fcmap_Last() {
    return fcmap_Find(u64(_db.fcmap_n-1));
}

// --- amc.FDb.fcmap.N
// Return number of items in the pool
inline i32 amc::fcmap_N() {
    return _db.fcmap_n;
}

// --- amc.FDb.fcmap.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFcmap& amc::fcmap_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fcmap_lary[bsr][index];
}

// --- amc.FDb.zs_ordkeyfield.EmptyQ
// Return true if index is empty
inline bool amc::zs_ordkeyfield_EmptyQ() {
    return _db.zs_ordkeyfield_head == NULL;
}

// --- amc.FDb.zs_ordkeyfield.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FField* amc::zs_ordkeyfield_First() {
    amc::FField *row = NULL;
    row = _db.zs_ordkeyfield_head;
    return row;
}

// --- amc.FDb.zs_ordkeyfield.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_ordkeyfield_InLlistQ(amc::FField& row) {
    bool result = false;
    result = !(row.zs_ordkeyfield_next == (amc::FField*)-1);
    return result;
}

// --- amc.FDb.zs_ordkeyfield.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FField* amc::zs_ordkeyfield_Last() {
    amc::FField *row = NULL;
    row = _db.zs_ordkeyfield_tail;
    return row;
}

// --- amc.FDb.zs_ordkeyfield.Next
// Return pointer to next element in the list
inline amc::FField* amc::zs_ordkeyfield_Next(amc::FField &row) {
    return row.zs_ordkeyfield_next;
}

// --- amc.FDb.zs_ordkeyfield.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FField& amc::zs_ordkeyfield_qLast() {
    amc::FField *row = NULL;
    row = _db.zs_ordkeyfield_tail;
    return *row;
}

// --- amc.FDb.nsproto.EmptyQ
// Return true if index is empty
inline bool amc::nsproto_EmptyQ() {
    return _db.nsproto_n == 0;
}

// --- amc.FDb.nsproto.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNsproto* amc::nsproto_Find(u64 t) {
    amc::FNsproto *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nsproto_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nsproto_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nsproto.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNsproto* amc::nsproto_Last() {
    return nsproto_Find(u64(_db.nsproto_n-1));
}

// --- amc.FDb.nsproto.N
// Return number of items in the pool
inline i32 amc::nsproto_N() {
    return _db.nsproto_n;
}

// --- amc.FDb.nsproto.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNsproto& amc::nsproto_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nsproto_lary[bsr][index];
}

// --- amc.FDb.nsdb.EmptyQ
// Return true if index is empty
inline bool amc::nsdb_EmptyQ() {
    return _db.nsdb_n == 0;
}

// --- amc.FDb.nsdb.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNsdb* amc::nsdb_Find(u64 t) {
    amc::FNsdb *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nsdb_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nsdb_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nsdb.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNsdb* amc::nsdb_Last() {
    return nsdb_Find(u64(_db.nsdb_n-1));
}

// --- amc.FDb.nsdb.N
// Return number of items in the pool
inline i32 amc::nsdb_N() {
    return _db.nsdb_n;
}

// --- amc.FDb.nsdb.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNsdb& amc::nsdb_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nsdb_lary[bsr][index];
}

// --- amc.FDb.zd_substr_params.EmptyQ
// Return true if index is empty
inline bool amc::zd_substr_params_EmptyQ() {
    return _db.zd_substr_params_head == NULL;
}

// --- amc.FDb.zd_substr_params.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FSubstr* amc::zd_substr_params_First() {
    amc::FSubstr *row = NULL;
    row = _db.zd_substr_params_head;
    return row;
}

// --- amc.FDb.zd_substr_params.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zd_substr_params_InLlistQ(amc::FSubstr& row) {
    bool result = false;
    result = !(row.zd_substr_params_next == (amc::FSubstr*)-1);
    return result;
}

// --- amc.FDb.zd_substr_params.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FSubstr* amc::zd_substr_params_Last() {
    amc::FSubstr *row = NULL;
    row = _db.zd_substr_params_tail;
    return row;
}

// --- amc.FDb.zd_substr_params.N
// Return number of items in the linked list
inline i32 amc::zd_substr_params_N() {
    return _db.zd_substr_params_n;
}

// --- amc.FDb.zd_substr_params.Next
// Return pointer to next element in the list
inline amc::FSubstr* amc::zd_substr_params_Next(amc::FSubstr &row) {
    return row.zd_substr_params_next;
}

// --- amc.FDb.zd_substr_params.Prev
// Return pointer to previous element in the list
inline amc::FSubstr* amc::zd_substr_params_Prev(amc::FSubstr &row) {
    return row.zd_substr_params_prev;
}

// --- amc.FDb.zd_substr_params.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FSubstr& amc::zd_substr_params_qLast() {
    amc::FSubstr *row = NULL;
    row = _db.zd_substr_params_tail;
    return *row;
}

// --- amc.FDb.ind_fconst_int.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fconst_int_EmptyQ() {
    return _db.ind_fconst_int_n == 0;
}

// --- amc.FDb.ind_fconst_int.N
// Return number of items in the hash
inline i32 amc::ind_fconst_int_N() {
    return _db.ind_fconst_int_n;
}

// --- amc.FDb.fprefix.EmptyQ
// Return true if index is empty
inline bool amc::fprefix_EmptyQ() {
    return _db.fprefix_n == 0;
}

// --- amc.FDb.fprefix.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFprefix* amc::fprefix_Find(u64 t) {
    amc::FFprefix *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fprefix_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fprefix_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fprefix.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFprefix* amc::fprefix_Last() {
    return fprefix_Find(u64(_db.fprefix_n-1));
}

// --- amc.FDb.fprefix.N
// Return number of items in the pool
inline i32 amc::fprefix_N() {
    return _db.fprefix_n;
}

// --- amc.FDb.fprefix.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFprefix& amc::fprefix_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fprefix_lary[bsr][index];
}

// --- amc.FDb.ind_prefix.EmptyQ
// Return true if hash is empty
inline bool amc::ind_prefix_EmptyQ() {
    return _db.ind_prefix_n == 0;
}

// --- amc.FDb.ind_prefix.N
// Return number of items in the hash
inline i32 amc::ind_prefix_N() {
    return _db.ind_prefix_n;
}

// --- amc.FDb.ftrace.EmptyQ
// Return true if index is empty
inline bool amc::ftrace_EmptyQ() {
    return _db.ftrace_n == 0;
}

// --- amc.FDb.ftrace.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFtrace* amc::ftrace_Find(u64 t) {
    amc::FFtrace *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ftrace_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ftrace_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ftrace.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFtrace* amc::ftrace_Last() {
    return ftrace_Find(u64(_db.ftrace_n-1));
}

// --- amc.FDb.ftrace.N
// Return number of items in the pool
inline i32 amc::ftrace_N() {
    return _db.ftrace_n;
}

// --- amc.FDb.ftrace.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFtrace& amc::ftrace_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ftrace_lary[bsr][index];
}

// --- amc.FDb.fnoremove.EmptyQ
// Return true if index is empty
inline bool amc::fnoremove_EmptyQ() {
    return _db.fnoremove_n == 0;
}

// --- amc.FDb.fnoremove.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFnoremove* amc::fnoremove_Find(u64 t) {
    amc::FFnoremove *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fnoremove_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fnoremove_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fnoremove.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFnoremove* amc::fnoremove_Last() {
    return fnoremove_Find(u64(_db.fnoremove_n-1));
}

// --- amc.FDb.fnoremove.N
// Return number of items in the pool
inline i32 amc::fnoremove_N() {
    return _db.fnoremove_n;
}

// --- amc.FDb.fnoremove.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFnoremove& amc::fnoremove_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fnoremove_lary[bsr][index];
}

// --- amc.FDb.c_substr_field.EmptyQ
// Return true if index is empty
inline bool amc::c_substr_field_EmptyQ() {
    return _db.c_substr_field_n == 0;
}

// --- amc.FDb.c_substr_field.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSubstr* amc::c_substr_field_Find(u32 t) {
    amc::FSubstr *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_substr_field_n;
    if (idx < lim) {
        retval = _db.c_substr_field_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_substr_field.Getary
// Return array of pointers
inline algo::aryptr<amc::FSubstr*> amc::c_substr_field_Getary() {
    return algo::aryptr<amc::FSubstr*>(_db.c_substr_field_elems, _db.c_substr_field_n);
}

// --- amc.FDb.c_substr_field.N
// Return number of items in the pointer array
inline i32 amc::c_substr_field_N() {
    return _db.c_substr_field_n;
}

// --- amc.FDb.c_substr_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_substr_field_RemoveAll() {
    for (u32 i = 0; i < _db.c_substr_field_n; i++) {
        // mark all elements as not-in-array
        _db.c_substr_field_elems[i]->_db_c_substr_field_in_ary = false;
    }
    _db.c_substr_field_n = 0;
}

// --- amc.FDb.c_substr_field.qFind
// Return reference without bounds checking
inline amc::FSubstr& amc::c_substr_field_qFind(u32 idx) {
    return *_db.c_substr_field_elems[idx];
}

// --- amc.FDb.c_substr_field.InAryQ
// True if row is in any ptrary instance
inline bool amc::c_substr_field_InAryQ(amc::FSubstr& row) {
    return row._db_c_substr_field_in_ary;
}

// --- amc.FDb.c_substr_field.qLast
// Reference to last element without bounds checking
inline amc::FSubstr& amc::c_substr_field_qLast() {
    return *_db.c_substr_field_elems[_db.c_substr_field_n-1];
}

// --- amc.FDb.ctypelen.EmptyQ
// Return true if index is empty
inline bool amc::ctypelen_EmptyQ() {
    return _db.ctypelen_n == 0;
}

// --- amc.FDb.ctypelen.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCtypelen* amc::ctypelen_Find(u64 t) {
    amc::FCtypelen *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ctypelen_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ctypelen_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ctypelen.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCtypelen* amc::ctypelen_Last() {
    return ctypelen_Find(u64(_db.ctypelen_n-1));
}

// --- amc.FDb.ctypelen.N
// Return number of items in the pool
inline i32 amc::ctypelen_N() {
    return _db.ctypelen_n;
}

// --- amc.FDb.ctypelen.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCtypelen& amc::ctypelen_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctypelen_lary[bsr][index];
}

// --- amc.FDb.c_ctypelen.EmptyQ
// Return true if index is empty
inline bool amc::c_ctypelen_EmptyQ() {
    return _db.c_ctypelen_n == 0;
}

// --- amc.FDb.c_ctypelen.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCtypelen* amc::c_ctypelen_Find(u32 t) {
    amc::FCtypelen *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_ctypelen_n;
    if (idx < lim) {
        retval = _db.c_ctypelen_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_ctypelen.Getary
// Return array of pointers
inline algo::aryptr<amc::FCtypelen*> amc::c_ctypelen_Getary() {
    return algo::aryptr<amc::FCtypelen*>(_db.c_ctypelen_elems, _db.c_ctypelen_n);
}

// --- amc.FDb.c_ctypelen.N
// Return number of items in the pointer array
inline i32 amc::c_ctypelen_N() {
    return _db.c_ctypelen_n;
}

// --- amc.FDb.c_ctypelen.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ctypelen_RemoveAll() {
    for (u32 i = 0; i < _db.c_ctypelen_n; i++) {
        // mark all elements as not-in-array
        _db.c_ctypelen_elems[i]->_db_c_ctypelen_in_ary = false;
    }
    _db.c_ctypelen_n = 0;
}

// --- amc.FDb.c_ctypelen.qFind
// Return reference without bounds checking
inline amc::FCtypelen& amc::c_ctypelen_qFind(u32 idx) {
    return *_db.c_ctypelen_elems[idx];
}

// --- amc.FDb.c_ctypelen.InAryQ
// True if row is in any ptrary instance
inline bool amc::c_ctypelen_InAryQ(amc::FCtypelen& row) {
    return row._db_c_ctypelen_in_ary;
}

// --- amc.FDb.c_ctypelen.qLast
// Reference to last element without bounds checking
inline amc::FCtypelen& amc::c_ctypelen_qLast() {
    return *_db.c_ctypelen_elems[_db.c_ctypelen_n-1];
}

// --- amc.FDb.c_tempfield.EmptyQ
// Return true if index is empty
inline bool amc::c_tempfield_EmptyQ() {
    return _db.c_tempfield_n == 0;
}

// --- amc.FDb.c_tempfield.Find
// Look up row by row id. Return NULL if out of range
inline amc::FField* amc::c_tempfield_Find(u32 t) {
    amc::FField *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_tempfield_n;
    if (idx < lim) {
        retval = _db.c_tempfield_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_tempfield.Getary
// Return array of pointers
inline algo::aryptr<amc::FField*> amc::c_tempfield_Getary() {
    return algo::aryptr<amc::FField*>(_db.c_tempfield_elems, _db.c_tempfield_n);
}

// --- amc.FDb.c_tempfield.N
// Return number of items in the pointer array
inline i32 amc::c_tempfield_N() {
    return _db.c_tempfield_n;
}

// --- amc.FDb.c_tempfield.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_tempfield_RemoveAll() {
    for (u32 i = 0; i < _db.c_tempfield_n; i++) {
        // mark all elements as not-in-array
        _db.c_tempfield_elems[i]->_db_c_tempfield_in_ary = false;
    }
    _db.c_tempfield_n = 0;
}

// --- amc.FDb.c_tempfield.qFind
// Return reference without bounds checking
inline amc::FField& amc::c_tempfield_qFind(u32 idx) {
    return *_db.c_tempfield_elems[idx];
}

// --- amc.FDb.c_tempfield.InAryQ
// True if row is in any ptrary instance
inline bool amc::c_tempfield_InAryQ(amc::FField& row) {
    return row._db_c_tempfield_in_ary;
}

// --- amc.FDb.c_tempfield.qLast
// Reference to last element without bounds checking
inline amc::FField& amc::c_tempfield_qLast() {
    return *_db.c_tempfield_elems[_db.c_tempfield_n-1];
}

// --- amc.FDb.fbase.EmptyQ
// Return true if index is empty
inline bool amc::fbase_EmptyQ() {
    return _db.fbase_n == 0;
}

// --- amc.FDb.fbase.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFbase* amc::fbase_Find(u64 t) {
    amc::FFbase *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fbase_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fbase_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fbase.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFbase* amc::fbase_Last() {
    return fbase_Find(u64(_db.fbase_n-1));
}

// --- amc.FDb.fbase.N
// Return number of items in the pool
inline i32 amc::fbase_N() {
    return _db.fbase_n;
}

// --- amc.FDb.fbase.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFbase& amc::fbase_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fbase_lary[bsr][index];
}

// --- amc.FDb.ind_fcmap.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fcmap_EmptyQ() {
    return _db.ind_fcmap_n == 0;
}

// --- amc.FDb.ind_fcmap.N
// Return number of items in the hash
inline i32 amc::ind_fcmap_N() {
    return _db.ind_fcmap_n;
}

// --- amc.FDb.nossimfile.EmptyQ
// Return true if index is empty
inline bool amc::nossimfile_EmptyQ() {
    return _db.nossimfile_n == 0;
}

// --- amc.FDb.nossimfile.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNossimfile* amc::nossimfile_Find(u64 t) {
    amc::FNossimfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nossimfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nossimfile_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nossimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNossimfile* amc::nossimfile_Last() {
    return nossimfile_Find(u64(_db.nossimfile_n-1));
}

// --- amc.FDb.nossimfile.N
// Return number of items in the pool
inline i32 amc::nossimfile_N() {
    return _db.nossimfile_n;
}

// --- amc.FDb.nossimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNossimfile& amc::nossimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nossimfile_lary[bsr][index];
}

// --- amc.FDb.gsymbol.EmptyQ
// Return true if index is empty
inline bool amc::gsymbol_EmptyQ() {
    return _db.gsymbol_n == 0;
}

// --- amc.FDb.gsymbol.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGsymbol* amc::gsymbol_Find(u64 t) {
    amc::FGsymbol *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gsymbol_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gsymbol_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.gsymbol.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FGsymbol* amc::gsymbol_Last() {
    return gsymbol_Find(u64(_db.gsymbol_n-1));
}

// --- amc.FDb.gsymbol.N
// Return number of items in the pool
inline i32 amc::gsymbol_N() {
    return _db.gsymbol_n;
}

// --- amc.FDb.gsymbol.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FGsymbol& amc::gsymbol_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gsymbol_lary[bsr][index];
}

// --- amc.FDb.sortfld.EmptyQ
// Return true if index is empty
inline bool amc::sortfld_EmptyQ() {
    return _db.sortfld_n == 0;
}

// --- amc.FDb.sortfld.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSortfld* amc::sortfld_Find(u64 t) {
    amc::FSortfld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.sortfld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.sortfld_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.sortfld.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FSortfld* amc::sortfld_Last() {
    return sortfld_Find(u64(_db.sortfld_n-1));
}

// --- amc.FDb.sortfld.N
// Return number of items in the pool
inline i32 amc::sortfld_N() {
    return _db.sortfld_n;
}

// --- amc.FDb.sortfld.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FSortfld& amc::sortfld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.sortfld_lary[bsr][index];
}

// --- amc.FDb.cget.EmptyQ
// Return true if index is empty
inline bool amc::cget_EmptyQ() {
    return _db.cget_n == 0;
}

// --- amc.FDb.cget.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCget* amc::cget_Find(u64 t) {
    amc::FCget *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cget_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cget_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.cget.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCget* amc::cget_Last() {
    return cget_Find(u64(_db.cget_n-1));
}

// --- amc.FDb.cget.N
// Return number of items in the pool
inline i32 amc::cget_N() {
    return _db.cget_n;
}

// --- amc.FDb.cget.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCget& amc::cget_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cget_lary[bsr][index];
}

// --- amc.FDb.cd_temp_func.EmptyQ
// Return true if index is empty
inline bool amc::cd_temp_func_EmptyQ() {
    return _db.cd_temp_func_head == NULL;
}

// --- amc.FDb.cd_temp_func.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FFunc* amc::cd_temp_func_First() {
    amc::FFunc *row = NULL;
    row = _db.cd_temp_func_head;
    return row;
}

// --- amc.FDb.cd_temp_func.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::cd_temp_func_InLlistQ(amc::FFunc& row) {
    bool result = false;
    result = !(row.cd_temp_func_next == (amc::FFunc*)-1);
    return result;
}

// --- amc.FDb.cd_temp_func.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FFunc* amc::cd_temp_func_Last() {
    amc::FFunc *row = NULL;
    row = _db.cd_temp_func_head ? _db.cd_temp_func_head->cd_temp_func_prev : NULL;
    return row;
}

// --- amc.FDb.cd_temp_func.N
// Return number of items in the linked list
inline i32 amc::cd_temp_func_N() {
    return _db.cd_temp_func_n;
}

// --- amc.FDb.cd_temp_func.Next
// Return pointer to next element in the list
inline amc::FFunc* amc::cd_temp_func_Next(amc::FFunc &row) {
    return row.cd_temp_func_next;
}

// --- amc.FDb.cd_temp_func.Prev
// Return pointer to previous element in the list
inline amc::FFunc* amc::cd_temp_func_Prev(amc::FFunc &row) {
    return row.cd_temp_func_prev;
}

// --- amc.FDb.cd_temp_func.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FFunc& amc::cd_temp_func_qLast() {
    amc::FFunc *row = NULL;
    row = _db.cd_temp_func_head ? _db.cd_temp_func_head->cd_temp_func_prev : NULL;
    return *row;
}

// --- amc.FDb.zs_gen_perns.EmptyQ
// Return true if index is empty
inline bool amc::zs_gen_perns_EmptyQ() {
    return _db.zs_gen_perns_head == NULL;
}

// --- amc.FDb.zs_gen_perns.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FGen* amc::zs_gen_perns_First() {
    amc::FGen *row = NULL;
    row = _db.zs_gen_perns_head;
    return row;
}

// --- amc.FDb.zs_gen_perns.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_gen_perns_InLlistQ(amc::FGen& row) {
    bool result = false;
    result = !(row.zs_gen_perns_next == (amc::FGen*)-1);
    return result;
}

// --- amc.FDb.zs_gen_perns.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FGen* amc::zs_gen_perns_Last() {
    amc::FGen *row = NULL;
    row = _db.zs_gen_perns_tail;
    return row;
}

// --- amc.FDb.zs_gen_perns.Next
// Return pointer to next element in the list
inline amc::FGen* amc::zs_gen_perns_Next(amc::FGen &row) {
    return row.zs_gen_perns_next;
}

// --- amc.FDb.zs_gen_perns.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FGen& amc::zs_gen_perns_qLast() {
    amc::FGen *row = NULL;
    row = _db.zs_gen_perns_tail;
    return *row;
}

// --- amc.FDb.hook.EmptyQ
// Return true if index is empty
inline bool amc::hook_EmptyQ() {
    return _db.hook_n == 0;
}

// --- amc.FDb.hook.Find
// Look up row by row id. Return NULL if out of range
inline amc::FHook* amc::hook_Find(u64 t) {
    amc::FHook *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.hook_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.hook_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.hook.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FHook* amc::hook_Last() {
    return hook_Find(u64(_db.hook_n-1));
}

// --- amc.FDb.hook.N
// Return number of items in the pool
inline i32 amc::hook_N() {
    return _db.hook_n;
}

// --- amc.FDb.hook.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FHook& amc::hook_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.hook_lary[bsr][index];
}

// --- amc.FDb.charset.EmptyQ
// Return true if index is empty
inline bool amc::charset_EmptyQ() {
    return _db.charset_n == 0;
}

// --- amc.FDb.charset.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCharset* amc::charset_Find(u64 t) {
    amc::FCharset *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.charset_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.charset_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.charset.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FCharset* amc::charset_Last() {
    return charset_Find(u64(_db.charset_n-1));
}

// --- amc.FDb.charset.N
// Return number of items in the pool
inline i32 amc::charset_N() {
    return _db.charset_n;
}

// --- amc.FDb.charset.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FCharset& amc::charset_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.charset_lary[bsr][index];
}

// --- amc.FDb.ValidRnumPad.Match
inline bool amc::ValidRnumPadQ(u32 ch) {
    return ch_GetBit(_db.ValidRnumPad, ch);
}

// --- amc.FDb.nsinclude.EmptyQ
// Return true if index is empty
inline bool amc::nsinclude_EmptyQ() {
    return _db.nsinclude_n == 0;
}

// --- amc.FDb.nsinclude.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNsinclude* amc::nsinclude_Find(u64 t) {
    amc::FNsinclude *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nsinclude_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nsinclude_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nsinclude.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNsinclude* amc::nsinclude_Last() {
    return nsinclude_Find(u64(_db.nsinclude_n-1));
}

// --- amc.FDb.nsinclude.N
// Return number of items in the pool
inline i32 amc::nsinclude_N() {
    return _db.nsinclude_n;
}

// --- amc.FDb.nsinclude.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNsinclude& amc::nsinclude_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nsinclude_lary[bsr][index];
}

// --- amc.FDb.ssimvolatile.EmptyQ
// Return true if index is empty
inline bool amc::ssimvolatile_EmptyQ() {
    return _db.ssimvolatile_n == 0;
}

// --- amc.FDb.ssimvolatile.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSsimvolatile* amc::ssimvolatile_Find(u64 t) {
    amc::FSsimvolatile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ssimvolatile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ssimvolatile_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.ssimvolatile.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FSsimvolatile* amc::ssimvolatile_Last() {
    return ssimvolatile_Find(u64(_db.ssimvolatile_n-1));
}

// --- amc.FDb.ssimvolatile.N
// Return number of items in the pool
inline i32 amc::ssimvolatile_N() {
    return _db.ssimvolatile_n;
}

// --- amc.FDb.ssimvolatile.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FSsimvolatile& amc::ssimvolatile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimvolatile_lary[bsr][index];
}

// --- amc.FDb.funique.EmptyQ
// Return true if index is empty
inline bool amc::funique_EmptyQ() {
    return _db.funique_n == 0;
}

// --- amc.FDb.funique.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFunique* amc::funique_Find(u64 t) {
    amc::FFunique *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.funique_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.funique_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.funique.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFunique* amc::funique_Last() {
    return funique_Find(u64(_db.funique_n-1));
}

// --- amc.FDb.funique.N
// Return number of items in the pool
inline i32 amc::funique_N() {
    return _db.funique_n;
}

// --- amc.FDb.funique.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFunique& amc::funique_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.funique_lary[bsr][index];
}

// --- amc.FDb.fuserinit.EmptyQ
// Return true if index is empty
inline bool amc::fuserinit_EmptyQ() {
    return _db.fuserinit_n == 0;
}

// --- amc.FDb.fuserinit.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFuserinit* amc::fuserinit_Find(u64 t) {
    amc::FFuserinit *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fuserinit_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fuserinit_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fuserinit.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFuserinit* amc::fuserinit_Last() {
    return fuserinit_Find(u64(_db.fuserinit_n-1));
}

// --- amc.FDb.fuserinit.N
// Return number of items in the pool
inline i32 amc::fuserinit_N() {
    return _db.fuserinit_n;
}

// --- amc.FDb.fuserinit.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFuserinit& amc::fuserinit_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fuserinit_lary[bsr][index];
}

// --- amc.FDb.ind_fcurs.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fcurs_EmptyQ() {
    return _db.ind_fcurs_n == 0;
}

// --- amc.FDb.ind_fcurs.N
// Return number of items in the hash
inline i32 amc::ind_fcurs_N() {
    return _db.ind_fcurs_n;
}

// --- amc.FDb.tcurs.EmptyQ
// Return true if index is empty
inline bool amc::tcurs_EmptyQ() {
    return _db.tcurs_n == 0;
}

// --- amc.FDb.tcurs.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTcurs* amc::tcurs_Find(u64 t) {
    amc::FTcurs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tcurs_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tcurs_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.tcurs.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FTcurs* amc::tcurs_Last() {
    return tcurs_Find(u64(_db.tcurs_n-1));
}

// --- amc.FDb.tcurs.N
// Return number of items in the pool
inline i32 amc::tcurs_N() {
    return _db.tcurs_n;
}

// --- amc.FDb.tcurs.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FTcurs& amc::tcurs_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tcurs_lary[bsr][index];
}

// --- amc.FDb.nscpp.EmptyQ
// Return true if index is empty
inline bool amc::nscpp_EmptyQ() {
    return _db.nscpp_n == 0;
}

// --- amc.FDb.nscpp.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNscpp* amc::nscpp_Find(u64 t) {
    amc::FNscpp *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nscpp_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nscpp_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.nscpp.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FNscpp* amc::nscpp_Last() {
    return nscpp_Find(u64(_db.nscpp_n-1));
}

// --- amc.FDb.nscpp.N
// Return number of items in the pool
inline i32 amc::nscpp_N() {
    return _db.nscpp_n;
}

// --- amc.FDb.nscpp.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FNscpp& amc::nscpp_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nscpp_lary[bsr][index];
}

// --- amc.FDb.fflag.EmptyQ
// Return true if index is empty
inline bool amc::fflag_EmptyQ() {
    return _db.fflag_n == 0;
}

// --- amc.FDb.fflag.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFflag* amc::fflag_Find(u64 t) {
    amc::FFflag *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fflag_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fflag_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.fflag.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFflag* amc::fflag_Last() {
    return fflag_Find(u64(_db.fflag_n-1));
}

// --- amc.FDb.fflag.N
// Return number of items in the pool
inline i32 amc::fflag_N() {
    return _db.fflag_n;
}

// --- amc.FDb.fflag.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFflag& amc::fflag_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fflag_lary[bsr][index];
}

// --- amc.FDb.ind_fflag.EmptyQ
// Return true if hash is empty
inline bool amc::ind_fflag_EmptyQ() {
    return _db.ind_fflag_n == 0;
}

// --- amc.FDb.ind_fflag.N
// Return number of items in the hash
inline i32 amc::ind_fflag_N() {
    return _db.ind_fflag_n;
}

// --- amc.FDb.falias.EmptyQ
// Return true if index is empty
inline bool amc::falias_EmptyQ() {
    return _db.falias_n == 0;
}

// --- amc.FDb.falias.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFalias* amc::falias_Find(u64 t) {
    amc::FFalias *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.falias_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.falias_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.falias.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FFalias* amc::falias_Last() {
    return falias_Find(u64(_db.falias_n-1));
}

// --- amc.FDb.falias.N
// Return number of items in the pool
inline i32 amc::falias_N() {
    return _db.falias_n;
}

// --- amc.FDb.falias.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FFalias& amc::falias_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.falias_lary[bsr][index];
}

// --- amc.FDb.license.EmptyQ
// Return true if index is empty
inline bool amc::license_EmptyQ() {
    return _db.license_n == 0;
}

// --- amc.FDb.license.Find
// Look up row by row id. Return NULL if out of range
inline amc::FLicense* amc::license_Find(u64 t) {
    amc::FLicense *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.license_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.license_lary[bsr][index];
    }
    return retval;
}

// --- amc.FDb.license.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FLicense* amc::license_Last() {
    return license_Find(u64(_db.license_n-1));
}

// --- amc.FDb.license.N
// Return number of items in the pool
inline i32 amc::license_N() {
    return _db.license_n;
}

// --- amc.FDb.license.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FLicense& amc::license_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.license_lary[bsr][index];
}

// --- amc.FDb.ind_license.EmptyQ
// Return true if hash is empty
inline bool amc::ind_license_EmptyQ() {
    return _db.ind_license_n == 0;
}

// --- amc.FDb.ind_license.N
// Return number of items in the hash
inline i32 amc::ind_license_N() {
    return _db.ind_license_n;
}

// --- amc.FDb.c_ssimfile_sorted.EmptyQ
// Return true if index is empty
inline bool amc::c_ssimfile_sorted_EmptyQ() {
    return _db.c_ssimfile_sorted_n == 0;
}

// --- amc.FDb.c_ssimfile_sorted.Find
// Look up row by row id. Return NULL if out of range
inline amc::FSsimfile* amc::c_ssimfile_sorted_Find(u32 t) {
    amc::FSsimfile *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_ssimfile_sorted_n;
    if (idx < lim) {
        retval = _db.c_ssimfile_sorted_elems[idx];
    }
    return retval;
}

// --- amc.FDb.c_ssimfile_sorted.Getary
// Return array of pointers
inline algo::aryptr<amc::FSsimfile*> amc::c_ssimfile_sorted_Getary() {
    return algo::aryptr<amc::FSsimfile*>(_db.c_ssimfile_sorted_elems, _db.c_ssimfile_sorted_n);
}

// --- amc.FDb.c_ssimfile_sorted.N
// Return number of items in the pointer array
inline i32 amc::c_ssimfile_sorted_N() {
    return _db.c_ssimfile_sorted_n;
}

// --- amc.FDb.c_ssimfile_sorted.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ssimfile_sorted_RemoveAll() {
    for (u32 i = 0; i < _db.c_ssimfile_sorted_n; i++) {
        // mark all elements as not-in-array
        _db.c_ssimfile_sorted_elems[i]->_db_c_ssimfile_sorted_in_ary = false;
    }
    _db.c_ssimfile_sorted_n = 0;
}

// --- amc.FDb.c_ssimfile_sorted.qFind
// Return reference without bounds checking
inline amc::FSsimfile& amc::c_ssimfile_sorted_qFind(u32 idx) {
    return *_db.c_ssimfile_sorted_elems[idx];
}

// --- amc.FDb.c_ssimfile_sorted.InAryQ
// True if row is in any ptrary instance
inline bool amc::c_ssimfile_sorted_InAryQ(amc::FSsimfile& row) {
    return row._db_c_ssimfile_sorted_in_ary;
}

// --- amc.FDb.c_ssimfile_sorted.qLast
// Reference to last element without bounds checking
inline amc::FSsimfile& amc::c_ssimfile_sorted_qLast() {
    return *_db.c_ssimfile_sorted_elems[_db.c_ssimfile_sorted_n-1];
}

// --- amc.FDb.zd_ssimfile_todo.EmptyQ
// Return true if index is empty
inline bool amc::zd_ssimfile_todo_EmptyQ() {
    return _db.zd_ssimfile_todo_head == NULL;
}

// --- amc.FDb.zd_ssimfile_todo.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FSsimfile* amc::zd_ssimfile_todo_First() {
    amc::FSsimfile *row = NULL;
    row = _db.zd_ssimfile_todo_head;
    return row;
}

// --- amc.FDb.zd_ssimfile_todo.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zd_ssimfile_todo_InLlistQ(amc::FSsimfile& row) {
    bool result = false;
    result = !(row.zd_ssimfile_todo_next == (amc::FSsimfile*)-1);
    return result;
}

// --- amc.FDb.zd_ssimfile_todo.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FSsimfile* amc::zd_ssimfile_todo_Last() {
    amc::FSsimfile *row = NULL;
    row = _db.zd_ssimfile_todo_tail;
    return row;
}

// --- amc.FDb.zd_ssimfile_todo.N
// Return number of items in the linked list
inline i32 amc::zd_ssimfile_todo_N() {
    return _db.zd_ssimfile_todo_n;
}

// --- amc.FDb.zd_ssimfile_todo.Next
// Return pointer to next element in the list
inline amc::FSsimfile* amc::zd_ssimfile_todo_Next(amc::FSsimfile &row) {
    return row.zd_ssimfile_todo_next;
}

// --- amc.FDb.zd_ssimfile_todo.Prev
// Return pointer to previous element in the list
inline amc::FSsimfile* amc::zd_ssimfile_todo_Prev(amc::FSsimfile &row) {
    return row.zd_ssimfile_todo_prev;
}

// --- amc.FDb.zd_ssimfile_todo.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FSsimfile& amc::zd_ssimfile_todo_qLast() {
    amc::FSsimfile *row = NULL;
    row = _db.zd_ssimfile_todo_tail;
    return *row;
}

// --- amc.FDb.fsort_curs.Reset
// cursor points to valid item
inline void amc::_db_fsort_curs_Reset(_db_fsort_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fsort_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fsort_curs_ValidQ(_db_fsort_curs &curs) {
    return curs.index < _db.fsort_n;
}

// --- amc.FDb.fsort_curs.Next
// proceed to next item
inline void amc::_db_fsort_curs_Next(_db_fsort_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fsort_curs.Access
// item access
inline amc::FFsort& amc::_db_fsort_curs_Access(_db_fsort_curs &curs) {
    return fsort_qFind(u64(curs.index));
}

// --- amc.FDb.dispfilter_curs.Reset
// cursor points to valid item
inline void amc::_db_dispfilter_curs_Reset(_db_dispfilter_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.dispfilter_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_dispfilter_curs_ValidQ(_db_dispfilter_curs &curs) {
    return curs.index < _db.dispfilter_n;
}

// --- amc.FDb.dispfilter_curs.Next
// proceed to next item
inline void amc::_db_dispfilter_curs_Next(_db_dispfilter_curs &curs) {
    curs.index++;
}

// --- amc.FDb.dispfilter_curs.Access
// item access
inline amc::FDispfilter& amc::_db_dispfilter_curs_Access(_db_dispfilter_curs &curs) {
    return dispfilter_qFind(u64(curs.index));
}

// --- amc.FDb.usertracefld_curs.Reset
// cursor points to valid item
inline void amc::_db_usertracefld_curs_Reset(_db_usertracefld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.usertracefld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_usertracefld_curs_ValidQ(_db_usertracefld_curs &curs) {
    return curs.index < _db.usertracefld_n;
}

// --- amc.FDb.usertracefld_curs.Next
// proceed to next item
inline void amc::_db_usertracefld_curs_Next(_db_usertracefld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.usertracefld_curs.Access
// item access
inline amc::FUsertracefld& amc::_db_usertracefld_curs_Access(_db_usertracefld_curs &curs) {
    return usertracefld_qFind(u64(curs.index));
}

// --- amc.FDb.cfmt_curs.Reset
// cursor points to valid item
inline void amc::_db_cfmt_curs_Reset(_db_cfmt_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cfmt_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cfmt_curs_ValidQ(_db_cfmt_curs &curs) {
    return curs.index < _db.cfmt_n;
}

// --- amc.FDb.cfmt_curs.Next
// proceed to next item
inline void amc::_db_cfmt_curs_Next(_db_cfmt_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cfmt_curs.Access
// item access
inline amc::FCfmt& amc::_db_cfmt_curs_Access(_db_cfmt_curs &curs) {
    return cfmt_qFind(u64(curs.index));
}

// --- amc.FDb.dispatch_curs.Reset
// cursor points to valid item
inline void amc::_db_dispatch_curs_Reset(_db_dispatch_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.dispatch_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_dispatch_curs_ValidQ(_db_dispatch_curs &curs) {
    return curs.index < _db.dispatch_n;
}

// --- amc.FDb.dispatch_curs.Next
// proceed to next item
inline void amc::_db_dispatch_curs_Next(_db_dispatch_curs &curs) {
    curs.index++;
}

// --- amc.FDb.dispatch_curs.Access
// item access
inline amc::FDispatch& amc::_db_dispatch_curs_Access(_db_dispatch_curs &curs) {
    return dispatch_qFind(u64(curs.index));
}

// --- amc.FDb.dispatch_msg_curs.Reset
// cursor points to valid item
inline void amc::_db_dispatch_msg_curs_Reset(_db_dispatch_msg_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.dispatch_msg_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_dispatch_msg_curs_ValidQ(_db_dispatch_msg_curs &curs) {
    return curs.index < _db.dispatch_msg_n;
}

// --- amc.FDb.dispatch_msg_curs.Next
// proceed to next item
inline void amc::_db_dispatch_msg_curs_Next(_db_dispatch_msg_curs &curs) {
    curs.index++;
}

// --- amc.FDb.dispatch_msg_curs.Access
// item access
inline amc::FDispatchmsg& amc::_db_dispatch_msg_curs_Access(_db_dispatch_msg_curs &curs) {
    return dispatch_msg_qFind(u64(curs.index));
}

// --- amc.FDb.ctype_curs.Reset
// cursor points to valid item
inline void amc::_db_ctype_curs_Reset(_db_ctype_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- amc.FDb.ctype_curs.Next
// proceed to next item
inline void amc::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ctype_curs.Access
// item access
inline amc::FCtype& amc::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(u64(curs.index));
}

// --- amc.FDb.field_curs.Reset
// cursor points to valid item
inline void amc::_db_field_curs_Reset(_db_field_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- amc.FDb.field_curs.Next
// proceed to next item
inline void amc::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- amc.FDb.field_curs.Access
// item access
inline amc::FField& amc::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u64(curs.index));
}

// --- amc.FDb.basepool_curs.Reset
// cursor points to valid item
inline void amc::_db_basepool_curs_Reset(_db_basepool_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.basepool_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_basepool_curs_ValidQ(_db_basepool_curs &curs) {
    return curs.index < _db.basepool_n;
}

// --- amc.FDb.basepool_curs.Next
// proceed to next item
inline void amc::_db_basepool_curs_Next(_db_basepool_curs &curs) {
    curs.index++;
}

// --- amc.FDb.basepool_curs.Access
// item access
inline amc::FBasepool& amc::_db_basepool_curs_Access(_db_basepool_curs &curs) {
    return basepool_qFind(u64(curs.index));
}

// --- amc.FDb.llist_curs.Reset
// cursor points to valid item
inline void amc::_db_llist_curs_Reset(_db_llist_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.llist_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_llist_curs_ValidQ(_db_llist_curs &curs) {
    return curs.index < _db.llist_n;
}

// --- amc.FDb.llist_curs.Next
// proceed to next item
inline void amc::_db_llist_curs_Next(_db_llist_curs &curs) {
    curs.index++;
}

// --- amc.FDb.llist_curs.Access
// item access
inline amc::FLlist& amc::_db_llist_curs_Access(_db_llist_curs &curs) {
    return llist_qFind(u64(curs.index));
}

// --- amc.FDb.anonfld_curs.Reset
// cursor points to valid item
inline void amc::_db_anonfld_curs_Reset(_db_anonfld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.anonfld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_anonfld_curs_ValidQ(_db_anonfld_curs &curs) {
    return curs.index < _db.anonfld_n;
}

// --- amc.FDb.anonfld_curs.Next
// proceed to next item
inline void amc::_db_anonfld_curs_Next(_db_anonfld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.anonfld_curs.Access
// item access
inline amc::FAnonfld& amc::_db_anonfld_curs_Access(_db_anonfld_curs &curs) {
    return anonfld_qFind(u64(curs.index));
}

// --- amc.FDb.xref_curs.Reset
// cursor points to valid item
inline void amc::_db_xref_curs_Reset(_db_xref_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.xref_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_xref_curs_ValidQ(_db_xref_curs &curs) {
    return curs.index < _db.xref_n;
}

// --- amc.FDb.xref_curs.Next
// proceed to next item
inline void amc::_db_xref_curs_Next(_db_xref_curs &curs) {
    curs.index++;
}

// --- amc.FDb.xref_curs.Access
// item access
inline amc::FXref& amc::_db_xref_curs_Access(_db_xref_curs &curs) {
    return xref_qFind(u64(curs.index));
}

// --- amc.FDb.ns_curs.Reset
// cursor points to valid item
inline void amc::_db_ns_curs_Reset(_db_ns_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ns_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ns_curs_ValidQ(_db_ns_curs &curs) {
    return curs.index < _db.ns_n;
}

// --- amc.FDb.ns_curs.Next
// proceed to next item
inline void amc::_db_ns_curs_Next(_db_ns_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ns_curs.Access
// item access
inline amc::FNs& amc::_db_ns_curs_Access(_db_ns_curs &curs) {
    return ns_qFind(u64(curs.index));
}

// --- amc.FDb.pnew_curs.Reset
// cursor points to valid item
inline void amc::_db_pnew_curs_Reset(_db_pnew_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.pnew_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_pnew_curs_ValidQ(_db_pnew_curs &curs) {
    return curs.index < _db.pnew_n;
}

// --- amc.FDb.pnew_curs.Next
// proceed to next item
inline void amc::_db_pnew_curs_Next(_db_pnew_curs &curs) {
    curs.index++;
}

// --- amc.FDb.pnew_curs.Access
// item access
inline amc::FPnew& amc::_db_pnew_curs_Access(_db_pnew_curs &curs) {
    return pnew_qFind(u64(curs.index));
}

// --- amc.FDb.fldoffset_curs.Reset
// cursor points to valid item
inline void amc::_db_fldoffset_curs_Reset(_db_fldoffset_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fldoffset_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fldoffset_curs_ValidQ(_db_fldoffset_curs &curs) {
    return curs.index < _db.fldoffset_n;
}

// --- amc.FDb.fldoffset_curs.Next
// proceed to next item
inline void amc::_db_fldoffset_curs_Next(_db_fldoffset_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fldoffset_curs.Access
// item access
inline amc::FFldoffset& amc::_db_fldoffset_curs_Access(_db_fldoffset_curs &curs) {
    return fldoffset_qFind(u64(curs.index));
}

// --- amc.FDb.typefld_curs.Reset
// cursor points to valid item
inline void amc::_db_typefld_curs_Reset(_db_typefld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.typefld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_typefld_curs_ValidQ(_db_typefld_curs &curs) {
    return curs.index < _db.typefld_n;
}

// --- amc.FDb.typefld_curs.Next
// proceed to next item
inline void amc::_db_typefld_curs_Next(_db_typefld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.typefld_curs.Access
// item access
inline amc::FTypefld& amc::_db_typefld_curs_Access(_db_typefld_curs &curs) {
    return typefld_qFind(u64(curs.index));
}

// --- amc.FDb.lenfld_curs.Reset
// cursor points to valid item
inline void amc::_db_lenfld_curs_Reset(_db_lenfld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.lenfld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_lenfld_curs_ValidQ(_db_lenfld_curs &curs) {
    return curs.index < _db.lenfld_n;
}

// --- amc.FDb.lenfld_curs.Next
// proceed to next item
inline void amc::_db_lenfld_curs_Next(_db_lenfld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.lenfld_curs.Access
// item access
inline amc::FLenfld& amc::_db_lenfld_curs_Access(_db_lenfld_curs &curs) {
    return lenfld_qFind(u64(curs.index));
}

// --- amc.FDb.bltin_curs.Reset
// cursor points to valid item
inline void amc::_db_bltin_curs_Reset(_db_bltin_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.bltin_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_bltin_curs_ValidQ(_db_bltin_curs &curs) {
    return curs.index < _db.bltin_n;
}

// --- amc.FDb.bltin_curs.Next
// proceed to next item
inline void amc::_db_bltin_curs_Next(_db_bltin_curs &curs) {
    curs.index++;
}

// --- amc.FDb.bltin_curs.Access
// item access
inline amc::FBltin& amc::_db_bltin_curs_Access(_db_bltin_curs &curs) {
    return bltin_qFind(u64(curs.index));
}

// --- amc.FDb.static_tuple_curs.Reset
// cursor points to valid item
inline void amc::_db_static_tuple_curs_Reset(_db_static_tuple_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.static_tuple_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_static_tuple_curs_ValidQ(_db_static_tuple_curs &curs) {
    return curs.index < _db.static_tuple_n;
}

// --- amc.FDb.static_tuple_curs.Next
// proceed to next item
inline void amc::_db_static_tuple_curs_Next(_db_static_tuple_curs &curs) {
    curs.index++;
}

// --- amc.FDb.static_tuple_curs.Access
// item access
inline amc::FStatictuple& amc::_db_static_tuple_curs_Access(_db_static_tuple_curs &curs) {
    return static_tuple_qFind(u64(curs.index));
}

// --- amc.FDb.msgtype_curs.Reset
// cursor points to valid item
inline void amc::_db_msgtype_curs_Reset(_db_msgtype_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.msgtype_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_msgtype_curs_ValidQ(_db_msgtype_curs &curs) {
    return curs.index < _db.msgtype_n;
}

// --- amc.FDb.msgtype_curs.Next
// proceed to next item
inline void amc::_db_msgtype_curs_Next(_db_msgtype_curs &curs) {
    curs.index++;
}

// --- amc.FDb.msgtype_curs.Access
// item access
inline amc::FMsgtype& amc::_db_msgtype_curs_Access(_db_msgtype_curs &curs) {
    return msgtype_qFind(u64(curs.index));
}

// --- amc.FDb.gconst_curs.Reset
// cursor points to valid item
inline void amc::_db_gconst_curs_Reset(_db_gconst_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.gconst_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_gconst_curs_ValidQ(_db_gconst_curs &curs) {
    return curs.index < _db.gconst_n;
}

// --- amc.FDb.gconst_curs.Next
// proceed to next item
inline void amc::_db_gconst_curs_Next(_db_gconst_curs &curs) {
    curs.index++;
}

// --- amc.FDb.gconst_curs.Access
// item access
inline amc::FGconst& amc::_db_gconst_curs_Access(_db_gconst_curs &curs) {
    return gconst_qFind(u64(curs.index));
}

// --- amc.FDb.gstatic_curs.Reset
// cursor points to valid item
inline void amc::_db_gstatic_curs_Reset(_db_gstatic_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.gstatic_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_gstatic_curs_ValidQ(_db_gstatic_curs &curs) {
    return curs.index < _db.gstatic_n;
}

// --- amc.FDb.gstatic_curs.Next
// proceed to next item
inline void amc::_db_gstatic_curs_Next(_db_gstatic_curs &curs) {
    curs.index++;
}

// --- amc.FDb.gstatic_curs.Access
// item access
inline amc::FGstatic& amc::_db_gstatic_curs_Access(_db_gstatic_curs &curs) {
    return gstatic_qFind(u32(curs.index));
}

// --- amc.FDb.thash_curs.Reset
// cursor points to valid item
inline void amc::_db_thash_curs_Reset(_db_thash_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.thash_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_thash_curs_ValidQ(_db_thash_curs &curs) {
    return curs.index < _db.thash_n;
}

// --- amc.FDb.thash_curs.Next
// proceed to next item
inline void amc::_db_thash_curs_Next(_db_thash_curs &curs) {
    curs.index++;
}

// --- amc.FDb.thash_curs.Access
// item access
inline amc::FThash& amc::_db_thash_curs_Access(_db_thash_curs &curs) {
    return thash_qFind(u64(curs.index));
}

// --- amc.FDb.func_curs.Reset
// cursor points to valid item
inline void amc::_db_func_curs_Reset(_db_func_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.func_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_func_curs_ValidQ(_db_func_curs &curs) {
    return curs.index < _db.func_n;
}

// --- amc.FDb.func_curs.Next
// proceed to next item
inline void amc::_db_func_curs_Next(_db_func_curs &curs) {
    curs.index++;
}

// --- amc.FDb.func_curs.Access
// item access
inline amc::FFunc& amc::_db_func_curs_Access(_db_func_curs &curs) {
    return func_qFind(u64(curs.index));
}

// --- amc.FDb.smallstr_curs.Reset
// cursor points to valid item
inline void amc::_db_smallstr_curs_Reset(_db_smallstr_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.smallstr_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_smallstr_curs_ValidQ(_db_smallstr_curs &curs) {
    return curs.index < _db.smallstr_n;
}

// --- amc.FDb.smallstr_curs.Next
// proceed to next item
inline void amc::_db_smallstr_curs_Next(_db_smallstr_curs &curs) {
    curs.index++;
}

// --- amc.FDb.smallstr_curs.Access
// item access
inline amc::FSmallstr& amc::_db_smallstr_curs_Access(_db_smallstr_curs &curs) {
    return smallstr_qFind(u64(curs.index));
}

// --- amc.FDb.numstr_curs.Reset
// cursor points to valid item
inline void amc::_db_numstr_curs_Reset(_db_numstr_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.numstr_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_numstr_curs_ValidQ(_db_numstr_curs &curs) {
    return curs.index < _db.numstr_n;
}

// --- amc.FDb.numstr_curs.Next
// proceed to next item
inline void amc::_db_numstr_curs_Next(_db_numstr_curs &curs) {
    curs.index++;
}

// --- amc.FDb.numstr_curs.Access
// item access
inline amc::FNumstr& amc::_db_numstr_curs_Access(_db_numstr_curs &curs) {
    return numstr_qFind(u64(curs.index));
}

// --- amc.FDb.main_curs.Reset
// cursor points to valid item
inline void amc::_db_main_curs_Reset(_db_main_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.main_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_main_curs_ValidQ(_db_main_curs &curs) {
    return curs.index < _db.main_n;
}

// --- amc.FDb.main_curs.Next
// proceed to next item
inline void amc::_db_main_curs_Next(_db_main_curs &curs) {
    curs.index++;
}

// --- amc.FDb.main_curs.Access
// item access
inline amc::FMain& amc::_db_main_curs_Access(_db_main_curs &curs) {
    return main_qFind(u64(curs.index));
}

// --- amc.FDb.reftype_curs.Reset
// cursor points to valid item
inline void amc::_db_reftype_curs_Reset(_db_reftype_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.reftype_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_reftype_curs_ValidQ(_db_reftype_curs &curs) {
    return curs.index < _db.reftype_n;
}

// --- amc.FDb.reftype_curs.Next
// proceed to next item
inline void amc::_db_reftype_curs_Next(_db_reftype_curs &curs) {
    curs.index++;
}

// --- amc.FDb.reftype_curs.Access
// item access
inline amc::FReftype& amc::_db_reftype_curs_Access(_db_reftype_curs &curs) {
    return reftype_qFind(i32(curs.index));
}

// --- amc.FDb.cpptype_curs.Reset
// cursor points to valid item
inline void amc::_db_cpptype_curs_Reset(_db_cpptype_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cpptype_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cpptype_curs_ValidQ(_db_cpptype_curs &curs) {
    return curs.index < _db.cpptype_n;
}

// --- amc.FDb.cpptype_curs.Next
// proceed to next item
inline void amc::_db_cpptype_curs_Next(_db_cpptype_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cpptype_curs.Access
// item access
inline amc::FCpptype& amc::_db_cpptype_curs_Access(_db_cpptype_curs &curs) {
    return cpptype_qFind(u64(curs.index));
}

// --- amc.FDb.inlary_curs.Reset
// cursor points to valid item
inline void amc::_db_inlary_curs_Reset(_db_inlary_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.inlary_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_inlary_curs_ValidQ(_db_inlary_curs &curs) {
    return curs.index < _db.inlary_n;
}

// --- amc.FDb.inlary_curs.Next
// proceed to next item
inline void amc::_db_inlary_curs_Next(_db_inlary_curs &curs) {
    curs.index++;
}

// --- amc.FDb.inlary_curs.Access
// item access
inline amc::FInlary& amc::_db_inlary_curs_Access(_db_inlary_curs &curs) {
    return inlary_qFind(u64(curs.index));
}

// --- amc.FDb.tary_curs.Reset
// cursor points to valid item
inline void amc::_db_tary_curs_Reset(_db_tary_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.tary_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_tary_curs_ValidQ(_db_tary_curs &curs) {
    return curs.index < _db.tary_n;
}

// --- amc.FDb.tary_curs.Next
// proceed to next item
inline void amc::_db_tary_curs_Next(_db_tary_curs &curs) {
    curs.index++;
}

// --- amc.FDb.tary_curs.Access
// item access
inline amc::FTary& amc::_db_tary_curs_Access(_db_tary_curs &curs) {
    return tary_qFind(u64(curs.index));
}

// --- amc.FDb.cppfunc_curs.Reset
// cursor points to valid item
inline void amc::_db_cppfunc_curs_Reset(_db_cppfunc_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cppfunc_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cppfunc_curs_ValidQ(_db_cppfunc_curs &curs) {
    return curs.index < _db.cppfunc_n;
}

// --- amc.FDb.cppfunc_curs.Next
// proceed to next item
inline void amc::_db_cppfunc_curs_Next(_db_cppfunc_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cppfunc_curs.Access
// item access
inline amc::FCppfunc& amc::_db_cppfunc_curs_Access(_db_cppfunc_curs &curs) {
    return cppfunc_qFind(u64(curs.index));
}

// --- amc.FDb.rowid_curs.Reset
// cursor points to valid item
inline void amc::_db_rowid_curs_Reset(_db_rowid_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.rowid_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_rowid_curs_ValidQ(_db_rowid_curs &curs) {
    return curs.index < _db.rowid_n;
}

// --- amc.FDb.rowid_curs.Next
// proceed to next item
inline void amc::_db_rowid_curs_Next(_db_rowid_curs &curs) {
    curs.index++;
}

// --- amc.FDb.rowid_curs.Access
// item access
inline amc::FRowid& amc::_db_rowid_curs_Access(_db_rowid_curs &curs) {
    return rowid_qFind(u64(curs.index));
}

// --- amc.FDb.cascdel_curs.Reset
// cursor points to valid item
inline void amc::_db_cascdel_curs_Reset(_db_cascdel_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cascdel_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cascdel_curs_ValidQ(_db_cascdel_curs &curs) {
    return curs.index < _db.cascdel_n;
}

// --- amc.FDb.cascdel_curs.Next
// proceed to next item
inline void amc::_db_cascdel_curs_Next(_db_cascdel_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cascdel_curs.Access
// item access
inline amc::FCascdel& amc::_db_cascdel_curs_Access(_db_cascdel_curs &curs) {
    return cascdel_qFind(u64(curs.index));
}

// --- amc.FDb.substr_curs.Reset
// cursor points to valid item
inline void amc::_db_substr_curs_Reset(_db_substr_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.substr_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_substr_curs_ValidQ(_db_substr_curs &curs) {
    return curs.index < _db.substr_n;
}

// --- amc.FDb.substr_curs.Next
// proceed to next item
inline void amc::_db_substr_curs_Next(_db_substr_curs &curs) {
    curs.index++;
}

// --- amc.FDb.substr_curs.Access
// item access
inline amc::FSubstr& amc::_db_substr_curs_Access(_db_substr_curs &curs) {
    return substr_qFind(u64(curs.index));
}

// --- amc.FDb.bitfld_curs.Reset
// cursor points to valid item
inline void amc::_db_bitfld_curs_Reset(_db_bitfld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.bitfld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_bitfld_curs_ValidQ(_db_bitfld_curs &curs) {
    return curs.index < _db.bitfld_n;
}

// --- amc.FDb.bitfld_curs.Next
// proceed to next item
inline void amc::_db_bitfld_curs_Next(_db_bitfld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.bitfld_curs.Access
// item access
inline amc::FBitfld& amc::_db_bitfld_curs_Access(_db_bitfld_curs &curs) {
    return bitfld_qFind(u64(curs.index));
}

// --- amc.FDb.ssimfile_curs.Reset
// cursor points to valid item
inline void amc::_db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ssimfile_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) {
    return curs.index < _db.ssimfile_n;
}

// --- amc.FDb.ssimfile_curs.Next
// proceed to next item
inline void amc::_db_ssimfile_curs_Next(_db_ssimfile_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ssimfile_curs.Access
// item access
inline amc::FSsimfile& amc::_db_ssimfile_curs_Access(_db_ssimfile_curs &curs) {
    return ssimfile_qFind(u64(curs.index));
}

// --- amc.FDb.pack_curs.Reset
// cursor points to valid item
inline void amc::_db_pack_curs_Reset(_db_pack_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.pack_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_pack_curs_ValidQ(_db_pack_curs &curs) {
    return curs.index < _db.pack_n;
}

// --- amc.FDb.pack_curs.Next
// proceed to next item
inline void amc::_db_pack_curs_Next(_db_pack_curs &curs) {
    curs.index++;
}

// --- amc.FDb.pack_curs.Access
// item access
inline amc::FPack& amc::_db_pack_curs_Access(_db_pack_curs &curs) {
    return pack_qFind(u64(curs.index));
}

// --- amc.FDb.ptrary_curs.Reset
// cursor points to valid item
inline void amc::_db_ptrary_curs_Reset(_db_ptrary_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ptrary_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ptrary_curs_ValidQ(_db_ptrary_curs &curs) {
    return curs.index < _db.ptrary_n;
}

// --- amc.FDb.ptrary_curs.Next
// proceed to next item
inline void amc::_db_ptrary_curs_Next(_db_ptrary_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ptrary_curs.Access
// item access
inline amc::FPtrary& amc::_db_ptrary_curs_Access(_db_ptrary_curs &curs) {
    return ptrary_qFind(u64(curs.index));
}

// --- amc.FDb.c_ctype_sorted_curs.Reset
inline void amc::_db_c_ctype_sorted_curs_Reset(_db_c_ctype_sorted_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_ctype_sorted_elems;
    curs.n_elems = parent.c_ctype_sorted_n;
    curs.index = 0;
}

// --- amc.FDb.c_ctype_sorted_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_ctype_sorted_curs_ValidQ(_db_c_ctype_sorted_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_ctype_sorted_curs.Next
// proceed to next item
inline void amc::_db_c_ctype_sorted_curs_Next(_db_c_ctype_sorted_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_ctype_sorted_curs.Access
// item access
inline amc::FCtype& amc::_db_c_ctype_sorted_curs_Access(_db_c_ctype_sorted_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.enumstr_curs.Reset
// cursor points to valid item
inline void amc::_db_enumstr_curs_Reset(_db_enumstr_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.enumstr_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_enumstr_curs_ValidQ(_db_enumstr_curs &curs) {
    return curs.index < _db.enumstr_n;
}

// --- amc.FDb.enumstr_curs.Next
// proceed to next item
inline void amc::_db_enumstr_curs_Next(_db_enumstr_curs &curs) {
    curs.index++;
}

// --- amc.FDb.enumstr_curs.Access
// item access
inline amc::FEnumstr& amc::_db_enumstr_curs_Access(_db_enumstr_curs &curs) {
    return enumstr_qFind(u64(curs.index));
}

// --- amc.FDb.enumstr_len_curs.Reset
// cursor points to valid item
inline void amc::_db_enumstr_len_curs_Reset(_db_enumstr_len_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.enumstr_len_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_enumstr_len_curs_ValidQ(_db_enumstr_len_curs &curs) {
    return curs.index < _db.enumstr_len_n;
}

// --- amc.FDb.enumstr_len_curs.Next
// proceed to next item
inline void amc::_db_enumstr_len_curs_Next(_db_enumstr_len_curs &curs) {
    curs.index++;
}

// --- amc.FDb.enumstr_len_curs.Access
// item access
inline amc::FEnumstrLen& amc::_db_enumstr_len_curs_Access(_db_enumstr_len_curs &curs) {
    return enumstr_len_qFind(u64(curs.index));
}

// --- amc.FDb.bh_enumstr_len_curs.Access
// Access current element. If not more elements, return NULL
inline amc::FEnumstrLen& amc::_db_bh_enumstr_len_curs_Access(_db_bh_enumstr_len_curs &curs) {
    return *curs.temp_elems[0];
}

// --- amc.FDb.bh_enumstr_len_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool amc::_db_bh_enumstr_len_curs_ValidQ(_db_bh_enumstr_len_curs &curs) {
    return curs.temp_n > 0;
}

// --- amc.FDb.fbitset_curs.Reset
// cursor points to valid item
inline void amc::_db_fbitset_curs_Reset(_db_fbitset_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fbitset_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fbitset_curs_ValidQ(_db_fbitset_curs &curs) {
    return curs.index < _db.fbitset_n;
}

// --- amc.FDb.fbitset_curs.Next
// proceed to next item
inline void amc::_db_fbitset_curs_Next(_db_fbitset_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fbitset_curs.Access
// item access
inline amc::FFbitset& amc::_db_fbitset_curs_Access(_db_fbitset_curs &curs) {
    return fbitset_qFind(u64(curs.index));
}

// --- amc.FDb.fcleanup_curs.Reset
// cursor points to valid item
inline void amc::_db_fcleanup_curs_Reset(_db_fcleanup_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcleanup_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcleanup_curs_ValidQ(_db_fcleanup_curs &curs) {
    return curs.index < _db.fcleanup_n;
}

// --- amc.FDb.fcleanup_curs.Next
// proceed to next item
inline void amc::_db_fcleanup_curs_Next(_db_fcleanup_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcleanup_curs.Access
// item access
inline amc::FFcleanup& amc::_db_fcleanup_curs_Access(_db_fcleanup_curs &curs) {
    return fcleanup_qFind(u64(curs.index));
}

// --- amc.FDb.fdec_curs.Reset
// cursor points to valid item
inline void amc::_db_fdec_curs_Reset(_db_fdec_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fdec_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fdec_curs_ValidQ(_db_fdec_curs &curs) {
    return curs.index < _db.fdec_n;
}

// --- amc.FDb.fdec_curs.Next
// proceed to next item
inline void amc::_db_fdec_curs_Next(_db_fdec_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fdec_curs.Access
// item access
inline amc::FFdec& amc::_db_fdec_curs_Access(_db_fdec_curs &curs) {
    return fdec_qFind(u64(curs.index));
}

// --- amc.FDb.fconst_curs.Reset
// cursor points to valid item
inline void amc::_db_fconst_curs_Reset(_db_fconst_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fconst_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fconst_curs_ValidQ(_db_fconst_curs &curs) {
    return curs.index < _db.fconst_n;
}

// --- amc.FDb.fconst_curs.Next
// proceed to next item
inline void amc::_db_fconst_curs_Next(_db_fconst_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fconst_curs.Access
// item access
inline amc::FFconst& amc::_db_fconst_curs_Access(_db_fconst_curs &curs) {
    return fconst_qFind(u64(curs.index));
}

// --- amc.FDb.c_ns_sorted_curs.Reset
inline void amc::_db_c_ns_sorted_curs_Reset(_db_c_ns_sorted_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_ns_sorted_elems;
    curs.n_elems = parent.c_ns_sorted_n;
    curs.index = 0;
}

// --- amc.FDb.c_ns_sorted_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_ns_sorted_curs_ValidQ(_db_c_ns_sorted_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_ns_sorted_curs.Next
// proceed to next item
inline void amc::_db_c_ns_sorted_curs_Next(_db_c_ns_sorted_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_ns_sorted_curs.Access
// item access
inline amc::FNs& amc::_db_c_ns_sorted_curs_Access(_db_c_ns_sorted_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.finput_curs.Reset
// cursor points to valid item
inline void amc::_db_finput_curs_Reset(_db_finput_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.finput_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_finput_curs_ValidQ(_db_finput_curs &curs) {
    return curs.index < _db.finput_n;
}

// --- amc.FDb.finput_curs.Next
// proceed to next item
inline void amc::_db_finput_curs_Next(_db_finput_curs &curs) {
    curs.index++;
}

// --- amc.FDb.finput_curs.Access
// item access
inline amc::FFinput& amc::_db_finput_curs_Access(_db_finput_curs &curs) {
    return finput_qFind(u64(curs.index));
}

// --- amc.FDb.foutput_curs.Reset
// cursor points to valid item
inline void amc::_db_foutput_curs_Reset(_db_foutput_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.foutput_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_foutput_curs_ValidQ(_db_foutput_curs &curs) {
    return curs.index < _db.foutput_n;
}

// --- amc.FDb.foutput_curs.Next
// proceed to next item
inline void amc::_db_foutput_curs_Next(_db_foutput_curs &curs) {
    curs.index++;
}

// --- amc.FDb.foutput_curs.Access
// item access
inline amc::FFoutput& amc::_db_foutput_curs_Access(_db_foutput_curs &curs) {
    return foutput_qFind(u64(curs.index));
}

// --- amc.FDb.fbuf_curs.Reset
// cursor points to valid item
inline void amc::_db_fbuf_curs_Reset(_db_fbuf_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fbuf_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fbuf_curs_ValidQ(_db_fbuf_curs &curs) {
    return curs.index < _db.fbuf_n;
}

// --- amc.FDb.fbuf_curs.Next
// proceed to next item
inline void amc::_db_fbuf_curs_Next(_db_fbuf_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fbuf_curs.Access
// item access
inline amc::FFbuf& amc::_db_fbuf_curs_Access(_db_fbuf_curs &curs) {
    return fbuf_qFind(u64(curs.index));
}

// --- amc.FDb.chash_curs.Reset
// cursor points to valid item
inline void amc::_db_chash_curs_Reset(_db_chash_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.chash_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_chash_curs_ValidQ(_db_chash_curs &curs) {
    return curs.index < _db.chash_n;
}

// --- amc.FDb.chash_curs.Next
// proceed to next item
inline void amc::_db_chash_curs_Next(_db_chash_curs &curs) {
    curs.index++;
}

// --- amc.FDb.chash_curs.Access
// item access
inline amc::FChash& amc::_db_chash_curs_Access(_db_chash_curs &curs) {
    return chash_qFind(u64(curs.index));
}

// --- amc.FDb.ccmp_curs.Reset
// cursor points to valid item
inline void amc::_db_ccmp_curs_Reset(_db_ccmp_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ccmp_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ccmp_curs_ValidQ(_db_ccmp_curs &curs) {
    return curs.index < _db.ccmp_n;
}

// --- amc.FDb.ccmp_curs.Next
// proceed to next item
inline void amc::_db_ccmp_curs_Next(_db_ccmp_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ccmp_curs.Access
// item access
inline amc::FCcmp& amc::_db_ccmp_curs_Access(_db_ccmp_curs &curs) {
    return ccmp_qFind(u64(curs.index));
}

// --- amc.FDb.fbigend_curs.Reset
// cursor points to valid item
inline void amc::_db_fbigend_curs_Reset(_db_fbigend_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fbigend_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fbigend_curs_ValidQ(_db_fbigend_curs &curs) {
    return curs.index < _db.fbigend_n;
}

// --- amc.FDb.fbigend_curs.Next
// proceed to next item
inline void amc::_db_fbigend_curs_Next(_db_fbigend_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fbigend_curs.Access
// item access
inline amc::FFbigend& amc::_db_fbigend_curs_Access(_db_fbigend_curs &curs) {
    return fbigend_qFind(u64(curs.index));
}

// --- amc.FDb.zsl_ctype_pack_tran_curs.Reset
// cursor points to valid item
inline void amc::_db_zsl_ctype_pack_tran_curs_Reset(_db_zsl_ctype_pack_tran_curs &curs, amc::FDb &parent) {
    curs.row = parent.zsl_ctype_pack_tran_head;
}

// --- amc.FDb.zsl_ctype_pack_tran_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_zsl_ctype_pack_tran_curs_ValidQ(_db_zsl_ctype_pack_tran_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.zsl_ctype_pack_tran_curs.Next
// proceed to next item
inline void amc::_db_zsl_ctype_pack_tran_curs_Next(_db_zsl_ctype_pack_tran_curs &curs) {
    amc::FCtype *next = (*curs.row).zsl_ctype_pack_tran_next;
    curs.row = next;
}

// --- amc.FDb.zsl_ctype_pack_tran_curs.Access
// item access
inline amc::FCtype& amc::_db_zsl_ctype_pack_tran_curs_Access(_db_zsl_ctype_pack_tran_curs &curs) {
    return *curs.row;
}

// --- amc.FDb.cstr_curs.Reset
// cursor points to valid item
inline void amc::_db_cstr_curs_Reset(_db_cstr_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cstr_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cstr_curs_ValidQ(_db_cstr_curs &curs) {
    return curs.index < _db.cstr_n;
}

// --- amc.FDb.cstr_curs.Next
// proceed to next item
inline void amc::_db_cstr_curs_Next(_db_cstr_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cstr_curs.Access
// item access
inline amc::FCstr& amc::_db_cstr_curs_Access(_db_cstr_curs &curs) {
    return cstr_qFind(u64(curs.index));
}

// --- amc.FDb.listtype_curs.Reset
// cursor points to valid item
inline void amc::_db_listtype_curs_Reset(_db_listtype_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.listtype_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_listtype_curs_ValidQ(_db_listtype_curs &curs) {
    return curs.index < _db.listtype_n;
}

// --- amc.FDb.listtype_curs.Next
// proceed to next item
inline void amc::_db_listtype_curs_Next(_db_listtype_curs &curs) {
    curs.index++;
}

// --- amc.FDb.listtype_curs.Access
// item access
inline amc::FListtype& amc::_db_listtype_curs_Access(_db_listtype_curs &curs) {
    return listtype_qFind(u64(curs.index));
}

// --- amc.FDb.fstep_curs.Reset
// cursor points to valid item
inline void amc::_db_fstep_curs_Reset(_db_fstep_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fstep_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fstep_curs_ValidQ(_db_fstep_curs &curs) {
    return curs.index < _db.fstep_n;
}

// --- amc.FDb.fstep_curs.Next
// proceed to next item
inline void amc::_db_fstep_curs_Next(_db_fstep_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fstep_curs.Access
// item access
inline amc::FFstep& amc::_db_fstep_curs_Access(_db_fstep_curs &curs) {
    return fstep_qFind(u64(curs.index));
}

// --- amc.FDb.cextern_curs.Reset
// cursor points to valid item
inline void amc::_db_cextern_curs_Reset(_db_cextern_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cextern_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cextern_curs_ValidQ(_db_cextern_curs &curs) {
    return curs.index < _db.cextern_n;
}

// --- amc.FDb.cextern_curs.Next
// proceed to next item
inline void amc::_db_cextern_curs_Next(_db_cextern_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cextern_curs.Access
// item access
inline amc::FCextern& amc::_db_cextern_curs_Access(_db_cextern_curs &curs) {
    return cextern_qFind(u64(curs.index));
}

// --- amc.FDb.fdelay_curs.Reset
// cursor points to valid item
inline void amc::_db_fdelay_curs_Reset(_db_fdelay_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fdelay_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fdelay_curs_ValidQ(_db_fdelay_curs &curs) {
    return curs.index < _db.fdelay_n;
}

// --- amc.FDb.fdelay_curs.Next
// proceed to next item
inline void amc::_db_fdelay_curs_Next(_db_fdelay_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fdelay_curs.Access
// item access
inline amc::FFdelay& amc::_db_fdelay_curs_Access(_db_fdelay_curs &curs) {
    return fdelay_qFind(u64(curs.index));
}

// --- amc.FDb.disptrace_curs.Reset
// cursor points to valid item
inline void amc::_db_disptrace_curs_Reset(_db_disptrace_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.disptrace_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_disptrace_curs_ValidQ(_db_disptrace_curs &curs) {
    return curs.index < _db.disptrace_n;
}

// --- amc.FDb.disptrace_curs.Next
// proceed to next item
inline void amc::_db_disptrace_curs_Next(_db_disptrace_curs &curs) {
    curs.index++;
}

// --- amc.FDb.disptrace_curs.Access
// item access
inline amc::FDisptrace& amc::_db_disptrace_curs_Access(_db_disptrace_curs &curs) {
    return disptrace_qFind(u64(curs.index));
}

// --- amc.FDb.tracefld_curs.Reset
// cursor points to valid item
inline void amc::_db_tracefld_curs_Reset(_db_tracefld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.tracefld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_tracefld_curs_ValidQ(_db_tracefld_curs &curs) {
    return curs.index < _db.tracefld_n;
}

// --- amc.FDb.tracefld_curs.Next
// proceed to next item
inline void amc::_db_tracefld_curs_Next(_db_tracefld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.tracefld_curs.Access
// item access
inline amc::FTracefld& amc::_db_tracefld_curs_Access(_db_tracefld_curs &curs) {
    return tracefld_qFind(u64(curs.index));
}

// --- amc.FDb.tracerec_curs.Reset
// cursor points to valid item
inline void amc::_db_tracerec_curs_Reset(_db_tracerec_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.tracerec_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_tracerec_curs_ValidQ(_db_tracerec_curs &curs) {
    return curs.index < _db.tracerec_n;
}

// --- amc.FDb.tracerec_curs.Next
// proceed to next item
inline void amc::_db_tracerec_curs_Next(_db_tracerec_curs &curs) {
    curs.index++;
}

// --- amc.FDb.tracerec_curs.Access
// item access
inline amc::FTracerec& amc::_db_tracerec_curs_Access(_db_tracerec_curs &curs) {
    return tracerec_qFind(u64(curs.index));
}

// --- amc.FDb.dispsig_curs.Reset
// cursor points to valid item
inline void amc::_db_dispsig_curs_Reset(_db_dispsig_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.dispsig_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_dispsig_curs_ValidQ(_db_dispsig_curs &curs) {
    return curs.index < _db.dispsig_n;
}

// --- amc.FDb.dispsig_curs.Next
// proceed to next item
inline void amc::_db_dispsig_curs_Next(_db_dispsig_curs &curs) {
    curs.index++;
}

// --- amc.FDb.dispsig_curs.Access
// item access
inline amc::FDispsig& amc::_db_dispsig_curs_Access(_db_dispsig_curs &curs) {
    return dispsig_qFind(u64(curs.index));
}

// --- amc.FDb.c_dispsig_sorted_curs.Reset
inline void amc::_db_c_dispsig_sorted_curs_Reset(_db_c_dispsig_sorted_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_dispsig_sorted_elems;
    curs.n_elems = parent.c_dispsig_sorted_n;
    curs.index = 0;
}

// --- amc.FDb.c_dispsig_sorted_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_dispsig_sorted_curs_ValidQ(_db_c_dispsig_sorted_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_dispsig_sorted_curs.Next
// proceed to next item
inline void amc::_db_c_dispsig_sorted_curs_Next(_db_c_dispsig_sorted_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_dispsig_sorted_curs.Access
// item access
inline amc::FDispsig& amc::_db_c_dispsig_sorted_curs_Access(_db_c_dispsig_sorted_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.zs_sig_visit_curs.Reset
// cursor points to valid item
inline void amc::_db_zs_sig_visit_curs_Reset(_db_zs_sig_visit_curs &curs, amc::FDb &parent) {
    curs.row = parent.zs_sig_visit_head;
}

// --- amc.FDb.zs_sig_visit_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_zs_sig_visit_curs_ValidQ(_db_zs_sig_visit_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.zs_sig_visit_curs.Next
// proceed to next item
inline void amc::_db_zs_sig_visit_curs_Next(_db_zs_sig_visit_curs &curs) {
    amc::FCtype *next = (*curs.row).zs_sig_visit_next;
    curs.row = next;
}

// --- amc.FDb.zs_sig_visit_curs.Access
// item access
inline amc::FCtype& amc::_db_zs_sig_visit_curs_Access(_db_zs_sig_visit_curs &curs) {
    return *curs.row;
}

// --- amc.FDb.target_curs.Reset
// cursor points to valid item
inline void amc::_db_target_curs_Reset(_db_target_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.target_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_target_curs_ValidQ(_db_target_curs &curs) {
    return curs.index < _db.target_n;
}

// --- amc.FDb.target_curs.Next
// proceed to next item
inline void amc::_db_target_curs_Next(_db_target_curs &curs) {
    curs.index++;
}

// --- amc.FDb.target_curs.Access
// item access
inline amc::FTarget& amc::_db_target_curs_Access(_db_target_curs &curs) {
    return target_qFind(u64(curs.index));
}

// --- amc.FDb.targdep_curs.Reset
// cursor points to valid item
inline void amc::_db_targdep_curs_Reset(_db_targdep_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.targdep_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_targdep_curs_ValidQ(_db_targdep_curs &curs) {
    return curs.index < _db.targdep_n;
}

// --- amc.FDb.targdep_curs.Next
// proceed to next item
inline void amc::_db_targdep_curs_Next(_db_targdep_curs &curs) {
    curs.index++;
}

// --- amc.FDb.targdep_curs.Access
// item access
inline amc::FTargdep& amc::_db_targdep_curs_Access(_db_targdep_curs &curs) {
    return targdep_qFind(u64(curs.index));
}

// --- amc.FDb.dispctx_curs.Reset
// cursor points to valid item
inline void amc::_db_dispctx_curs_Reset(_db_dispctx_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.dispctx_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_dispctx_curs_ValidQ(_db_dispctx_curs &curs) {
    return curs.index < _db.dispctx_n;
}

// --- amc.FDb.dispctx_curs.Next
// proceed to next item
inline void amc::_db_dispctx_curs_Next(_db_dispctx_curs &curs) {
    curs.index++;
}

// --- amc.FDb.dispctx_curs.Access
// item access
inline amc::FDispctx& amc::_db_dispctx_curs_Access(_db_dispctx_curs &curs) {
    return dispctx_qFind(u64(curs.index));
}

// --- amc.FDb.pmaskfld_curs.Reset
// cursor points to valid item
inline void amc::_db_pmaskfld_curs_Reset(_db_pmaskfld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.pmaskfld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_pmaskfld_curs_ValidQ(_db_pmaskfld_curs &curs) {
    return curs.index < _db.pmaskfld_n;
}

// --- amc.FDb.pmaskfld_curs.Next
// proceed to next item
inline void amc::_db_pmaskfld_curs_Next(_db_pmaskfld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.pmaskfld_curs.Access
// item access
inline amc::FPmaskfld& amc::_db_pmaskfld_curs_Access(_db_pmaskfld_curs &curs) {
    return pmaskfld_qFind(u64(curs.index));
}

// --- amc.FDb.fwddecl_curs.Reset
// cursor points to valid item
inline void amc::_db_fwddecl_curs_Reset(_db_fwddecl_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fwddecl_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fwddecl_curs_ValidQ(_db_fwddecl_curs &curs) {
    return curs.index < _db.fwddecl_n;
}

// --- amc.FDb.fwddecl_curs.Next
// proceed to next item
inline void amc::_db_fwddecl_curs_Next(_db_fwddecl_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fwddecl_curs.Access
// item access
inline amc::FFwddecl& amc::_db_fwddecl_curs_Access(_db_fwddecl_curs &curs) {
    return fwddecl_qFind(u64(curs.index));
}

// --- amc.FDb.tfunc_curs.Reset
// cursor points to valid item
inline void amc::_db_tfunc_curs_Reset(_db_tfunc_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.tfunc_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_tfunc_curs_ValidQ(_db_tfunc_curs &curs) {
    return curs.index < _db.tfunc_n;
}

// --- amc.FDb.tfunc_curs.Next
// proceed to next item
inline void amc::_db_tfunc_curs_Next(_db_tfunc_curs &curs) {
    curs.index++;
}

// --- amc.FDb.tfunc_curs.Access
// item access
inline amc::FTfunc& amc::_db_tfunc_curs_Access(_db_tfunc_curs &curs) {
    return tfunc_qFind(u64(curs.index));
}

// --- amc.FDb.gen_curs.Reset
// cursor points to valid item
inline void amc::_db_gen_curs_Reset(_db_gen_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.gen_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_gen_curs_ValidQ(_db_gen_curs &curs) {
    return curs.index < _db.gen_n;
}

// --- amc.FDb.gen_curs.Next
// proceed to next item
inline void amc::_db_gen_curs_Next(_db_gen_curs &curs) {
    curs.index++;
}

// --- amc.FDb.gen_curs.Access
// item access
inline amc::FGen& amc::_db_gen_curs_Access(_db_gen_curs &curs) {
    return gen_qFind(u64(curs.index));
}

// --- amc.FDb.fregx_curs.Reset
// cursor points to valid item
inline void amc::_db_fregx_curs_Reset(_db_fregx_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fregx_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fregx_curs_ValidQ(_db_fregx_curs &curs) {
    return curs.index < _db.fregx_n;
}

// --- amc.FDb.fregx_curs.Next
// proceed to next item
inline void amc::_db_fregx_curs_Next(_db_fregx_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fregx_curs.Access
// item access
inline amc::FFregx& amc::_db_fregx_curs_Access(_db_fregx_curs &curs) {
    return fregx_qFind(u64(curs.index));
}

// --- amc.FDb.tclass_curs.Reset
// cursor points to valid item
inline void amc::_db_tclass_curs_Reset(_db_tclass_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.tclass_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_tclass_curs_ValidQ(_db_tclass_curs &curs) {
    return u64(curs.index) < u64(curs.parent->tclass_n);
}

// --- amc.FDb.tclass_curs.Next
// proceed to next item
inline void amc::_db_tclass_curs_Next(_db_tclass_curs &curs) {
    curs.index++;
}

// --- amc.FDb.tclass_curs.Access
// item access
inline amc::FTclass& amc::_db_tclass_curs_Access(_db_tclass_curs &curs) {
    return tclass_qFind(u64(curs.index));
}

// --- amc.FDb.fcmp_curs.Reset
// cursor points to valid item
inline void amc::_db_fcmp_curs_Reset(_db_fcmp_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcmp_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcmp_curs_ValidQ(_db_fcmp_curs &curs) {
    return curs.index < _db.fcmp_n;
}

// --- amc.FDb.fcmp_curs.Next
// proceed to next item
inline void amc::_db_fcmp_curs_Next(_db_fcmp_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcmp_curs.Access
// item access
inline amc::FFcmp& amc::_db_fcmp_curs_Access(_db_fcmp_curs &curs) {
    return fcmp_qFind(u64(curs.index));
}

// --- amc.FDb.fcast_curs.Reset
// cursor points to valid item
inline void amc::_db_fcast_curs_Reset(_db_fcast_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcast_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcast_curs_ValidQ(_db_fcast_curs &curs) {
    return curs.index < _db.fcast_n;
}

// --- amc.FDb.fcast_curs.Next
// proceed to next item
inline void amc::_db_fcast_curs_Next(_db_fcast_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcast_curs.Access
// item access
inline amc::FFcast& amc::_db_fcast_curs_Access(_db_fcast_curs &curs) {
    return fcast_qFind(u64(curs.index));
}

// --- amc.FDb.noxref_curs.Reset
// cursor points to valid item
inline void amc::_db_noxref_curs_Reset(_db_noxref_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.noxref_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_noxref_curs_ValidQ(_db_noxref_curs &curs) {
    return curs.index < _db.noxref_n;
}

// --- amc.FDb.noxref_curs.Next
// proceed to next item
inline void amc::_db_noxref_curs_Next(_db_noxref_curs &curs) {
    curs.index++;
}

// --- amc.FDb.noxref_curs.Access
// item access
inline amc::FNoxref& amc::_db_noxref_curs_Access(_db_noxref_curs &curs) {
    return noxref_qFind(u64(curs.index));
}

// --- amc.FDb.nocascdel_curs.Reset
// cursor points to valid item
inline void amc::_db_nocascdel_curs_Reset(_db_nocascdel_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nocascdel_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nocascdel_curs_ValidQ(_db_nocascdel_curs &curs) {
    return curs.index < _db.nocascdel_n;
}

// --- amc.FDb.nocascdel_curs.Next
// proceed to next item
inline void amc::_db_nocascdel_curs_Next(_db_nocascdel_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nocascdel_curs.Access
// item access
inline amc::FNocascdel& amc::_db_nocascdel_curs_Access(_db_nocascdel_curs &curs) {
    return nocascdel_qFind(u64(curs.index));
}

// --- amc.FDb.cafter_curs.Reset
// cursor points to valid item
inline void amc::_db_cafter_curs_Reset(_db_cafter_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cafter_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cafter_curs_ValidQ(_db_cafter_curs &curs) {
    return curs.index < _db.cafter_n;
}

// --- amc.FDb.cafter_curs.Next
// proceed to next item
inline void amc::_db_cafter_curs_Next(_db_cafter_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cafter_curs.Access
// item access
inline amc::FCafter& amc::_db_cafter_curs_Access(_db_cafter_curs &curs) {
    return cafter_qFind(u64(curs.index));
}

// --- amc.FDb.csize_curs.Reset
// cursor points to valid item
inline void amc::_db_csize_curs_Reset(_db_csize_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.csize_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_csize_curs_ValidQ(_db_csize_curs &curs) {
    return curs.index < _db.csize_n;
}

// --- amc.FDb.csize_curs.Next
// proceed to next item
inline void amc::_db_csize_curs_Next(_db_csize_curs &curs) {
    curs.index++;
}

// --- amc.FDb.csize_curs.Access
// item access
inline amc::FCsize& amc::_db_csize_curs_Access(_db_csize_curs &curs) {
    return csize_qFind(u64(curs.index));
}

// --- amc.FDb.nsx_curs.Reset
// cursor points to valid item
inline void amc::_db_nsx_curs_Reset(_db_nsx_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nsx_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nsx_curs_ValidQ(_db_nsx_curs &curs) {
    return curs.index < _db.nsx_n;
}

// --- amc.FDb.nsx_curs.Next
// proceed to next item
inline void amc::_db_nsx_curs_Next(_db_nsx_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nsx_curs.Access
// item access
inline amc::FNsx& amc::_db_nsx_curs_Access(_db_nsx_curs &curs) {
    return nsx_qFind(u64(curs.index));
}

// --- amc.FDb.fcompact_curs.Reset
// cursor points to valid item
inline void amc::_db_fcompact_curs_Reset(_db_fcompact_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcompact_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcompact_curs_ValidQ(_db_fcompact_curs &curs) {
    return curs.index < _db.fcompact_n;
}

// --- amc.FDb.fcompact_curs.Next
// proceed to next item
inline void amc::_db_fcompact_curs_Next(_db_fcompact_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcompact_curs.Access
// item access
inline amc::FFcompact& amc::_db_fcompact_curs_Access(_db_fcompact_curs &curs) {
    return fcompact_qFind(u64(curs.index));
}

// --- amc.FDb.findrem_curs.Reset
// cursor points to valid item
inline void amc::_db_findrem_curs_Reset(_db_findrem_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.findrem_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_findrem_curs_ValidQ(_db_findrem_curs &curs) {
    return curs.index < _db.findrem_n;
}

// --- amc.FDb.findrem_curs.Next
// proceed to next item
inline void amc::_db_findrem_curs_Next(_db_findrem_curs &curs) {
    curs.index++;
}

// --- amc.FDb.findrem_curs.Access
// item access
inline amc::FFindrem& amc::_db_findrem_curs_Access(_db_findrem_curs &curs) {
    return findrem_qFind(u64(curs.index));
}

// --- amc.FDb.fcurs_curs.Reset
// cursor points to valid item
inline void amc::_db_fcurs_curs_Reset(_db_fcurs_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcurs_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcurs_curs_ValidQ(_db_fcurs_curs &curs) {
    return curs.index < _db.fcurs_n;
}

// --- amc.FDb.fcurs_curs.Next
// proceed to next item
inline void amc::_db_fcurs_curs_Next(_db_fcurs_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcurs_curs.Access
// item access
inline amc::FFcurs& amc::_db_fcurs_curs_Access(_db_fcurs_curs &curs) {
    return fcurs_qFind(u64(curs.index));
}

// --- amc.FDb.cdflt_curs.Reset
// cursor points to valid item
inline void amc::_db_cdflt_curs_Reset(_db_cdflt_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cdflt_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cdflt_curs_ValidQ(_db_cdflt_curs &curs) {
    return curs.index < _db.cdflt_n;
}

// --- amc.FDb.cdflt_curs.Next
// proceed to next item
inline void amc::_db_cdflt_curs_Next(_db_cdflt_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cdflt_curs.Access
// item access
inline amc::FCdflt& amc::_db_cdflt_curs_Access(_db_cdflt_curs &curs) {
    return cdflt_qFind(u64(curs.index));
}

// --- amc.FDb.argvtype_curs.Reset
// cursor points to valid item
inline void amc::_db_argvtype_curs_Reset(_db_argvtype_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.argvtype_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_argvtype_curs_ValidQ(_db_argvtype_curs &curs) {
    return curs.index < _db.argvtype_n;
}

// --- amc.FDb.argvtype_curs.Next
// proceed to next item
inline void amc::_db_argvtype_curs_Next(_db_argvtype_curs &curs) {
    curs.index++;
}

// --- amc.FDb.argvtype_curs.Access
// item access
inline amc::FArgvtype& amc::_db_argvtype_curs_Access(_db_argvtype_curs &curs) {
    return argvtype_qFind(u64(curs.index));
}

// --- amc.FDb.fcmdline_curs.Reset
// cursor points to valid item
inline void amc::_db_fcmdline_curs_Reset(_db_fcmdline_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcmdline_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcmdline_curs_ValidQ(_db_fcmdline_curs &curs) {
    return curs.index < _db.fcmdline_n;
}

// --- amc.FDb.fcmdline_curs.Next
// proceed to next item
inline void amc::_db_fcmdline_curs_Next(_db_fcmdline_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcmdline_curs.Access
// item access
inline amc::FFcmdline& amc::_db_fcmdline_curs_Access(_db_fcmdline_curs &curs) {
    return fcmdline_qFind(u64(curs.index));
}

// --- amc.FDb.floadtuples_curs.Reset
// cursor points to valid item
inline void amc::_db_floadtuples_curs_Reset(_db_floadtuples_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.floadtuples_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_floadtuples_curs_ValidQ(_db_floadtuples_curs &curs) {
    return curs.index < _db.floadtuples_n;
}

// --- amc.FDb.floadtuples_curs.Next
// proceed to next item
inline void amc::_db_floadtuples_curs_Next(_db_floadtuples_curs &curs) {
    curs.index++;
}

// --- amc.FDb.floadtuples_curs.Access
// item access
inline amc::FFloadtuples& amc::_db_floadtuples_curs_Access(_db_floadtuples_curs &curs) {
    return floadtuples_qFind(u64(curs.index));
}

// --- amc.FDb.fcmap_curs.Reset
// cursor points to valid item
inline void amc::_db_fcmap_curs_Reset(_db_fcmap_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fcmap_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fcmap_curs_ValidQ(_db_fcmap_curs &curs) {
    return curs.index < _db.fcmap_n;
}

// --- amc.FDb.fcmap_curs.Next
// proceed to next item
inline void amc::_db_fcmap_curs_Next(_db_fcmap_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fcmap_curs.Access
// item access
inline amc::FFcmap& amc::_db_fcmap_curs_Access(_db_fcmap_curs &curs) {
    return fcmap_qFind(u64(curs.index));
}

// --- amc.FDb.zs_ordkeyfield_curs.Reset
// cursor points to valid item
inline void amc::_db_zs_ordkeyfield_curs_Reset(_db_zs_ordkeyfield_curs &curs, amc::FDb &parent) {
    curs.row = parent.zs_ordkeyfield_head;
}

// --- amc.FDb.zs_ordkeyfield_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_zs_ordkeyfield_curs_ValidQ(_db_zs_ordkeyfield_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.zs_ordkeyfield_curs.Next
// proceed to next item
inline void amc::_db_zs_ordkeyfield_curs_Next(_db_zs_ordkeyfield_curs &curs) {
    amc::FField *next = (*curs.row).zs_ordkeyfield_next;
    curs.row = next;
}

// --- amc.FDb.zs_ordkeyfield_curs.Access
// item access
inline amc::FField& amc::_db_zs_ordkeyfield_curs_Access(_db_zs_ordkeyfield_curs &curs) {
    return *curs.row;
}

// --- amc.FDb.nsproto_curs.Reset
// cursor points to valid item
inline void amc::_db_nsproto_curs_Reset(_db_nsproto_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nsproto_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nsproto_curs_ValidQ(_db_nsproto_curs &curs) {
    return curs.index < _db.nsproto_n;
}

// --- amc.FDb.nsproto_curs.Next
// proceed to next item
inline void amc::_db_nsproto_curs_Next(_db_nsproto_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nsproto_curs.Access
// item access
inline amc::FNsproto& amc::_db_nsproto_curs_Access(_db_nsproto_curs &curs) {
    return nsproto_qFind(u64(curs.index));
}

// --- amc.FDb.nsdb_curs.Reset
// cursor points to valid item
inline void amc::_db_nsdb_curs_Reset(_db_nsdb_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nsdb_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nsdb_curs_ValidQ(_db_nsdb_curs &curs) {
    return curs.index < _db.nsdb_n;
}

// --- amc.FDb.nsdb_curs.Next
// proceed to next item
inline void amc::_db_nsdb_curs_Next(_db_nsdb_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nsdb_curs.Access
// item access
inline amc::FNsdb& amc::_db_nsdb_curs_Access(_db_nsdb_curs &curs) {
    return nsdb_qFind(u64(curs.index));
}

// --- amc.FDb.zd_substr_params_curs.Reset
// cursor points to valid item
inline void amc::_db_zd_substr_params_curs_Reset(_db_zd_substr_params_curs &curs, amc::FDb &parent) {
    curs.row = parent.zd_substr_params_head;
}

// --- amc.FDb.zd_substr_params_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_zd_substr_params_curs_ValidQ(_db_zd_substr_params_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.zd_substr_params_curs.Next
// proceed to next item
inline void amc::_db_zd_substr_params_curs_Next(_db_zd_substr_params_curs &curs) {
    amc::FSubstr *next = (*curs.row).zd_substr_params_next;
    curs.row = next;
}

// --- amc.FDb.zd_substr_params_curs.Access
// item access
inline amc::FSubstr& amc::_db_zd_substr_params_curs_Access(_db_zd_substr_params_curs &curs) {
    return *curs.row;
}

// --- amc.FDb.fprefix_curs.Reset
// cursor points to valid item
inline void amc::_db_fprefix_curs_Reset(_db_fprefix_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fprefix_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fprefix_curs_ValidQ(_db_fprefix_curs &curs) {
    return curs.index < _db.fprefix_n;
}

// --- amc.FDb.fprefix_curs.Next
// proceed to next item
inline void amc::_db_fprefix_curs_Next(_db_fprefix_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fprefix_curs.Access
// item access
inline amc::FFprefix& amc::_db_fprefix_curs_Access(_db_fprefix_curs &curs) {
    return fprefix_qFind(u64(curs.index));
}

// --- amc.FDb.ftrace_curs.Reset
// cursor points to valid item
inline void amc::_db_ftrace_curs_Reset(_db_ftrace_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ftrace_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ftrace_curs_ValidQ(_db_ftrace_curs &curs) {
    return curs.index < _db.ftrace_n;
}

// --- amc.FDb.ftrace_curs.Next
// proceed to next item
inline void amc::_db_ftrace_curs_Next(_db_ftrace_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ftrace_curs.Access
// item access
inline amc::FFtrace& amc::_db_ftrace_curs_Access(_db_ftrace_curs &curs) {
    return ftrace_qFind(u64(curs.index));
}

// --- amc.FDb.fnoremove_curs.Reset
// cursor points to valid item
inline void amc::_db_fnoremove_curs_Reset(_db_fnoremove_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fnoremove_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fnoremove_curs_ValidQ(_db_fnoremove_curs &curs) {
    return curs.index < _db.fnoremove_n;
}

// --- amc.FDb.fnoremove_curs.Next
// proceed to next item
inline void amc::_db_fnoremove_curs_Next(_db_fnoremove_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fnoremove_curs.Access
// item access
inline amc::FFnoremove& amc::_db_fnoremove_curs_Access(_db_fnoremove_curs &curs) {
    return fnoremove_qFind(u64(curs.index));
}

// --- amc.FDb.c_substr_field_curs.Reset
inline void amc::_db_c_substr_field_curs_Reset(_db_c_substr_field_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_substr_field_elems;
    curs.n_elems = parent.c_substr_field_n;
    curs.index = 0;
}

// --- amc.FDb.c_substr_field_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_substr_field_curs_ValidQ(_db_c_substr_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_substr_field_curs.Next
// proceed to next item
inline void amc::_db_c_substr_field_curs_Next(_db_c_substr_field_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_substr_field_curs.Access
// item access
inline amc::FSubstr& amc::_db_c_substr_field_curs_Access(_db_c_substr_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.ctypelen_curs.Reset
// cursor points to valid item
inline void amc::_db_ctypelen_curs_Reset(_db_ctypelen_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ctypelen_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ctypelen_curs_ValidQ(_db_ctypelen_curs &curs) {
    return curs.index < _db.ctypelen_n;
}

// --- amc.FDb.ctypelen_curs.Next
// proceed to next item
inline void amc::_db_ctypelen_curs_Next(_db_ctypelen_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ctypelen_curs.Access
// item access
inline amc::FCtypelen& amc::_db_ctypelen_curs_Access(_db_ctypelen_curs &curs) {
    return ctypelen_qFind(u64(curs.index));
}

// --- amc.FDb.c_ctypelen_curs.Reset
inline void amc::_db_c_ctypelen_curs_Reset(_db_c_ctypelen_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_ctypelen_elems;
    curs.n_elems = parent.c_ctypelen_n;
    curs.index = 0;
}

// --- amc.FDb.c_ctypelen_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_ctypelen_curs_ValidQ(_db_c_ctypelen_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_ctypelen_curs.Next
// proceed to next item
inline void amc::_db_c_ctypelen_curs_Next(_db_c_ctypelen_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_ctypelen_curs.Access
// item access
inline amc::FCtypelen& amc::_db_c_ctypelen_curs_Access(_db_c_ctypelen_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.c_tempfield_curs.Reset
inline void amc::_db_c_tempfield_curs_Reset(_db_c_tempfield_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_tempfield_elems;
    curs.n_elems = parent.c_tempfield_n;
    curs.index = 0;
}

// --- amc.FDb.c_tempfield_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_tempfield_curs_ValidQ(_db_c_tempfield_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_tempfield_curs.Next
// proceed to next item
inline void amc::_db_c_tempfield_curs_Next(_db_c_tempfield_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_tempfield_curs.Access
// item access
inline amc::FField& amc::_db_c_tempfield_curs_Access(_db_c_tempfield_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.fbase_curs.Reset
// cursor points to valid item
inline void amc::_db_fbase_curs_Reset(_db_fbase_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fbase_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fbase_curs_ValidQ(_db_fbase_curs &curs) {
    return curs.index < _db.fbase_n;
}

// --- amc.FDb.fbase_curs.Next
// proceed to next item
inline void amc::_db_fbase_curs_Next(_db_fbase_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fbase_curs.Access
// item access
inline amc::FFbase& amc::_db_fbase_curs_Access(_db_fbase_curs &curs) {
    return fbase_qFind(u64(curs.index));
}

// --- amc.FDb.nossimfile_curs.Reset
// cursor points to valid item
inline void amc::_db_nossimfile_curs_Reset(_db_nossimfile_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nossimfile_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nossimfile_curs_ValidQ(_db_nossimfile_curs &curs) {
    return curs.index < _db.nossimfile_n;
}

// --- amc.FDb.nossimfile_curs.Next
// proceed to next item
inline void amc::_db_nossimfile_curs_Next(_db_nossimfile_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nossimfile_curs.Access
// item access
inline amc::FNossimfile& amc::_db_nossimfile_curs_Access(_db_nossimfile_curs &curs) {
    return nossimfile_qFind(u64(curs.index));
}

// --- amc.FDb.gsymbol_curs.Reset
// cursor points to valid item
inline void amc::_db_gsymbol_curs_Reset(_db_gsymbol_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.gsymbol_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_gsymbol_curs_ValidQ(_db_gsymbol_curs &curs) {
    return curs.index < _db.gsymbol_n;
}

// --- amc.FDb.gsymbol_curs.Next
// proceed to next item
inline void amc::_db_gsymbol_curs_Next(_db_gsymbol_curs &curs) {
    curs.index++;
}

// --- amc.FDb.gsymbol_curs.Access
// item access
inline amc::FGsymbol& amc::_db_gsymbol_curs_Access(_db_gsymbol_curs &curs) {
    return gsymbol_qFind(u64(curs.index));
}

// --- amc.FDb.sortfld_curs.Reset
// cursor points to valid item
inline void amc::_db_sortfld_curs_Reset(_db_sortfld_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.sortfld_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_sortfld_curs_ValidQ(_db_sortfld_curs &curs) {
    return curs.index < _db.sortfld_n;
}

// --- amc.FDb.sortfld_curs.Next
// proceed to next item
inline void amc::_db_sortfld_curs_Next(_db_sortfld_curs &curs) {
    curs.index++;
}

// --- amc.FDb.sortfld_curs.Access
// item access
inline amc::FSortfld& amc::_db_sortfld_curs_Access(_db_sortfld_curs &curs) {
    return sortfld_qFind(u64(curs.index));
}

// --- amc.FDb.cget_curs.Reset
// cursor points to valid item
inline void amc::_db_cget_curs_Reset(_db_cget_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.cget_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cget_curs_ValidQ(_db_cget_curs &curs) {
    return curs.index < _db.cget_n;
}

// --- amc.FDb.cget_curs.Next
// proceed to next item
inline void amc::_db_cget_curs_Next(_db_cget_curs &curs) {
    curs.index++;
}

// --- amc.FDb.cget_curs.Access
// item access
inline amc::FCget& amc::_db_cget_curs_Access(_db_cget_curs &curs) {
    return cget_qFind(u64(curs.index));
}

// --- amc.FDb.cd_temp_func_curs.Reset
// cursor points to valid item
inline void amc::_db_cd_temp_func_curs_Reset(_db_cd_temp_func_curs &curs, amc::FDb &parent) {
    curs.row = parent.cd_temp_func_head;
    curs.head = &parent.cd_temp_func_head;
}

// --- amc.FDb.cd_temp_func_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_cd_temp_func_curs_ValidQ(_db_cd_temp_func_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.cd_temp_func_curs.Next
// proceed to next item
inline void amc::_db_cd_temp_func_curs_Next(_db_cd_temp_func_curs &curs) {
    amc::FFunc *next = (*curs.row).cd_temp_func_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- amc.FDb.cd_temp_func_curs.Access
// item access
inline amc::FFunc& amc::_db_cd_temp_func_curs_Access(_db_cd_temp_func_curs &curs) {
    return *curs.row;
}

// --- amc.FDb.zs_gen_perns_curs.Reset
// cursor points to valid item
inline void amc::_db_zs_gen_perns_curs_Reset(_db_zs_gen_perns_curs &curs, amc::FDb &parent) {
    curs.row = parent.zs_gen_perns_head;
}

// --- amc.FDb.zs_gen_perns_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_zs_gen_perns_curs_ValidQ(_db_zs_gen_perns_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.zs_gen_perns_curs.Next
// proceed to next item
inline void amc::_db_zs_gen_perns_curs_Next(_db_zs_gen_perns_curs &curs) {
    amc::FGen *next = (*curs.row).zs_gen_perns_next;
    curs.row = next;
}

// --- amc.FDb.zs_gen_perns_curs.Access
// item access
inline amc::FGen& amc::_db_zs_gen_perns_curs_Access(_db_zs_gen_perns_curs &curs) {
    return *curs.row;
}

// --- amc.FDb.hook_curs.Reset
// cursor points to valid item
inline void amc::_db_hook_curs_Reset(_db_hook_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.hook_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_hook_curs_ValidQ(_db_hook_curs &curs) {
    return curs.index < _db.hook_n;
}

// --- amc.FDb.hook_curs.Next
// proceed to next item
inline void amc::_db_hook_curs_Next(_db_hook_curs &curs) {
    curs.index++;
}

// --- amc.FDb.hook_curs.Access
// item access
inline amc::FHook& amc::_db_hook_curs_Access(_db_hook_curs &curs) {
    return hook_qFind(u64(curs.index));
}

// --- amc.FDb.charset_curs.Reset
// cursor points to valid item
inline void amc::_db_charset_curs_Reset(_db_charset_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.charset_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_charset_curs_ValidQ(_db_charset_curs &curs) {
    return curs.index < _db.charset_n;
}

// --- amc.FDb.charset_curs.Next
// proceed to next item
inline void amc::_db_charset_curs_Next(_db_charset_curs &curs) {
    curs.index++;
}

// --- amc.FDb.charset_curs.Access
// item access
inline amc::FCharset& amc::_db_charset_curs_Access(_db_charset_curs &curs) {
    return charset_qFind(u64(curs.index));
}

// --- amc.FDb.nsinclude_curs.Reset
// cursor points to valid item
inline void amc::_db_nsinclude_curs_Reset(_db_nsinclude_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nsinclude_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nsinclude_curs_ValidQ(_db_nsinclude_curs &curs) {
    return curs.index < _db.nsinclude_n;
}

// --- amc.FDb.nsinclude_curs.Next
// proceed to next item
inline void amc::_db_nsinclude_curs_Next(_db_nsinclude_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nsinclude_curs.Access
// item access
inline amc::FNsinclude& amc::_db_nsinclude_curs_Access(_db_nsinclude_curs &curs) {
    return nsinclude_qFind(u64(curs.index));
}

// --- amc.FDb.ssimvolatile_curs.Reset
// cursor points to valid item
inline void amc::_db_ssimvolatile_curs_Reset(_db_ssimvolatile_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.ssimvolatile_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_ssimvolatile_curs_ValidQ(_db_ssimvolatile_curs &curs) {
    return curs.index < _db.ssimvolatile_n;
}

// --- amc.FDb.ssimvolatile_curs.Next
// proceed to next item
inline void amc::_db_ssimvolatile_curs_Next(_db_ssimvolatile_curs &curs) {
    curs.index++;
}

// --- amc.FDb.ssimvolatile_curs.Access
// item access
inline amc::FSsimvolatile& amc::_db_ssimvolatile_curs_Access(_db_ssimvolatile_curs &curs) {
    return ssimvolatile_qFind(u64(curs.index));
}

// --- amc.FDb.funique_curs.Reset
// cursor points to valid item
inline void amc::_db_funique_curs_Reset(_db_funique_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.funique_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_funique_curs_ValidQ(_db_funique_curs &curs) {
    return curs.index < _db.funique_n;
}

// --- amc.FDb.funique_curs.Next
// proceed to next item
inline void amc::_db_funique_curs_Next(_db_funique_curs &curs) {
    curs.index++;
}

// --- amc.FDb.funique_curs.Access
// item access
inline amc::FFunique& amc::_db_funique_curs_Access(_db_funique_curs &curs) {
    return funique_qFind(u64(curs.index));
}

// --- amc.FDb.fuserinit_curs.Reset
// cursor points to valid item
inline void amc::_db_fuserinit_curs_Reset(_db_fuserinit_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fuserinit_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fuserinit_curs_ValidQ(_db_fuserinit_curs &curs) {
    return curs.index < _db.fuserinit_n;
}

// --- amc.FDb.fuserinit_curs.Next
// proceed to next item
inline void amc::_db_fuserinit_curs_Next(_db_fuserinit_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fuserinit_curs.Access
// item access
inline amc::FFuserinit& amc::_db_fuserinit_curs_Access(_db_fuserinit_curs &curs) {
    return fuserinit_qFind(u64(curs.index));
}

// --- amc.FDb.tcurs_curs.Reset
// cursor points to valid item
inline void amc::_db_tcurs_curs_Reset(_db_tcurs_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.tcurs_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_tcurs_curs_ValidQ(_db_tcurs_curs &curs) {
    return curs.index < _db.tcurs_n;
}

// --- amc.FDb.tcurs_curs.Next
// proceed to next item
inline void amc::_db_tcurs_curs_Next(_db_tcurs_curs &curs) {
    curs.index++;
}

// --- amc.FDb.tcurs_curs.Access
// item access
inline amc::FTcurs& amc::_db_tcurs_curs_Access(_db_tcurs_curs &curs) {
    return tcurs_qFind(u64(curs.index));
}

// --- amc.FDb.nscpp_curs.Reset
// cursor points to valid item
inline void amc::_db_nscpp_curs_Reset(_db_nscpp_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.nscpp_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_nscpp_curs_ValidQ(_db_nscpp_curs &curs) {
    return curs.index < _db.nscpp_n;
}

// --- amc.FDb.nscpp_curs.Next
// proceed to next item
inline void amc::_db_nscpp_curs_Next(_db_nscpp_curs &curs) {
    curs.index++;
}

// --- amc.FDb.nscpp_curs.Access
// item access
inline amc::FNscpp& amc::_db_nscpp_curs_Access(_db_nscpp_curs &curs) {
    return nscpp_qFind(u64(curs.index));
}

// --- amc.FDb.fflag_curs.Reset
// cursor points to valid item
inline void amc::_db_fflag_curs_Reset(_db_fflag_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.fflag_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_fflag_curs_ValidQ(_db_fflag_curs &curs) {
    return curs.index < _db.fflag_n;
}

// --- amc.FDb.fflag_curs.Next
// proceed to next item
inline void amc::_db_fflag_curs_Next(_db_fflag_curs &curs) {
    curs.index++;
}

// --- amc.FDb.fflag_curs.Access
// item access
inline amc::FFflag& amc::_db_fflag_curs_Access(_db_fflag_curs &curs) {
    return fflag_qFind(u64(curs.index));
}

// --- amc.FDb.falias_curs.Reset
// cursor points to valid item
inline void amc::_db_falias_curs_Reset(_db_falias_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.falias_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_falias_curs_ValidQ(_db_falias_curs &curs) {
    return curs.index < _db.falias_n;
}

// --- amc.FDb.falias_curs.Next
// proceed to next item
inline void amc::_db_falias_curs_Next(_db_falias_curs &curs) {
    curs.index++;
}

// --- amc.FDb.falias_curs.Access
// item access
inline amc::FFalias& amc::_db_falias_curs_Access(_db_falias_curs &curs) {
    return falias_qFind(u64(curs.index));
}

// --- amc.FDb.license_curs.Reset
// cursor points to valid item
inline void amc::_db_license_curs_Reset(_db_license_curs &curs, amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FDb.license_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_license_curs_ValidQ(_db_license_curs &curs) {
    return curs.index < _db.license_n;
}

// --- amc.FDb.license_curs.Next
// proceed to next item
inline void amc::_db_license_curs_Next(_db_license_curs &curs) {
    curs.index++;
}

// --- amc.FDb.license_curs.Access
// item access
inline amc::FLicense& amc::_db_license_curs_Access(_db_license_curs &curs) {
    return license_qFind(u64(curs.index));
}

// --- amc.FDb.c_ssimfile_sorted_curs.Reset
inline void amc::_db_c_ssimfile_sorted_curs_Reset(_db_c_ssimfile_sorted_curs &curs, amc::FDb &parent) {
    curs.elems = parent.c_ssimfile_sorted_elems;
    curs.n_elems = parent.c_ssimfile_sorted_n;
    curs.index = 0;
}

// --- amc.FDb.c_ssimfile_sorted_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_c_ssimfile_sorted_curs_ValidQ(_db_c_ssimfile_sorted_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDb.c_ssimfile_sorted_curs.Next
// proceed to next item
inline void amc::_db_c_ssimfile_sorted_curs_Next(_db_c_ssimfile_sorted_curs &curs) {
    curs.index++;
}

// --- amc.FDb.c_ssimfile_sorted_curs.Access
// item access
inline amc::FSsimfile& amc::_db_c_ssimfile_sorted_curs_Access(_db_c_ssimfile_sorted_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FDb.zd_ssimfile_todo_curs.Reset
// cursor points to valid item
inline void amc::_db_zd_ssimfile_todo_curs_Reset(_db_zd_ssimfile_todo_curs &curs, amc::FDb &parent) {
    curs.row = parent.zd_ssimfile_todo_head;
}

// --- amc.FDb.zd_ssimfile_todo_curs.ValidQ
// cursor points to valid item
inline bool amc::_db_zd_ssimfile_todo_curs_ValidQ(_db_zd_ssimfile_todo_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FDb.zd_ssimfile_todo_curs.Next
// proceed to next item
inline void amc::_db_zd_ssimfile_todo_curs_Next(_db_zd_ssimfile_todo_curs &curs) {
    amc::FSsimfile *next = (*curs.row).zd_ssimfile_todo_next;
    curs.row = next;
}

// --- amc.FDb.zd_ssimfile_todo_curs.Access
// item access
inline amc::FSsimfile& amc::_db_zd_ssimfile_todo_curs_Access(_db_zd_ssimfile_todo_curs &curs) {
    return *curs.row;
}
inline amc::FDispatch::FDispatch() {
    amc::FDispatch_Init(*this);
}

inline amc::FDispatch::~FDispatch() {
    amc::FDispatch_Uninit(*this);
}


// --- amc.FDispatch.c_dispfilter.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_dispfilter_InsertMaybe(amc::FDispatch& dispatch, amc::FDispfilter& row) {
    amc::FDispfilter* ptr = dispatch.c_dispfilter;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        dispatch.c_dispfilter = &row;
    }
    return retval;
}

// --- amc.FDispatch.c_dispfilter.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_dispfilter_Remove(amc::FDispatch& dispatch, amc::FDispfilter& row) {
    amc::FDispfilter *ptr = dispatch.c_dispfilter;
    if (LIKELY(ptr == &row)) {
        dispatch.c_dispfilter = NULL;
    }
}

// --- amc.FDispatch.c_dispatch_msg.EmptyQ
// Return true if index is empty
inline bool amc::c_dispatch_msg_EmptyQ(amc::FDispatch& dispatch) {
    return dispatch.c_dispatch_msg_n == 0;
}

// --- amc.FDispatch.c_dispatch_msg.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispatchmsg* amc::c_dispatch_msg_Find(amc::FDispatch& dispatch, u32 t) {
    amc::FDispatchmsg *retval = NULL;
    u64 idx = t;
    u64 lim = dispatch.c_dispatch_msg_n;
    if (idx < lim) {
        retval = dispatch.c_dispatch_msg_elems[idx];
    }
    return retval;
}

// --- amc.FDispatch.c_dispatch_msg.Getary
// Return array of pointers
inline algo::aryptr<amc::FDispatchmsg*> amc::c_dispatch_msg_Getary(amc::FDispatch& dispatch) {
    return algo::aryptr<amc::FDispatchmsg*>(dispatch.c_dispatch_msg_elems, dispatch.c_dispatch_msg_n);
}

// --- amc.FDispatch.c_dispatch_msg.N
// Return number of items in the pointer array
inline i32 amc::c_dispatch_msg_N(const amc::FDispatch& dispatch) {
    return dispatch.c_dispatch_msg_n;
}

// --- amc.FDispatch.c_dispatch_msg.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_dispatch_msg_RemoveAll(amc::FDispatch& dispatch) {
    for (u32 i = 0; i < dispatch.c_dispatch_msg_n; i++) {
        // mark all elements as not-in-array
        dispatch.c_dispatch_msg_elems[i]->dispatch_c_dispatch_msg_in_ary = false;
    }
    dispatch.c_dispatch_msg_n = 0;
}

// --- amc.FDispatch.c_dispatch_msg.qFind
// Return reference without bounds checking
inline amc::FDispatchmsg& amc::c_dispatch_msg_qFind(amc::FDispatch& dispatch, u32 idx) {
    return *dispatch.c_dispatch_msg_elems[idx];
}

// --- amc.FDispatch.c_dispatch_msg.InAryQ
// True if row is in any ptrary instance
inline bool amc::dispatch_c_dispatch_msg_InAryQ(amc::FDispatchmsg& row) {
    return row.dispatch_c_dispatch_msg_in_ary;
}

// --- amc.FDispatch.c_dispatch_msg.qLast
// Reference to last element without bounds checking
inline amc::FDispatchmsg& amc::c_dispatch_msg_qLast(amc::FDispatch& dispatch) {
    return *dispatch.c_dispatch_msg_elems[dispatch.c_dispatch_msg_n-1];
}

// --- amc.FDispatch.c_disptrace.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_disptrace_InsertMaybe(amc::FDispatch& dispatch, amc::FDisptrace& row) {
    amc::FDisptrace* ptr = dispatch.c_disptrace;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        dispatch.c_disptrace = &row;
    }
    return retval;
}

// --- amc.FDispatch.c_disptrace.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_disptrace_Remove(amc::FDispatch& dispatch, amc::FDisptrace& row) {
    amc::FDisptrace *ptr = dispatch.c_disptrace;
    if (LIKELY(ptr == &row)) {
        dispatch.c_disptrace = NULL;
    }
}

// --- amc.FDispatch.c_dispctx.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_dispctx_InsertMaybe(amc::FDispatch& dispatch, amc::FDispctx& row) {
    amc::FDispctx* ptr = dispatch.c_dispctx;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        dispatch.c_dispctx = &row;
    }
    return retval;
}

// --- amc.FDispatch.c_dispctx.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_dispctx_Remove(amc::FDispatch& dispatch, amc::FDispctx& row) {
    amc::FDispctx *ptr = dispatch.c_dispctx;
    if (LIKELY(ptr == &row)) {
        dispatch.c_dispctx = NULL;
    }
}

// --- amc.FDispatch.c_dispatch_msg_curs.Reset
inline void amc::dispatch_c_dispatch_msg_curs_Reset(dispatch_c_dispatch_msg_curs &curs, amc::FDispatch &parent) {
    curs.elems = parent.c_dispatch_msg_elems;
    curs.n_elems = parent.c_dispatch_msg_n;
    curs.index = 0;
}

// --- amc.FDispatch.c_dispatch_msg_curs.ValidQ
// cursor points to valid item
inline bool amc::dispatch_c_dispatch_msg_curs_ValidQ(dispatch_c_dispatch_msg_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FDispatch.c_dispatch_msg_curs.Next
// proceed to next item
inline void amc::dispatch_c_dispatch_msg_curs_Next(dispatch_c_dispatch_msg_curs &curs) {
    curs.index++;
}

// --- amc.FDispatch.c_dispatch_msg_curs.Access
// item access
inline amc::FDispatchmsg& amc::dispatch_c_dispatch_msg_curs_Access(dispatch_c_dispatch_msg_curs &curs) {
    return *curs.elems[curs.index];
}
inline amc::FDispatchmsg::FDispatchmsg() {
    amc::FDispatchmsg_Init(*this);
}

inline amc::FDispatchmsg::~FDispatchmsg() {
    amc::FDispatchmsg_Uninit(*this);
}


// --- amc.FDispatchmsg..Init
// Set all fields to initial values.
inline void amc::FDispatchmsg_Init(amc::FDispatchmsg& dispatch_msg) {
    dispatch_msg.p_ctype = NULL;
    dispatch_msg.p_dispatch = NULL;
    dispatch_msg.dispatch_c_dispatch_msg_in_ary = bool(false);
}
inline amc::FDispctx::FDispctx() {
    amc::FDispctx_Init(*this);
}

inline amc::FDispctx::~FDispctx() {
    amc::FDispctx_Uninit(*this);
}


// --- amc.FDispctx..Init
// Set all fields to initial values.
inline void amc::FDispctx_Init(amc::FDispctx& dispctx) {
    dispctx.p_ctype = NULL;
}
inline amc::FDispfilter::FDispfilter() {
    amc::FDispfilter_Init(*this);
}

inline amc::FDispfilter::~FDispfilter() {
    amc::FDispfilter_Uninit(*this);
}


// --- amc.FDispfilter..Init
// Set all fields to initial values.
inline void amc::FDispfilter_Init(amc::FDispfilter& dispfilter) {
    dispfilter.match_all = bool(false);
}
inline amc::FDispsig::FDispsig() {
    amc::FDispsig_Init(*this);
}

inline amc::FDispsig::~FDispsig() {
    amc::FDispsig_Uninit(*this);
}


// --- amc.FDispsig..Init
// Set all fields to initial values.
inline void amc::FDispsig_Init(amc::FDispsig& dispsig) {
    dispsig._db_c_dispsig_sorted_in_ary = bool(false);
    dispsig.ns_c_dispsig_in_ary = bool(false);
}
inline amc::FDisptrace::FDisptrace() {
    amc::FDisptrace_Init(*this);
}

inline amc::FDisptrace::~FDisptrace() {
    amc::FDisptrace_Uninit(*this);
}


// --- amc.FDisptrace..Init
// Set all fields to initial values.
inline void amc::FDisptrace_Init(amc::FDisptrace& disptrace) {
    disptrace.cycle = bool(false);
    disptrace.p_dispatch = NULL;
}
inline amc::FEnumstr::FEnumstr() {
    amc::FEnumstr_Init(*this);
}

inline amc::FEnumstr::~FEnumstr() {
    amc::FEnumstr_Uninit(*this);
}


// --- amc.FEnumstr.c_fconst.EmptyQ
// Return true if index is empty
inline bool amc::c_fconst_EmptyQ(amc::FEnumstr& enumstr) {
    return enumstr.c_fconst_n == 0;
}

// --- amc.FEnumstr.c_fconst.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFconst* amc::c_fconst_Find(amc::FEnumstr& enumstr, u32 t) {
    amc::FFconst *retval = NULL;
    u64 idx = t;
    u64 lim = enumstr.c_fconst_n;
    if (idx < lim) {
        retval = enumstr.c_fconst_elems[idx];
    }
    return retval;
}

// --- amc.FEnumstr.c_fconst.Getary
// Return array of pointers
inline algo::aryptr<amc::FFconst*> amc::c_fconst_Getary(amc::FEnumstr& enumstr) {
    return algo::aryptr<amc::FFconst*>(enumstr.c_fconst_elems, enumstr.c_fconst_n);
}

// --- amc.FEnumstr.c_fconst.N
// Return number of items in the pointer array
inline i32 amc::c_fconst_N(const amc::FEnumstr& enumstr) {
    return enumstr.c_fconst_n;
}

// --- amc.FEnumstr.c_fconst.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_fconst_RemoveAll(amc::FEnumstr& enumstr) {
    enumstr.c_fconst_n = 0;
}

// --- amc.FEnumstr.c_fconst.qFind
// Return reference without bounds checking
inline amc::FFconst& amc::c_fconst_qFind(amc::FEnumstr& enumstr, u32 idx) {
    return *enumstr.c_fconst_elems[idx];
}

// --- amc.FEnumstr.c_fconst.qLast
// Reference to last element without bounds checking
inline amc::FFconst& amc::c_fconst_qLast(amc::FEnumstr& enumstr) {
    return *enumstr.c_fconst_elems[enumstr.c_fconst_n-1];
}

// --- amc.FEnumstr..Init
// Set all fields to initial values.
inline void amc::FEnumstr_Init(amc::FEnumstr& enumstr) {
    enumstr.c_fconst_elems = NULL; // (amc.FEnumstr.c_fconst)
    enumstr.c_fconst_n = 0; // (amc.FEnumstr.c_fconst)
    enumstr.c_fconst_max = 0; // (amc.FEnumstr.c_fconst)
    enumstr.ind_enumstr_next = (amc::FEnumstr*)-1; // (amc.FDb.ind_enumstr) not-in-hash
    enumstr.bh_enumstr_idx = -1; // (amc.FEnumstrLen.bh_enumstr) not-in-heap
}

// --- amc.FEnumstr.c_fconst_curs.Reset
inline void amc::enumstr_c_fconst_curs_Reset(enumstr_c_fconst_curs &curs, amc::FEnumstr &parent) {
    curs.elems = parent.c_fconst_elems;
    curs.n_elems = parent.c_fconst_n;
    curs.index = 0;
}

// --- amc.FEnumstr.c_fconst_curs.ValidQ
// cursor points to valid item
inline bool amc::enumstr_c_fconst_curs_ValidQ(enumstr_c_fconst_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FEnumstr.c_fconst_curs.Next
// proceed to next item
inline void amc::enumstr_c_fconst_curs_Next(enumstr_c_fconst_curs &curs) {
    curs.index++;
}

// --- amc.FEnumstr.c_fconst_curs.Access
// item access
inline amc::FFconst& amc::enumstr_c_fconst_curs_Access(enumstr_c_fconst_curs &curs) {
    return *curs.elems[curs.index];
}
inline amc::FEnumstrLen::FEnumstrLen() {
    amc::FEnumstrLen_Init(*this);
}

inline amc::FEnumstrLen::~FEnumstrLen() {
    amc::FEnumstrLen_Uninit(*this);
}


// --- amc.FEnumstrLen.bh_enumstr.EmptyQ
// Return true if index is empty
inline bool amc::bh_enumstr_EmptyQ(amc::FEnumstrLen& enumstr_len) {
    return enumstr_len.bh_enumstr_n == 0;
}

// --- amc.FEnumstrLen.bh_enumstr.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FEnumstr* amc::bh_enumstr_First(amc::FEnumstrLen& enumstr_len) {
    amc::FEnumstr *row = NULL;
    if (enumstr_len.bh_enumstr_n > 0) {
        row = enumstr_len.bh_enumstr_elems[0];
    }
    return row;
}

// --- amc.FEnumstrLen.bh_enumstr.InBheapQ
// Return true if row is in index, false otherwise
inline bool amc::bh_enumstr_InBheapQ(amc::FEnumstr& row) {
    bool result = false;
    result = row.bh_enumstr_idx != -1;
    return result;
}

// --- amc.FEnumstrLen.bh_enumstr.N
// Return number of items in the heap
inline i32 amc::bh_enumstr_N(const amc::FEnumstrLen& enumstr_len) {
    return enumstr_len.bh_enumstr_n;
}

// --- amc.FEnumstrLen..Init
// Set all fields to initial values.
inline void amc::FEnumstrLen_Init(amc::FEnumstrLen& enumstr_len) {
    enumstr_len.len = i32(0);
    enumstr_len.bh_enumstr_max   	= 0; // (amc.FEnumstrLen.bh_enumstr)
    enumstr_len.bh_enumstr_n     	= 0; // (amc.FEnumstrLen.bh_enumstr)
    enumstr_len.bh_enumstr_elems 	= NULL; // (amc.FEnumstrLen.bh_enumstr)
    enumstr_len.bh_enumstr_len_idx = -1; // (amc.FDb.bh_enumstr_len) not-in-heap
    enumstr_len.ind_enumstr_len_next = (amc::FEnumstrLen*)-1; // (amc.FDb.ind_enumstr_len) not-in-hash
}

// --- amc.FEnumstrLen.bh_enumstr_curs.Access
// Access current element. If not more elements, return NULL
inline amc::FEnumstr& amc::enumstr_len_bh_enumstr_curs_Access(enumstr_len_bh_enumstr_curs &curs) {
    return *curs.temp_elems[0];
}

// --- amc.FEnumstrLen.bh_enumstr_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool amc::enumstr_len_bh_enumstr_curs_ValidQ(enumstr_len_bh_enumstr_curs &curs) {
    return curs.temp_n > 0;
}
inline amc::FFalias::FFalias() {
    amc::FFalias_Init(*this);
}

inline amc::FFalias::~FFalias() {
    amc::FFalias_Uninit(*this);
}


// --- amc.FFalias..Init
// Set all fields to initial values.
inline void amc::FFalias_Init(amc::FFalias& falias) {
    falias.p_srcfield = NULL;
}
inline amc::FFbase::FFbase() {
    amc::FFbase_Init(*this);
}

inline amc::FFbase::~FFbase() {
    amc::FFbase_Uninit(*this);
}


// --- amc.FFbase..Init
// Set all fields to initial values.
inline void amc::FFbase_Init(amc::FFbase& fbase) {
    fbase.stripcomment = bool(false);
}
inline amc::FFbigend::FFbigend() {
    amc::FFbigend_Init(*this);
}

inline amc::FFbigend::~FFbigend() {
    amc::FFbigend_Uninit(*this);
}


// --- amc.FFbigend..Init
// Set all fields to initial values.
inline void amc::FFbigend_Init(amc::FFbigend& fbigend) {
    fbigend.p_field = NULL;
}
inline amc::FFbitset::FFbitset() {
    amc::FFbitset_Init(*this);
}

inline amc::FFbitset::~FFbitset() {
    amc::FFbitset_Uninit(*this);
}


// --- amc.FFbitset..Init
// Set all fields to initial values.
inline void amc::FFbitset_Init(amc::FFbitset& fbitset) {
    fbitset.p_field = NULL;
    fbitset.ind_fbitset_next = (amc::FFbitset*)-1; // (amc.FDb.ind_fbitset) not-in-hash
}
inline amc::FFbuf::FFbuf() {
    amc::FFbuf_Init(*this);
}

inline amc::FFbuf::~FFbuf() {
    amc::FFbuf_Uninit(*this);
}


// --- amc.FFbuf..Init
// Set all fields to initial values.
inline void amc::FFbuf_Init(amc::FFbuf& fbuf) {
    fbuf.max = u32(0);
    fbuf.p_insready = NULL;
    fbuf.p_inseof = NULL;
    fbuf.ind_fbuf_next = (amc::FFbuf*)-1; // (amc.FDb.ind_fbuf) not-in-hash
}
inline amc::FFcast::FFcast() {
}

inline amc::FFcast::~FFcast() {
    amc::FFcast_Uninit(*this);
}

inline amc::FFcleanup::FFcleanup() {
    amc::FFcleanup_Init(*this);
}

inline amc::FFcleanup::~FFcleanup() {
    amc::FFcleanup_Uninit(*this);
}


// --- amc.FFcleanup..Init
// Set all fields to initial values.
inline void amc::FFcleanup_Init(amc::FFcleanup& fcleanup) {
    fcleanup.p_field = NULL;
}
inline amc::FFcmap::FFcmap() {
    amc::FFcmap_Init(*this);
}

inline amc::FFcmap::~FFcmap() {
    amc::FFcmap_Uninit(*this);
}

inline amc::FFcmdline::FFcmdline() {
    amc::FFcmdline_Init(*this);
}

inline amc::FFcmdline::~FFcmdline() {
    amc::FFcmdline_Uninit(*this);
}


// --- amc.FFcmdline..Init
// Set all fields to initial values.
inline void amc::FFcmdline_Init(amc::FFcmdline& fcmdline) {
    fcmdline.read = bool(true);
    fcmdline.p_field = NULL;
    fcmdline.p_ns = NULL;
    fcmdline.p_basecmdline = NULL;
}
inline amc::FFcmp::FFcmp() {
    amc::FFcmp_Init(*this);
}

inline amc::FFcmp::~FFcmp() {
    amc::FFcmp_Uninit(*this);
}


// --- amc.FFcmp..Init
// Set all fields to initial values.
inline void amc::FFcmp_Init(amc::FFcmp& fcmp) {
    fcmp.versionsort = bool(false);
    fcmp.casesens = bool(true);
    fcmp.extrn = bool(false);
}
inline amc::FFcompact::FFcompact() {
}

inline amc::FFcompact::~FFcompact() {
    amc::FFcompact_Uninit(*this);
}

inline amc::FFconst::FFconst() {
    amc::FFconst_Init(*this);
}

inline amc::FFconst::~FFconst() {
    amc::FFconst_Uninit(*this);
}

inline amc::FFcurs::FFcurs() {
    amc::FFcurs_Init(*this);
}

inline amc::FFcurs::~FFcurs() {
    amc::FFcurs_Uninit(*this);
}


// --- amc.FFcurs..Init
// Set all fields to initial values.
inline void amc::FFcurs_Init(amc::FFcurs& fcurs) {
    fcurs.p_field = NULL;
    fcurs.ctype_c_fcurs_in_ary = bool(false);
    fcurs.ind_fcurs_next = (amc::FFcurs*)-1; // (amc.FDb.ind_fcurs) not-in-hash
}
inline amc::FFdec::FFdec() {
    amc::FFdec_Init(*this);
}

inline amc::FFdec::~FFdec() {
    amc::FFdec_Uninit(*this);
}


// --- amc.FFdec..Init
// Set all fields to initial values.
inline void amc::FFdec_Init(amc::FFdec& fdec) {
    fdec.nplace = i32(0);
    fdec.fixedfmt = bool(false);
    fdec.p_field = NULL;
    fdec.ind_fdec_next = (amc::FFdec*)-1; // (amc.FDb.ind_fdec) not-in-hash
}
inline amc::FFdelay::FFdelay() {
    amc::FFdelay_Init(*this);
}

inline amc::FFdelay::~FFdelay() {
    amc::FFdelay_Uninit(*this);
}


// --- amc.FFdelay..Init
// Set all fields to initial values.
inline void amc::FFdelay_Init(amc::FFdelay& fdelay) {
    fdelay.scale = bool(false);
}
inline amc::FFflag::FFflag() {
    amc::FFflag_Init(*this);
}

inline amc::FFflag::~FFflag() {
    amc::FFflag_Uninit(*this);
}


// --- amc.FFflag..Init
// Set all fields to initial values.
inline void amc::FFflag_Init(amc::FFflag& fflag) {
    fflag.cumulative = bool(false);
    fflag.emptyval = algo::strptr("");
    fflag.ind_fflag_next = (amc::FFflag*)-1; // (amc.FDb.ind_fflag) not-in-hash
}
inline amc::FField::FField() {
    amc::FField_Init(*this);
}

inline amc::FField::~FField() {
    amc::FField_Uninit(*this);
}


// --- amc.FField.c_fsort.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fsort_InsertMaybe(amc::FField& field, amc::FFsort& row) {
    amc::FFsort* ptr = field.c_fsort;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fsort = &row;
    }
    return retval;
}

// --- amc.FField.c_fsort.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fsort_Remove(amc::FField& field, amc::FFsort& row) {
    amc::FFsort *ptr = field.c_fsort;
    if (LIKELY(ptr == &row)) {
        field.c_fsort = NULL;
    }
}

// --- amc.FField.c_fbitset.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fbitset_InsertMaybe(amc::FField& field, amc::FFbitset& row) {
    amc::FFbitset* ptr = field.c_fbitset;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fbitset = &row;
    }
    return retval;
}

// --- amc.FField.c_fbitset.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fbitset_Remove(amc::FField& field, amc::FFbitset& row) {
    amc::FFbitset *ptr = field.c_fbitset;
    if (LIKELY(ptr == &row)) {
        field.c_fbitset = NULL;
    }
}

// --- amc.FField.c_smallstr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_smallstr_InsertMaybe(amc::FField& field, amc::FSmallstr& row) {
    amc::FSmallstr* ptr = field.c_smallstr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_smallstr = &row;
    }
    return retval;
}

// --- amc.FField.c_smallstr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_smallstr_Remove(amc::FField& field, amc::FSmallstr& row) {
    amc::FSmallstr *ptr = field.c_smallstr;
    if (LIKELY(ptr == &row)) {
        field.c_smallstr = NULL;
    }
}

// --- amc.FField.c_ffunc.EmptyQ
// Return true if index is empty
inline bool amc::c_ffunc_EmptyQ(amc::FField& field) {
    return field.c_ffunc_n == 0;
}

// --- amc.FField.c_ffunc.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFunc* amc::c_ffunc_Find(amc::FField& field, u32 t) {
    amc::FFunc *retval = NULL;
    u64 idx = t;
    u64 lim = field.c_ffunc_n;
    if (idx < lim) {
        retval = field.c_ffunc_elems[idx];
    }
    return retval;
}

// --- amc.FField.c_ffunc.Getary
// Return array of pointers
inline algo::aryptr<amc::FFunc*> amc::c_ffunc_Getary(amc::FField& field) {
    return algo::aryptr<amc::FFunc*>(field.c_ffunc_elems, field.c_ffunc_n);
}

// --- amc.FField.c_ffunc.N
// Return number of items in the pointer array
inline i32 amc::c_ffunc_N(const amc::FField& field) {
    return field.c_ffunc_n;
}

// --- amc.FField.c_ffunc.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ffunc_RemoveAll(amc::FField& field) {
    field.c_ffunc_n = 0;
}

// --- amc.FField.c_ffunc.qFind
// Return reference without bounds checking
inline amc::FFunc& amc::c_ffunc_qFind(amc::FField& field, u32 idx) {
    return *field.c_ffunc_elems[idx];
}

// --- amc.FField.c_ffunc.qLast
// Reference to last element without bounds checking
inline amc::FFunc& amc::c_ffunc_qLast(amc::FField& field) {
    return *field.c_ffunc_elems[field.c_ffunc_n-1];
}

// --- amc.FField.c_xref.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_xref_InsertMaybe(amc::FField& field, amc::FXref& row) {
    amc::FXref* ptr = field.c_xref;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_xref = &row;
    }
    return retval;
}

// --- amc.FField.c_xref.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_xref_Remove(amc::FField& field, amc::FXref& row) {
    amc::FXref *ptr = field.c_xref;
    if (LIKELY(ptr == &row)) {
        field.c_xref = NULL;
    }
}

// --- amc.FField.c_anonfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_anonfld_InsertMaybe(amc::FField& field, amc::FAnonfld& row) {
    amc::FAnonfld* ptr = field.c_anonfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_anonfld = &row;
    }
    return retval;
}

// --- amc.FField.c_anonfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_anonfld_Remove(amc::FField& field, amc::FAnonfld& row) {
    amc::FAnonfld *ptr = field.c_anonfld;
    if (LIKELY(ptr == &row)) {
        field.c_anonfld = NULL;
    }
}

// --- amc.FField.c_fldoffset.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fldoffset_InsertMaybe(amc::FField& field, amc::FFldoffset& row) {
    amc::FFldoffset* ptr = field.c_fldoffset;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fldoffset = &row;
    }
    return retval;
}

// --- amc.FField.c_fldoffset.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fldoffset_Remove(amc::FField& field, amc::FFldoffset& row) {
    amc::FFldoffset *ptr = field.c_fldoffset;
    if (LIKELY(ptr == &row)) {
        field.c_fldoffset = NULL;
    }
}

// --- amc.FField.c_basepool.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_basepool_InsertMaybe(amc::FField& field, amc::FBasepool& row) {
    amc::FBasepool* ptr = field.c_basepool;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_basepool = &row;
    }
    return retval;
}

// --- amc.FField.c_basepool.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_basepool_Remove(amc::FField& field, amc::FBasepool& row) {
    amc::FBasepool *ptr = field.c_basepool;
    if (LIKELY(ptr == &row)) {
        field.c_basepool = NULL;
    }
}

// --- amc.FField.c_llist.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_llist_InsertMaybe(amc::FField& field, amc::FLlist& row) {
    amc::FLlist* ptr = field.c_llist;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_llist = &row;
    }
    return retval;
}

// --- amc.FField.c_llist.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_llist_Remove(amc::FField& field, amc::FLlist& row) {
    amc::FLlist *ptr = field.c_llist;
    if (LIKELY(ptr == &row)) {
        field.c_llist = NULL;
    }
}

// --- amc.FField.c_thash.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_thash_InsertMaybe(amc::FField& field, amc::FThash& row) {
    amc::FThash* ptr = field.c_thash;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_thash = &row;
    }
    return retval;
}

// --- amc.FField.c_thash.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_thash_Remove(amc::FField& field, amc::FThash& row) {
    amc::FThash *ptr = field.c_thash;
    if (LIKELY(ptr == &row)) {
        field.c_thash = NULL;
    }
}

// --- amc.FField.c_inlary.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_inlary_InsertMaybe(amc::FField& field, amc::FInlary& row) {
    amc::FInlary* ptr = field.c_inlary;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_inlary = &row;
    }
    return retval;
}

// --- amc.FField.c_inlary.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_inlary_Remove(amc::FField& field, amc::FInlary& row) {
    amc::FInlary *ptr = field.c_inlary;
    if (LIKELY(ptr == &row)) {
        field.c_inlary = NULL;
    }
}

// --- amc.FField.c_tary.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_tary_InsertMaybe(amc::FField& field, amc::FTary& row) {
    amc::FTary* ptr = field.c_tary;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_tary = &row;
    }
    return retval;
}

// --- amc.FField.c_tary.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_tary_Remove(amc::FField& field, amc::FTary& row) {
    amc::FTary *ptr = field.c_tary;
    if (LIKELY(ptr == &row)) {
        field.c_tary = NULL;
    }
}

// --- amc.FField.c_rowid.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_rowid_InsertMaybe(amc::FField& field, amc::FRowid& row) {
    amc::FRowid* ptr = field.c_rowid;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_rowid = &row;
    }
    return retval;
}

// --- amc.FField.c_rowid.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_rowid_Remove(amc::FField& field, amc::FRowid& row) {
    amc::FRowid *ptr = field.c_rowid;
    if (LIKELY(ptr == &row)) {
        field.c_rowid = NULL;
    }
}

// --- amc.FField.c_cascdel.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_cascdel_InsertMaybe(amc::FField& field, amc::FCascdel& row) {
    amc::FCascdel* ptr = field.c_cascdel;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_cascdel = &row;
    }
    return retval;
}

// --- amc.FField.c_cascdel.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_cascdel_Remove(amc::FField& field, amc::FCascdel& row) {
    amc::FCascdel *ptr = field.c_cascdel;
    if (LIKELY(ptr == &row)) {
        field.c_cascdel = NULL;
    }
}

// --- amc.FField.c_gstatic.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_gstatic_InsertMaybe(amc::FField& field, amc::FGstatic& row) {
    amc::FGstatic* ptr = field.c_gstatic;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_gstatic = &row;
    }
    return retval;
}

// --- amc.FField.c_gstatic.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_gstatic_Remove(amc::FField& field, amc::FGstatic& row) {
    amc::FGstatic *ptr = field.c_gstatic;
    if (LIKELY(ptr == &row)) {
        field.c_gstatic = NULL;
    }
}

// --- amc.FField.c_ptrary.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_ptrary_InsertMaybe(amc::FField& field, amc::FPtrary& row) {
    amc::FPtrary* ptr = field.c_ptrary;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_ptrary = &row;
    }
    return retval;
}

// --- amc.FField.c_ptrary.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_ptrary_Remove(amc::FField& field, amc::FPtrary& row) {
    amc::FPtrary *ptr = field.c_ptrary;
    if (LIKELY(ptr == &row)) {
        field.c_ptrary = NULL;
    }
}

// --- amc.FField.c_pmaskfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_pmaskfld_InsertMaybe(amc::FField& field, amc::FPmaskfld& row) {
    amc::FPmaskfld* ptr = field.c_pmaskfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_pmaskfld = &row;
    }
    return retval;
}

// --- amc.FField.c_pmaskfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_pmaskfld_Remove(amc::FField& field, amc::FPmaskfld& row) {
    amc::FPmaskfld *ptr = field.c_pmaskfld;
    if (LIKELY(ptr == &row)) {
        field.c_pmaskfld = NULL;
    }
}

// --- amc.FField.c_typefld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_typefld_InsertMaybe(amc::FField& field, amc::FTypefld& row) {
    amc::FTypefld* ptr = field.c_typefld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_typefld = &row;
    }
    return retval;
}

// --- amc.FField.c_typefld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_typefld_Remove(amc::FField& field, amc::FTypefld& row) {
    amc::FTypefld *ptr = field.c_typefld;
    if (LIKELY(ptr == &row)) {
        field.c_typefld = NULL;
    }
}

// --- amc.FField.c_fcleanup.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fcleanup_InsertMaybe(amc::FField& field, amc::FFcleanup& row) {
    amc::FFcleanup* ptr = field.c_fcleanup;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fcleanup = &row;
    }
    return retval;
}

// --- amc.FField.c_fcleanup.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fcleanup_Remove(amc::FField& field, amc::FFcleanup& row) {
    amc::FFcleanup *ptr = field.c_fcleanup;
    if (LIKELY(ptr == &row)) {
        field.c_fcleanup = NULL;
    }
}

// --- amc.FField.c_fdec.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fdec_InsertMaybe(amc::FField& field, amc::FFdec& row) {
    amc::FFdec* ptr = field.c_fdec;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fdec = &row;
    }
    return retval;
}

// --- amc.FField.c_fdec.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fdec_Remove(amc::FField& field, amc::FFdec& row) {
    amc::FFdec *ptr = field.c_fdec;
    if (LIKELY(ptr == &row)) {
        field.c_fdec = NULL;
    }
}

// --- amc.FField.c_fconst.EmptyQ
// Return true if index is empty
inline bool amc::c_fconst_EmptyQ(amc::FField& field) {
    return field.c_fconst_n == 0;
}

// --- amc.FField.c_fconst.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFconst* amc::c_fconst_Find(amc::FField& field, u32 t) {
    amc::FFconst *retval = NULL;
    u64 idx = t;
    u64 lim = field.c_fconst_n;
    if (idx < lim) {
        retval = field.c_fconst_elems[idx];
    }
    return retval;
}

// --- amc.FField.c_fconst.Getary
// Return array of pointers
inline algo::aryptr<amc::FFconst*> amc::c_fconst_Getary(amc::FField& field) {
    return algo::aryptr<amc::FFconst*>(field.c_fconst_elems, field.c_fconst_n);
}

// --- amc.FField.c_fconst.N
// Return number of items in the pointer array
inline i32 amc::c_fconst_N(const amc::FField& field) {
    return field.c_fconst_n;
}

// --- amc.FField.c_fconst.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_fconst_RemoveAll(amc::FField& field) {
    for (u32 i = 0; i < field.c_fconst_n; i++) {
        // mark all elements as not-in-array
        field.c_fconst_elems[i]->field_c_fconst_in_ary = false;
    }
    field.c_fconst_n = 0;
}

// --- amc.FField.c_fconst.qFind
// Return reference without bounds checking
inline amc::FFconst& amc::c_fconst_qFind(amc::FField& field, u32 idx) {
    return *field.c_fconst_elems[idx];
}

// --- amc.FField.c_fconst.InAryQ
// True if row is in any ptrary instance
inline bool amc::field_c_fconst_InAryQ(amc::FFconst& row) {
    return row.field_c_fconst_in_ary;
}

// --- amc.FField.c_fconst.qLast
// Reference to last element without bounds checking
inline amc::FFconst& amc::c_fconst_qLast(amc::FField& field) {
    return *field.c_fconst_elems[field.c_fconst_n-1];
}

// --- amc.FField.c_finput.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_finput_InsertMaybe(amc::FField& field, amc::FFinput& row) {
    amc::FFinput* ptr = field.c_finput;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_finput = &row;
    }
    return retval;
}

// --- amc.FField.c_finput.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_finput_Remove(amc::FField& field, amc::FFinput& row) {
    amc::FFinput *ptr = field.c_finput;
    if (LIKELY(ptr == &row)) {
        field.c_finput = NULL;
    }
}

// --- amc.FField.c_foutput.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_foutput_InsertMaybe(amc::FField& field, amc::FFoutput& row) {
    amc::FFoutput* ptr = field.c_foutput;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_foutput = &row;
    }
    return retval;
}

// --- amc.FField.c_foutput.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_foutput_Remove(amc::FField& field, amc::FFoutput& row) {
    amc::FFoutput *ptr = field.c_foutput;
    if (LIKELY(ptr == &row)) {
        field.c_foutput = NULL;
    }
}

// --- amc.FField.c_fbuf.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fbuf_InsertMaybe(amc::FField& field, amc::FFbuf& row) {
    amc::FFbuf* ptr = field.c_fbuf;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fbuf = &row;
    }
    return retval;
}

// --- amc.FField.c_fbuf.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fbuf_Remove(amc::FField& field, amc::FFbuf& row) {
    amc::FFbuf *ptr = field.c_fbuf;
    if (LIKELY(ptr == &row)) {
        field.c_fbuf = NULL;
    }
}

// --- amc.FField.c_fbigend.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fbigend_InsertMaybe(amc::FField& field, amc::FFbigend& row) {
    amc::FFbigend* ptr = field.c_fbigend;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fbigend = &row;
    }
    return retval;
}

// --- amc.FField.c_fbigend.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fbigend_Remove(amc::FField& field, amc::FFbigend& row) {
    amc::FFbigend *ptr = field.c_fbigend;
    if (LIKELY(ptr == &row)) {
        field.c_fbigend = NULL;
    }
}

// --- amc.FField.c_fstep.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fstep_InsertMaybe(amc::FField& field, amc::FFstep& row) {
    amc::FFstep* ptr = field.c_fstep;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fstep = &row;
    }
    return retval;
}

// --- amc.FField.c_fstep.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fstep_Remove(amc::FField& field, amc::FFstep& row) {
    amc::FFstep *ptr = field.c_fstep;
    if (LIKELY(ptr == &row)) {
        field.c_fstep = NULL;
    }
}

// --- amc.FField.c_fregx.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fregx_InsertMaybe(amc::FField& field, amc::FFregx& row) {
    amc::FFregx* ptr = field.c_fregx;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fregx = &row;
    }
    return retval;
}

// --- amc.FField.c_fregx.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fregx_Remove(amc::FField& field, amc::FFregx& row) {
    amc::FFregx *ptr = field.c_fregx;
    if (LIKELY(ptr == &row)) {
        field.c_fregx = NULL;
    }
}

// --- amc.FField.c_fcmp.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fcmp_InsertMaybe(amc::FField& field, amc::FFcmp& row) {
    amc::FFcmp* ptr = field.c_fcmp;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fcmp = &row;
    }
    return retval;
}

// --- amc.FField.c_fcmp.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fcmp_Remove(amc::FField& field, amc::FFcmp& row) {
    amc::FFcmp *ptr = field.c_fcmp;
    if (LIKELY(ptr == &row)) {
        field.c_fcmp = NULL;
    }
}

// --- amc.FField.c_fcast.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fcast_InsertMaybe(amc::FField& field, amc::FFcast& row) {
    amc::FFcast* ptr = field.c_fcast;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fcast = &row;
    }
    return retval;
}

// --- amc.FField.c_fcast.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fcast_Remove(amc::FField& field, amc::FFcast& row) {
    amc::FFcast *ptr = field.c_fcast;
    if (LIKELY(ptr == &row)) {
        field.c_fcast = NULL;
    }
}

// --- amc.FField.c_gconst.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_gconst_InsertMaybe(amc::FField& field, amc::FGconst& row) {
    amc::FGconst* ptr = field.c_gconst;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_gconst = &row;
    }
    return retval;
}

// --- amc.FField.c_gconst.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_gconst_Remove(amc::FField& field, amc::FGconst& row) {
    amc::FGconst *ptr = field.c_gconst;
    if (LIKELY(ptr == &row)) {
        field.c_gconst = NULL;
    }
}

// --- amc.FField.c_bitfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_bitfld_InsertMaybe(amc::FField& field, amc::FBitfld& row) {
    amc::FBitfld* ptr = field.c_bitfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_bitfld = &row;
    }
    return retval;
}

// --- amc.FField.c_bitfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_bitfld_Remove(amc::FField& field, amc::FBitfld& row) {
    amc::FBitfld *ptr = field.c_bitfld;
    if (LIKELY(ptr == &row)) {
        field.c_bitfld = NULL;
    }
}

// --- amc.FField.c_noxref.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_noxref_InsertMaybe(amc::FField& field, amc::FNoxref& row) {
    amc::FNoxref* ptr = field.c_noxref;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_noxref = &row;
    }
    return retval;
}

// --- amc.FField.c_noxref.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_noxref_Remove(amc::FField& field, amc::FNoxref& row) {
    amc::FNoxref *ptr = field.c_noxref;
    if (LIKELY(ptr == &row)) {
        field.c_noxref = NULL;
    }
}

// --- amc.FField.c_cppfunc.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_cppfunc_InsertMaybe(amc::FField& field, amc::FCppfunc& row) {
    amc::FCppfunc* ptr = field.c_cppfunc;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_cppfunc = &row;
    }
    return retval;
}

// --- amc.FField.c_cppfunc.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_cppfunc_Remove(amc::FField& field, amc::FCppfunc& row) {
    amc::FCppfunc *ptr = field.c_cppfunc;
    if (LIKELY(ptr == &row)) {
        field.c_cppfunc = NULL;
    }
}

// --- amc.FField.c_substr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_substr_InsertMaybe(amc::FField& field, amc::FSubstr& row) {
    amc::FSubstr* ptr = field.c_substr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_substr = &row;
    }
    return retval;
}

// --- amc.FField.c_substr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_substr_Remove(amc::FField& field, amc::FSubstr& row) {
    amc::FSubstr *ptr = field.c_substr;
    if (LIKELY(ptr == &row)) {
        field.c_substr = NULL;
    }
}

// --- amc.FField.c_fcompact.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fcompact_InsertMaybe(amc::FField& field, amc::FFcompact& row) {
    amc::FFcompact* ptr = field.c_fcompact;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fcompact = &row;
    }
    return retval;
}

// --- amc.FField.c_fcompact.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fcompact_Remove(amc::FField& field, amc::FFcompact& row) {
    amc::FFcompact *ptr = field.c_fcompact;
    if (LIKELY(ptr == &row)) {
        field.c_fcompact = NULL;
    }
}

// --- amc.FField.c_findrem.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_findrem_InsertMaybe(amc::FField& field, amc::FFindrem& row) {
    amc::FFindrem* ptr = field.c_findrem;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_findrem = &row;
    }
    return retval;
}

// --- amc.FField.c_findrem.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_findrem_Remove(amc::FField& field, amc::FFindrem& row) {
    amc::FFindrem *ptr = field.c_findrem;
    if (LIKELY(ptr == &row)) {
        field.c_findrem = NULL;
    }
}

// --- amc.FField.zd_xref_keyfld.EmptyQ
// Return true if index is empty
inline bool amc::zd_xref_keyfld_EmptyQ(amc::FField& field) {
    return field.zd_xref_keyfld_head == NULL;
}

// --- amc.FField.zd_xref_keyfld.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FXref* amc::zd_xref_keyfld_First(amc::FField& field) {
    amc::FXref *row = NULL;
    row = field.zd_xref_keyfld_head;
    return row;
}

// --- amc.FField.zd_xref_keyfld.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zd_xref_keyfld_InLlistQ(amc::FXref& row) {
    bool result = false;
    result = !(row.zd_xref_keyfld_next == (amc::FXref*)-1);
    return result;
}

// --- amc.FField.zd_xref_keyfld.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FXref* amc::zd_xref_keyfld_Last(amc::FField& field) {
    amc::FXref *row = NULL;
    row = field.zd_xref_keyfld_tail;
    return row;
}

// --- amc.FField.zd_xref_keyfld.N
// Return number of items in the linked list
inline i32 amc::zd_xref_keyfld_N(const amc::FField& field) {
    return field.zd_xref_keyfld_n;
}

// --- amc.FField.zd_xref_keyfld.Next
// Return pointer to next element in the list
inline amc::FXref* amc::zd_xref_keyfld_Next(amc::FXref &row) {
    return row.zd_xref_keyfld_next;
}

// --- amc.FField.zd_xref_keyfld.Prev
// Return pointer to previous element in the list
inline amc::FXref* amc::zd_xref_keyfld_Prev(amc::FXref &row) {
    return row.zd_xref_keyfld_prev;
}

// --- amc.FField.zd_xref_keyfld.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FXref& amc::zd_xref_keyfld_qLast(amc::FField& field) {
    amc::FXref *row = NULL;
    row = field.zd_xref_keyfld_tail;
    return *row;
}

// --- amc.FField.zs_fcmap.EmptyQ
// Return true if index is empty
inline bool amc::zs_fcmap_EmptyQ(amc::FField& field) {
    return field.zs_fcmap_head == NULL;
}

// --- amc.FField.zs_fcmap.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FFcmap* amc::zs_fcmap_First(amc::FField& field) {
    amc::FFcmap *row = NULL;
    row = field.zs_fcmap_head;
    return row;
}

// --- amc.FField.zs_fcmap.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_fcmap_InLlistQ(amc::FFcmap& row) {
    bool result = false;
    result = !(row.zs_fcmap_next == (amc::FFcmap*)-1);
    return result;
}

// --- amc.FField.zs_fcmap.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FFcmap* amc::zs_fcmap_Last(amc::FField& field) {
    amc::FFcmap *row = NULL;
    row = field.zs_fcmap_tail;
    return row;
}

// --- amc.FField.zs_fcmap.Next
// Return pointer to next element in the list
inline amc::FFcmap* amc::zs_fcmap_Next(amc::FFcmap &row) {
    return row.zs_fcmap_next;
}

// --- amc.FField.zs_fcmap.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FFcmap& amc::zs_fcmap_qLast(amc::FField& field) {
    amc::FFcmap *row = NULL;
    row = field.zs_fcmap_tail;
    return *row;
}

// --- amc.FField.c_fbase.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fbase_InsertMaybe(amc::FField& field, amc::FFbase& row) {
    amc::FFbase* ptr = field.c_fbase;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fbase = &row;
    }
    return retval;
}

// --- amc.FField.c_fbase.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fbase_Remove(amc::FField& field, amc::FFbase& row) {
    amc::FFbase *ptr = field.c_fbase;
    if (LIKELY(ptr == &row)) {
        field.c_fbase = NULL;
    }
}

// --- amc.FField.c_fnoremove.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fnoremove_InsertMaybe(amc::FField& field, amc::FFnoremove& row) {
    amc::FFnoremove* ptr = field.c_fnoremove;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fnoremove = &row;
    }
    return retval;
}

// --- amc.FField.c_fnoremove.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fnoremove_Remove(amc::FField& field, amc::FFnoremove& row) {
    amc::FFnoremove *ptr = field.c_fnoremove;
    if (LIKELY(ptr == &row)) {
        field.c_fnoremove = NULL;
    }
}

// --- amc.FField.c_sortfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_sortfld_InsertMaybe(amc::FField& field, amc::FSortfld& row) {
    amc::FSortfld* ptr = field.c_sortfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_sortfld = &row;
    }
    return retval;
}

// --- amc.FField.c_sortfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_sortfld_Remove(amc::FField& field, amc::FSortfld& row) {
    amc::FSortfld *ptr = field.c_sortfld;
    if (LIKELY(ptr == &row)) {
        field.c_sortfld = NULL;
    }
}

// --- amc.FField.c_ftrace.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_ftrace_InsertMaybe(amc::FField& field, amc::FFtrace& row) {
    amc::FFtrace* ptr = field.c_ftrace;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_ftrace = &row;
    }
    return retval;
}

// --- amc.FField.c_ftrace.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_ftrace_Remove(amc::FField& field, amc::FFtrace& row) {
    amc::FFtrace *ptr = field.c_ftrace;
    if (LIKELY(ptr == &row)) {
        field.c_ftrace = NULL;
    }
}

// --- amc.FField.c_hook.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_hook_InsertMaybe(amc::FField& field, amc::FHook& row) {
    amc::FHook* ptr = field.c_hook;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_hook = &row;
    }
    return retval;
}

// --- amc.FField.c_hook.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_hook_Remove(amc::FField& field, amc::FHook& row) {
    amc::FHook *ptr = field.c_hook;
    if (LIKELY(ptr == &row)) {
        field.c_hook = NULL;
    }
}

// --- amc.FField.c_charset.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_charset_InsertMaybe(amc::FField& field, amc::FCharset& row) {
    amc::FCharset* ptr = field.c_charset;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_charset = &row;
    }
    return retval;
}

// --- amc.FField.c_charset.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_charset_Remove(amc::FField& field, amc::FCharset& row) {
    amc::FCharset *ptr = field.c_charset;
    if (LIKELY(ptr == &row)) {
        field.c_charset = NULL;
    }
}

// --- amc.FField.bh_bitfld.EmptyQ
// Return true if index is empty
inline bool amc::bh_bitfld_EmptyQ(amc::FField& field) {
    return field.bh_bitfld_n == 0;
}

// --- amc.FField.bh_bitfld.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FBitfld* amc::bh_bitfld_First(amc::FField& field) {
    amc::FBitfld *row = NULL;
    if (field.bh_bitfld_n > 0) {
        row = field.bh_bitfld_elems[0];
    }
    return row;
}

// --- amc.FField.bh_bitfld.InBheapQ
// Return true if row is in index, false otherwise
inline bool amc::bh_bitfld_InBheapQ(amc::FBitfld& row) {
    bool result = false;
    result = row.bh_bitfld_idx != -1;
    return result;
}

// --- amc.FField.bh_bitfld.N
// Return number of items in the heap
inline i32 amc::bh_bitfld_N(const amc::FField& field) {
    return field.bh_bitfld_n;
}

// --- amc.FField.c_funique.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_funique_InsertMaybe(amc::FField& field, amc::FFunique& row) {
    amc::FFunique* ptr = field.c_funique;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_funique = &row;
    }
    return retval;
}

// --- amc.FField.c_funique.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_funique_Remove(amc::FField& field, amc::FFunique& row) {
    amc::FFunique *ptr = field.c_funique;
    if (LIKELY(ptr == &row)) {
        field.c_funique = NULL;
    }
}

// --- amc.FField.c_fuserinit.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fuserinit_InsertMaybe(amc::FField& field, amc::FFuserinit& row) {
    amc::FFuserinit* ptr = field.c_fuserinit;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fuserinit = &row;
    }
    return retval;
}

// --- amc.FField.c_fuserinit.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fuserinit_Remove(amc::FField& field, amc::FFuserinit& row) {
    amc::FFuserinit *ptr = field.c_fuserinit;
    if (LIKELY(ptr == &row)) {
        field.c_fuserinit = NULL;
    }
}

// --- amc.FField.c_fflag.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fflag_InsertMaybe(amc::FField& field, amc::FFflag& row) {
    amc::FFflag* ptr = field.c_fflag;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_fflag = &row;
    }
    return retval;
}

// --- amc.FField.c_fflag.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fflag_Remove(amc::FField& field, amc::FFflag& row) {
    amc::FFflag *ptr = field.c_fflag;
    if (LIKELY(ptr == &row)) {
        field.c_fflag = NULL;
    }
}

// --- amc.FField.c_falias.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_falias_InsertMaybe(amc::FField& field, amc::FFalias& row) {
    amc::FFalias* ptr = field.c_falias;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_falias = &row;
    }
    return retval;
}

// --- amc.FField.c_falias.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_falias_Remove(amc::FField& field, amc::FFalias& row) {
    amc::FFalias *ptr = field.c_falias;
    if (LIKELY(ptr == &row)) {
        field.c_falias = NULL;
    }
}

// --- amc.FField.c_ffunc_curs.Reset
inline void amc::field_c_ffunc_curs_Reset(field_c_ffunc_curs &curs, amc::FField &parent) {
    curs.elems = parent.c_ffunc_elems;
    curs.n_elems = parent.c_ffunc_n;
    curs.index = 0;
}

// --- amc.FField.c_ffunc_curs.ValidQ
// cursor points to valid item
inline bool amc::field_c_ffunc_curs_ValidQ(field_c_ffunc_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FField.c_ffunc_curs.Next
// proceed to next item
inline void amc::field_c_ffunc_curs_Next(field_c_ffunc_curs &curs) {
    curs.index++;
}

// --- amc.FField.c_ffunc_curs.Access
// item access
inline amc::FFunc& amc::field_c_ffunc_curs_Access(field_c_ffunc_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FField.c_fconst_curs.Reset
inline void amc::field_c_fconst_curs_Reset(field_c_fconst_curs &curs, amc::FField &parent) {
    curs.elems = parent.c_fconst_elems;
    curs.n_elems = parent.c_fconst_n;
    curs.index = 0;
}

// --- amc.FField.c_fconst_curs.ValidQ
// cursor points to valid item
inline bool amc::field_c_fconst_curs_ValidQ(field_c_fconst_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FField.c_fconst_curs.Next
// proceed to next item
inline void amc::field_c_fconst_curs_Next(field_c_fconst_curs &curs) {
    curs.index++;
}

// --- amc.FField.c_fconst_curs.Access
// item access
inline amc::FFconst& amc::field_c_fconst_curs_Access(field_c_fconst_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FField.zd_xref_keyfld_curs.Reset
// cursor points to valid item
inline void amc::field_zd_xref_keyfld_curs_Reset(field_zd_xref_keyfld_curs &curs, amc::FField &parent) {
    curs.row = parent.zd_xref_keyfld_head;
}

// --- amc.FField.zd_xref_keyfld_curs.ValidQ
// cursor points to valid item
inline bool amc::field_zd_xref_keyfld_curs_ValidQ(field_zd_xref_keyfld_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FField.zd_xref_keyfld_curs.Next
// proceed to next item
inline void amc::field_zd_xref_keyfld_curs_Next(field_zd_xref_keyfld_curs &curs) {
    amc::FXref *next = (*curs.row).zd_xref_keyfld_next;
    curs.row = next;
}

// --- amc.FField.zd_xref_keyfld_curs.Access
// item access
inline amc::FXref& amc::field_zd_xref_keyfld_curs_Access(field_zd_xref_keyfld_curs &curs) {
    return *curs.row;
}

// --- amc.FField.zs_fcmap_curs.Reset
// cursor points to valid item
inline void amc::field_zs_fcmap_curs_Reset(field_zs_fcmap_curs &curs, amc::FField &parent) {
    curs.row = parent.zs_fcmap_head;
}

// --- amc.FField.zs_fcmap_curs.ValidQ
// cursor points to valid item
inline bool amc::field_zs_fcmap_curs_ValidQ(field_zs_fcmap_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FField.zs_fcmap_curs.Next
// proceed to next item
inline void amc::field_zs_fcmap_curs_Next(field_zs_fcmap_curs &curs) {
    amc::FFcmap *next = (*curs.row).zs_fcmap_next;
    curs.row = next;
}

// --- amc.FField.zs_fcmap_curs.Access
// item access
inline amc::FFcmap& amc::field_zs_fcmap_curs_Access(field_zs_fcmap_curs &curs) {
    return *curs.row;
}

// --- amc.FField.bh_bitfld_curs.Access
// Access current element. If not more elements, return NULL
inline amc::FBitfld& amc::field_bh_bitfld_curs_Access(field_bh_bitfld_curs &curs) {
    return *curs.temp_elems[0];
}

// --- amc.FField.bh_bitfld_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool amc::field_bh_bitfld_curs_ValidQ(field_bh_bitfld_curs &curs) {
    return curs.temp_n > 0;
}
inline amc::FFindrem::FFindrem() {
}

inline amc::FFindrem::~FFindrem() {
    amc::FFindrem_Uninit(*this);
}

inline amc::FFinput::FFinput() {
    amc::FFinput_Init(*this);
}

inline amc::FFinput::~FFinput() {
    amc::FFinput_Uninit(*this);
}


// --- amc.FFinput..Init
// Set all fields to initial values.
inline void amc::FFinput_Init(amc::FFinput& finput) {
    finput.extrn = bool(false);
    finput.update = bool(false);
    finput.strict = bool(true);
    finput.p_field = NULL;
}
inline amc::FFldoffset::FFldoffset() {
    amc::FFldoffset_Init(*this);
}

inline amc::FFldoffset::~FFldoffset() {
    amc::FFldoffset_Uninit(*this);
}


// --- amc.FFldoffset..Init
// Set all fields to initial values.
inline void amc::FFldoffset_Init(amc::FFldoffset& fldoffset) {
    fldoffset.offset = i32(0);
    fldoffset.p_field = NULL;
}
inline amc::FFloadtuples::FFloadtuples() {
    amc::FFloadtuples_Init(*this);
}

inline amc::FFloadtuples::~FFloadtuples() {
    amc::FFloadtuples_Uninit(*this);
}


// --- amc.FFloadtuples..Init
// Set all fields to initial values.
inline void amc::FFloadtuples_Init(amc::FFloadtuples& floadtuples) {
    floadtuples.p_field = NULL;
}
inline amc::FFnoremove::FFnoremove() {
}

inline amc::FFnoremove::~FFnoremove() {
    amc::FFnoremove_Uninit(*this);
}

inline amc::FFoutput::FFoutput() {
    amc::FFoutput_Init(*this);
}

inline amc::FFoutput::~FFoutput() {
    amc::FFoutput_Uninit(*this);
}


// --- amc.FFoutput..Init
// Set all fields to initial values.
inline void amc::FFoutput_Init(amc::FFoutput& foutput) {
    foutput.ns_c_foutput_in_ary = bool(false);
}
inline amc::FFprefix::FFprefix() {
    amc::FFprefix_Init(*this);
}

inline amc::FFprefix::~FFprefix() {
    amc::FFprefix_Uninit(*this);
}


// --- amc.FFprefix..Init
// Set all fields to initial values.
inline void amc::FFprefix_Init(amc::FFprefix& fprefix) {
    fprefix.ind_prefix_next = (amc::FFprefix*)-1; // (amc.FDb.ind_prefix) not-in-hash
    fprefix.zs_fprefix_next = (amc::FFprefix*)-1; // (amc.FReftype.zs_fprefix) not-in-list
}
inline amc::FFregx::FFregx() {
    amc::FFregx_Init(*this);
}

inline amc::FFregx::~FFregx() {
    amc::FFregx_Uninit(*this);
}


// --- amc.FFregx..Init
// Set all fields to initial values.
inline void amc::FFregx_Init(amc::FFregx& fregx) {
    fregx.partial = bool(false);
}
inline amc::FFsort::FFsort() {
    amc::FFsort_Init(*this);
}

inline amc::FFsort::~FFsort() {
    amc::FFsort_Uninit(*this);
}


// --- amc.FFsort..Init
// Set all fields to initial values.
inline void amc::FFsort_Init(amc::FFsort& fsort) {
    fsort.p_field = NULL;
    fsort.p_sortfld = NULL;
}
inline amc::FFstep::FFstep() {
    amc::FFstep_Init(*this);
}

inline amc::FFstep::~FFstep() {
    amc::FFstep_Uninit(*this);
}


// --- amc.FFstep.c_fdelay.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fdelay_InsertMaybe(amc::FFstep& fstep, amc::FFdelay& row) {
    amc::FFdelay* ptr = fstep.c_fdelay;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        fstep.c_fdelay = &row;
    }
    return retval;
}

// --- amc.FFstep.c_fdelay.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fdelay_Remove(amc::FFstep& fstep, amc::FFdelay& row) {
    amc::FFdelay *ptr = fstep.c_fdelay;
    if (LIKELY(ptr == &row)) {
        fstep.c_fdelay = NULL;
    }
}

// --- amc.FFstep..Init
// Set all fields to initial values.
inline void amc::FFstep_Init(amc::FFstep& fstep) {
    fstep.c_fdelay = NULL;
    fstep.p_field = NULL;
    fstep.ns_c_fstep_in_ary = bool(false);
    fstep.ind_fstep_next = (amc::FFstep*)-1; // (amc.FDb.ind_fstep) not-in-hash
}
inline amc::FFtrace::FFtrace() {
}

inline amc::FFtrace::~FFtrace() {
    amc::FFtrace_Uninit(*this);
}

inline amc::FFunc::FFunc() {
    amc::FFunc_Init(*this);
}

inline amc::FFunc::~FFunc() {
    amc::FFunc_Uninit(*this);
}


// --- amc.FFunc.funcarg.EmptyQ
// Return true if index is empty
inline bool amc::funcarg_EmptyQ(amc::FFunc& func) {
    return func.funcarg_n == 0;
}

// --- amc.FFunc.funcarg.Find
// Look up row by row id. Return NULL if out of range
inline amc::Funcarg* amc::funcarg_Find(amc::FFunc& func, u64 t) {
    u64 idx = t;
    u64 lim = func.funcarg_n;
    if (idx >= lim) return NULL;
    return func.funcarg_elems + idx;
}

// --- amc.FFunc.funcarg.Getary
// Return array pointer by value
inline algo::aryptr<amc::Funcarg> amc::funcarg_Getary(amc::FFunc& func) {
    return algo::aryptr<amc::Funcarg>(func.funcarg_elems, func.funcarg_n);
}

// --- amc.FFunc.funcarg.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::Funcarg* amc::funcarg_Last(amc::FFunc& func) {
    return funcarg_Find(func, u64(func.funcarg_n-1));
}

// --- amc.FFunc.funcarg.Max
// Return max. number of items in the array
inline i32 amc::funcarg_Max(amc::FFunc& func) {
    (void)func;
    return func.funcarg_max;
}

// --- amc.FFunc.funcarg.N
// Return number of items in the array
inline i32 amc::funcarg_N(const amc::FFunc& func) {
    return func.funcarg_n;
}

// --- amc.FFunc.funcarg.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void amc::funcarg_Reserve(amc::FFunc& func, int n) {
    u32 new_n = func.funcarg_n + n;
    if (UNLIKELY(new_n > func.funcarg_max)) {
        funcarg_AbsReserve(func, new_n);
    }
}

// --- amc.FFunc.funcarg.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::Funcarg& amc::funcarg_qFind(amc::FFunc& func, u64 t) {
    return func.funcarg_elems[t];
}

// --- amc.FFunc.funcarg.qLast
// Return reference to last element of array. No bounds checking
inline amc::Funcarg& amc::funcarg_qLast(amc::FFunc& func) {
    return funcarg_qFind(func, u64(func.funcarg_n-1));
}

// --- amc.FFunc.funcarg.rowid_Get
// Return row id of specified element
inline u64 amc::funcarg_rowid_Get(amc::FFunc& func, amc::Funcarg &elem) {
    u64 id = &elem - func.funcarg_elems;
    return u64(id);
}

// --- amc.FFunc.funcarg_curs.Next
// proceed to next item
inline void amc::func_funcarg_curs_Next(func_funcarg_curs &curs) {
    curs.index++;
}

// --- amc.FFunc.funcarg_curs.Reset
inline void amc::func_funcarg_curs_Reset(func_funcarg_curs &curs, amc::FFunc &parent) {
    curs.elems = parent.funcarg_elems;
    curs.n_elems = parent.funcarg_n;
    curs.index = 0;
}

// --- amc.FFunc.funcarg_curs.ValidQ
// cursor points to valid item
inline bool amc::func_funcarg_curs_ValidQ(func_funcarg_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FFunc.funcarg_curs.Access
// item access
inline amc::Funcarg& amc::func_funcarg_curs_Access(func_funcarg_curs &curs) {
    return curs.elems[curs.index];
}
inline amc::FFunique::FFunique() {
}

inline amc::FFunique::~FFunique() {
    amc::FFunique_Uninit(*this);
}

inline amc::FFuserinit::FFuserinit() {
}

inline amc::FFuserinit::~FFuserinit() {
    amc::FFuserinit_Uninit(*this);
}

inline amc::FFwddecl::FFwddecl() {
    amc::FFwddecl_Init(*this);
}

inline amc::FFwddecl::~FFwddecl() {
    amc::FFwddecl_Uninit(*this);
}


// --- amc.FFwddecl..Init
// Set all fields to initial values.
inline void amc::FFwddecl_Init(amc::FFwddecl& fwddecl) {
    fwddecl.ns_c_fwddecl_in_ary = bool(false);
    fwddecl.ind_fwddecl_next = (amc::FFwddecl*)-1; // (amc.FDb.ind_fwddecl) not-in-hash
}
inline amc::FGconst::FGconst() {
    amc::FGconst_Init(*this);
}

inline amc::FGconst::~FGconst() {
    amc::FGconst_Uninit(*this);
}


// --- amc.FGconst..Init
// Set all fields to initial values.
inline void amc::FGconst_Init(amc::FGconst& gconst) {
    gconst.wantenum = bool(true);
    gconst.p_namefld = NULL;
    gconst.p_field = NULL;
}
inline amc::FGen::FGen() {
    amc::FGen_Init(*this);
}

inline amc::FGen::~FGen() {
    amc::FGen_Uninit(*this);
}


// --- amc.FGen.step.Call
// Invoke function by pointer
inline void amc::step_Call(amc::FGen& gen) {
    if (gen.step) {
        gen.step();
    }
}

// --- amc.FGen..Init
// Set all fields to initial values.
inline void amc::FGen_Init(amc::FGen& gen) {
    gen.perns = bool(false);
    gen.cycle_total = u64(0);
    gen.zs_gen_perns_next = (amc::FGen*)-1; // (amc.FDb.zs_gen_perns) not-in-list
    gen.step = NULL;
}
inline amc::FGenXref::FGenXref() {
    amc::FGenXref_Init(*this);
}

inline amc::FGenXref::~FGenXref() {
    amc::FGenXref_Uninit(*this);
}


// --- amc.FGenXref.ind_seen.EmptyQ
// Return true if hash is empty
inline bool amc::ind_seen_EmptyQ(amc::FGenXref& parent) {
    return parent.ind_seen_n == 0;
}

// --- amc.FGenXref.ind_seen.N
// Return number of items in the hash
inline i32 amc::ind_seen_N(const amc::FGenXref& parent) {
    return parent.ind_seen_n;
}

// --- amc.FGenXref.seen.EmptyQ
// Return true if index is empty
inline bool amc::seen_EmptyQ(amc::FGenXref& parent) {
    return parent.seen_n == 0;
}

// --- amc.FGenXref.seen.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGenXrefSeen* amc::seen_Find(amc::FGenXref& parent, u64 t) {
    amc::FGenXrefSeen *retval = NULL;
    if (LIKELY(u64(t) < u64(parent.seen_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &parent.seen_lary[bsr][index];
    }
    return retval;
}

// --- amc.FGenXref.seen.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc::FGenXrefSeen* amc::seen_Last(amc::FGenXref& parent) {
    return seen_Find(parent, u64(parent.seen_n-1));
}

// --- amc.FGenXref.seen.N
// Return number of items in the pool
inline i32 amc::seen_N(const amc::FGenXref& parent) {
    return parent.seen_n;
}

// --- amc.FGenXref.seen.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc::FGenXrefSeen& amc::seen_qFind(amc::FGenXref& parent, u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return parent.seen_lary[bsr][index];
}

// --- amc.FGenXref.seen_curs.Reset
// cursor points to valid item
inline void amc::FGenXref_seen_curs_Reset(FGenXref_seen_curs &curs, amc::FGenXref &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc.FGenXref.seen_curs.ValidQ
// cursor points to valid item
inline bool amc::FGenXref_seen_curs_ValidQ(FGenXref_seen_curs &curs) {
    return curs.index < (*curs.parent).seen_n;
}

// --- amc.FGenXref.seen_curs.Next
// proceed to next item
inline void amc::FGenXref_seen_curs_Next(FGenXref_seen_curs &curs) {
    curs.index++;
}

// --- amc.FGenXref.seen_curs.Access
// item access
inline amc::FGenXrefSeen& amc::FGenXref_seen_curs_Access(FGenXref_seen_curs &curs) {
    return seen_qFind((*curs.parent), u64(curs.index));
}
inline amc::FGenXrefSeen::FGenXrefSeen() {
    amc::FGenXrefSeen_Init(*this);
}


// --- amc.FGenXrefSeen..Init
// Set all fields to initial values.
inline void amc::FGenXrefSeen_Init(amc::FGenXrefSeen& seen) {
    seen.ind_seen_next = (amc::FGenXrefSeen*)-1; // (amc.FGenXref.ind_seen) not-in-hash
}
inline amc::FGstatic::FGstatic() {
    amc::FGstatic_Init(*this);
}

inline amc::FGstatic::~FGstatic() {
    amc::FGstatic_Uninit(*this);
}


// --- amc.FGstatic..Init
// Set all fields to initial values.
inline void amc::FGstatic_Init(amc::FGstatic& gstatic) {
    gstatic.p_field = NULL;
    gstatic.rowid = u32(0);
    gstatic.ns_c_gstatic_in_ary = bool(false);
}
inline amc::FGsymbol::FGsymbol() {
    amc::FGsymbol_Init(*this);
}

inline amc::FGsymbol::~FGsymbol() {
    amc::FGsymbol_Uninit(*this);
}


// --- amc.FGsymbol..Init
// Set all fields to initial values.
inline void amc::FGsymbol_Init(amc::FGsymbol& gsymbol) {
    gsymbol.p_ssimfile = NULL;
    gsymbol.p_symboltype = NULL;
    gsymbol.ns_c_gsymbol_in_ary = bool(false);
}
inline amc::FHook::FHook() {
    amc::FHook_Init(*this);
}

inline amc::FHook::~FHook() {
    amc::FHook_Uninit(*this);
}


// --- amc.FHook..Init
// Set all fields to initial values.
inline void amc::FHook_Init(amc::FHook& hook) {
    hook.p_funcptr = NULL;
    hook.p_field = NULL;
}
inline amc::FInlary::FInlary() {
    amc::FInlary_Init(*this);
}

inline amc::FInlary::~FInlary() {
    amc::FInlary_Uninit(*this);
}


// --- amc.FInlary..Init
// Set all fields to initial values.
inline void amc::FInlary_Init(amc::FInlary& inlary) {
    inlary.min = i32(0);
    inlary.max = i32(0);
    inlary.ind_inlary_next = (amc::FInlary*)-1; // (amc.FDb.ind_inlary) not-in-hash
}
inline amc::FLenfld::FLenfld() {
    amc::FLenfld_Init(*this);
}

inline amc::FLenfld::~FLenfld() {
    amc::FLenfld_Uninit(*this);
}


// --- amc.FLenfld..Init
// Set all fields to initial values.
inline void amc::FLenfld_Init(amc::FLenfld& lenfld) {
    lenfld.extra = i32(0);
    lenfld.p_field = NULL;
}
inline amc::FLicense::FLicense() {
    amc::FLicense_Init(*this);
}

inline amc::FLicense::~FLicense() {
    amc::FLicense_Uninit(*this);
}


// --- amc.FLicense..Init
// Set all fields to initial values.
inline void amc::FLicense_Init(amc::FLicense& license) {
    license.ind_license_next = (amc::FLicense*)-1; // (amc.FDb.ind_license) not-in-hash
}
inline amc::FListtype::FListtype() {
    amc::FListtype_Init(*this);
}

inline amc::FListtype::~FListtype() {
    amc::FListtype_Uninit(*this);
}


// --- amc.FListtype..Init
// Set all fields to initial values.
inline void amc::FListtype_Init(amc::FListtype& listtype) {
    listtype.circular = bool(false);
    listtype.haveprev = bool(false);
    listtype.instail = bool(false);
    listtype.ind_listtype_next = (amc::FListtype*)-1; // (amc.FDb.ind_listtype) not-in-hash
}
inline amc::FLlist::FLlist() {
    amc::FLlist_Init(*this);
}

inline amc::FLlist::~FLlist() {
    amc::FLlist_Uninit(*this);
}


// --- amc.FLlist..Init
// Set all fields to initial values.
inline void amc::FLlist_Init(amc::FLlist& llist) {
    llist.havetail = bool(true);
    llist.havecount = bool(false);
    llist.p_listtype = NULL;
}
inline amc::FMain::FMain() {
    amc::FMain_Init(*this);
}

inline amc::FMain::~FMain() {
    amc::FMain_Uninit(*this);
}


// --- amc.FMain..Init
// Set all fields to initial values.
inline void amc::FMain_Init(amc::FMain& main) {
    main.ismodule = bool(false);
    main.ind_main_next = (amc::FMain*)-1; // (amc.FDb.ind_main) not-in-hash
}
inline amc::FMsgtype::FMsgtype() {
    amc::FMsgtype_Init(*this);
}

inline amc::FMsgtype::~FMsgtype() {
    amc::FMsgtype_Uninit(*this);
}


// --- amc.FMsgtype..Init
// Set all fields to initial values.
inline void amc::FMsgtype_Init(amc::FMsgtype& msgtype) {
    msgtype.p_ctype = NULL;
}
inline amc::FNocascdel::FNocascdel() {
}

inline amc::FNocascdel::~FNocascdel() {
    amc::FNocascdel_Uninit(*this);
}

inline amc::FNossimfile::FNossimfile() {
}

inline amc::FNossimfile::~FNossimfile() {
    amc::FNossimfile_Uninit(*this);
}

inline amc::FNoxref::FNoxref() {
}

inline amc::FNoxref::~FNoxref() {
    amc::FNoxref_Uninit(*this);
}

inline amc::FNs::FNs() {
    amc::FNs_Init(*this);
}

inline amc::FNs::~FNs() {
    amc::FNs_Uninit(*this);
}


// --- amc.FNs.c_ctype.EmptyQ
// Return true if index is empty
inline bool amc::c_ctype_EmptyQ(amc::FNs& ns) {
    return ns.c_ctype_n == 0;
}

// --- amc.FNs.c_ctype.Find
// Look up row by row id. Return NULL if out of range
inline amc::FCtype* amc::c_ctype_Find(amc::FNs& ns, u32 t) {
    amc::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_ctype_n;
    if (idx < lim) {
        retval = ns.c_ctype_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_ctype.Getary
// Return array of pointers
inline algo::aryptr<amc::FCtype*> amc::c_ctype_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FCtype*>(ns.c_ctype_elems, ns.c_ctype_n);
}

// --- amc.FNs.c_ctype.N
// Return number of items in the pointer array
inline i32 amc::c_ctype_N(const amc::FNs& ns) {
    return ns.c_ctype_n;
}

// --- amc.FNs.c_ctype.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_ctype_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_ctype_n; i++) {
        // mark all elements as not-in-array
        ns.c_ctype_elems[i]->ns_c_ctype_in_ary = false;
    }
    ns.c_ctype_n = 0;
}

// --- amc.FNs.c_ctype.qFind
// Return reference without bounds checking
inline amc::FCtype& amc::c_ctype_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_ctype_elems[idx];
}

// --- amc.FNs.c_ctype.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_ctype_InAryQ(amc::FCtype& row) {
    return row.ns_c_ctype_in_ary;
}

// --- amc.FNs.c_ctype.qLast
// Reference to last element without bounds checking
inline amc::FCtype& amc::c_ctype_qLast(amc::FNs& ns) {
    return *ns.c_ctype_elems[ns.c_ctype_n-1];
}

// --- amc.FNs.c_func.EmptyQ
// Return true if index is empty
inline bool amc::c_func_EmptyQ(amc::FNs& ns) {
    return ns.c_func_n == 0;
}

// --- amc.FNs.c_func.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFunc* amc::c_func_Find(amc::FNs& ns, u32 t) {
    amc::FFunc *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_func_n;
    if (idx < lim) {
        retval = ns.c_func_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_func.Getary
// Return array of pointers
inline algo::aryptr<amc::FFunc*> amc::c_func_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FFunc*>(ns.c_func_elems, ns.c_func_n);
}

// --- amc.FNs.c_func.N
// Return number of items in the pointer array
inline i32 amc::c_func_N(const amc::FNs& ns) {
    return ns.c_func_n;
}

// --- amc.FNs.c_func.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_func_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_func_n; i++) {
        // mark all elements as not-in-array
        ns.c_func_elems[i]->ns_c_func_in_ary = false;
    }
    ns.c_func_n = 0;
}

// --- amc.FNs.c_func.qFind
// Return reference without bounds checking
inline amc::FFunc& amc::c_func_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_func_elems[idx];
}

// --- amc.FNs.c_func.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_func_InAryQ(amc::FFunc& row) {
    return row.ns_c_func_in_ary;
}

// --- amc.FNs.c_func.qLast
// Reference to last element without bounds checking
inline amc::FFunc& amc::c_func_qLast(amc::FNs& ns) {
    return *ns.c_func_elems[ns.c_func_n-1];
}

// --- amc.FNs.c_dispatch.EmptyQ
// Return true if index is empty
inline bool amc::c_dispatch_EmptyQ(amc::FNs& ns) {
    return ns.c_dispatch_n == 0;
}

// --- amc.FNs.c_dispatch.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispatch* amc::c_dispatch_Find(amc::FNs& ns, u32 t) {
    amc::FDispatch *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_dispatch_n;
    if (idx < lim) {
        retval = ns.c_dispatch_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_dispatch.Getary
// Return array of pointers
inline algo::aryptr<amc::FDispatch*> amc::c_dispatch_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FDispatch*>(ns.c_dispatch_elems, ns.c_dispatch_n);
}

// --- amc.FNs.c_dispatch.N
// Return number of items in the pointer array
inline i32 amc::c_dispatch_N(const amc::FNs& ns) {
    return ns.c_dispatch_n;
}

// --- amc.FNs.c_dispatch.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_dispatch_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_dispatch_n; i++) {
        // mark all elements as not-in-array
        ns.c_dispatch_elems[i]->ns_c_dispatch_in_ary = false;
    }
    ns.c_dispatch_n = 0;
}

// --- amc.FNs.c_dispatch.qFind
// Return reference without bounds checking
inline amc::FDispatch& amc::c_dispatch_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_dispatch_elems[idx];
}

// --- amc.FNs.c_dispatch.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_dispatch_InAryQ(amc::FDispatch& row) {
    return row.ns_c_dispatch_in_ary;
}

// --- amc.FNs.c_dispatch.qLast
// Reference to last element without bounds checking
inline amc::FDispatch& amc::c_dispatch_qLast(amc::FNs& ns) {
    return *ns.c_dispatch_elems[ns.c_dispatch_n-1];
}

// --- amc.FNs.c_globfld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_globfld_InsertMaybe(amc::FNs& ns, amc::FField& row) {
    amc::FField* ptr = ns.c_globfld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_globfld = &row;
    }
    return retval;
}

// --- amc.FNs.c_globfld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_globfld_Remove(amc::FNs& ns, amc::FField& row) {
    amc::FField *ptr = ns.c_globfld;
    if (LIKELY(ptr == &row)) {
        ns.c_globfld = NULL;
    }
}

// --- amc.FNs.c_gstatic.EmptyQ
// Return true if index is empty
inline bool amc::c_gstatic_EmptyQ(amc::FNs& ns) {
    return ns.c_gstatic_n == 0;
}

// --- amc.FNs.c_gstatic.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGstatic* amc::c_gstatic_Find(amc::FNs& ns, u32 t) {
    amc::FGstatic *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_gstatic_n;
    if (idx < lim) {
        retval = ns.c_gstatic_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_gstatic.Getary
// Return array of pointers
inline algo::aryptr<amc::FGstatic*> amc::c_gstatic_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FGstatic*>(ns.c_gstatic_elems, ns.c_gstatic_n);
}

// --- amc.FNs.c_gstatic.N
// Return number of items in the pointer array
inline i32 amc::c_gstatic_N(const amc::FNs& ns) {
    return ns.c_gstatic_n;
}

// --- amc.FNs.c_gstatic.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_gstatic_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_gstatic_n; i++) {
        // mark all elements as not-in-array
        ns.c_gstatic_elems[i]->ns_c_gstatic_in_ary = false;
    }
    ns.c_gstatic_n = 0;
}

// --- amc.FNs.c_gstatic.qFind
// Return reference without bounds checking
inline amc::FGstatic& amc::c_gstatic_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_gstatic_elems[idx];
}

// --- amc.FNs.c_gstatic.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_gstatic_InAryQ(amc::FGstatic& row) {
    return row.ns_c_gstatic_in_ary;
}

// --- amc.FNs.c_gstatic.qLast
// Reference to last element without bounds checking
inline amc::FGstatic& amc::c_gstatic_qLast(amc::FNs& ns) {
    return *ns.c_gstatic_elems[ns.c_gstatic_n-1];
}

// --- amc.FNs.c_main.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_main_InsertMaybe(amc::FNs& ns, amc::FMain& row) {
    amc::FMain* ptr = ns.c_main;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_main = &row;
    }
    return retval;
}

// --- amc.FNs.c_main.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_main_Remove(amc::FNs& ns, amc::FMain& row) {
    amc::FMain *ptr = ns.c_main;
    if (LIKELY(ptr == &row)) {
        ns.c_main = NULL;
    }
}

// --- amc.FNs.include.EmptyQ
// Return true if index is empty
inline bool amc::include_EmptyQ(amc::FNs& ns) {
    return ns.include_n == 0;
}

// --- amc.FNs.include.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* amc::include_Find(amc::FNs& ns, u64 t) {
    u64 idx = t;
    u64 lim = ns.include_n;
    if (idx >= lim) return NULL;
    return ns.include_elems + idx;
}

// --- amc.FNs.include.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> amc::include_Getary(amc::FNs& ns) {
    return algo::aryptr<algo::cstring>(ns.include_elems, ns.include_n);
}

// --- amc.FNs.include.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* amc::include_Last(amc::FNs& ns) {
    return include_Find(ns, u64(ns.include_n-1));
}

// --- amc.FNs.include.Max
// Return max. number of items in the array
inline i32 amc::include_Max(amc::FNs& ns) {
    (void)ns;
    return ns.include_max;
}

// --- amc.FNs.include.N
// Return number of items in the array
inline i32 amc::include_N(const amc::FNs& ns) {
    return ns.include_n;
}

// --- amc.FNs.include.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void amc::include_Reserve(amc::FNs& ns, int n) {
    u32 new_n = ns.include_n + n;
    if (UNLIKELY(new_n > ns.include_max)) {
        include_AbsReserve(ns, new_n);
    }
}

// --- amc.FNs.include.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& amc::include_qFind(amc::FNs& ns, u64 t) {
    return ns.include_elems[t];
}

// --- amc.FNs.include.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& amc::include_qLast(amc::FNs& ns) {
    return include_qFind(ns, u64(ns.include_n-1));
}

// --- amc.FNs.include.rowid_Get
// Return row id of specified element
inline u64 amc::include_rowid_Get(amc::FNs& ns, algo::cstring &elem) {
    u64 id = &elem - ns.include_elems;
    return u64(id);
}

// --- amc.FNs.c_dispsig.EmptyQ
// Return true if index is empty
inline bool amc::c_dispsig_EmptyQ(amc::FNs& ns) {
    return ns.c_dispsig_n == 0;
}

// --- amc.FNs.c_dispsig.Find
// Look up row by row id. Return NULL if out of range
inline amc::FDispsig* amc::c_dispsig_Find(amc::FNs& ns, u32 t) {
    amc::FDispsig *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_dispsig_n;
    if (idx < lim) {
        retval = ns.c_dispsig_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_dispsig.Getary
// Return array of pointers
inline algo::aryptr<amc::FDispsig*> amc::c_dispsig_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FDispsig*>(ns.c_dispsig_elems, ns.c_dispsig_n);
}

// --- amc.FNs.c_dispsig.N
// Return number of items in the pointer array
inline i32 amc::c_dispsig_N(const amc::FNs& ns) {
    return ns.c_dispsig_n;
}

// --- amc.FNs.c_dispsig.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_dispsig_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_dispsig_n; i++) {
        // mark all elements as not-in-array
        ns.c_dispsig_elems[i]->ns_c_dispsig_in_ary = false;
    }
    ns.c_dispsig_n = 0;
}

// --- amc.FNs.c_dispsig.qFind
// Return reference without bounds checking
inline amc::FDispsig& amc::c_dispsig_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_dispsig_elems[idx];
}

// --- amc.FNs.c_dispsig.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_dispsig_InAryQ(amc::FDispsig& row) {
    return row.ns_c_dispsig_in_ary;
}

// --- amc.FNs.c_dispsig.qLast
// Reference to last element without bounds checking
inline amc::FDispsig& amc::c_dispsig_qLast(amc::FNs& ns) {
    return *ns.c_dispsig_elems[ns.c_dispsig_n-1];
}

// --- amc.FNs.c_parentns.EmptyQ
// Return true if index is empty
inline bool amc::c_parentns_EmptyQ(amc::FNs& ns) {
    return ns.c_parentns_n == 0;
}

// --- amc.FNs.c_parentns.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNs* amc::c_parentns_Find(amc::FNs& ns, u32 t) {
    amc::FNs *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_parentns_n;
    if (idx < lim) {
        retval = ns.c_parentns_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_parentns.Getary
// Return array of pointers
inline algo::aryptr<amc::FNs*> amc::c_parentns_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FNs*>(ns.c_parentns_elems, ns.c_parentns_n);
}

// --- amc.FNs.c_parentns.N
// Return number of items in the pointer array
inline i32 amc::c_parentns_N(const amc::FNs& ns) {
    return ns.c_parentns_n;
}

// --- amc.FNs.c_parentns.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_parentns_RemoveAll(amc::FNs& ns) {
    ns.c_parentns_n = 0;
}

// --- amc.FNs.c_parentns.qFind
// Return reference without bounds checking
inline amc::FNs& amc::c_parentns_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_parentns_elems[idx];
}

// --- amc.FNs.c_parentns.qLast
// Reference to last element without bounds checking
inline amc::FNs& amc::c_parentns_qLast(amc::FNs& ns) {
    return *ns.c_parentns_elems[ns.c_parentns_n-1];
}

// --- amc.FNs.c_cppincl.EmptyQ
// Return true if index is empty
inline bool amc::c_cppincl_EmptyQ(amc::FNs& ns) {
    return ns.c_cppincl_n == 0;
}

// --- amc.FNs.c_cppincl.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNs* amc::c_cppincl_Find(amc::FNs& ns, u32 t) {
    amc::FNs *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_cppincl_n;
    if (idx < lim) {
        retval = ns.c_cppincl_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_cppincl.Getary
// Return array of pointers
inline algo::aryptr<amc::FNs*> amc::c_cppincl_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FNs*>(ns.c_cppincl_elems, ns.c_cppincl_n);
}

// --- amc.FNs.c_cppincl.N
// Return number of items in the pointer array
inline i32 amc::c_cppincl_N(const amc::FNs& ns) {
    return ns.c_cppincl_n;
}

// --- amc.FNs.c_cppincl.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_cppincl_RemoveAll(amc::FNs& ns) {
    ns.c_cppincl_n = 0;
}

// --- amc.FNs.c_cppincl.qFind
// Return reference without bounds checking
inline amc::FNs& amc::c_cppincl_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_cppincl_elems[idx];
}

// --- amc.FNs.c_cppincl.qLast
// Reference to last element without bounds checking
inline amc::FNs& amc::c_cppincl_qLast(amc::FNs& ns) {
    return *ns.c_cppincl_elems[ns.c_cppincl_n-1];
}

// --- amc.FNs.c_hdrincl.EmptyQ
// Return true if index is empty
inline bool amc::c_hdrincl_EmptyQ(amc::FNs& ns) {
    return ns.c_hdrincl_n == 0;
}

// --- amc.FNs.c_hdrincl.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNs* amc::c_hdrincl_Find(amc::FNs& ns, u32 t) {
    amc::FNs *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_hdrincl_n;
    if (idx < lim) {
        retval = ns.c_hdrincl_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_hdrincl.Getary
// Return array of pointers
inline algo::aryptr<amc::FNs*> amc::c_hdrincl_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FNs*>(ns.c_hdrincl_elems, ns.c_hdrincl_n);
}

// --- amc.FNs.c_hdrincl.N
// Return number of items in the pointer array
inline i32 amc::c_hdrincl_N(const amc::FNs& ns) {
    return ns.c_hdrincl_n;
}

// --- amc.FNs.c_hdrincl.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_hdrincl_RemoveAll(amc::FNs& ns) {
    ns.c_hdrincl_n = 0;
}

// --- amc.FNs.c_hdrincl.qFind
// Return reference without bounds checking
inline amc::FNs& amc::c_hdrincl_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_hdrincl_elems[idx];
}

// --- amc.FNs.c_hdrincl.qLast
// Reference to last element without bounds checking
inline amc::FNs& amc::c_hdrincl_qLast(amc::FNs& ns) {
    return *ns.c_hdrincl_elems[ns.c_hdrincl_n-1];
}

// --- amc.FNs.c_fwddecl.EmptyQ
// Return true if index is empty
inline bool amc::c_fwddecl_EmptyQ(amc::FNs& ns) {
    return ns.c_fwddecl_n == 0;
}

// --- amc.FNs.c_fwddecl.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFwddecl* amc::c_fwddecl_Find(amc::FNs& ns, u32 t) {
    amc::FFwddecl *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_fwddecl_n;
    if (idx < lim) {
        retval = ns.c_fwddecl_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_fwddecl.Getary
// Return array of pointers
inline algo::aryptr<amc::FFwddecl*> amc::c_fwddecl_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FFwddecl*>(ns.c_fwddecl_elems, ns.c_fwddecl_n);
}

// --- amc.FNs.c_fwddecl.N
// Return number of items in the pointer array
inline i32 amc::c_fwddecl_N(const amc::FNs& ns) {
    return ns.c_fwddecl_n;
}

// --- amc.FNs.c_fwddecl.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_fwddecl_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_fwddecl_n; i++) {
        // mark all elements as not-in-array
        ns.c_fwddecl_elems[i]->ns_c_fwddecl_in_ary = false;
    }
    ns.c_fwddecl_n = 0;
}

// --- amc.FNs.c_fwddecl.qFind
// Return reference without bounds checking
inline amc::FFwddecl& amc::c_fwddecl_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_fwddecl_elems[idx];
}

// --- amc.FNs.c_fwddecl.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_fwddecl_InAryQ(amc::FFwddecl& row) {
    return row.ns_c_fwddecl_in_ary;
}

// --- amc.FNs.c_fwddecl.qLast
// Reference to last element without bounds checking
inline amc::FFwddecl& amc::c_fwddecl_qLast(amc::FNs& ns) {
    return *ns.c_fwddecl_elems[ns.c_fwddecl_n-1];
}

// --- amc.FNs.c_nsx.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_nsx_InsertMaybe(amc::FNs& ns, amc::FNsx& row) {
    amc::FNsx* ptr = ns.c_nsx;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_nsx = &row;
    }
    return retval;
}

// --- amc.FNs.c_nsx.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_nsx_Remove(amc::FNs& ns, amc::FNsx& row) {
    amc::FNsx *ptr = ns.c_nsx;
    if (LIKELY(ptr == &row)) {
        ns.c_nsx = NULL;
    }
}

// --- amc.FNs.c_target.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_target_InsertMaybe(amc::FNs& ns, amc::FTarget& row) {
    amc::FTarget* ptr = ns.c_target;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_target = &row;
    }
    return retval;
}

// --- amc.FNs.c_target.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_target_Remove(amc::FNs& ns, amc::FTarget& row) {
    amc::FTarget *ptr = ns.c_target;
    if (LIKELY(ptr == &row)) {
        ns.c_target = NULL;
    }
}

// --- amc.FNs.c_pnew.EmptyQ
// Return true if index is empty
inline bool amc::c_pnew_EmptyQ(amc::FNs& ns) {
    return ns.c_pnew_n == 0;
}

// --- amc.FNs.c_pnew.Find
// Look up row by row id. Return NULL if out of range
inline amc::FPnew* amc::c_pnew_Find(amc::FNs& ns, u32 t) {
    amc::FPnew *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_pnew_n;
    if (idx < lim) {
        retval = ns.c_pnew_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_pnew.Getary
// Return array of pointers
inline algo::aryptr<amc::FPnew*> amc::c_pnew_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FPnew*>(ns.c_pnew_elems, ns.c_pnew_n);
}

// --- amc.FNs.c_pnew.N
// Return number of items in the pointer array
inline i32 amc::c_pnew_N(const amc::FNs& ns) {
    return ns.c_pnew_n;
}

// --- amc.FNs.c_pnew.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_pnew_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_pnew_n; i++) {
        // mark all elements as not-in-array
        ns.c_pnew_elems[i]->ns_c_pnew_in_ary = false;
    }
    ns.c_pnew_n = 0;
}

// --- amc.FNs.c_pnew.qFind
// Return reference without bounds checking
inline amc::FPnew& amc::c_pnew_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_pnew_elems[idx];
}

// --- amc.FNs.c_pnew.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_pnew_InAryQ(amc::FPnew& row) {
    return row.ns_c_pnew_in_ary;
}

// --- amc.FNs.c_pnew.qLast
// Reference to last element without bounds checking
inline amc::FPnew& amc::c_pnew_qLast(amc::FNs& ns) {
    return *ns.c_pnew_elems[ns.c_pnew_n-1];
}

// --- amc.FNs.c_fcmdline.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_fcmdline_InsertMaybe(amc::FNs& ns, amc::FFcmdline& row) {
    amc::FFcmdline* ptr = ns.c_fcmdline;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_fcmdline = &row;
    }
    return retval;
}

// --- amc.FNs.c_fcmdline.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_fcmdline_Remove(amc::FNs& ns, amc::FFcmdline& row) {
    amc::FFcmdline *ptr = ns.c_fcmdline;
    if (LIKELY(ptr == &row)) {
        ns.c_fcmdline = NULL;
    }
}

// --- amc.FNs.c_nsproto.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_nsproto_InsertMaybe(amc::FNs& ns, amc::FNsproto& row) {
    amc::FNsproto* ptr = ns.c_nsproto;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_nsproto = &row;
    }
    return retval;
}

// --- amc.FNs.c_nsproto.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_nsproto_Remove(amc::FNs& ns, amc::FNsproto& row) {
    amc::FNsproto *ptr = ns.c_nsproto;
    if (LIKELY(ptr == &row)) {
        ns.c_nsproto = NULL;
    }
}

// --- amc.FNs.c_nsdb.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_nsdb_InsertMaybe(amc::FNs& ns, amc::FNsdb& row) {
    amc::FNsdb* ptr = ns.c_nsdb;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_nsdb = &row;
    }
    return retval;
}

// --- amc.FNs.c_nsdb.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_nsdb_Remove(amc::FNs& ns, amc::FNsdb& row) {
    amc::FNsdb *ptr = ns.c_nsdb;
    if (LIKELY(ptr == &row)) {
        ns.c_nsdb = NULL;
    }
}

// --- amc.FNs.c_outfile.EmptyQ
// Return true if index is empty
inline bool amc::c_outfile_EmptyQ(amc::FNs& ns) {
    return ns.c_outfile_n == 0;
}

// --- amc.FNs.c_outfile.Find
// Look up row by row id. Return NULL if out of range
inline amc::FOutfile* amc::c_outfile_Find(amc::FNs& ns, u32 t) {
    amc::FOutfile *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_outfile_n;
    if (idx < lim) {
        retval = ns.c_outfile_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_outfile.Getary
// Return array of pointers
inline algo::aryptr<amc::FOutfile*> amc::c_outfile_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FOutfile*>(ns.c_outfile_elems, ns.c_outfile_n);
}

// --- amc.FNs.c_outfile.N
// Return number of items in the pointer array
inline i32 amc::c_outfile_N(const amc::FNs& ns) {
    return ns.c_outfile_n;
}

// --- amc.FNs.c_outfile.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_outfile_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_outfile_n; i++) {
        // mark all elements as not-in-array
        ns.c_outfile_elems[i]->ns_c_outfile_in_ary = false;
    }
    ns.c_outfile_n = 0;
}

// --- amc.FNs.c_outfile.qFind
// Return reference without bounds checking
inline amc::FOutfile& amc::c_outfile_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_outfile_elems[idx];
}

// --- amc.FNs.c_outfile.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_outfile_InAryQ(amc::FOutfile& row) {
    return row.ns_c_outfile_in_ary;
}

// --- amc.FNs.c_outfile.qLast
// Reference to last element without bounds checking
inline amc::FOutfile& amc::c_outfile_qLast(amc::FNs& ns) {
    return *ns.c_outfile_elems[ns.c_outfile_n-1];
}

// --- amc.FNs.c_foutput.EmptyQ
// Return true if index is empty
inline bool amc::c_foutput_EmptyQ(amc::FNs& ns) {
    return ns.c_foutput_n == 0;
}

// --- amc.FNs.c_foutput.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFoutput* amc::c_foutput_Find(amc::FNs& ns, u32 t) {
    amc::FFoutput *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_foutput_n;
    if (idx < lim) {
        retval = ns.c_foutput_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_foutput.Getary
// Return array of pointers
inline algo::aryptr<amc::FFoutput*> amc::c_foutput_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FFoutput*>(ns.c_foutput_elems, ns.c_foutput_n);
}

// --- amc.FNs.c_foutput.N
// Return number of items in the pointer array
inline i32 amc::c_foutput_N(const amc::FNs& ns) {
    return ns.c_foutput_n;
}

// --- amc.FNs.c_foutput.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_foutput_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_foutput_n; i++) {
        // mark all elements as not-in-array
        ns.c_foutput_elems[i]->ns_c_foutput_in_ary = false;
    }
    ns.c_foutput_n = 0;
}

// --- amc.FNs.c_foutput.qFind
// Return reference without bounds checking
inline amc::FFoutput& amc::c_foutput_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_foutput_elems[idx];
}

// --- amc.FNs.c_foutput.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_foutput_InAryQ(amc::FFoutput& row) {
    return row.ns_c_foutput_in_ary;
}

// --- amc.FNs.c_foutput.qLast
// Reference to last element without bounds checking
inline amc::FFoutput& amc::c_foutput_qLast(amc::FNs& ns) {
    return *ns.c_foutput_elems[ns.c_foutput_n-1];
}

// --- amc.FNs.c_fstep.EmptyQ
// Return true if index is empty
inline bool amc::c_fstep_EmptyQ(amc::FNs& ns) {
    return ns.c_fstep_n == 0;
}

// --- amc.FNs.c_fstep.Find
// Look up row by row id. Return NULL if out of range
inline amc::FFstep* amc::c_fstep_Find(amc::FNs& ns, u32 t) {
    amc::FFstep *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_fstep_n;
    if (idx < lim) {
        retval = ns.c_fstep_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_fstep.Getary
// Return array of pointers
inline algo::aryptr<amc::FFstep*> amc::c_fstep_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FFstep*>(ns.c_fstep_elems, ns.c_fstep_n);
}

// --- amc.FNs.c_fstep.N
// Return number of items in the pointer array
inline i32 amc::c_fstep_N(const amc::FNs& ns) {
    return ns.c_fstep_n;
}

// --- amc.FNs.c_fstep.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_fstep_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_fstep_n; i++) {
        // mark all elements as not-in-array
        ns.c_fstep_elems[i]->ns_c_fstep_in_ary = false;
    }
    ns.c_fstep_n = 0;
}

// --- amc.FNs.c_fstep.qFind
// Return reference without bounds checking
inline amc::FFstep& amc::c_fstep_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_fstep_elems[idx];
}

// --- amc.FNs.c_fstep.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_fstep_InAryQ(amc::FFstep& row) {
    return row.ns_c_fstep_in_ary;
}

// --- amc.FNs.c_fstep.qLast
// Reference to last element without bounds checking
inline amc::FFstep& amc::c_fstep_qLast(amc::FNs& ns) {
    return *ns.c_fstep_elems[ns.c_fstep_n-1];
}

// --- amc.FNs.c_gsymbol.EmptyQ
// Return true if index is empty
inline bool amc::c_gsymbol_EmptyQ(amc::FNs& ns) {
    return ns.c_gsymbol_n == 0;
}

// --- amc.FNs.c_gsymbol.Find
// Look up row by row id. Return NULL if out of range
inline amc::FGsymbol* amc::c_gsymbol_Find(amc::FNs& ns, u32 t) {
    amc::FGsymbol *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_gsymbol_n;
    if (idx < lim) {
        retval = ns.c_gsymbol_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_gsymbol.Getary
// Return array of pointers
inline algo::aryptr<amc::FGsymbol*> amc::c_gsymbol_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FGsymbol*>(ns.c_gsymbol_elems, ns.c_gsymbol_n);
}

// --- amc.FNs.c_gsymbol.N
// Return number of items in the pointer array
inline i32 amc::c_gsymbol_N(const amc::FNs& ns) {
    return ns.c_gsymbol_n;
}

// --- amc.FNs.c_gsymbol.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_gsymbol_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_gsymbol_n; i++) {
        // mark all elements as not-in-array
        ns.c_gsymbol_elems[i]->ns_c_gsymbol_in_ary = false;
    }
    ns.c_gsymbol_n = 0;
}

// --- amc.FNs.c_gsymbol.qFind
// Return reference without bounds checking
inline amc::FGsymbol& amc::c_gsymbol_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_gsymbol_elems[idx];
}

// --- amc.FNs.c_gsymbol.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_gsymbol_InAryQ(amc::FGsymbol& row) {
    return row.ns_c_gsymbol_in_ary;
}

// --- amc.FNs.c_gsymbol.qLast
// Reference to last element without bounds checking
inline amc::FGsymbol& amc::c_gsymbol_qLast(amc::FNs& ns) {
    return *ns.c_gsymbol_elems[ns.c_gsymbol_n-1];
}

// --- amc.FNs.c_nsinclude.EmptyQ
// Return true if index is empty
inline bool amc::c_nsinclude_EmptyQ(amc::FNs& ns) {
    return ns.c_nsinclude_n == 0;
}

// --- amc.FNs.c_nsinclude.Find
// Look up row by row id. Return NULL if out of range
inline amc::FNsinclude* amc::c_nsinclude_Find(amc::FNs& ns, u32 t) {
    amc::FNsinclude *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_nsinclude_n;
    if (idx < lim) {
        retval = ns.c_nsinclude_elems[idx];
    }
    return retval;
}

// --- amc.FNs.c_nsinclude.Getary
// Return array of pointers
inline algo::aryptr<amc::FNsinclude*> amc::c_nsinclude_Getary(amc::FNs& ns) {
    return algo::aryptr<amc::FNsinclude*>(ns.c_nsinclude_elems, ns.c_nsinclude_n);
}

// --- amc.FNs.c_nsinclude.N
// Return number of items in the pointer array
inline i32 amc::c_nsinclude_N(const amc::FNs& ns) {
    return ns.c_nsinclude_n;
}

// --- amc.FNs.c_nsinclude.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_nsinclude_RemoveAll(amc::FNs& ns) {
    for (u32 i = 0; i < ns.c_nsinclude_n; i++) {
        // mark all elements as not-in-array
        ns.c_nsinclude_elems[i]->ns_c_nsinclude_in_ary = false;
    }
    ns.c_nsinclude_n = 0;
}

// --- amc.FNs.c_nsinclude.qFind
// Return reference without bounds checking
inline amc::FNsinclude& amc::c_nsinclude_qFind(amc::FNs& ns, u32 idx) {
    return *ns.c_nsinclude_elems[idx];
}

// --- amc.FNs.c_nsinclude.InAryQ
// True if row is in any ptrary instance
inline bool amc::ns_c_nsinclude_InAryQ(amc::FNsinclude& row) {
    return row.ns_c_nsinclude_in_ary;
}

// --- amc.FNs.c_nsinclude.qLast
// Reference to last element without bounds checking
inline amc::FNsinclude& amc::c_nsinclude_qLast(amc::FNs& ns) {
    return *ns.c_nsinclude_elems[ns.c_nsinclude_n-1];
}

// --- amc.FNs.c_nscpp.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_nscpp_InsertMaybe(amc::FNs& ns, amc::FNscpp& row) {
    amc::FNscpp* ptr = ns.c_nscpp;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_nscpp = &row;
    }
    return retval;
}

// --- amc.FNs.c_nscpp.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_nscpp_Remove(amc::FNs& ns, amc::FNscpp& row) {
    amc::FNscpp *ptr = ns.c_nscpp;
    if (LIKELY(ptr == &row)) {
        ns.c_nscpp = NULL;
    }
}

// --- amc.FNs.c_ctype_curs.Reset
inline void amc::ns_c_ctype_curs_Reset(ns_c_ctype_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_ctype_elems;
    curs.n_elems = parent.c_ctype_n;
    curs.index = 0;
}

// --- amc.FNs.c_ctype_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_ctype_curs_ValidQ(ns_c_ctype_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_ctype_curs.Next
// proceed to next item
inline void amc::ns_c_ctype_curs_Next(ns_c_ctype_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_ctype_curs.Access
// item access
inline amc::FCtype& amc::ns_c_ctype_curs_Access(ns_c_ctype_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_func_curs.Reset
inline void amc::ns_c_func_curs_Reset(ns_c_func_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_func_elems;
    curs.n_elems = parent.c_func_n;
    curs.index = 0;
}

// --- amc.FNs.c_func_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_func_curs_ValidQ(ns_c_func_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_func_curs.Next
// proceed to next item
inline void amc::ns_c_func_curs_Next(ns_c_func_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_func_curs.Access
// item access
inline amc::FFunc& amc::ns_c_func_curs_Access(ns_c_func_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_dispatch_curs.Reset
inline void amc::ns_c_dispatch_curs_Reset(ns_c_dispatch_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_dispatch_elems;
    curs.n_elems = parent.c_dispatch_n;
    curs.index = 0;
}

// --- amc.FNs.c_dispatch_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_dispatch_curs_ValidQ(ns_c_dispatch_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_dispatch_curs.Next
// proceed to next item
inline void amc::ns_c_dispatch_curs_Next(ns_c_dispatch_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_dispatch_curs.Access
// item access
inline amc::FDispatch& amc::ns_c_dispatch_curs_Access(ns_c_dispatch_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_gstatic_curs.Reset
inline void amc::ns_c_gstatic_curs_Reset(ns_c_gstatic_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_gstatic_elems;
    curs.n_elems = parent.c_gstatic_n;
    curs.index = 0;
}

// --- amc.FNs.c_gstatic_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_gstatic_curs_ValidQ(ns_c_gstatic_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_gstatic_curs.Next
// proceed to next item
inline void amc::ns_c_gstatic_curs_Next(ns_c_gstatic_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_gstatic_curs.Access
// item access
inline amc::FGstatic& amc::ns_c_gstatic_curs_Access(ns_c_gstatic_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.include_curs.Next
// proceed to next item
inline void amc::ns_include_curs_Next(ns_include_curs &curs) {
    curs.index++;
}

// --- amc.FNs.include_curs.Reset
inline void amc::ns_include_curs_Reset(ns_include_curs &curs, amc::FNs &parent) {
    curs.elems = parent.include_elems;
    curs.n_elems = parent.include_n;
    curs.index = 0;
}

// --- amc.FNs.include_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_include_curs_ValidQ(ns_include_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.include_curs.Access
// item access
inline algo::cstring& amc::ns_include_curs_Access(ns_include_curs &curs) {
    return curs.elems[curs.index];
}

// --- amc.FNs.c_dispsig_curs.Reset
inline void amc::ns_c_dispsig_curs_Reset(ns_c_dispsig_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_dispsig_elems;
    curs.n_elems = parent.c_dispsig_n;
    curs.index = 0;
}

// --- amc.FNs.c_dispsig_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_dispsig_curs_ValidQ(ns_c_dispsig_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_dispsig_curs.Next
// proceed to next item
inline void amc::ns_c_dispsig_curs_Next(ns_c_dispsig_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_dispsig_curs.Access
// item access
inline amc::FDispsig& amc::ns_c_dispsig_curs_Access(ns_c_dispsig_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_parentns_curs.Reset
inline void amc::ns_c_parentns_curs_Reset(ns_c_parentns_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_parentns_elems;
    curs.n_elems = parent.c_parentns_n;
    curs.index = 0;
}

// --- amc.FNs.c_parentns_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_parentns_curs_ValidQ(ns_c_parentns_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_parentns_curs.Next
// proceed to next item
inline void amc::ns_c_parentns_curs_Next(ns_c_parentns_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_parentns_curs.Access
// item access
inline amc::FNs& amc::ns_c_parentns_curs_Access(ns_c_parentns_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_cppincl_curs.Reset
inline void amc::ns_c_cppincl_curs_Reset(ns_c_cppincl_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_cppincl_elems;
    curs.n_elems = parent.c_cppincl_n;
    curs.index = 0;
}

// --- amc.FNs.c_cppincl_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_cppincl_curs_ValidQ(ns_c_cppincl_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_cppincl_curs.Next
// proceed to next item
inline void amc::ns_c_cppincl_curs_Next(ns_c_cppincl_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_cppincl_curs.Access
// item access
inline amc::FNs& amc::ns_c_cppincl_curs_Access(ns_c_cppincl_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_hdrincl_curs.Reset
inline void amc::ns_c_hdrincl_curs_Reset(ns_c_hdrincl_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_hdrincl_elems;
    curs.n_elems = parent.c_hdrincl_n;
    curs.index = 0;
}

// --- amc.FNs.c_hdrincl_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_hdrincl_curs_ValidQ(ns_c_hdrincl_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_hdrincl_curs.Next
// proceed to next item
inline void amc::ns_c_hdrincl_curs_Next(ns_c_hdrincl_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_hdrincl_curs.Access
// item access
inline amc::FNs& amc::ns_c_hdrincl_curs_Access(ns_c_hdrincl_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_fwddecl_curs.Reset
inline void amc::ns_c_fwddecl_curs_Reset(ns_c_fwddecl_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_fwddecl_elems;
    curs.n_elems = parent.c_fwddecl_n;
    curs.index = 0;
}

// --- amc.FNs.c_fwddecl_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_fwddecl_curs_ValidQ(ns_c_fwddecl_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_fwddecl_curs.Next
// proceed to next item
inline void amc::ns_c_fwddecl_curs_Next(ns_c_fwddecl_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_fwddecl_curs.Access
// item access
inline amc::FFwddecl& amc::ns_c_fwddecl_curs_Access(ns_c_fwddecl_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_pnew_curs.Reset
inline void amc::ns_c_pnew_curs_Reset(ns_c_pnew_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_pnew_elems;
    curs.n_elems = parent.c_pnew_n;
    curs.index = 0;
}

// --- amc.FNs.c_pnew_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_pnew_curs_ValidQ(ns_c_pnew_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_pnew_curs.Next
// proceed to next item
inline void amc::ns_c_pnew_curs_Next(ns_c_pnew_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_pnew_curs.Access
// item access
inline amc::FPnew& amc::ns_c_pnew_curs_Access(ns_c_pnew_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_outfile_curs.Reset
inline void amc::ns_c_outfile_curs_Reset(ns_c_outfile_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_outfile_elems;
    curs.n_elems = parent.c_outfile_n;
    curs.index = 0;
}

// --- amc.FNs.c_outfile_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_outfile_curs_ValidQ(ns_c_outfile_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_outfile_curs.Next
// proceed to next item
inline void amc::ns_c_outfile_curs_Next(ns_c_outfile_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_outfile_curs.Access
// item access
inline amc::FOutfile& amc::ns_c_outfile_curs_Access(ns_c_outfile_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_foutput_curs.Reset
inline void amc::ns_c_foutput_curs_Reset(ns_c_foutput_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_foutput_elems;
    curs.n_elems = parent.c_foutput_n;
    curs.index = 0;
}

// --- amc.FNs.c_foutput_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_foutput_curs_ValidQ(ns_c_foutput_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_foutput_curs.Next
// proceed to next item
inline void amc::ns_c_foutput_curs_Next(ns_c_foutput_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_foutput_curs.Access
// item access
inline amc::FFoutput& amc::ns_c_foutput_curs_Access(ns_c_foutput_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_fstep_curs.Reset
inline void amc::ns_c_fstep_curs_Reset(ns_c_fstep_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_fstep_elems;
    curs.n_elems = parent.c_fstep_n;
    curs.index = 0;
}

// --- amc.FNs.c_fstep_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_fstep_curs_ValidQ(ns_c_fstep_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_fstep_curs.Next
// proceed to next item
inline void amc::ns_c_fstep_curs_Next(ns_c_fstep_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_fstep_curs.Access
// item access
inline amc::FFstep& amc::ns_c_fstep_curs_Access(ns_c_fstep_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_gsymbol_curs.Reset
inline void amc::ns_c_gsymbol_curs_Reset(ns_c_gsymbol_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_gsymbol_elems;
    curs.n_elems = parent.c_gsymbol_n;
    curs.index = 0;
}

// --- amc.FNs.c_gsymbol_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_gsymbol_curs_ValidQ(ns_c_gsymbol_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_gsymbol_curs.Next
// proceed to next item
inline void amc::ns_c_gsymbol_curs_Next(ns_c_gsymbol_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_gsymbol_curs.Access
// item access
inline amc::FGsymbol& amc::ns_c_gsymbol_curs_Access(ns_c_gsymbol_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc.FNs.c_nsinclude_curs.Reset
inline void amc::ns_c_nsinclude_curs_Reset(ns_c_nsinclude_curs &curs, amc::FNs &parent) {
    curs.elems = parent.c_nsinclude_elems;
    curs.n_elems = parent.c_nsinclude_n;
    curs.index = 0;
}

// --- amc.FNs.c_nsinclude_curs.ValidQ
// cursor points to valid item
inline bool amc::ns_c_nsinclude_curs_ValidQ(ns_c_nsinclude_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FNs.c_nsinclude_curs.Next
// proceed to next item
inline void amc::ns_c_nsinclude_curs_Next(ns_c_nsinclude_curs &curs) {
    curs.index++;
}

// --- amc.FNs.c_nsinclude_curs.Access
// item access
inline amc::FNsinclude& amc::ns_c_nsinclude_curs_Access(ns_c_nsinclude_curs &curs) {
    return *curs.elems[curs.index];
}
inline amc::FNscpp::FNscpp() {
}

inline amc::FNscpp::~FNscpp() {
    amc::FNscpp_Uninit(*this);
}

inline amc::FNsdb::FNsdb() {
}

inline amc::FNsdb::~FNsdb() {
    amc::FNsdb_Uninit(*this);
}

inline amc::FNsinclude::FNsinclude() {
    amc::FNsinclude_Init(*this);
}

inline amc::FNsinclude::~FNsinclude() {
    amc::FNsinclude_Uninit(*this);
}


// --- amc.FNsinclude..Init
// Set all fields to initial values.
inline void amc::FNsinclude_Init(amc::FNsinclude& nsinclude) {
    nsinclude.sys = bool(false);
    nsinclude.ns_c_nsinclude_in_ary = bool(false);
}
inline amc::FNsproto::FNsproto() {
}

inline amc::FNsproto::~FNsproto() {
    amc::FNsproto_Uninit(*this);
}

inline amc::FNsx::FNsx() {
    amc::FNsx_Init(*this);
}

inline amc::FNsx::~FNsx() {
    amc::FNsx_Uninit(*this);
}


// --- amc.FNsx..Init
// Set all fields to initial values.
inline void amc::FNsx_Init(amc::FNsx& nsx) {
    nsx.genthrow = bool(false);
    nsx.correct_getorcreate = bool(false);
    nsx.sortxref = bool(false);
    nsx.pack = bool(false);
    nsx.p_pool = NULL;
}
inline amc::FNumstr::FNumstr() {
    amc::FNumstr_Init(*this);
}

inline amc::FNumstr::~FNumstr() {
    amc::FNumstr_Uninit(*this);
}


// --- amc.FNumstr..Init
// Set all fields to initial values.
inline void amc::FNumstr_Init(amc::FNumstr& numstr) {
    numstr.base = i32(0);
    numstr.min_len = i32(0);
    numstr.p_numtype = NULL;
    numstr.nummin = u64(0);
    numstr.nummax = u64(0);
    numstr.issigned = bool(false);
}
inline amc::FOutfile::FOutfile() {
    amc::FOutfile_Init(*this);
}

inline amc::FOutfile::~FOutfile() {
    amc::FOutfile_Uninit(*this);
}


// --- amc.FOutfile..Init
// Set all fields to initial values.
inline void amc::FOutfile_Init(amc::FOutfile& outfile) {
    outfile.p_ns = NULL;
    outfile.ns_c_outfile_in_ary = bool(false);
    outfile.outfile_next = (amc::FOutfile*)-1; // (amc.FDb.outfile) not-in-tpool's freelist
}
inline amc::FPack::FPack() {
    amc::FPack_Init(*this);
}

inline amc::FPack::~FPack() {
    amc::FPack_Uninit(*this);
}


// --- amc.FPack..Init
// Set all fields to initial values.
inline void amc::FPack_Init(amc::FPack& pack) {
    pack.p_ctype = NULL;
    pack.ind_pack_next = (amc::FPack*)-1; // (amc.FDb.ind_pack) not-in-hash
}
inline amc::FPmaskfld::FPmaskfld() {
    amc::FPmaskfld_Init(*this);
}

inline amc::FPmaskfld::~FPmaskfld() {
    amc::FPmaskfld_Uninit(*this);
}


// --- amc.FPmaskfld..Init
// Set all fields to initial values.
inline void amc::FPmaskfld_Init(amc::FPmaskfld& pmaskfld) {
    pmaskfld.p_field = NULL;
    pmaskfld.nextbit = u32(0);
}
inline amc::FPnew::FPnew() {
    amc::FPnew_Init(*this);
}

inline amc::FPnew::~FPnew() {
    amc::FPnew_Uninit(*this);
}


// --- amc.FPnew..Init
// Set all fields to initial values.
inline void amc::FPnew_Init(amc::FPnew& pnew) {
    pnew.p_ctype = NULL;
    pnew.p_ns = NULL;
    pnew.ns_c_pnew_in_ary = bool(false);
    pnew.ind_pnew_next = (amc::FPnew*)-1; // (amc.FDb.ind_pnew) not-in-hash
}
inline amc::FPtrary::FPtrary() {
    amc::FPtrary_Init(*this);
}

inline amc::FPtrary::~FPtrary() {
    amc::FPtrary_Uninit(*this);
}


// --- amc.FPtrary..Init
// Set all fields to initial values.
inline void amc::FPtrary_Init(amc::FPtrary& ptrary) {
    ptrary.unique = bool(false);
    ptrary.p_field = NULL;
}
inline amc::FReftype::FReftype() {
    amc::FReftype_Init(*this);
}

inline amc::FReftype::~FReftype() {
    amc::FReftype_Uninit(*this);
}


// --- amc.FReftype.zs_fprefix.EmptyQ
// Return true if index is empty
inline bool amc::zs_fprefix_EmptyQ(amc::FReftype& reftype) {
    return reftype.zs_fprefix_head == NULL;
}

// --- amc.FReftype.zs_fprefix.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc::FFprefix* amc::zs_fprefix_First(amc::FReftype& reftype) {
    amc::FFprefix *row = NULL;
    row = reftype.zs_fprefix_head;
    return row;
}

// --- amc.FReftype.zs_fprefix.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc::zs_fprefix_InLlistQ(amc::FFprefix& row) {
    bool result = false;
    result = !(row.zs_fprefix_next == (amc::FFprefix*)-1);
    return result;
}

// --- amc.FReftype.zs_fprefix.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc::FFprefix* amc::zs_fprefix_Last(amc::FReftype& reftype) {
    amc::FFprefix *row = NULL;
    row = reftype.zs_fprefix_tail;
    return row;
}

// --- amc.FReftype.zs_fprefix.Next
// Return pointer to next element in the list
inline amc::FFprefix* amc::zs_fprefix_Next(amc::FFprefix &row) {
    return row.zs_fprefix_next;
}

// --- amc.FReftype.zs_fprefix.qLast
// Return reference to last element in the index. No bounds checking.
inline amc::FFprefix& amc::zs_fprefix_qLast(amc::FReftype& reftype) {
    amc::FFprefix *row = NULL;
    row = reftype.zs_fprefix_tail;
    return *row;
}

// --- amc.FReftype.zs_fprefix_curs.Reset
// cursor points to valid item
inline void amc::reftype_zs_fprefix_curs_Reset(reftype_zs_fprefix_curs &curs, amc::FReftype &parent) {
    curs.row = parent.zs_fprefix_head;
}

// --- amc.FReftype.zs_fprefix_curs.ValidQ
// cursor points to valid item
inline bool amc::reftype_zs_fprefix_curs_ValidQ(reftype_zs_fprefix_curs &curs) {
    return curs.row != NULL;
}

// --- amc.FReftype.zs_fprefix_curs.Next
// proceed to next item
inline void amc::reftype_zs_fprefix_curs_Next(reftype_zs_fprefix_curs &curs) {
    amc::FFprefix *next = (*curs.row).zs_fprefix_next;
    curs.row = next;
}

// --- amc.FReftype.zs_fprefix_curs.Access
// item access
inline amc::FFprefix& amc::reftype_zs_fprefix_curs_Access(reftype_zs_fprefix_curs &curs) {
    return *curs.row;
}
inline amc::FRowid::FRowid() {
    amc::FRowid_Init(*this);
}

inline amc::FRowid::~FRowid() {
    amc::FRowid_Uninit(*this);
}


// --- amc.FRowid..Init
// Set all fields to initial values.
inline void amc::FRowid_Init(amc::FRowid& rowid) {
    rowid.ind_rowid_next = (amc::FRowid*)-1; // (amc.FDb.ind_rowid) not-in-hash
}
inline amc::FSmallstr::FSmallstr() {
    amc::FSmallstr_Init(*this);
}

inline amc::FSmallstr::~FSmallstr() {
    amc::FSmallstr_Uninit(*this);
}


// --- amc.FSmallstr.c_numstr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_numstr_InsertMaybe(amc::FSmallstr& smallstr, amc::FNumstr& row) {
    amc::FNumstr* ptr = smallstr.c_numstr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        smallstr.c_numstr = &row;
    }
    return retval;
}

// --- amc.FSmallstr.c_numstr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_numstr_Remove(amc::FSmallstr& smallstr, amc::FNumstr& row) {
    amc::FNumstr *ptr = smallstr.c_numstr;
    if (LIKELY(ptr == &row)) {
        smallstr.c_numstr = NULL;
    }
}

// --- amc.FSmallstr..Init
// Set all fields to initial values.
inline void amc::FSmallstr_Init(amc::FSmallstr& smallstr) {
    smallstr.length = i32(0);
    smallstr.strict = bool(false);
    smallstr.p_field = NULL;
    smallstr.c_numstr = NULL;
    smallstr.ind_smallstr_next = (amc::FSmallstr*)-1; // (amc.FDb.ind_smallstr) not-in-hash
}
inline amc::FSortfld::FSortfld() {
    amc::FSortfld_Init(*this);
}

inline amc::FSortfld::~FSortfld() {
    amc::FSortfld_Uninit(*this);
}


// --- amc.FSortfld..Init
// Set all fields to initial values.
inline void amc::FSortfld_Init(amc::FSortfld& sortfld) {
    sortfld.p_sortfld = NULL;
}
inline amc::FSsimfile::FSsimfile() {
    amc::FSsimfile_Init(*this);
}

inline amc::FSsimfile::~FSsimfile() {
    amc::FSsimfile_Uninit(*this);
}


// --- amc.FSsimfile.c_ssimvolatile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_ssimvolatile_InsertMaybe(amc::FSsimfile& ssimfile, amc::FSsimvolatile& row) {
    amc::FSsimvolatile* ptr = ssimfile.c_ssimvolatile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ssimfile.c_ssimvolatile = &row;
    }
    return retval;
}

// --- amc.FSsimfile.c_ssimvolatile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_ssimvolatile_Remove(amc::FSsimfile& ssimfile, amc::FSsimvolatile& row) {
    amc::FSsimvolatile *ptr = ssimfile.c_ssimvolatile;
    if (LIKELY(ptr == &row)) {
        ssimfile.c_ssimvolatile = NULL;
    }
}
inline amc::FSsimvolatile::FSsimvolatile() {
}

inline amc::FSsimvolatile::~FSsimvolatile() {
    amc::FSsimvolatile_Uninit(*this);
}

inline amc::FStatictuple::FStatictuple() {
    amc::FStatictuple_Init(*this);
}

inline amc::FStatictuple::~FStatictuple() {
    amc::FStatictuple_Uninit(*this);
}


// --- amc.FStatictuple..Init
// Set all fields to initial values.
inline void amc::FStatictuple_Init(amc::FStatictuple& static_tuple) {
    static_tuple.ctype_c_static_in_ary = bool(false);
}
inline amc::FSubstr::FSubstr() {
    amc::FSubstr_Init(*this);
}

inline amc::FSubstr::~FSubstr() {
    amc::FSubstr_Uninit(*this);
}


// --- amc.FSubstr..Init
// Set all fields to initial values.
inline void amc::FSubstr_Init(amc::FSubstr& substr) {
    substr.p_field = NULL;
    substr.p_srcfield = NULL;
    substr.range = u64(0);
    substr._db_c_substr_field_in_ary = bool(false);
    substr.zd_substr_params_next = (amc::FSubstr*)-1; // (amc.FDb.zd_substr_params) not-in-list
    substr.zd_substr_params_prev = NULL; // (amc.FDb.zd_substr_params)
}
inline amc::FTargdep::FTargdep() {
    amc::FTargdep_Init(*this);
}

inline amc::FTargdep::~FTargdep() {
    amc::FTargdep_Uninit(*this);
}


// --- amc.FTargdep..Init
// Set all fields to initial values.
inline void amc::FTargdep_Init(amc::FTargdep& targdep) {
    targdep.p_target = NULL;
    targdep.p_parent = NULL;
    targdep.target_c_targdep_in_ary = bool(false);
}
inline amc::FTarget::FTarget() {
    amc::FTarget_Init(*this);
}

inline amc::FTarget::~FTarget() {
    amc::FTarget_Uninit(*this);
}


// --- amc.FTarget.c_targdep.EmptyQ
// Return true if index is empty
inline bool amc::c_targdep_EmptyQ(amc::FTarget& target) {
    return target.c_targdep_n == 0;
}

// --- amc.FTarget.c_targdep.Find
// Look up row by row id. Return NULL if out of range
inline amc::FTargdep* amc::c_targdep_Find(amc::FTarget& target, u32 t) {
    amc::FTargdep *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_targdep_n;
    if (idx < lim) {
        retval = target.c_targdep_elems[idx];
    }
    return retval;
}

// --- amc.FTarget.c_targdep.Getary
// Return array of pointers
inline algo::aryptr<amc::FTargdep*> amc::c_targdep_Getary(amc::FTarget& target) {
    return algo::aryptr<amc::FTargdep*>(target.c_targdep_elems, target.c_targdep_n);
}

// --- amc.FTarget.c_targdep.N
// Return number of items in the pointer array
inline i32 amc::c_targdep_N(const amc::FTarget& target) {
    return target.c_targdep_n;
}

// --- amc.FTarget.c_targdep.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc::c_targdep_RemoveAll(amc::FTarget& target) {
    for (u32 i = 0; i < target.c_targdep_n; i++) {
        // mark all elements as not-in-array
        target.c_targdep_elems[i]->target_c_targdep_in_ary = false;
    }
    target.c_targdep_n = 0;
}

// --- amc.FTarget.c_targdep.qFind
// Return reference without bounds checking
inline amc::FTargdep& amc::c_targdep_qFind(amc::FTarget& target, u32 idx) {
    return *target.c_targdep_elems[idx];
}

// --- amc.FTarget.c_targdep.InAryQ
// True if row is in any ptrary instance
inline bool amc::target_c_targdep_InAryQ(amc::FTargdep& row) {
    return row.target_c_targdep_in_ary;
}

// --- amc.FTarget.c_targdep.qLast
// Reference to last element without bounds checking
inline amc::FTargdep& amc::c_targdep_qLast(amc::FTarget& target) {
    return *target.c_targdep_elems[target.c_targdep_n-1];
}

// --- amc.FTarget..Init
// Set all fields to initial values.
inline void amc::FTarget_Init(amc::FTarget& target) {
    target.compat = algo::strptr("Linux-%.%-%");
    target.c_targdep_elems = NULL; // (amc.FTarget.c_targdep)
    target.c_targdep_n = 0; // (amc.FTarget.c_targdep)
    target.c_targdep_max = 0; // (amc.FTarget.c_targdep)
    target.p_ns = NULL;
    target.ind_target_next = (amc::FTarget*)-1; // (amc.FDb.ind_target) not-in-hash
}

// --- amc.FTarget.c_targdep_curs.Reset
inline void amc::target_c_targdep_curs_Reset(target_c_targdep_curs &curs, amc::FTarget &parent) {
    curs.elems = parent.c_targdep_elems;
    curs.n_elems = parent.c_targdep_n;
    curs.index = 0;
}

// --- amc.FTarget.c_targdep_curs.ValidQ
// cursor points to valid item
inline bool amc::target_c_targdep_curs_ValidQ(target_c_targdep_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc.FTarget.c_targdep_curs.Next
// proceed to next item
inline void amc::target_c_targdep_curs_Next(target_c_targdep_curs &curs) {
    curs.index++;
}

// --- amc.FTarget.c_targdep_curs.Access
// item access
inline amc::FTargdep& amc::target_c_targdep_curs_Access(target_c_targdep_curs &curs) {
    return *curs.elems[curs.index];
}
inline amc::FTary::FTary() {
    amc::FTary_Init(*this);
}

inline amc::FTary::~FTary() {
    amc::FTary_Uninit(*this);
}


// --- amc.FTary..Init
// Set all fields to initial values.
inline void amc::FTary_Init(amc::FTary& tary) {
    tary.aliased = bool(false);
    tary.p_field = NULL;
    tary.ind_tary_next = (amc::FTary*)-1; // (amc.FDb.ind_tary) not-in-hash
}
inline amc::FTcurs::FTcurs() {
    amc::FTcurs_Init(*this);
}

inline amc::FTcurs::~FTcurs() {
    amc::FTcurs_Uninit(*this);
}


// --- amc.FTcurs..Init
// Set all fields to initial values.
inline void amc::FTcurs_Init(amc::FTcurs& tcurs) {
    tcurs.dflt = bool(false);
}
inline amc::FTfunc::FTfunc() {
    amc::FTfunc_Init(*this);
}

inline amc::FTfunc::~FTfunc() {
    amc::FTfunc_Uninit(*this);
}


// --- amc.FTfunc.step.Call
// Invoke function by pointer
inline void amc::step_Call(amc::FTfunc& tfunc) {
    if (tfunc.step) {
        tfunc.step();
    }
}

// --- amc.FTfunc.c_tcurs.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_tcurs_InsertMaybe(amc::FTfunc& tfunc, amc::FTcurs& row) {
    amc::FTcurs* ptr = tfunc.c_tcurs;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        tfunc.c_tcurs = &row;
    }
    return retval;
}

// --- amc.FTfunc.c_tcurs.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_tcurs_Remove(amc::FTfunc& tfunc, amc::FTcurs& row) {
    amc::FTcurs *ptr = tfunc.c_tcurs;
    if (LIKELY(ptr == &row)) {
        tfunc.c_tcurs = NULL;
    }
}
inline amc::FThash::FThash() {
    amc::FThash_Init(*this);
}

inline amc::FThash::~FThash() {
    amc::FThash_Uninit(*this);
}


// --- amc.FThash..Init
// Set all fields to initial values.
inline void amc::FThash_Init(amc::FThash& thash) {
    thash.unique = bool(true);
    thash.p_hashfld = NULL;
    thash.p_field = NULL;
}
inline amc::FTracefld::FTracefld() {
}

inline amc::FTracerec::FTracerec() {
}

inline amc::FTypefld::FTypefld() {
    amc::FTypefld_Init(*this);
}

inline amc::FTypefld::~FTypefld() {
    amc::FTypefld_Uninit(*this);
}


// --- amc.FTypefld..Init
// Set all fields to initial values.
inline void amc::FTypefld_Init(amc::FTypefld& typefld) {
    typefld.p_field = NULL;
    typefld.p_ctype = NULL;
}
inline amc::FUsertracefld::FUsertracefld() {
}

inline amc::FXref::FXref() {
    amc::FXref_Init(*this);
}

inline amc::FXref::~FXref() {
    amc::FXref_Uninit(*this);
}


// --- amc.FXref.c_nocascdel.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc::c_nocascdel_InsertMaybe(amc::FXref& xref, amc::FNocascdel& row) {
    amc::FNocascdel* ptr = xref.c_nocascdel;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        xref.c_nocascdel = &row;
    }
    return retval;
}

// --- amc.FXref.c_nocascdel.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc::c_nocascdel_Remove(amc::FXref& xref, amc::FNocascdel& row) {
    amc::FNocascdel *ptr = xref.c_nocascdel;
    if (LIKELY(ptr == &row)) {
        xref.c_nocascdel = NULL;
    }
}
inline amc::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline amc::FieldId::FieldId(amc_FieldIdEnum arg) { this->value = i32(arg); }
inline amc::FieldId::FieldId() {
    amc::FieldId_Init(*this);
}


// --- amc.FieldId.value.GetEnum
// Get value of field as enum type
inline amc_FieldIdEnum amc::value_GetEnum(const amc::FieldId& parent) {
    return amc_FieldIdEnum(parent.value);
}

// --- amc.FieldId.value.SetEnum
// Set value of field from enum type.
inline void amc::value_SetEnum(amc::FieldId& parent, amc_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- amc.FieldId.value.Cast
inline amc::FieldId::operator amc_FieldIdEnum () const {
    return amc_FieldIdEnum((*this).value);
}

// --- amc.FieldId..Init
// Set all fields to initial values.
inline void amc::FieldId_Init(amc::FieldId& parent) {
    parent.value = i32(-1);
}
inline amc::Funcarg::Funcarg() {
    amc::Funcarg_Init(*this);
}


// --- amc.Funcarg..Init
// Set all fields to initial values.
inline void amc::Funcarg_Init(amc::Funcarg& funcarg) {
    funcarg.retval = bool(false);
    funcarg.initialized = bool(false);
    funcarg.indent = bool(false);
    funcarg.typearg = bool(false);
}
inline amc::Genpnew::Genpnew() {
    amc::Genpnew_Init(*this);
}

inline amc::Pnewtype::Pnewtype(u8                             in_value)
    : value(in_value)
{
}
inline amc::Pnewtype::Pnewtype(amc_PnewtypeEnum arg) { this->value = u8(arg); }
inline amc::Pnewtype::Pnewtype() {
    amc::Pnewtype_Init(*this);
}


// --- amc.Pnewtype.value.GetEnum
// Get value of field as enum type
inline amc_PnewtypeEnum amc::value_GetEnum(const amc::Pnewtype& parent) {
    return amc_PnewtypeEnum(parent.value);
}

// --- amc.Pnewtype.value.SetEnum
// Set value of field from enum type.
inline void amc::value_SetEnum(amc::Pnewtype& parent, amc_PnewtypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- amc.Pnewtype.value.Cast
inline amc::Pnewtype::operator amc_PnewtypeEnum () const {
    return amc_PnewtypeEnum((*this).value);
}

// --- amc.Pnewtype..Init
// Set all fields to initial values.
inline void amc::Pnewtype_Init(amc::Pnewtype& parent) {
    parent.value = u8(0);
}
inline amc::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline amc::TableId::TableId(amc_TableIdEnum arg) { this->value = i32(arg); }
inline amc::TableId::TableId() {
    amc::TableId_Init(*this);
}


// --- amc.TableId.value.GetEnum
// Get value of field as enum type
inline amc_TableIdEnum amc::value_GetEnum(const amc::TableId& parent) {
    return amc_TableIdEnum(parent.value);
}

// --- amc.TableId.value.SetEnum
// Set value of field from enum type.
inline void amc::value_SetEnum(amc::TableId& parent, amc_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- amc.TableId.value.Cast
inline amc::TableId::operator amc_TableIdEnum () const {
    return amc_TableIdEnum((*this).value);
}

// --- amc.TableId..Init
// Set all fields to initial values.
inline void amc::TableId_Init(amc::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc::BltinId &row) {// cfmt:amc.BltinId.String
    amc::BltinId_Print(const_cast<amc::BltinId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc::Enumstr &row) {// cfmt:amc.Enumstr.String
    amc::Enumstr_Print(const_cast<amc::Enumstr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc::trace &row) {// cfmt:amc.trace.String
    amc::trace_Print(const_cast<amc::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc::FieldId &row) {// cfmt:amc.FieldId.String
    amc::FieldId_Print(const_cast<amc::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc::Pnewtype &row) {// cfmt:amc.Pnewtype.String
    amc::Pnewtype_Print(const_cast<amc::Pnewtype&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc::TableId &row) {// cfmt:amc.TableId.String
    amc::TableId_Print(const_cast<amc::TableId&>(row), str);
    return str;
}
