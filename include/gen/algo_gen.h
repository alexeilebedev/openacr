//
// include/gen/algo_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
//#pragma endinclude
// gen:ns_enums

// --- algo_BoolEnum

enum algo_BoolEnum {        // algo.Bool.value
     algo_Bool_N       = 0
    ,algo_Bool_Y       = 1
    ,algo_Bool_true    = 1
    ,algo_Bool_false   = 0
    ,algo_Bool_0       = 0
    ,algo_Bool_1       = 1
    ,algo_Bool_off     = 0
    ,algo_Bool_on      = 1
    ,algo_Bool_no      = 0
    ,algo_Bool_yes     = 1
};

enum { algo_BoolEnum_N = 10 };


// --- algo_EchoQEnum

enum algo_EchoQEnum {        // algo.EchoQ.value
     algo_EchoQ_true    = 1
    ,algo_EchoQ_false   = 0
};

enum { algo_EchoQEnum_N = 2 };


// --- algo_ErrnsEnum

enum algo_ErrnsEnum {       // algo.Errns.value
     algo_Errns_unix   = 0
    ,algo_Errns_win    = 1
};

enum { algo_ErrnsEnum_N = 2 };


// --- algo_FailokQEnum

enum algo_FailokQEnum {        // algo.FailokQ.value
     algo_FailokQ_true    = 1
    ,algo_FailokQ_false   = 0
};

enum { algo_FailokQEnum_N = 2 };


// --- algo_FieldIdEnum

enum algo_FieldIdEnum {                    // algo.FieldId.value
     algo_FieldId_name               = 0
    ,algo_FieldId_value              = 1
    ,algo_FieldId_ch                 = 2
    ,algo_FieldId_min                = 3
    ,algo_FieldId_max                = 4
    ,algo_FieldId_append             = 5
    ,algo_FieldId_read               = 6
    ,algo_FieldId_write              = 7
    ,algo_FieldId__throw             = 8
    ,algo_FieldId_temp               = 9
    ,algo_FieldId_overlap            = 10
    ,algo_FieldId_linear             = 11
    ,algo_FieldId_printerr           = 12
    ,algo_FieldId_eof                = 13
    ,algo_FieldId_err                = 14
    ,algo_FieldId_x                  = 15
    ,algo_FieldId_y                  = 16
    ,algo_FieldId_ip_host            = 17
    ,algo_FieldId_mask               = 18
    ,algo_FieldId_ok                 = 19
    ,algo_FieldId_neg                = 20
    ,algo_FieldId_overflow           = 21
    ,algo_FieldId_hex                = 22
    ,algo_FieldId_sha1sig            = 23
    ,algo_FieldId_attrs              = 24
    ,algo_FieldId_head               = 25
    ,algo_FieldId_protocol           = 26
    ,algo_FieldId_username           = 27
    ,algo_FieldId_password           = 28
    ,algo_FieldId_server             = 29
    ,algo_FieldId_dir                = 30
    ,algo_FieldId_port               = 31
    ,algo_FieldId_source_addr_host   = 32
    ,algo_FieldId_host               = 33
};

enum { algo_FieldIdEnum_N = 34 };


// --- algo_FileFlagsEnum

enum algo_FileFlagsEnum {                      // algo.FileFlags.value
     algo_FileFlags_read       = (u32(1)<<0)   // algo.FileFlags.read
    ,algo_FileFlags_write      = (u32(1)<<1)   // algo.FileFlags.write
    ,algo_FileFlags_append     = (u32(1)<<4)   // algo.FileFlags.append
    ,algo_FileFlags__throw     = (u32(1)<<5)   // algo.FileFlags._throw
    ,algo_FileFlags_temp       = (u32(1)<<6)   // algo.FileFlags.temp
    ,algo_FileFlags_overlap    = (u32(1)<<7)   // algo.FileFlags.overlap
    ,algo_FileFlags_linear     = (u32(1)<<8)   // algo.FileFlags.linear
    ,algo_FileFlags_printerr   = (u32(1)<<9)   // algo.FileFlags.printerr
};

enum { algo_FileFlagsEnum_N = 8 };


// --- algo_IOEvtFlagsEnum

enum algo_IOEvtFlagsEnum {                   // algo.IOEvtFlags.value
     algo_IOEvtFlags_read    = (u32(1)<<0)   // algo.IOEvtFlags.read
    ,algo_IOEvtFlags_write   = (u32(1)<<1)   // algo.IOEvtFlags.write
    ,algo_IOEvtFlags_eof     = (u32(1)<<2)   // algo.IOEvtFlags.eof
    ,algo_IOEvtFlags_err     = (u32(1)<<3)   // algo.IOEvtFlags.err
};

enum { algo_IOEvtFlagsEnum_N = 4 };


// --- algo_MonthEnum

enum algo_MonthEnum {             // algo.Month.value
     algo_Month_January     = 1
    ,algo_Month_February    = 2
    ,algo_Month_March       = 3
    ,algo_Month_April       = 4
    ,algo_Month_May         = 5
    ,algo_Month_June        = 6
    ,algo_Month_July        = 7
    ,algo_Month_August      = 8
    ,algo_Month_September   = 9
    ,algo_Month_October     = 10
    ,algo_Month_November    = 11
    ,algo_Month_December    = 12
    ,algo_Month_None        = 0
};

enum { algo_MonthEnum_N = 13 };


// --- algo_NumParseFlagsEnum

enum algo_NumParseFlagsEnum {                      // algo.NumParseFlags.value
     algo_NumParseFlags_err        = (u32(1)<<0)   // algo.NumParseFlags.err
    ,algo_NumParseFlags_ok         = (u32(1)<<1)   // algo.NumParseFlags.ok
    ,algo_NumParseFlags_neg        = (u32(1)<<2)   // algo.NumParseFlags.neg
    ,algo_NumParseFlags_overflow   = (u32(1)<<3)   // algo.NumParseFlags.overflow
    ,algo_NumParseFlags_hex        = (u32(1)<<4)   // algo.NumParseFlags.hex
};

enum { algo_NumParseFlagsEnum_N = 5 };


// --- algo_TermStyleEnum

enum algo_TermStyleEnum {             // algo.TermStyle.value
     algo_TermStyle_default   = 0
    ,algo_TermStyle_red       = 1<<0
    ,algo_TermStyle_green     = 1<<1
    ,algo_TermStyle_blue      = 1<<2
    ,algo_TermStyle_bold      = 1<<3
};

enum { algo_TermStyleEnum_N = 5 };


// --- algo_TextJustEnum

enum algo_TextJustEnum {            // algo.TextJust.value
     algo_TextJust_j_right    = 1
    ,algo_TextJust_j_left     = -1
    ,algo_TextJust_j_center   = 0
};

enum { algo_TextJustEnum_N = 3 };

namespace algo { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace algo { // gen:ns_field
} // gen:ns_field
// gen:ns_fwddecl2
namespace algo { struct cstring_ch_curs; }
namespace algo { struct ByteAry_ary_curs; }
namespace algo { struct Charset_ch_bitcurs; }
namespace algo { struct Charset_ch_curs; }
namespace algo { struct LineBuf_buf_curs; }
namespace algo { struct Md5Digest_value_curs; }
namespace algo { struct NormTxttbl_start_curs; }
namespace algo { struct Sha1sig_sha1sig_curs; }
namespace algo { struct Tuple_attrs_curs; }
namespace algo { struct U64Ary_ary_curs; }
namespace lib_json { struct FNode; }
namespace algo { struct cstring; }
namespace algo { struct Attr; }
namespace algo { struct Bool; }
namespace algo { struct ByteAry; }
namespace algo { struct Charset; }
namespace algo { struct Smallstr150; }
namespace algo { struct Comment; }
namespace algo { struct Smallstr250; }
namespace algo { struct CppExpr; }
namespace algo { struct UnTime; }
namespace algo { struct DateCache; }
namespace algo { struct Dbbox; }
namespace algo { struct DirEntry; }
namespace algo { struct DryrunQ; }
namespace algo { struct EchoQ; }
namespace algo { struct Errns; }
namespace algo { struct Errcode; }
namespace algo { struct FailokQ; }
namespace algo { struct FieldId; }
namespace algo { struct Fildes; }
namespace algo { struct FileFlags; }
namespace algo { struct I32Dec1; }
namespace algo { struct I32Dec2; }
namespace algo { struct I32Dec3; }
namespace algo { struct I32Dec4; }
namespace algo { struct I32Dec5; }
namespace algo { struct I64Dec1; }
namespace algo { struct I64Dec10; }
namespace algo { struct I64Dec2; }
namespace algo { struct I64Dec3; }
namespace algo { struct I64Dec4; }
namespace algo { struct I64Dec5; }
namespace algo { struct I64Dec6; }
namespace algo { struct I64Dec7; }
namespace algo { struct I64Dec8; }
namespace algo { struct I64Dec9; }
namespace algo { struct IOEvtFlags; }
namespace algo { struct IPoint; }
namespace algo { struct Smallstr50; }
namespace algo { struct Imdb; }
namespace algo { struct ImrowPtr; }
namespace algo { struct Imtable; }
namespace algo { struct Ipmask; }
namespace algo { struct LineBuf; }
namespace algo { struct LnumStr10_U64; }
namespace algo { struct LnumStr11_U64; }
namespace algo { struct LnumStr12_U64; }
namespace algo { struct LnumStr13_U64_Base36; }
namespace algo { struct LnumStr16_U64_Base16; }
namespace algo { struct LnumStr1_U32; }
namespace algo { struct LnumStr20_U64; }
namespace algo { struct LnumStr22_U64; }
namespace algo { struct LnumStr2_U32; }
namespace algo { struct LnumStr3_U32; }
namespace algo { struct LnumStr4_U32; }
namespace algo { struct LnumStr5_U32; }
namespace algo { struct LnumStr5_U32_Base36; }
namespace algo { struct LnumStr6_U32; }
namespace algo { struct LnumStr7_U32; }
namespace algo { struct LnumStr7_U32_Base36; }
namespace algo { struct LnumStr8_U32; }
namespace algo { struct LnumStr8_U32_Base16; }
namespace algo { struct LnumStr8_U64; }
namespace algo { struct LnumStr9_U32; }
namespace algo { struct LnumStr9_U64; }
namespace algo { struct LogcatId; }
namespace algo { struct LogcatKey; }
namespace algo { struct SchedTime; }
namespace algo { struct Smallstr200; }
namespace algo { struct Logmsg; }
namespace algo { struct LspaceStr10; }
namespace algo { struct LspaceStr12; }
namespace algo { struct LspaceStr14; }
namespace algo { struct LspaceStr15; }
namespace algo { struct LspaceStr20_I64; }
namespace algo { struct LspaceStr20_U64; }
namespace algo { struct LspaceStr3; }
namespace algo { struct LspaceStr3_I16; }
namespace algo { struct LspaceStr4; }
namespace algo { struct LspaceStr5; }
namespace algo { struct LspaceStr5_I16; }
namespace algo { struct LspaceStr6; }
namespace algo { struct LspaceStr6_U32; }
namespace algo { struct LspaceStr7_I32_Base36; }
namespace algo { struct LspaceStr8; }
namespace algo { struct LspaceStr9; }
namespace algo { struct Md5Digest; }
namespace algo { struct Month; }
namespace algo { struct NormTxttbl; }
namespace algo { struct NumParseFlags; }
namespace algo { struct Protocol; }
namespace algo { struct RnullStr1; }
namespace algo { struct RnullStr10; }
namespace algo { struct RnullStr100; }
namespace algo { struct RnullStr1000; }
namespace algo { struct RnullStr11; }
namespace algo { struct RnullStr12; }
namespace algo { struct RnullStr129; }
namespace algo { struct RnullStr13; }
namespace algo { struct RnullStr14; }
namespace algo { struct RnullStr15; }
namespace algo { struct RnullStr151; }
namespace algo { struct RnullStr16; }
namespace algo { struct RnullStr17; }
namespace algo { struct RnullStr18; }
namespace algo { struct RnullStr19; }
namespace algo { struct RnullStr2; }
namespace algo { struct RnullStr20; }
namespace algo { struct RnullStr21; }
namespace algo { struct RnullStr24; }
namespace algo { struct RnullStr25; }
namespace algo { struct RnullStr28; }
namespace algo { struct RnullStr3; }
namespace algo { struct RnullStr30; }
namespace algo { struct RnullStr32; }
namespace algo { struct RnullStr33; }
namespace algo { struct RnullStr35; }
namespace algo { struct RnullStr36; }
namespace algo { struct RnullStr4; }
namespace algo { struct RnullStr40; }
namespace algo { struct RnullStr41; }
namespace algo { struct RnullStr43; }
namespace algo { struct RnullStr44; }
namespace algo { struct RnullStr48; }
namespace algo { struct RnullStr5; }
namespace algo { struct RnullStr50; }
namespace algo { struct RnullStr54; }
namespace algo { struct RnullStr55; }
namespace algo { struct RnullStr6; }
namespace algo { struct RnullStr60; }
namespace algo { struct RnullStr62; }
namespace algo { struct RnullStr66; }
namespace algo { struct RnullStr6_U32; }
namespace algo { struct RnullStr7; }
namespace algo { struct RnullStr8; }
namespace algo { struct RnullStr80; }
namespace algo { struct RnullStr9; }
namespace algo { struct RspaceStr10; }
namespace algo { struct RspaceStr100; }
namespace algo { struct RspaceStr11; }
namespace algo { struct RspaceStr12; }
namespace algo { struct RspaceStr128; }
namespace algo { struct RspaceStr14; }
namespace algo { struct RspaceStr15; }
namespace algo { struct RspaceStr16; }
namespace algo { struct RspaceStr18; }
namespace algo { struct RspaceStr2; }
namespace algo { struct RspaceStr20; }
namespace algo { struct RspaceStr200; }
namespace algo { struct RspaceStr21; }
namespace algo { struct RspaceStr24; }
namespace algo { struct RspaceStr240; }
namespace algo { struct RspaceStr25; }
namespace algo { struct RspaceStr26; }
namespace algo { struct RspaceStr3; }
namespace algo { struct RspaceStr31; }
namespace algo { struct RspaceStr32; }
namespace algo { struct RspaceStr4; }
namespace algo { struct RspaceStr40; }
namespace algo { struct RspaceStr5; }
namespace algo { struct RspaceStr50; }
namespace algo { struct RspaceStr6; }
namespace algo { struct RspaceStr64; }
namespace algo { struct RspaceStr7; }
namespace algo { struct RspaceStr75; }
namespace algo { struct RspaceStr8; }
namespace algo { struct RspaceStr9; }
namespace algo { struct SeqType; }
namespace algo { struct Sha1sig; }
namespace algo { struct Smallstr1; }
namespace algo { struct Smallstr10; }
namespace algo { struct Smallstr100; }
namespace algo { struct Smallstr16; }
namespace algo { struct Smallstr2; }
namespace algo { struct Smallstr20; }
namespace algo { struct Smallstr25; }
namespace algo { struct Smallstr3; }
namespace algo { struct Smallstr30; }
namespace algo { struct Smallstr32; }
namespace algo { struct Smallstr4; }
namespace algo { struct Smallstr40; }
namespace algo { struct Smallstr5; }
namespace algo { struct TermStyle; }
namespace algo { struct TextJust; }
namespace algo { struct TstampCache; }
namespace algo { struct Tuple; }
namespace algo { struct U16Dec2; }
namespace algo { struct U32Dec1; }
namespace algo { struct U32Dec2; }
namespace algo { struct U32Dec3; }
namespace algo { struct U32Dec4; }
namespace algo { struct U32Dec5; }
namespace algo { struct U64Ary; }
namespace algo { struct U64Dec10; }
namespace algo { struct U64Dec2; }
namespace algo { struct U64Dec4; }
namespace algo { struct U64Dec5; }
namespace algo { struct U64Dec6; }
namespace algo { struct U64Dec7; }
namespace algo { struct U64Dec8; }
namespace algo { struct U64Dec9; }
namespace algo { struct URL; }
namespace algo { struct UnDiff; }
namespace algo { struct UnixDiff; }
namespace algo { struct UnixTime; }
namespace algo { struct WDiff; }
namespace algo { struct WTime; }
namespace algo { struct i32_Range; }
namespace algo { // gen:ns_print_struct

// --- algo.cstring
struct cstring { // algo.cstring
    char*   ch_elems;   // pointer to elements
    u32     ch_n;       // number of elements in array
    u32     ch_max;     // max. capacity of array before realloc
    cstring& operator =(const algo::strptr &t);
    cstring(const cstring &t);
    cstring& operator =(const cstring &s);
    explicit cstring(const algo::strptr &s);
    cstring(const tempstr &rhs);
    operator algo::strptr() const {
        return algo::strptr(const_cast<char*>(ch_elems),ch_n);
    }
    bool operator ==(const algo::cstring &rhs) const;
    bool operator !=(const algo::cstring &rhs) const;
    bool operator <(const algo::cstring &rhs) const;
    bool operator >(const algo::cstring &rhs) const;
    bool operator <=(const algo::cstring &rhs) const;
    bool operator >=(const algo::cstring &rhs) const;
    cstring();
    ~cstring();
};

bool                 ch_Eq(const algo::cstring& parent,const algo::cstring &rhs) __attribute__((nothrow));
int                  ch_Cmp(algo::cstring& parent, algo::cstring &rhs) __attribute__((nothrow));
// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<char>   ch_Addary(algo::cstring& parent, algo::aryptr<char> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
char&                ch_Alloc(algo::cstring& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
char&                ch_AllocAt(algo::cstring& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char>   ch_AllocN(algo::cstring& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ch_EmptyQ(algo::cstring& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
char*                ch_Find(algo::cstring& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<char>   ch_Getary(algo::cstring& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
char*                ch_Last(algo::cstring& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  ch_Max(algo::cstring& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  ch_N(const algo::cstring& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 ch_Remove(algo::cstring& parent, u32 i) __attribute__((nothrow));
void                 ch_RemoveAll(algo::cstring& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ch_RemoveLast(algo::cstring& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 ch_Reserve(algo::cstring& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 ch_AbsReserve(algo::cstring& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 ch_Setary(algo::cstring& parent, algo::cstring &rhs) __attribute__((nothrow));
// Copy specified array into ch, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 ch_Setary(algo::cstring& parent, const algo::aryptr<char> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
char&                ch_qFind(algo::cstring& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
char&                ch_qLast(algo::cstring& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  ch_rowid_Get(algo::cstring& parent, char &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char>   ch_AllocNVal(algo::cstring& parent, int n_elems, const char& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 cstring_ch_curs_Next(cstring_ch_curs &curs);
void                 cstring_ch_curs_Reset(cstring_ch_curs &curs, algo::cstring &parent);
// cursor points to valid item
bool                 cstring_ch_curs_ValidQ(cstring_ch_curs &curs);
// item access
char&                cstring_ch_curs_Access(cstring_ch_curs &curs);
u32                  cstring_Hash(u32 prev, const algo::cstring & rhs) __attribute__((nothrow));
// Read fields of algo::cstring from an ascii string.
// The function is implemented externally.
bool                 cstring_ReadStrptrMaybe(algo::cstring &parent, algo::strptr in_str);
bool                 cstring_Lt(algo::cstring & lhs, algo::cstring & rhs) __attribute__((nothrow));
i32                  cstring_Cmp(algo::cstring & lhs, algo::cstring & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 cstring_Init(algo::cstring& parent);
void                 cstring_Uninit(algo::cstring& parent) __attribute__((nothrow));
bool                 cstring_Eq(const algo::cstring & lhs,const algo::cstring & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 cstring_Update(algo::cstring &lhs, algo::cstring & rhs) __attribute__((nothrow));
// Convert algo::cstring to a string (user-implemented function)
void                 cstring_Print(algo::cstring & row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of algo::cstring under PARENT node -- implemented externally
lib_json::FNode *    cstring_FmtJson(algo::cstring & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- algo.Attr
// create: algo.Tuple.attrs (Tary)
struct Attr { // algo.Attr
    algo::cstring   name;    // attribute name
    algo::cstring   value;   // attribute value
    explicit Attr(const algo::strptr&            in_name
        ,const algo::strptr&            in_value);
    bool operator ==(const algo::Attr &rhs) const;
    bool operator !=(const algo::Attr &rhs) const;
    Attr();
};

// Read fields of algo::Attr from an ascii string.
// The function is implemented externally.
bool                 Attr_ReadStrptrMaybe(algo::Attr &parent, algo::strptr in_str);
i32                  Attr_Cmp(algo::Attr & lhs, algo::Attr & rhs) __attribute__((nothrow));
bool                 Attr_Eq(const algo::Attr & lhs,const algo::Attr & rhs) __attribute__((nothrow));
// Convert algo::Attr to a string (user-implemented function)
void                 Attr_Print(algo::Attr & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Bool
struct Bool { // algo.Bool
    u8   value;   //   false
    inline operator algo_BoolEnum() const;
    explicit Bool(u8                             in_value);
    Bool(algo_BoolEnum arg);
    Bool();
};

// Get value of field as enum type
algo_BoolEnum        value_GetEnum(const algo::Bool& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::Bool& parent, algo_BoolEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::Bool& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::Bool& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::Bool& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::Bool& parent, algo::strptr rhs, algo_BoolEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 Bool_Init(algo::Bool& parent);
// Convert algo::Bool to a string (user-implemented function)
void                 Bool_Print(algo::Bool row, algo::cstring &str) __attribute__((nothrow));

// --- algo.ByteAry
struct ByteAry { // algo.ByteAry
    u8*   ary_elems;   // pointer to elements
    u32   ary_n;       // number of elements in array
    u32   ary_max;     // max. capacity of array before realloc
    ByteAry();
    ~ByteAry();
private:
    // reftype Tary of algo.ByteAry.ary prohibits copy
    ByteAry(const ByteAry&){ /*disallow copy constructor */}
    void operator =(const ByteAry&){ /*disallow direct assignment */}
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u8>     ary_Addary(algo::ByteAry& parent, algo::aryptr<u8> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8&                  ary_Alloc(algo::ByteAry& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8&                  ary_AllocAt(algo::ByteAry& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8>     ary_AllocN(algo::ByteAry& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ary_EmptyQ(algo::ByteAry& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u8*                  ary_Find(algo::ByteAry& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<u8>     ary_Getary(algo::ByteAry& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
u8*                  ary_Last(algo::ByteAry& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  ary_Max(algo::ByteAry& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  ary_N(const algo::ByteAry& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 ary_Remove(algo::ByteAry& parent, u32 i) __attribute__((nothrow));
void                 ary_RemoveAll(algo::ByteAry& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ary_RemoveLast(algo::ByteAry& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 ary_Reserve(algo::ByteAry& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 ary_AbsReserve(algo::ByteAry& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 ary_Setary(algo::ByteAry& parent, algo::ByteAry &rhs) __attribute__((nothrow));
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 ary_Setary(algo::ByteAry& parent, const algo::aryptr<u8> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
u8&                  ary_qFind(algo::ByteAry& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
u8&                  ary_qLast(algo::ByteAry& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  ary_rowid_Get(algo::ByteAry& parent, u8 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8>     ary_AllocNVal(algo::ByteAry& parent, int n_elems, const u8& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 ByteAry_ary_curs_Next(ByteAry_ary_curs &curs);
void                 ByteAry_ary_curs_Reset(ByteAry_ary_curs &curs, algo::ByteAry &parent);
// cursor points to valid item
bool                 ByteAry_ary_curs_ValidQ(ByteAry_ary_curs &curs);
// item access
u8&                  ByteAry_ary_curs_Access(ByteAry_ary_curs &curs);
// Set all fields to initial values.
void                 ByteAry_Init(algo::ByteAry& parent);
void                 ByteAry_Uninit(algo::ByteAry& parent) __attribute__((nothrow));

// --- algo.Charset
struct Charset { // algo.Charset
    u64   ch_elems[8];   //   0  fixed array
    Charset();
};

// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  ch_Nbits(algo::Charset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 ch_qGetBit(algo::Charset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 ch_GetBit(algo::Charset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 ch_BitsEmptyQ(algo::Charset& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  ch_Sum1s(algo::Charset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 ch_qClearBit(algo::Charset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 ch_ClearBit(algo::Charset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 ch_qSetBit(algo::Charset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 ch_SetBit(algo::Charset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 ch_qSetBitVal(algo::Charset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 ch_qOrBitVal(algo::Charset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 ch_ClearBitsAll(algo::Charset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 ch_ClearBits(algo::Charset& parent, algo::Charset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 ch_OrBits(algo::Charset& parent, algo::Charset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  ch_Sup(algo::Charset& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
void                 ch_Fill(algo::Charset& parent, const u64 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u64*                 ch_Find(algo::Charset& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array ch as aryptr.
algo::aryptr<u64>    ch_Getary(algo::Charset& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  ch_Max(algo::Charset& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  ch_N(const algo::Charset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 ch_Setary(algo::Charset& parent, const algo::aryptr<u64> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u64&                 ch_qFind(algo::Charset& parent, u64 t) __attribute__((nothrow));
// Convert ch to a string. Parent's separator is used.
void                 ch_Print(algo::Charset& parent, algo::cstring &lhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Charset& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 Charset_ch_bitcurs_Next(Charset_ch_bitcurs &curs);
void                 Charset_ch_bitcurs_Reset(Charset_ch_bitcurs &curs, algo::Charset &parent);
// cursor points to valid item
bool                 Charset_ch_bitcurs_ValidQ(Charset_ch_bitcurs &curs);
// item access
int&                 Charset_ch_bitcurs_Access(Charset_ch_bitcurs &curs);
// cursor points to valid item
void                 Charset_ch_curs_Reset(Charset_ch_curs &curs, algo::Charset &parent);
// cursor points to valid item
bool                 Charset_ch_curs_ValidQ(Charset_ch_curs &curs);
// proceed to next item
void                 Charset_ch_curs_Next(Charset_ch_curs &curs);
// item access
u64&                 Charset_ch_curs_Access(Charset_ch_curs &curs);
// Read fields of algo::Charset from an ascii string.
// The function is implemented externally.
bool                 Charset_ReadStrptrMaybe(algo::Charset &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Charset_Init(algo::Charset& parent);

// --- algo.Smallstr150
struct Smallstr150 { // algo.Smallstr150
    enum { ch_max = 150 };
    u8 ch[150+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr150 &rhs) const;
    bool operator !=(const algo::Smallstr150 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr150& parent) __attribute__((nothrow));
    Smallstr150(const algo::Smallstr150 &rhs) __attribute__((nothrow));
    Smallstr150(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr150();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr150& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr150& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr150& parent) __attribute__((nothrow));
u32                  Smallstr150_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr150 &parent) __attribute__((nothrow));
// always return constant 150
int                  ch_Max(algo::Smallstr150& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr150& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr150& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr150& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr150& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr150_Hash(u32 prev, const algo::Smallstr150 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr150 from an ascii string.
// The format of the string is the format of the algo::Smallstr150's only field
bool                 Smallstr150_ReadStrptrMaybe(algo::Smallstr150 &parent, algo::strptr in_str);
i32                  Smallstr150_Cmp(algo::Smallstr150 & lhs, algo::Smallstr150 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr150_Init(algo::Smallstr150& parent);
bool                 Smallstr150_Eq(const algo::Smallstr150 & lhs,const algo::Smallstr150 & rhs) __attribute__((nothrow));
bool                 Smallstr150_EqStrptr(algo::Smallstr150 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr150 to string LHS, no header -- cprint:algo.Smallstr150.String
void                 Smallstr150_Print(algo::Smallstr150 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Comment
struct Comment { // algo.Comment
    algo::Smallstr150   value;   // 150 chars should be enough
    inline operator algo::strptr() const;
    explicit Comment(const algo::strptr&            in_value);
    Comment();
};

// Read fields of algo::Comment from an ascii string.
// The format of the string is the format of the algo::Comment's only field
bool                 Comment_ReadStrptrMaybe(algo::Comment &parent, algo::strptr in_str);
i32                  Comment_Cmp(algo::Comment & lhs, algo::Comment & rhs) __attribute__((nothrow));
bool                 Comment_Eq(const algo::Comment & lhs,const algo::Comment & rhs) __attribute__((nothrow));
// print string representation of algo::Comment to string LHS, no header -- cprint:algo.Comment.String
void                 Comment_Print(algo::Comment & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr250
struct Smallstr250 { // algo.Smallstr250
    enum { ch_max = 250 };
    u8 ch[250+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr250 &rhs) const;
    bool operator !=(const algo::Smallstr250 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr250& parent) __attribute__((nothrow));
    Smallstr250(const algo::Smallstr250 &rhs) __attribute__((nothrow));
    Smallstr250(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr250();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr250& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr250& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr250& parent) __attribute__((nothrow));
u32                  Smallstr250_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr250 &parent) __attribute__((nothrow));
// always return constant 250
int                  ch_Max(algo::Smallstr250& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr250& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr250& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr250& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr250& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr250_Hash(u32 prev, const algo::Smallstr250 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr250 from an ascii string.
// The format of the string is the format of the algo::Smallstr250's only field
bool                 Smallstr250_ReadStrptrMaybe(algo::Smallstr250 &parent, algo::strptr in_str);
i32                  Smallstr250_Cmp(algo::Smallstr250 & lhs, algo::Smallstr250 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr250_Init(algo::Smallstr250& parent);
bool                 Smallstr250_Eq(const algo::Smallstr250 & lhs,const algo::Smallstr250 & rhs) __attribute__((nothrow));
bool                 Smallstr250_EqStrptr(algo::Smallstr250 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr250 to string LHS, no header -- cprint:algo.Smallstr250.String
void                 Smallstr250_Print(algo::Smallstr250 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.CppExpr
struct CppExpr { // algo.CppExpr
    algo::Smallstr250   value;   // expression
    explicit CppExpr(const algo::strptr&            in_value);
    CppExpr();
};

// Read fields of algo::CppExpr from an ascii string.
// The format of the string is the format of the algo::CppExpr's only field
bool                 CppExpr_ReadStrptrMaybe(algo::CppExpr &parent, algo::strptr in_str);
// print string representation of algo::CppExpr to string LHS, no header -- cprint:algo.CppExpr.String
void                 CppExpr_Print(algo::CppExpr & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.UnTime
#pragma pack(push,1)
struct UnTime { // algo.UnTime: Unix time * 1e9 + nanoseconds
    i64   value;   //   0
    explicit UnTime(i64                            in_value);
    bool operator ==(const algo::UnTime &rhs) const;
    bool operator !=(const algo::UnTime &rhs) const;
    bool operator <(const algo::UnTime &rhs) const;
    bool operator >(const algo::UnTime &rhs) const;
    bool operator <=(const algo::UnTime &rhs) const;
    bool operator >=(const algo::UnTime &rhs) const;
    UnTime();
};
#pragma pack(pop)

u32                  UnTime_Hash(u32 prev, algo::UnTime rhs) __attribute__((nothrow));
// Read fields of algo::UnTime from an ascii string.
// The function is implemented externally.
bool                 UnTime_ReadStrptrMaybe(algo::UnTime &parent, algo::strptr in_str);
bool                 UnTime_Lt(algo::UnTime lhs, algo::UnTime rhs) __attribute__((nothrow));
i32                  UnTime_Cmp(algo::UnTime lhs, algo::UnTime rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 UnTime_Init(algo::UnTime& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 UnTime_UpdateMax(algo::UnTime &lhs, algo::UnTime rhs) __attribute__((nothrow));
// Return the lesser of two values
algo::UnTime         UnTime_Min(algo::UnTime lhs, algo::UnTime rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 UnTime_UpdateMin(algo::UnTime &lhs, algo::UnTime rhs) __attribute__((nothrow));
// Return the greater of two values
algo::UnTime         UnTime_Max(algo::UnTime lhs, algo::UnTime rhs) __attribute__((nothrow));
bool                 UnTime_Eq(algo::UnTime lhs, algo::UnTime rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 UnTime_Update(algo::UnTime &lhs, algo::UnTime rhs) __attribute__((nothrow));
// Convert algo::UnTime to a string (user-implemented function)
void                 UnTime_Print(algo::UnTime row, algo::cstring &str) __attribute__((nothrow));

// --- algo.DateCache
struct DateCache { // algo.DateCache
    algo::UnTime   min;   // Min input value
    algo::UnTime   max;   // Max input value
    DateCache();
};


// --- algo.Dbbox
struct Dbbox { // algo.Dbbox
    double   min;   //   1e38
    double   max;   //   -1e38
    explicit Dbbox(double                         in_min
        ,double                         in_max);
    Dbbox();
};

bool                 Dbbox_ReadFieldMaybe(algo::Dbbox &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of algo::Dbbox from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dbbox_ReadStrptrMaybe(algo::Dbbox &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Dbbox_Init(algo::Dbbox& parent);
// print string representation of algo::Dbbox to string LHS, no header -- cprint:algo.Dbbox.String
void                 Dbbox_Print(algo::Dbbox & row, algo::cstring &str) __attribute__((nothrow));
algo::strptr         Dbbox_GetAnon(algo::Dbbox &parent, i32 idx) __attribute__((nothrow));

// --- algo.DirEntry
struct DirEntry { // algo.DirEntry
    algo::cstring   dirname;      // Base directory name, e.g. /tmp
    algo::cstring   pattern;      // Shell wildcard to match, e.g. aa*bb
    algo::cstring   pathname;     // Current pathname, e.g. /tmp/aaCbb
    algo::cstring   filename;     // Current filename, e.g. aaCbb
    u64             mode;         //   0
    u64             size;         //   0  Size of file in bytes
    algo::UnTime    mtime;        // Modification time of file
    algo::UnTime    ctime;        // Change time of file
    bool            eof;          //   false  (internal) EOF flag -- no more dir entries left
    bool            match;        //   false  (internal) File entry matches pattern
    bool            is_dir;       //   false  File is a directory
    DIR*            dir_handle;   // (internal) handle for scanning. optional pointer
    DirEntry();
    ~DirEntry();
private:
    // user-defined fcleanup on algo.DirEntry.dir_handle prevents copy
    DirEntry(const DirEntry&){ /*disallow copy constructor */}
    void operator =(const DirEntry&){ /*disallow direct assignment */}
};

// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field dir_handle of algo::DirEntry
void                 dir_handle_Cleanup(algo::DirEntry& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 DirEntry_Init(algo::DirEntry& parent);
void                 DirEntry_Uninit(algo::DirEntry& parent) __attribute__((nothrow));

// --- algo.DryrunQ
struct DryrunQ { // algo.DryrunQ: Symbolic bool
    bool   value;   //   false
    inline operator bool() const;
    explicit DryrunQ(bool                           in_value);
    DryrunQ();
};

// Set all fields to initial values.
void                 DryrunQ_Init(algo::DryrunQ& parent);
// print string representation of algo::DryrunQ to string LHS, no header -- cprint:algo.DryrunQ.String
void                 DryrunQ_Print(algo::DryrunQ row, algo::cstring &str) __attribute__((nothrow));

// --- algo.EchoQ
struct EchoQ { // algo.EchoQ: Symbolic bool
    bool   value;   //   false
    inline operator algo_EchoQEnum() const;
    explicit EchoQ(bool                           in_value);
    EchoQ(algo_EchoQEnum arg);
    EchoQ();
};

// Get value of field as enum type
algo_EchoQEnum       value_GetEnum(const algo::EchoQ& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::EchoQ& parent, algo_EchoQEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::EchoQ& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::EchoQ& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::EchoQ& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::EchoQ& parent, algo::strptr rhs, algo_EchoQEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 EchoQ_Init(algo::EchoQ& parent);
// print string representation of algo::EchoQ to string LHS, no header -- cprint:algo.EchoQ.String
void                 EchoQ_Print(algo::EchoQ row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Errns
// create: algo.Errcode.type (Bitfld)
struct Errns { // algo.Errns: Error namespace.
    u8   value;   //   0
    inline operator algo_ErrnsEnum() const;
    explicit Errns(u8                             in_value);
    Errns(algo_ErrnsEnum arg);
    Errns();
};

// Get value of field as enum type
algo_ErrnsEnum       value_GetEnum(const algo::Errns& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::Errns& parent, algo_ErrnsEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::Errns& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::Errns& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::Errns& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::Errns& parent, algo::strptr rhs, algo_ErrnsEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 Errns_Init(algo::Errns& parent);

// --- algo.Errcode
struct Errcode { // algo.Errcode
    u64   value;   //   0
    Errcode();
};

// Retrieve bitfield from value of field value
//    32 bits starting at bit 0.
i32                  code_Get(const algo::Errcode& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    32 bits starting at bit 0.
void                 code_Set(algo::Errcode& parent, i32 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    8 bits starting at bit 32.
algo::Errns          type_Get(const algo::Errcode& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    8 bits starting at bit 32.
void                 type_Set(algo::Errcode& parent, algo::Errns rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 Errcode_Init(algo::Errcode& parent);
// Convert algo::Errcode to a string (user-implemented function)
void                 Errcode_Print(algo::Errcode & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.FailokQ
struct FailokQ { // algo.FailokQ: Symbolic bool
    bool   value;   //   false
    inline operator algo_FailokQEnum() const;
    explicit FailokQ(bool                           in_value);
    FailokQ(algo_FailokQEnum arg);
    FailokQ();
};

// Get value of field as enum type
algo_FailokQEnum     value_GetEnum(const algo::FailokQ& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::FailokQ& parent, algo_FailokQEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::FailokQ& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::FailokQ& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::FailokQ& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::FailokQ& parent, algo::strptr rhs, algo_FailokQEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 FailokQ_Init(algo::FailokQ& parent);
// print string representation of algo::FailokQ to string LHS, no header -- cprint:algo.FailokQ.String
void                 FailokQ_Print(algo::FailokQ row, algo::cstring &str) __attribute__((nothrow));

// --- algo.FieldId
#pragma pack(push,1)
struct FieldId { // algo.FieldId: Field read helper
    i32   value;   //   -1
    inline operator algo_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(algo_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
algo_FieldIdEnum     value_GetEnum(const algo::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::FieldId& parent, algo_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::FieldId& parent, algo::strptr rhs, algo_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(algo::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of algo::FieldId from an ascii string.
// The format of the string is the format of the algo::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(algo::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(algo::FieldId& parent);
// print string representation of algo::FieldId to string LHS, no header -- cprint:algo.FieldId.String
void                 FieldId_Print(algo::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Fildes
struct Fildes { // algo.Fildes: File descriptor primary key
    i32   value;   //   -1  -1 is invalid value; 0 and above are valid (stdin)
    explicit Fildes(i32                            in_value);
    bool operator ==(const algo::Fildes &rhs) const;
    bool operator !=(const algo::Fildes &rhs) const;
    bool operator <(const algo::Fildes &rhs) const;
    bool operator >(const algo::Fildes &rhs) const;
    bool operator <=(const algo::Fildes &rhs) const;
    bool operator >=(const algo::Fildes &rhs) const;
    Fildes();
};

u32                  Fildes_Hash(u32 prev, const algo::Fildes & rhs) __attribute__((nothrow));
bool                 Fildes_Lt(algo::Fildes & lhs, algo::Fildes & rhs) __attribute__((nothrow));
i32                  Fildes_Cmp(algo::Fildes & lhs, algo::Fildes & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Fildes_Init(algo::Fildes& parent);
bool                 Fildes_Eq(const algo::Fildes & lhs,const algo::Fildes & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Fildes_Update(algo::Fildes &lhs, algo::Fildes & rhs) __attribute__((nothrow));

// --- algo.FileFlags
struct FileFlags { // algo.FileFlags
    u32   value;   //   0
    inline operator algo_FileFlagsEnum() const;
    explicit FileFlags(u32                            in_value);
    FileFlags(algo_FileFlagsEnum arg);
    FileFlags();
};

// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
bool                 append_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
void                 append_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
bool                 read_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
void                 read_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
bool                 write_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
void                 write_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 5.
bool                 _throw_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 5.
void                 _throw_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
bool                 temp_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
void                 temp_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 7.
bool                 overlap_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 7.
void                 overlap_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 8.
bool                 linear_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 8.
void                 linear_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 9.
bool                 printerr_Get(const algo::FileFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 9.
void                 printerr_Set(algo::FileFlags& parent, bool rhs) __attribute__((nothrow));

bool                 FileFlags_ReadFieldMaybe(algo::FileFlags &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of algo::FileFlags from an ascii string.
bool                 FileFlags_ReadStrptrMaybe(algo::FileFlags &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FileFlags_Init(algo::FileFlags& parent);
// print string representation of algo::FileFlags to string LHS, no header -- cprint:algo.FileFlags.String
void                 FileFlags_Print(algo::FileFlags & row, algo::cstring &str) __attribute__((nothrow));
algo::strptr         FileFlags_GetAnon(algo::FileFlags &parent, i32 idx) __attribute__((nothrow));

// --- algo.I32Dec1
struct I32Dec1 { // algo.I32Dec1: signed i32, scale 1e1
    i32   value;   //   0
    inline operator i32() const;
    explicit I32Dec1(i32                            in_value);
    I32Dec1();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I32Dec1& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I32Dec1& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10)
i32                  value_GetInt(const algo::I32Dec1& parent) __attribute__((nothrow));
// Return constant 10
i32                  I32Dec1_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I32Dec1& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I32Dec1& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I32Dec1& parent, cstring &outstr) __attribute__((nothrow));

u32                  I32Dec1_Hash(u32 prev, algo::I32Dec1 rhs) __attribute__((nothrow));
// Read fields of algo::I32Dec1 from an ascii string.
// The format of the string is the format of the algo::I32Dec1's only field
bool                 I32Dec1_ReadStrptrMaybe(algo::I32Dec1 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I32Dec1_Init(algo::I32Dec1& parent);
// print string representation of algo::I32Dec1 to string LHS, no header -- cprint:algo.I32Dec1.String
void                 I32Dec1_Print(algo::I32Dec1 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I32Dec2
struct I32Dec2 { // algo.I32Dec2: signed i32, scale 1e2
    i32   value;   //   0
    inline operator i32() const;
    explicit I32Dec2(i32                            in_value);
    I32Dec2();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I32Dec2& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I32Dec2& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100)
i32                  value_GetInt(const algo::I32Dec2& parent) __attribute__((nothrow));
// Return constant 100
i32                  I32Dec2_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I32Dec2& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I32Dec2& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I32Dec2& parent, cstring &outstr) __attribute__((nothrow));

u32                  I32Dec2_Hash(u32 prev, algo::I32Dec2 rhs) __attribute__((nothrow));
// Read fields of algo::I32Dec2 from an ascii string.
// The format of the string is the format of the algo::I32Dec2's only field
bool                 I32Dec2_ReadStrptrMaybe(algo::I32Dec2 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I32Dec2_Init(algo::I32Dec2& parent);
// print string representation of algo::I32Dec2 to string LHS, no header -- cprint:algo.I32Dec2.String
void                 I32Dec2_Print(algo::I32Dec2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I32Dec3
struct I32Dec3 { // algo.I32Dec3
    i32   value;   //   0
    inline operator i32() const;
    explicit I32Dec3(i32                            in_value);
    I32Dec3();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I32Dec3& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I32Dec3& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000)
i32                  value_GetInt(const algo::I32Dec3& parent) __attribute__((nothrow));
// Return constant 1000
i32                  I32Dec3_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I32Dec3& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I32Dec3& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I32Dec3& parent, cstring &outstr) __attribute__((nothrow));

u32                  I32Dec3_Hash(u32 prev, algo::I32Dec3 rhs) __attribute__((nothrow));
// Read fields of algo::I32Dec3 from an ascii string.
// The format of the string is the format of the algo::I32Dec3's only field
bool                 I32Dec3_ReadStrptrMaybe(algo::I32Dec3 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I32Dec3_Init(algo::I32Dec3& parent);
// print string representation of algo::I32Dec3 to string LHS, no header -- cprint:algo.I32Dec3.String
void                 I32Dec3_Print(algo::I32Dec3 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I32Dec4
struct I32Dec4 { // algo.I32Dec4
    i32   value;   //   0
    inline operator i32() const;
    explicit I32Dec4(i32                            in_value);
    I32Dec4();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I32Dec4& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I32Dec4& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000)
i32                  value_GetInt(const algo::I32Dec4& parent) __attribute__((nothrow));
// Return constant 10000
i32                  I32Dec4_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I32Dec4& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I32Dec4& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I32Dec4& parent, cstring &outstr) __attribute__((nothrow));

u32                  I32Dec4_Hash(u32 prev, algo::I32Dec4 rhs) __attribute__((nothrow));
// Read fields of algo::I32Dec4 from an ascii string.
// The format of the string is the format of the algo::I32Dec4's only field
bool                 I32Dec4_ReadStrptrMaybe(algo::I32Dec4 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I32Dec4_Init(algo::I32Dec4& parent);
// print string representation of algo::I32Dec4 to string LHS, no header -- cprint:algo.I32Dec4.String
void                 I32Dec4_Print(algo::I32Dec4 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I32Dec5
struct I32Dec5 { // algo.I32Dec5
    i32   value;   //   0
    inline operator i32() const;
    explicit I32Dec5(i32                            in_value);
    I32Dec5();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I32Dec5& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I32Dec5& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100000)
i32                  value_GetInt(const algo::I32Dec5& parent) __attribute__((nothrow));
// Return constant 100000
i32                  I32Dec5_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I32Dec5& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I32Dec5& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I32Dec5& parent, cstring &outstr) __attribute__((nothrow));

u32                  I32Dec5_Hash(u32 prev, algo::I32Dec5 rhs) __attribute__((nothrow));
// Read fields of algo::I32Dec5 from an ascii string.
// The format of the string is the format of the algo::I32Dec5's only field
bool                 I32Dec5_ReadStrptrMaybe(algo::I32Dec5 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I32Dec5_Init(algo::I32Dec5& parent);
// print string representation of algo::I32Dec5 to string LHS, no header -- cprint:algo.I32Dec5.String
void                 I32Dec5_Print(algo::I32Dec5 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec1
struct I64Dec1 { // algo.I64Dec1
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec1(i64                            in_value);
    I64Dec1();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec1& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec1& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10)
i64                  value_GetInt(const algo::I64Dec1& parent) __attribute__((nothrow));
// Return constant 10
i64                  I64Dec1_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec1& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec1& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec1& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec1_Hash(u32 prev, algo::I64Dec1 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec1 from an ascii string.
// The format of the string is the format of the algo::I64Dec1's only field
bool                 I64Dec1_ReadStrptrMaybe(algo::I64Dec1 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec1_Init(algo::I64Dec1& parent);
// print string representation of algo::I64Dec1 to string LHS, no header -- cprint:algo.I64Dec1.String
void                 I64Dec1_Print(algo::I64Dec1 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec10
struct I64Dec10 { // algo.I64Dec10: signed i64, scale 1e10
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec10(i64                            in_value);
    I64Dec10();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec10& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec10& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000000000)
i64                  value_GetInt(const algo::I64Dec10& parent) __attribute__((nothrow));
// Return constant 10000000000
i64                  I64Dec10_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec10& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec10& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec10& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec10_Hash(u32 prev, algo::I64Dec10 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec10 from an ascii string.
// The format of the string is the format of the algo::I64Dec10's only field
bool                 I64Dec10_ReadStrptrMaybe(algo::I64Dec10 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec10_Init(algo::I64Dec10& parent);
// print string representation of algo::I64Dec10 to string LHS, no header -- cprint:algo.I64Dec10.String
void                 I64Dec10_Print(algo::I64Dec10 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec2
struct I64Dec2 { // algo.I64Dec2
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec2(i64                            in_value);
    I64Dec2();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec2& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec2& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100)
i64                  value_GetInt(const algo::I64Dec2& parent) __attribute__((nothrow));
// Return constant 100
i64                  I64Dec2_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec2& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec2& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec2& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec2_Hash(u32 prev, algo::I64Dec2 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec2 from an ascii string.
// The format of the string is the format of the algo::I64Dec2's only field
bool                 I64Dec2_ReadStrptrMaybe(algo::I64Dec2 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec2_Init(algo::I64Dec2& parent);
// print string representation of algo::I64Dec2 to string LHS, no header -- cprint:algo.I64Dec2.String
void                 I64Dec2_Print(algo::I64Dec2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec3
struct I64Dec3 { // algo.I64Dec3
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec3(i64                            in_value);
    I64Dec3();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec3& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec3& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000)
i64                  value_GetInt(const algo::I64Dec3& parent) __attribute__((nothrow));
// Return constant 1000
i64                  I64Dec3_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec3& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec3& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec3& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec3_Hash(u32 prev, algo::I64Dec3 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec3 from an ascii string.
// The format of the string is the format of the algo::I64Dec3's only field
bool                 I64Dec3_ReadStrptrMaybe(algo::I64Dec3 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec3_Init(algo::I64Dec3& parent);
// print string representation of algo::I64Dec3 to string LHS, no header -- cprint:algo.I64Dec3.String
void                 I64Dec3_Print(algo::I64Dec3 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec4
#pragma pack(push,1)
struct I64Dec4 { // algo.I64Dec4
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec4(i64                            in_value);
    I64Dec4();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec4& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec4& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000)
i64                  value_GetInt(const algo::I64Dec4& parent) __attribute__((nothrow));
// Return constant 10000
i64                  I64Dec4_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec4& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec4& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec4& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec4_Hash(u32 prev, algo::I64Dec4 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec4 from an ascii string.
// The format of the string is the format of the algo::I64Dec4's only field
bool                 I64Dec4_ReadStrptrMaybe(algo::I64Dec4 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec4_Init(algo::I64Dec4& parent);
// print string representation of algo::I64Dec4 to string LHS, no header -- cprint:algo.I64Dec4.String
void                 I64Dec4_Print(algo::I64Dec4 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec5
#pragma pack(push,1)
struct I64Dec5 { // algo.I64Dec5
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec5(i64                            in_value);
    I64Dec5();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec5& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec5& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100000)
i64                  value_GetInt(const algo::I64Dec5& parent) __attribute__((nothrow));
// Return constant 100000
i64                  I64Dec5_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec5& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec5& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec5& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec5_Hash(u32 prev, algo::I64Dec5 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec5 from an ascii string.
// The format of the string is the format of the algo::I64Dec5's only field
bool                 I64Dec5_ReadStrptrMaybe(algo::I64Dec5 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec5_Init(algo::I64Dec5& parent);
// print string representation of algo::I64Dec5 to string LHS, no header -- cprint:algo.I64Dec5.String
void                 I64Dec5_Print(algo::I64Dec5 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec6
struct I64Dec6 { // algo.I64Dec6
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec6(i64                            in_value);
    I64Dec6();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec6& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec6& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000000)
i64                  value_GetInt(const algo::I64Dec6& parent) __attribute__((nothrow));
// Return constant 1000000
i64                  I64Dec6_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec6& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec6& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec6& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec6_Hash(u32 prev, algo::I64Dec6 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec6 from an ascii string.
// The format of the string is the format of the algo::I64Dec6's only field
bool                 I64Dec6_ReadStrptrMaybe(algo::I64Dec6 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec6_Init(algo::I64Dec6& parent);
// print string representation of algo::I64Dec6 to string LHS, no header -- cprint:algo.I64Dec6.String
void                 I64Dec6_Print(algo::I64Dec6 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec7
struct I64Dec7 { // algo.I64Dec7: signed i64, scale 1e7
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec7(i64                            in_value);
    I64Dec7();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec7& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec7& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000000)
i64                  value_GetInt(const algo::I64Dec7& parent) __attribute__((nothrow));
// Return constant 10000000
i64                  I64Dec7_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec7& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec7& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec7& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec7_Hash(u32 prev, algo::I64Dec7 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec7 from an ascii string.
// The format of the string is the format of the algo::I64Dec7's only field
bool                 I64Dec7_ReadStrptrMaybe(algo::I64Dec7 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec7_Init(algo::I64Dec7& parent);
// print string representation of algo::I64Dec7 to string LHS, no header -- cprint:algo.I64Dec7.String
void                 I64Dec7_Print(algo::I64Dec7 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec8
#pragma pack(push,1)
struct I64Dec8 { // algo.I64Dec8: signed i64, scale 1e8
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec8(i64                            in_value);
    I64Dec8();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec8& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec8& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100000000)
i64                  value_GetInt(const algo::I64Dec8& parent) __attribute__((nothrow));
// Return constant 100000000
i64                  I64Dec8_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec8& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec8& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec8& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec8_Hash(u32 prev, algo::I64Dec8 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec8 from an ascii string.
// The format of the string is the format of the algo::I64Dec8's only field
bool                 I64Dec8_ReadStrptrMaybe(algo::I64Dec8 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec8_Init(algo::I64Dec8& parent);
// print string representation of algo::I64Dec8 to string LHS, no header -- cprint:algo.I64Dec8.String
void                 I64Dec8_Print(algo::I64Dec8 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.I64Dec9
struct I64Dec9 { // algo.I64Dec9: signed i64, scale 1e9
    i64   value;   //   0
    inline operator i64() const;
    explicit I64Dec9(i64                            in_value);
    I64Dec9();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::I64Dec9& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::I64Dec9& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000000000)
i64                  value_GetInt(const algo::I64Dec9& parent) __attribute__((nothrow));
// Return constant 1000000000
i64                  I64Dec9_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::I64Dec9& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::I64Dec9& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::I64Dec9& parent, cstring &outstr) __attribute__((nothrow));

u32                  I64Dec9_Hash(u32 prev, algo::I64Dec9 rhs) __attribute__((nothrow));
// Read fields of algo::I64Dec9 from an ascii string.
// The format of the string is the format of the algo::I64Dec9's only field
bool                 I64Dec9_ReadStrptrMaybe(algo::I64Dec9 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 I64Dec9_Init(algo::I64Dec9& parent);
// print string representation of algo::I64Dec9 to string LHS, no header -- cprint:algo.I64Dec9.String
void                 I64Dec9_Print(algo::I64Dec9 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.IOEvtFlags
struct IOEvtFlags { // algo.IOEvtFlags
    u32   value;   //   0
    inline operator algo_IOEvtFlagsEnum() const;
    explicit IOEvtFlags(u32                            in_value);
    IOEvtFlags(algo_IOEvtFlagsEnum arg);
    IOEvtFlags();
};

// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
bool                 read_Get(const algo::IOEvtFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
void                 read_Set(algo::IOEvtFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
bool                 write_Get(const algo::IOEvtFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
void                 write_Set(algo::IOEvtFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
bool                 eof_Get(const algo::IOEvtFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
void                 eof_Set(algo::IOEvtFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
bool                 err_Get(const algo::IOEvtFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
void                 err_Set(algo::IOEvtFlags& parent, bool rhs) __attribute__((nothrow));

bool                 IOEvtFlags_ReadFieldMaybe(algo::IOEvtFlags &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of algo::IOEvtFlags from an ascii string.
bool                 IOEvtFlags_ReadStrptrMaybe(algo::IOEvtFlags &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 IOEvtFlags_Init(algo::IOEvtFlags& parent);
// print string representation of algo::IOEvtFlags to string LHS, no header -- cprint:algo.IOEvtFlags.String
void                 IOEvtFlags_Print(algo::IOEvtFlags & row, algo::cstring &str) __attribute__((nothrow));
algo::strptr         IOEvtFlags_GetAnon(algo::IOEvtFlags &parent, i32 idx) __attribute__((nothrow));

// --- algo.IPoint
struct IPoint { // algo.IPoint
    i32   x;   //   0
    i32   y;   //   0
    IPoint();
};

bool                 IPoint_ReadFieldMaybe(algo::IPoint &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of algo::IPoint from an ascii string.
// The format of the string is a string with separated values
bool                 IPoint_ReadStrptrMaybe(algo::IPoint &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 IPoint_Init(algo::IPoint& parent);
// print string representation of algo::IPoint to string LHS, no header -- cprint:algo.IPoint.String
void                 IPoint_Print(algo::IPoint & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr50
#pragma pack(push,1)
struct Smallstr50 { // algo.Smallstr50
    enum { ch_max = 50 };
    u8 ch[50+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr50 &rhs) const;
    bool operator !=(const algo::Smallstr50 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::Smallstr50 &rhs) const;
    bool operator >(const algo::Smallstr50 &rhs) const;
    bool operator <=(const algo::Smallstr50 &rhs) const;
    bool operator >=(const algo::Smallstr50 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr50& parent) __attribute__((nothrow));
    Smallstr50(const algo::Smallstr50 &rhs) __attribute__((nothrow));
    Smallstr50(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr50();
};
#pragma pack(pop)

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr50& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr50& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr50& parent) __attribute__((nothrow));
u32                  Smallstr50_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr50 &parent) __attribute__((nothrow));
// always return constant 50
int                  ch_Max(algo::Smallstr50& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr50& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr50& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr50& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr50& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr50_Hash(u32 prev, const algo::Smallstr50 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr50 from an ascii string.
// The format of the string is the format of the algo::Smallstr50's only field
bool                 Smallstr50_ReadStrptrMaybe(algo::Smallstr50 &parent, algo::strptr in_str);
bool                 Smallstr50_Lt(algo::Smallstr50 & lhs, algo::Smallstr50 & rhs) __attribute__((nothrow));
i32                  Smallstr50_Cmp(algo::Smallstr50 & lhs, algo::Smallstr50 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr50_Init(algo::Smallstr50& parent);
bool                 Smallstr50_Eq(const algo::Smallstr50 & lhs,const algo::Smallstr50 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Smallstr50_Update(algo::Smallstr50 &lhs, algo::Smallstr50 & rhs) __attribute__((nothrow));
bool                 Smallstr50_EqStrptr(algo::Smallstr50 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr50 to string LHS, no header -- cprint:algo.Smallstr50.String
void                 Smallstr50_Print(algo::Smallstr50 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Imdb
struct Imdb { // algo.Imdb: In-memory database descriptor (what is algo.Db then?)
    algo::Smallstr50                 imdb;                // Database name
    algo::ImdbInsertStrptrMaybeFcn   InsertStrptrMaybe;   //   0  Insert new element given a string
    algo::ImdbStepFcn                Step;                //   0  Perform one step (may be NULL)
    algo::ImdbMainLoopFcn            MainLoop;            //   0  Loop!
    algo::ImdbGetTraceFcn            GetTrace;            //   0
    algo::Comment                    comment;             //
    explicit Imdb(const algo::strptr&            in_imdb
        ,const algo::ImdbInsertStrptrMaybeFcn& in_InsertStrptrMaybe
        ,const algo::ImdbStepFcn&       in_Step
        ,const algo::ImdbMainLoopFcn&   in_MainLoop
        ,const algo::ImdbGetTraceFcn&   in_GetTrace
        ,const algo::Comment&           in_comment);
    Imdb();
};

// Set all fields to initial values.
void                 Imdb_Init(algo::Imdb& parent);
// print string representation of algo::Imdb to string LHS, no header -- cprint:algo.Imdb.String
void                 Imdb_Print(algo::Imdb & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.ImrowPtr
struct ImrowPtr { // algo.ImrowPtr
    u64   value;   //   0
    inline operator u64() const;
    explicit ImrowPtr(u64                            in_value);
    ImrowPtr();
};

// Set all fields to initial values.
void                 ImrowPtr_Init(algo::ImrowPtr& parent);
// print string representation of algo::ImrowPtr to string LHS, no header -- cprint:algo.ImrowPtr.String
void                 ImrowPtr_Print(algo::ImrowPtr & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Imtable
struct Imtable { // algo.Imtable: In-memory table descriptor
    algo::Smallstr50          imtable;       // Table name
    algo::Smallstr50          elem_type;     // Element type name
    algo::ImrowRowidFindFcn   c_RowidFind;   //   0  Function to find element by rowid (may be NULL)
    algo::ImrowXrefXFcn       XrefX;         //   0  Function to x-reference an element (may be NULL)
    algo::ImrowNItemsFcn      NItems;        //   0  Return number of elements in the table
    algo::ImrowPrintFcn       Print;         //   0  Convert specified element to string (may be NULL)
    i32                       size;          //   0  Size of one element (for fixed-width elements only)
    algo::Smallstr50          ssimfile;      // Ssimfile name (if associated)
    algo::Comment             comment;       //
    explicit Imtable(const algo::strptr&            in_imtable
        ,const algo::strptr&            in_elem_type
        ,const algo::ImrowRowidFindFcn& in_c_RowidFind
        ,const algo::ImrowXrefXFcn&     in_XrefX
        ,const algo::ImrowNItemsFcn&    in_NItems
        ,const algo::ImrowPrintFcn&     in_Print
        ,i32                            in_size
        ,const algo::strptr&            in_ssimfile
        ,const algo::Comment&           in_comment);
    Imtable();
};

// Set all fields to initial values.
void                 Imtable_Init(algo::Imtable& parent);
// print string representation of algo::Imtable to string LHS, no header -- cprint:algo.Imtable.String
void                 Imtable_Print(algo::Imtable & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Ipmask
struct Ipmask { // algo.Ipmask: Format: 10.0.0.0/16
    u32   ip_host;   //   0
    u32   mask;      //   0
    Ipmask();
};

// Read fields of algo::Ipmask from an ascii string.
// The function is implemented externally.
bool                 Ipmask_ReadStrptrMaybe(algo::Ipmask &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ipmask_Init(algo::Ipmask& parent);
// Convert algo::Ipmask to a string (user-implemented function)
void                 Ipmask_Print(algo::Ipmask & row, algo::cstring &str) __attribute__((nothrow));
u32                  strptr_Hash(u32 prev, algo::strptr rhs) __attribute__((nothrow));
bool                 strptr_Lt(algo::strptr lhs, algo::strptr rhs) __attribute__((nothrow));
i32                  strptr_Cmp(algo::strptr lhs, algo::strptr rhs) __attribute__((nothrow));
bool                 strptr_Eq(algo::strptr lhs, algo::strptr rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 strptr_Update(algo::strptr &lhs, algo::strptr rhs) __attribute__((nothrow));
// Create JSON representation of algo::strptr under PARENT node -- implemented externally
lib_json::FNode *    strptr_FmtJson(algo::strptr row, lib_json::FNode *parent) __attribute__((nothrow));

// --- algo.LineBuf
struct LineBuf { // algo.LineBuf
    char*          buf_elems;     // pointer to elements
    u32            buf_n;         // number of elements in array
    u32            buf_max;       // max. capacity of array before realloc
    algo::strptr   incoming;      //
    bool           implied_eof;   //   false
    bool           eof;           //   false
    LineBuf();
    ~LineBuf();
private:
    // reftype Tary of algo.LineBuf.buf prohibits copy
    LineBuf(const LineBuf&){ /*disallow copy constructor */}
    void operator =(const LineBuf&){ /*disallow direct assignment */}
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<char>   buf_Addary(algo::LineBuf& parent, algo::aryptr<char> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
char&                buf_Alloc(algo::LineBuf& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
char&                buf_AllocAt(algo::LineBuf& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char>   buf_AllocN(algo::LineBuf& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 buf_EmptyQ(algo::LineBuf& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
char*                buf_Find(algo::LineBuf& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<char>   buf_Getary(algo::LineBuf& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
char*                buf_Last(algo::LineBuf& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  buf_Max(algo::LineBuf& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  buf_N(const algo::LineBuf& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 buf_Remove(algo::LineBuf& parent, u32 i) __attribute__((nothrow));
void                 buf_RemoveAll(algo::LineBuf& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 buf_RemoveLast(algo::LineBuf& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 buf_Reserve(algo::LineBuf& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 buf_AbsReserve(algo::LineBuf& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 buf_Setary(algo::LineBuf& parent, algo::LineBuf &rhs) __attribute__((nothrow));
// Copy specified array into buf, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 buf_Setary(algo::LineBuf& parent, const algo::aryptr<char> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
char&                buf_qFind(algo::LineBuf& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
char&                buf_qLast(algo::LineBuf& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  buf_rowid_Get(algo::LineBuf& parent, char &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<char>   buf_AllocNVal(algo::LineBuf& parent, int n_elems, const char& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 LineBuf_buf_curs_Next(LineBuf_buf_curs &curs);
void                 LineBuf_buf_curs_Reset(LineBuf_buf_curs &curs, algo::LineBuf &parent);
// cursor points to valid item
bool                 LineBuf_buf_curs_ValidQ(LineBuf_buf_curs &curs);
// item access
char&                LineBuf_buf_curs_Access(LineBuf_buf_curs &curs);
// Set all fields to initial values.
void                 LineBuf_Init(algo::LineBuf& parent);
void                 LineBuf_Uninit(algo::LineBuf& parent) __attribute__((nothrow));

// --- algo.LnumStr10_U64
#pragma pack(push,1)
struct LnumStr10_U64 { // algo.LnumStr10_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 10 };
    u8 ch[10];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr10_U64 &rhs) const;
    bool operator !=(const algo::LnumStr10_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr10_U64& parent) __attribute__((nothrow));
    LnumStr10_U64(const algo::LnumStr10_U64 &rhs) __attribute__((nothrow));
    LnumStr10_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr10_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr10_U64& parent) __attribute__((nothrow));
u32                  LnumStr10_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr10_U64 &parent) __attribute__((nothrow));
// always return constant 10
int                  ch_Max(algo::LnumStr10_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr10_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr10_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr10_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr10_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr10_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr10_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr10_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr10_U64_Hash(u32 prev, const algo::LnumStr10_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr10_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr10_U64's only field
bool                 LnumStr10_U64_ReadStrptrMaybe(algo::LnumStr10_U64 &parent, algo::strptr in_str);
i32                  LnumStr10_U64_Cmp(algo::LnumStr10_U64 & lhs, algo::LnumStr10_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr10_U64_Init(algo::LnumStr10_U64& parent);
bool                 LnumStr10_U64_Eq(const algo::LnumStr10_U64 & lhs,const algo::LnumStr10_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr10_U64_EqStrptr(algo::LnumStr10_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr10_U64 to string LHS, no header -- cprint:algo.LnumStr10_U64.String
void                 LnumStr10_U64_Print(algo::LnumStr10_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr11_U64
#pragma pack(push,1)
struct LnumStr11_U64 { // algo.LnumStr11_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 11 };
    u8 ch[11];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr11_U64 &rhs) const;
    bool operator !=(const algo::LnumStr11_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr11_U64& parent) __attribute__((nothrow));
    LnumStr11_U64(const algo::LnumStr11_U64 &rhs) __attribute__((nothrow));
    LnumStr11_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr11_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr11_U64& parent) __attribute__((nothrow));
u32                  LnumStr11_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr11_U64 &parent) __attribute__((nothrow));
// always return constant 11
int                  ch_Max(algo::LnumStr11_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr11_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr11_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr11_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr11_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr11_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr11_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr11_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr11_U64_Hash(u32 prev, const algo::LnumStr11_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr11_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr11_U64's only field
bool                 LnumStr11_U64_ReadStrptrMaybe(algo::LnumStr11_U64 &parent, algo::strptr in_str);
i32                  LnumStr11_U64_Cmp(algo::LnumStr11_U64 & lhs, algo::LnumStr11_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr11_U64_Init(algo::LnumStr11_U64& parent);
bool                 LnumStr11_U64_Eq(const algo::LnumStr11_U64 & lhs,const algo::LnumStr11_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr11_U64_EqStrptr(algo::LnumStr11_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr11_U64 to string LHS, no header -- cprint:algo.LnumStr11_U64.String
void                 LnumStr11_U64_Print(algo::LnumStr11_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr12_U64
#pragma pack(push,1)
struct LnumStr12_U64 { // algo.LnumStr12_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 12 };
    u8 ch[12];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr12_U64 &rhs) const;
    bool operator !=(const algo::LnumStr12_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr12_U64& parent) __attribute__((nothrow));
    LnumStr12_U64(const algo::LnumStr12_U64 &rhs) __attribute__((nothrow));
    LnumStr12_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr12_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr12_U64& parent) __attribute__((nothrow));
u32                  LnumStr12_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr12_U64 &parent) __attribute__((nothrow));
// always return constant 12
int                  ch_Max(algo::LnumStr12_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr12_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr12_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr12_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr12_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr12_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr12_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr12_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr12_U64_Hash(u32 prev, const algo::LnumStr12_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr12_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr12_U64's only field
bool                 LnumStr12_U64_ReadStrptrMaybe(algo::LnumStr12_U64 &parent, algo::strptr in_str);
i32                  LnumStr12_U64_Cmp(algo::LnumStr12_U64 & lhs, algo::LnumStr12_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr12_U64_Init(algo::LnumStr12_U64& parent);
bool                 LnumStr12_U64_Eq(const algo::LnumStr12_U64 & lhs,const algo::LnumStr12_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr12_U64_EqStrptr(algo::LnumStr12_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr12_U64 to string LHS, no header -- cprint:algo.LnumStr12_U64.String
void                 LnumStr12_U64_Print(algo::LnumStr12_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr13_U64_Base36
#pragma pack(push,1)
struct LnumStr13_U64_Base36 { // algo.LnumStr13_U64_Base36: number stored as ascii digits, left pad with '0', base 36
    enum { ch_max = 13 };
    u8 ch[13];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr13_U64_Base36 &rhs) const;
    bool operator !=(const algo::LnumStr13_U64_Base36 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr13_U64_Base36& parent) __attribute__((nothrow));
    LnumStr13_U64_Base36(const algo::LnumStr13_U64_Base36 &rhs) __attribute__((nothrow));
    LnumStr13_U64_Base36(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr13_U64_Base36();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr13_U64_Base36& parent) __attribute__((nothrow));
u32                  LnumStr13_U64_Base36_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr13_U64_Base36 &parent) __attribute__((nothrow));
// always return constant 13
int                  ch_Max(algo::LnumStr13_U64_Base36& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr13_U64_Base36& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr13_U64_Base36& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr13_U64_Base36& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr13_U64_Base36& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr13_U64_Base36& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr13_U64_Base36& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr13_U64_Base36& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr13_U64_Base36_Hash(u32 prev, const algo::LnumStr13_U64_Base36 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr13_U64_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr13_U64_Base36's only field
bool                 LnumStr13_U64_Base36_ReadStrptrMaybe(algo::LnumStr13_U64_Base36 &parent, algo::strptr in_str);
i32                  LnumStr13_U64_Base36_Cmp(algo::LnumStr13_U64_Base36 & lhs, algo::LnumStr13_U64_Base36 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr13_U64_Base36_Init(algo::LnumStr13_U64_Base36& parent);
bool                 LnumStr13_U64_Base36_Eq(const algo::LnumStr13_U64_Base36 & lhs,const algo::LnumStr13_U64_Base36 & rhs) __attribute__((nothrow));
bool                 LnumStr13_U64_Base36_EqStrptr(algo::LnumStr13_U64_Base36 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr13_U64_Base36 to string LHS, no header -- cprint:algo.LnumStr13_U64_Base36.String
void                 LnumStr13_U64_Base36_Print(algo::LnumStr13_U64_Base36 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr16_U64_Base16
#pragma pack(push,1)
struct LnumStr16_U64_Base16 { // algo.LnumStr16_U64_Base16: number stored as ascii digits, padded with 0s, base 16
    enum { ch_max = 16 };
    u8 ch[16];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr16_U64_Base16 &rhs) const;
    bool operator !=(const algo::LnumStr16_U64_Base16 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr16_U64_Base16& parent) __attribute__((nothrow));
    LnumStr16_U64_Base16(const algo::LnumStr16_U64_Base16 &rhs) __attribute__((nothrow));
    LnumStr16_U64_Base16(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr16_U64_Base16();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr16_U64_Base16& parent) __attribute__((nothrow));
u32                  LnumStr16_U64_Base16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr16_U64_Base16 &parent) __attribute__((nothrow));
// always return constant 16
int                  ch_Max(algo::LnumStr16_U64_Base16& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr16_U64_Base16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr16_U64_Base16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr16_U64_Base16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr16_U64_Base16& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr16_U64_Base16& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr16_U64_Base16& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-16 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr16_U64_Base16& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr16_U64_Base16_Hash(u32 prev, const algo::LnumStr16_U64_Base16 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr16_U64_Base16 from an ascii string.
// The format of the string is the format of the algo::LnumStr16_U64_Base16's only field
bool                 LnumStr16_U64_Base16_ReadStrptrMaybe(algo::LnumStr16_U64_Base16 &parent, algo::strptr in_str);
i32                  LnumStr16_U64_Base16_Cmp(algo::LnumStr16_U64_Base16 & lhs, algo::LnumStr16_U64_Base16 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr16_U64_Base16_Init(algo::LnumStr16_U64_Base16& parent);
bool                 LnumStr16_U64_Base16_Eq(const algo::LnumStr16_U64_Base16 & lhs,const algo::LnumStr16_U64_Base16 & rhs) __attribute__((nothrow));
bool                 LnumStr16_U64_Base16_EqStrptr(algo::LnumStr16_U64_Base16 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr16_U64_Base16 to string LHS, no header -- cprint:algo.LnumStr16_U64_Base16.String
void                 LnumStr16_U64_Base16_Print(algo::LnumStr16_U64_Base16 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr1_U32
#pragma pack(push,1)
struct LnumStr1_U32 { // algo.LnumStr1_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 1 };
    u8 ch[1];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr1_U32 &rhs) const;
    bool operator !=(const algo::LnumStr1_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr1_U32& parent) __attribute__((nothrow));
    LnumStr1_U32(const algo::LnumStr1_U32 &rhs) __attribute__((nothrow));
    LnumStr1_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr1_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr1_U32& parent) __attribute__((nothrow));
u32                  LnumStr1_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr1_U32 &parent) __attribute__((nothrow));
// always return constant 1
int                  ch_Max(algo::LnumStr1_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr1_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr1_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr1_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr1_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr1_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr1_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr1_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr1_U32_Hash(u32 prev, const algo::LnumStr1_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr1_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr1_U32's only field
bool                 LnumStr1_U32_ReadStrptrMaybe(algo::LnumStr1_U32 &parent, algo::strptr in_str);
i32                  LnumStr1_U32_Cmp(algo::LnumStr1_U32 & lhs, algo::LnumStr1_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr1_U32_Init(algo::LnumStr1_U32& parent);
bool                 LnumStr1_U32_Eq(const algo::LnumStr1_U32 & lhs,const algo::LnumStr1_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr1_U32_EqStrptr(algo::LnumStr1_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr1_U32 to string LHS, no header -- cprint:algo.LnumStr1_U32.String
void                 LnumStr1_U32_Print(algo::LnumStr1_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr20_U64
#pragma pack(push,1)
struct LnumStr20_U64 { // algo.LnumStr20_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 20 };
    u8 ch[20];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr20_U64 &rhs) const;
    bool operator !=(const algo::LnumStr20_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr20_U64& parent) __attribute__((nothrow));
    LnumStr20_U64(const algo::LnumStr20_U64 &rhs) __attribute__((nothrow));
    LnumStr20_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr20_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr20_U64& parent) __attribute__((nothrow));
u32                  LnumStr20_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr20_U64 &parent) __attribute__((nothrow));
// always return constant 20
int                  ch_Max(algo::LnumStr20_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr20_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr20_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr20_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr20_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr20_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr20_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr20_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr20_U64_Hash(u32 prev, const algo::LnumStr20_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr20_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr20_U64's only field
bool                 LnumStr20_U64_ReadStrptrMaybe(algo::LnumStr20_U64 &parent, algo::strptr in_str);
i32                  LnumStr20_U64_Cmp(algo::LnumStr20_U64 & lhs, algo::LnumStr20_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr20_U64_Init(algo::LnumStr20_U64& parent);
bool                 LnumStr20_U64_Eq(const algo::LnumStr20_U64 & lhs,const algo::LnumStr20_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr20_U64_EqStrptr(algo::LnumStr20_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr20_U64 to string LHS, no header -- cprint:algo.LnumStr20_U64.String
void                 LnumStr20_U64_Print(algo::LnumStr20_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr22_U64
#pragma pack(push,1)
struct LnumStr22_U64 { // algo.LnumStr22_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 22 };
    u8 ch[22];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr22_U64 &rhs) const;
    bool operator !=(const algo::LnumStr22_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr22_U64& parent) __attribute__((nothrow));
    LnumStr22_U64(const algo::LnumStr22_U64 &rhs) __attribute__((nothrow));
    LnumStr22_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr22_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr22_U64& parent) __attribute__((nothrow));
u32                  LnumStr22_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr22_U64 &parent) __attribute__((nothrow));
// always return constant 22
int                  ch_Max(algo::LnumStr22_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr22_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr22_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr22_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr22_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr22_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr22_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr22_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr22_U64_Hash(u32 prev, const algo::LnumStr22_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr22_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr22_U64's only field
bool                 LnumStr22_U64_ReadStrptrMaybe(algo::LnumStr22_U64 &parent, algo::strptr in_str);
i32                  LnumStr22_U64_Cmp(algo::LnumStr22_U64 & lhs, algo::LnumStr22_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr22_U64_Init(algo::LnumStr22_U64& parent);
bool                 LnumStr22_U64_Eq(const algo::LnumStr22_U64 & lhs,const algo::LnumStr22_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr22_U64_EqStrptr(algo::LnumStr22_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr22_U64 to string LHS, no header -- cprint:algo.LnumStr22_U64.String
void                 LnumStr22_U64_Print(algo::LnumStr22_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr2_U32
#pragma pack(push,1)
struct LnumStr2_U32 { // algo.LnumStr2_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 2 };
    u8 ch[2];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr2_U32 &rhs) const;
    bool operator !=(const algo::LnumStr2_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr2_U32& parent) __attribute__((nothrow));
    LnumStr2_U32(const algo::LnumStr2_U32 &rhs) __attribute__((nothrow));
    LnumStr2_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr2_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr2_U32& parent) __attribute__((nothrow));
u32                  LnumStr2_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr2_U32 &parent) __attribute__((nothrow));
// always return constant 2
int                  ch_Max(algo::LnumStr2_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr2_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr2_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr2_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr2_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr2_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr2_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr2_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr2_U32_Hash(u32 prev, const algo::LnumStr2_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr2_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr2_U32's only field
bool                 LnumStr2_U32_ReadStrptrMaybe(algo::LnumStr2_U32 &parent, algo::strptr in_str);
i32                  LnumStr2_U32_Cmp(algo::LnumStr2_U32 & lhs, algo::LnumStr2_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr2_U32_Init(algo::LnumStr2_U32& parent);
bool                 LnumStr2_U32_Eq(const algo::LnumStr2_U32 & lhs,const algo::LnumStr2_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr2_U32_EqStrptr(algo::LnumStr2_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr2_U32 to string LHS, no header -- cprint:algo.LnumStr2_U32.String
void                 LnumStr2_U32_Print(algo::LnumStr2_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr3_U32
#pragma pack(push,1)
struct LnumStr3_U32 { // algo.LnumStr3_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 3 };
    u8 ch[3];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr3_U32 &rhs) const;
    bool operator !=(const algo::LnumStr3_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr3_U32& parent) __attribute__((nothrow));
    LnumStr3_U32(const algo::LnumStr3_U32 &rhs) __attribute__((nothrow));
    LnumStr3_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr3_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr3_U32& parent) __attribute__((nothrow));
u32                  LnumStr3_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr3_U32 &parent) __attribute__((nothrow));
// always return constant 3
int                  ch_Max(algo::LnumStr3_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr3_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr3_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr3_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr3_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr3_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr3_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr3_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr3_U32_Hash(u32 prev, const algo::LnumStr3_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr3_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr3_U32's only field
bool                 LnumStr3_U32_ReadStrptrMaybe(algo::LnumStr3_U32 &parent, algo::strptr in_str);
i32                  LnumStr3_U32_Cmp(algo::LnumStr3_U32 & lhs, algo::LnumStr3_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr3_U32_Init(algo::LnumStr3_U32& parent);
bool                 LnumStr3_U32_Eq(const algo::LnumStr3_U32 & lhs,const algo::LnumStr3_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr3_U32_EqStrptr(algo::LnumStr3_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr3_U32 to string LHS, no header -- cprint:algo.LnumStr3_U32.String
void                 LnumStr3_U32_Print(algo::LnumStr3_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr4_U32
#pragma pack(push,1)
struct LnumStr4_U32 { // algo.LnumStr4_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 4 };
    u8 ch[4];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr4_U32 &rhs) const;
    bool operator !=(const algo::LnumStr4_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr4_U32& parent) __attribute__((nothrow));
    LnumStr4_U32(const algo::LnumStr4_U32 &rhs) __attribute__((nothrow));
    LnumStr4_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr4_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr4_U32& parent) __attribute__((nothrow));
u32                  LnumStr4_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr4_U32 &parent) __attribute__((nothrow));
// always return constant 4
int                  ch_Max(algo::LnumStr4_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr4_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr4_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr4_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr4_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr4_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr4_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr4_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr4_U32_Hash(u32 prev, const algo::LnumStr4_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr4_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr4_U32's only field
bool                 LnumStr4_U32_ReadStrptrMaybe(algo::LnumStr4_U32 &parent, algo::strptr in_str);
i32                  LnumStr4_U32_Cmp(algo::LnumStr4_U32 & lhs, algo::LnumStr4_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr4_U32_Init(algo::LnumStr4_U32& parent);
bool                 LnumStr4_U32_Eq(const algo::LnumStr4_U32 & lhs,const algo::LnumStr4_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr4_U32_EqStrptr(algo::LnumStr4_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr4_U32 to string LHS, no header -- cprint:algo.LnumStr4_U32.String
void                 LnumStr4_U32_Print(algo::LnumStr4_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr5_U32
#pragma pack(push,1)
struct LnumStr5_U32 { // algo.LnumStr5_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 5 };
    u8 ch[5];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr5_U32 &rhs) const;
    bool operator !=(const algo::LnumStr5_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr5_U32& parent) __attribute__((nothrow));
    LnumStr5_U32(const algo::LnumStr5_U32 &rhs) __attribute__((nothrow));
    LnumStr5_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr5_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr5_U32& parent) __attribute__((nothrow));
u32                  LnumStr5_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr5_U32 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::LnumStr5_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr5_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr5_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr5_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr5_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr5_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr5_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr5_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr5_U32_Hash(u32 prev, const algo::LnumStr5_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr5_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr5_U32's only field
bool                 LnumStr5_U32_ReadStrptrMaybe(algo::LnumStr5_U32 &parent, algo::strptr in_str);
i32                  LnumStr5_U32_Cmp(algo::LnumStr5_U32 & lhs, algo::LnumStr5_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr5_U32_Init(algo::LnumStr5_U32& parent);
bool                 LnumStr5_U32_Eq(const algo::LnumStr5_U32 & lhs,const algo::LnumStr5_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr5_U32_EqStrptr(algo::LnumStr5_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr5_U32 to string LHS, no header -- cprint:algo.LnumStr5_U32.String
void                 LnumStr5_U32_Print(algo::LnumStr5_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr5_U32_Base36
#pragma pack(push,1)
struct LnumStr5_U32_Base36 { // algo.LnumStr5_U32_Base36: number stored as ascii digits, left pad with '0', base 36
    enum { ch_max = 5 };
    u8 ch[5];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr5_U32_Base36 &rhs) const;
    bool operator !=(const algo::LnumStr5_U32_Base36 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr5_U32_Base36& parent) __attribute__((nothrow));
    LnumStr5_U32_Base36(const algo::LnumStr5_U32_Base36 &rhs) __attribute__((nothrow));
    LnumStr5_U32_Base36(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr5_U32_Base36();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr5_U32_Base36& parent) __attribute__((nothrow));
u32                  LnumStr5_U32_Base36_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr5_U32_Base36 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::LnumStr5_U32_Base36& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr5_U32_Base36& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr5_U32_Base36& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr5_U32_Base36& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr5_U32_Base36& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr5_U32_Base36& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr5_U32_Base36& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr5_U32_Base36& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr5_U32_Base36_Hash(u32 prev, const algo::LnumStr5_U32_Base36 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr5_U32_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr5_U32_Base36's only field
bool                 LnumStr5_U32_Base36_ReadStrptrMaybe(algo::LnumStr5_U32_Base36 &parent, algo::strptr in_str);
i32                  LnumStr5_U32_Base36_Cmp(algo::LnumStr5_U32_Base36 & lhs, algo::LnumStr5_U32_Base36 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr5_U32_Base36_Init(algo::LnumStr5_U32_Base36& parent);
bool                 LnumStr5_U32_Base36_Eq(const algo::LnumStr5_U32_Base36 & lhs,const algo::LnumStr5_U32_Base36 & rhs) __attribute__((nothrow));
bool                 LnumStr5_U32_Base36_EqStrptr(algo::LnumStr5_U32_Base36 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr5_U32_Base36 to string LHS, no header -- cprint:algo.LnumStr5_U32_Base36.String
void                 LnumStr5_U32_Base36_Print(algo::LnumStr5_U32_Base36 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr6_U32
#pragma pack(push,1)
struct LnumStr6_U32 { // algo.LnumStr6_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 6 };
    u8 ch[6];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr6_U32 &rhs) const;
    bool operator !=(const algo::LnumStr6_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr6_U32& parent) __attribute__((nothrow));
    LnumStr6_U32(const algo::LnumStr6_U32 &rhs) __attribute__((nothrow));
    LnumStr6_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr6_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr6_U32& parent) __attribute__((nothrow));
u32                  LnumStr6_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr6_U32 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(algo::LnumStr6_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr6_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr6_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr6_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr6_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr6_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr6_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr6_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr6_U32_Hash(u32 prev, const algo::LnumStr6_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr6_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr6_U32's only field
bool                 LnumStr6_U32_ReadStrptrMaybe(algo::LnumStr6_U32 &parent, algo::strptr in_str);
i32                  LnumStr6_U32_Cmp(algo::LnumStr6_U32 & lhs, algo::LnumStr6_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr6_U32_Init(algo::LnumStr6_U32& parent);
bool                 LnumStr6_U32_Eq(const algo::LnumStr6_U32 & lhs,const algo::LnumStr6_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr6_U32_EqStrptr(algo::LnumStr6_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr6_U32 to string LHS, no header -- cprint:algo.LnumStr6_U32.String
void                 LnumStr6_U32_Print(algo::LnumStr6_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr7_U32
#pragma pack(push,1)
struct LnumStr7_U32 { // algo.LnumStr7_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 7 };
    u8 ch[7];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr7_U32 &rhs) const;
    bool operator !=(const algo::LnumStr7_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr7_U32& parent) __attribute__((nothrow));
    LnumStr7_U32(const algo::LnumStr7_U32 &rhs) __attribute__((nothrow));
    LnumStr7_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr7_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr7_U32& parent) __attribute__((nothrow));
u32                  LnumStr7_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr7_U32 &parent) __attribute__((nothrow));
// always return constant 7
int                  ch_Max(algo::LnumStr7_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr7_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr7_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr7_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr7_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr7_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr7_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr7_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr7_U32_Hash(u32 prev, const algo::LnumStr7_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr7_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr7_U32's only field
bool                 LnumStr7_U32_ReadStrptrMaybe(algo::LnumStr7_U32 &parent, algo::strptr in_str);
i32                  LnumStr7_U32_Cmp(algo::LnumStr7_U32 & lhs, algo::LnumStr7_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr7_U32_Init(algo::LnumStr7_U32& parent);
bool                 LnumStr7_U32_Eq(const algo::LnumStr7_U32 & lhs,const algo::LnumStr7_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr7_U32_EqStrptr(algo::LnumStr7_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr7_U32 to string LHS, no header -- cprint:algo.LnumStr7_U32.String
void                 LnumStr7_U32_Print(algo::LnumStr7_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr7_U32_Base36
#pragma pack(push,1)
struct LnumStr7_U32_Base36 { // algo.LnumStr7_U32_Base36: number stored as ascii digits, left pad with '0', base 36
    enum { ch_max = 7 };
    u8 ch[7];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr7_U32_Base36 &rhs) const;
    bool operator !=(const algo::LnumStr7_U32_Base36 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr7_U32_Base36& parent) __attribute__((nothrow));
    LnumStr7_U32_Base36(const algo::LnumStr7_U32_Base36 &rhs) __attribute__((nothrow));
    LnumStr7_U32_Base36(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr7_U32_Base36();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr7_U32_Base36& parent) __attribute__((nothrow));
u32                  LnumStr7_U32_Base36_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr7_U32_Base36 &parent) __attribute__((nothrow));
// always return constant 7
int                  ch_Max(algo::LnumStr7_U32_Base36& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr7_U32_Base36& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr7_U32_Base36& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr7_U32_Base36& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr7_U32_Base36& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr7_U32_Base36& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr7_U32_Base36& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr7_U32_Base36& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr7_U32_Base36_Hash(u32 prev, const algo::LnumStr7_U32_Base36 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr7_U32_Base36 from an ascii string.
// The format of the string is the format of the algo::LnumStr7_U32_Base36's only field
bool                 LnumStr7_U32_Base36_ReadStrptrMaybe(algo::LnumStr7_U32_Base36 &parent, algo::strptr in_str);
i32                  LnumStr7_U32_Base36_Cmp(algo::LnumStr7_U32_Base36 & lhs, algo::LnumStr7_U32_Base36 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr7_U32_Base36_Init(algo::LnumStr7_U32_Base36& parent);
bool                 LnumStr7_U32_Base36_Eq(const algo::LnumStr7_U32_Base36 & lhs,const algo::LnumStr7_U32_Base36 & rhs) __attribute__((nothrow));
bool                 LnumStr7_U32_Base36_EqStrptr(algo::LnumStr7_U32_Base36 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr7_U32_Base36 to string LHS, no header -- cprint:algo.LnumStr7_U32_Base36.String
void                 LnumStr7_U32_Base36_Print(algo::LnumStr7_U32_Base36 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr8_U32
#pragma pack(push,1)
struct LnumStr8_U32 { // algo.LnumStr8_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 8 };
    u8 ch[8];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr8_U32 &rhs) const;
    bool operator !=(const algo::LnumStr8_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr8_U32& parent) __attribute__((nothrow));
    LnumStr8_U32(const algo::LnumStr8_U32 &rhs) __attribute__((nothrow));
    LnumStr8_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr8_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr8_U32& parent) __attribute__((nothrow));
u32                  LnumStr8_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr8_U32 &parent) __attribute__((nothrow));
// always return constant 8
int                  ch_Max(algo::LnumStr8_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr8_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr8_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr8_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr8_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr8_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr8_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr8_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr8_U32_Hash(u32 prev, const algo::LnumStr8_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr8_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U32's only field
bool                 LnumStr8_U32_ReadStrptrMaybe(algo::LnumStr8_U32 &parent, algo::strptr in_str);
i32                  LnumStr8_U32_Cmp(algo::LnumStr8_U32 & lhs, algo::LnumStr8_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr8_U32_Init(algo::LnumStr8_U32& parent);
bool                 LnumStr8_U32_Eq(const algo::LnumStr8_U32 & lhs,const algo::LnumStr8_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr8_U32_EqStrptr(algo::LnumStr8_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr8_U32 to string LHS, no header -- cprint:algo.LnumStr8_U32.String
void                 LnumStr8_U32_Print(algo::LnumStr8_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr8_U32_Base16
#pragma pack(push,1)
struct LnumStr8_U32_Base16 { // algo.LnumStr8_U32_Base16: number stored as ascii digits, padded with 0s, base 16
    enum { ch_max = 8 };
    u8 ch[8];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr8_U32_Base16 &rhs) const;
    bool operator !=(const algo::LnumStr8_U32_Base16 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr8_U32_Base16& parent) __attribute__((nothrow));
    LnumStr8_U32_Base16(const algo::LnumStr8_U32_Base16 &rhs) __attribute__((nothrow));
    LnumStr8_U32_Base16(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr8_U32_Base16();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr8_U32_Base16& parent) __attribute__((nothrow));
u32                  LnumStr8_U32_Base16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr8_U32_Base16 &parent) __attribute__((nothrow));
// always return constant 8
int                  ch_Max(algo::LnumStr8_U32_Base16& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr8_U32_Base16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr8_U32_Base16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr8_U32_Base16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr8_U32_Base16& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr8_U32_Base16& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr8_U32_Base16& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-16 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr8_U32_Base16& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr8_U32_Base16_Hash(u32 prev, const algo::LnumStr8_U32_Base16 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr8_U32_Base16 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U32_Base16's only field
bool                 LnumStr8_U32_Base16_ReadStrptrMaybe(algo::LnumStr8_U32_Base16 &parent, algo::strptr in_str);
i32                  LnumStr8_U32_Base16_Cmp(algo::LnumStr8_U32_Base16 & lhs, algo::LnumStr8_U32_Base16 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr8_U32_Base16_Init(algo::LnumStr8_U32_Base16& parent);
bool                 LnumStr8_U32_Base16_Eq(const algo::LnumStr8_U32_Base16 & lhs,const algo::LnumStr8_U32_Base16 & rhs) __attribute__((nothrow));
bool                 LnumStr8_U32_Base16_EqStrptr(algo::LnumStr8_U32_Base16 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr8_U32_Base16 to string LHS, no header -- cprint:algo.LnumStr8_U32_Base16.String
void                 LnumStr8_U32_Base16_Print(algo::LnumStr8_U32_Base16 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr8_U64
#pragma pack(push,1)
struct LnumStr8_U64 { // algo.LnumStr8_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 8 };
    u8 ch[8];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr8_U64 &rhs) const;
    bool operator !=(const algo::LnumStr8_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr8_U64& parent) __attribute__((nothrow));
    LnumStr8_U64(const algo::LnumStr8_U64 &rhs) __attribute__((nothrow));
    LnumStr8_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr8_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr8_U64& parent) __attribute__((nothrow));
u32                  LnumStr8_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr8_U64 &parent) __attribute__((nothrow));
// always return constant 8
int                  ch_Max(algo::LnumStr8_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr8_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr8_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr8_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr8_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr8_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr8_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr8_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr8_U64_Hash(u32 prev, const algo::LnumStr8_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr8_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr8_U64's only field
bool                 LnumStr8_U64_ReadStrptrMaybe(algo::LnumStr8_U64 &parent, algo::strptr in_str);
i32                  LnumStr8_U64_Cmp(algo::LnumStr8_U64 & lhs, algo::LnumStr8_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr8_U64_Init(algo::LnumStr8_U64& parent);
bool                 LnumStr8_U64_Eq(const algo::LnumStr8_U64 & lhs,const algo::LnumStr8_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr8_U64_EqStrptr(algo::LnumStr8_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr8_U64 to string LHS, no header -- cprint:algo.LnumStr8_U64.String
void                 LnumStr8_U64_Print(algo::LnumStr8_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr9_U32
#pragma pack(push,1)
struct LnumStr9_U32 { // algo.LnumStr9_U32: number stored as ascii digits, left pad with '0'
    enum { ch_max = 9 };
    u8 ch[9];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr9_U32 &rhs) const;
    bool operator !=(const algo::LnumStr9_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr9_U32& parent) __attribute__((nothrow));
    LnumStr9_U32(const algo::LnumStr9_U32 &rhs) __attribute__((nothrow));
    LnumStr9_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr9_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr9_U32& parent) __attribute__((nothrow));
u32                  LnumStr9_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr9_U32 &parent) __attribute__((nothrow));
// always return constant 9
int                  ch_Max(algo::LnumStr9_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr9_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr9_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr9_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr9_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LnumStr9_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr9_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr9_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr9_U32_Hash(u32 prev, const algo::LnumStr9_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr9_U32 from an ascii string.
// The format of the string is the format of the algo::LnumStr9_U32's only field
bool                 LnumStr9_U32_ReadStrptrMaybe(algo::LnumStr9_U32 &parent, algo::strptr in_str);
i32                  LnumStr9_U32_Cmp(algo::LnumStr9_U32 & lhs, algo::LnumStr9_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr9_U32_Init(algo::LnumStr9_U32& parent);
bool                 LnumStr9_U32_Eq(const algo::LnumStr9_U32 & lhs,const algo::LnumStr9_U32 & rhs) __attribute__((nothrow));
bool                 LnumStr9_U32_EqStrptr(algo::LnumStr9_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr9_U32 to string LHS, no header -- cprint:algo.LnumStr9_U32.String
void                 LnumStr9_U32_Print(algo::LnumStr9_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LnumStr9_U64
struct LnumStr9_U64 { // algo.LnumStr9_U64: number stored as ascii digits, left pad with '0'
    enum { ch_max = 9 };
    u8 ch[9];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LnumStr9_U64 &rhs) const;
    bool operator !=(const algo::LnumStr9_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LnumStr9_U64& parent) __attribute__((nothrow));
    LnumStr9_U64(const algo::LnumStr9_U64 &rhs) __attribute__((nothrow));
    LnumStr9_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LnumStr9_U64();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LnumStr9_U64& parent) __attribute__((nothrow));
u32                  LnumStr9_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LnumStr9_U64 &parent) __attribute__((nothrow));
// always return constant 9
int                  ch_Max(algo::LnumStr9_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LnumStr9_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LnumStr9_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LnumStr9_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LnumStr9_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LnumStr9_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LnumStr9_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LnumStr9_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LnumStr9_U64_Hash(u32 prev, const algo::LnumStr9_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LnumStr9_U64 from an ascii string.
// The format of the string is the format of the algo::LnumStr9_U64's only field
bool                 LnumStr9_U64_ReadStrptrMaybe(algo::LnumStr9_U64 &parent, algo::strptr in_str);
i32                  LnumStr9_U64_Cmp(algo::LnumStr9_U64 & lhs, algo::LnumStr9_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LnumStr9_U64_Init(algo::LnumStr9_U64& parent);
bool                 LnumStr9_U64_Eq(const algo::LnumStr9_U64 & lhs,const algo::LnumStr9_U64 & rhs) __attribute__((nothrow));
bool                 LnumStr9_U64_EqStrptr(algo::LnumStr9_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LnumStr9_U64 to string LHS, no header -- cprint:algo.LnumStr9_U64.String
void                 LnumStr9_U64_Print(algo::LnumStr9_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LogcatId
struct LogcatId { // algo.LogcatId
    i32   value;   //   0
    inline operator i32() const;
    explicit LogcatId(i32                            in_value);
    LogcatId();
};

// Read fields of algo::LogcatId from an ascii string.
// The format of the string is the format of the algo::LogcatId's only field
bool                 LogcatId_ReadStrptrMaybe(algo::LogcatId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 LogcatId_Init(algo::LogcatId& parent);
// print string representation of algo::LogcatId to string LHS, no header -- cprint:algo.LogcatId.String
void                 LogcatId_Print(algo::LogcatId row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LogcatKey
struct LogcatKey { // algo.LogcatKey
    algo::Smallstr50   value;   //
    inline operator algo::strptr() const;
    explicit LogcatKey(const algo::strptr&            in_value);
    LogcatKey();
};

// Read fields of algo::LogcatKey from an ascii string.
// The format of the string is the format of the algo::LogcatKey's only field
bool                 LogcatKey_ReadStrptrMaybe(algo::LogcatKey &parent, algo::strptr in_str);
// print string representation of algo::LogcatKey to string LHS, no header -- cprint:algo.LogcatKey.String
void                 LogcatKey_Print(algo::LogcatKey & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.SchedTime
#pragma pack(push,1)
struct SchedTime { // algo.SchedTime
    u64   value;   //   0
    inline operator u64() const;
    explicit SchedTime(u64                            in_value);
    SchedTime();
};
#pragma pack(pop)

// Read fields of algo::SchedTime from an ascii string.
// The format of the string is the format of the algo::SchedTime's only field
bool                 SchedTime_ReadStrptrMaybe(algo::SchedTime &parent, algo::strptr in_str);
bool                 SchedTime_Lt(algo::SchedTime lhs, algo::SchedTime rhs) __attribute__((nothrow));
i32                  SchedTime_Cmp(algo::SchedTime lhs, algo::SchedTime rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 SchedTime_Init(algo::SchedTime& parent);
bool                 SchedTime_Eq(algo::SchedTime lhs, algo::SchedTime rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 SchedTime_Update(algo::SchedTime &lhs, algo::SchedTime rhs) __attribute__((nothrow));
// print string representation of algo::SchedTime to string LHS, no header -- cprint:algo.SchedTime.String
void                 SchedTime_Print(algo::SchedTime row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr200
struct Smallstr200 { // algo.Smallstr200
    enum { ch_max = 200 };
    u8 ch[200+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr200 &rhs) const;
    bool operator !=(const algo::Smallstr200 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr200& parent) __attribute__((nothrow));
    Smallstr200(const algo::Smallstr200 &rhs) __attribute__((nothrow));
    Smallstr200(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr200();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr200& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr200& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr200& parent) __attribute__((nothrow));
u32                  Smallstr200_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr200 &parent) __attribute__((nothrow));
// always return constant 200
int                  ch_Max(algo::Smallstr200& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr200& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr200& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr200& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr200& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr200_Hash(u32 prev, const algo::Smallstr200 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr200 from an ascii string.
// The format of the string is the format of the algo::Smallstr200's only field
bool                 Smallstr200_ReadStrptrMaybe(algo::Smallstr200 &parent, algo::strptr in_str);
i32                  Smallstr200_Cmp(algo::Smallstr200 & lhs, algo::Smallstr200 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr200_Init(algo::Smallstr200& parent);
bool                 Smallstr200_Eq(const algo::Smallstr200 & lhs,const algo::Smallstr200 & rhs) __attribute__((nothrow));
bool                 Smallstr200_EqStrptr(algo::Smallstr200 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr200 to string LHS, no header -- cprint:algo.Smallstr200.String
void                 Smallstr200_Print(algo::Smallstr200 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Logmsg
struct Logmsg { // algo.Logmsg
    u64                 logmsg;   //   0  Sequence number
    algo::SchedTime     time;     // Timestamp
    bool                err;      //   false  Error?
    bool                part;     //   false  Partial message (next message follows)
    algo::Smallstr200   text;     // Message text
    Logmsg();
};

// Set all fields to initial values.
void                 Logmsg_Init(algo::Logmsg& parent);
// print string representation of algo::Logmsg to string LHS, no header -- cprint:algo.Logmsg.String
void                 Logmsg_Print(algo::Logmsg & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr10
#pragma pack(push,1)
struct LspaceStr10 { // algo.LspaceStr10
    enum { ch_max = 10 };
    u8 ch[10];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr10 &rhs) const;
    bool operator !=(const algo::LspaceStr10 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr10& parent) __attribute__((nothrow));
    LspaceStr10(const algo::LspaceStr10 &rhs) __attribute__((nothrow));
    LspaceStr10(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr10();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr10& parent) __attribute__((nothrow));
u32                  LspaceStr10_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr10 &parent) __attribute__((nothrow));
// always return constant 10
int                  ch_Max(algo::LspaceStr10& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr10& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr10& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr10& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr10& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr10_Hash(u32 prev, const algo::LspaceStr10 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr10 from an ascii string.
// The format of the string is the format of the algo::LspaceStr10's only field
bool                 LspaceStr10_ReadStrptrMaybe(algo::LspaceStr10 &parent, algo::strptr in_str);
i32                  LspaceStr10_Cmp(algo::LspaceStr10 & lhs, algo::LspaceStr10 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr10_Init(algo::LspaceStr10& parent);
bool                 LspaceStr10_Eq(const algo::LspaceStr10 & lhs,const algo::LspaceStr10 & rhs) __attribute__((nothrow));
bool                 LspaceStr10_EqStrptr(algo::LspaceStr10 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr10 to string LHS, no header -- cprint:algo.LspaceStr10.String
void                 LspaceStr10_Print(algo::LspaceStr10 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr12
#pragma pack(push,1)
struct LspaceStr12 { // algo.LspaceStr12
    enum { ch_max = 12 };
    u8 ch[12];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr12 &rhs) const;
    bool operator !=(const algo::LspaceStr12 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr12& parent) __attribute__((nothrow));
    LspaceStr12(const algo::LspaceStr12 &rhs) __attribute__((nothrow));
    LspaceStr12(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr12();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr12& parent) __attribute__((nothrow));
u32                  LspaceStr12_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr12 &parent) __attribute__((nothrow));
// always return constant 12
int                  ch_Max(algo::LspaceStr12& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr12& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr12& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr12& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr12& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr12_Hash(u32 prev, const algo::LspaceStr12 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr12 from an ascii string.
// The format of the string is the format of the algo::LspaceStr12's only field
bool                 LspaceStr12_ReadStrptrMaybe(algo::LspaceStr12 &parent, algo::strptr in_str);
i32                  LspaceStr12_Cmp(algo::LspaceStr12 & lhs, algo::LspaceStr12 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr12_Init(algo::LspaceStr12& parent);
bool                 LspaceStr12_Eq(const algo::LspaceStr12 & lhs,const algo::LspaceStr12 & rhs) __attribute__((nothrow));
bool                 LspaceStr12_EqStrptr(algo::LspaceStr12 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr12 to string LHS, no header -- cprint:algo.LspaceStr12.String
void                 LspaceStr12_Print(algo::LspaceStr12 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr14
#pragma pack(push,1)
struct LspaceStr14 { // algo.LspaceStr14
    enum { ch_max = 14 };
    u8 ch[14];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr14 &rhs) const;
    bool operator !=(const algo::LspaceStr14 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr14& parent) __attribute__((nothrow));
    LspaceStr14(const algo::LspaceStr14 &rhs) __attribute__((nothrow));
    LspaceStr14(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr14();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr14& parent) __attribute__((nothrow));
u32                  LspaceStr14_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr14 &parent) __attribute__((nothrow));
// always return constant 14
int                  ch_Max(algo::LspaceStr14& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr14& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr14& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr14& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr14& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr14_Hash(u32 prev, const algo::LspaceStr14 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr14 from an ascii string.
// The format of the string is the format of the algo::LspaceStr14's only field
bool                 LspaceStr14_ReadStrptrMaybe(algo::LspaceStr14 &parent, algo::strptr in_str);
i32                  LspaceStr14_Cmp(algo::LspaceStr14 & lhs, algo::LspaceStr14 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr14_Init(algo::LspaceStr14& parent);
bool                 LspaceStr14_Eq(const algo::LspaceStr14 & lhs,const algo::LspaceStr14 & rhs) __attribute__((nothrow));
bool                 LspaceStr14_EqStrptr(algo::LspaceStr14 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr14 to string LHS, no header -- cprint:algo.LspaceStr14.String
void                 LspaceStr14_Print(algo::LspaceStr14 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr15
#pragma pack(push,1)
struct LspaceStr15 { // algo.LspaceStr15
    enum { ch_max = 15 };
    u8 ch[15];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr15 &rhs) const;
    bool operator !=(const algo::LspaceStr15 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr15& parent) __attribute__((nothrow));
    LspaceStr15(const algo::LspaceStr15 &rhs) __attribute__((nothrow));
    LspaceStr15(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr15();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr15& parent) __attribute__((nothrow));
u32                  LspaceStr15_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr15 &parent) __attribute__((nothrow));
// always return constant 15
int                  ch_Max(algo::LspaceStr15& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr15& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr15& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr15& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr15& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr15_Hash(u32 prev, const algo::LspaceStr15 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr15 from an ascii string.
// The format of the string is the format of the algo::LspaceStr15's only field
bool                 LspaceStr15_ReadStrptrMaybe(algo::LspaceStr15 &parent, algo::strptr in_str);
i32                  LspaceStr15_Cmp(algo::LspaceStr15 & lhs, algo::LspaceStr15 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr15_Init(algo::LspaceStr15& parent);
bool                 LspaceStr15_Eq(const algo::LspaceStr15 & lhs,const algo::LspaceStr15 & rhs) __attribute__((nothrow));
bool                 LspaceStr15_EqStrptr(algo::LspaceStr15 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr15 to string LHS, no header -- cprint:algo.LspaceStr15.String
void                 LspaceStr15_Print(algo::LspaceStr15 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr20_I64
struct LspaceStr20_I64 { // algo.LspaceStr20_I64: number stored as ascii digits, left pad with ' '
    enum { ch_max = 20 };
    u8 ch[20];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr20_I64 &rhs) const;
    bool operator !=(const algo::LspaceStr20_I64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr20_I64& parent) __attribute__((nothrow));
    LspaceStr20_I64(const algo::LspaceStr20_I64 &rhs) __attribute__((nothrow));
    LspaceStr20_I64(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr20_I64();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr20_I64& parent) __attribute__((nothrow));
u32                  LspaceStr20_I64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr20_I64 &parent) __attribute__((nothrow));
// always return constant 20
int                  ch_Max(algo::LspaceStr20_I64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr20_I64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr20_I64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr20_I64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr20_I64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i64                  ch_GetnumDflt(algo::LspaceStr20_I64& parent, i64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LspaceStr20_I64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LspaceStr20_I64& parent, i64 rhs) __attribute__((nothrow));

u32                  LspaceStr20_I64_Hash(u32 prev, const algo::LspaceStr20_I64 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr20_I64 from an ascii string.
// The format of the string is the format of the algo::LspaceStr20_I64's only field
bool                 LspaceStr20_I64_ReadStrptrMaybe(algo::LspaceStr20_I64 &parent, algo::strptr in_str);
i32                  LspaceStr20_I64_Cmp(algo::LspaceStr20_I64 & lhs, algo::LspaceStr20_I64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr20_I64_Init(algo::LspaceStr20_I64& parent);
bool                 LspaceStr20_I64_Eq(const algo::LspaceStr20_I64 & lhs,const algo::LspaceStr20_I64 & rhs) __attribute__((nothrow));
bool                 LspaceStr20_I64_EqStrptr(algo::LspaceStr20_I64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr20_I64 to string LHS, no header -- cprint:algo.LspaceStr20_I64.String
void                 LspaceStr20_I64_Print(algo::LspaceStr20_I64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr20_U64
#pragma pack(push,1)
struct LspaceStr20_U64 { // algo.LspaceStr20_U64: number stored as ascii digits, left pad with ' '
    enum { ch_max = 20 };
    u8 ch[20];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr20_U64 &rhs) const;
    bool operator !=(const algo::LspaceStr20_U64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr20_U64& parent) __attribute__((nothrow));
    LspaceStr20_U64(const algo::LspaceStr20_U64 &rhs) __attribute__((nothrow));
    LspaceStr20_U64(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr20_U64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr20_U64& parent) __attribute__((nothrow));
u32                  LspaceStr20_U64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr20_U64 &parent) __attribute__((nothrow));
// always return constant 20
int                  ch_Max(algo::LspaceStr20_U64& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr20_U64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr20_U64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr20_U64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr20_U64& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u64                  ch_GetnumDflt(algo::LspaceStr20_U64& parent, u64 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LspaceStr20_U64& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LspaceStr20_U64& parent, i64 rhs) __attribute__((nothrow));

u32                  LspaceStr20_U64_Hash(u32 prev, const algo::LspaceStr20_U64 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr20_U64 from an ascii string.
// The format of the string is the format of the algo::LspaceStr20_U64's only field
bool                 LspaceStr20_U64_ReadStrptrMaybe(algo::LspaceStr20_U64 &parent, algo::strptr in_str);
i32                  LspaceStr20_U64_Cmp(algo::LspaceStr20_U64 & lhs, algo::LspaceStr20_U64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr20_U64_Init(algo::LspaceStr20_U64& parent);
bool                 LspaceStr20_U64_Eq(const algo::LspaceStr20_U64 & lhs,const algo::LspaceStr20_U64 & rhs) __attribute__((nothrow));
bool                 LspaceStr20_U64_EqStrptr(algo::LspaceStr20_U64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr20_U64 to string LHS, no header -- cprint:algo.LspaceStr20_U64.String
void                 LspaceStr20_U64_Print(algo::LspaceStr20_U64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr3
#pragma pack(push,1)
struct LspaceStr3 { // algo.LspaceStr3
    enum { ch_max = 3 };
    u8 ch[3];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr3 &rhs) const;
    bool operator !=(const algo::LspaceStr3 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr3& parent) __attribute__((nothrow));
    LspaceStr3(const algo::LspaceStr3 &rhs) __attribute__((nothrow));
    LspaceStr3(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr3();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr3& parent) __attribute__((nothrow));
u32                  LspaceStr3_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr3 &parent) __attribute__((nothrow));
// always return constant 3
int                  ch_Max(algo::LspaceStr3& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr3& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr3& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr3& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr3& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr3_Hash(u32 prev, const algo::LspaceStr3 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr3 from an ascii string.
// The format of the string is the format of the algo::LspaceStr3's only field
bool                 LspaceStr3_ReadStrptrMaybe(algo::LspaceStr3 &parent, algo::strptr in_str);
i32                  LspaceStr3_Cmp(algo::LspaceStr3 & lhs, algo::LspaceStr3 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr3_Init(algo::LspaceStr3& parent);
bool                 LspaceStr3_Eq(const algo::LspaceStr3 & lhs,const algo::LspaceStr3 & rhs) __attribute__((nothrow));
bool                 LspaceStr3_EqStrptr(algo::LspaceStr3 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr3 to string LHS, no header -- cprint:algo.LspaceStr3.String
void                 LspaceStr3_Print(algo::LspaceStr3 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr3_I16
#pragma pack(push,1)
struct LspaceStr3_I16 { // algo.LspaceStr3_I16: number stored as ascii digits, left pad with ' '
    enum { ch_max = 3 };
    u8 ch[3];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr3_I16 &rhs) const;
    bool operator !=(const algo::LspaceStr3_I16 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr3_I16& parent) __attribute__((nothrow));
    LspaceStr3_I16(const algo::LspaceStr3_I16 &rhs) __attribute__((nothrow));
    LspaceStr3_I16(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr3_I16();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr3_I16& parent) __attribute__((nothrow));
u32                  LspaceStr3_I16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr3_I16 &parent) __attribute__((nothrow));
// always return constant 3
int                  ch_Max(algo::LspaceStr3_I16& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr3_I16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr3_I16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr3_I16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr3_I16& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i16                  ch_GetnumDflt(algo::LspaceStr3_I16& parent, i16 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LspaceStr3_I16& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LspaceStr3_I16& parent, i64 rhs) __attribute__((nothrow));

u32                  LspaceStr3_I16_Hash(u32 prev, const algo::LspaceStr3_I16 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr3_I16 from an ascii string.
// The format of the string is the format of the algo::LspaceStr3_I16's only field
bool                 LspaceStr3_I16_ReadStrptrMaybe(algo::LspaceStr3_I16 &parent, algo::strptr in_str);
i32                  LspaceStr3_I16_Cmp(algo::LspaceStr3_I16 & lhs, algo::LspaceStr3_I16 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr3_I16_Init(algo::LspaceStr3_I16& parent);
bool                 LspaceStr3_I16_Eq(const algo::LspaceStr3_I16 & lhs,const algo::LspaceStr3_I16 & rhs) __attribute__((nothrow));
bool                 LspaceStr3_I16_EqStrptr(algo::LspaceStr3_I16 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr3_I16 to string LHS, no header -- cprint:algo.LspaceStr3_I16.String
void                 LspaceStr3_I16_Print(algo::LspaceStr3_I16 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr4
#pragma pack(push,1)
struct LspaceStr4 { // algo.LspaceStr4
    enum { ch_max = 4 };
    u8 ch[4];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr4 &rhs) const;
    bool operator !=(const algo::LspaceStr4 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr4& parent) __attribute__((nothrow));
    LspaceStr4(const algo::LspaceStr4 &rhs) __attribute__((nothrow));
    LspaceStr4(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr4();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr4& parent) __attribute__((nothrow));
u32                  LspaceStr4_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr4 &parent) __attribute__((nothrow));
// always return constant 4
int                  ch_Max(algo::LspaceStr4& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr4& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr4& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr4& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr4& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr4_Hash(u32 prev, const algo::LspaceStr4 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr4 from an ascii string.
// The format of the string is the format of the algo::LspaceStr4's only field
bool                 LspaceStr4_ReadStrptrMaybe(algo::LspaceStr4 &parent, algo::strptr in_str);
i32                  LspaceStr4_Cmp(algo::LspaceStr4 & lhs, algo::LspaceStr4 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr4_Init(algo::LspaceStr4& parent);
bool                 LspaceStr4_Eq(const algo::LspaceStr4 & lhs,const algo::LspaceStr4 & rhs) __attribute__((nothrow));
bool                 LspaceStr4_EqStrptr(algo::LspaceStr4 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr4 to string LHS, no header -- cprint:algo.LspaceStr4.String
void                 LspaceStr4_Print(algo::LspaceStr4 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr5
#pragma pack(push,1)
struct LspaceStr5 { // algo.LspaceStr5
    enum { ch_max = 5 };
    u8 ch[5];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr5 &rhs) const;
    bool operator !=(const algo::LspaceStr5 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr5& parent) __attribute__((nothrow));
    LspaceStr5(const algo::LspaceStr5 &rhs) __attribute__((nothrow));
    LspaceStr5(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr5();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr5& parent) __attribute__((nothrow));
u32                  LspaceStr5_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr5 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::LspaceStr5& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr5& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr5& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr5& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr5& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr5_Hash(u32 prev, const algo::LspaceStr5 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr5 from an ascii string.
// The format of the string is the format of the algo::LspaceStr5's only field
bool                 LspaceStr5_ReadStrptrMaybe(algo::LspaceStr5 &parent, algo::strptr in_str);
i32                  LspaceStr5_Cmp(algo::LspaceStr5 & lhs, algo::LspaceStr5 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr5_Init(algo::LspaceStr5& parent);
bool                 LspaceStr5_Eq(const algo::LspaceStr5 & lhs,const algo::LspaceStr5 & rhs) __attribute__((nothrow));
bool                 LspaceStr5_EqStrptr(algo::LspaceStr5 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr5 to string LHS, no header -- cprint:algo.LspaceStr5.String
void                 LspaceStr5_Print(algo::LspaceStr5 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr5_I16
#pragma pack(push,1)
struct LspaceStr5_I16 { // algo.LspaceStr5_I16
    enum { ch_max = 5 };
    u8 ch[5];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr5_I16 &rhs) const;
    bool operator !=(const algo::LspaceStr5_I16 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr5_I16& parent) __attribute__((nothrow));
    LspaceStr5_I16(const algo::LspaceStr5_I16 &rhs) __attribute__((nothrow));
    LspaceStr5_I16(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr5_I16();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr5_I16& parent) __attribute__((nothrow));
u32                  LspaceStr5_I16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr5_I16 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::LspaceStr5_I16& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr5_I16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr5_I16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr5_I16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr5_I16& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u16                  ch_GetnumDflt(algo::LspaceStr5_I16& parent, u16 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LspaceStr5_I16& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LspaceStr5_I16& parent, i64 rhs) __attribute__((nothrow));

u32                  LspaceStr5_I16_Hash(u32 prev, const algo::LspaceStr5_I16 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr5_I16 from an ascii string.
// The format of the string is the format of the algo::LspaceStr5_I16's only field
bool                 LspaceStr5_I16_ReadStrptrMaybe(algo::LspaceStr5_I16 &parent, algo::strptr in_str);
i32                  LspaceStr5_I16_Cmp(algo::LspaceStr5_I16 & lhs, algo::LspaceStr5_I16 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr5_I16_Init(algo::LspaceStr5_I16& parent);
bool                 LspaceStr5_I16_Eq(const algo::LspaceStr5_I16 & lhs,const algo::LspaceStr5_I16 & rhs) __attribute__((nothrow));
bool                 LspaceStr5_I16_EqStrptr(algo::LspaceStr5_I16 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr5_I16 to string LHS, no header -- cprint:algo.LspaceStr5_I16.String
void                 LspaceStr5_I16_Print(algo::LspaceStr5_I16 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr6
#pragma pack(push,1)
struct LspaceStr6 { // algo.LspaceStr6
    enum { ch_max = 6 };
    u8 ch[6];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr6 &rhs) const;
    bool operator !=(const algo::LspaceStr6 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr6& parent) __attribute__((nothrow));
    LspaceStr6(const algo::LspaceStr6 &rhs) __attribute__((nothrow));
    LspaceStr6(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr6();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr6& parent) __attribute__((nothrow));
u32                  LspaceStr6_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr6 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(algo::LspaceStr6& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr6& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr6& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr6& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr6& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr6_Hash(u32 prev, const algo::LspaceStr6 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr6 from an ascii string.
// The format of the string is the format of the algo::LspaceStr6's only field
bool                 LspaceStr6_ReadStrptrMaybe(algo::LspaceStr6 &parent, algo::strptr in_str);
i32                  LspaceStr6_Cmp(algo::LspaceStr6 & lhs, algo::LspaceStr6 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr6_Init(algo::LspaceStr6& parent);
bool                 LspaceStr6_Eq(const algo::LspaceStr6 & lhs,const algo::LspaceStr6 & rhs) __attribute__((nothrow));
bool                 LspaceStr6_EqStrptr(algo::LspaceStr6 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr6 to string LHS, no header -- cprint:algo.LspaceStr6.String
void                 LspaceStr6_Print(algo::LspaceStr6 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr6_U32
struct LspaceStr6_U32 { // algo.LspaceStr6_U32: number stored as ascii digits, left pad with ' '
    enum { ch_max = 6 };
    u8 ch[6];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr6_U32 &rhs) const;
    bool operator !=(const algo::LspaceStr6_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr6_U32& parent) __attribute__((nothrow));
    LspaceStr6_U32(const algo::LspaceStr6_U32 &rhs) __attribute__((nothrow));
    LspaceStr6_U32(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr6_U32();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr6_U32& parent) __attribute__((nothrow));
u32                  LspaceStr6_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr6_U32 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(algo::LspaceStr6_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr6_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr6_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr6_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr6_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::LspaceStr6_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LspaceStr6_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LspaceStr6_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  LspaceStr6_U32_Hash(u32 prev, const algo::LspaceStr6_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr6_U32 from an ascii string.
// The format of the string is the format of the algo::LspaceStr6_U32's only field
bool                 LspaceStr6_U32_ReadStrptrMaybe(algo::LspaceStr6_U32 &parent, algo::strptr in_str);
i32                  LspaceStr6_U32_Cmp(algo::LspaceStr6_U32 & lhs, algo::LspaceStr6_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr6_U32_Init(algo::LspaceStr6_U32& parent);
bool                 LspaceStr6_U32_Eq(const algo::LspaceStr6_U32 & lhs,const algo::LspaceStr6_U32 & rhs) __attribute__((nothrow));
bool                 LspaceStr6_U32_EqStrptr(algo::LspaceStr6_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr6_U32 to string LHS, no header -- cprint:algo.LspaceStr6_U32.String
void                 LspaceStr6_U32_Print(algo::LspaceStr6_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr7_I32_Base36
struct LspaceStr7_I32_Base36 { // algo.LspaceStr7_I32_Base36: number stored as ascii digits, left pad with ' ', base 36
    enum { ch_max = 7 };
    u8 ch[7];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr7_I32_Base36 &rhs) const;
    bool operator !=(const algo::LspaceStr7_I32_Base36 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr7_I32_Base36& parent) __attribute__((nothrow));
    LspaceStr7_I32_Base36(const algo::LspaceStr7_I32_Base36 &rhs) __attribute__((nothrow));
    LspaceStr7_I32_Base36(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr7_I32_Base36();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr7_I32_Base36& parent) __attribute__((nothrow));
u32                  LspaceStr7_I32_Base36_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr7_I32_Base36 &parent) __attribute__((nothrow));
// always return constant 7
int                  ch_Max(algo::LspaceStr7_I32_Base36& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr7_I32_Base36& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr7_I32_Base36& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr7_I32_Base36& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr7_I32_Base36& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
i32                  ch_GetnumDflt(algo::LspaceStr7_I32_Base36& parent, i32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::LspaceStr7_I32_Base36& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-36 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::LspaceStr7_I32_Base36& parent, i64 rhs) __attribute__((nothrow));

u32                  LspaceStr7_I32_Base36_Hash(u32 prev, const algo::LspaceStr7_I32_Base36 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr7_I32_Base36 from an ascii string.
// The format of the string is the format of the algo::LspaceStr7_I32_Base36's only field
bool                 LspaceStr7_I32_Base36_ReadStrptrMaybe(algo::LspaceStr7_I32_Base36 &parent, algo::strptr in_str);
i32                  LspaceStr7_I32_Base36_Cmp(algo::LspaceStr7_I32_Base36 & lhs, algo::LspaceStr7_I32_Base36 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr7_I32_Base36_Init(algo::LspaceStr7_I32_Base36& parent);
bool                 LspaceStr7_I32_Base36_Eq(const algo::LspaceStr7_I32_Base36 & lhs,const algo::LspaceStr7_I32_Base36 & rhs) __attribute__((nothrow));
bool                 LspaceStr7_I32_Base36_EqStrptr(algo::LspaceStr7_I32_Base36 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr7_I32_Base36 to string LHS, no header -- cprint:algo.LspaceStr7_I32_Base36.String
void                 LspaceStr7_I32_Base36_Print(algo::LspaceStr7_I32_Base36 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr8
#pragma pack(push,1)
struct LspaceStr8 { // algo.LspaceStr8
    enum { ch_max = 8 };
    u8 ch[8];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr8 &rhs) const;
    bool operator !=(const algo::LspaceStr8 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr8& parent) __attribute__((nothrow));
    LspaceStr8(const algo::LspaceStr8 &rhs) __attribute__((nothrow));
    LspaceStr8(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr8();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr8& parent) __attribute__((nothrow));
u32                  LspaceStr8_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr8 &parent) __attribute__((nothrow));
// always return constant 8
int                  ch_Max(algo::LspaceStr8& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr8& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr8& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr8& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr8& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr8_Hash(u32 prev, const algo::LspaceStr8 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr8 from an ascii string.
// The format of the string is the format of the algo::LspaceStr8's only field
bool                 LspaceStr8_ReadStrptrMaybe(algo::LspaceStr8 &parent, algo::strptr in_str);
i32                  LspaceStr8_Cmp(algo::LspaceStr8 & lhs, algo::LspaceStr8 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr8_Init(algo::LspaceStr8& parent);
bool                 LspaceStr8_Eq(const algo::LspaceStr8 & lhs,const algo::LspaceStr8 & rhs) __attribute__((nothrow));
bool                 LspaceStr8_EqStrptr(algo::LspaceStr8 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr8 to string LHS, no header -- cprint:algo.LspaceStr8.String
void                 LspaceStr8_Print(algo::LspaceStr8 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.LspaceStr9
#pragma pack(push,1)
struct LspaceStr9 { // algo.LspaceStr9
    enum { ch_max = 9 };
    u8 ch[9];
    inline operator algo::strptr() const;
    bool operator ==(const algo::LspaceStr9 &rhs) const;
    bool operator !=(const algo::LspaceStr9 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::LspaceStr9& parent) __attribute__((nothrow));
    LspaceStr9(const algo::LspaceStr9 &rhs) __attribute__((nothrow));
    LspaceStr9(const algo::strptr &rhs) __attribute__((nothrow));
    LspaceStr9();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::LspaceStr9& parent) __attribute__((nothrow));
u32                  LspaceStr9_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::LspaceStr9 &parent) __attribute__((nothrow));
// always return constant 9
int                  ch_Max(algo::LspaceStr9& parent) __attribute__((nothrow));
int                  ch_N(const algo::LspaceStr9& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::LspaceStr9& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::LspaceStr9& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::LspaceStr9& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  LspaceStr9_Hash(u32 prev, const algo::LspaceStr9 & rhs) __attribute__((nothrow));
// Read fields of algo::LspaceStr9 from an ascii string.
// The format of the string is the format of the algo::LspaceStr9's only field
bool                 LspaceStr9_ReadStrptrMaybe(algo::LspaceStr9 &parent, algo::strptr in_str);
i32                  LspaceStr9_Cmp(algo::LspaceStr9 & lhs, algo::LspaceStr9 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 LspaceStr9_Init(algo::LspaceStr9& parent);
bool                 LspaceStr9_Eq(const algo::LspaceStr9 & lhs,const algo::LspaceStr9 & rhs) __attribute__((nothrow));
bool                 LspaceStr9_EqStrptr(algo::LspaceStr9 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::LspaceStr9 to string LHS, no header -- cprint:algo.LspaceStr9.String
void                 LspaceStr9_Print(algo::LspaceStr9 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Md5Digest
struct Md5Digest { // algo.Md5Digest
    u8   value_elems[16];   //   0  fixed array
    explicit Md5Digest(algo::aryptr<u8 >              in_value);
    Md5Digest();
};

// Set all elements of fixed array to value RHS
void                 value_Fill(algo::Md5Digest& parent, const u8 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u8*                  value_Find(algo::Md5Digest& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array value as aryptr.
algo::aryptr<u8>     value_Getary(algo::Md5Digest& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  value_Max(algo::Md5Digest& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  value_N(const algo::Md5Digest& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 value_Setary(algo::Md5Digest& parent, const algo::aryptr<u8> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u8&                  value_qFind(algo::Md5Digest& parent, u64 t) __attribute__((nothrow));
// Convert value to a string. Parent's separator is used.
void                 value_Print(algo::Md5Digest& parent, algo::cstring &lhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(algo::Md5Digest& parent, algo::strptr in_str) __attribute__((nothrow));

// cursor points to valid item
void                 Md5Digest_value_curs_Reset(Md5Digest_value_curs &curs, algo::Md5Digest &parent);
// cursor points to valid item
bool                 Md5Digest_value_curs_ValidQ(Md5Digest_value_curs &curs);
// proceed to next item
void                 Md5Digest_value_curs_Next(Md5Digest_value_curs &curs);
// item access
u8&                  Md5Digest_value_curs_Access(Md5Digest_value_curs &curs);
// Read fields of algo::Md5Digest from an ascii string.
// The format of the string is the format of the algo::Md5Digest's only field
bool                 Md5Digest_ReadStrptrMaybe(algo::Md5Digest &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Md5Digest_Init(algo::Md5Digest& parent);
// print string representation of algo::Md5Digest to string LHS, no header -- cprint:algo.Md5Digest.String
void                 Md5Digest_Print(algo::Md5Digest row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Month
struct Month { // algo.Month
    u32   value;   //   0
    inline operator algo_MonthEnum() const;
    explicit Month(u32                            in_value);
    Month(algo_MonthEnum arg);
    Month();
};

// Get value of field as enum type
algo_MonthEnum       value_GetEnum(const algo::Month& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::Month& parent, algo_MonthEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::Month& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::Month& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::Month& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::Month& parent, algo::strptr rhs, algo_MonthEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(algo::Month& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of algo::Month from an ascii string.
// The format of the string is the format of the algo::Month's only field
bool                 Month_ReadStrptrMaybe(algo::Month &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Month_Init(algo::Month& parent);
// print string representation of algo::Month to string LHS, no header -- cprint:algo.Month.String
void                 Month_Print(algo::Month row, algo::cstring &str) __attribute__((nothrow));

// --- algo.NormTxttbl
struct NormTxttbl { // algo.NormTxttbl
    i32*   start_elems;   // pointer to elements
    u32    start_n;       // number of elements in array
    u32    start_max;     // max. capacity of array before realloc
    i32    maxspan;       //   0
    NormTxttbl();
    ~NormTxttbl();
private:
    // reftype Tary of algo.NormTxttbl.start prohibits copy
    NormTxttbl(const NormTxttbl&){ /*disallow copy constructor */}
    void operator =(const NormTxttbl&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32&                 start_Alloc(algo::NormTxttbl& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32&                 start_AllocAt(algo::NormTxttbl& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    start_AllocN(algo::NormTxttbl& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 start_EmptyQ(algo::NormTxttbl& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
i32*                 start_Find(algo::NormTxttbl& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<i32>    start_Getary(algo::NormTxttbl& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
i32*                 start_Last(algo::NormTxttbl& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  start_Max(algo::NormTxttbl& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  start_N(const algo::NormTxttbl& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 start_Remove(algo::NormTxttbl& parent, u32 i) __attribute__((nothrow));
void                 start_RemoveAll(algo::NormTxttbl& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 start_RemoveLast(algo::NormTxttbl& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 start_Reserve(algo::NormTxttbl& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 start_AbsReserve(algo::NormTxttbl& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 start_Setary(algo::NormTxttbl& parent, algo::NormTxttbl &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
i32&                 start_qFind(algo::NormTxttbl& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
i32&                 start_qLast(algo::NormTxttbl& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  start_rowid_Get(algo::NormTxttbl& parent, i32 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    start_AllocNVal(algo::NormTxttbl& parent, int n_elems, const i32& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 NormTxttbl_start_curs_Next(NormTxttbl_start_curs &curs);
void                 NormTxttbl_start_curs_Reset(NormTxttbl_start_curs &curs, algo::NormTxttbl &parent);
// cursor points to valid item
bool                 NormTxttbl_start_curs_ValidQ(NormTxttbl_start_curs &curs);
// item access
i32&                 NormTxttbl_start_curs_Access(NormTxttbl_start_curs &curs);
// Set all fields to initial values.
void                 NormTxttbl_Init(algo::NormTxttbl& parent);
void                 NormTxttbl_Uninit(algo::NormTxttbl& parent) __attribute__((nothrow));

// --- algo.NumParseFlags
struct NumParseFlags { // algo.NumParseFlags
    u32   value;   //   0
    inline operator algo_NumParseFlagsEnum() const;
    explicit NumParseFlags(u32                            in_value);
    NumParseFlags(algo_NumParseFlagsEnum arg);
    NumParseFlags();
};

// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
bool                 err_Get(const algo::NumParseFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
void                 err_Set(algo::NumParseFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
bool                 ok_Get(const algo::NumParseFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
void                 ok_Set(algo::NumParseFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
bool                 neg_Get(const algo::NumParseFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
void                 neg_Set(algo::NumParseFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
bool                 overflow_Get(const algo::NumParseFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
void                 overflow_Set(algo::NumParseFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
bool                 hex_Get(const algo::NumParseFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
void                 hex_Set(algo::NumParseFlags& parent, bool rhs) __attribute__((nothrow));

bool                 NumParseFlags_ReadFieldMaybe(algo::NumParseFlags &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of algo::NumParseFlags from an ascii string.
bool                 NumParseFlags_ReadStrptrMaybe(algo::NumParseFlags &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 NumParseFlags_Init(algo::NumParseFlags& parent);
// print string representation of algo::NumParseFlags to string LHS, no header -- cprint:algo.NumParseFlags.String
void                 NumParseFlags_Print(algo::NumParseFlags & row, algo::cstring &str) __attribute__((nothrow));
algo::strptr         NumParseFlags_GetAnon(algo::NumParseFlags &parent, i32 idx) __attribute__((nothrow));

// --- algo.Protocol
// access: algo.Protocol.proto (Protocol)
#pragma pack(push,1)
struct Protocol { // algo.Protocol: amc-generated struct for internal purposes
    Protocol();
};
#pragma pack(pop)

void                 StaticCheck();


// --- algo.RnullStr1
#pragma pack(push,1)
struct RnullStr1 { // algo.RnullStr1
    enum { ch_max = 1 };
    u8 ch[1];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr1 &rhs) const;
    bool operator !=(const algo::RnullStr1 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr1 &rhs) const;
    bool operator >(const algo::RnullStr1 &rhs) const;
    bool operator <=(const algo::RnullStr1 &rhs) const;
    bool operator >=(const algo::RnullStr1 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr1& parent) __attribute__((nothrow));
    RnullStr1(const algo::RnullStr1 &rhs) __attribute__((nothrow));
    RnullStr1(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr1();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr1& parent) __attribute__((nothrow));
u32                  RnullStr1_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr1 &parent) __attribute__((nothrow));
// always return constant 1
int                  ch_Max(algo::RnullStr1& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr1& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr1& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr1& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr1& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr1_Hash(u32 prev, algo::RnullStr1 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr1 from an ascii string.
// The format of the string is the format of the algo::RnullStr1's only field
bool                 RnullStr1_ReadStrptrMaybe(algo::RnullStr1 &parent, algo::strptr in_str);
bool                 RnullStr1_Lt(algo::RnullStr1 lhs, algo::RnullStr1 rhs) __attribute__((nothrow));
i32                  RnullStr1_Cmp(algo::RnullStr1 lhs, algo::RnullStr1 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr1_Init(algo::RnullStr1& parent);
bool                 RnullStr1_Eq(algo::RnullStr1 lhs, algo::RnullStr1 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr1_Update(algo::RnullStr1 &lhs, algo::RnullStr1 rhs) __attribute__((nothrow));
bool                 RnullStr1_EqStrptr(algo::RnullStr1 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr1 to string LHS, no header -- cprint:algo.RnullStr1.String
void                 RnullStr1_Print(algo::RnullStr1 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr10
#pragma pack(push,1)
struct RnullStr10 { // algo.RnullStr10
    enum { ch_max = 10 };
    u8 ch[10];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr10 &rhs) const;
    bool operator !=(const algo::RnullStr10 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr10 &rhs) const;
    bool operator >(const algo::RnullStr10 &rhs) const;
    bool operator <=(const algo::RnullStr10 &rhs) const;
    bool operator >=(const algo::RnullStr10 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr10& parent) __attribute__((nothrow));
    RnullStr10(const algo::RnullStr10 &rhs) __attribute__((nothrow));
    RnullStr10(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr10();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr10& parent) __attribute__((nothrow));
u32                  RnullStr10_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr10 &parent) __attribute__((nothrow));
// always return constant 10
int                  ch_Max(algo::RnullStr10& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr10& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr10& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr10& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr10& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr10_Hash(u32 prev, algo::RnullStr10 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr10 from an ascii string.
// The format of the string is the format of the algo::RnullStr10's only field
bool                 RnullStr10_ReadStrptrMaybe(algo::RnullStr10 &parent, algo::strptr in_str);
bool                 RnullStr10_Lt(algo::RnullStr10 lhs, algo::RnullStr10 rhs) __attribute__((nothrow));
i32                  RnullStr10_Cmp(algo::RnullStr10 lhs, algo::RnullStr10 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr10_Init(algo::RnullStr10& parent);
bool                 RnullStr10_Eq(algo::RnullStr10 lhs, algo::RnullStr10 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr10_Update(algo::RnullStr10 &lhs, algo::RnullStr10 rhs) __attribute__((nothrow));
bool                 RnullStr10_EqStrptr(algo::RnullStr10 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr10 to string LHS, no header -- cprint:algo.RnullStr10.String
void                 RnullStr10_Print(algo::RnullStr10 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr100
#pragma pack(push,1)
struct RnullStr100 { // algo.RnullStr100
    enum { ch_max = 100 };
    u8 ch[100];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr100& parent) __attribute__((nothrow));
    RnullStr100(const algo::RnullStr100 &rhs) __attribute__((nothrow));
    RnullStr100(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr100();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr100& parent) __attribute__((nothrow));
u32                  RnullStr100_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr100 &parent) __attribute__((nothrow));
// always return constant 100
int                  ch_Max(algo::RnullStr100& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr100& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr100& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr100& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr100& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr100_Hash(u32 prev, const algo::RnullStr100 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr100 from an ascii string.
// The format of the string is the format of the algo::RnullStr100's only field
bool                 RnullStr100_ReadStrptrMaybe(algo::RnullStr100 &parent, algo::strptr in_str);
bool                 RnullStr100_Lt(algo::RnullStr100 & lhs, algo::RnullStr100 & rhs) __attribute__((nothrow));
i32                  RnullStr100_Cmp(algo::RnullStr100 & lhs, algo::RnullStr100 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr100_Init(algo::RnullStr100& parent);
bool                 RnullStr100_Eq(const algo::RnullStr100 & lhs,const algo::RnullStr100 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr100_Update(algo::RnullStr100 &lhs, algo::RnullStr100 & rhs) __attribute__((nothrow));
bool                 RnullStr100_EqStrptr(algo::RnullStr100 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr100 to string LHS, no header -- cprint:algo.RnullStr100.String
void                 RnullStr100_Print(algo::RnullStr100 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr1000
#pragma pack(push,1)
struct RnullStr1000 { // algo.RnullStr1000
    enum { ch_max = 1000 };
    u8 ch[1000];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr1000 &rhs) const;
    bool operator !=(const algo::RnullStr1000 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr1000 &rhs) const;
    bool operator >(const algo::RnullStr1000 &rhs) const;
    bool operator <=(const algo::RnullStr1000 &rhs) const;
    bool operator >=(const algo::RnullStr1000 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr1000& parent) __attribute__((nothrow));
    RnullStr1000(const algo::RnullStr1000 &rhs) __attribute__((nothrow));
    RnullStr1000(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr1000();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr1000& parent) __attribute__((nothrow));
u32                  RnullStr1000_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr1000 &parent) __attribute__((nothrow));
// always return constant 1000
int                  ch_Max(algo::RnullStr1000& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr1000& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr1000& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr1000& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr1000& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr1000_Hash(u32 prev, const algo::RnullStr1000 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr1000 from an ascii string.
// The format of the string is the format of the algo::RnullStr1000's only field
bool                 RnullStr1000_ReadStrptrMaybe(algo::RnullStr1000 &parent, algo::strptr in_str);
bool                 RnullStr1000_Lt(algo::RnullStr1000 & lhs, algo::RnullStr1000 & rhs) __attribute__((nothrow));
i32                  RnullStr1000_Cmp(algo::RnullStr1000 & lhs, algo::RnullStr1000 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr1000_Init(algo::RnullStr1000& parent);
bool                 RnullStr1000_Eq(const algo::RnullStr1000 & lhs,const algo::RnullStr1000 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr1000_Update(algo::RnullStr1000 &lhs, algo::RnullStr1000 & rhs) __attribute__((nothrow));
bool                 RnullStr1000_EqStrptr(algo::RnullStr1000 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr1000 to string LHS, no header -- cprint:algo.RnullStr1000.String
void                 RnullStr1000_Print(algo::RnullStr1000 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr11
#pragma pack(push,1)
struct RnullStr11 { // algo.RnullStr11
    enum { ch_max = 11 };
    u8 ch[11];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr11 &rhs) const;
    bool operator !=(const algo::RnullStr11 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr11 &rhs) const;
    bool operator >(const algo::RnullStr11 &rhs) const;
    bool operator <=(const algo::RnullStr11 &rhs) const;
    bool operator >=(const algo::RnullStr11 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr11& parent) __attribute__((nothrow));
    RnullStr11(const algo::RnullStr11 &rhs) __attribute__((nothrow));
    RnullStr11(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr11();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr11& parent) __attribute__((nothrow));
u32                  RnullStr11_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr11 &parent) __attribute__((nothrow));
// always return constant 11
int                  ch_Max(algo::RnullStr11& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr11& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr11& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr11& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr11& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr11_Hash(u32 prev, const algo::RnullStr11 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr11 from an ascii string.
// The format of the string is the format of the algo::RnullStr11's only field
bool                 RnullStr11_ReadStrptrMaybe(algo::RnullStr11 &parent, algo::strptr in_str);
bool                 RnullStr11_Lt(algo::RnullStr11 & lhs, algo::RnullStr11 & rhs) __attribute__((nothrow));
i32                  RnullStr11_Cmp(algo::RnullStr11 & lhs, algo::RnullStr11 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr11_Init(algo::RnullStr11& parent);
bool                 RnullStr11_Eq(const algo::RnullStr11 & lhs,const algo::RnullStr11 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr11_Update(algo::RnullStr11 &lhs, algo::RnullStr11 & rhs) __attribute__((nothrow));
bool                 RnullStr11_EqStrptr(algo::RnullStr11 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr11 to string LHS, no header -- cprint:algo.RnullStr11.String
void                 RnullStr11_Print(algo::RnullStr11 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr12
#pragma pack(push,1)
struct RnullStr12 { // algo.RnullStr12
    enum { ch_max = 12 };
    u8 ch[12];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr12 &rhs) const;
    bool operator !=(const algo::RnullStr12 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr12 &rhs) const;
    bool operator >(const algo::RnullStr12 &rhs) const;
    bool operator <=(const algo::RnullStr12 &rhs) const;
    bool operator >=(const algo::RnullStr12 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr12& parent) __attribute__((nothrow));
    RnullStr12(const algo::RnullStr12 &rhs) __attribute__((nothrow));
    RnullStr12(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr12();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr12& parent) __attribute__((nothrow));
u32                  RnullStr12_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr12 &parent) __attribute__((nothrow));
// always return constant 12
int                  ch_Max(algo::RnullStr12& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr12& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr12& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr12& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr12& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr12_Hash(u32 prev, const algo::RnullStr12 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr12 from an ascii string.
// The format of the string is the format of the algo::RnullStr12's only field
bool                 RnullStr12_ReadStrptrMaybe(algo::RnullStr12 &parent, algo::strptr in_str);
bool                 RnullStr12_Lt(algo::RnullStr12 & lhs, algo::RnullStr12 & rhs) __attribute__((nothrow));
i32                  RnullStr12_Cmp(algo::RnullStr12 & lhs, algo::RnullStr12 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr12_Init(algo::RnullStr12& parent);
bool                 RnullStr12_Eq(const algo::RnullStr12 & lhs,const algo::RnullStr12 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr12_Update(algo::RnullStr12 &lhs, algo::RnullStr12 & rhs) __attribute__((nothrow));
bool                 RnullStr12_EqStrptr(algo::RnullStr12 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr12 to string LHS, no header -- cprint:algo.RnullStr12.String
void                 RnullStr12_Print(algo::RnullStr12 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr129
#pragma pack(push,1)
struct RnullStr129 { // algo.RnullStr129
    enum { ch_max = 129 };
    u8 ch[129];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr129 &rhs) const;
    bool operator !=(const algo::RnullStr129 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr129 &rhs) const;
    bool operator >(const algo::RnullStr129 &rhs) const;
    bool operator <=(const algo::RnullStr129 &rhs) const;
    bool operator >=(const algo::RnullStr129 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr129& parent) __attribute__((nothrow));
    RnullStr129(const algo::RnullStr129 &rhs) __attribute__((nothrow));
    RnullStr129(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr129();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr129& parent) __attribute__((nothrow));
u32                  RnullStr129_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr129 &parent) __attribute__((nothrow));
// always return constant 129
int                  ch_Max(algo::RnullStr129& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr129& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr129& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr129& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr129& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr129_Hash(u32 prev, const algo::RnullStr129 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr129 from an ascii string.
// The format of the string is the format of the algo::RnullStr129's only field
bool                 RnullStr129_ReadStrptrMaybe(algo::RnullStr129 &parent, algo::strptr in_str);
bool                 RnullStr129_Lt(algo::RnullStr129 & lhs, algo::RnullStr129 & rhs) __attribute__((nothrow));
i32                  RnullStr129_Cmp(algo::RnullStr129 & lhs, algo::RnullStr129 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr129_Init(algo::RnullStr129& parent);
bool                 RnullStr129_Eq(const algo::RnullStr129 & lhs,const algo::RnullStr129 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr129_Update(algo::RnullStr129 &lhs, algo::RnullStr129 & rhs) __attribute__((nothrow));
bool                 RnullStr129_EqStrptr(algo::RnullStr129 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr129 to string LHS, no header -- cprint:algo.RnullStr129.String
void                 RnullStr129_Print(algo::RnullStr129 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr13
#pragma pack(push,1)
struct RnullStr13 { // algo.RnullStr13
    enum { ch_max = 13 };
    u8 ch[13];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr13 &rhs) const;
    bool operator !=(const algo::RnullStr13 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr13 &rhs) const;
    bool operator >(const algo::RnullStr13 &rhs) const;
    bool operator <=(const algo::RnullStr13 &rhs) const;
    bool operator >=(const algo::RnullStr13 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr13& parent) __attribute__((nothrow));
    RnullStr13(const algo::RnullStr13 &rhs) __attribute__((nothrow));
    RnullStr13(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr13();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr13& parent) __attribute__((nothrow));
u32                  RnullStr13_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr13 &parent) __attribute__((nothrow));
// always return constant 13
int                  ch_Max(algo::RnullStr13& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr13& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr13& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr13& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr13& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr13_Hash(u32 prev, const algo::RnullStr13 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr13 from an ascii string.
// The format of the string is the format of the algo::RnullStr13's only field
bool                 RnullStr13_ReadStrptrMaybe(algo::RnullStr13 &parent, algo::strptr in_str);
bool                 RnullStr13_Lt(algo::RnullStr13 & lhs, algo::RnullStr13 & rhs) __attribute__((nothrow));
i32                  RnullStr13_Cmp(algo::RnullStr13 & lhs, algo::RnullStr13 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr13_Init(algo::RnullStr13& parent);
bool                 RnullStr13_Eq(const algo::RnullStr13 & lhs,const algo::RnullStr13 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr13_Update(algo::RnullStr13 &lhs, algo::RnullStr13 & rhs) __attribute__((nothrow));
bool                 RnullStr13_EqStrptr(algo::RnullStr13 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr13 to string LHS, no header -- cprint:algo.RnullStr13.String
void                 RnullStr13_Print(algo::RnullStr13 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr14
#pragma pack(push,1)
struct RnullStr14 { // algo.RnullStr14
    enum { ch_max = 14 };
    u8 ch[14];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr14 &rhs) const;
    bool operator !=(const algo::RnullStr14 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr14 &rhs) const;
    bool operator >(const algo::RnullStr14 &rhs) const;
    bool operator <=(const algo::RnullStr14 &rhs) const;
    bool operator >=(const algo::RnullStr14 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr14& parent) __attribute__((nothrow));
    RnullStr14(const algo::RnullStr14 &rhs) __attribute__((nothrow));
    RnullStr14(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr14();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr14& parent) __attribute__((nothrow));
u32                  RnullStr14_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr14 &parent) __attribute__((nothrow));
// always return constant 14
int                  ch_Max(algo::RnullStr14& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr14& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr14& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr14& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr14& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr14_Hash(u32 prev, const algo::RnullStr14 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr14 from an ascii string.
// The format of the string is the format of the algo::RnullStr14's only field
bool                 RnullStr14_ReadStrptrMaybe(algo::RnullStr14 &parent, algo::strptr in_str);
bool                 RnullStr14_Lt(algo::RnullStr14 & lhs, algo::RnullStr14 & rhs) __attribute__((nothrow));
i32                  RnullStr14_Cmp(algo::RnullStr14 & lhs, algo::RnullStr14 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr14_Init(algo::RnullStr14& parent);
bool                 RnullStr14_Eq(const algo::RnullStr14 & lhs,const algo::RnullStr14 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr14_Update(algo::RnullStr14 &lhs, algo::RnullStr14 & rhs) __attribute__((nothrow));
bool                 RnullStr14_EqStrptr(algo::RnullStr14 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr14 to string LHS, no header -- cprint:algo.RnullStr14.String
void                 RnullStr14_Print(algo::RnullStr14 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr15
#pragma pack(push,1)
struct RnullStr15 { // algo.RnullStr15
    enum { ch_max = 15 };
    u8 ch[15];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr15 &rhs) const;
    bool operator !=(const algo::RnullStr15 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr15 &rhs) const;
    bool operator >(const algo::RnullStr15 &rhs) const;
    bool operator <=(const algo::RnullStr15 &rhs) const;
    bool operator >=(const algo::RnullStr15 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr15& parent) __attribute__((nothrow));
    RnullStr15(const algo::RnullStr15 &rhs) __attribute__((nothrow));
    RnullStr15(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr15();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr15& parent) __attribute__((nothrow));
u32                  RnullStr15_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr15 &parent) __attribute__((nothrow));
// always return constant 15
int                  ch_Max(algo::RnullStr15& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr15& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr15& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr15& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr15& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr15_Hash(u32 prev, const algo::RnullStr15 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr15 from an ascii string.
// The format of the string is the format of the algo::RnullStr15's only field
bool                 RnullStr15_ReadStrptrMaybe(algo::RnullStr15 &parent, algo::strptr in_str);
bool                 RnullStr15_Lt(algo::RnullStr15 & lhs, algo::RnullStr15 & rhs) __attribute__((nothrow));
i32                  RnullStr15_Cmp(algo::RnullStr15 & lhs, algo::RnullStr15 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr15_Init(algo::RnullStr15& parent);
bool                 RnullStr15_Eq(const algo::RnullStr15 & lhs,const algo::RnullStr15 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr15_Update(algo::RnullStr15 &lhs, algo::RnullStr15 & rhs) __attribute__((nothrow));
bool                 RnullStr15_EqStrptr(algo::RnullStr15 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr15 to string LHS, no header -- cprint:algo.RnullStr15.String
void                 RnullStr15_Print(algo::RnullStr15 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr151
#pragma pack(push,1)
struct RnullStr151 { // algo.RnullStr151
    enum { ch_max = 151 };
    u8 ch[151];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr151 &rhs) const;
    bool operator !=(const algo::RnullStr151 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr151 &rhs) const;
    bool operator >(const algo::RnullStr151 &rhs) const;
    bool operator <=(const algo::RnullStr151 &rhs) const;
    bool operator >=(const algo::RnullStr151 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr151& parent) __attribute__((nothrow));
    RnullStr151(const algo::RnullStr151 &rhs) __attribute__((nothrow));
    RnullStr151(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr151();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr151& parent) __attribute__((nothrow));
u32                  RnullStr151_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr151 &parent) __attribute__((nothrow));
// always return constant 151
int                  ch_Max(algo::RnullStr151& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr151& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr151& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr151& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr151& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr151_Hash(u32 prev, const algo::RnullStr151 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr151 from an ascii string.
// The format of the string is the format of the algo::RnullStr151's only field
bool                 RnullStr151_ReadStrptrMaybe(algo::RnullStr151 &parent, algo::strptr in_str);
bool                 RnullStr151_Lt(algo::RnullStr151 & lhs, algo::RnullStr151 & rhs) __attribute__((nothrow));
i32                  RnullStr151_Cmp(algo::RnullStr151 & lhs, algo::RnullStr151 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr151_Init(algo::RnullStr151& parent);
bool                 RnullStr151_Eq(const algo::RnullStr151 & lhs,const algo::RnullStr151 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr151_Update(algo::RnullStr151 &lhs, algo::RnullStr151 & rhs) __attribute__((nothrow));
bool                 RnullStr151_EqStrptr(algo::RnullStr151 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr151 to string LHS, no header -- cprint:algo.RnullStr151.String
void                 RnullStr151_Print(algo::RnullStr151 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr16
#pragma pack(push,1)
struct RnullStr16 { // algo.RnullStr16
    enum { ch_max = 16 };
    u8 ch[16];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr16& parent) __attribute__((nothrow));
    RnullStr16(const algo::RnullStr16 &rhs) __attribute__((nothrow));
    RnullStr16(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr16();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr16& parent) __attribute__((nothrow));
u32                  RnullStr16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr16 &parent) __attribute__((nothrow));
// always return constant 16
int                  ch_Max(algo::RnullStr16& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr16& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr16_Hash(u32 prev, algo::RnullStr16 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr16 from an ascii string.
// The format of the string is the format of the algo::RnullStr16's only field
bool                 RnullStr16_ReadStrptrMaybe(algo::RnullStr16 &parent, algo::strptr in_str);
bool                 RnullStr16_Lt(algo::RnullStr16 lhs, algo::RnullStr16 rhs) __attribute__((nothrow));
i32                  RnullStr16_Cmp(algo::RnullStr16 lhs, algo::RnullStr16 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr16_Init(algo::RnullStr16& parent);
bool                 RnullStr16_Eq(algo::RnullStr16 lhs, algo::RnullStr16 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr16_Update(algo::RnullStr16 &lhs, algo::RnullStr16 rhs) __attribute__((nothrow));
bool                 RnullStr16_EqStrptr(algo::RnullStr16 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr16 to string LHS, no header -- cprint:algo.RnullStr16.String
void                 RnullStr16_Print(algo::RnullStr16 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr17
#pragma pack(push,1)
struct RnullStr17 { // algo.RnullStr17
    enum { ch_max = 17 };
    u8 ch[17];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr17 &rhs) const;
    bool operator !=(const algo::RnullStr17 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr17 &rhs) const;
    bool operator >(const algo::RnullStr17 &rhs) const;
    bool operator <=(const algo::RnullStr17 &rhs) const;
    bool operator >=(const algo::RnullStr17 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr17& parent) __attribute__((nothrow));
    RnullStr17(const algo::RnullStr17 &rhs) __attribute__((nothrow));
    RnullStr17(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr17();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr17& parent) __attribute__((nothrow));
u32                  RnullStr17_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr17 &parent) __attribute__((nothrow));
// always return constant 17
int                  ch_Max(algo::RnullStr17& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr17& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr17& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr17& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr17& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr17_Hash(u32 prev, const algo::RnullStr17 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr17 from an ascii string.
// The format of the string is the format of the algo::RnullStr17's only field
bool                 RnullStr17_ReadStrptrMaybe(algo::RnullStr17 &parent, algo::strptr in_str);
bool                 RnullStr17_Lt(algo::RnullStr17 & lhs, algo::RnullStr17 & rhs) __attribute__((nothrow));
i32                  RnullStr17_Cmp(algo::RnullStr17 & lhs, algo::RnullStr17 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr17_Init(algo::RnullStr17& parent);
bool                 RnullStr17_Eq(const algo::RnullStr17 & lhs,const algo::RnullStr17 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr17_Update(algo::RnullStr17 &lhs, algo::RnullStr17 & rhs) __attribute__((nothrow));
bool                 RnullStr17_EqStrptr(algo::RnullStr17 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr17 to string LHS, no header -- cprint:algo.RnullStr17.String
void                 RnullStr17_Print(algo::RnullStr17 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr18
#pragma pack(push,1)
struct RnullStr18 { // algo.RnullStr18
    enum { ch_max = 18 };
    u8 ch[18];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr18 &rhs) const;
    bool operator !=(const algo::RnullStr18 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr18 &rhs) const;
    bool operator >(const algo::RnullStr18 &rhs) const;
    bool operator <=(const algo::RnullStr18 &rhs) const;
    bool operator >=(const algo::RnullStr18 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr18& parent) __attribute__((nothrow));
    RnullStr18(const algo::RnullStr18 &rhs) __attribute__((nothrow));
    RnullStr18(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr18();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr18& parent) __attribute__((nothrow));
u32                  RnullStr18_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr18 &parent) __attribute__((nothrow));
// always return constant 18
int                  ch_Max(algo::RnullStr18& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr18& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr18& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr18& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr18& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr18_Hash(u32 prev, algo::RnullStr18 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr18 from an ascii string.
// The format of the string is the format of the algo::RnullStr18's only field
bool                 RnullStr18_ReadStrptrMaybe(algo::RnullStr18 &parent, algo::strptr in_str);
bool                 RnullStr18_Lt(algo::RnullStr18 lhs, algo::RnullStr18 rhs) __attribute__((nothrow));
i32                  RnullStr18_Cmp(algo::RnullStr18 lhs, algo::RnullStr18 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr18_Init(algo::RnullStr18& parent);
bool                 RnullStr18_Eq(algo::RnullStr18 lhs, algo::RnullStr18 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr18_Update(algo::RnullStr18 &lhs, algo::RnullStr18 rhs) __attribute__((nothrow));
bool                 RnullStr18_EqStrptr(algo::RnullStr18 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr18 to string LHS, no header -- cprint:algo.RnullStr18.String
void                 RnullStr18_Print(algo::RnullStr18 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr19
#pragma pack(push,1)
struct RnullStr19 { // algo.RnullStr19
    enum { ch_max = 19 };
    u8 ch[19];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr19& parent) __attribute__((nothrow));
    RnullStr19(const algo::RnullStr19 &rhs) __attribute__((nothrow));
    RnullStr19(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr19();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr19& parent) __attribute__((nothrow));
u32                  RnullStr19_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr19 &parent) __attribute__((nothrow));
// always return constant 19
int                  ch_Max(algo::RnullStr19& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr19& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr19& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr19& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr19& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr19_Hash(u32 prev, const algo::RnullStr19 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr19 from an ascii string.
// The format of the string is the format of the algo::RnullStr19's only field
bool                 RnullStr19_ReadStrptrMaybe(algo::RnullStr19 &parent, algo::strptr in_str);
bool                 RnullStr19_Lt(algo::RnullStr19 & lhs, algo::RnullStr19 & rhs) __attribute__((nothrow));
i32                  RnullStr19_Cmp(algo::RnullStr19 & lhs, algo::RnullStr19 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr19_Init(algo::RnullStr19& parent);
bool                 RnullStr19_Eq(const algo::RnullStr19 & lhs,const algo::RnullStr19 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr19_Update(algo::RnullStr19 &lhs, algo::RnullStr19 & rhs) __attribute__((nothrow));
bool                 RnullStr19_EqStrptr(algo::RnullStr19 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr19 to string LHS, no header -- cprint:algo.RnullStr19.String
void                 RnullStr19_Print(algo::RnullStr19 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr2
#pragma pack(push,1)
struct RnullStr2 { // algo.RnullStr2
    enum { ch_max = 2 };
    u8 ch[2];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr2 &rhs) const;
    bool operator !=(const algo::RnullStr2 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr2 &rhs) const;
    bool operator >(const algo::RnullStr2 &rhs) const;
    bool operator <=(const algo::RnullStr2 &rhs) const;
    bool operator >=(const algo::RnullStr2 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr2& parent) __attribute__((nothrow));
    RnullStr2(const algo::RnullStr2 &rhs) __attribute__((nothrow));
    RnullStr2(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr2();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr2& parent) __attribute__((nothrow));
u32                  RnullStr2_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr2 &parent) __attribute__((nothrow));
// always return constant 2
int                  ch_Max(algo::RnullStr2& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr2& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr2& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr2& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr2& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr2_Hash(u32 prev, algo::RnullStr2 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr2 from an ascii string.
// The format of the string is the format of the algo::RnullStr2's only field
bool                 RnullStr2_ReadStrptrMaybe(algo::RnullStr2 &parent, algo::strptr in_str);
bool                 RnullStr2_Lt(algo::RnullStr2 lhs, algo::RnullStr2 rhs) __attribute__((nothrow));
i32                  RnullStr2_Cmp(algo::RnullStr2 lhs, algo::RnullStr2 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr2_Init(algo::RnullStr2& parent);
bool                 RnullStr2_Eq(algo::RnullStr2 lhs, algo::RnullStr2 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr2_Update(algo::RnullStr2 &lhs, algo::RnullStr2 rhs) __attribute__((nothrow));
bool                 RnullStr2_EqStrptr(algo::RnullStr2 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr2 to string LHS, no header -- cprint:algo.RnullStr2.String
void                 RnullStr2_Print(algo::RnullStr2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr20
#pragma pack(push,1)
struct RnullStr20 { // algo.RnullStr20
    enum { ch_max = 20 };
    u8 ch[20];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr20 &rhs) const;
    bool operator !=(const algo::RnullStr20 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr20 &rhs) const;
    bool operator >(const algo::RnullStr20 &rhs) const;
    bool operator <=(const algo::RnullStr20 &rhs) const;
    bool operator >=(const algo::RnullStr20 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr20& parent) __attribute__((nothrow));
    RnullStr20(const algo::RnullStr20 &rhs) __attribute__((nothrow));
    RnullStr20(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr20();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr20& parent) __attribute__((nothrow));
u32                  RnullStr20_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr20 &parent) __attribute__((nothrow));
// always return constant 20
int                  ch_Max(algo::RnullStr20& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr20& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr20& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr20& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr20& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr20_Hash(u32 prev, algo::RnullStr20 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr20 from an ascii string.
// The format of the string is the format of the algo::RnullStr20's only field
bool                 RnullStr20_ReadStrptrMaybe(algo::RnullStr20 &parent, algo::strptr in_str);
bool                 RnullStr20_Lt(algo::RnullStr20 lhs, algo::RnullStr20 rhs) __attribute__((nothrow));
i32                  RnullStr20_Cmp(algo::RnullStr20 lhs, algo::RnullStr20 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr20_Init(algo::RnullStr20& parent);
bool                 RnullStr20_Eq(algo::RnullStr20 lhs, algo::RnullStr20 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr20_Update(algo::RnullStr20 &lhs, algo::RnullStr20 rhs) __attribute__((nothrow));
bool                 RnullStr20_EqStrptr(algo::RnullStr20 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr20 to string LHS, no header -- cprint:algo.RnullStr20.String
void                 RnullStr20_Print(algo::RnullStr20 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr21
#pragma pack(push,1)
struct RnullStr21 { // algo.RnullStr21
    enum { ch_max = 21 };
    u8 ch[21];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr21& parent) __attribute__((nothrow));
    RnullStr21(const algo::RnullStr21 &rhs) __attribute__((nothrow));
    RnullStr21(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr21();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr21& parent) __attribute__((nothrow));
u32                  RnullStr21_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr21 &parent) __attribute__((nothrow));
// always return constant 21
int                  ch_Max(algo::RnullStr21& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr21& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr21& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr21& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr21& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr21_Hash(u32 prev, const algo::RnullStr21 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr21 from an ascii string.
// The format of the string is the format of the algo::RnullStr21's only field
bool                 RnullStr21_ReadStrptrMaybe(algo::RnullStr21 &parent, algo::strptr in_str);
bool                 RnullStr21_Lt(algo::RnullStr21 & lhs, algo::RnullStr21 & rhs) __attribute__((nothrow));
i32                  RnullStr21_Cmp(algo::RnullStr21 & lhs, algo::RnullStr21 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr21_Init(algo::RnullStr21& parent);
bool                 RnullStr21_Eq(const algo::RnullStr21 & lhs,const algo::RnullStr21 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr21_Update(algo::RnullStr21 &lhs, algo::RnullStr21 & rhs) __attribute__((nothrow));
bool                 RnullStr21_EqStrptr(algo::RnullStr21 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr21 to string LHS, no header -- cprint:algo.RnullStr21.String
void                 RnullStr21_Print(algo::RnullStr21 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr24
#pragma pack(push,1)
struct RnullStr24 { // algo.RnullStr24
    enum { ch_max = 24 };
    u8 ch[24];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr24 &rhs) const;
    bool operator !=(const algo::RnullStr24 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr24 &rhs) const;
    bool operator >(const algo::RnullStr24 &rhs) const;
    bool operator <=(const algo::RnullStr24 &rhs) const;
    bool operator >=(const algo::RnullStr24 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr24& parent) __attribute__((nothrow));
    RnullStr24(const algo::RnullStr24 &rhs) __attribute__((nothrow));
    RnullStr24(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr24();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr24& parent) __attribute__((nothrow));
u32                  RnullStr24_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr24 &parent) __attribute__((nothrow));
// always return constant 24
int                  ch_Max(algo::RnullStr24& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr24& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr24& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr24& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr24& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr24_Hash(u32 prev, const algo::RnullStr24 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr24 from an ascii string.
// The format of the string is the format of the algo::RnullStr24's only field
bool                 RnullStr24_ReadStrptrMaybe(algo::RnullStr24 &parent, algo::strptr in_str);
bool                 RnullStr24_Lt(algo::RnullStr24 & lhs, algo::RnullStr24 & rhs) __attribute__((nothrow));
i32                  RnullStr24_Cmp(algo::RnullStr24 & lhs, algo::RnullStr24 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr24_Init(algo::RnullStr24& parent);
bool                 RnullStr24_Eq(const algo::RnullStr24 & lhs,const algo::RnullStr24 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr24_Update(algo::RnullStr24 &lhs, algo::RnullStr24 & rhs) __attribute__((nothrow));
bool                 RnullStr24_EqStrptr(algo::RnullStr24 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr24 to string LHS, no header -- cprint:algo.RnullStr24.String
void                 RnullStr24_Print(algo::RnullStr24 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr25
#pragma pack(push,1)
struct RnullStr25 { // algo.RnullStr25
    enum { ch_max = 25 };
    u8 ch[25];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr25 &rhs) const;
    bool operator !=(const algo::RnullStr25 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr25 &rhs) const;
    bool operator >(const algo::RnullStr25 &rhs) const;
    bool operator <=(const algo::RnullStr25 &rhs) const;
    bool operator >=(const algo::RnullStr25 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr25& parent) __attribute__((nothrow));
    RnullStr25(const algo::RnullStr25 &rhs) __attribute__((nothrow));
    RnullStr25(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr25();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr25& parent) __attribute__((nothrow));
u32                  RnullStr25_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr25 &parent) __attribute__((nothrow));
// always return constant 25
int                  ch_Max(algo::RnullStr25& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr25& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr25& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr25& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr25& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr25_Hash(u32 prev, const algo::RnullStr25 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr25 from an ascii string.
// The format of the string is the format of the algo::RnullStr25's only field
bool                 RnullStr25_ReadStrptrMaybe(algo::RnullStr25 &parent, algo::strptr in_str);
bool                 RnullStr25_Lt(algo::RnullStr25 & lhs, algo::RnullStr25 & rhs) __attribute__((nothrow));
i32                  RnullStr25_Cmp(algo::RnullStr25 & lhs, algo::RnullStr25 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr25_Init(algo::RnullStr25& parent);
bool                 RnullStr25_Eq(const algo::RnullStr25 & lhs,const algo::RnullStr25 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr25_Update(algo::RnullStr25 &lhs, algo::RnullStr25 & rhs) __attribute__((nothrow));
bool                 RnullStr25_EqStrptr(algo::RnullStr25 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr25 to string LHS, no header -- cprint:algo.RnullStr25.String
void                 RnullStr25_Print(algo::RnullStr25 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr28
#pragma pack(push,1)
struct RnullStr28 { // algo.RnullStr28
    enum { ch_max = 28 };
    u8 ch[28];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr28 &rhs) const;
    bool operator !=(const algo::RnullStr28 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr28 &rhs) const;
    bool operator >(const algo::RnullStr28 &rhs) const;
    bool operator <=(const algo::RnullStr28 &rhs) const;
    bool operator >=(const algo::RnullStr28 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr28& parent) __attribute__((nothrow));
    RnullStr28(const algo::RnullStr28 &rhs) __attribute__((nothrow));
    RnullStr28(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr28();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr28& parent) __attribute__((nothrow));
u32                  RnullStr28_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr28 &parent) __attribute__((nothrow));
// always return constant 28
int                  ch_Max(algo::RnullStr28& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr28& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr28& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr28& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr28& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr28_Hash(u32 prev, const algo::RnullStr28 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr28 from an ascii string.
// The format of the string is the format of the algo::RnullStr28's only field
bool                 RnullStr28_ReadStrptrMaybe(algo::RnullStr28 &parent, algo::strptr in_str);
bool                 RnullStr28_Lt(algo::RnullStr28 & lhs, algo::RnullStr28 & rhs) __attribute__((nothrow));
i32                  RnullStr28_Cmp(algo::RnullStr28 & lhs, algo::RnullStr28 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr28_Init(algo::RnullStr28& parent);
bool                 RnullStr28_Eq(const algo::RnullStr28 & lhs,const algo::RnullStr28 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr28_Update(algo::RnullStr28 &lhs, algo::RnullStr28 & rhs) __attribute__((nothrow));
bool                 RnullStr28_EqStrptr(algo::RnullStr28 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr28 to string LHS, no header -- cprint:algo.RnullStr28.String
void                 RnullStr28_Print(algo::RnullStr28 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr3
#pragma pack(push,1)
struct RnullStr3 { // algo.RnullStr3
    enum { ch_max = 3 };
    u8 ch[3];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr3 &rhs) const;
    bool operator !=(const algo::RnullStr3 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr3 &rhs) const;
    bool operator >(const algo::RnullStr3 &rhs) const;
    bool operator <=(const algo::RnullStr3 &rhs) const;
    bool operator >=(const algo::RnullStr3 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr3& parent) __attribute__((nothrow));
    RnullStr3(const algo::RnullStr3 &rhs) __attribute__((nothrow));
    RnullStr3(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr3();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr3& parent) __attribute__((nothrow));
u32                  RnullStr3_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr3 &parent) __attribute__((nothrow));
// always return constant 3
int                  ch_Max(algo::RnullStr3& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr3& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr3& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr3& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr3& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr3_Hash(u32 prev, algo::RnullStr3 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr3 from an ascii string.
// The format of the string is the format of the algo::RnullStr3's only field
bool                 RnullStr3_ReadStrptrMaybe(algo::RnullStr3 &parent, algo::strptr in_str);
bool                 RnullStr3_Lt(algo::RnullStr3 lhs, algo::RnullStr3 rhs) __attribute__((nothrow));
i32                  RnullStr3_Cmp(algo::RnullStr3 lhs, algo::RnullStr3 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr3_Init(algo::RnullStr3& parent);
bool                 RnullStr3_Eq(algo::RnullStr3 lhs, algo::RnullStr3 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr3_Update(algo::RnullStr3 &lhs, algo::RnullStr3 rhs) __attribute__((nothrow));
bool                 RnullStr3_EqStrptr(algo::RnullStr3 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr3 to string LHS, no header -- cprint:algo.RnullStr3.String
void                 RnullStr3_Print(algo::RnullStr3 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr30
#pragma pack(push,1)
struct RnullStr30 { // algo.RnullStr30
    enum { ch_max = 30 };
    u8 ch[30];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr30& parent) __attribute__((nothrow));
    RnullStr30(const algo::RnullStr30 &rhs) __attribute__((nothrow));
    RnullStr30(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr30();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr30& parent) __attribute__((nothrow));
u32                  RnullStr30_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr30 &parent) __attribute__((nothrow));
// always return constant 30
int                  ch_Max(algo::RnullStr30& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr30& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr30& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr30& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr30& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr30_Hash(u32 prev, algo::RnullStr30 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr30 from an ascii string.
// The format of the string is the format of the algo::RnullStr30's only field
bool                 RnullStr30_ReadStrptrMaybe(algo::RnullStr30 &parent, algo::strptr in_str);
bool                 RnullStr30_Lt(algo::RnullStr30 lhs, algo::RnullStr30 rhs) __attribute__((nothrow));
i32                  RnullStr30_Cmp(algo::RnullStr30 lhs, algo::RnullStr30 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr30_Init(algo::RnullStr30& parent);
bool                 RnullStr30_Eq(algo::RnullStr30 lhs, algo::RnullStr30 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr30_Update(algo::RnullStr30 &lhs, algo::RnullStr30 rhs) __attribute__((nothrow));
bool                 RnullStr30_EqStrptr(algo::RnullStr30 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr30 to string LHS, no header -- cprint:algo.RnullStr30.String
void                 RnullStr30_Print(algo::RnullStr30 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr32
#pragma pack(push,1)
struct RnullStr32 { // algo.RnullStr32
    enum { ch_max = 32 };
    u8 ch[32];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr32 &rhs) const;
    bool operator !=(const algo::RnullStr32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr32 &rhs) const;
    bool operator >(const algo::RnullStr32 &rhs) const;
    bool operator <=(const algo::RnullStr32 &rhs) const;
    bool operator >=(const algo::RnullStr32 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr32& parent) __attribute__((nothrow));
    RnullStr32(const algo::RnullStr32 &rhs) __attribute__((nothrow));
    RnullStr32(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr32& parent) __attribute__((nothrow));
u32                  RnullStr32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr32 &parent) __attribute__((nothrow));
// always return constant 32
int                  ch_Max(algo::RnullStr32& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr32& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr32_Hash(u32 prev, algo::RnullStr32 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr32 from an ascii string.
// The format of the string is the format of the algo::RnullStr32's only field
bool                 RnullStr32_ReadStrptrMaybe(algo::RnullStr32 &parent, algo::strptr in_str);
bool                 RnullStr32_Lt(algo::RnullStr32 lhs, algo::RnullStr32 rhs) __attribute__((nothrow));
i32                  RnullStr32_Cmp(algo::RnullStr32 lhs, algo::RnullStr32 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr32_Init(algo::RnullStr32& parent);
bool                 RnullStr32_Eq(algo::RnullStr32 lhs, algo::RnullStr32 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr32_Update(algo::RnullStr32 &lhs, algo::RnullStr32 rhs) __attribute__((nothrow));
bool                 RnullStr32_EqStrptr(algo::RnullStr32 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr32 to string LHS, no header -- cprint:algo.RnullStr32.String
void                 RnullStr32_Print(algo::RnullStr32 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr33
#pragma pack(push,1)
struct RnullStr33 { // algo.RnullStr33
    enum { ch_max = 33 };
    u8 ch[33];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr33 &rhs) const;
    bool operator !=(const algo::RnullStr33 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr33 &rhs) const;
    bool operator >(const algo::RnullStr33 &rhs) const;
    bool operator <=(const algo::RnullStr33 &rhs) const;
    bool operator >=(const algo::RnullStr33 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr33& parent) __attribute__((nothrow));
    RnullStr33(const algo::RnullStr33 &rhs) __attribute__((nothrow));
    RnullStr33(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr33();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr33& parent) __attribute__((nothrow));
u32                  RnullStr33_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr33 &parent) __attribute__((nothrow));
// always return constant 33
int                  ch_Max(algo::RnullStr33& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr33& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr33& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr33& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr33& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr33_Hash(u32 prev, const algo::RnullStr33 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr33 from an ascii string.
// The format of the string is the format of the algo::RnullStr33's only field
bool                 RnullStr33_ReadStrptrMaybe(algo::RnullStr33 &parent, algo::strptr in_str);
bool                 RnullStr33_Lt(algo::RnullStr33 & lhs, algo::RnullStr33 & rhs) __attribute__((nothrow));
i32                  RnullStr33_Cmp(algo::RnullStr33 & lhs, algo::RnullStr33 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr33_Init(algo::RnullStr33& parent);
bool                 RnullStr33_Eq(const algo::RnullStr33 & lhs,const algo::RnullStr33 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr33_Update(algo::RnullStr33 &lhs, algo::RnullStr33 & rhs) __attribute__((nothrow));
bool                 RnullStr33_EqStrptr(algo::RnullStr33 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr33 to string LHS, no header -- cprint:algo.RnullStr33.String
void                 RnullStr33_Print(algo::RnullStr33 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr35
struct RnullStr35 { // algo.RnullStr35
    enum { ch_max = 35 };
    u8 ch[35];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr35 &rhs) const;
    bool operator !=(const algo::RnullStr35 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr35 &rhs) const;
    bool operator >(const algo::RnullStr35 &rhs) const;
    bool operator <=(const algo::RnullStr35 &rhs) const;
    bool operator >=(const algo::RnullStr35 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr35& parent) __attribute__((nothrow));
    RnullStr35(const algo::RnullStr35 &rhs) __attribute__((nothrow));
    RnullStr35(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr35();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr35& parent) __attribute__((nothrow));
u32                  RnullStr35_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr35 &parent) __attribute__((nothrow));
// always return constant 35
int                  ch_Max(algo::RnullStr35& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr35& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr35& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr35& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr35& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr35_Hash(u32 prev, const algo::RnullStr35 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr35 from an ascii string.
// The format of the string is the format of the algo::RnullStr35's only field
bool                 RnullStr35_ReadStrptrMaybe(algo::RnullStr35 &parent, algo::strptr in_str);
bool                 RnullStr35_Lt(algo::RnullStr35 & lhs, algo::RnullStr35 & rhs) __attribute__((nothrow));
i32                  RnullStr35_Cmp(algo::RnullStr35 & lhs, algo::RnullStr35 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr35_Init(algo::RnullStr35& parent);
bool                 RnullStr35_Eq(const algo::RnullStr35 & lhs,const algo::RnullStr35 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr35_Update(algo::RnullStr35 &lhs, algo::RnullStr35 & rhs) __attribute__((nothrow));
bool                 RnullStr35_EqStrptr(algo::RnullStr35 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr35 to string LHS, no header -- cprint:algo.RnullStr35.String
void                 RnullStr35_Print(algo::RnullStr35 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr36
#pragma pack(push,1)
struct RnullStr36 { // algo.RnullStr36
    enum { ch_max = 36 };
    u8 ch[36];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr36 &rhs) const;
    bool operator !=(const algo::RnullStr36 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr36 &rhs) const;
    bool operator >(const algo::RnullStr36 &rhs) const;
    bool operator <=(const algo::RnullStr36 &rhs) const;
    bool operator >=(const algo::RnullStr36 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr36& parent) __attribute__((nothrow));
    RnullStr36(const algo::RnullStr36 &rhs) __attribute__((nothrow));
    RnullStr36(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr36();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr36& parent) __attribute__((nothrow));
u32                  RnullStr36_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr36 &parent) __attribute__((nothrow));
// always return constant 36
int                  ch_Max(algo::RnullStr36& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr36& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr36& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr36& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr36& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr36_Hash(u32 prev, const algo::RnullStr36 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr36 from an ascii string.
// The format of the string is the format of the algo::RnullStr36's only field
bool                 RnullStr36_ReadStrptrMaybe(algo::RnullStr36 &parent, algo::strptr in_str);
bool                 RnullStr36_Lt(algo::RnullStr36 & lhs, algo::RnullStr36 & rhs) __attribute__((nothrow));
i32                  RnullStr36_Cmp(algo::RnullStr36 & lhs, algo::RnullStr36 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr36_Init(algo::RnullStr36& parent);
bool                 RnullStr36_Eq(const algo::RnullStr36 & lhs,const algo::RnullStr36 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr36_Update(algo::RnullStr36 &lhs, algo::RnullStr36 & rhs) __attribute__((nothrow));
bool                 RnullStr36_EqStrptr(algo::RnullStr36 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr36 to string LHS, no header -- cprint:algo.RnullStr36.String
void                 RnullStr36_Print(algo::RnullStr36 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr4
#pragma pack(push,1)
struct RnullStr4 { // algo.RnullStr4
    enum { ch_max = 4 };
    u8 ch[4];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr4& parent) __attribute__((nothrow));
    RnullStr4(const algo::RnullStr4 &rhs) __attribute__((nothrow));
    RnullStr4(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr4();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr4& parent) __attribute__((nothrow));
u32                  RnullStr4_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr4 &parent) __attribute__((nothrow));
// always return constant 4
int                  ch_Max(algo::RnullStr4& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr4& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr4& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr4& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr4& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr4_Hash(u32 prev, algo::RnullStr4 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr4 from an ascii string.
// The format of the string is the format of the algo::RnullStr4's only field
bool                 RnullStr4_ReadStrptrMaybe(algo::RnullStr4 &parent, algo::strptr in_str);
bool                 RnullStr4_Lt(algo::RnullStr4 lhs, algo::RnullStr4 rhs) __attribute__((nothrow));
i32                  RnullStr4_Cmp(algo::RnullStr4 lhs, algo::RnullStr4 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr4_Init(algo::RnullStr4& parent);
bool                 RnullStr4_Eq(algo::RnullStr4 lhs, algo::RnullStr4 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr4_Update(algo::RnullStr4 &lhs, algo::RnullStr4 rhs) __attribute__((nothrow));
bool                 RnullStr4_EqStrptr(algo::RnullStr4 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr4 to string LHS, no header -- cprint:algo.RnullStr4.String
void                 RnullStr4_Print(algo::RnullStr4 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr40
#pragma pack(push,1)
struct RnullStr40 { // algo.RnullStr40
    enum { ch_max = 40 };
    u8 ch[40];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr40 &rhs) const;
    bool operator !=(const algo::RnullStr40 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr40 &rhs) const;
    bool operator >(const algo::RnullStr40 &rhs) const;
    bool operator <=(const algo::RnullStr40 &rhs) const;
    bool operator >=(const algo::RnullStr40 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr40& parent) __attribute__((nothrow));
    RnullStr40(const algo::RnullStr40 &rhs) __attribute__((nothrow));
    RnullStr40(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr40();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr40& parent) __attribute__((nothrow));
u32                  RnullStr40_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr40 &parent) __attribute__((nothrow));
// always return constant 40
int                  ch_Max(algo::RnullStr40& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr40& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr40& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr40& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr40& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr40_Hash(u32 prev, const algo::RnullStr40 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr40 from an ascii string.
// The format of the string is the format of the algo::RnullStr40's only field
bool                 RnullStr40_ReadStrptrMaybe(algo::RnullStr40 &parent, algo::strptr in_str);
bool                 RnullStr40_Lt(algo::RnullStr40 & lhs, algo::RnullStr40 & rhs) __attribute__((nothrow));
i32                  RnullStr40_Cmp(algo::RnullStr40 & lhs, algo::RnullStr40 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr40_Init(algo::RnullStr40& parent);
bool                 RnullStr40_Eq(const algo::RnullStr40 & lhs,const algo::RnullStr40 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr40_Update(algo::RnullStr40 &lhs, algo::RnullStr40 & rhs) __attribute__((nothrow));
bool                 RnullStr40_EqStrptr(algo::RnullStr40 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr40 to string LHS, no header -- cprint:algo.RnullStr40.String
void                 RnullStr40_Print(algo::RnullStr40 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr41
#pragma pack(push,1)
struct RnullStr41 { // algo.RnullStr41
    enum { ch_max = 41 };
    u8 ch[41];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr41 &rhs) const;
    bool operator !=(const algo::RnullStr41 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr41 &rhs) const;
    bool operator >(const algo::RnullStr41 &rhs) const;
    bool operator <=(const algo::RnullStr41 &rhs) const;
    bool operator >=(const algo::RnullStr41 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr41& parent) __attribute__((nothrow));
    RnullStr41(const algo::RnullStr41 &rhs) __attribute__((nothrow));
    RnullStr41(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr41();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr41& parent) __attribute__((nothrow));
u32                  RnullStr41_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr41 &parent) __attribute__((nothrow));
// always return constant 41
int                  ch_Max(algo::RnullStr41& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr41& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr41& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr41& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr41& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr41_Hash(u32 prev, const algo::RnullStr41 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr41 from an ascii string.
// The format of the string is the format of the algo::RnullStr41's only field
bool                 RnullStr41_ReadStrptrMaybe(algo::RnullStr41 &parent, algo::strptr in_str);
bool                 RnullStr41_Lt(algo::RnullStr41 & lhs, algo::RnullStr41 & rhs) __attribute__((nothrow));
i32                  RnullStr41_Cmp(algo::RnullStr41 & lhs, algo::RnullStr41 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr41_Init(algo::RnullStr41& parent);
bool                 RnullStr41_Eq(const algo::RnullStr41 & lhs,const algo::RnullStr41 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr41_Update(algo::RnullStr41 &lhs, algo::RnullStr41 & rhs) __attribute__((nothrow));
bool                 RnullStr41_EqStrptr(algo::RnullStr41 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr41 to string LHS, no header -- cprint:algo.RnullStr41.String
void                 RnullStr41_Print(algo::RnullStr41 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr43
#pragma pack(push,1)
struct RnullStr43 { // algo.RnullStr43
    enum { ch_max = 43 };
    u8 ch[43];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr43& parent) __attribute__((nothrow));
    RnullStr43(const algo::RnullStr43 &rhs) __attribute__((nothrow));
    RnullStr43(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr43();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr43& parent) __attribute__((nothrow));
u32                  RnullStr43_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr43 &parent) __attribute__((nothrow));
// always return constant 43
int                  ch_Max(algo::RnullStr43& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr43& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr43& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr43& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr43& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr43_Hash(u32 prev, const algo::RnullStr43 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr43 from an ascii string.
// The format of the string is the format of the algo::RnullStr43's only field
bool                 RnullStr43_ReadStrptrMaybe(algo::RnullStr43 &parent, algo::strptr in_str);
bool                 RnullStr43_Lt(algo::RnullStr43 & lhs, algo::RnullStr43 & rhs) __attribute__((nothrow));
i32                  RnullStr43_Cmp(algo::RnullStr43 & lhs, algo::RnullStr43 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr43_Init(algo::RnullStr43& parent);
bool                 RnullStr43_Eq(const algo::RnullStr43 & lhs,const algo::RnullStr43 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr43_Update(algo::RnullStr43 &lhs, algo::RnullStr43 & rhs) __attribute__((nothrow));
bool                 RnullStr43_EqStrptr(algo::RnullStr43 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr43 to string LHS, no header -- cprint:algo.RnullStr43.String
void                 RnullStr43_Print(algo::RnullStr43 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr44
#pragma pack(push,1)
struct RnullStr44 { // algo.RnullStr44
    enum { ch_max = 44 };
    u8 ch[44];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr44& parent) __attribute__((nothrow));
    RnullStr44(const algo::RnullStr44 &rhs) __attribute__((nothrow));
    RnullStr44(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr44();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr44& parent) __attribute__((nothrow));
u32                  RnullStr44_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr44 &parent) __attribute__((nothrow));
// always return constant 44
int                  ch_Max(algo::RnullStr44& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr44& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr44& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr44& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr44& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr44_Hash(u32 prev, const algo::RnullStr44 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr44 from an ascii string.
// The format of the string is the format of the algo::RnullStr44's only field
bool                 RnullStr44_ReadStrptrMaybe(algo::RnullStr44 &parent, algo::strptr in_str);
bool                 RnullStr44_Lt(algo::RnullStr44 & lhs, algo::RnullStr44 & rhs) __attribute__((nothrow));
i32                  RnullStr44_Cmp(algo::RnullStr44 & lhs, algo::RnullStr44 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr44_Init(algo::RnullStr44& parent);
bool                 RnullStr44_Eq(const algo::RnullStr44 & lhs,const algo::RnullStr44 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr44_Update(algo::RnullStr44 &lhs, algo::RnullStr44 & rhs) __attribute__((nothrow));
bool                 RnullStr44_EqStrptr(algo::RnullStr44 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr44 to string LHS, no header -- cprint:algo.RnullStr44.String
void                 RnullStr44_Print(algo::RnullStr44 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr48
#pragma pack(push,1)
struct RnullStr48 { // algo.RnullStr48
    enum { ch_max = 48 };
    u8 ch[48];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr48& parent) __attribute__((nothrow));
    RnullStr48(const algo::RnullStr48 &rhs) __attribute__((nothrow));
    RnullStr48(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr48();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr48& parent) __attribute__((nothrow));
u32                  RnullStr48_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr48 &parent) __attribute__((nothrow));
// always return constant 48
int                  ch_Max(algo::RnullStr48& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr48& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr48& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr48& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr48& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr48_Hash(u32 prev, const algo::RnullStr48 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr48 from an ascii string.
// The format of the string is the format of the algo::RnullStr48's only field
bool                 RnullStr48_ReadStrptrMaybe(algo::RnullStr48 &parent, algo::strptr in_str);
bool                 RnullStr48_Lt(algo::RnullStr48 & lhs, algo::RnullStr48 & rhs) __attribute__((nothrow));
i32                  RnullStr48_Cmp(algo::RnullStr48 & lhs, algo::RnullStr48 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr48_Init(algo::RnullStr48& parent);
bool                 RnullStr48_Eq(const algo::RnullStr48 & lhs,const algo::RnullStr48 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr48_Update(algo::RnullStr48 &lhs, algo::RnullStr48 & rhs) __attribute__((nothrow));
bool                 RnullStr48_EqStrptr(algo::RnullStr48 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr48 to string LHS, no header -- cprint:algo.RnullStr48.String
void                 RnullStr48_Print(algo::RnullStr48 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr5
#pragma pack(push,1)
struct RnullStr5 { // algo.RnullStr5
    enum { ch_max = 5 };
    u8 ch[5];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr5& parent) __attribute__((nothrow));
    RnullStr5(const algo::RnullStr5 &rhs) __attribute__((nothrow));
    RnullStr5(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr5();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr5& parent) __attribute__((nothrow));
u32                  RnullStr5_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr5 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::RnullStr5& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr5& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr5& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr5& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr5& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr5_Hash(u32 prev, algo::RnullStr5 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr5 from an ascii string.
// The format of the string is the format of the algo::RnullStr5's only field
bool                 RnullStr5_ReadStrptrMaybe(algo::RnullStr5 &parent, algo::strptr in_str);
bool                 RnullStr5_Lt(algo::RnullStr5 lhs, algo::RnullStr5 rhs) __attribute__((nothrow));
i32                  RnullStr5_Cmp(algo::RnullStr5 lhs, algo::RnullStr5 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr5_Init(algo::RnullStr5& parent);
bool                 RnullStr5_Eq(algo::RnullStr5 lhs, algo::RnullStr5 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr5_Update(algo::RnullStr5 &lhs, algo::RnullStr5 rhs) __attribute__((nothrow));
bool                 RnullStr5_EqStrptr(algo::RnullStr5 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr5 to string LHS, no header -- cprint:algo.RnullStr5.String
void                 RnullStr5_Print(algo::RnullStr5 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr50
#pragma pack(push,1)
struct RnullStr50 { // algo.RnullStr50
    enum { ch_max = 50 };
    u8 ch[50];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr50& parent) __attribute__((nothrow));
    RnullStr50(const algo::RnullStr50 &rhs) __attribute__((nothrow));
    RnullStr50(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr50();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr50& parent) __attribute__((nothrow));
u32                  RnullStr50_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr50 &parent) __attribute__((nothrow));
// always return constant 50
int                  ch_Max(algo::RnullStr50& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr50& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr50& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr50& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr50& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr50_Hash(u32 prev, const algo::RnullStr50 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr50 from an ascii string.
// The format of the string is the format of the algo::RnullStr50's only field
bool                 RnullStr50_ReadStrptrMaybe(algo::RnullStr50 &parent, algo::strptr in_str);
bool                 RnullStr50_Lt(algo::RnullStr50 & lhs, algo::RnullStr50 & rhs) __attribute__((nothrow));
i32                  RnullStr50_Cmp(algo::RnullStr50 & lhs, algo::RnullStr50 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr50_Init(algo::RnullStr50& parent);
bool                 RnullStr50_Eq(const algo::RnullStr50 & lhs,const algo::RnullStr50 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr50_Update(algo::RnullStr50 &lhs, algo::RnullStr50 & rhs) __attribute__((nothrow));
bool                 RnullStr50_EqStrptr(algo::RnullStr50 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr50 to string LHS, no header -- cprint:algo.RnullStr50.String
void                 RnullStr50_Print(algo::RnullStr50 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr54
#pragma pack(push,1)
struct RnullStr54 { // algo.RnullStr54
    enum { ch_max = 54 };
    u8 ch[54];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr54 &rhs) const;
    bool operator !=(const algo::RnullStr54 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr54 &rhs) const;
    bool operator >(const algo::RnullStr54 &rhs) const;
    bool operator <=(const algo::RnullStr54 &rhs) const;
    bool operator >=(const algo::RnullStr54 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr54& parent) __attribute__((nothrow));
    RnullStr54(const algo::RnullStr54 &rhs) __attribute__((nothrow));
    RnullStr54(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr54();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr54& parent) __attribute__((nothrow));
u32                  RnullStr54_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr54 &parent) __attribute__((nothrow));
// always return constant 54
int                  ch_Max(algo::RnullStr54& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr54& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr54& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr54& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr54& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr54_Hash(u32 prev, const algo::RnullStr54 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr54 from an ascii string.
// The format of the string is the format of the algo::RnullStr54's only field
bool                 RnullStr54_ReadStrptrMaybe(algo::RnullStr54 &parent, algo::strptr in_str);
bool                 RnullStr54_Lt(algo::RnullStr54 & lhs, algo::RnullStr54 & rhs) __attribute__((nothrow));
i32                  RnullStr54_Cmp(algo::RnullStr54 & lhs, algo::RnullStr54 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr54_Init(algo::RnullStr54& parent);
bool                 RnullStr54_Eq(const algo::RnullStr54 & lhs,const algo::RnullStr54 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr54_Update(algo::RnullStr54 &lhs, algo::RnullStr54 & rhs) __attribute__((nothrow));
bool                 RnullStr54_EqStrptr(algo::RnullStr54 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr54 to string LHS, no header -- cprint:algo.RnullStr54.String
void                 RnullStr54_Print(algo::RnullStr54 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr55
#pragma pack(push,1)
struct RnullStr55 { // algo.RnullStr55
    enum { ch_max = 55 };
    u8 ch[55];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr55& parent) __attribute__((nothrow));
    RnullStr55(const algo::RnullStr55 &rhs) __attribute__((nothrow));
    RnullStr55(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr55();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr55& parent) __attribute__((nothrow));
u32                  RnullStr55_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr55 &parent) __attribute__((nothrow));
// always return constant 55
int                  ch_Max(algo::RnullStr55& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr55& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr55& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr55& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr55& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr55_Hash(u32 prev, const algo::RnullStr55 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr55 from an ascii string.
// The format of the string is the format of the algo::RnullStr55's only field
bool                 RnullStr55_ReadStrptrMaybe(algo::RnullStr55 &parent, algo::strptr in_str);
bool                 RnullStr55_Lt(algo::RnullStr55 & lhs, algo::RnullStr55 & rhs) __attribute__((nothrow));
i32                  RnullStr55_Cmp(algo::RnullStr55 & lhs, algo::RnullStr55 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr55_Init(algo::RnullStr55& parent);
bool                 RnullStr55_Eq(const algo::RnullStr55 & lhs,const algo::RnullStr55 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr55_Update(algo::RnullStr55 &lhs, algo::RnullStr55 & rhs) __attribute__((nothrow));
bool                 RnullStr55_EqStrptr(algo::RnullStr55 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr55 to string LHS, no header -- cprint:algo.RnullStr55.String
void                 RnullStr55_Print(algo::RnullStr55 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr6
#pragma pack(push,1)
struct RnullStr6 { // algo.RnullStr6
    enum { ch_max = 6 };
    u8 ch[6];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr6 &rhs) const;
    bool operator !=(const algo::RnullStr6 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr6 &rhs) const;
    bool operator >(const algo::RnullStr6 &rhs) const;
    bool operator <=(const algo::RnullStr6 &rhs) const;
    bool operator >=(const algo::RnullStr6 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr6& parent) __attribute__((nothrow));
    RnullStr6(const algo::RnullStr6 &rhs) __attribute__((nothrow));
    RnullStr6(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr6();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr6& parent) __attribute__((nothrow));
u32                  RnullStr6_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr6 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(algo::RnullStr6& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr6& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr6& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr6& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr6& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr6_Hash(u32 prev, algo::RnullStr6 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr6 from an ascii string.
// The format of the string is the format of the algo::RnullStr6's only field
bool                 RnullStr6_ReadStrptrMaybe(algo::RnullStr6 &parent, algo::strptr in_str);
bool                 RnullStr6_Lt(algo::RnullStr6 lhs, algo::RnullStr6 rhs) __attribute__((nothrow));
i32                  RnullStr6_Cmp(algo::RnullStr6 lhs, algo::RnullStr6 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr6_Init(algo::RnullStr6& parent);
bool                 RnullStr6_Eq(algo::RnullStr6 lhs, algo::RnullStr6 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr6_Update(algo::RnullStr6 &lhs, algo::RnullStr6 rhs) __attribute__((nothrow));
bool                 RnullStr6_EqStrptr(algo::RnullStr6 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr6 to string LHS, no header -- cprint:algo.RnullStr6.String
void                 RnullStr6_Print(algo::RnullStr6 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr60
#pragma pack(push,1)
struct RnullStr60 { // algo.RnullStr60
    enum { ch_max = 60 };
    u8 ch[60];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr60 &rhs) const;
    bool operator !=(const algo::RnullStr60 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr60 &rhs) const;
    bool operator >(const algo::RnullStr60 &rhs) const;
    bool operator <=(const algo::RnullStr60 &rhs) const;
    bool operator >=(const algo::RnullStr60 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr60& parent) __attribute__((nothrow));
    RnullStr60(const algo::RnullStr60 &rhs) __attribute__((nothrow));
    RnullStr60(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr60();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr60& parent) __attribute__((nothrow));
u32                  RnullStr60_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr60 &parent) __attribute__((nothrow));
// always return constant 60
int                  ch_Max(algo::RnullStr60& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr60& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr60& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr60& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr60& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr60_Hash(u32 prev, const algo::RnullStr60 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr60 from an ascii string.
// The format of the string is the format of the algo::RnullStr60's only field
bool                 RnullStr60_ReadStrptrMaybe(algo::RnullStr60 &parent, algo::strptr in_str);
bool                 RnullStr60_Lt(algo::RnullStr60 & lhs, algo::RnullStr60 & rhs) __attribute__((nothrow));
i32                  RnullStr60_Cmp(algo::RnullStr60 & lhs, algo::RnullStr60 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr60_Init(algo::RnullStr60& parent);
bool                 RnullStr60_Eq(const algo::RnullStr60 & lhs,const algo::RnullStr60 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr60_Update(algo::RnullStr60 &lhs, algo::RnullStr60 & rhs) __attribute__((nothrow));
bool                 RnullStr60_EqStrptr(algo::RnullStr60 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr60 to string LHS, no header -- cprint:algo.RnullStr60.String
void                 RnullStr60_Print(algo::RnullStr60 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr62
#pragma pack(push,1)
struct RnullStr62 { // algo.RnullStr62
    enum { ch_max = 62 };
    u8 ch[62];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr62 &rhs) const;
    bool operator !=(const algo::RnullStr62 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr62 &rhs) const;
    bool operator >(const algo::RnullStr62 &rhs) const;
    bool operator <=(const algo::RnullStr62 &rhs) const;
    bool operator >=(const algo::RnullStr62 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr62& parent) __attribute__((nothrow));
    RnullStr62(const algo::RnullStr62 &rhs) __attribute__((nothrow));
    RnullStr62(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr62();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr62& parent) __attribute__((nothrow));
u32                  RnullStr62_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr62 &parent) __attribute__((nothrow));
// always return constant 62
int                  ch_Max(algo::RnullStr62& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr62& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr62& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr62& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr62& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr62_Hash(u32 prev, const algo::RnullStr62 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr62 from an ascii string.
// The format of the string is the format of the algo::RnullStr62's only field
bool                 RnullStr62_ReadStrptrMaybe(algo::RnullStr62 &parent, algo::strptr in_str);
bool                 RnullStr62_Lt(algo::RnullStr62 & lhs, algo::RnullStr62 & rhs) __attribute__((nothrow));
i32                  RnullStr62_Cmp(algo::RnullStr62 & lhs, algo::RnullStr62 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr62_Init(algo::RnullStr62& parent);
bool                 RnullStr62_Eq(const algo::RnullStr62 & lhs,const algo::RnullStr62 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr62_Update(algo::RnullStr62 &lhs, algo::RnullStr62 & rhs) __attribute__((nothrow));
bool                 RnullStr62_EqStrptr(algo::RnullStr62 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr62 to string LHS, no header -- cprint:algo.RnullStr62.String
void                 RnullStr62_Print(algo::RnullStr62 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr66
#pragma pack(push,1)
struct RnullStr66 { // algo.RnullStr66
    enum { ch_max = 66 };
    u8 ch[66];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr66& parent) __attribute__((nothrow));
    RnullStr66(const algo::RnullStr66 &rhs) __attribute__((nothrow));
    RnullStr66(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr66();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr66& parent) __attribute__((nothrow));
u32                  RnullStr66_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr66 &parent) __attribute__((nothrow));
// always return constant 66
int                  ch_Max(algo::RnullStr66& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr66& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr66& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr66& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr66& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr66_Hash(u32 prev, const algo::RnullStr66 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr66 from an ascii string.
// The format of the string is the format of the algo::RnullStr66's only field
bool                 RnullStr66_ReadStrptrMaybe(algo::RnullStr66 &parent, algo::strptr in_str);
bool                 RnullStr66_Lt(algo::RnullStr66 & lhs, algo::RnullStr66 & rhs) __attribute__((nothrow));
i32                  RnullStr66_Cmp(algo::RnullStr66 & lhs, algo::RnullStr66 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr66_Init(algo::RnullStr66& parent);
bool                 RnullStr66_Eq(const algo::RnullStr66 & lhs,const algo::RnullStr66 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr66_Update(algo::RnullStr66 &lhs, algo::RnullStr66 & rhs) __attribute__((nothrow));
bool                 RnullStr66_EqStrptr(algo::RnullStr66 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr66 to string LHS, no header -- cprint:algo.RnullStr66.String
void                 RnullStr66_Print(algo::RnullStr66 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr6_U32
#pragma pack(push,1)
struct RnullStr6_U32 { // algo.RnullStr6_U32: number stored as ascii digits, right pad with null
    enum { ch_max = 6 };
    u8 ch[6];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr6_U32 &rhs) const;
    bool operator !=(const algo::RnullStr6_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr6_U32& parent) __attribute__((nothrow));
    RnullStr6_U32(const algo::RnullStr6_U32 &rhs) __attribute__((nothrow));
    RnullStr6_U32(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr6_U32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr6_U32& parent) __attribute__((nothrow));
u32                  RnullStr6_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr6_U32 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(algo::RnullStr6_U32& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr6_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr6_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr6_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr6_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(algo::RnullStr6_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(algo::RnullStr6_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(algo::RnullStr6_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  RnullStr6_U32_Hash(u32 prev, const algo::RnullStr6_U32 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr6_U32 from an ascii string.
// The format of the string is the format of the algo::RnullStr6_U32's only field
bool                 RnullStr6_U32_ReadStrptrMaybe(algo::RnullStr6_U32 &parent, algo::strptr in_str);
i32                  RnullStr6_U32_Cmp(algo::RnullStr6_U32 & lhs, algo::RnullStr6_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr6_U32_Init(algo::RnullStr6_U32& parent);
bool                 RnullStr6_U32_Eq(const algo::RnullStr6_U32 & lhs,const algo::RnullStr6_U32 & rhs) __attribute__((nothrow));
bool                 RnullStr6_U32_EqStrptr(algo::RnullStr6_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr6_U32 to string LHS, no header -- cprint:algo.RnullStr6_U32.String
void                 RnullStr6_U32_Print(algo::RnullStr6_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr7
#pragma pack(push,1)
struct RnullStr7 { // algo.RnullStr7
    enum { ch_max = 7 };
    u8 ch[7];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr7 &rhs) const;
    bool operator !=(const algo::RnullStr7 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr7 &rhs) const;
    bool operator >(const algo::RnullStr7 &rhs) const;
    bool operator <=(const algo::RnullStr7 &rhs) const;
    bool operator >=(const algo::RnullStr7 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr7& parent) __attribute__((nothrow));
    RnullStr7(const algo::RnullStr7 &rhs) __attribute__((nothrow));
    RnullStr7(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr7();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr7& parent) __attribute__((nothrow));
u32                  RnullStr7_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr7 &parent) __attribute__((nothrow));
// always return constant 7
int                  ch_Max(algo::RnullStr7& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr7& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr7& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr7& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr7& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr7_Hash(u32 prev, algo::RnullStr7 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr7 from an ascii string.
// The format of the string is the format of the algo::RnullStr7's only field
bool                 RnullStr7_ReadStrptrMaybe(algo::RnullStr7 &parent, algo::strptr in_str);
bool                 RnullStr7_Lt(algo::RnullStr7 lhs, algo::RnullStr7 rhs) __attribute__((nothrow));
i32                  RnullStr7_Cmp(algo::RnullStr7 lhs, algo::RnullStr7 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr7_Init(algo::RnullStr7& parent);
bool                 RnullStr7_Eq(algo::RnullStr7 lhs, algo::RnullStr7 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr7_Update(algo::RnullStr7 &lhs, algo::RnullStr7 rhs) __attribute__((nothrow));
bool                 RnullStr7_EqStrptr(algo::RnullStr7 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr7 to string LHS, no header -- cprint:algo.RnullStr7.String
void                 RnullStr7_Print(algo::RnullStr7 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr8
#pragma pack(push,1)
struct RnullStr8 { // algo.RnullStr8
    enum { ch_max = 8 };
    u8 ch[8];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr8& parent) __attribute__((nothrow));
    RnullStr8(const algo::RnullStr8 &rhs) __attribute__((nothrow));
    RnullStr8(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr8();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr8& parent) __attribute__((nothrow));
u32                  RnullStr8_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr8 &parent) __attribute__((nothrow));
// always return constant 8
int                  ch_Max(algo::RnullStr8& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr8& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr8& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr8& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr8& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr8_Hash(u32 prev, algo::RnullStr8 rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr8 from an ascii string.
// The format of the string is the format of the algo::RnullStr8's only field
bool                 RnullStr8_ReadStrptrMaybe(algo::RnullStr8 &parent, algo::strptr in_str);
bool                 RnullStr8_Lt(algo::RnullStr8 lhs, algo::RnullStr8 rhs) __attribute__((nothrow));
i32                  RnullStr8_Cmp(algo::RnullStr8 lhs, algo::RnullStr8 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr8_Init(algo::RnullStr8& parent);
bool                 RnullStr8_Eq(algo::RnullStr8 lhs, algo::RnullStr8 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr8_Update(algo::RnullStr8 &lhs, algo::RnullStr8 rhs) __attribute__((nothrow));
bool                 RnullStr8_EqStrptr(algo::RnullStr8 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr8 to string LHS, no header -- cprint:algo.RnullStr8.String
void                 RnullStr8_Print(algo::RnullStr8 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr80
#pragma pack(push,1)
struct RnullStr80 { // algo.RnullStr80
    enum { ch_max = 80 };
    u8 ch[80];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr80& parent) __attribute__((nothrow));
    RnullStr80(const algo::RnullStr80 &rhs) __attribute__((nothrow));
    RnullStr80(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr80();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr80& parent) __attribute__((nothrow));
u32                  RnullStr80_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr80 &parent) __attribute__((nothrow));
// always return constant 80
int                  ch_Max(algo::RnullStr80& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr80& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr80& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr80& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr80& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr80_Hash(u32 prev, const algo::RnullStr80 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr80 from an ascii string.
// The format of the string is the format of the algo::RnullStr80's only field
bool                 RnullStr80_ReadStrptrMaybe(algo::RnullStr80 &parent, algo::strptr in_str);
bool                 RnullStr80_Lt(algo::RnullStr80 & lhs, algo::RnullStr80 & rhs) __attribute__((nothrow));
i32                  RnullStr80_Cmp(algo::RnullStr80 & lhs, algo::RnullStr80 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr80_Init(algo::RnullStr80& parent);
bool                 RnullStr80_Eq(const algo::RnullStr80 & lhs,const algo::RnullStr80 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr80_Update(algo::RnullStr80 &lhs, algo::RnullStr80 & rhs) __attribute__((nothrow));
bool                 RnullStr80_EqStrptr(algo::RnullStr80 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr80 to string LHS, no header -- cprint:algo.RnullStr80.String
void                 RnullStr80_Print(algo::RnullStr80 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RnullStr9
#pragma pack(push,1)
struct RnullStr9 { // algo.RnullStr9
    enum { ch_max = 9 };
    u8 ch[9];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RnullStr9 &rhs) const;
    bool operator !=(const algo::RnullStr9 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RnullStr9 &rhs) const;
    bool operator >(const algo::RnullStr9 &rhs) const;
    bool operator <=(const algo::RnullStr9 &rhs) const;
    bool operator >=(const algo::RnullStr9 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RnullStr9& parent) __attribute__((nothrow));
    RnullStr9(const algo::RnullStr9 &rhs) __attribute__((nothrow));
    RnullStr9(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr9();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RnullStr9& parent) __attribute__((nothrow));
u32                  RnullStr9_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RnullStr9 &parent) __attribute__((nothrow));
// always return constant 9
int                  ch_Max(algo::RnullStr9& parent) __attribute__((nothrow));
int                  ch_N(const algo::RnullStr9& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RnullStr9& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RnullStr9& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RnullStr9& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RnullStr9_Hash(u32 prev, const algo::RnullStr9 & rhs) __attribute__((nothrow));
// Read fields of algo::RnullStr9 from an ascii string.
// The format of the string is the format of the algo::RnullStr9's only field
bool                 RnullStr9_ReadStrptrMaybe(algo::RnullStr9 &parent, algo::strptr in_str);
bool                 RnullStr9_Lt(algo::RnullStr9 & lhs, algo::RnullStr9 & rhs) __attribute__((nothrow));
i32                  RnullStr9_Cmp(algo::RnullStr9 & lhs, algo::RnullStr9 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr9_Init(algo::RnullStr9& parent);
bool                 RnullStr9_Eq(const algo::RnullStr9 & lhs,const algo::RnullStr9 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr9_Update(algo::RnullStr9 &lhs, algo::RnullStr9 & rhs) __attribute__((nothrow));
bool                 RnullStr9_EqStrptr(algo::RnullStr9 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RnullStr9 to string LHS, no header -- cprint:algo.RnullStr9.String
void                 RnullStr9_Print(algo::RnullStr9 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr10
#pragma pack(push,1)
struct RspaceStr10 { // algo.RspaceStr10
    enum { ch_max = 10 };
    u8 ch[10];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr10 &rhs) const;
    bool operator !=(const algo::RspaceStr10 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr10& parent) __attribute__((nothrow));
    RspaceStr10(const algo::RspaceStr10 &rhs) __attribute__((nothrow));
    RspaceStr10(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr10();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr10& parent) __attribute__((nothrow));
u32                  RspaceStr10_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr10 &parent) __attribute__((nothrow));
// always return constant 10
int                  ch_Max(algo::RspaceStr10& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr10& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr10& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr10& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr10& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr10_Hash(u32 prev, algo::RspaceStr10 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr10 from an ascii string.
// The format of the string is the format of the algo::RspaceStr10's only field
bool                 RspaceStr10_ReadStrptrMaybe(algo::RspaceStr10 &parent, algo::strptr in_str);
i32                  RspaceStr10_Cmp(algo::RspaceStr10 lhs, algo::RspaceStr10 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr10_Init(algo::RspaceStr10& parent);
bool                 RspaceStr10_Eq(algo::RspaceStr10 lhs, algo::RspaceStr10 rhs) __attribute__((nothrow));
bool                 RspaceStr10_EqStrptr(algo::RspaceStr10 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr10 to string LHS, no header -- cprint:algo.RspaceStr10.String
void                 RspaceStr10_Print(algo::RspaceStr10 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr100
#pragma pack(push,1)
struct RspaceStr100 { // algo.RspaceStr100
    enum { ch_max = 100 };
    u8 ch[100];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr100 &rhs) const;
    bool operator !=(const algo::RspaceStr100 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr100& parent) __attribute__((nothrow));
    RspaceStr100(const algo::RspaceStr100 &rhs) __attribute__((nothrow));
    RspaceStr100(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr100();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr100& parent) __attribute__((nothrow));
u32                  RspaceStr100_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr100 &parent) __attribute__((nothrow));
// always return constant 100
int                  ch_Max(algo::RspaceStr100& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr100& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr100& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr100& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr100& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr100_Hash(u32 prev, const algo::RspaceStr100 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr100 from an ascii string.
// The format of the string is the format of the algo::RspaceStr100's only field
bool                 RspaceStr100_ReadStrptrMaybe(algo::RspaceStr100 &parent, algo::strptr in_str);
i32                  RspaceStr100_Cmp(algo::RspaceStr100 & lhs, algo::RspaceStr100 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr100_Init(algo::RspaceStr100& parent);
bool                 RspaceStr100_Eq(const algo::RspaceStr100 & lhs,const algo::RspaceStr100 & rhs) __attribute__((nothrow));
bool                 RspaceStr100_EqStrptr(algo::RspaceStr100 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr100 to string LHS, no header -- cprint:algo.RspaceStr100.String
void                 RspaceStr100_Print(algo::RspaceStr100 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr11
#pragma pack(push,1)
struct RspaceStr11 { // algo.RspaceStr11
    enum { ch_max = 11 };
    u8 ch[11];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr11 &rhs) const;
    bool operator !=(const algo::RspaceStr11 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr11& parent) __attribute__((nothrow));
    RspaceStr11(const algo::RspaceStr11 &rhs) __attribute__((nothrow));
    RspaceStr11(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr11();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr11& parent) __attribute__((nothrow));
u32                  RspaceStr11_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr11 &parent) __attribute__((nothrow));
// always return constant 11
int                  ch_Max(algo::RspaceStr11& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr11& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr11& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr11& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr11& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr11_Hash(u32 prev, const algo::RspaceStr11 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr11 from an ascii string.
// The format of the string is the format of the algo::RspaceStr11's only field
bool                 RspaceStr11_ReadStrptrMaybe(algo::RspaceStr11 &parent, algo::strptr in_str);
i32                  RspaceStr11_Cmp(algo::RspaceStr11 & lhs, algo::RspaceStr11 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr11_Init(algo::RspaceStr11& parent);
bool                 RspaceStr11_Eq(const algo::RspaceStr11 & lhs,const algo::RspaceStr11 & rhs) __attribute__((nothrow));
bool                 RspaceStr11_EqStrptr(algo::RspaceStr11 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr11 to string LHS, no header -- cprint:algo.RspaceStr11.String
void                 RspaceStr11_Print(algo::RspaceStr11 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr12
#pragma pack(push,1)
struct RspaceStr12 { // algo.RspaceStr12
    enum { ch_max = 12 };
    u8 ch[12];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr12 &rhs) const;
    bool operator !=(const algo::RspaceStr12 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr12& parent) __attribute__((nothrow));
    RspaceStr12(const algo::RspaceStr12 &rhs) __attribute__((nothrow));
    RspaceStr12(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr12();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr12& parent) __attribute__((nothrow));
u32                  RspaceStr12_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr12 &parent) __attribute__((nothrow));
// always return constant 12
int                  ch_Max(algo::RspaceStr12& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr12& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr12& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr12& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr12& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr12_Hash(u32 prev, algo::RspaceStr12 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr12 from an ascii string.
// The format of the string is the format of the algo::RspaceStr12's only field
bool                 RspaceStr12_ReadStrptrMaybe(algo::RspaceStr12 &parent, algo::strptr in_str);
i32                  RspaceStr12_Cmp(algo::RspaceStr12 lhs, algo::RspaceStr12 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr12_Init(algo::RspaceStr12& parent);
bool                 RspaceStr12_Eq(algo::RspaceStr12 lhs, algo::RspaceStr12 rhs) __attribute__((nothrow));
bool                 RspaceStr12_EqStrptr(algo::RspaceStr12 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr12 to string LHS, no header -- cprint:algo.RspaceStr12.String
void                 RspaceStr12_Print(algo::RspaceStr12 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr128
#pragma pack(push,1)
struct RspaceStr128 { // algo.RspaceStr128
    enum { ch_max = 128 };
    u8 ch[128];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr128 &rhs) const;
    bool operator !=(const algo::RspaceStr128 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr128& parent) __attribute__((nothrow));
    RspaceStr128(const algo::RspaceStr128 &rhs) __attribute__((nothrow));
    RspaceStr128(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr128();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr128& parent) __attribute__((nothrow));
u32                  RspaceStr128_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr128 &parent) __attribute__((nothrow));
// always return constant 128
int                  ch_Max(algo::RspaceStr128& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr128& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr128& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr128& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr128& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr128_Hash(u32 prev, algo::RspaceStr128 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr128 from an ascii string.
// The format of the string is the format of the algo::RspaceStr128's only field
bool                 RspaceStr128_ReadStrptrMaybe(algo::RspaceStr128 &parent, algo::strptr in_str);
i32                  RspaceStr128_Cmp(algo::RspaceStr128 lhs, algo::RspaceStr128 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr128_Init(algo::RspaceStr128& parent);
bool                 RspaceStr128_Eq(algo::RspaceStr128 lhs, algo::RspaceStr128 rhs) __attribute__((nothrow));
bool                 RspaceStr128_EqStrptr(algo::RspaceStr128 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr128 to string LHS, no header -- cprint:algo.RspaceStr128.String
void                 RspaceStr128_Print(algo::RspaceStr128 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr14
#pragma pack(push,1)
struct RspaceStr14 { // algo.RspaceStr14
    enum { ch_max = 14 };
    u8 ch[14];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr14 &rhs) const;
    bool operator !=(const algo::RspaceStr14 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr14& parent) __attribute__((nothrow));
    RspaceStr14(const algo::RspaceStr14 &rhs) __attribute__((nothrow));
    RspaceStr14(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr14();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr14& parent) __attribute__((nothrow));
u32                  RspaceStr14_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr14 &parent) __attribute__((nothrow));
// always return constant 14
int                  ch_Max(algo::RspaceStr14& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr14& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr14& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr14& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr14& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr14_Hash(u32 prev, algo::RspaceStr14 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr14 from an ascii string.
// The format of the string is the format of the algo::RspaceStr14's only field
bool                 RspaceStr14_ReadStrptrMaybe(algo::RspaceStr14 &parent, algo::strptr in_str);
i32                  RspaceStr14_Cmp(algo::RspaceStr14 lhs, algo::RspaceStr14 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr14_Init(algo::RspaceStr14& parent);
bool                 RspaceStr14_Eq(algo::RspaceStr14 lhs, algo::RspaceStr14 rhs) __attribute__((nothrow));
bool                 RspaceStr14_EqStrptr(algo::RspaceStr14 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr14 to string LHS, no header -- cprint:algo.RspaceStr14.String
void                 RspaceStr14_Print(algo::RspaceStr14 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr15
#pragma pack(push,1)
struct RspaceStr15 { // algo.RspaceStr15
    enum { ch_max = 15 };
    u8 ch[15];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr15 &rhs) const;
    bool operator !=(const algo::RspaceStr15 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr15& parent) __attribute__((nothrow));
    RspaceStr15(const algo::RspaceStr15 &rhs) __attribute__((nothrow));
    RspaceStr15(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr15();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr15& parent) __attribute__((nothrow));
u32                  RspaceStr15_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr15 &parent) __attribute__((nothrow));
// always return constant 15
int                  ch_Max(algo::RspaceStr15& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr15& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr15& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr15& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr15& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr15_Hash(u32 prev, algo::RspaceStr15 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr15 from an ascii string.
// The format of the string is the format of the algo::RspaceStr15's only field
bool                 RspaceStr15_ReadStrptrMaybe(algo::RspaceStr15 &parent, algo::strptr in_str);
i32                  RspaceStr15_Cmp(algo::RspaceStr15 lhs, algo::RspaceStr15 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr15_Init(algo::RspaceStr15& parent);
bool                 RspaceStr15_Eq(algo::RspaceStr15 lhs, algo::RspaceStr15 rhs) __attribute__((nothrow));
bool                 RspaceStr15_EqStrptr(algo::RspaceStr15 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr15 to string LHS, no header -- cprint:algo.RspaceStr15.String
void                 RspaceStr15_Print(algo::RspaceStr15 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr16
#pragma pack(push,1)
struct RspaceStr16 { // algo.RspaceStr16
    enum { ch_max = 16 };
    u8 ch[16];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr16& parent) __attribute__((nothrow));
    RspaceStr16(const algo::RspaceStr16 &rhs) __attribute__((nothrow));
    RspaceStr16(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr16();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr16& parent) __attribute__((nothrow));
u32                  RspaceStr16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr16 &parent) __attribute__((nothrow));
// always return constant 16
int                  ch_Max(algo::RspaceStr16& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr16& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr16_Hash(u32 prev, algo::RspaceStr16 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr16 from an ascii string.
// The format of the string is the format of the algo::RspaceStr16's only field
bool                 RspaceStr16_ReadStrptrMaybe(algo::RspaceStr16 &parent, algo::strptr in_str);
bool                 RspaceStr16_Lt(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) __attribute__((nothrow));
i32                  RspaceStr16_Cmp(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr16_Init(algo::RspaceStr16& parent);
bool                 RspaceStr16_Eq(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RspaceStr16_Update(algo::RspaceStr16 &lhs, algo::RspaceStr16 rhs) __attribute__((nothrow));
bool                 RspaceStr16_EqStrptr(algo::RspaceStr16 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr16 to string LHS, no header -- cprint:algo.RspaceStr16.String
void                 RspaceStr16_Print(algo::RspaceStr16 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr18
#pragma pack(push,1)
struct RspaceStr18 { // algo.RspaceStr18
    enum { ch_max = 18 };
    u8 ch[18];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr18 &rhs) const;
    bool operator !=(const algo::RspaceStr18 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr18& parent) __attribute__((nothrow));
    RspaceStr18(const algo::RspaceStr18 &rhs) __attribute__((nothrow));
    RspaceStr18(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr18();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr18& parent) __attribute__((nothrow));
u32                  RspaceStr18_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr18 &parent) __attribute__((nothrow));
// always return constant 18
int                  ch_Max(algo::RspaceStr18& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr18& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr18& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr18& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr18& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr18_Hash(u32 prev, algo::RspaceStr18 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr18 from an ascii string.
// The format of the string is the format of the algo::RspaceStr18's only field
bool                 RspaceStr18_ReadStrptrMaybe(algo::RspaceStr18 &parent, algo::strptr in_str);
i32                  RspaceStr18_Cmp(algo::RspaceStr18 lhs, algo::RspaceStr18 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr18_Init(algo::RspaceStr18& parent);
bool                 RspaceStr18_Eq(algo::RspaceStr18 lhs, algo::RspaceStr18 rhs) __attribute__((nothrow));
bool                 RspaceStr18_EqStrptr(algo::RspaceStr18 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr18 to string LHS, no header -- cprint:algo.RspaceStr18.String
void                 RspaceStr18_Print(algo::RspaceStr18 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr2
#pragma pack(push,1)
struct RspaceStr2 { // algo.RspaceStr2
    enum { ch_max = 2 };
    u8 ch[2];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr2 &rhs) const;
    bool operator !=(const algo::RspaceStr2 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr2& parent) __attribute__((nothrow));
    RspaceStr2(const algo::RspaceStr2 &rhs) __attribute__((nothrow));
    RspaceStr2(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr2();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr2& parent) __attribute__((nothrow));
u32                  RspaceStr2_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr2 &parent) __attribute__((nothrow));
// always return constant 2
int                  ch_Max(algo::RspaceStr2& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr2& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr2& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr2& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr2& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr2_Hash(u32 prev, algo::RspaceStr2 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr2 from an ascii string.
// The format of the string is the format of the algo::RspaceStr2's only field
bool                 RspaceStr2_ReadStrptrMaybe(algo::RspaceStr2 &parent, algo::strptr in_str);
i32                  RspaceStr2_Cmp(algo::RspaceStr2 lhs, algo::RspaceStr2 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr2_Init(algo::RspaceStr2& parent);
bool                 RspaceStr2_Eq(algo::RspaceStr2 lhs, algo::RspaceStr2 rhs) __attribute__((nothrow));
bool                 RspaceStr2_EqStrptr(algo::RspaceStr2 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr2 to string LHS, no header -- cprint:algo.RspaceStr2.String
void                 RspaceStr2_Print(algo::RspaceStr2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr20
#pragma pack(push,1)
struct RspaceStr20 { // algo.RspaceStr20
    enum { ch_max = 20 };
    u8 ch[20];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr20 &rhs) const;
    bool operator !=(const algo::RspaceStr20 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr20& parent) __attribute__((nothrow));
    RspaceStr20(const algo::RspaceStr20 &rhs) __attribute__((nothrow));
    RspaceStr20(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr20();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr20& parent) __attribute__((nothrow));
u32                  RspaceStr20_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr20 &parent) __attribute__((nothrow));
// always return constant 20
int                  ch_Max(algo::RspaceStr20& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr20& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr20& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr20& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr20& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr20_Hash(u32 prev, algo::RspaceStr20 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr20 from an ascii string.
// The format of the string is the format of the algo::RspaceStr20's only field
bool                 RspaceStr20_ReadStrptrMaybe(algo::RspaceStr20 &parent, algo::strptr in_str);
i32                  RspaceStr20_Cmp(algo::RspaceStr20 lhs, algo::RspaceStr20 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr20_Init(algo::RspaceStr20& parent);
bool                 RspaceStr20_Eq(algo::RspaceStr20 lhs, algo::RspaceStr20 rhs) __attribute__((nothrow));
bool                 RspaceStr20_EqStrptr(algo::RspaceStr20 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr20 to string LHS, no header -- cprint:algo.RspaceStr20.String
void                 RspaceStr20_Print(algo::RspaceStr20 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr200
#pragma pack(push,1)
struct RspaceStr200 { // algo.RspaceStr200
    enum { ch_max = 200 };
    u8 ch[200];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr200 &rhs) const;
    bool operator !=(const algo::RspaceStr200 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr200& parent) __attribute__((nothrow));
    RspaceStr200(const algo::RspaceStr200 &rhs) __attribute__((nothrow));
    RspaceStr200(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr200();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr200& parent) __attribute__((nothrow));
u32                  RspaceStr200_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr200 &parent) __attribute__((nothrow));
// always return constant 200
int                  ch_Max(algo::RspaceStr200& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr200& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr200& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr200& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr200& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr200_Hash(u32 prev, const algo::RspaceStr200 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr200 from an ascii string.
// The format of the string is the format of the algo::RspaceStr200's only field
bool                 RspaceStr200_ReadStrptrMaybe(algo::RspaceStr200 &parent, algo::strptr in_str);
i32                  RspaceStr200_Cmp(algo::RspaceStr200 & lhs, algo::RspaceStr200 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr200_Init(algo::RspaceStr200& parent);
bool                 RspaceStr200_Eq(const algo::RspaceStr200 & lhs,const algo::RspaceStr200 & rhs) __attribute__((nothrow));
bool                 RspaceStr200_EqStrptr(algo::RspaceStr200 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr200 to string LHS, no header -- cprint:algo.RspaceStr200.String
void                 RspaceStr200_Print(algo::RspaceStr200 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr21
#pragma pack(push,1)
struct RspaceStr21 { // algo.RspaceStr21
    enum { ch_max = 21 };
    u8 ch[21];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr21 &rhs) const;
    bool operator !=(const algo::RspaceStr21 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr21& parent) __attribute__((nothrow));
    RspaceStr21(const algo::RspaceStr21 &rhs) __attribute__((nothrow));
    RspaceStr21(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr21();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr21& parent) __attribute__((nothrow));
u32                  RspaceStr21_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr21 &parent) __attribute__((nothrow));
// always return constant 21
int                  ch_Max(algo::RspaceStr21& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr21& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr21& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr21& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr21& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr21_Hash(u32 prev, const algo::RspaceStr21 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr21 from an ascii string.
// The format of the string is the format of the algo::RspaceStr21's only field
bool                 RspaceStr21_ReadStrptrMaybe(algo::RspaceStr21 &parent, algo::strptr in_str);
i32                  RspaceStr21_Cmp(algo::RspaceStr21 & lhs, algo::RspaceStr21 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr21_Init(algo::RspaceStr21& parent);
bool                 RspaceStr21_Eq(const algo::RspaceStr21 & lhs,const algo::RspaceStr21 & rhs) __attribute__((nothrow));
bool                 RspaceStr21_EqStrptr(algo::RspaceStr21 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr21 to string LHS, no header -- cprint:algo.RspaceStr21.String
void                 RspaceStr21_Print(algo::RspaceStr21 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr24
#pragma pack(push,1)
struct RspaceStr24 { // algo.RspaceStr24
    enum { ch_max = 24 };
    u8 ch[24];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr24& parent) __attribute__((nothrow));
    RspaceStr24(const algo::RspaceStr24 &rhs) __attribute__((nothrow));
    RspaceStr24(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr24();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr24& parent) __attribute__((nothrow));
u32                  RspaceStr24_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr24 &parent) __attribute__((nothrow));
// always return constant 24
int                  ch_Max(algo::RspaceStr24& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr24& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr24& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr24& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr24& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr24_Hash(u32 prev, algo::RspaceStr24 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr24 from an ascii string.
// The format of the string is the format of the algo::RspaceStr24's only field
bool                 RspaceStr24_ReadStrptrMaybe(algo::RspaceStr24 &parent, algo::strptr in_str);
bool                 RspaceStr24_Lt(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) __attribute__((nothrow));
i32                  RspaceStr24_Cmp(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr24_Init(algo::RspaceStr24& parent);
bool                 RspaceStr24_Eq(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RspaceStr24_Update(algo::RspaceStr24 &lhs, algo::RspaceStr24 rhs) __attribute__((nothrow));
bool                 RspaceStr24_EqStrptr(algo::RspaceStr24 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr24 to string LHS, no header -- cprint:algo.RspaceStr24.String
void                 RspaceStr24_Print(algo::RspaceStr24 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr240
#pragma pack(push,1)
struct RspaceStr240 { // algo.RspaceStr240
    enum { ch_max = 240 };
    u8 ch[240];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr240 &rhs) const;
    bool operator !=(const algo::RspaceStr240 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr240& parent) __attribute__((nothrow));
    RspaceStr240(const algo::RspaceStr240 &rhs) __attribute__((nothrow));
    RspaceStr240(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr240();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr240& parent) __attribute__((nothrow));
u32                  RspaceStr240_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr240 &parent) __attribute__((nothrow));
// always return constant 240
int                  ch_Max(algo::RspaceStr240& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr240& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr240& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr240& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr240& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr240_Hash(u32 prev, const algo::RspaceStr240 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr240 from an ascii string.
// The format of the string is the format of the algo::RspaceStr240's only field
bool                 RspaceStr240_ReadStrptrMaybe(algo::RspaceStr240 &parent, algo::strptr in_str);
i32                  RspaceStr240_Cmp(algo::RspaceStr240 & lhs, algo::RspaceStr240 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr240_Init(algo::RspaceStr240& parent);
bool                 RspaceStr240_Eq(const algo::RspaceStr240 & lhs,const algo::RspaceStr240 & rhs) __attribute__((nothrow));
bool                 RspaceStr240_EqStrptr(algo::RspaceStr240 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr240 to string LHS, no header -- cprint:algo.RspaceStr240.String
void                 RspaceStr240_Print(algo::RspaceStr240 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr25
#pragma pack(push,1)
struct RspaceStr25 { // algo.RspaceStr25
    enum { ch_max = 25 };
    u8 ch[25];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr25& parent) __attribute__((nothrow));
    RspaceStr25(const algo::RspaceStr25 &rhs) __attribute__((nothrow));
    RspaceStr25(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr25();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr25& parent) __attribute__((nothrow));
u32                  RspaceStr25_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr25 &parent) __attribute__((nothrow));
// always return constant 25
int                  ch_Max(algo::RspaceStr25& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr25& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr25& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr25& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr25& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr25_Hash(u32 prev, algo::RspaceStr25 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr25 from an ascii string.
// The format of the string is the format of the algo::RspaceStr25's only field
bool                 RspaceStr25_ReadStrptrMaybe(algo::RspaceStr25 &parent, algo::strptr in_str);
bool                 RspaceStr25_Lt(algo::RspaceStr25 lhs, algo::RspaceStr25 rhs) __attribute__((nothrow));
i32                  RspaceStr25_Cmp(algo::RspaceStr25 lhs, algo::RspaceStr25 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr25_Init(algo::RspaceStr25& parent);
bool                 RspaceStr25_Eq(algo::RspaceStr25 lhs, algo::RspaceStr25 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RspaceStr25_Update(algo::RspaceStr25 &lhs, algo::RspaceStr25 rhs) __attribute__((nothrow));
bool                 RspaceStr25_EqStrptr(algo::RspaceStr25 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr25 to string LHS, no header -- cprint:algo.RspaceStr25.String
void                 RspaceStr25_Print(algo::RspaceStr25 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr26
#pragma pack(push,1)
struct RspaceStr26 { // algo.RspaceStr26
    enum { ch_max = 26 };
    u8 ch[26];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr26 &rhs) const;
    bool operator !=(const algo::RspaceStr26 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr26& parent) __attribute__((nothrow));
    RspaceStr26(const algo::RspaceStr26 &rhs) __attribute__((nothrow));
    RspaceStr26(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr26();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr26& parent) __attribute__((nothrow));
u32                  RspaceStr26_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr26 &parent) __attribute__((nothrow));
// always return constant 26
int                  ch_Max(algo::RspaceStr26& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr26& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr26& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr26& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr26& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr26_Hash(u32 prev, const algo::RspaceStr26 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr26 from an ascii string.
// The format of the string is the format of the algo::RspaceStr26's only field
bool                 RspaceStr26_ReadStrptrMaybe(algo::RspaceStr26 &parent, algo::strptr in_str);
i32                  RspaceStr26_Cmp(algo::RspaceStr26 & lhs, algo::RspaceStr26 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr26_Init(algo::RspaceStr26& parent);
bool                 RspaceStr26_Eq(const algo::RspaceStr26 & lhs,const algo::RspaceStr26 & rhs) __attribute__((nothrow));
bool                 RspaceStr26_EqStrptr(algo::RspaceStr26 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr26 to string LHS, no header -- cprint:algo.RspaceStr26.String
void                 RspaceStr26_Print(algo::RspaceStr26 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr3
#pragma pack(push,1)
struct RspaceStr3 { // algo.RspaceStr3
    enum { ch_max = 3 };
    u8 ch[3];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr3 &rhs) const;
    bool operator !=(const algo::RspaceStr3 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr3& parent) __attribute__((nothrow));
    RspaceStr3(const algo::RspaceStr3 &rhs) __attribute__((nothrow));
    RspaceStr3(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr3();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr3& parent) __attribute__((nothrow));
u32                  RspaceStr3_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr3 &parent) __attribute__((nothrow));
// always return constant 3
int                  ch_Max(algo::RspaceStr3& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr3& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr3& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr3& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr3& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr3_Hash(u32 prev, algo::RspaceStr3 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr3 from an ascii string.
// The format of the string is the format of the algo::RspaceStr3's only field
bool                 RspaceStr3_ReadStrptrMaybe(algo::RspaceStr3 &parent, algo::strptr in_str);
i32                  RspaceStr3_Cmp(algo::RspaceStr3 lhs, algo::RspaceStr3 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr3_Init(algo::RspaceStr3& parent);
bool                 RspaceStr3_Eq(algo::RspaceStr3 lhs, algo::RspaceStr3 rhs) __attribute__((nothrow));
bool                 RspaceStr3_EqStrptr(algo::RspaceStr3 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr3 to string LHS, no header -- cprint:algo.RspaceStr3.String
void                 RspaceStr3_Print(algo::RspaceStr3 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr31
#pragma pack(push,1)
struct RspaceStr31 { // algo.RspaceStr31
    enum { ch_max = 31 };
    u8 ch[31];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr31 &rhs) const;
    bool operator !=(const algo::RspaceStr31 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr31& parent) __attribute__((nothrow));
    RspaceStr31(const algo::RspaceStr31 &rhs) __attribute__((nothrow));
    RspaceStr31(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr31();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr31& parent) __attribute__((nothrow));
u32                  RspaceStr31_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr31 &parent) __attribute__((nothrow));
// always return constant 31
int                  ch_Max(algo::RspaceStr31& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr31& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr31& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr31& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr31& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr31_Hash(u32 prev, const algo::RspaceStr31 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr31 from an ascii string.
// The format of the string is the format of the algo::RspaceStr31's only field
bool                 RspaceStr31_ReadStrptrMaybe(algo::RspaceStr31 &parent, algo::strptr in_str);
i32                  RspaceStr31_Cmp(algo::RspaceStr31 & lhs, algo::RspaceStr31 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr31_Init(algo::RspaceStr31& parent);
bool                 RspaceStr31_Eq(const algo::RspaceStr31 & lhs,const algo::RspaceStr31 & rhs) __attribute__((nothrow));
bool                 RspaceStr31_EqStrptr(algo::RspaceStr31 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr31 to string LHS, no header -- cprint:algo.RspaceStr31.String
void                 RspaceStr31_Print(algo::RspaceStr31 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr32
#pragma pack(push,1)
struct RspaceStr32 { // algo.RspaceStr32
    enum { ch_max = 32 };
    u8 ch[32];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr32 &rhs) const;
    bool operator !=(const algo::RspaceStr32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr32& parent) __attribute__((nothrow));
    RspaceStr32(const algo::RspaceStr32 &rhs) __attribute__((nothrow));
    RspaceStr32(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr32();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr32& parent) __attribute__((nothrow));
u32                  RspaceStr32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr32 &parent) __attribute__((nothrow));
// always return constant 32
int                  ch_Max(algo::RspaceStr32& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr32& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr32_Hash(u32 prev, algo::RspaceStr32 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr32 from an ascii string.
// The format of the string is the format of the algo::RspaceStr32's only field
bool                 RspaceStr32_ReadStrptrMaybe(algo::RspaceStr32 &parent, algo::strptr in_str);
i32                  RspaceStr32_Cmp(algo::RspaceStr32 lhs, algo::RspaceStr32 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr32_Init(algo::RspaceStr32& parent);
bool                 RspaceStr32_Eq(algo::RspaceStr32 lhs, algo::RspaceStr32 rhs) __attribute__((nothrow));
bool                 RspaceStr32_EqStrptr(algo::RspaceStr32 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr32 to string LHS, no header -- cprint:algo.RspaceStr32.String
void                 RspaceStr32_Print(algo::RspaceStr32 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr4
#pragma pack(push,1)
struct RspaceStr4 { // algo.RspaceStr4
    enum { ch_max = 4 };
    u8 ch[4];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr4 &rhs) const;
    bool operator !=(const algo::RspaceStr4 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr4& parent) __attribute__((nothrow));
    RspaceStr4(const algo::RspaceStr4 &rhs) __attribute__((nothrow));
    RspaceStr4(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr4();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr4& parent) __attribute__((nothrow));
u32                  RspaceStr4_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr4 &parent) __attribute__((nothrow));
// always return constant 4
int                  ch_Max(algo::RspaceStr4& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr4& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr4& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr4& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr4& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr4_Hash(u32 prev, algo::RspaceStr4 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr4 from an ascii string.
// The format of the string is the format of the algo::RspaceStr4's only field
bool                 RspaceStr4_ReadStrptrMaybe(algo::RspaceStr4 &parent, algo::strptr in_str);
i32                  RspaceStr4_Cmp(algo::RspaceStr4 lhs, algo::RspaceStr4 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr4_Init(algo::RspaceStr4& parent);
bool                 RspaceStr4_Eq(algo::RspaceStr4 lhs, algo::RspaceStr4 rhs) __attribute__((nothrow));
bool                 RspaceStr4_EqStrptr(algo::RspaceStr4 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr4 to string LHS, no header -- cprint:algo.RspaceStr4.String
void                 RspaceStr4_Print(algo::RspaceStr4 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr40
#pragma pack(push,1)
struct RspaceStr40 { // algo.RspaceStr40
    enum { ch_max = 40 };
    u8 ch[40];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr40& parent) __attribute__((nothrow));
    RspaceStr40(const algo::RspaceStr40 &rhs) __attribute__((nothrow));
    RspaceStr40(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr40();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr40& parent) __attribute__((nothrow));
u32                  RspaceStr40_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr40 &parent) __attribute__((nothrow));
// always return constant 40
int                  ch_Max(algo::RspaceStr40& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr40& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr40& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr40& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr40& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr40_Hash(u32 prev, algo::RspaceStr40 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr40 from an ascii string.
// The format of the string is the format of the algo::RspaceStr40's only field
bool                 RspaceStr40_ReadStrptrMaybe(algo::RspaceStr40 &parent, algo::strptr in_str);
i32                  RspaceStr40_Cmp(algo::RspaceStr40 lhs, algo::RspaceStr40 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr40_Init(algo::RspaceStr40& parent);
bool                 RspaceStr40_Eq(algo::RspaceStr40 lhs, algo::RspaceStr40 rhs) __attribute__((nothrow));
bool                 RspaceStr40_EqStrptr(algo::RspaceStr40 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr40 to string LHS, no header -- cprint:algo.RspaceStr40.String
void                 RspaceStr40_Print(algo::RspaceStr40 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr5
#pragma pack(push,1)
struct RspaceStr5 { // algo.RspaceStr5
    enum { ch_max = 5 };
    u8 ch[5];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr5 &rhs) const;
    bool operator !=(const algo::RspaceStr5 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr5& parent) __attribute__((nothrow));
    RspaceStr5(const algo::RspaceStr5 &rhs) __attribute__((nothrow));
    RspaceStr5(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr5();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr5& parent) __attribute__((nothrow));
u32                  RspaceStr5_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr5 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::RspaceStr5& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr5& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr5& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr5& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr5& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr5_Hash(u32 prev, algo::RspaceStr5 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr5 from an ascii string.
// The format of the string is the format of the algo::RspaceStr5's only field
bool                 RspaceStr5_ReadStrptrMaybe(algo::RspaceStr5 &parent, algo::strptr in_str);
i32                  RspaceStr5_Cmp(algo::RspaceStr5 lhs, algo::RspaceStr5 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr5_Init(algo::RspaceStr5& parent);
bool                 RspaceStr5_Eq(algo::RspaceStr5 lhs, algo::RspaceStr5 rhs) __attribute__((nothrow));
bool                 RspaceStr5_EqStrptr(algo::RspaceStr5 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr5 to string LHS, no header -- cprint:algo.RspaceStr5.String
void                 RspaceStr5_Print(algo::RspaceStr5 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr50
#pragma pack(push,1)
struct RspaceStr50 { // algo.RspaceStr50
    enum { ch_max = 50 };
    u8 ch[50];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr50 &rhs) const;
    bool operator !=(const algo::RspaceStr50 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr50& parent) __attribute__((nothrow));
    RspaceStr50(const algo::RspaceStr50 &rhs) __attribute__((nothrow));
    RspaceStr50(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr50();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr50& parent) __attribute__((nothrow));
u32                  RspaceStr50_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr50 &parent) __attribute__((nothrow));
// always return constant 50
int                  ch_Max(algo::RspaceStr50& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr50& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr50& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr50& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr50& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr50_Hash(u32 prev, algo::RspaceStr50 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr50 from an ascii string.
// The format of the string is the format of the algo::RspaceStr50's only field
bool                 RspaceStr50_ReadStrptrMaybe(algo::RspaceStr50 &parent, algo::strptr in_str);
i32                  RspaceStr50_Cmp(algo::RspaceStr50 lhs, algo::RspaceStr50 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr50_Init(algo::RspaceStr50& parent);
bool                 RspaceStr50_Eq(algo::RspaceStr50 lhs, algo::RspaceStr50 rhs) __attribute__((nothrow));
bool                 RspaceStr50_EqStrptr(algo::RspaceStr50 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr50 to string LHS, no header -- cprint:algo.RspaceStr50.String
void                 RspaceStr50_Print(algo::RspaceStr50 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr6
#pragma pack(push,1)
struct RspaceStr6 { // algo.RspaceStr6
    enum { ch_max = 6 };
    u8 ch[6];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr6 &rhs) const;
    bool operator !=(const algo::RspaceStr6 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::RspaceStr6 &rhs) const;
    bool operator >(const algo::RspaceStr6 &rhs) const;
    bool operator <=(const algo::RspaceStr6 &rhs) const;
    bool operator >=(const algo::RspaceStr6 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr6& parent) __attribute__((nothrow));
    RspaceStr6(const algo::RspaceStr6 &rhs) __attribute__((nothrow));
    RspaceStr6(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr6();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr6& parent) __attribute__((nothrow));
u32                  RspaceStr6_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr6 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(algo::RspaceStr6& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr6& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr6& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr6& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr6& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr6_Hash(u32 prev, algo::RspaceStr6 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr6 from an ascii string.
// The format of the string is the format of the algo::RspaceStr6's only field
bool                 RspaceStr6_ReadStrptrMaybe(algo::RspaceStr6 &parent, algo::strptr in_str);
bool                 RspaceStr6_Lt(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) __attribute__((nothrow));
i32                  RspaceStr6_Cmp(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr6_Init(algo::RspaceStr6& parent);
bool                 RspaceStr6_Eq(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RspaceStr6_Update(algo::RspaceStr6 &lhs, algo::RspaceStr6 rhs) __attribute__((nothrow));
bool                 RspaceStr6_EqStrptr(algo::RspaceStr6 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr6 to string LHS, no header -- cprint:algo.RspaceStr6.String
void                 RspaceStr6_Print(algo::RspaceStr6 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr64
#pragma pack(push,1)
struct RspaceStr64 { // algo.RspaceStr64
    enum { ch_max = 64 };
    u8 ch[64];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr64 &rhs) const;
    bool operator !=(const algo::RspaceStr64 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr64& parent) __attribute__((nothrow));
    RspaceStr64(const algo::RspaceStr64 &rhs) __attribute__((nothrow));
    RspaceStr64(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr64();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr64& parent) __attribute__((nothrow));
u32                  RspaceStr64_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr64 &parent) __attribute__((nothrow));
// always return constant 64
int                  ch_Max(algo::RspaceStr64& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr64& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr64& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr64& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr64& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr64_Hash(u32 prev, const algo::RspaceStr64 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr64 from an ascii string.
// The format of the string is the format of the algo::RspaceStr64's only field
bool                 RspaceStr64_ReadStrptrMaybe(algo::RspaceStr64 &parent, algo::strptr in_str);
i32                  RspaceStr64_Cmp(algo::RspaceStr64 & lhs, algo::RspaceStr64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr64_Init(algo::RspaceStr64& parent);
bool                 RspaceStr64_Eq(const algo::RspaceStr64 & lhs,const algo::RspaceStr64 & rhs) __attribute__((nothrow));
bool                 RspaceStr64_EqStrptr(algo::RspaceStr64 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr64 to string LHS, no header -- cprint:algo.RspaceStr64.String
void                 RspaceStr64_Print(algo::RspaceStr64 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr7
struct RspaceStr7 { // algo.RspaceStr7
    enum { ch_max = 7 };
    u8 ch[7];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr7 &rhs) const;
    bool operator !=(const algo::RspaceStr7 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr7& parent) __attribute__((nothrow));
    RspaceStr7(const algo::RspaceStr7 &rhs) __attribute__((nothrow));
    RspaceStr7(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr7();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr7& parent) __attribute__((nothrow));
u32                  RspaceStr7_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr7 &parent) __attribute__((nothrow));
// always return constant 7
int                  ch_Max(algo::RspaceStr7& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr7& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr7& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr7& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr7& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr7_Hash(u32 prev, algo::RspaceStr7 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr7 from an ascii string.
// The format of the string is the format of the algo::RspaceStr7's only field
bool                 RspaceStr7_ReadStrptrMaybe(algo::RspaceStr7 &parent, algo::strptr in_str);
i32                  RspaceStr7_Cmp(algo::RspaceStr7 lhs, algo::RspaceStr7 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr7_Init(algo::RspaceStr7& parent);
bool                 RspaceStr7_Eq(algo::RspaceStr7 lhs, algo::RspaceStr7 rhs) __attribute__((nothrow));
bool                 RspaceStr7_EqStrptr(algo::RspaceStr7 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr7 to string LHS, no header -- cprint:algo.RspaceStr7.String
void                 RspaceStr7_Print(algo::RspaceStr7 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr75
#pragma pack(push,1)
struct RspaceStr75 { // algo.RspaceStr75
    enum { ch_max = 75 };
    u8 ch[75];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr75 &rhs) const;
    bool operator !=(const algo::RspaceStr75 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr75& parent) __attribute__((nothrow));
    RspaceStr75(const algo::RspaceStr75 &rhs) __attribute__((nothrow));
    RspaceStr75(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr75();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr75& parent) __attribute__((nothrow));
u32                  RspaceStr75_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr75 &parent) __attribute__((nothrow));
// always return constant 75
int                  ch_Max(algo::RspaceStr75& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr75& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr75& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr75& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr75& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr75_Hash(u32 prev, algo::RspaceStr75 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr75 from an ascii string.
// The format of the string is the format of the algo::RspaceStr75's only field
bool                 RspaceStr75_ReadStrptrMaybe(algo::RspaceStr75 &parent, algo::strptr in_str);
i32                  RspaceStr75_Cmp(algo::RspaceStr75 lhs, algo::RspaceStr75 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr75_Init(algo::RspaceStr75& parent);
bool                 RspaceStr75_Eq(algo::RspaceStr75 lhs, algo::RspaceStr75 rhs) __attribute__((nothrow));
bool                 RspaceStr75_EqStrptr(algo::RspaceStr75 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr75 to string LHS, no header -- cprint:algo.RspaceStr75.String
void                 RspaceStr75_Print(algo::RspaceStr75 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr8
#pragma pack(push,1)
struct RspaceStr8 { // algo.RspaceStr8
    enum { ch_max = 8 };
    u8 ch[8];
    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr8& parent) __attribute__((nothrow));
    RspaceStr8(const algo::RspaceStr8 &rhs) __attribute__((nothrow));
    RspaceStr8(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr8();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr8& parent) __attribute__((nothrow));
u32                  RspaceStr8_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr8 &parent) __attribute__((nothrow));
// always return constant 8
int                  ch_Max(algo::RspaceStr8& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr8& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr8& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr8& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr8& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr8_Hash(u32 prev, algo::RspaceStr8 rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr8 from an ascii string.
// The format of the string is the format of the algo::RspaceStr8's only field
bool                 RspaceStr8_ReadStrptrMaybe(algo::RspaceStr8 &parent, algo::strptr in_str);
bool                 RspaceStr8_Lt(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) __attribute__((nothrow));
i32                  RspaceStr8_Cmp(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr8_Init(algo::RspaceStr8& parent);
bool                 RspaceStr8_Eq(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RspaceStr8_Update(algo::RspaceStr8 &lhs, algo::RspaceStr8 rhs) __attribute__((nothrow));
bool                 RspaceStr8_EqStrptr(algo::RspaceStr8 lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr8 to string LHS, no header -- cprint:algo.RspaceStr8.String
void                 RspaceStr8_Print(algo::RspaceStr8 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.RspaceStr9
#pragma pack(push,1)
struct RspaceStr9 { // algo.RspaceStr9
    enum { ch_max = 9 };
    u8 ch[9];
    inline operator algo::strptr() const;
    bool operator ==(const algo::RspaceStr9 &rhs) const;
    bool operator !=(const algo::RspaceStr9 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::RspaceStr9& parent) __attribute__((nothrow));
    RspaceStr9(const algo::RspaceStr9 &rhs) __attribute__((nothrow));
    RspaceStr9(const algo::strptr &rhs) __attribute__((nothrow));
    RspaceStr9();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::RspaceStr9& parent) __attribute__((nothrow));
u32                  RspaceStr9_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::RspaceStr9 &parent) __attribute__((nothrow));
// always return constant 9
int                  ch_Max(algo::RspaceStr9& parent) __attribute__((nothrow));
int                  ch_N(const algo::RspaceStr9& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::RspaceStr9& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::RspaceStr9& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::RspaceStr9& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  RspaceStr9_Hash(u32 prev, const algo::RspaceStr9 & rhs) __attribute__((nothrow));
// Read fields of algo::RspaceStr9 from an ascii string.
// The format of the string is the format of the algo::RspaceStr9's only field
bool                 RspaceStr9_ReadStrptrMaybe(algo::RspaceStr9 &parent, algo::strptr in_str);
i32                  RspaceStr9_Cmp(algo::RspaceStr9 & lhs, algo::RspaceStr9 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RspaceStr9_Init(algo::RspaceStr9& parent);
bool                 RspaceStr9_Eq(const algo::RspaceStr9 & lhs,const algo::RspaceStr9 & rhs) __attribute__((nothrow));
bool                 RspaceStr9_EqStrptr(algo::RspaceStr9 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::RspaceStr9 to string LHS, no header -- cprint:algo.RspaceStr9.String
void                 RspaceStr9_Print(algo::RspaceStr9 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.SeqType
#pragma pack(push,1)
struct SeqType { // algo.SeqType
    u64   value;   //   0
    inline operator u64() const;
    explicit SeqType(u64                            in_value);
    SeqType();
};
#pragma pack(pop)

u32                  SeqType_Hash(u32 prev, algo::SeqType rhs) __attribute__((nothrow));
// Read fields of algo::SeqType from an ascii string.
// The format of the string is the format of the algo::SeqType's only field
bool                 SeqType_ReadStrptrMaybe(algo::SeqType &parent, algo::strptr in_str);
bool                 SeqType_Lt(algo::SeqType lhs, algo::SeqType rhs) __attribute__((nothrow));
i32                  SeqType_Cmp(algo::SeqType lhs, algo::SeqType rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 SeqType_Init(algo::SeqType& parent);
bool                 SeqType_Eq(algo::SeqType lhs, algo::SeqType rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 SeqType_Update(algo::SeqType &lhs, algo::SeqType rhs) __attribute__((nothrow));
// print string representation of algo::SeqType to string LHS, no header -- cprint:algo.SeqType.String
void                 SeqType_Print(algo::SeqType row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Sha1sig
struct Sha1sig { // algo.Sha1sig
    u8   sha1sig_elems[20];   //   0  fixed array
    bool operator ==(const algo::Sha1sig &rhs) const;
    bool operator !=(const algo::Sha1sig &rhs) const;
    bool operator <(const algo::Sha1sig &rhs) const;
    bool operator >(const algo::Sha1sig &rhs) const;
    bool operator <=(const algo::Sha1sig &rhs) const;
    bool operator >=(const algo::Sha1sig &rhs) const;
    Sha1sig();
};

// Set all elements of fixed array to value RHS
void                 sha1sig_Fill(algo::Sha1sig& parent, const u8 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u8*                  sha1sig_Find(algo::Sha1sig& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array sha1sig as aryptr.
algo::aryptr<u8>     sha1sig_Getary(algo::Sha1sig& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  sha1sig_Max(algo::Sha1sig& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  sha1sig_N(const algo::Sha1sig& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 sha1sig_Setary(algo::Sha1sig& parent, const algo::aryptr<u8> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u8&                  sha1sig_qFind(algo::Sha1sig& parent, u64 t) __attribute__((nothrow));
bool                 sha1sig_Eq(const algo::Sha1sig& parent, const algo::Sha1sig &rhs) __attribute__((nothrow, pure));
int                  sha1sig_Cmp(algo::Sha1sig& parent, algo::Sha1sig &rhs) __attribute__((nothrow));
// Convert sha1sig to a string. Parent's separator is used.
void                 sha1sig_Print(algo::Sha1sig& parent, algo::cstring &lhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
bool                 sha1sig_ReadStrptrMaybe(algo::Sha1sig& parent, algo::strptr in_str) __attribute__((nothrow));

// cursor points to valid item
void                 Sha1sig_sha1sig_curs_Reset(Sha1sig_sha1sig_curs &curs, algo::Sha1sig &parent);
// cursor points to valid item
bool                 Sha1sig_sha1sig_curs_ValidQ(Sha1sig_sha1sig_curs &curs);
// proceed to next item
void                 Sha1sig_sha1sig_curs_Next(Sha1sig_sha1sig_curs &curs);
// item access
u8&                  Sha1sig_sha1sig_curs_Access(Sha1sig_sha1sig_curs &curs);
// Read fields of algo::Sha1sig from an ascii string.
// The function is implemented externally.
bool                 Sha1sig_ReadStrptrMaybe(algo::Sha1sig &parent, algo::strptr in_str);
bool                 Sha1sig_Lt(algo::Sha1sig & lhs, algo::Sha1sig & rhs) __attribute__((nothrow));
i32                  Sha1sig_Cmp(algo::Sha1sig & lhs, algo::Sha1sig & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Sha1sig_Init(algo::Sha1sig& parent);
bool                 Sha1sig_Eq(const algo::Sha1sig & lhs,const algo::Sha1sig & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Sha1sig_Update(algo::Sha1sig &lhs, algo::Sha1sig & rhs) __attribute__((nothrow));
// Convert algo::Sha1sig to a string (user-implemented function)
void                 Sha1sig_Print(algo::Sha1sig & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr1
struct Smallstr1 { // algo.Smallstr1
    enum { ch_max = 1 };
    u8 ch[1+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr1 &rhs) const;
    bool operator !=(const algo::Smallstr1 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr1& parent) __attribute__((nothrow));
    Smallstr1(const algo::Smallstr1 &rhs) __attribute__((nothrow));
    Smallstr1(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr1();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr1& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr1& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr1& parent) __attribute__((nothrow));
u32                  Smallstr1_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr1 &parent) __attribute__((nothrow));
// always return constant 1
int                  ch_Max(algo::Smallstr1& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr1& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr1& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr1& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr1& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr1_Hash(u32 prev, const algo::Smallstr1 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr1 from an ascii string.
// The format of the string is the format of the algo::Smallstr1's only field
bool                 Smallstr1_ReadStrptrMaybe(algo::Smallstr1 &parent, algo::strptr in_str);
i32                  Smallstr1_Cmp(algo::Smallstr1 & lhs, algo::Smallstr1 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr1_Init(algo::Smallstr1& parent);
bool                 Smallstr1_Eq(const algo::Smallstr1 & lhs,const algo::Smallstr1 & rhs) __attribute__((nothrow));
bool                 Smallstr1_EqStrptr(algo::Smallstr1 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr1 to string LHS, no header -- cprint:algo.Smallstr1.String
void                 Smallstr1_Print(algo::Smallstr1 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr10
#pragma pack(push,1)
struct Smallstr10 { // algo.Smallstr10
    enum { ch_max = 10 };
    u8 ch[10+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr10 &rhs) const;
    bool operator !=(const algo::Smallstr10 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr10& parent) __attribute__((nothrow));
    Smallstr10(const algo::Smallstr10 &rhs) __attribute__((nothrow));
    Smallstr10(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr10();
};
#pragma pack(pop)

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr10& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr10& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr10& parent) __attribute__((nothrow));
u32                  Smallstr10_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr10 &parent) __attribute__((nothrow));
// always return constant 10
int                  ch_Max(algo::Smallstr10& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr10& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr10& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr10& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr10& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr10_Hash(u32 prev, const algo::Smallstr10 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr10 from an ascii string.
// The format of the string is the format of the algo::Smallstr10's only field
bool                 Smallstr10_ReadStrptrMaybe(algo::Smallstr10 &parent, algo::strptr in_str);
i32                  Smallstr10_Cmp(algo::Smallstr10 & lhs, algo::Smallstr10 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr10_Init(algo::Smallstr10& parent);
bool                 Smallstr10_Eq(const algo::Smallstr10 & lhs,const algo::Smallstr10 & rhs) __attribute__((nothrow));
bool                 Smallstr10_EqStrptr(algo::Smallstr10 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr10 to string LHS, no header -- cprint:algo.Smallstr10.String
void                 Smallstr10_Print(algo::Smallstr10 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr100
#pragma pack(push,1)
struct Smallstr100 { // algo.Smallstr100
    enum { ch_max = 100 };
    u8 ch[100+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr100& parent) __attribute__((nothrow));
    Smallstr100(const algo::Smallstr100 &rhs) __attribute__((nothrow));
    Smallstr100(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr100();
};
#pragma pack(pop)

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr100& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr100& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr100& parent) __attribute__((nothrow));
u32                  Smallstr100_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr100 &parent) __attribute__((nothrow));
// always return constant 100
int                  ch_Max(algo::Smallstr100& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr100& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr100& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr100& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr100& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr100_Hash(u32 prev, const algo::Smallstr100 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr100 from an ascii string.
// The format of the string is the format of the algo::Smallstr100's only field
bool                 Smallstr100_ReadStrptrMaybe(algo::Smallstr100 &parent, algo::strptr in_str);
i32                  Smallstr100_Cmp(algo::Smallstr100 & lhs, algo::Smallstr100 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr100_Init(algo::Smallstr100& parent);
bool                 Smallstr100_Eq(const algo::Smallstr100 & lhs,const algo::Smallstr100 & rhs) __attribute__((nothrow));
bool                 Smallstr100_EqStrptr(algo::Smallstr100 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr100 to string LHS, no header -- cprint:algo.Smallstr100.String
void                 Smallstr100_Print(algo::Smallstr100 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr16
struct Smallstr16 { // algo.Smallstr16
    enum { ch_max = 16 };
    u8 ch[16+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr16 &rhs) const;
    bool operator !=(const algo::Smallstr16 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr16& parent) __attribute__((nothrow));
    Smallstr16(const algo::Smallstr16 &rhs) __attribute__((nothrow));
    Smallstr16(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr16();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr16& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr16& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr16& parent) __attribute__((nothrow));
u32                  Smallstr16_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr16 &parent) __attribute__((nothrow));
// always return constant 16
int                  ch_Max(algo::Smallstr16& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr16& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr16& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr16& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr16& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr16_Hash(u32 prev, const algo::Smallstr16 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr16 from an ascii string.
// The format of the string is the format of the algo::Smallstr16's only field
bool                 Smallstr16_ReadStrptrMaybe(algo::Smallstr16 &parent, algo::strptr in_str);
i32                  Smallstr16_Cmp(algo::Smallstr16 & lhs, algo::Smallstr16 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr16_Init(algo::Smallstr16& parent);
bool                 Smallstr16_Eq(const algo::Smallstr16 & lhs,const algo::Smallstr16 & rhs) __attribute__((nothrow));
bool                 Smallstr16_EqStrptr(algo::Smallstr16 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr16 to string LHS, no header -- cprint:algo.Smallstr16.String
void                 Smallstr16_Print(algo::Smallstr16 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr2
struct Smallstr2 { // algo.Smallstr2
    enum { ch_max = 2 };
    u8 ch[2+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr2 &rhs) const;
    bool operator !=(const algo::Smallstr2 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr2& parent) __attribute__((nothrow));
    Smallstr2(const algo::Smallstr2 &rhs) __attribute__((nothrow));
    Smallstr2(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr2();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr2& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr2& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr2& parent) __attribute__((nothrow));
u32                  Smallstr2_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr2 &parent) __attribute__((nothrow));
// always return constant 2
int                  ch_Max(algo::Smallstr2& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr2& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr2& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr2& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr2& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr2_Hash(u32 prev, const algo::Smallstr2 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr2 from an ascii string.
// The format of the string is the format of the algo::Smallstr2's only field
bool                 Smallstr2_ReadStrptrMaybe(algo::Smallstr2 &parent, algo::strptr in_str);
i32                  Smallstr2_Cmp(algo::Smallstr2 & lhs, algo::Smallstr2 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr2_Init(algo::Smallstr2& parent);
bool                 Smallstr2_Eq(const algo::Smallstr2 & lhs,const algo::Smallstr2 & rhs) __attribute__((nothrow));
bool                 Smallstr2_EqStrptr(algo::Smallstr2 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr2 to string LHS, no header -- cprint:algo.Smallstr2.String
void                 Smallstr2_Print(algo::Smallstr2 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr20
#pragma pack(push,1)
struct Smallstr20 { // algo.Smallstr20
    enum { ch_max = 20 };
    u8 ch[20+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr20 &rhs) const;
    bool operator !=(const algo::Smallstr20 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::Smallstr20 &rhs) const;
    bool operator >(const algo::Smallstr20 &rhs) const;
    bool operator <=(const algo::Smallstr20 &rhs) const;
    bool operator >=(const algo::Smallstr20 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr20& parent) __attribute__((nothrow));
    Smallstr20(const algo::Smallstr20 &rhs) __attribute__((nothrow));
    Smallstr20(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr20();
};
#pragma pack(pop)

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr20& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr20& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr20& parent) __attribute__((nothrow));
u32                  Smallstr20_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr20 &parent) __attribute__((nothrow));
// always return constant 20
int                  ch_Max(algo::Smallstr20& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr20& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr20& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr20& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr20& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr20_Hash(u32 prev, const algo::Smallstr20 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr20 from an ascii string.
// The format of the string is the format of the algo::Smallstr20's only field
bool                 Smallstr20_ReadStrptrMaybe(algo::Smallstr20 &parent, algo::strptr in_str);
bool                 Smallstr20_Lt(algo::Smallstr20 & lhs, algo::Smallstr20 & rhs) __attribute__((nothrow));
i32                  Smallstr20_Cmp(algo::Smallstr20 & lhs, algo::Smallstr20 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr20_Init(algo::Smallstr20& parent);
bool                 Smallstr20_Eq(const algo::Smallstr20 & lhs,const algo::Smallstr20 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Smallstr20_Update(algo::Smallstr20 &lhs, algo::Smallstr20 & rhs) __attribute__((nothrow));
bool                 Smallstr20_EqStrptr(algo::Smallstr20 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr20 to string LHS, no header -- cprint:algo.Smallstr20.String
void                 Smallstr20_Print(algo::Smallstr20 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr25
struct Smallstr25 { // algo.Smallstr25
    enum { ch_max = 25 };
    u8 ch[25+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr25 &rhs) const;
    bool operator !=(const algo::Smallstr25 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr25& parent) __attribute__((nothrow));
    Smallstr25(const algo::Smallstr25 &rhs) __attribute__((nothrow));
    Smallstr25(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr25();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr25& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr25& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr25& parent) __attribute__((nothrow));
u32                  Smallstr25_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr25 &parent) __attribute__((nothrow));
// always return constant 25
int                  ch_Max(algo::Smallstr25& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr25& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr25& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr25& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr25& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr25_Hash(u32 prev, const algo::Smallstr25 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr25 from an ascii string.
// The format of the string is the format of the algo::Smallstr25's only field
bool                 Smallstr25_ReadStrptrMaybe(algo::Smallstr25 &parent, algo::strptr in_str);
i32                  Smallstr25_Cmp(algo::Smallstr25 & lhs, algo::Smallstr25 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr25_Init(algo::Smallstr25& parent);
bool                 Smallstr25_Eq(const algo::Smallstr25 & lhs,const algo::Smallstr25 & rhs) __attribute__((nothrow));
bool                 Smallstr25_EqStrptr(algo::Smallstr25 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr25 to string LHS, no header -- cprint:algo.Smallstr25.String
void                 Smallstr25_Print(algo::Smallstr25 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr3
struct Smallstr3 { // algo.Smallstr3
    enum { ch_max = 3 };
    u8 ch[3+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr3 &rhs) const;
    bool operator !=(const algo::Smallstr3 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr3& parent) __attribute__((nothrow));
    Smallstr3(const algo::Smallstr3 &rhs) __attribute__((nothrow));
    Smallstr3(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr3();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr3& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr3& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr3& parent) __attribute__((nothrow));
u32                  Smallstr3_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr3 &parent) __attribute__((nothrow));
// always return constant 3
int                  ch_Max(algo::Smallstr3& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr3& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr3& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr3& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr3& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr3_Hash(u32 prev, const algo::Smallstr3 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr3 from an ascii string.
// The format of the string is the format of the algo::Smallstr3's only field
bool                 Smallstr3_ReadStrptrMaybe(algo::Smallstr3 &parent, algo::strptr in_str);
i32                  Smallstr3_Cmp(algo::Smallstr3 & lhs, algo::Smallstr3 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr3_Init(algo::Smallstr3& parent);
bool                 Smallstr3_Eq(const algo::Smallstr3 & lhs,const algo::Smallstr3 & rhs) __attribute__((nothrow));
bool                 Smallstr3_EqStrptr(algo::Smallstr3 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr3 to string LHS, no header -- cprint:algo.Smallstr3.String
void                 Smallstr3_Print(algo::Smallstr3 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr30
struct Smallstr30 { // algo.Smallstr30
    enum { ch_max = 30 };
    u8 ch[30+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr30 &rhs) const;
    bool operator !=(const algo::Smallstr30 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const algo::Smallstr30 &rhs) const;
    bool operator >(const algo::Smallstr30 &rhs) const;
    bool operator <=(const algo::Smallstr30 &rhs) const;
    bool operator >=(const algo::Smallstr30 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr30& parent) __attribute__((nothrow));
    Smallstr30(const algo::Smallstr30 &rhs) __attribute__((nothrow));
    Smallstr30(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr30();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr30& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr30& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr30& parent) __attribute__((nothrow));
u32                  Smallstr30_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr30 &parent) __attribute__((nothrow));
// always return constant 30
int                  ch_Max(algo::Smallstr30& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr30& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr30& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr30& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr30& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr30_Hash(u32 prev, const algo::Smallstr30 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr30 from an ascii string.
// The format of the string is the format of the algo::Smallstr30's only field
bool                 Smallstr30_ReadStrptrMaybe(algo::Smallstr30 &parent, algo::strptr in_str);
bool                 Smallstr30_Lt(algo::Smallstr30 & lhs, algo::Smallstr30 & rhs) __attribute__((nothrow));
i32                  Smallstr30_Cmp(algo::Smallstr30 & lhs, algo::Smallstr30 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr30_Init(algo::Smallstr30& parent);
bool                 Smallstr30_Eq(const algo::Smallstr30 & lhs,const algo::Smallstr30 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Smallstr30_Update(algo::Smallstr30 &lhs, algo::Smallstr30 & rhs) __attribute__((nothrow));
bool                 Smallstr30_EqStrptr(algo::Smallstr30 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr30 to string LHS, no header -- cprint:algo.Smallstr30.String
void                 Smallstr30_Print(algo::Smallstr30 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr32
#pragma pack(push,1)
struct Smallstr32 { // algo.Smallstr32
    enum { ch_max = 32 };
    u8 ch[32+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr32 &rhs) const;
    bool operator !=(const algo::Smallstr32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr32& parent) __attribute__((nothrow));
    Smallstr32(const algo::Smallstr32 &rhs) __attribute__((nothrow));
    Smallstr32(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr32();
};
#pragma pack(pop)

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr32& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr32& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr32& parent) __attribute__((nothrow));
u32                  Smallstr32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr32 &parent) __attribute__((nothrow));
// always return constant 32
int                  ch_Max(algo::Smallstr32& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr32& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr32_Hash(u32 prev, const algo::Smallstr32 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr32 from an ascii string.
// The format of the string is the format of the algo::Smallstr32's only field
bool                 Smallstr32_ReadStrptrMaybe(algo::Smallstr32 &parent, algo::strptr in_str);
i32                  Smallstr32_Cmp(algo::Smallstr32 & lhs, algo::Smallstr32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr32_Init(algo::Smallstr32& parent);
bool                 Smallstr32_Eq(const algo::Smallstr32 & lhs,const algo::Smallstr32 & rhs) __attribute__((nothrow));
bool                 Smallstr32_EqStrptr(algo::Smallstr32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr32 to string LHS, no header -- cprint:algo.Smallstr32.String
void                 Smallstr32_Print(algo::Smallstr32 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr4
struct Smallstr4 { // algo.Smallstr4
    enum { ch_max = 4 };
    u8 ch[4+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr4 &rhs) const;
    bool operator !=(const algo::Smallstr4 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr4& parent) __attribute__((nothrow));
    Smallstr4(const algo::Smallstr4 &rhs) __attribute__((nothrow));
    Smallstr4(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr4();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr4& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr4& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr4& parent) __attribute__((nothrow));
u32                  Smallstr4_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr4 &parent) __attribute__((nothrow));
// always return constant 4
int                  ch_Max(algo::Smallstr4& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr4& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr4& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr4& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr4& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr4_Hash(u32 prev, const algo::Smallstr4 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr4 from an ascii string.
// The format of the string is the format of the algo::Smallstr4's only field
bool                 Smallstr4_ReadStrptrMaybe(algo::Smallstr4 &parent, algo::strptr in_str);
i32                  Smallstr4_Cmp(algo::Smallstr4 & lhs, algo::Smallstr4 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr4_Init(algo::Smallstr4& parent);
bool                 Smallstr4_Eq(const algo::Smallstr4 & lhs,const algo::Smallstr4 & rhs) __attribute__((nothrow));
bool                 Smallstr4_EqStrptr(algo::Smallstr4 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr4 to string LHS, no header -- cprint:algo.Smallstr4.String
void                 Smallstr4_Print(algo::Smallstr4 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr40
struct Smallstr40 { // algo.Smallstr40
    enum { ch_max = 40 };
    u8 ch[40+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr40 &rhs) const;
    bool operator !=(const algo::Smallstr40 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr40& parent) __attribute__((nothrow));
    Smallstr40(const algo::Smallstr40 &rhs) __attribute__((nothrow));
    Smallstr40(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr40();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr40& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr40& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr40& parent) __attribute__((nothrow));
u32                  Smallstr40_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr40 &parent) __attribute__((nothrow));
// always return constant 40
int                  ch_Max(algo::Smallstr40& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr40& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr40& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr40& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr40& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr40_Hash(u32 prev, const algo::Smallstr40 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr40 from an ascii string.
// The format of the string is the format of the algo::Smallstr40's only field
bool                 Smallstr40_ReadStrptrMaybe(algo::Smallstr40 &parent, algo::strptr in_str);
i32                  Smallstr40_Cmp(algo::Smallstr40 & lhs, algo::Smallstr40 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr40_Init(algo::Smallstr40& parent);
bool                 Smallstr40_Eq(const algo::Smallstr40 & lhs,const algo::Smallstr40 & rhs) __attribute__((nothrow));
bool                 Smallstr40_EqStrptr(algo::Smallstr40 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr40 to string LHS, no header -- cprint:algo.Smallstr40.String
void                 Smallstr40_Print(algo::Smallstr40 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.Smallstr5
struct Smallstr5 { // algo.Smallstr5
    enum { ch_max = 5 };
    u8 ch[5+1];
    u8 n_ch;

    inline operator algo::strptr() const;
    bool operator ==(const algo::Smallstr5 &rhs) const;
    bool operator !=(const algo::Smallstr5 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const algo::Smallstr5& parent) __attribute__((nothrow));
    Smallstr5(const algo::Smallstr5 &rhs) __attribute__((nothrow));
    Smallstr5(const algo::strptr &rhs) __attribute__((nothrow));
    Smallstr5();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(algo::Smallstr5& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(algo::Smallstr5& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const algo::Smallstr5& parent) __attribute__((nothrow));
u32                  Smallstr5_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(algo::Smallstr5 &parent) __attribute__((nothrow));
// always return constant 5
int                  ch_Max(algo::Smallstr5& parent) __attribute__((nothrow));
int                  ch_N(const algo::Smallstr5& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(algo::Smallstr5& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(algo::Smallstr5& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(algo::Smallstr5& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Smallstr5_Hash(u32 prev, const algo::Smallstr5 & rhs) __attribute__((nothrow));
// Read fields of algo::Smallstr5 from an ascii string.
// The format of the string is the format of the algo::Smallstr5's only field
bool                 Smallstr5_ReadStrptrMaybe(algo::Smallstr5 &parent, algo::strptr in_str);
i32                  Smallstr5_Cmp(algo::Smallstr5 & lhs, algo::Smallstr5 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Smallstr5_Init(algo::Smallstr5& parent);
bool                 Smallstr5_Eq(const algo::Smallstr5 & lhs,const algo::Smallstr5 & rhs) __attribute__((nothrow));
bool                 Smallstr5_EqStrptr(algo::Smallstr5 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of algo::Smallstr5 to string LHS, no header -- cprint:algo.Smallstr5.String
void                 Smallstr5_Print(algo::Smallstr5 & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.TermStyle
struct TermStyle { // algo.TermStyle
    u32   value;   //   0
    inline operator algo_TermStyleEnum() const;
    explicit TermStyle(u32                            in_value);
    TermStyle(algo_TermStyleEnum arg);
    TermStyle();
};

// Get value of field as enum type
algo_TermStyleEnum   value_GetEnum(const algo::TermStyle& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::TermStyle& parent, algo_TermStyleEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::TermStyle& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::TermStyle& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::TermStyle& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::TermStyle& parent, algo::strptr rhs, algo_TermStyleEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(algo::TermStyle& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of algo::TermStyle from an ascii string.
// The format of the string is the format of the algo::TermStyle's only field
bool                 TermStyle_ReadStrptrMaybe(algo::TermStyle &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TermStyle_Init(algo::TermStyle& parent);
// print string representation of algo::TermStyle to string LHS, no header -- cprint:algo.TermStyle.String
void                 TermStyle_Print(algo::TermStyle row, algo::cstring &str) __attribute__((nothrow));

// --- algo.TextJust
struct TextJust { // algo.TextJust
    i32   value;   //   0
    inline operator algo_TextJustEnum() const;
    explicit TextJust(i32                            in_value);
    TextJust(algo_TextJustEnum arg);
    TextJust();
};

// Get value of field as enum type
algo_TextJustEnum    value_GetEnum(const algo::TextJust& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(algo::TextJust& parent, algo_TextJustEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const algo::TextJust& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const algo::TextJust& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(algo::TextJust& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(algo::TextJust& parent, algo::strptr rhs, algo_TextJustEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(algo::TextJust& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of algo::TextJust from an ascii string.
// The format of the string is the format of the algo::TextJust's only field
bool                 TextJust_ReadStrptrMaybe(algo::TextJust &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TextJust_Init(algo::TextJust& parent);
// print string representation of algo::TextJust to string LHS, no header -- cprint:algo.TextJust.String
void                 TextJust_Print(algo::TextJust row, algo::cstring &str) __attribute__((nothrow));

// --- algo.TstampCache
struct TstampCache { // algo.TstampCache
    algo::UnTime    valid_beg;       //
    algo::UnTime    valid_end;       //
    algo::cstring   cached;          //
    algo::cstring   spec;            //
    i8              sec_location;    //   0
    i8              min_location;    //   0
    i8              nano_location;   //   0
    i8              nano_size;       //   0
    bool            cacheable;       //   false
    bool            gmtQ;            //   false
    TstampCache();
};

// Set all fields to initial values.
void                 TstampCache_Init(algo::TstampCache& parent);

// --- algo.Tuple
struct Tuple { // algo.Tuple
    algo::Attr*   attrs_elems;   // pointer to elements
    u32           attrs_n;       // number of elements in array
    u32           attrs_max;     // max. capacity of array before realloc
    algo::Attr    head;          //
    Tuple();
    ~Tuple();
private:
    // reftype Tary of algo.Tuple.attrs prohibits copy
    Tuple(const Tuple&){ /*disallow copy constructor */}
    void operator =(const Tuple&){ /*disallow direct assignment */}
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<algo::Attr> attrs_Addary(algo::Tuple& parent, algo::aryptr<algo::Attr> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::Attr&          attrs_Alloc(algo::Tuple& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::Attr&          attrs_AllocAt(algo::Tuple& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::Attr> attrs_AllocN(algo::Tuple& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 attrs_EmptyQ(algo::Tuple& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::Attr*          attrs_Find(algo::Tuple& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::Attr> attrs_Getary(algo::Tuple& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::Attr*          attrs_Last(algo::Tuple& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  attrs_Max(algo::Tuple& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  attrs_N(const algo::Tuple& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 attrs_Remove(algo::Tuple& parent, u32 i) __attribute__((nothrow));
void                 attrs_RemoveAll(algo::Tuple& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 attrs_RemoveLast(algo::Tuple& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 attrs_Reserve(algo::Tuple& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 attrs_AbsReserve(algo::Tuple& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 attrs_Setary(algo::Tuple& parent, algo::Tuple &rhs) __attribute__((nothrow));
// Copy specified array into attrs, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 attrs_Setary(algo::Tuple& parent, const algo::aryptr<algo::Attr> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::Attr&          attrs_qFind(algo::Tuple& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::Attr&          attrs_qLast(algo::Tuple& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  attrs_rowid_Get(algo::Tuple& parent, algo::Attr &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::Attr> attrs_AllocNVal(algo::Tuple& parent, int n_elems, const algo::Attr& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 Tuple_attrs_curs_Next(Tuple_attrs_curs &curs);
void                 Tuple_attrs_curs_Reset(Tuple_attrs_curs &curs, algo::Tuple &parent);
// cursor points to valid item
bool                 Tuple_attrs_curs_ValidQ(Tuple_attrs_curs &curs);
// item access
algo::Attr&          Tuple_attrs_curs_Access(Tuple_attrs_curs &curs);
// Read fields of algo::Tuple from an ascii string.
// The function is implemented externally.
bool                 Tuple_ReadStrptrMaybe(algo::Tuple &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Tuple_Init(algo::Tuple& parent);
void                 Tuple_Uninit(algo::Tuple& parent) __attribute__((nothrow));
// Convert algo::Tuple to a string (user-implemented function)
void                 Tuple_Print(algo::Tuple & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U16Dec2
#pragma pack(push,1)
struct U16Dec2 { // algo.U16Dec2
    u16   value;   //   0
    inline operator u16() const;
    explicit U16Dec2(u16                            in_value);
    U16Dec2();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U16Dec2& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U16Dec2& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100)
u16                  value_GetInt(const algo::U16Dec2& parent) __attribute__((nothrow));
// Return constant 100
u16                  U16Dec2_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U16Dec2& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U16Dec2& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U16Dec2& parent, cstring &outstr) __attribute__((nothrow));

u32                  U16Dec2_Hash(u32 prev, algo::U16Dec2 rhs) __attribute__((nothrow));
// Read fields of algo::U16Dec2 from an ascii string.
// The format of the string is the format of the algo::U16Dec2's only field
bool                 U16Dec2_ReadStrptrMaybe(algo::U16Dec2 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U16Dec2_Init(algo::U16Dec2& parent);
// print string representation of algo::U16Dec2 to string LHS, no header -- cprint:algo.U16Dec2.String
void                 U16Dec2_Print(algo::U16Dec2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U32Dec1
#pragma pack(push,1)
struct U32Dec1 { // algo.U32Dec1
    u32   value;   //   0
    inline operator u32() const;
    explicit U32Dec1(u32                            in_value);
    U32Dec1();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U32Dec1& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U32Dec1& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10)
u32                  value_GetInt(const algo::U32Dec1& parent) __attribute__((nothrow));
// Return constant 10
u32                  U32Dec1_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U32Dec1& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U32Dec1& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U32Dec1& parent, cstring &outstr) __attribute__((nothrow));

u32                  U32Dec1_Hash(u32 prev, algo::U32Dec1 rhs) __attribute__((nothrow));
// Read fields of algo::U32Dec1 from an ascii string.
// The format of the string is the format of the algo::U32Dec1's only field
bool                 U32Dec1_ReadStrptrMaybe(algo::U32Dec1 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U32Dec1_Init(algo::U32Dec1& parent);
// print string representation of algo::U32Dec1 to string LHS, no header -- cprint:algo.U32Dec1.String
void                 U32Dec1_Print(algo::U32Dec1 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U32Dec2
struct U32Dec2 { // algo.U32Dec2
    u32   value;   //   0
    inline operator u32() const;
    explicit U32Dec2(u32                            in_value);
    U32Dec2();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U32Dec2& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U32Dec2& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100)
u32                  value_GetInt(const algo::U32Dec2& parent) __attribute__((nothrow));
// Return constant 100
u32                  U32Dec2_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U32Dec2& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U32Dec2& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U32Dec2& parent, cstring &outstr) __attribute__((nothrow));

u32                  U32Dec2_Hash(u32 prev, algo::U32Dec2 rhs) __attribute__((nothrow));
// Read fields of algo::U32Dec2 from an ascii string.
// The format of the string is the format of the algo::U32Dec2's only field
bool                 U32Dec2_ReadStrptrMaybe(algo::U32Dec2 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U32Dec2_Init(algo::U32Dec2& parent);
// print string representation of algo::U32Dec2 to string LHS, no header -- cprint:algo.U32Dec2.String
void                 U32Dec2_Print(algo::U32Dec2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U32Dec3
struct U32Dec3 { // algo.U32Dec3
    u32   value;   //   0
    inline operator u32() const;
    explicit U32Dec3(u32                            in_value);
    U32Dec3();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U32Dec3& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U32Dec3& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000)
u32                  value_GetInt(const algo::U32Dec3& parent) __attribute__((nothrow));
// Return constant 1000
u32                  U32Dec3_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U32Dec3& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U32Dec3& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U32Dec3& parent, cstring &outstr) __attribute__((nothrow));

u32                  U32Dec3_Hash(u32 prev, algo::U32Dec3 rhs) __attribute__((nothrow));
// Read fields of algo::U32Dec3 from an ascii string.
// The format of the string is the format of the algo::U32Dec3's only field
bool                 U32Dec3_ReadStrptrMaybe(algo::U32Dec3 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U32Dec3_Init(algo::U32Dec3& parent);
// print string representation of algo::U32Dec3 to string LHS, no header -- cprint:algo.U32Dec3.String
void                 U32Dec3_Print(algo::U32Dec3 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U32Dec4
struct U32Dec4 { // algo.U32Dec4
    u32   value;   //   0
    inline operator u32() const;
    explicit U32Dec4(u32                            in_value);
    U32Dec4();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U32Dec4& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U32Dec4& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000)
u32                  value_GetInt(const algo::U32Dec4& parent) __attribute__((nothrow));
// Return constant 10000
u32                  U32Dec4_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U32Dec4& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U32Dec4& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U32Dec4& parent, cstring &outstr) __attribute__((nothrow));

u32                  U32Dec4_Hash(u32 prev, algo::U32Dec4 rhs) __attribute__((nothrow));
// Read fields of algo::U32Dec4 from an ascii string.
// The format of the string is the format of the algo::U32Dec4's only field
bool                 U32Dec4_ReadStrptrMaybe(algo::U32Dec4 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U32Dec4_Init(algo::U32Dec4& parent);
// print string representation of algo::U32Dec4 to string LHS, no header -- cprint:algo.U32Dec4.String
void                 U32Dec4_Print(algo::U32Dec4 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U32Dec5
struct U32Dec5 { // algo.U32Dec5
    u32   value;   //   0
    inline operator u32() const;
    explicit U32Dec5(u32                            in_value);
    U32Dec5();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U32Dec5& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U32Dec5& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100000)
u32                  value_GetInt(const algo::U32Dec5& parent) __attribute__((nothrow));
// Return constant 100000
u32                  U32Dec5_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U32Dec5& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U32Dec5& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U32Dec5& parent, cstring &outstr) __attribute__((nothrow));

u32                  U32Dec5_Hash(u32 prev, algo::U32Dec5 rhs) __attribute__((nothrow));
// Read fields of algo::U32Dec5 from an ascii string.
// The format of the string is the format of the algo::U32Dec5's only field
bool                 U32Dec5_ReadStrptrMaybe(algo::U32Dec5 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U32Dec5_Init(algo::U32Dec5& parent);
// print string representation of algo::U32Dec5 to string LHS, no header -- cprint:algo.U32Dec5.String
void                 U32Dec5_Print(algo::U32Dec5 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Ary
struct U64Ary { // algo.U64Ary
    u64*   ary_elems;   // pointer to elements
    u32    ary_n;       // number of elements in array
    u32    ary_max;     // max. capacity of array before realloc
    U64Ary();
    ~U64Ary();
private:
    // reftype Tary of algo.U64Ary.ary prohibits copy
    U64Ary(const U64Ary&){ /*disallow copy constructor */}
    void operator =(const U64Ary&){ /*disallow direct assignment */}
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<u64>    ary_Addary(algo::U64Ary& parent, algo::aryptr<u64> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
u64&                 ary_Alloc(algo::U64Ary& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u64&                 ary_AllocAt(algo::U64Ary& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u64>    ary_AllocN(algo::U64Ary& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ary_EmptyQ(algo::U64Ary& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u64*                 ary_Find(algo::U64Ary& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<u64>    ary_Getary(algo::U64Ary& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
u64*                 ary_Last(algo::U64Ary& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  ary_Max(algo::U64Ary& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  ary_N(const algo::U64Ary& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 ary_Remove(algo::U64Ary& parent, u32 i) __attribute__((nothrow));
void                 ary_RemoveAll(algo::U64Ary& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ary_RemoveLast(algo::U64Ary& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 ary_Reserve(algo::U64Ary& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 ary_AbsReserve(algo::U64Ary& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 ary_Setary(algo::U64Ary& parent, algo::U64Ary &rhs) __attribute__((nothrow));
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 ary_Setary(algo::U64Ary& parent, const algo::aryptr<u64> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
u64&                 ary_qFind(algo::U64Ary& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
u64&                 ary_qLast(algo::U64Ary& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  ary_rowid_Get(algo::U64Ary& parent, u64 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u64>    ary_AllocNVal(algo::U64Ary& parent, int n_elems, const u64& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 U64Ary_ary_curs_Next(U64Ary_ary_curs &curs);
void                 U64Ary_ary_curs_Reset(U64Ary_ary_curs &curs, algo::U64Ary &parent);
// cursor points to valid item
bool                 U64Ary_ary_curs_ValidQ(U64Ary_ary_curs &curs);
// item access
u64&                 U64Ary_ary_curs_Access(U64Ary_ary_curs &curs);
// Set all fields to initial values.
void                 U64Ary_Init(algo::U64Ary& parent);
void                 U64Ary_Uninit(algo::U64Ary& parent) __attribute__((nothrow));

// --- algo.U64Dec10
struct U64Dec10 { // algo.U64Dec10: unsigned u64, scale 1e10
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec10(u64                            in_value);
    U64Dec10();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec10& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec10& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000000000)
u64                  value_GetInt(const algo::U64Dec10& parent) __attribute__((nothrow));
// Return constant 10000000000
u64                  U64Dec10_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec10& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec10& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec10& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec10_Hash(u32 prev, algo::U64Dec10 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec10 from an ascii string.
// The format of the string is the format of the algo::U64Dec10's only field
bool                 U64Dec10_ReadStrptrMaybe(algo::U64Dec10 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec10_Init(algo::U64Dec10& parent);
// print string representation of algo::U64Dec10 to string LHS, no header -- cprint:algo.U64Dec10.String
void                 U64Dec10_Print(algo::U64Dec10 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec2
#pragma pack(push,1)
struct U64Dec2 { // algo.U64Dec2
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec2(u64                            in_value);
    U64Dec2();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec2& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec2& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100)
u64                  value_GetInt(const algo::U64Dec2& parent) __attribute__((nothrow));
// Return constant 100
u64                  U64Dec2_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec2& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec2& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec2& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec2_Hash(u32 prev, algo::U64Dec2 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec2 from an ascii string.
// The format of the string is the format of the algo::U64Dec2's only field
bool                 U64Dec2_ReadStrptrMaybe(algo::U64Dec2 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec2_Init(algo::U64Dec2& parent);
// print string representation of algo::U64Dec2 to string LHS, no header -- cprint:algo.U64Dec2.String
void                 U64Dec2_Print(algo::U64Dec2 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec4
#pragma pack(push,1)
struct U64Dec4 { // algo.U64Dec4
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec4(u64                            in_value);
    U64Dec4();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec4& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec4& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000)
u64                  value_GetInt(const algo::U64Dec4& parent) __attribute__((nothrow));
// Return constant 10000
u64                  U64Dec4_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec4& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec4& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec4& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec4_Hash(u32 prev, algo::U64Dec4 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec4 from an ascii string.
// The format of the string is the format of the algo::U64Dec4's only field
bool                 U64Dec4_ReadStrptrMaybe(algo::U64Dec4 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec4_Init(algo::U64Dec4& parent);
// print string representation of algo::U64Dec4 to string LHS, no header -- cprint:algo.U64Dec4.String
void                 U64Dec4_Print(algo::U64Dec4 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec5
struct U64Dec5 { // algo.U64Dec5
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec5(u64                            in_value);
    U64Dec5();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec5& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec5& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100000)
u64                  value_GetInt(const algo::U64Dec5& parent) __attribute__((nothrow));
// Return constant 100000
u64                  U64Dec5_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec5& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec5& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec5& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec5_Hash(u32 prev, algo::U64Dec5 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec5 from an ascii string.
// The format of the string is the format of the algo::U64Dec5's only field
bool                 U64Dec5_ReadStrptrMaybe(algo::U64Dec5 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec5_Init(algo::U64Dec5& parent);
// print string representation of algo::U64Dec5 to string LHS, no header -- cprint:algo.U64Dec5.String
void                 U64Dec5_Print(algo::U64Dec5 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec6
struct U64Dec6 { // algo.U64Dec6
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec6(u64                            in_value);
    U64Dec6();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec6& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec6& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000000)
u64                  value_GetInt(const algo::U64Dec6& parent) __attribute__((nothrow));
// Return constant 1000000
u64                  U64Dec6_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec6& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec6& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec6& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec6_Hash(u32 prev, algo::U64Dec6 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec6 from an ascii string.
// The format of the string is the format of the algo::U64Dec6's only field
bool                 U64Dec6_ReadStrptrMaybe(algo::U64Dec6 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec6_Init(algo::U64Dec6& parent);
// print string representation of algo::U64Dec6 to string LHS, no header -- cprint:algo.U64Dec6.String
void                 U64Dec6_Print(algo::U64Dec6 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec7
struct U64Dec7 { // algo.U64Dec7: unsigned u64, scale 1e7
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec7(u64                            in_value);
    U64Dec7();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec7& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec7& parent) __attribute__((nothrow));
// Return integer portion (divide number by 10000000)
u64                  value_GetInt(const algo::U64Dec7& parent) __attribute__((nothrow));
// Return constant 10000000
u64                  U64Dec7_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec7& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec7& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec7& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec7_Hash(u32 prev, algo::U64Dec7 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec7 from an ascii string.
// The format of the string is the format of the algo::U64Dec7's only field
bool                 U64Dec7_ReadStrptrMaybe(algo::U64Dec7 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec7_Init(algo::U64Dec7& parent);
// print string representation of algo::U64Dec7 to string LHS, no header -- cprint:algo.U64Dec7.String
void                 U64Dec7_Print(algo::U64Dec7 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec8
#pragma pack(push,1)
struct U64Dec8 { // algo.U64Dec8: unsigned u64, scale 1e8
    u64   value;   //   0
    explicit U64Dec8(u64                            in_value);
    U64Dec8();
};
#pragma pack(pop)

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec8& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec8& parent) __attribute__((nothrow));
// Return integer portion (divide number by 100000000)
u64                  value_GetInt(const algo::U64Dec8& parent) __attribute__((nothrow));
// Return constant 100000000
u64                  U64Dec8_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec8& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec8& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec8& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec8_Hash(u32 prev, algo::U64Dec8 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec8 from an ascii string.
// The format of the string is the format of the algo::U64Dec8's only field
bool                 U64Dec8_ReadStrptrMaybe(algo::U64Dec8 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec8_Init(algo::U64Dec8& parent);
// print string representation of algo::U64Dec8 to string LHS, no header -- cprint:algo.U64Dec8.String
void                 U64Dec8_Print(algo::U64Dec8 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.U64Dec9
struct U64Dec9 { // algo.U64Dec9: unsigned u64, scale 1e9
    u64   value;   //   0
    inline operator u64() const;
    explicit U64Dec9(u64                            in_value);
    U64Dec9();
};

// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
void                 value_qSetDouble(algo::U64Dec9& parent, double val) __attribute__((nothrow));
double               value_GetDouble(const algo::U64Dec9& parent) __attribute__((nothrow));
// Return integer portion (divide number by 1000000000)
u64                  value_GetInt(const algo::U64Dec9& parent) __attribute__((nothrow));
// Return constant 1000000000
u64                  U64Dec9_GetScale() __attribute__((nothrow));
// Set value of field value, using rounding.
// If value is out of range for the target type, return false.
bool                 value_SetDoubleMaybe(algo::U64Dec9& parent, double val) __attribute__((nothrow));
bool                 value_ReadStrptrMaybe(algo::U64Dec9& parent, algo::strptr in) __attribute__((nothrow));
void                 value_Print(algo::U64Dec9& parent, cstring &outstr) __attribute__((nothrow));

u32                  U64Dec9_Hash(u32 prev, algo::U64Dec9 rhs) __attribute__((nothrow));
// Read fields of algo::U64Dec9 from an ascii string.
// The format of the string is the format of the algo::U64Dec9's only field
bool                 U64Dec9_ReadStrptrMaybe(algo::U64Dec9 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 U64Dec9_Init(algo::U64Dec9& parent);
// print string representation of algo::U64Dec9 to string LHS, no header -- cprint:algo.U64Dec9.String
void                 U64Dec9_Print(algo::U64Dec9 row, algo::cstring &str) __attribute__((nothrow));

// --- algo.URL
struct URL { // algo.URL
    algo::cstring   protocol;           //
    algo::cstring   username;           //
    algo::cstring   password;           // password
    algo::cstring   server;             // www.example.com or A.B.C.D
    algo::cstring   dir;                // /subdir/index.html
    i32             port;               //   -1  80
    u32             source_addr_host;   //   0  source address in host format (valid for multicast addresses only
    algo::cstring   host;               // 0.0.0.0, or A.B.C.D, or 192.168.1.* or eth2
    explicit URL(const algo::strptr&            in_protocol
        ,const algo::strptr&            in_username
        ,const algo::strptr&            in_password
        ,const algo::strptr&            in_server
        ,const algo::strptr&            in_dir
        ,i32                            in_port
        ,u32                            in_source_addr_host
        ,const algo::strptr&            in_host);
    URL();
};

// Read fields of algo::URL from an ascii string.
// The function is implemented externally.
bool                 URL_ReadStrptrMaybe(algo::URL &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 URL_Init(algo::URL& parent);
// Convert algo::URL to a string (user-implemented function)
void                 URL_Print(algo::URL & row, algo::cstring &str) __attribute__((nothrow));

// --- algo.UnDiff
#pragma pack(push,1)
struct UnDiff { // algo.UnDiff: Unix diff * 1e9 + nanoseconds
    i64   value;   //   0
    explicit UnDiff(i64                            in_value);
    bool operator ==(const algo::UnDiff &rhs) const;
    bool operator !=(const algo::UnDiff &rhs) const;
    bool operator <(const algo::UnDiff &rhs) const;
    bool operator >(const algo::UnDiff &rhs) const;
    bool operator <=(const algo::UnDiff &rhs) const;
    bool operator >=(const algo::UnDiff &rhs) const;
    UnDiff();
};
#pragma pack(pop)

u32                  UnDiff_Hash(u32 prev, algo::UnDiff rhs) __attribute__((nothrow));
// Read fields of algo::UnDiff from an ascii string.
// The function is implemented externally.
bool                 UnDiff_ReadStrptrMaybe(algo::UnDiff &parent, algo::strptr in_str);
bool                 UnDiff_Lt(algo::UnDiff lhs, algo::UnDiff rhs) __attribute__((nothrow));
i32                  UnDiff_Cmp(algo::UnDiff lhs, algo::UnDiff rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 UnDiff_Init(algo::UnDiff& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 UnDiff_UpdateMax(algo::UnDiff &lhs, algo::UnDiff rhs) __attribute__((nothrow));
// Return the lesser of two values
algo::UnDiff         UnDiff_Min(algo::UnDiff lhs, algo::UnDiff rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 UnDiff_UpdateMin(algo::UnDiff &lhs, algo::UnDiff rhs) __attribute__((nothrow));
// Return the greater of two values
algo::UnDiff         UnDiff_Max(algo::UnDiff lhs, algo::UnDiff rhs) __attribute__((nothrow));
bool                 UnDiff_Eq(algo::UnDiff lhs, algo::UnDiff rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 UnDiff_Update(algo::UnDiff &lhs, algo::UnDiff rhs) __attribute__((nothrow));
// Convert algo::UnDiff to a string (user-implemented function)
void                 UnDiff_Print(algo::UnDiff row, algo::cstring &str) __attribute__((nothrow));

// --- algo.UnixDiff
struct UnixDiff { // algo.UnixDiff: Difference between two UnixTimes; units: seconds
    i64   value;   //   0
    explicit UnixDiff(i64                            in_value);
    bool operator ==(const algo::UnixDiff &rhs) const;
    bool operator !=(const algo::UnixDiff &rhs) const;
    bool operator <(const algo::UnixDiff &rhs) const;
    bool operator >(const algo::UnixDiff &rhs) const;
    bool operator <=(const algo::UnixDiff &rhs) const;
    bool operator >=(const algo::UnixDiff &rhs) const;
    UnixDiff();
};

u32                  UnixDiff_Hash(u32 prev, algo::UnixDiff rhs) __attribute__((nothrow));
// Read fields of algo::UnixDiff from an ascii string.
// The function is implemented externally.
bool                 UnixDiff_ReadStrptrMaybe(algo::UnixDiff &parent, algo::strptr in_str);
bool                 UnixDiff_Lt(algo::UnixDiff lhs, algo::UnixDiff rhs) __attribute__((nothrow));
i32                  UnixDiff_Cmp(algo::UnixDiff lhs, algo::UnixDiff rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 UnixDiff_Init(algo::UnixDiff& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 UnixDiff_UpdateMax(algo::UnixDiff &lhs, algo::UnixDiff rhs) __attribute__((nothrow));
// Return the lesser of two values
algo::UnixDiff       UnixDiff_Min(algo::UnixDiff lhs, algo::UnixDiff rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 UnixDiff_UpdateMin(algo::UnixDiff &lhs, algo::UnixDiff rhs) __attribute__((nothrow));
// Return the greater of two values
algo::UnixDiff       UnixDiff_Max(algo::UnixDiff lhs, algo::UnixDiff rhs) __attribute__((nothrow));
bool                 UnixDiff_Eq(algo::UnixDiff lhs, algo::UnixDiff rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 UnixDiff_Update(algo::UnixDiff &lhs, algo::UnixDiff rhs) __attribute__((nothrow));
// Convert algo::UnixDiff to a string (user-implemented function)
void                 UnixDiff_Print(algo::UnixDiff row, algo::cstring &str) __attribute__((nothrow));

// --- algo.UnixTime
#pragma pack(push,1)
struct UnixTime { // algo.UnixTime: Unix epoch time, in seconds
    i64   value;   //   0
    explicit UnixTime(i64                            in_value);
    bool operator ==(const algo::UnixTime &rhs) const;
    bool operator !=(const algo::UnixTime &rhs) const;
    bool operator <(const algo::UnixTime &rhs) const;
    bool operator >(const algo::UnixTime &rhs) const;
    bool operator <=(const algo::UnixTime &rhs) const;
    bool operator >=(const algo::UnixTime &rhs) const;
    UnixTime();
};
#pragma pack(pop)

u32                  UnixTime_Hash(u32 prev, algo::UnixTime rhs) __attribute__((nothrow));
// Read fields of algo::UnixTime from an ascii string.
// The function is implemented externally.
bool                 UnixTime_ReadStrptrMaybe(algo::UnixTime &parent, algo::strptr in_str);
bool                 UnixTime_Lt(algo::UnixTime lhs, algo::UnixTime rhs) __attribute__((nothrow));
i32                  UnixTime_Cmp(algo::UnixTime lhs, algo::UnixTime rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 UnixTime_Init(algo::UnixTime& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 UnixTime_UpdateMax(algo::UnixTime &lhs, algo::UnixTime rhs) __attribute__((nothrow));
// Return the lesser of two values
algo::UnixTime       UnixTime_Min(algo::UnixTime lhs, algo::UnixTime rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 UnixTime_UpdateMin(algo::UnixTime &lhs, algo::UnixTime rhs) __attribute__((nothrow));
// Return the greater of two values
algo::UnixTime       UnixTime_Max(algo::UnixTime lhs, algo::UnixTime rhs) __attribute__((nothrow));
bool                 UnixTime_Eq(algo::UnixTime lhs, algo::UnixTime rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 UnixTime_Update(algo::UnixTime &lhs, algo::UnixTime rhs) __attribute__((nothrow));
// Convert algo::UnixTime to a string (user-implemented function)
void                 UnixTime_Print(algo::UnixTime row, algo::cstring &str) __attribute__((nothrow));

// --- algo.WDiff
#pragma pack(push,1)
struct WDiff { // algo.WDiff: Difference between two WinTimes
    i64   value;   //   0
    explicit WDiff(i64                            in_value);
    bool operator ==(const algo::WDiff &rhs) const;
    bool operator !=(const algo::WDiff &rhs) const;
    bool operator <(const algo::WDiff &rhs) const;
    bool operator >(const algo::WDiff &rhs) const;
    bool operator <=(const algo::WDiff &rhs) const;
    bool operator >=(const algo::WDiff &rhs) const;
    WDiff();
};
#pragma pack(pop)

u32                  WDiff_Hash(u32 prev, algo::WDiff rhs) __attribute__((nothrow));
// Read fields of algo::WDiff from an ascii string.
// The function is implemented externally.
bool                 WDiff_ReadStrptrMaybe(algo::WDiff &parent, algo::strptr in_str);
bool                 WDiff_Lt(algo::WDiff lhs, algo::WDiff rhs) __attribute__((nothrow));
i32                  WDiff_Cmp(algo::WDiff lhs, algo::WDiff rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 WDiff_Init(algo::WDiff& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 WDiff_UpdateMax(algo::WDiff &lhs, algo::WDiff rhs) __attribute__((nothrow));
// Return the lesser of two values
algo::WDiff          WDiff_Min(algo::WDiff lhs, algo::WDiff rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 WDiff_UpdateMin(algo::WDiff &lhs, algo::WDiff rhs) __attribute__((nothrow));
// Return the greater of two values
algo::WDiff          WDiff_Max(algo::WDiff lhs, algo::WDiff rhs) __attribute__((nothrow));
bool                 WDiff_Eq(algo::WDiff lhs, algo::WDiff rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 WDiff_Update(algo::WDiff &lhs, algo::WDiff rhs) __attribute__((nothrow));
// Convert algo::WDiff to a string (user-implemented function)
void                 WDiff_Print(algo::WDiff row, algo::cstring &str) __attribute__((nothrow));

// --- algo.WTime
#pragma pack(push,1)
struct WTime { // algo.WTime: Units: 100nsec; Number of units since Jan 1, 1600
    i64   value;   //   0
    explicit WTime(i64                            in_value);
    bool operator ==(const algo::WTime &rhs) const;
    bool operator !=(const algo::WTime &rhs) const;
    bool operator <(const algo::WTime &rhs) const;
    bool operator >(const algo::WTime &rhs) const;
    bool operator <=(const algo::WTime &rhs) const;
    bool operator >=(const algo::WTime &rhs) const;
    WTime();
};
#pragma pack(pop)

u32                  WTime_Hash(u32 prev, algo::WTime rhs) __attribute__((nothrow));
// Read fields of algo::WTime from an ascii string.
// The function is implemented externally.
bool                 WTime_ReadStrptrMaybe(algo::WTime &parent, algo::strptr in_str);
bool                 WTime_Lt(algo::WTime lhs, algo::WTime rhs) __attribute__((nothrow));
i32                  WTime_Cmp(algo::WTime lhs, algo::WTime rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 WTime_Init(algo::WTime& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 WTime_UpdateMax(algo::WTime &lhs, algo::WTime rhs) __attribute__((nothrow));
// Return the lesser of two values
algo::WTime          WTime_Min(algo::WTime lhs, algo::WTime rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 WTime_UpdateMin(algo::WTime &lhs, algo::WTime rhs) __attribute__((nothrow));
// Return the greater of two values
algo::WTime          WTime_Max(algo::WTime lhs, algo::WTime rhs) __attribute__((nothrow));
bool                 WTime_Eq(algo::WTime lhs, algo::WTime rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 WTime_Update(algo::WTime &lhs, algo::WTime rhs) __attribute__((nothrow));
// Convert algo::WTime to a string (user-implemented function)
void                 WTime_Print(algo::WTime row, algo::cstring &str) __attribute__((nothrow));

// --- algo.i32_Range
struct i32_Range { // algo.i32_Range
    i32   beg;   //   0
    i32   end;   //   0
    explicit i32_Range(i32                            in_beg
        ,i32                            in_end);
    bool operator ==(const algo::i32_Range &rhs) const;
    bool operator !=(const algo::i32_Range &rhs) const;
    bool operator <(const algo::i32_Range &rhs) const;
    bool operator >(const algo::i32_Range &rhs) const;
    bool operator <=(const algo::i32_Range &rhs) const;
    bool operator >=(const algo::i32_Range &rhs) const;
    i32_Range();
};

u32                  i32_Range_Hash(u32 prev, const algo::i32_Range & rhs) __attribute__((nothrow));
bool                 i32_Range_Lt(algo::i32_Range & lhs, algo::i32_Range & rhs) __attribute__((nothrow));
i32                  i32_Range_Cmp(algo::i32_Range & lhs, algo::i32_Range & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 i32_Range_Init(algo::i32_Range& parent);
bool                 i32_Range_Eq(const algo::i32_Range & lhs,const algo::i32_Range & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 i32_Range_Update(algo::i32_Range &lhs, algo::i32_Range & rhs) __attribute__((nothrow));
// Convert algo::i32_Range to a string (user-implemented function)
void                 i32_Range_Print(algo::i32_Range & row, algo::cstring &str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace algo { // gen:ns_curstext

struct cstring_ch_curs {// cursor
    typedef char ChildType;
    char* elems;
    int n_elems;
    int index;
    cstring_ch_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ByteAry_ary_curs {// cursor
    typedef u8 ChildType;
    u8* elems;
    int n_elems;
    int index;
    ByteAry_ary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct Charset_ch_bitcurs {// cursor
    typedef int& ChildType;
    u64* elems;
    int n_elems;
    int bit;
    Charset_ch_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct Charset_ch_curs {// cursor
    typedef u64 ChildType;
    int index;
    algo::Charset *parent;
    Charset_ch_curs() { parent=NULL; index=0; }
};


struct LineBuf_buf_curs {// cursor
    typedef char ChildType;
    char* elems;
    int n_elems;
    int index;
    LineBuf_buf_curs() { elems=NULL; n_elems=0; index=0; }
};


struct Md5Digest_value_curs {// cursor
    typedef u8 ChildType;
    int index;
    algo::Md5Digest *parent;
    Md5Digest_value_curs() { parent=NULL; index=0; }
};


struct NormTxttbl_start_curs {// cursor
    typedef i32 ChildType;
    i32* elems;
    int n_elems;
    int index;
    NormTxttbl_start_curs() { elems=NULL; n_elems=0; index=0; }
};


struct Sha1sig_sha1sig_curs {// cursor
    typedef u8 ChildType;
    int index;
    algo::Sha1sig *parent;
    Sha1sig_sha1sig_curs() { parent=NULL; index=0; }
};


struct Tuple_attrs_curs {// cursor
    typedef algo::Attr ChildType;
    algo::Attr* elems;
    int n_elems;
    int index;
    Tuple_attrs_curs() { elems=NULL; n_elems=0; index=0; }
};


struct U64Ary_ary_curs {// cursor
    typedef u64 ChildType;
    u64* elems;
    int n_elems;
    int index;
    U64Ary_ary_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace algo { // gen:ns_func
// Test string conversion
void                 ForAllStrings(void (*fcn)(algo::StringDesc&) );
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const algo::Attr &row);// cfmt:algo.Attr.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Bool &row);// cfmt:algo.Bool.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Comment &row);// cfmt:algo.Comment.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::CppExpr &row);// cfmt:algo.CppExpr.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::UnTime &row);// cfmt:algo.UnTime.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Dbbox &row);// cfmt:algo.Dbbox.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::DryrunQ &row);// cfmt:algo.DryrunQ.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::EchoQ &row);// cfmt:algo.EchoQ.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Errcode &row);// cfmt:algo.Errcode.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::FailokQ &row);// cfmt:algo.FailokQ.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::FieldId &row);// cfmt:algo.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::FileFlags &row);// cfmt:algo.FileFlags.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I32Dec1 &row);// cfmt:algo.I32Dec1.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I32Dec2 &row);// cfmt:algo.I32Dec2.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I32Dec3 &row);// cfmt:algo.I32Dec3.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I32Dec4 &row);// cfmt:algo.I32Dec4.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I32Dec5 &row);// cfmt:algo.I32Dec5.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec1 &row);// cfmt:algo.I64Dec1.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec10 &row);// cfmt:algo.I64Dec10.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec2 &row);// cfmt:algo.I64Dec2.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec3 &row);// cfmt:algo.I64Dec3.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec4 &row);// cfmt:algo.I64Dec4.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec5 &row);// cfmt:algo.I64Dec5.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec6 &row);// cfmt:algo.I64Dec6.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec7 &row);// cfmt:algo.I64Dec7.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec8 &row);// cfmt:algo.I64Dec8.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::I64Dec9 &row);// cfmt:algo.I64Dec9.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::IOEvtFlags &row);// cfmt:algo.IOEvtFlags.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Imdb &row);// cfmt:algo.Imdb.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::ImrowPtr &row);// cfmt:algo.ImrowPtr.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Imtable &row);// cfmt:algo.Imtable.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Ipmask &row);// cfmt:algo.Ipmask.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::LogcatId &row);// cfmt:algo.LogcatId.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::LogcatKey &row);// cfmt:algo.LogcatKey.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::SchedTime &row);// cfmt:algo.SchedTime.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Logmsg &row);// cfmt:algo.Logmsg.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Md5Digest &row);// cfmt:algo.Md5Digest.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Month &row);// cfmt:algo.Month.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::NumParseFlags &row);// cfmt:algo.NumParseFlags.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::SeqType &row);// cfmt:algo.SeqType.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Sha1sig &row);// cfmt:algo.Sha1sig.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::TermStyle &row);// cfmt:algo.TermStyle.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::TextJust &row);// cfmt:algo.TextJust.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::Tuple &row);// cfmt:algo.Tuple.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U16Dec2 &row);// cfmt:algo.U16Dec2.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U32Dec1 &row);// cfmt:algo.U32Dec1.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U32Dec2 &row);// cfmt:algo.U32Dec2.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U32Dec3 &row);// cfmt:algo.U32Dec3.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U32Dec4 &row);// cfmt:algo.U32Dec4.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U32Dec5 &row);// cfmt:algo.U32Dec5.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec10 &row);// cfmt:algo.U64Dec10.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec2 &row);// cfmt:algo.U64Dec2.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec4 &row);// cfmt:algo.U64Dec4.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec5 &row);// cfmt:algo.U64Dec5.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec6 &row);// cfmt:algo.U64Dec6.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec7 &row);// cfmt:algo.U64Dec7.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec8 &row);// cfmt:algo.U64Dec8.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::U64Dec9 &row);// cfmt:algo.U64Dec9.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::URL &row);// cfmt:algo.URL.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::UnDiff &row);// cfmt:algo.UnDiff.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::UnixDiff &row);// cfmt:algo.UnixDiff.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::UnixTime &row);// cfmt:algo.UnixTime.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::WDiff &row);// cfmt:algo.WDiff.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::WTime &row);// cfmt:algo.WTime.String
inline algo::cstring &operator <<(algo::cstring &str, const algo::i32_Range &row);// cfmt:algo.i32_Range.String
}
