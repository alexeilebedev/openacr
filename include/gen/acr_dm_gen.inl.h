//
// include/gen/acr_dm_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
//#pragma endinclude
inline acr_dm::FAttr::FAttr() {
    acr_dm::FAttr_Init(*this);
}

inline acr_dm::FAttr::~FAttr() {
    acr_dm::FAttr_Uninit(*this);
}


// --- acr_dm.FAttr.zs_value.EmptyQ
// Return true if index is empty
inline bool acr_dm::zs_value_EmptyQ(acr_dm::FAttr& attr) {
    return attr.zs_value_head == NULL;
}

// --- acr_dm.FAttr.zs_value.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr_dm::FValue* acr_dm::zs_value_First(acr_dm::FAttr& attr) {
    acr_dm::FValue *row = NULL;
    row = attr.zs_value_head;
    return row;
}

// --- acr_dm.FAttr.zs_value.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr_dm::zs_value_InLlistQ(acr_dm::FValue& row) {
    bool result = false;
    result = !(row.zs_value_next == (acr_dm::FValue*)-1);
    return result;
}

// --- acr_dm.FAttr.zs_value.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr_dm::FValue* acr_dm::zs_value_Last(acr_dm::FAttr& attr) {
    acr_dm::FValue *row = NULL;
    row = attr.zs_value_tail;
    return row;
}

// --- acr_dm.FAttr.zs_value.N
// Return number of items in the linked list
inline i32 acr_dm::zs_value_N(const acr_dm::FAttr& attr) {
    return attr.zs_value_n;
}

// --- acr_dm.FAttr.zs_value.Next
// Return pointer to next element in the list
inline acr_dm::FValue* acr_dm::zs_value_Next(acr_dm::FValue &row) {
    return row.zs_value_next;
}

// --- acr_dm.FAttr.zs_value.qLast
// Return reference to last element in the index. No bounds checking.
inline acr_dm::FValue& acr_dm::zs_value_qLast(acr_dm::FAttr& attr) {
    acr_dm::FValue *row = NULL;
    row = attr.zs_value_tail;
    return *row;
}

// --- acr_dm.FAttr.zs_value_curs.Reset
// cursor points to valid item
inline void acr_dm::attr_zs_value_curs_Reset(attr_zs_value_curs &curs, acr_dm::FAttr &parent) {
    curs.row = parent.zs_value_head;
}

// --- acr_dm.FAttr.zs_value_curs.ValidQ
// cursor points to valid item
inline bool acr_dm::attr_zs_value_curs_ValidQ(attr_zs_value_curs &curs) {
    return curs.row != NULL;
}

// --- acr_dm.FAttr.zs_value_curs.Next
// proceed to next item
inline void acr_dm::attr_zs_value_curs_Next(attr_zs_value_curs &curs) {
    acr_dm::FValue *next = (*curs.row).zs_value_next;
    curs.row = next;
}

// --- acr_dm.FAttr.zs_value_curs.Access
// item access
inline acr_dm::FValue& acr_dm::attr_zs_value_curs_Access(attr_zs_value_curs &curs) {
    return *curs.row;
}

// --- acr_dm.FAttr..Init
// Set all fields to initial values.
inline void acr_dm::FAttr_Init(acr_dm::FAttr& attr) {
    attr.p_tuple = NULL;
    attr.zs_value_head = NULL; // (acr_dm.FAttr.zs_value)
    attr.zs_value_n = 0; // (acr_dm.FAttr.zs_value)
    attr.zs_value_tail = NULL; // (acr_dm.FAttr.zs_value)
    attr.zs_attr_next = (acr_dm::FAttr*)-1; // (acr_dm.FTuple.zs_attr) not-in-list
}
inline acr_dm::trace::trace() {
}


// --- acr_dm.FDb.tuple.EmptyQ
// Return true if index is empty
inline bool acr_dm::tuple_EmptyQ() {
    return _db.tuple_n == 0;
}

// --- acr_dm.FDb.tuple.Find
// Look up row by row id. Return NULL if out of range
inline acr_dm::FTuple* acr_dm::tuple_Find(u64 t) {
    acr_dm::FTuple *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tuple_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tuple_lary[bsr][index];
    }
    return retval;
}

// --- acr_dm.FDb.tuple.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_dm::FTuple* acr_dm::tuple_Last() {
    return tuple_Find(u64(_db.tuple_n-1));
}

// --- acr_dm.FDb.tuple.N
// Return number of items in the pool
inline i32 acr_dm::tuple_N() {
    return _db.tuple_n;
}

// --- acr_dm.FDb.tuple.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_dm::FTuple& acr_dm::tuple_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tuple_lary[bsr][index];
}

// --- acr_dm.FDb.ind_tuple.EmptyQ
// Return true if hash is empty
inline bool acr_dm::ind_tuple_EmptyQ() {
    return _db.ind_tuple_n == 0;
}

// --- acr_dm.FDb.ind_tuple.N
// Return number of items in the hash
inline i32 acr_dm::ind_tuple_N() {
    return _db.ind_tuple_n;
}

// --- acr_dm.FDb.attr.EmptyQ
// Return true if index is empty
inline bool acr_dm::attr_EmptyQ() {
    return _db.attr_n == 0;
}

// --- acr_dm.FDb.attr.Find
// Look up row by row id. Return NULL if out of range
inline acr_dm::FAttr* acr_dm::attr_Find(u64 t) {
    acr_dm::FAttr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.attr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.attr_lary[bsr][index];
    }
    return retval;
}

// --- acr_dm.FDb.attr.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_dm::FAttr* acr_dm::attr_Last() {
    return attr_Find(u64(_db.attr_n-1));
}

// --- acr_dm.FDb.attr.N
// Return number of items in the pool
inline i32 acr_dm::attr_N() {
    return _db.attr_n;
}

// --- acr_dm.FDb.attr.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_dm::FAttr& acr_dm::attr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.attr_lary[bsr][index];
}

// --- acr_dm.FDb.value.EmptyQ
// Return true if index is empty
inline bool acr_dm::value_EmptyQ() {
    return _db.value_n == 0;
}

// --- acr_dm.FDb.value.Find
// Look up row by row id. Return NULL if out of range
inline acr_dm::FValue* acr_dm::value_Find(u64 t) {
    acr_dm::FValue *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.value_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.value_lary[bsr][index];
    }
    return retval;
}

// --- acr_dm.FDb.value.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_dm::FValue* acr_dm::value_Last() {
    return value_Find(u64(_db.value_n-1));
}

// --- acr_dm.FDb.value.N
// Return number of items in the pool
inline i32 acr_dm::value_N() {
    return _db.value_n;
}

// --- acr_dm.FDb.value.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_dm::FValue& acr_dm::value_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.value_lary[bsr][index];
}

// --- acr_dm.FDb.bh_tuple.EmptyQ
// Return true if index is empty
inline bool acr_dm::bh_tuple_EmptyQ() {
    return _db.bh_tuple_n == 0;
}

// --- acr_dm.FDb.bh_tuple.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr_dm::FTuple* acr_dm::bh_tuple_First() {
    acr_dm::FTuple *row = NULL;
    if (_db.bh_tuple_n > 0) {
        row = _db.bh_tuple_elems[0];
    }
    return row;
}

// --- acr_dm.FDb.bh_tuple.InBheapQ
// Return true if row is in index, false otherwise
inline bool acr_dm::bh_tuple_InBheapQ(acr_dm::FTuple& row) {
    bool result = false;
    result = row.bh_tuple_idx != -1;
    return result;
}

// --- acr_dm.FDb.bh_tuple.N
// Return number of items in the heap
inline i32 acr_dm::bh_tuple_N() {
    return _db.bh_tuple_n;
}

// --- acr_dm.FDb.tuple_curs.Reset
// cursor points to valid item
inline void acr_dm::_db_tuple_curs_Reset(_db_tuple_curs &curs, acr_dm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_dm.FDb.tuple_curs.ValidQ
// cursor points to valid item
inline bool acr_dm::_db_tuple_curs_ValidQ(_db_tuple_curs &curs) {
    return curs.index < _db.tuple_n;
}

// --- acr_dm.FDb.tuple_curs.Next
// proceed to next item
inline void acr_dm::_db_tuple_curs_Next(_db_tuple_curs &curs) {
    curs.index++;
}

// --- acr_dm.FDb.tuple_curs.Access
// item access
inline acr_dm::FTuple& acr_dm::_db_tuple_curs_Access(_db_tuple_curs &curs) {
    return tuple_qFind(u64(curs.index));
}

// --- acr_dm.FDb.attr_curs.Reset
// cursor points to valid item
inline void acr_dm::_db_attr_curs_Reset(_db_attr_curs &curs, acr_dm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_dm.FDb.attr_curs.ValidQ
// cursor points to valid item
inline bool acr_dm::_db_attr_curs_ValidQ(_db_attr_curs &curs) {
    return curs.index < _db.attr_n;
}

// --- acr_dm.FDb.attr_curs.Next
// proceed to next item
inline void acr_dm::_db_attr_curs_Next(_db_attr_curs &curs) {
    curs.index++;
}

// --- acr_dm.FDb.attr_curs.Access
// item access
inline acr_dm::FAttr& acr_dm::_db_attr_curs_Access(_db_attr_curs &curs) {
    return attr_qFind(u64(curs.index));
}

// --- acr_dm.FDb.value_curs.Reset
// cursor points to valid item
inline void acr_dm::_db_value_curs_Reset(_db_value_curs &curs, acr_dm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_dm.FDb.value_curs.ValidQ
// cursor points to valid item
inline bool acr_dm::_db_value_curs_ValidQ(_db_value_curs &curs) {
    return curs.index < _db.value_n;
}

// --- acr_dm.FDb.value_curs.Next
// proceed to next item
inline void acr_dm::_db_value_curs_Next(_db_value_curs &curs) {
    curs.index++;
}

// --- acr_dm.FDb.value_curs.Access
// item access
inline acr_dm::FValue& acr_dm::_db_value_curs_Access(_db_value_curs &curs) {
    return value_qFind(u64(curs.index));
}

// --- acr_dm.FDb.bh_tuple_curs.Access
// Access current element. If not more elements, return NULL
inline acr_dm::FTuple& acr_dm::_db_bh_tuple_curs_Access(_db_bh_tuple_curs &curs) {
    return *curs.temp_elems[0];
}

// --- acr_dm.FDb.bh_tuple_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool acr_dm::_db_bh_tuple_curs_ValidQ(_db_bh_tuple_curs &curs) {
    return curs.temp_n > 0;
}
inline acr_dm::Rowid::Rowid(i32                            in_f1
        ,i32                            in_f2
        ,i32                            in_f3)
    : f1(in_f1)
    , f2(in_f2)
    , f3(in_f3)
{
}

inline bool acr_dm::Rowid::operator ==(const acr_dm::Rowid &rhs) const {
    return acr_dm::Rowid_Eq(const_cast<acr_dm::Rowid&>(*this),const_cast<acr_dm::Rowid&>(rhs));
}

inline bool acr_dm::Rowid::operator !=(const acr_dm::Rowid &rhs) const {
    return !acr_dm::Rowid_Eq(const_cast<acr_dm::Rowid&>(*this),const_cast<acr_dm::Rowid&>(rhs));
}

inline bool acr_dm::Rowid::operator <(const acr_dm::Rowid &rhs) const {
    return acr_dm::Rowid_Lt(const_cast<acr_dm::Rowid&>(*this),const_cast<acr_dm::Rowid&>(rhs));
}

inline bool acr_dm::Rowid::operator >(const acr_dm::Rowid &rhs) const {
    return rhs < *this;
}

inline bool acr_dm::Rowid::operator <=(const acr_dm::Rowid &rhs) const {
    return !(rhs < *this);
}

inline bool acr_dm::Rowid::operator >=(const acr_dm::Rowid &rhs) const {
    return !(*this < rhs);
}
inline acr_dm::Rowid::Rowid() {
    acr_dm::Rowid_Init(*this);
}


// --- acr_dm.Rowid..Lt
inline bool acr_dm::Rowid_Lt(acr_dm::Rowid& lhs, acr_dm::Rowid& rhs) {
    return Rowid_Cmp(lhs,rhs) < 0;
}

// --- acr_dm.Rowid..Cmp
inline i32 acr_dm::Rowid_Cmp(acr_dm::Rowid& lhs, acr_dm::Rowid& rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.f1, rhs.f1);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.f2, rhs.f2);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.f3, rhs.f3);
    return retval;
}

// --- acr_dm.Rowid..Init
// Set all fields to initial values.
inline void acr_dm::Rowid_Init(acr_dm::Rowid& parent) {
    parent.f1 = i32(0);
    parent.f2 = i32(0);
    parent.f3 = i32(0);
}

// --- acr_dm.Rowid..Eq
inline bool acr_dm::Rowid_Eq(const acr_dm::Rowid& lhs, const acr_dm::Rowid& rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.f1, rhs.f1);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.f2, rhs.f2);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.f3, rhs.f3);
    return retval;
}

// --- acr_dm.Rowid..Update
// Set value. Return true if new value is different from old value.
inline bool acr_dm::Rowid_Update(acr_dm::Rowid &lhs, acr_dm::Rowid& rhs) {
    bool ret = !Rowid_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline acr_dm::Source::Source() {
    acr_dm::Source_Init(*this);
}


// --- acr_dm.Source.source.N
// Return constant 1
inline int acr_dm::source_N(acr_dm::Source& parent) {
    (void)parent;
    return 1;
}

// --- acr_dm.Source.source.qFind
// Access value
inline u8& acr_dm::source_qFind(acr_dm::Source& parent, int) {
    return parent.source;
}

// --- acr_dm.Source.source.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int acr_dm::source_Nbits(acr_dm::Source& parent) {
    return source_N(parent) * 8;
}

// --- acr_dm.Source.source.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool acr_dm::source_qGetBit(acr_dm::Source& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = source_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- acr_dm.Source.source.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool acr_dm::source_GetBit(acr_dm::Source& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    bool ret = false;
    u64 lim = source_N(parent);
    if (elem_idx < lim) {
        u8 &elem = source_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- acr_dm.Source.source.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool acr_dm::source_BitsEmptyQ(acr_dm::Source& parent) {
    bool retval = true;
    u64 n = source_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (source_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- acr_dm.Source.source.Sum1s
inline u64 acr_dm::source_Sum1s(acr_dm::Source& parent) {
    u64 sum = 0;
    u64 n = source_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u8_Count1s(source_qFind(parent, i));
    }
    return sum;
}

// --- acr_dm.Source.source.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void acr_dm::source_qClearBit(acr_dm::Source& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = source_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u8(1) << shift); // clear bit
}

// --- acr_dm.Source.source.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void acr_dm::source_ClearBit(acr_dm::Source& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u64 lim = source_N(parent);
    if (elem_idx < lim) {
        u8 &elem = source_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u8(1) << shift); // clear bit
    }
}

// --- acr_dm.Source.source.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void acr_dm::source_qSetBit(acr_dm::Source& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = source_qFind(parent, elem_idx); // fetch
    elem = elem | (u8(1) << shift); // set bit
}

// --- acr_dm.Source.source.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void acr_dm::source_SetBit(acr_dm::Source& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u64 lim = source_N(parent);
    if (elem_idx < lim) {
        u8 &elem = source_qFind(parent, elem_idx); // fetch
        elem = elem | (u8(1) << shift); // set bit
    }
}

// --- acr_dm.Source.source.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void acr_dm::source_qSetBitVal(acr_dm::Source& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = source_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u8(1) << shift)) | (u8(val) << shift); // insert new value
}

// --- acr_dm.Source.source.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void acr_dm::source_qOrBitVal(acr_dm::Source& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = source_qFind(parent, elem_idx); // fetch
    elem = elem | (u8(val) << shift); // Or in val into elem
}

// --- acr_dm.Source.source.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void acr_dm::source_ClearBitsAll(acr_dm::Source& parent) {
    u64 n = source_N(parent);
    for (u64 i = 0; i < n; i++) {
        source_qFind(parent, i) = 0;
    }
}

// --- acr_dm.Source.source.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void acr_dm::source_ClearBits(acr_dm::Source& parent, acr_dm::Source &rhs) {
    u64 n = u64_Min(source_N(parent), source_N(rhs));
    for (u64 i = 0; i < n; i++) {
        source_qFind(parent, i) &= ~source_qFind(rhs, i);
    }
}

// --- acr_dm.Source.source.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void acr_dm::source_OrBits(acr_dm::Source& parent, acr_dm::Source &rhs) {
    u64 n = u64_Min(source_N(parent), source_N(rhs));
    for (u64 i = 0; i < n; i++) {
        source_qFind(parent, i) |= source_qFind(rhs, i);
    }
}

// --- acr_dm.Source.source.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 acr_dm::source_Sup(acr_dm::Source& parent) {
    u64 lim = source_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u8 &val = source_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 8 + bitidx;
            break;
        }
    }
    return ret;
}

// --- acr_dm.Source.source_bitcurs.ValidQ
// cursor points to valid item
inline bool acr_dm::Source_source_bitcurs_ValidQ(Source_source_bitcurs &curs) {
    return curs.bit < curs.n_elems*8;
}

// --- acr_dm.Source.source_bitcurs.Access
// item access
inline int& acr_dm::Source_source_bitcurs_Access(Source_source_bitcurs &curs) {
    return curs.bit;
}

// --- acr_dm.Source..Init
// Set all fields to initial values.
inline void acr_dm::Source_Init(acr_dm::Source& parent) {
    parent.source = u8(0);
}
inline acr_dm::FTuple::FTuple() {
    acr_dm::FTuple_Init(*this);
}

inline acr_dm::FTuple::~FTuple() {
    acr_dm::FTuple_Uninit(*this);
}


// --- acr_dm.FTuple.rowid.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool acr_dm::rowid_Lt(acr_dm::FTuple& tuple, acr_dm::FTuple &rhs) {
    return acr_dm::Rowid_Lt(tuple.rowid,rhs.rowid);
}

// --- acr_dm.FTuple.rowid.Cmp
// Compare two fields.
inline i32 acr_dm::rowid_Cmp(acr_dm::FTuple& tuple, acr_dm::FTuple &rhs) {
    i32 retval = 0;
    retval = acr_dm::Rowid_Cmp(tuple.rowid, rhs.rowid);
    return retval;
}

// --- acr_dm.FTuple.zs_attr.EmptyQ
// Return true if index is empty
inline bool acr_dm::zs_attr_EmptyQ(acr_dm::FTuple& tuple) {
    return tuple.zs_attr_head == NULL;
}

// --- acr_dm.FTuple.zs_attr.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr_dm::FAttr* acr_dm::zs_attr_First(acr_dm::FTuple& tuple) {
    acr_dm::FAttr *row = NULL;
    row = tuple.zs_attr_head;
    return row;
}

// --- acr_dm.FTuple.zs_attr.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr_dm::zs_attr_InLlistQ(acr_dm::FAttr& row) {
    bool result = false;
    result = !(row.zs_attr_next == (acr_dm::FAttr*)-1);
    return result;
}

// --- acr_dm.FTuple.zs_attr.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr_dm::FAttr* acr_dm::zs_attr_Last(acr_dm::FTuple& tuple) {
    acr_dm::FAttr *row = NULL;
    row = tuple.zs_attr_tail;
    return row;
}

// --- acr_dm.FTuple.zs_attr.N
// Return number of items in the linked list
inline i32 acr_dm::zs_attr_N(const acr_dm::FTuple& tuple) {
    return tuple.zs_attr_n;
}

// --- acr_dm.FTuple.zs_attr.Next
// Return pointer to next element in the list
inline acr_dm::FAttr* acr_dm::zs_attr_Next(acr_dm::FAttr &row) {
    return row.zs_attr_next;
}

// --- acr_dm.FTuple.zs_attr.qLast
// Return reference to last element in the index. No bounds checking.
inline acr_dm::FAttr& acr_dm::zs_attr_qLast(acr_dm::FTuple& tuple) {
    acr_dm::FAttr *row = NULL;
    row = tuple.zs_attr_tail;
    return *row;
}

// --- acr_dm.FTuple..Init
// Set all fields to initial values.
inline void acr_dm::FTuple_Init(acr_dm::FTuple& tuple) {
    tuple.zs_attr_head = NULL; // (acr_dm.FTuple.zs_attr)
    tuple.zs_attr_n = 0; // (acr_dm.FTuple.zs_attr)
    tuple.zs_attr_tail = NULL; // (acr_dm.FTuple.zs_attr)
    tuple.ind_tuple_next = (acr_dm::FTuple*)-1; // (acr_dm.FDb.ind_tuple) not-in-hash
    tuple.bh_tuple_idx = -1; // (acr_dm.FDb.bh_tuple) not-in-heap
}

// --- acr_dm.FTuple.zs_attr_curs.Reset
// cursor points to valid item
inline void acr_dm::tuple_zs_attr_curs_Reset(tuple_zs_attr_curs &curs, acr_dm::FTuple &parent) {
    curs.row = parent.zs_attr_head;
}

// --- acr_dm.FTuple.zs_attr_curs.ValidQ
// cursor points to valid item
inline bool acr_dm::tuple_zs_attr_curs_ValidQ(tuple_zs_attr_curs &curs) {
    return curs.row != NULL;
}

// --- acr_dm.FTuple.zs_attr_curs.Next
// proceed to next item
inline void acr_dm::tuple_zs_attr_curs_Next(tuple_zs_attr_curs &curs) {
    acr_dm::FAttr *next = (*curs.row).zs_attr_next;
    curs.row = next;
}

// --- acr_dm.FTuple.zs_attr_curs.Access
// item access
inline acr_dm::FAttr& acr_dm::tuple_zs_attr_curs_Access(tuple_zs_attr_curs &curs) {
    return *curs.row;
}
inline acr_dm::FValue::FValue() {
    acr_dm::FValue_Init(*this);
}

inline acr_dm::FValue::~FValue() {
    acr_dm::FValue_Uninit(*this);
}


// --- acr_dm.FValue..Init
// Set all fields to initial values.
inline void acr_dm::FValue_Init(acr_dm::FValue& value) {
    value.p_attr = NULL;
    value.zs_value_next = (acr_dm::FValue*)-1; // (acr_dm.FAttr.zs_value) not-in-list
}
inline acr_dm::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline acr_dm::FieldId::FieldId(acr_dm_FieldIdEnum arg) { this->value = i32(arg); }
inline acr_dm::FieldId::FieldId() {
    acr_dm::FieldId_Init(*this);
}


// --- acr_dm.FieldId.value.GetEnum
// Get value of field as enum type
inline acr_dm_FieldIdEnum acr_dm::value_GetEnum(const acr_dm::FieldId& parent) {
    return acr_dm_FieldIdEnum(parent.value);
}

// --- acr_dm.FieldId.value.SetEnum
// Set value of field from enum type.
inline void acr_dm::value_SetEnum(acr_dm::FieldId& parent, acr_dm_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr_dm.FieldId.value.Cast
inline acr_dm::FieldId::operator acr_dm_FieldIdEnum () const {
    return acr_dm_FieldIdEnum((*this).value);
}

// --- acr_dm.FieldId..Init
// Set all fields to initial values.
inline void acr_dm::FieldId_Init(acr_dm::FieldId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_dm::trace &row) {// cfmt:acr_dm.trace.String
    acr_dm::trace_Print(const_cast<acr_dm::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_dm::Rowid &row) {// cfmt:acr_dm.Rowid.String
    acr_dm::Rowid_Print(const_cast<acr_dm::Rowid&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_dm::FieldId &row) {// cfmt:acr_dm.FieldId.String
    acr_dm::FieldId_Print(const_cast<acr_dm::FieldId&>(row), str);
    return str;
}
