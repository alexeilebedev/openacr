//
// include/gen/atf_exp_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/ams_gen.inl.h"
//#pragma endinclude

// --- atf_exp.trace..Ctor
inline  atf_exp::trace::trace() {
    atf_exp::trace_Init(*this);
}

// --- atf_exp.FDb.ind_proc.EmptyQ
// Return true if hash is empty
inline bool atf_exp::ind_proc_EmptyQ() {
    return _db.ind_proc_n == 0;
}

// --- atf_exp.FDb.ind_proc.N
// Return number of items in the hash
inline i32 atf_exp::ind_proc_N() {
    return _db.ind_proc_n;
}

// --- atf_exp.FDb.zd_proc.EmptyQ
// Return true if index is empty
inline bool atf_exp::zd_proc_EmptyQ() {
    return _db.zd_proc_head == NULL;
}

// --- atf_exp.FDb.zd_proc.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_exp::FProc* atf_exp::zd_proc_First() {
    atf_exp::FProc *row = NULL;
    row = _db.zd_proc_head;
    return row;
}

// --- atf_exp.FDb.zd_proc.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_exp::zd_proc_InLlistQ(atf_exp::FProc& row) {
    bool result = false;
    result = !(row.zd_proc_next == (atf_exp::FProc*)-1);
    return result;
}

// --- atf_exp.FDb.zd_proc.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_exp::FProc* atf_exp::zd_proc_Last() {
    atf_exp::FProc *row = NULL;
    row = _db.zd_proc_tail;
    return row;
}

// --- atf_exp.FDb.zd_proc.N
// Return number of items in the linked list
inline i32 atf_exp::zd_proc_N() {
    return _db.zd_proc_n;
}

// --- atf_exp.FDb.zd_proc.Next
// Return pointer to next element in the list
inline atf_exp::FProc* atf_exp::zd_proc_Next(atf_exp::FProc &row) {
    return row.zd_proc_next;
}

// --- atf_exp.FDb.zd_proc.Prev
// Return pointer to previous element in the list
inline atf_exp::FProc* atf_exp::zd_proc_Prev(atf_exp::FProc &row) {
    return row.zd_proc_prev;
}

// --- atf_exp.FDb.zd_proc.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_exp::FProc& atf_exp::zd_proc_qLast() {
    atf_exp::FProc *row = NULL;
    row = _db.zd_proc_tail;
    return *row;
}

// --- atf_exp.FDb.cd_proc_read.EmptyQ
// Return true if index is empty
inline bool atf_exp::cd_proc_read_EmptyQ() {
    return _db.cd_proc_read_head == NULL;
}

// --- atf_exp.FDb.cd_proc_read.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_exp::FProc* atf_exp::cd_proc_read_First() {
    atf_exp::FProc *row = NULL;
    row = _db.cd_proc_read_head;
    return row;
}

// --- atf_exp.FDb.cd_proc_read.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_exp::cd_proc_read_InLlistQ(atf_exp::FProc& row) {
    bool result = false;
    result = !(row.cd_proc_read_next == (atf_exp::FProc*)-1);
    return result;
}

// --- atf_exp.FDb.cd_proc_read.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_exp::FProc* atf_exp::cd_proc_read_Last() {
    atf_exp::FProc *row = NULL;
    row = _db.cd_proc_read_head ? _db.cd_proc_read_head->cd_proc_read_prev : NULL;
    return row;
}

// --- atf_exp.FDb.cd_proc_read.N
// Return number of items in the linked list
inline i32 atf_exp::cd_proc_read_N() {
    return _db.cd_proc_read_n;
}

// --- atf_exp.FDb.cd_proc_read.Next
// Return pointer to next element in the list
inline atf_exp::FProc* atf_exp::cd_proc_read_Next(atf_exp::FProc &row) {
    return row.cd_proc_read_next;
}

// --- atf_exp.FDb.cd_proc_read.Prev
// Return pointer to previous element in the list
inline atf_exp::FProc* atf_exp::cd_proc_read_Prev(atf_exp::FProc &row) {
    return row.cd_proc_read_prev;
}

// --- atf_exp.FDb.cd_proc_read.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_exp::FProc& atf_exp::cd_proc_read_qLast() {
    atf_exp::FProc *row = NULL;
    row = _db.cd_proc_read_head ? _db.cd_proc_read_head->cd_proc_read_prev : NULL;
    return *row;
}

// --- atf_exp.FDb.cd_proc_outflow.EmptyQ
// Return true if index is empty
inline bool atf_exp::cd_proc_outflow_EmptyQ() {
    return _db.cd_proc_outflow_head == NULL;
}

// --- atf_exp.FDb.cd_proc_outflow.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_exp::FProc* atf_exp::cd_proc_outflow_First() {
    atf_exp::FProc *row = NULL;
    row = _db.cd_proc_outflow_head;
    return row;
}

// --- atf_exp.FDb.cd_proc_outflow.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_exp::cd_proc_outflow_InLlistQ(atf_exp::FProc& row) {
    bool result = false;
    result = !(row.cd_proc_outflow_next == (atf_exp::FProc*)-1);
    return result;
}

// --- atf_exp.FDb.cd_proc_outflow.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_exp::FProc* atf_exp::cd_proc_outflow_Last() {
    atf_exp::FProc *row = NULL;
    row = _db.cd_proc_outflow_head ? _db.cd_proc_outflow_head->cd_proc_outflow_prev : NULL;
    return row;
}

// --- atf_exp.FDb.cd_proc_outflow.N
// Return number of items in the linked list
inline i32 atf_exp::cd_proc_outflow_N() {
    return _db.cd_proc_outflow_n;
}

// --- atf_exp.FDb.cd_proc_outflow.Next
// Return pointer to next element in the list
inline atf_exp::FProc* atf_exp::cd_proc_outflow_Next(atf_exp::FProc &row) {
    return row.cd_proc_outflow_next;
}

// --- atf_exp.FDb.cd_proc_outflow.Prev
// Return pointer to previous element in the list
inline atf_exp::FProc* atf_exp::cd_proc_outflow_Prev(atf_exp::FProc &row) {
    return row.cd_proc_outflow_prev;
}

// --- atf_exp.FDb.cd_proc_outflow.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_exp::FProc& atf_exp::cd_proc_outflow_qLast() {
    atf_exp::FProc *row = NULL;
    row = _db.cd_proc_outflow_head ? _db.cd_proc_outflow_head->cd_proc_outflow_prev : NULL;
    return *row;
}

// --- atf_exp.FDb.ind_proc_pid.EmptyQ
// Return true if hash is empty
inline bool atf_exp::ind_proc_pid_EmptyQ() {
    return _db.ind_proc_pid_n == 0;
}

// --- atf_exp.FDb.ind_proc_pid.N
// Return number of items in the hash
inline i32 atf_exp::ind_proc_pid_N() {
    return _db.ind_proc_pid_n;
}

// --- atf_exp.FDb.c_proc_read.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool atf_exp::c_proc_read_InsertMaybe(atf_exp::FProc& row) {
    atf_exp::FProc* ptr = _db.c_proc_read;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        _db.c_proc_read = &row;
    }
    return retval;
}

// --- atf_exp.FDb.c_proc_read.Remove
// Remove element from index. If element is not in index, do nothing.
inline void atf_exp::c_proc_read_Remove(atf_exp::FProc& row) {
    atf_exp::FProc *ptr = _db.c_proc_read;
    if (LIKELY(ptr == &row)) {
        _db.c_proc_read = NULL;
    }
}

// --- atf_exp.FDb.cd_fdin_eof.EmptyQ
// Return true if index is empty
inline bool atf_exp::cd_fdin_eof_EmptyQ() {
    return _db.cd_fdin_eof_head == NULL;
}

// --- atf_exp.FDb.cd_fdin_eof.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_exp::FFdin* atf_exp::cd_fdin_eof_First() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head;
    return row;
}

// --- atf_exp.FDb.cd_fdin_eof.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_exp::cd_fdin_eof_InLlistQ(atf_exp::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_eof_next == (atf_exp::FFdin*)-1);
    return result;
}

// --- atf_exp.FDb.cd_fdin_eof.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_exp::FFdin* atf_exp::cd_fdin_eof_Last() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head ? _db.cd_fdin_eof_head->cd_fdin_eof_prev : NULL;
    return row;
}

// --- atf_exp.FDb.cd_fdin_eof.N
// Return number of items in the linked list
inline i32 atf_exp::cd_fdin_eof_N() {
    return _db.cd_fdin_eof_n;
}

// --- atf_exp.FDb.cd_fdin_eof.Next
// Return pointer to next element in the list
inline atf_exp::FFdin* atf_exp::cd_fdin_eof_Next(atf_exp::FFdin &row) {
    return row.cd_fdin_eof_next;
}

// --- atf_exp.FDb.cd_fdin_eof.Prev
// Return pointer to previous element in the list
inline atf_exp::FFdin* atf_exp::cd_fdin_eof_Prev(atf_exp::FFdin &row) {
    return row.cd_fdin_eof_prev;
}

// --- atf_exp.FDb.cd_fdin_eof.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_exp::FFdin& atf_exp::cd_fdin_eof_qLast() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head ? _db.cd_fdin_eof_head->cd_fdin_eof_prev : NULL;
    return *row;
}

// --- atf_exp.FDb.cd_fdin_read.EmptyQ
// Return true if index is empty
inline bool atf_exp::cd_fdin_read_EmptyQ() {
    return _db.cd_fdin_read_head == NULL;
}

// --- atf_exp.FDb.cd_fdin_read.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_exp::FFdin* atf_exp::cd_fdin_read_First() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_read_head;
    return row;
}

// --- atf_exp.FDb.cd_fdin_read.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_exp::cd_fdin_read_InLlistQ(atf_exp::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_read_next == (atf_exp::FFdin*)-1);
    return result;
}

// --- atf_exp.FDb.cd_fdin_read.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_exp::FFdin* atf_exp::cd_fdin_read_Last() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_read_head ? _db.cd_fdin_read_head->cd_fdin_read_prev : NULL;
    return row;
}

// --- atf_exp.FDb.cd_fdin_read.N
// Return number of items in the linked list
inline i32 atf_exp::cd_fdin_read_N() {
    return _db.cd_fdin_read_n;
}

// --- atf_exp.FDb.cd_fdin_read.Next
// Return pointer to next element in the list
inline atf_exp::FFdin* atf_exp::cd_fdin_read_Next(atf_exp::FFdin &row) {
    return row.cd_fdin_read_next;
}

// --- atf_exp.FDb.cd_fdin_read.Prev
// Return pointer to previous element in the list
inline atf_exp::FFdin* atf_exp::cd_fdin_read_Prev(atf_exp::FFdin &row) {
    return row.cd_fdin_read_prev;
}

// --- atf_exp.FDb.cd_fdin_read.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_exp::FFdin& atf_exp::cd_fdin_read_qLast() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_read_head ? _db.cd_fdin_read_head->cd_fdin_read_prev : NULL;
    return *row;
}

// --- atf_exp.FDb.cd_fdin_suspend.EmptyQ
// Return true if index is empty
inline bool atf_exp::cd_fdin_suspend_EmptyQ() {
    return _db.cd_fdin_suspend_head == NULL;
}

// --- atf_exp.FDb.cd_fdin_suspend.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_exp::FFdin* atf_exp::cd_fdin_suspend_First() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_suspend_head;
    return row;
}

// --- atf_exp.FDb.cd_fdin_suspend.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_exp::cd_fdin_suspend_InLlistQ(atf_exp::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_suspend_next == (atf_exp::FFdin*)-1);
    return result;
}

// --- atf_exp.FDb.cd_fdin_suspend.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_exp::FFdin* atf_exp::cd_fdin_suspend_Last() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_suspend_head ? _db.cd_fdin_suspend_head->cd_fdin_suspend_prev : NULL;
    return row;
}

// --- atf_exp.FDb.cd_fdin_suspend.N
// Return number of items in the linked list
inline i32 atf_exp::cd_fdin_suspend_N() {
    return _db.cd_fdin_suspend_n;
}

// --- atf_exp.FDb.cd_fdin_suspend.Next
// Return pointer to next element in the list
inline atf_exp::FFdin* atf_exp::cd_fdin_suspend_Next(atf_exp::FFdin &row) {
    return row.cd_fdin_suspend_next;
}

// --- atf_exp.FDb.cd_fdin_suspend.Prev
// Return pointer to previous element in the list
inline atf_exp::FFdin* atf_exp::cd_fdin_suspend_Prev(atf_exp::FFdin &row) {
    return row.cd_fdin_suspend_prev;
}

// --- atf_exp.FDb.cd_fdin_suspend.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_exp::FFdin& atf_exp::cd_fdin_suspend_qLast() {
    atf_exp::FFdin *row = NULL;
    row = _db.cd_fdin_suspend_head ? _db.cd_fdin_suspend_head->cd_fdin_suspend_prev : NULL;
    return *row;
}

// --- atf_exp.FDb.zd_proc_curs.Reset
// cursor points to valid item
inline void atf_exp::_db_zd_proc_curs_Reset(_db_zd_proc_curs &curs, atf_exp::FDb &parent) {
    curs.row = parent.zd_proc_head;
}

// --- atf_exp.FDb.zd_proc_curs.ValidQ
// cursor points to valid item
inline bool atf_exp::_db_zd_proc_curs_ValidQ(_db_zd_proc_curs &curs) {
    return curs.row != NULL;
}

// --- atf_exp.FDb.zd_proc_curs.Next
// proceed to next item
inline void atf_exp::_db_zd_proc_curs_Next(_db_zd_proc_curs &curs) {
    atf_exp::FProc *next = (*curs.row).zd_proc_next;
    curs.row = next;
}

// --- atf_exp.FDb.zd_proc_curs.Access
// item access
inline atf_exp::FProc& atf_exp::_db_zd_proc_curs_Access(_db_zd_proc_curs &curs) {
    return *curs.row;
}

// --- atf_exp.FDb.cd_proc_read_curs.Reset
// cursor points to valid item
inline void atf_exp::_db_cd_proc_read_curs_Reset(_db_cd_proc_read_curs &curs, atf_exp::FDb &parent) {
    curs.row = parent.cd_proc_read_head;
    curs.head = &parent.cd_proc_read_head;
}

// --- atf_exp.FDb.cd_proc_read_curs.ValidQ
// cursor points to valid item
inline bool atf_exp::_db_cd_proc_read_curs_ValidQ(_db_cd_proc_read_curs &curs) {
    return curs.row != NULL;
}

// --- atf_exp.FDb.cd_proc_read_curs.Next
// proceed to next item
inline void atf_exp::_db_cd_proc_read_curs_Next(_db_cd_proc_read_curs &curs) {
    atf_exp::FProc *next = (*curs.row).cd_proc_read_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_exp.FDb.cd_proc_read_curs.Access
// item access
inline atf_exp::FProc& atf_exp::_db_cd_proc_read_curs_Access(_db_cd_proc_read_curs &curs) {
    return *curs.row;
}

// --- atf_exp.FDb.cd_proc_outflow_curs.Reset
// cursor points to valid item
inline void atf_exp::_db_cd_proc_outflow_curs_Reset(_db_cd_proc_outflow_curs &curs, atf_exp::FDb &parent) {
    curs.row = parent.cd_proc_outflow_head;
    curs.head = &parent.cd_proc_outflow_head;
}

// --- atf_exp.FDb.cd_proc_outflow_curs.ValidQ
// cursor points to valid item
inline bool atf_exp::_db_cd_proc_outflow_curs_ValidQ(_db_cd_proc_outflow_curs &curs) {
    return curs.row != NULL;
}

// --- atf_exp.FDb.cd_proc_outflow_curs.Next
// proceed to next item
inline void atf_exp::_db_cd_proc_outflow_curs_Next(_db_cd_proc_outflow_curs &curs) {
    atf_exp::FProc *next = (*curs.row).cd_proc_outflow_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_exp.FDb.cd_proc_outflow_curs.Access
// item access
inline atf_exp::FProc& atf_exp::_db_cd_proc_outflow_curs_Access(_db_cd_proc_outflow_curs &curs) {
    return *curs.row;
}

// --- atf_exp.FDb.cd_fdin_eof_curs.Reset
// cursor points to valid item
inline void atf_exp::_db_cd_fdin_eof_curs_Reset(_db_cd_fdin_eof_curs &curs, atf_exp::FDb &parent) {
    curs.row = parent.cd_fdin_eof_head;
    curs.head = &parent.cd_fdin_eof_head;
}

// --- atf_exp.FDb.cd_fdin_eof_curs.ValidQ
// cursor points to valid item
inline bool atf_exp::_db_cd_fdin_eof_curs_ValidQ(_db_cd_fdin_eof_curs &curs) {
    return curs.row != NULL;
}

// --- atf_exp.FDb.cd_fdin_eof_curs.Next
// proceed to next item
inline void atf_exp::_db_cd_fdin_eof_curs_Next(_db_cd_fdin_eof_curs &curs) {
    atf_exp::FFdin *next = (*curs.row).cd_fdin_eof_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_exp.FDb.cd_fdin_eof_curs.Access
// item access
inline atf_exp::FFdin& atf_exp::_db_cd_fdin_eof_curs_Access(_db_cd_fdin_eof_curs &curs) {
    return *curs.row;
}

// --- atf_exp.FDb.cd_fdin_read_curs.Reset
// cursor points to valid item
inline void atf_exp::_db_cd_fdin_read_curs_Reset(_db_cd_fdin_read_curs &curs, atf_exp::FDb &parent) {
    curs.row = parent.cd_fdin_read_head;
    curs.head = &parent.cd_fdin_read_head;
}

// --- atf_exp.FDb.cd_fdin_read_curs.ValidQ
// cursor points to valid item
inline bool atf_exp::_db_cd_fdin_read_curs_ValidQ(_db_cd_fdin_read_curs &curs) {
    return curs.row != NULL;
}

// --- atf_exp.FDb.cd_fdin_read_curs.Next
// proceed to next item
inline void atf_exp::_db_cd_fdin_read_curs_Next(_db_cd_fdin_read_curs &curs) {
    atf_exp::FFdin *next = (*curs.row).cd_fdin_read_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_exp.FDb.cd_fdin_read_curs.Access
// item access
inline atf_exp::FFdin& atf_exp::_db_cd_fdin_read_curs_Access(_db_cd_fdin_read_curs &curs) {
    return *curs.row;
}

// --- atf_exp.FDb.cd_fdin_suspend_curs.Reset
// cursor points to valid item
inline void atf_exp::_db_cd_fdin_suspend_curs_Reset(_db_cd_fdin_suspend_curs &curs, atf_exp::FDb &parent) {
    curs.row = parent.cd_fdin_suspend_head;
    curs.head = &parent.cd_fdin_suspend_head;
}

// --- atf_exp.FDb.cd_fdin_suspend_curs.ValidQ
// cursor points to valid item
inline bool atf_exp::_db_cd_fdin_suspend_curs_ValidQ(_db_cd_fdin_suspend_curs &curs) {
    return curs.row != NULL;
}

// --- atf_exp.FDb.cd_fdin_suspend_curs.Next
// proceed to next item
inline void atf_exp::_db_cd_fdin_suspend_curs_Next(_db_cd_fdin_suspend_curs &curs) {
    atf_exp::FFdin *next = (*curs.row).cd_fdin_suspend_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_exp.FDb.cd_fdin_suspend_curs.Access
// item access
inline atf_exp::FFdin& atf_exp::_db_cd_fdin_suspend_curs_Access(_db_cd_fdin_suspend_curs &curs) {
    return *curs.row;
}

// --- atf_exp.FFdin.in.Max
// Return max. number of bytes in the buffer.
inline i32 atf_exp::in_Max(atf_exp::FFdin& fdin) {
    return fdin.in_max;
}

// --- atf_exp.FFdin.in.N
// Return number of bytes in the buffer.
inline i32 atf_exp::in_N(atf_exp::FFdin& fdin) {
    return fdin.in_end - fdin.in_start;
}

// --- atf_exp.FFdin..Ctor
inline  atf_exp::FFdin::FFdin() {
    atf_exp::FFdin_Init(*this);
    // added because atf_exp.FFdin.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}

// --- atf_exp.FFdin..Dtor
inline  atf_exp::FFdin::~FFdin() {
    atf_exp::FFdin_Uninit(*this);
}

// --- atf_exp.FProc.in.Max
// Return max. number of bytes in the buffer.
inline i32 atf_exp::in_Max(atf_exp::FProc& proc) {
    return proc.in_max;
}

// --- atf_exp.FProc.in.N
// Return number of bytes in the buffer.
inline i32 atf_exp::in_N(atf_exp::FProc& proc) {
    return proc.in_end - proc.in_start;
}

// --- atf_exp.FProc.out.Max
// Return max. number of bytes in the buffer.
inline i32 atf_exp::out_Max(atf_exp::FProc& proc) {
    return proc.out_max;
}

// --- atf_exp.FProc.out.N
// Return number of bytes in the buffer.
inline i32 atf_exp::out_N(atf_exp::FProc& proc) {
    return proc.out_end - proc.out_start;
}

// --- atf_exp.FProc..Ctor
inline  atf_exp::FProc::FProc() {
    atf_exp::FProc_Init(*this);
    // added because atf_exp.FProc.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}

// --- atf_exp.FProc..Dtor
inline  atf_exp::FProc::~FProc() {
    atf_exp::FProc_Uninit(*this);
}

// --- atf_exp.FieldId.value.GetEnum
// Get value of field as enum type
inline atf_exp_FieldIdEnum atf_exp::value_GetEnum(const atf_exp::FieldId& parent) {
    return atf_exp_FieldIdEnum(parent.value);
}

// --- atf_exp.FieldId.value.SetEnum
// Set value of field from enum type.
inline void atf_exp::value_SetEnum(atf_exp::FieldId& parent, atf_exp_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- atf_exp.FieldId.value.Cast
inline  atf_exp::FieldId::operator atf_exp_FieldIdEnum() const {
    return atf_exp_FieldIdEnum((*this).value);
}

// --- atf_exp.FieldId..Init
// Set all fields to initial values.
inline void atf_exp::FieldId_Init(atf_exp::FieldId& parent) {
    parent.value = i32(-1);
}

// --- atf_exp.FieldId..Ctor
inline  atf_exp::FieldId::FieldId() {
    atf_exp::FieldId_Init(*this);
}

// --- atf_exp.FieldId..FieldwiseCtor
inline  atf_exp::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- atf_exp.FieldId..EnumCtor
inline  atf_exp::FieldId::FieldId(atf_exp_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- atf_exp.InCase.value.GetEnum
// Get value of field as enum type
inline atf_exp_InCaseEnum atf_exp::value_GetEnum(const atf_exp::InCase& parent) {
    return atf_exp_InCaseEnum(parent.value);
}

// --- atf_exp.InCase.value.SetEnum
// Set value of field from enum type.
inline void atf_exp::value_SetEnum(atf_exp::InCase& parent, atf_exp_InCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- atf_exp.InCase.value.Cast
inline  atf_exp::InCase::operator atf_exp_InCaseEnum() const {
    return atf_exp_InCaseEnum((*this).value);
}

// --- atf_exp.InCase..Init
// Set all fields to initial values.
inline void atf_exp::InCase_Init(atf_exp::InCase& parent) {
    parent.value = u32(0);
}

// --- atf_exp.InCase..Ctor
inline  atf_exp::InCase::InCase() {
    atf_exp::InCase_Init(*this);
}

// --- atf_exp.InCase..FieldwiseCtor
inline  atf_exp::InCase::InCase(u32 in_value)
    : value(in_value)
 {
}

// --- atf_exp.InCase..EnumCtor
inline  atf_exp::InCase::InCase(atf_exp_InCaseEnum arg) {
    this->value = u32(arg);
}

// --- atf_exp.Proc..Ctor
inline  atf_exp::Proc::Proc() {
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_exp::trace &row) {// cfmt:atf_exp.trace.String
    atf_exp::trace_Print(const_cast<atf_exp::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_exp::FieldId &row) {// cfmt:atf_exp.FieldId.String
    atf_exp::FieldId_Print(const_cast<atf_exp::FieldId&>(row), str);
    return str;
}
