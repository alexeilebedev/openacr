//
// include/gen/dmmeta_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
//#pragma endinclude
// gen:ns_enums
extern const char *  dmmeta_Buftype_pnewtype_Memptr;      // Memptr       fconst:dmmeta.Buftype.pnewtype/Memptr
extern const char *  dmmeta_Buftype_pnewtype_AmsStream;   // AmsStream    fconst:dmmeta.Buftype.pnewtype/AmsStream
extern const char *  dmmeta_Buftype_pnewtype_Fixed;       // Fixed        fconst:dmmeta.Buftype.pnewtype/Fixed
extern const char *  dmmeta_Buftype_pnewtype_Dynamic;     // Dynamic      fconst:dmmeta.Buftype.pnewtype/Dynamic
extern const char *  dmmeta_Buftype_pnewtype_ByteAry;     // ByteAry      fconst:dmmeta.Buftype.pnewtype/ByteAry
extern const char *  dmmeta_Buftype_pnewtype_Append;      // Append       fconst:dmmeta.Buftype.pnewtype/Append
extern const char *  dmmeta_Fbufdir_fbufdir_in;    // in     fconst:dmmeta.Fbufdir.fbufdir/in
extern const char *  dmmeta_Fbufdir_fbufdir_out;   // out    fconst:dmmeta.Fbufdir.fbufdir/out
extern const char *  dmmeta_Fbuftype_fbuftype_Bytebuf;   // Bytebuf    fconst:dmmeta.Fbuftype.fbuftype/Bytebuf
extern const char *  dmmeta_Fbuftype_fbuftype_Linebuf;   // Linebuf    fconst:dmmeta.Fbuftype.fbuftype/Linebuf
extern const char *  dmmeta_Fbuftype_fbuftype_Msgbuf;    // Msgbuf     fconst:dmmeta.Fbuftype.fbuftype/Msgbuf

// --- dmmeta_FieldIdEnum

enum dmmeta_FieldIdEnum {                        // dmmeta.FieldId.value
     dmmeta_FieldId_field                 = 0
    ,dmmeta_FieldId_comment               = 1
    ,dmmeta_FieldId_ctype                 = 2
    ,dmmeta_FieldId_argvtype              = 3
    ,dmmeta_FieldId_base                  = 4
    ,dmmeta_FieldId_name                  = 5
    ,dmmeta_FieldId_offset                = 6
    ,dmmeta_FieldId_width                 = 7
    ,dmmeta_FieldId_srcfield              = 8
    ,dmmeta_FieldId_pnewtype              = 9
    ,dmmeta_FieldId_cafter                = 10
    ,dmmeta_FieldId_after                 = 11
    ,dmmeta_FieldId_extrn                 = 12
    ,dmmeta_FieldId_genop                 = 13
    ,dmmeta_FieldId_order                 = 14
    ,dmmeta_FieldId_minmax                = 15
    ,dmmeta_FieldId_dflt                  = 16
    ,dmmeta_FieldId_cppdflt               = 17
    ,dmmeta_FieldId_ssimdflt              = 18
    ,dmmeta_FieldId_jsdflt                = 19
    ,dmmeta_FieldId_initmemset            = 20
    ,dmmeta_FieldId_isstruct              = 21
    ,dmmeta_FieldId_cfmt                  = 22
    ,dmmeta_FieldId_strfmt                = 23
    ,dmmeta_FieldId_printfmt              = 24
    ,dmmeta_FieldId_read                  = 25
    ,dmmeta_FieldId_print                 = 26
    ,dmmeta_FieldId_sep                   = 27
    ,dmmeta_FieldId_expr                  = 28
    ,dmmeta_FieldId_charrange             = 29
    ,dmmeta_FieldId_calc                  = 30
    ,dmmeta_FieldId_hashtype              = 31
    ,dmmeta_FieldId_cppkeyword            = 32
    ,dmmeta_FieldId_ctor                  = 33
    ,dmmeta_FieldId_dtor                  = 34
    ,dmmeta_FieldId_cheap_copy            = 35
    ,dmmeta_FieldId_size                  = 36
    ,dmmeta_FieldId_alignment             = 37
    ,dmmeta_FieldId_strequiv              = 38
    ,dmmeta_FieldId_ns                    = 39
    ,dmmeta_FieldId_len                   = 40
    ,dmmeta_FieldId_padbytes              = 41
    ,dmmeta_FieldId_dispatch              = 42
    ,dmmeta_FieldId_unk                   = 43
    ,dmmeta_FieldId_haslen                = 44
    ,dmmeta_FieldId_call                  = 45
    ,dmmeta_FieldId_strict                = 46
    ,dmmeta_FieldId_dispatch_msg          = 47
    ,dmmeta_FieldId_match_all             = 48
    ,dmmeta_FieldId_dispsig               = 49
    ,dmmeta_FieldId_signature             = 50
    ,dmmeta_FieldId_cycle                 = 51
    ,dmmeta_FieldId_stripcomment          = 52
    ,dmmeta_FieldId_fbufdir               = 53
    ,dmmeta_FieldId_max                   = 54
    ,dmmeta_FieldId_fbuftype              = 55
    ,dmmeta_FieldId_insready              = 56
    ,dmmeta_FieldId_inseof                = 57
    ,dmmeta_FieldId_getmsg                = 58
    ,dmmeta_FieldId_skipbytes             = 59
    ,dmmeta_FieldId_fcmap                 = 60
    ,dmmeta_FieldId_leftField             = 61
    ,dmmeta_FieldId_leftVal               = 62
    ,dmmeta_FieldId_rightVal              = 63
    ,dmmeta_FieldId_rightField            = 64
    ,dmmeta_FieldId_bidir                 = 65
    ,dmmeta_FieldId_basecmdline           = 66
    ,dmmeta_FieldId_versionsort           = 67
    ,dmmeta_FieldId_casesens              = 68
    ,dmmeta_FieldId_fconst                = 69
    ,dmmeta_FieldId_value                 = 70
    ,dmmeta_FieldId_fcurs                 = 71
    ,dmmeta_FieldId_curstype              = 72
    ,dmmeta_FieldId_nplace                = 73
    ,dmmeta_FieldId_fixedfmt              = 74
    ,dmmeta_FieldId_fstep                 = 75
    ,dmmeta_FieldId_delay                 = 76
    ,dmmeta_FieldId_scale                 = 77
    ,dmmeta_FieldId_cumulative            = 78
    ,dmmeta_FieldId_emptyval              = 79
    ,dmmeta_FieldId_arg                   = 80
    ,dmmeta_FieldId_reftype               = 81
    ,dmmeta_FieldId_update                = 82
    ,dmmeta_FieldId_fprefix               = 83
    ,dmmeta_FieldId_partial               = 84
    ,dmmeta_FieldId_regxtype              = 85
    ,dmmeta_FieldId_sorttype              = 86
    ,dmmeta_FieldId_sortfld               = 87
    ,dmmeta_FieldId_steptype              = 88
    ,dmmeta_FieldId_func                  = 89
    ,dmmeta_FieldId_inl                   = 90
    ,dmmeta_FieldId_proto                 = 91
    ,dmmeta_FieldId_body                  = 92
    ,dmmeta_FieldId_deprecate             = 93
    ,dmmeta_FieldId_ismacro               = 94
    ,dmmeta_FieldId_glob                  = 95
    ,dmmeta_FieldId_priv                  = 96
    ,dmmeta_FieldId_ret                   = 97
    ,dmmeta_FieldId_fwddecl               = 98
    ,dmmeta_FieldId_namefld               = 99
    ,dmmeta_FieldId_idfld                 = 100
    ,dmmeta_FieldId_wantenum              = 101
    ,dmmeta_FieldId_namefldctyp           = 102
    ,dmmeta_FieldId_gsymbol               = 103
    ,dmmeta_FieldId_ssimfile              = 104
    ,dmmeta_FieldId_inc                   = 105
    ,dmmeta_FieldId_symboltype            = 106
    ,dmmeta_FieldId_min                   = 107
    ,dmmeta_FieldId_extra                 = 108
    ,dmmeta_FieldId_listtype              = 109
    ,dmmeta_FieldId_circular              = 110
    ,dmmeta_FieldId_haveprev              = 111
    ,dmmeta_FieldId_instail               = 112
    ,dmmeta_FieldId_havetail              = 113
    ,dmmeta_FieldId_havecount             = 114
    ,dmmeta_FieldId_logcat                = 115
    ,dmmeta_FieldId_enabled               = 116
    ,dmmeta_FieldId_builtin               = 117
    ,dmmeta_FieldId_ismodule              = 118
    ,dmmeta_FieldId_type                  = 119
    ,dmmeta_FieldId_xref                  = 120
    ,dmmeta_FieldId_nstype                = 121
    ,dmmeta_FieldId_license               = 122
    ,dmmeta_FieldId_nsinclude             = 123
    ,dmmeta_FieldId_sys                   = 124
    ,dmmeta_FieldId_version               = 125
    ,dmmeta_FieldId_genthrow              = 126
    ,dmmeta_FieldId_correct_getorcreate   = 127
    ,dmmeta_FieldId_pool                  = 128
    ,dmmeta_FieldId_sortxref              = 129
    ,dmmeta_FieldId_pack                  = 130
    ,dmmeta_FieldId_numtype               = 131
    ,dmmeta_FieldId_min_len               = 132
    ,dmmeta_FieldId_pnew                  = 133
    ,dmmeta_FieldId_buftype               = 134
    ,dmmeta_FieldId_unique                = 135
    ,dmmeta_FieldId_isval                 = 136
    ,dmmeta_FieldId_cascins               = 137
    ,dmmeta_FieldId_usebasepool           = 138
    ,dmmeta_FieldId_cancopy               = 139
    ,dmmeta_FieldId_isxref                = 140
    ,dmmeta_FieldId_del                   = 141
    ,dmmeta_FieldId_up                    = 142
    ,dmmeta_FieldId_isnew                 = 143
    ,dmmeta_FieldId_hasalloc              = 144
    ,dmmeta_FieldId_inst                  = 145
    ,dmmeta_FieldId_varlen                = 146
    ,dmmeta_FieldId_length                = 147
    ,dmmeta_FieldId_strtype               = 148
    ,dmmeta_FieldId_pad                   = 149
    ,dmmeta_FieldId_ssimns                = 150
    ,dmmeta_FieldId_maxwid                = 151
    ,dmmeta_FieldId_fixedwid1             = 152
    ,dmmeta_FieldId_fixedwid2             = 153
    ,dmmeta_FieldId_aliased               = 154
    ,dmmeta_FieldId_hashfld               = 155
    ,dmmeta_FieldId_tracefld              = 156
    ,dmmeta_FieldId_tracerec              = 157
    ,dmmeta_FieldId_inscond               = 158
    ,dmmeta_FieldId_via                   = 159
    ,dmmeta_FieldId_viafld                = 160
    ,dmmeta_FieldId_keyfld                = 161
};

enum { dmmeta_FieldIdEnum_N = 162 };

extern const char *  dmmeta_Hashtype_hashtype_Extern;   // Extern    fconst:dmmeta.Hashtype.hashtype/Extern
extern const char *  dmmeta_Hashtype_hashtype_CRC32;    // CRC32     fconst:dmmeta.Hashtype.hashtype/CRC32
extern const char *  dmmeta_Ns_ns_;               //                 fconst:dmmeta.Ns.ns/
extern const char *  dmmeta_Ns_ns_abt;            // abt             fconst:dmmeta.Ns.ns/abt
extern const char *  dmmeta_Ns_ns_abt_md;         // abt_md          fconst:dmmeta.Ns.ns/abt_md
extern const char *  dmmeta_Ns_ns_acr;            // acr             fconst:dmmeta.Ns.ns/acr
extern const char *  dmmeta_Ns_ns_acr_compl;      // acr_compl       fconst:dmmeta.Ns.ns/acr_compl
extern const char *  dmmeta_Ns_ns_acr_dm;         // acr_dm          fconst:dmmeta.Ns.ns/acr_dm
extern const char *  dmmeta_Ns_ns_acr_ed;         // acr_ed          fconst:dmmeta.Ns.ns/acr_ed
extern const char *  dmmeta_Ns_ns_acr_in;         // acr_in          fconst:dmmeta.Ns.ns/acr_in
extern const char *  dmmeta_Ns_ns_acr_my;         // acr_my          fconst:dmmeta.Ns.ns/acr_my
extern const char *  dmmeta_Ns_ns_algo;           // algo            fconst:dmmeta.Ns.ns/algo
extern const char *  dmmeta_Ns_ns_algo_lib;       // algo_lib        fconst:dmmeta.Ns.ns/algo_lib
extern const char *  dmmeta_Ns_ns_algo_pch;       // algo_pch        fconst:dmmeta.Ns.ns/algo_pch
extern const char *  dmmeta_Ns_ns_amc;            // amc             fconst:dmmeta.Ns.ns/amc
extern const char *  dmmeta_Ns_ns_amc_gc;         // amc_gc          fconst:dmmeta.Ns.ns/amc_gc
extern const char *  dmmeta_Ns_ns_amc_vis;        // amc_vis         fconst:dmmeta.Ns.ns/amc_vis
extern const char *  dmmeta_Ns_ns_amcdb;          // amcdb           fconst:dmmeta.Ns.ns/amcdb
extern const char *  dmmeta_Ns_ns_ams;            // ams             fconst:dmmeta.Ns.ns/ams
extern const char *  dmmeta_Ns_ns_ams_cat;        // ams_cat         fconst:dmmeta.Ns.ns/ams_cat
extern const char *  dmmeta_Ns_ns_ams_sendtest;   // ams_sendtest    fconst:dmmeta.Ns.ns/ams_sendtest
extern const char *  dmmeta_Ns_ns_amsdb;          // amsdb           fconst:dmmeta.Ns.ns/amsdb
extern const char *  dmmeta_Ns_ns_atf;            // atf             fconst:dmmeta.Ns.ns/atf
extern const char *  dmmeta_Ns_ns_atf_amc;        // atf_amc         fconst:dmmeta.Ns.ns/atf_amc
extern const char *  dmmeta_Ns_ns_atf_ci;         // atf_ci          fconst:dmmeta.Ns.ns/atf_ci
extern const char *  dmmeta_Ns_ns_atf_cmdline;    // atf_cmdline     fconst:dmmeta.Ns.ns/atf_cmdline
extern const char *  dmmeta_Ns_ns_atf_comp;       // atf_comp        fconst:dmmeta.Ns.ns/atf_comp
extern const char *  dmmeta_Ns_ns_atf_cov;        // atf_cov         fconst:dmmeta.Ns.ns/atf_cov
extern const char *  dmmeta_Ns_ns_atf_fuzz;       // atf_fuzz        fconst:dmmeta.Ns.ns/atf_fuzz
extern const char *  dmmeta_Ns_ns_atf_gcli;       // atf_gcli        fconst:dmmeta.Ns.ns/atf_gcli
extern const char *  dmmeta_Ns_ns_atf_nrun;       // atf_nrun        fconst:dmmeta.Ns.ns/atf_nrun
extern const char *  dmmeta_Ns_ns_atf_unit;       // atf_unit        fconst:dmmeta.Ns.ns/atf_unit
extern const char *  dmmeta_Ns_ns_atfdb;          // atfdb           fconst:dmmeta.Ns.ns/atfdb
extern const char *  dmmeta_Ns_ns_bash2html;      // bash2html       fconst:dmmeta.Ns.ns/bash2html
extern const char *  dmmeta_Ns_ns_command;        // command         fconst:dmmeta.Ns.ns/command
extern const char *  dmmeta_Ns_ns_dev;            // dev             fconst:dmmeta.Ns.ns/dev
extern const char *  dmmeta_Ns_ns_dmmeta;         // dmmeta          fconst:dmmeta.Ns.ns/dmmeta
extern const char *  dmmeta_Ns_ns_fm;             // fm              fconst:dmmeta.Ns.ns/fm
extern const char *  dmmeta_Ns_ns_fmdb;           // fmdb            fconst:dmmeta.Ns.ns/fmdb
extern const char *  dmmeta_Ns_ns_gcache;         // gcache          fconst:dmmeta.Ns.ns/gcache
extern const char *  dmmeta_Ns_ns_gcli;           // gcli            fconst:dmmeta.Ns.ns/gcli
extern const char *  dmmeta_Ns_ns_gclidb;         // gclidb          fconst:dmmeta.Ns.ns/gclidb
extern const char *  dmmeta_Ns_ns_ietf;           // ietf            fconst:dmmeta.Ns.ns/ietf
extern const char *  dmmeta_Ns_ns_lib_amcdb;      // lib_amcdb       fconst:dmmeta.Ns.ns/lib_amcdb
extern const char *  dmmeta_Ns_ns_lib_ams;        // lib_ams         fconst:dmmeta.Ns.ns/lib_ams
extern const char *  dmmeta_Ns_ns_lib_ctype;      // lib_ctype       fconst:dmmeta.Ns.ns/lib_ctype
extern const char *  dmmeta_Ns_ns_lib_exec;       // lib_exec        fconst:dmmeta.Ns.ns/lib_exec
extern const char *  dmmeta_Ns_ns_lib_fm;         // lib_fm          fconst:dmmeta.Ns.ns/lib_fm
extern const char *  dmmeta_Ns_ns_lib_git;        // lib_git         fconst:dmmeta.Ns.ns/lib_git
extern const char *  dmmeta_Ns_ns_lib_iconv;      // lib_iconv       fconst:dmmeta.Ns.ns/lib_iconv
extern const char *  dmmeta_Ns_ns_lib_json;       // lib_json        fconst:dmmeta.Ns.ns/lib_json
extern const char *  dmmeta_Ns_ns_lib_mysql;      // lib_mysql       fconst:dmmeta.Ns.ns/lib_mysql
extern const char *  dmmeta_Ns_ns_lib_prot;       // lib_prot        fconst:dmmeta.Ns.ns/lib_prot
extern const char *  dmmeta_Ns_ns_lib_sql;        // lib_sql         fconst:dmmeta.Ns.ns/lib_sql
extern const char *  dmmeta_Ns_ns_mdbg;           // mdbg            fconst:dmmeta.Ns.ns/mdbg
extern const char *  dmmeta_Ns_ns_mysql2ssim;     // mysql2ssim      fconst:dmmeta.Ns.ns/mysql2ssim
extern const char *  dmmeta_Ns_ns_orgfile;        // orgfile         fconst:dmmeta.Ns.ns/orgfile
extern const char *  dmmeta_Ns_ns_report;         // report          fconst:dmmeta.Ns.ns/report
extern const char *  dmmeta_Ns_ns_samp_regx;      // samp_regx       fconst:dmmeta.Ns.ns/samp_regx
extern const char *  dmmeta_Ns_ns_sandbox;        // sandbox         fconst:dmmeta.Ns.ns/sandbox
extern const char *  dmmeta_Ns_ns_src_func;       // src_func        fconst:dmmeta.Ns.ns/src_func
extern const char *  dmmeta_Ns_ns_src_hdr;        // src_hdr         fconst:dmmeta.Ns.ns/src_hdr
extern const char *  dmmeta_Ns_ns_src_lim;        // src_lim         fconst:dmmeta.Ns.ns/src_lim
extern const char *  dmmeta_Ns_ns_ssim2csv;       // ssim2csv        fconst:dmmeta.Ns.ns/ssim2csv
extern const char *  dmmeta_Ns_ns_ssim2mysql;     // ssim2mysql      fconst:dmmeta.Ns.ns/ssim2mysql
extern const char *  dmmeta_Ns_ns_ssimfilt;       // ssimfilt        fconst:dmmeta.Ns.ns/ssimfilt
extern const char *  dmmeta_Ns_ns_strconv;        // strconv         fconst:dmmeta.Ns.ns/strconv
extern const char *  dmmeta_Ns_ns_sv2ssim;        // sv2ssim         fconst:dmmeta.Ns.ns/sv2ssim
extern const char *  dmmeta_Nstype_nstype_exe;        // exe         fconst:dmmeta.Nstype.nstype/exe
extern const char *  dmmeta_Nstype_nstype_lib;        // lib         fconst:dmmeta.Nstype.nstype/lib
extern const char *  dmmeta_Nstype_nstype_none;       // none        fconst:dmmeta.Nstype.nstype/none
extern const char *  dmmeta_Nstype_nstype_objlist;    // objlist     fconst:dmmeta.Nstype.nstype/objlist
extern const char *  dmmeta_Nstype_nstype_pch;        // pch         fconst:dmmeta.Nstype.nstype/pch
extern const char *  dmmeta_Nstype_nstype_protocol;   // protocol    fconst:dmmeta.Nstype.nstype/protocol
extern const char *  dmmeta_Nstype_nstype_ssimdb;     // ssimdb      fconst:dmmeta.Nstype.nstype/ssimdb
extern const char *  dmmeta_Printfmt_printfmt_Auto;         // Auto          fconst:dmmeta.Printfmt.printfmt/Auto
extern const char *  dmmeta_Printfmt_printfmt_Bitset;       // Bitset        fconst:dmmeta.Printfmt.printfmt/Bitset
extern const char *  dmmeta_Printfmt_printfmt_CompactSep;   // CompactSep    fconst:dmmeta.Printfmt.printfmt/CompactSep
extern const char *  dmmeta_Printfmt_printfmt_Extern;       // Extern        fconst:dmmeta.Printfmt.printfmt/Extern
extern const char *  dmmeta_Printfmt_printfmt_Raw;          // Raw           fconst:dmmeta.Printfmt.printfmt/Raw
extern const char *  dmmeta_Printfmt_printfmt_Sep;          // Sep           fconst:dmmeta.Printfmt.printfmt/Sep
extern const char *  dmmeta_Printfmt_printfmt_Tuple;        // Tuple         fconst:dmmeta.Printfmt.printfmt/Tuple
extern const char *  dmmeta_Reftype_reftype_Alias;      // Alias       fconst:dmmeta.Reftype.reftype/Alias
extern const char *  dmmeta_Reftype_reftype_Atree;      // Atree       fconst:dmmeta.Reftype.reftype/Atree
extern const char *  dmmeta_Reftype_reftype_Base;       // Base        fconst:dmmeta.Reftype.reftype/Base
extern const char *  dmmeta_Reftype_reftype_Bheap;      // Bheap       fconst:dmmeta.Reftype.reftype/Bheap
extern const char *  dmmeta_Reftype_reftype_Bitfld;     // Bitfld      fconst:dmmeta.Reftype.reftype/Bitfld
extern const char *  dmmeta_Reftype_reftype_Blkpool;    // Blkpool     fconst:dmmeta.Reftype.reftype/Blkpool
extern const char *  dmmeta_Reftype_reftype_Charset;    // Charset     fconst:dmmeta.Reftype.reftype/Charset
extern const char *  dmmeta_Reftype_reftype_Count;      // Count       fconst:dmmeta.Reftype.reftype/Count
extern const char *  dmmeta_Reftype_reftype_Cppstack;   // Cppstack    fconst:dmmeta.Reftype.reftype/Cppstack
extern const char *  dmmeta_Reftype_reftype_Delptr;     // Delptr      fconst:dmmeta.Reftype.reftype/Delptr
extern const char *  dmmeta_Reftype_reftype_Exec;       // Exec        fconst:dmmeta.Reftype.reftype/Exec
extern const char *  dmmeta_Reftype_reftype_Fbuf;       // Fbuf        fconst:dmmeta.Reftype.reftype/Fbuf
extern const char *  dmmeta_Reftype_reftype_Global;     // Global      fconst:dmmeta.Reftype.reftype/Global
extern const char *  dmmeta_Reftype_reftype_Hook;       // Hook        fconst:dmmeta.Reftype.reftype/Hook
extern const char *  dmmeta_Reftype_reftype_Inlary;     // Inlary      fconst:dmmeta.Reftype.reftype/Inlary
extern const char *  dmmeta_Reftype_reftype_Lary;       // Lary        fconst:dmmeta.Reftype.reftype/Lary
extern const char *  dmmeta_Reftype_reftype_Llist;      // Llist       fconst:dmmeta.Reftype.reftype/Llist
extern const char *  dmmeta_Reftype_reftype_Lpool;      // Lpool       fconst:dmmeta.Reftype.reftype/Lpool
extern const char *  dmmeta_Reftype_reftype_Malloc;     // Malloc      fconst:dmmeta.Reftype.reftype/Malloc
extern const char *  dmmeta_Reftype_reftype_Opt;        // Opt         fconst:dmmeta.Reftype.reftype/Opt
extern const char *  dmmeta_Reftype_reftype_Pkey;       // Pkey        fconst:dmmeta.Reftype.reftype/Pkey
extern const char *  dmmeta_Reftype_reftype_Protocol;   // Protocol    fconst:dmmeta.Reftype.reftype/Protocol
extern const char *  dmmeta_Reftype_reftype_Ptr;        // Ptr         fconst:dmmeta.Reftype.reftype/Ptr
extern const char *  dmmeta_Reftype_reftype_Ptrary;     // Ptrary      fconst:dmmeta.Reftype.reftype/Ptrary
extern const char *  dmmeta_Reftype_reftype_Regx;       // Regx        fconst:dmmeta.Reftype.reftype/Regx
extern const char *  dmmeta_Reftype_reftype_RegxSql;    // RegxSql     fconst:dmmeta.Reftype.reftype/RegxSql
extern const char *  dmmeta_Reftype_reftype_Sbrk;       // Sbrk        fconst:dmmeta.Reftype.reftype/Sbrk
extern const char *  dmmeta_Reftype_reftype_Smallstr;   // Smallstr    fconst:dmmeta.Reftype.reftype/Smallstr
extern const char *  dmmeta_Reftype_reftype_Tary;       // Tary        fconst:dmmeta.Reftype.reftype/Tary
extern const char *  dmmeta_Reftype_reftype_Thash;      // Thash       fconst:dmmeta.Reftype.reftype/Thash
extern const char *  dmmeta_Reftype_reftype_Tpool;      // Tpool       fconst:dmmeta.Reftype.reftype/Tpool
extern const char *  dmmeta_Reftype_reftype_Upptr;      // Upptr       fconst:dmmeta.Reftype.reftype/Upptr
extern const char *  dmmeta_Reftype_reftype_Val;        // Val         fconst:dmmeta.Reftype.reftype/Val
extern const char *  dmmeta_Reftype_reftype_Varlen;     // Varlen      fconst:dmmeta.Reftype.reftype/Varlen
extern const char *  dmmeta_Reftype_reftype_ZSListMT;   // ZSListMT    fconst:dmmeta.Reftype.reftype/ZSListMT

// --- dmmeta_ReftypeCaseEnum

enum dmmeta_ReftypeCaseEnum {            // dmmeta.ReftypeCase.reftype
     dmmeta_ReftypeCase_Alias      = 1
    ,dmmeta_ReftypeCase_Atree      = 2
    ,dmmeta_ReftypeCase_Base       = 3
    ,dmmeta_ReftypeCase_Bheap      = 4
    ,dmmeta_ReftypeCase_Bitfld     = 5
    ,dmmeta_ReftypeCase_Blkpool    = 6
    ,dmmeta_ReftypeCase_Charset    = 7
    ,dmmeta_ReftypeCase_Count      = 8
    ,dmmeta_ReftypeCase_Cppstack   = 9
    ,dmmeta_ReftypeCase_Delptr     = 10
    ,dmmeta_ReftypeCase_Exec       = 11
    ,dmmeta_ReftypeCase_Fbuf       = 12
    ,dmmeta_ReftypeCase_Global     = 13
    ,dmmeta_ReftypeCase_Hook       = 14
    ,dmmeta_ReftypeCase_Inlary     = 15
    ,dmmeta_ReftypeCase_Lary       = 16
    ,dmmeta_ReftypeCase_Llist      = 17
    ,dmmeta_ReftypeCase_Lpool      = 18
    ,dmmeta_ReftypeCase_Malloc     = 19
    ,dmmeta_ReftypeCase_Opt        = 20
    ,dmmeta_ReftypeCase_Pkey       = 21
    ,dmmeta_ReftypeCase_Protocol   = 22
    ,dmmeta_ReftypeCase_Ptr        = 23
    ,dmmeta_ReftypeCase_Ptrary     = 24
    ,dmmeta_ReftypeCase_Regx       = 25
    ,dmmeta_ReftypeCase_RegxSql    = 26
    ,dmmeta_ReftypeCase_Sbrk       = 27
    ,dmmeta_ReftypeCase_Smallstr   = 28
    ,dmmeta_ReftypeCase_Tary       = 29
    ,dmmeta_ReftypeCase_Thash      = 30
    ,dmmeta_ReftypeCase_Tpool      = 31
    ,dmmeta_ReftypeCase_Upptr      = 32
    ,dmmeta_ReftypeCase_Val        = 33
    ,dmmeta_ReftypeCase_Varlen     = 34
    ,dmmeta_ReftypeCase_ZSListMT   = 35
};

enum { dmmeta_ReftypeCaseEnum_N = 35 };

extern const char *  dmmeta_Sorttype_sorttype_QuickSort;       // QuickSort        fconst:dmmeta.Sorttype.sorttype/QuickSort
extern const char *  dmmeta_Sorttype_sorttype_InsertionSort;   // InsertionSort    fconst:dmmeta.Sorttype.sorttype/InsertionSort
extern const char *  dmmeta_Sorttype_sorttype_HeapSort;        // HeapSort         fconst:dmmeta.Sorttype.sorttype/HeapSort
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_bltin;                 // amcdb.bltin                  fconst:dmmeta.Ssimfile.ssimfile/amcdb.bltin
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_curstype;              // amcdb.curstype               fconst:dmmeta.Ssimfile.ssimfile/amcdb.curstype
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_gen;                   // amcdb.gen                    fconst:dmmeta.Ssimfile.ssimfile/amcdb.gen
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_regxtype;              // amcdb.regxtype               fconst:dmmeta.Ssimfile.ssimfile/amcdb.regxtype
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tclass;                // amcdb.tclass                 fconst:dmmeta.Ssimfile.ssimfile/amcdb.tclass
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tcurs;                 // amcdb.tcurs                  fconst:dmmeta.Ssimfile.ssimfile/amcdb.tcurs
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tfunc;                 // amcdb.tfunc                  fconst:dmmeta.Ssimfile.ssimfile/amcdb.tfunc
extern const char *  dmmeta_Ssimfile_ssimfile_amsdb_proctype;              // amsdb.proctype               fconst:dmmeta.Ssimfile.ssimfile/amsdb.proctype
extern const char *  dmmeta_Ssimfile_ssimfile_amsdb_streamtype;            // amsdb.streamtype             fconst:dmmeta.Ssimfile.ssimfile/amsdb.streamtype
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_amctest;               // atfdb.amctest                fconst:dmmeta.Ssimfile.ssimfile/atfdb.amctest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_cijob;                 // atfdb.cijob                  fconst:dmmeta.Ssimfile.ssimfile/atfdb.cijob
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_citest;                // atfdb.citest                 fconst:dmmeta.Ssimfile.ssimfile/atfdb.citest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_comptest;              // atfdb.comptest               fconst:dmmeta.Ssimfile.ssimfile/atfdb.comptest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_fuzzstrat;             // atfdb.fuzzstrat              fconst:dmmeta.Ssimfile.ssimfile/atfdb.fuzzstrat
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_msgdir;                // atfdb.msgdir                 fconst:dmmeta.Ssimfile.ssimfile/atfdb.msgdir
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_targs;                 // atfdb.targs                  fconst:dmmeta.Ssimfile.ssimfile/atfdb.targs
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_char;     // atfdb.test_gsymbol_char      fconst:dmmeta.Ssimfile.ssimfile/atfdb.test_gsymbol_char
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_pkey;     // atfdb.test_gsymbol_pkey      fconst:dmmeta.Ssimfile.ssimfile/atfdb.test_gsymbol_pkey
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_strptr;   // atfdb.test_gsymbol_strptr    fconst:dmmeta.Ssimfile.ssimfile/atfdb.test_gsymbol_strptr
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_tfilt;                 // atfdb.tfilt                  fconst:dmmeta.Ssimfile.ssimfile/atfdb.tfilt
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_tmsg;                  // atfdb.tmsg                   fconst:dmmeta.Ssimfile.ssimfile/atfdb.tmsg
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_unittest;              // atfdb.unittest               fconst:dmmeta.Ssimfile.ssimfile/atfdb.unittest
extern const char *  dmmeta_Ssimfile_ssimfile_dev_arch;                    // dev.arch                     fconst:dmmeta.Ssimfile.ssimfile/dev.arch
extern const char *  dmmeta_Ssimfile_ssimfile_dev_badline;                 // dev.badline                  fconst:dmmeta.Ssimfile.ssimfile/dev.badline
extern const char *  dmmeta_Ssimfile_ssimfile_dev_builddir;                // dev.builddir                 fconst:dmmeta.Ssimfile.ssimfile/dev.builddir
extern const char *  dmmeta_Ssimfile_ssimfile_dev_cfg;                     // dev.cfg                      fconst:dmmeta.Ssimfile.ssimfile/dev.cfg
extern const char *  dmmeta_Ssimfile_ssimfile_dev_compiler;                // dev.compiler                 fconst:dmmeta.Ssimfile.ssimfile/dev.compiler
extern const char *  dmmeta_Ssimfile_ssimfile_dev_covfile;                 // dev.covfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.covfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_covline;                 // dev.covline                  fconst:dmmeta.Ssimfile.ssimfile/dev.covline
extern const char *  dmmeta_Ssimfile_ssimfile_dev_covtarget;               // dev.covtarget                fconst:dmmeta.Ssimfile.ssimfile/dev.covtarget
extern const char *  dmmeta_Ssimfile_ssimfile_dev_edaction;                // dev.edaction                 fconst:dmmeta.Ssimfile.ssimfile/dev.edaction
extern const char *  dmmeta_Ssimfile_ssimfile_dev_edacttype;               // dev.edacttype                fconst:dmmeta.Ssimfile.ssimfile/dev.edacttype
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitfile;                 // dev.gitfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.gitfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitinfo;                 // dev.gitinfo                  fconst:dmmeta.Ssimfile.ssimfile/dev.gitinfo
extern const char *  dmmeta_Ssimfile_ssimfile_dev_hilite;                  // dev.hilite                   fconst:dmmeta.Ssimfile.ssimfile/dev.hilite
extern const char *  dmmeta_Ssimfile_ssimfile_dev_htmlentity;              // dev.htmlentity               fconst:dmmeta.Ssimfile.ssimfile/dev.htmlentity
extern const char *  dmmeta_Ssimfile_ssimfile_dev_include;                 // dev.include                  fconst:dmmeta.Ssimfile.ssimfile/dev.include
extern const char *  dmmeta_Ssimfile_ssimfile_dev_license;                 // dev.license                  fconst:dmmeta.Ssimfile.ssimfile/dev.license
extern const char *  dmmeta_Ssimfile_ssimfile_dev_linelim;                 // dev.linelim                  fconst:dmmeta.Ssimfile.ssimfile/dev.linelim
extern const char *  dmmeta_Ssimfile_ssimfile_dev_mdsection;               // dev.mdsection                fconst:dmmeta.Ssimfile.ssimfile/dev.mdsection
extern const char *  dmmeta_Ssimfile_ssimfile_dev_msgfile;                 // dev.msgfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.msgfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_noindent;                // dev.noindent                 fconst:dmmeta.Ssimfile.ssimfile/dev.noindent
extern const char *  dmmeta_Ssimfile_ssimfile_dev_opt_type;                // dev.opt_type                 fconst:dmmeta.Ssimfile.ssimfile/dev.opt_type
extern const char *  dmmeta_Ssimfile_ssimfile_dev_readme;                  // dev.readme                   fconst:dmmeta.Ssimfile.ssimfile/dev.readme
extern const char *  dmmeta_Ssimfile_ssimfile_dev_readmens;                // dev.readmens                 fconst:dmmeta.Ssimfile.ssimfile/dev.readmens
extern const char *  dmmeta_Ssimfile_ssimfile_dev_sandbox;                 // dev.sandbox                  fconst:dmmeta.Ssimfile.ssimfile/dev.sandbox
extern const char *  dmmeta_Ssimfile_ssimfile_dev_sbpath;                  // dev.sbpath                   fconst:dmmeta.Ssimfile.ssimfile/dev.sbpath
extern const char *  dmmeta_Ssimfile_ssimfile_dev_scriptfile;              // dev.scriptfile               fconst:dmmeta.Ssimfile.ssimfile/dev.scriptfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_srcfile;                 // dev.srcfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.srcfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_ssimfs;                  // dev.ssimfs                   fconst:dmmeta.Ssimfile.ssimfile/dev.ssimfs
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syscmd;                  // dev.syscmd                   fconst:dmmeta.Ssimfile.ssimfile/dev.syscmd
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syscmddep;               // dev.syscmddep                fconst:dmmeta.Ssimfile.ssimfile/dev.syscmddep
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syslib;                  // dev.syslib                   fconst:dmmeta.Ssimfile.ssimfile/dev.syslib
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targdep;                 // dev.targdep                  fconst:dmmeta.Ssimfile.ssimfile/dev.targdep
extern const char *  dmmeta_Ssimfile_ssimfile_dev_target;                  // dev.target                   fconst:dmmeta.Ssimfile.ssimfile/dev.target
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targsrc;                 // dev.targsrc                  fconst:dmmeta.Ssimfile.ssimfile/dev.targsrc
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targsyslib;              // dev.targsyslib               fconst:dmmeta.Ssimfile.ssimfile/dev.targsyslib
extern const char *  dmmeta_Ssimfile_ssimfile_dev_tgtcov;                  // dev.tgtcov                   fconst:dmmeta.Ssimfile.ssimfile/dev.tgtcov
extern const char *  dmmeta_Ssimfile_ssimfile_dev_timefmt;                 // dev.timefmt                  fconst:dmmeta.Ssimfile.ssimfile/dev.timefmt
extern const char *  dmmeta_Ssimfile_ssimfile_dev_tool_opt;                // dev.tool_opt                 fconst:dmmeta.Ssimfile.ssimfile/dev.tool_opt
extern const char *  dmmeta_Ssimfile_ssimfile_dev_uname;                   // dev.uname                    fconst:dmmeta.Ssimfile.ssimfile/dev.uname
extern const char *  dmmeta_Ssimfile_ssimfile_dev_unstablefld;             // dev.unstablefld              fconst:dmmeta.Ssimfile.ssimfile/dev.unstablefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_anonfld;              // dmmeta.anonfld               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.anonfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_argvtype;             // dmmeta.argvtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.argvtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_basepool;             // dmmeta.basepool              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.basepool
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_bitfld;               // dmmeta.bitfld                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.bitfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cafter;               // dmmeta.cafter                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cafter
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cascdel;              // dmmeta.cascdel               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cascdel
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ccmp;                 // dmmeta.ccmp                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ccmp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cdflt;                // dmmeta.cdflt                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cdflt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cextern;              // dmmeta.cextern               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cextern
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cfmt;                 // dmmeta.cfmt                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cget;                 // dmmeta.cget                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cget
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_charset;              // dmmeta.charset               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.charset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_chash;                // dmmeta.chash                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.chash
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cppfunc;              // dmmeta.cppfunc               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cppfunc
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cppkeyword;           // dmmeta.cppkeyword            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cppkeyword
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cpptype;              // dmmeta.cpptype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cpptype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_csize;                // dmmeta.csize                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.csize
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cstr;                 // dmmeta.cstr                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ctype;                // dmmeta.ctype                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ctype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ctypelen;             // dmmeta.ctypelen              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ctypelen
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispatch;             // dmmeta.dispatch              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispatch
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispatch_msg;         // dmmeta.dispatch_msg          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispatch_msg
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispctx;              // dmmeta.dispctx               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispctx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispfilter;           // dmmeta.dispfilter            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispfilter
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispsig;              // dmmeta.dispsig               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispsig
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispsigcheck;         // dmmeta.dispsigcheck          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispsigcheck
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_disptrace;            // dmmeta.disptrace             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.disptrace
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_falias;               // dmmeta.falias                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.falias
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbase;                // dmmeta.fbase                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbase
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbigend;              // dmmeta.fbigend               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbigend
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbitset;              // dmmeta.fbitset               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbitset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbuf;                 // dmmeta.fbuf                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbuf
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbufdir;              // dmmeta.fbufdir               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbufdir
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbuftype;             // dmmeta.fbuftype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbuftype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcast;                // dmmeta.fcast                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcast
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcleanup;             // dmmeta.fcleanup              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcleanup
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmap;                // dmmeta.fcmap                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmap
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmdline;             // dmmeta.fcmdline              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmdline
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmp;                 // dmmeta.fcmp                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcompact;             // dmmeta.fcompact              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcompact
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fconst;               // dmmeta.fconst                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fconst
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcurs;                // dmmeta.fcurs                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcurs
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fdec;                 // dmmeta.fdec                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fdec
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fdelay;               // dmmeta.fdelay                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fdelay
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fflag;                // dmmeta.fflag                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fflag
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_field;                // dmmeta.field                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.field
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_findrem;              // dmmeta.findrem               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.findrem
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_finput;               // dmmeta.finput                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.finput
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fldoffset;            // dmmeta.fldoffset             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fldoffset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_floadtuples;          // dmmeta.floadtuples           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.floadtuples
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fnoremove;            // dmmeta.fnoremove             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fnoremove
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_foutput;              // dmmeta.foutput               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.foutput
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fprefix;              // dmmeta.fprefix               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fprefix
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fregx;                // dmmeta.fregx                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fregx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fsort;                // dmmeta.fsort                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fsort
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fstep;                // dmmeta.fstep                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fstep
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ftrace;               // dmmeta.ftrace                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ftrace
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ftuple;               // dmmeta.ftuple                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ftuple
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_func;                 // dmmeta.func                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.func
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_funique;              // dmmeta.funique               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.funique
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fuserinit;            // dmmeta.fuserinit             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fuserinit
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fwddecl;              // dmmeta.fwddecl               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fwddecl
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gconst;               // dmmeta.gconst                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gconst
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gstatic;              // dmmeta.gstatic               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gstatic
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gsymbol;              // dmmeta.gsymbol               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gsymbol
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_hashtype;             // dmmeta.hashtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.hashtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_hook;                 // dmmeta.hook                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.hook
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_inlary;               // dmmeta.inlary                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.inlary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_lenfld;               // dmmeta.lenfld                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.lenfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_listtype;             // dmmeta.listtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.listtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_llist;                // dmmeta.llist                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.llist
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_logcat;               // dmmeta.logcat                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.logcat
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_main;                 // dmmeta.main                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.main
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_msgtype;              // dmmeta.msgtype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.msgtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nocascdel;            // dmmeta.nocascdel             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nocascdel
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nossimfile;           // dmmeta.nossimfile            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nossimfile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_noxref;               // dmmeta.noxref                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.noxref
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ns;                   // dmmeta.ns                    fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ns
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nscpp;                // dmmeta.nscpp                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nscpp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsdb;                 // dmmeta.nsdb                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsdb
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsinclude;            // dmmeta.nsinclude             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsinclude
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsproto;              // dmmeta.nsproto               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsproto
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nstype;               // dmmeta.nstype                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nstype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsversion;            // dmmeta.nsversion             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsversion
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsx;                  // dmmeta.nsx                   fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_numstr;               // dmmeta.numstr                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.numstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pack;                 // dmmeta.pack                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pack
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld;             // dmmeta.pmaskfld              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pmaskfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pnew;                 // dmmeta.pnew                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pnew
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pnewtype;             // dmmeta.pnewtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pnewtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_printfmt;             // dmmeta.printfmt              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.printfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ptrary;               // dmmeta.ptrary                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ptrary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_reftype;              // dmmeta.reftype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.reftype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_rowid;                // dmmeta.rowid                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.rowid
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_smallstr;             // dmmeta.smallstr              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.smallstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sortfld;              // dmmeta.sortfld               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sortfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sorttype;             // dmmeta.sorttype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sorttype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sqltype;              // dmmeta.sqltype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sqltype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimfile;             // dmmeta.ssimfile              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimfile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimreq;              // dmmeta.ssimreq               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimreq
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimsort;             // dmmeta.ssimsort              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimsort
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimvolatile;         // dmmeta.ssimvolatile          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimvolatile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_steptype;             // dmmeta.steptype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.steptype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_strfmt;               // dmmeta.strfmt                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.strfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_strtype;              // dmmeta.strtype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.strtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_substr;               // dmmeta.substr                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.substr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_svtype;               // dmmeta.svtype                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.svtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tary;                 // dmmeta.tary                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_thash;                // dmmeta.thash                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.thash
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tracefld;             // dmmeta.tracefld              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tracefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tracerec;             // dmmeta.tracerec              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tracerec
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_typefld;              // dmmeta.typefld               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.typefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_usertracefld;         // dmmeta.usertracefld          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.usertracefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_xref;                 // dmmeta.xref                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.xref
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alarm;                  // fmdb.alarm                   fconst:dmmeta.Ssimfile.ssimfile/fmdb.alarm
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alm_code;               // fmdb.alm_code                fconst:dmmeta.Ssimfile.ssimfile/fmdb.alm_code
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alm_objtype;            // fmdb.alm_objtype             fconst:dmmeta.Ssimfile.ssimfile/fmdb.alm_objtype
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alm_source;             // fmdb.alm_source              fconst:dmmeta.Ssimfile.ssimfile/fmdb.alm_source
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gact;                 // gclidb.gact                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gact
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gatv;                 // gclidb.gatv                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gatv
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclicmd;              // gclidb.gclicmd               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclicmd
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclicmdf2j;           // gclidb.gclicmdf2j            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclicmdf2j
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclicmdt;             // gclidb.gclicmdt              fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclicmdt
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclienv;              // gclidb.gclienv               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclienv
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclienvsub;           // gclidb.gclienvsub            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclienvsub
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclisub;              // gclidb.gclisub               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclisub
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gfld;                 // gclidb.gfld                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gfld
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_githost;              // gclidb.githost               fconst:dmmeta.Ssimfile.ssimfile/gclidb.githost
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gmethod;              // gclidb.gmethod               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gmethod
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_grepo;                // gclidb.grepo                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.grepo
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_grepogitport;         // gclidb.grepogitport          fconst:dmmeta.Ssimfile.ssimfile/gclidb.grepogitport
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_grepossh;             // gclidb.grepossh              fconst:dmmeta.Ssimfile.ssimfile/gclidb.grepossh
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gstate;               // gclidb.gstate                fconst:dmmeta.Ssimfile.ssimfile/gclidb.gstate
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gstatet;              // gclidb.gstatet               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gstatet
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtbl;                 // gclidb.gtbl                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtbl
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblact;              // gclidb.gtblact               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblact
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblactfld;           // gclidb.gtblactfld            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblactfld
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblacttst;           // gclidb.gtblacttst            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblacttst
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblacttstout;        // gclidb.gtblacttstout         fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblacttstout
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtype;                // gclidb.gtype                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtype
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtypeh;               // gclidb.gtypeh                fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtypeh
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtypeprefix;          // gclidb.gtypeprefix           fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtypeprefix
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_issue;                // gclidb.issue                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.issue
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_issuenote;            // gclidb.issuenote             fconst:dmmeta.Ssimfile.ssimfile/gclidb.issuenote
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_issuepipeline;        // gclidb.issuepipeline         fconst:dmmeta.Ssimfile.ssimfile/gclidb.issuepipeline
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_label;                // gclidb.label                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.label
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_milestone;            // gclidb.milestone             fconst:dmmeta.Ssimfile.ssimfile/gclidb.milestone
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_mr;                   // gclidb.mr                    fconst:dmmeta.Ssimfile.ssimfile/gclidb.mr
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_mrjob;                // gclidb.mrjob                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.mrjob
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_mrnote;               // gclidb.mrnote                fconst:dmmeta.Ssimfile.ssimfile/gclidb.mrnote
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_project;              // gclidb.project               fconst:dmmeta.Ssimfile.ssimfile/gclidb.project
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_user;                 // gclidb.user                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.user
extern const char *  dmmeta_Steptype_steptype_Callback;        // Callback         fconst:dmmeta.Steptype.steptype/Callback
extern const char *  dmmeta_Steptype_steptype_Extern;          // Extern           fconst:dmmeta.Steptype.steptype/Extern
extern const char *  dmmeta_Steptype_steptype_Inline;          // Inline           fconst:dmmeta.Steptype.steptype/Inline
extern const char *  dmmeta_Steptype_steptype_InlineOnce;      // InlineOnce       fconst:dmmeta.Steptype.steptype/InlineOnce
extern const char *  dmmeta_Steptype_steptype_InlineRecur;     // InlineRecur      fconst:dmmeta.Steptype.steptype/InlineRecur
extern const char *  dmmeta_Steptype_steptype_TimeHookRecur;   // TimeHookRecur    fconst:dmmeta.Steptype.steptype/TimeHookRecur
extern const char *  dmmeta_Strfmt_strfmt_Argv;      // Argv       fconst:dmmeta.Strfmt.strfmt/Argv
extern const char *  dmmeta_Strfmt_strfmt_ArgvGnu;   // ArgvGnu    fconst:dmmeta.Strfmt.strfmt/ArgvGnu
extern const char *  dmmeta_Strfmt_strfmt_Json;      // Json       fconst:dmmeta.Strfmt.strfmt/Json
extern const char *  dmmeta_Strfmt_strfmt_String;    // String     fconst:dmmeta.Strfmt.strfmt/String
extern const char *  dmmeta_Strfmt_strfmt_Tuple;     // Tuple      fconst:dmmeta.Strfmt.strfmt/Tuple
extern const char *  dmmeta_Strtype_strtype_rpascal;    // rpascal     fconst:dmmeta.Strtype.strtype/rpascal
extern const char *  dmmeta_Strtype_strtype_rightpad;   // rightpad    fconst:dmmeta.Strtype.strtype/rightpad
extern const char *  dmmeta_Strtype_strtype_leftpad;    // leftpad     fconst:dmmeta.Strtype.strtype/leftpad
namespace dmmeta { // gen:ns_pkeytypedef
    typedef algo::Smallstr50 BuftypePkey;
    typedef algo::Smallstr50 CafterPkey;
    typedef algo::Smallstr100 CfmtPkey;
    typedef algo::Smallstr20 CppkeywordPkey;
    typedef algo::Smallstr50 CtypePkey;
    typedef algo::Smallstr50 DispatchPkey;
    typedef algo::Smallstr100 DispatchMsgPkey;
    typedef algo::Smallstr50 DispsigPkey;
    typedef algo::Smallstr50 FbufdirPkey;
    typedef algo::Smallstr50 FbuftypePkey;
    typedef algo::Smallstr250 FcmapPkey;
    typedef algo::Smallstr100 FconstPkey;
    typedef algo::Smallstr50 FcursPkey;
    typedef algo::Smallstr100 FieldPkey;
    typedef algo::Smallstr5 FprefixPkey;
    typedef algo::Smallstr100 FstepPkey;
    typedef algo::Smallstr100 FuncPkey;
    typedef algo::Smallstr100 FwddeclPkey;
    typedef algo::Smallstr50 GsymbolPkey;
    typedef algo::Smallstr50 HashtypePkey;
    typedef algo::Smallstr5 ListtypePkey;
    typedef algo::Smallstr50 LogcatPkey;
    typedef algo::Smallstr16 NsPkey;
    typedef algo::Smallstr16 NsdbPkey;
    typedef algo::Smallstr50 NsincludePkey;
    typedef algo::Smallstr50 NstypePkey;
    typedef algo::Smallstr100 PnewPkey;
    typedef algo::Smallstr50 PrintfmtPkey;
    typedef algo::Smallstr50 ReftypePkey;
    typedef algo::Smallstr100 SmallstrPkey;
    typedef algo::Smallstr50 SorttypePkey;
    typedef algo::Smallstr50 SsimfilePkey;
    typedef algo::Smallstr50 SteptypePkey;
    typedef algo::Smallstr50 StrfmtPkey;
    typedef algo::Smallstr50 StrtypePkey;
    typedef algo::Smallstr100 SubstrPkey;
    typedef algo::Smallstr100 TracefldPkey;
    typedef algo::Smallstr50 TracerecPkey;
    typedef algo::Smallstr100 XrefPkey;
} // gen:ns_pkeytypedef
namespace dmmeta { // gen:ns_field
} // gen:ns_field
// gen:ns_fwddecl2
namespace dmmeta { struct Anonfld; }
namespace dmmeta { struct Argvtype; }
namespace dmmeta { struct Basepool; }
namespace dmmeta { struct Bitfld; }
namespace dmmeta { struct Buftype; }
namespace dmmeta { struct Cafter; }
namespace dmmeta { struct Cascdel; }
namespace dmmeta { struct Ccmp; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cextern; }
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cget; }
namespace dmmeta { struct Charset; }
namespace dmmeta { struct Chash; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Cppkeyword; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Csize; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace dmmeta { struct Ctypelen; }
namespace dmmeta { struct Dispatch; }
namespace dmmeta { struct DispatchMsg; }
namespace dmmeta { struct Dispctx; }
namespace dmmeta { struct Dispfilter; }
namespace dmmeta { struct Dispsig; }
namespace dmmeta { struct Dispsigcheck; }
namespace dmmeta { struct Disptrace; }
namespace dmmeta { struct Falias; }
namespace dmmeta { struct Fbase; }
namespace dmmeta { struct Fbigend; }
namespace dmmeta { struct Fbitset; }
namespace dmmeta { struct Fbuf; }
namespace dmmeta { struct Fbufdir; }
namespace dmmeta { struct Fbuftype; }
namespace dmmeta { struct Fcast; }
namespace dmmeta { struct Fcleanup; }
namespace dmmeta { struct Fcmap; }
namespace dmmeta { struct Fcmdline; }
namespace dmmeta { struct Fcmp; }
namespace dmmeta { struct Fcompact; }
namespace dmmeta { struct Fconst; }
namespace dmmeta { struct Fcurs; }
namespace dmmeta { struct Fdec; }
namespace dmmeta { struct Fdelay; }
namespace dmmeta { struct Fflag; }
namespace dmmeta { struct Field; }
namespace dmmeta { struct FieldId; }
namespace dmmeta { struct Findrem; }
namespace dmmeta { struct Finput; }
namespace dmmeta { struct Fldoffset; }
namespace dmmeta { struct Floadtuples; }
namespace dmmeta { struct Fnoremove; }
namespace dmmeta { struct Foutput; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Fregx; }
namespace dmmeta { struct Fsort; }
namespace dmmeta { struct Fstep; }
namespace dmmeta { struct Ftrace; }
namespace dmmeta { struct Ftuple; }
namespace dmmeta { struct Func; }
namespace dmmeta { struct Funique; }
namespace dmmeta { struct Fuserinit; }
namespace dmmeta { struct Fwddecl; }
namespace dmmeta { struct Gconst; }
namespace dmmeta { struct Gstatic; }
namespace dmmeta { struct Gsymbol; }
namespace dmmeta { struct Hashtype; }
namespace dmmeta { struct Hook; }
namespace dmmeta { struct Inlary; }
namespace dmmeta { struct Lenfld; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Llist; }
namespace dmmeta { struct Logcat; }
namespace dmmeta { struct Main; }
namespace dmmeta { struct Msgtype; }
namespace dmmeta { struct Nocascdel; }
namespace dmmeta { struct Nossimfile; }
namespace dmmeta { struct Noxref; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Nscpp; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Nsinclude; }
namespace dmmeta { struct Nsproto; }
namespace dmmeta { struct Nstype; }
namespace dmmeta { struct Nsversion; }
namespace dmmeta { struct Nsx; }
namespace dmmeta { struct Numstr; }
namespace dmmeta { struct Pack; }
namespace dmmeta { struct Pmaskfld; }
namespace dmmeta { struct Pnew; }
namespace dmmeta { struct Printfmt; }
namespace dmmeta { struct Ptrary; }
namespace dmmeta { struct Reftype; }
namespace dmmeta { struct ReftypeCase; }
namespace dmmeta { struct Rowid; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Sortfld; }
namespace dmmeta { struct Sorttype; }
namespace dmmeta { struct Sqltype; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimreq; }
namespace dmmeta { struct Ssimsort; }
namespace dmmeta { struct Ssimvolatile; }
namespace dmmeta { struct Steptype; }
namespace dmmeta { struct Strfmt; }
namespace dmmeta { struct Strtype; }
namespace dmmeta { struct Substr; }
namespace dmmeta { struct Svtype; }
namespace dmmeta { struct Tary; }
namespace dmmeta { struct Thash; }
namespace dmmeta { struct Tracefld; }
namespace dmmeta { struct Tracerec; }
namespace dmmeta { struct Typefld; }
namespace dmmeta { struct Usertracefld; }
namespace dmmeta { struct Xref; }
namespace dmmeta { // gen:ns_print_struct

// --- dmmeta.Anonfld
struct Anonfld { // dmmeta.Anonfld: Omit field name where possible (command line, enums, constants)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Anonfld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Anonfld();
};

bool                 Anonfld_ReadFieldMaybe(dmmeta::Anonfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Anonfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Anonfld_ReadStrptrMaybe(dmmeta::Anonfld &parent, algo::strptr in_str);
// print string representation of dmmeta::Anonfld to string LHS, no header -- cprint:dmmeta.Anonfld.String
void                 Anonfld_Print(dmmeta::Anonfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Argvtype
struct Argvtype { // dmmeta.Argvtype: Customize parsing of command lines (rarely used)
    algo::Smallstr50   ctype;      //
    algo::Smallstr50   argvtype;   //
    algo::Comment      comment;    //
    Argvtype();
};

bool                 Argvtype_ReadFieldMaybe(dmmeta::Argvtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Argvtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Argvtype_ReadStrptrMaybe(dmmeta::Argvtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Argvtype to string LHS, no header -- cprint:dmmeta.Argvtype.String
void                 Argvtype_Print(dmmeta::Argvtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Basepool
struct Basepool { // dmmeta.Basepool: Specify pool to be used for allocating elements of a type
    algo::Smallstr100   field;   //
    algo::Smallstr100   base;    //
    explicit Basepool(const algo::strptr&            in_field
        ,const algo::strptr&            in_base);
    Basepool();
};

bool                 Basepool_ReadFieldMaybe(dmmeta::Basepool &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Basepool from an ascii string.
// The format of the string is an ssim Tuple
bool                 Basepool_ReadStrptrMaybe(dmmeta::Basepool &parent, algo::strptr in_str);
// print string representation of dmmeta::Basepool to string LHS, no header -- cprint:dmmeta.Basepool.String
void                 Basepool_Print(dmmeta::Basepool & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Bitfld
struct Bitfld { // dmmeta.Bitfld: Specify offset/width of a bitfield within another field
    algo::Smallstr100   field;      //
    i32                 offset;     //   0  Offset, in bits, within parent field
    i32                 width;      //   0  Width, in bits, within parent field.
    algo::Smallstr100   srcfield;   //
    algo::Comment       comment;    //
    explicit Bitfld(const algo::strptr&            in_field
        ,i32                            in_offset
        ,i32                            in_width
        ,const algo::strptr&            in_srcfield
        ,const algo::Comment&           in_comment);
    Bitfld();
};

algo::Smallstr50     name_Get(dmmeta::Bitfld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Bitfld_name_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Bitfld_ReadFieldMaybe(dmmeta::Bitfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Bitfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Bitfld_ReadStrptrMaybe(dmmeta::Bitfld &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Bitfld_Init(dmmeta::Bitfld& parent);
// print string representation of dmmeta::Bitfld to string LHS, no header -- cprint:dmmeta.Bitfld.String
void                 Bitfld_Print(dmmeta::Bitfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Buftype
struct Buftype { // dmmeta.Buftype
    algo::Smallstr50   pnewtype;   //
    algo::Comment      comment;    //
    explicit Buftype(const algo::strptr&            in_pnewtype
        ,const algo::Comment&           in_comment);
    Buftype();
};

bool                 Buftype_ReadFieldMaybe(dmmeta::Buftype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Buftype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Buftype_ReadStrptrMaybe(dmmeta::Buftype &parent, algo::strptr in_str);
// print string representation of dmmeta::Buftype to string LHS, no header -- cprint:dmmeta.Buftype.String
void                 Buftype_Print(dmmeta::Buftype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cafter
struct Cafter { // dmmeta.Cafter: Control amc processing order for unrelated types (used in rare situations)
    algo::Smallstr50   cafter;    //
    algo::Comment      comment;   //
    Cafter();
};

algo::Smallstr50     ctype_Get(dmmeta::Cafter& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cafter_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     after_Get(dmmeta::Cafter& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cafter_after_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Cafter_Concat_ctype_after( const algo::strptr& ctype ,const algo::strptr& after );
bool                 Cafter_ReadFieldMaybe(dmmeta::Cafter &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cafter from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cafter_ReadStrptrMaybe(dmmeta::Cafter &parent, algo::strptr in_str);
// print string representation of dmmeta::Cafter to string LHS, no header -- cprint:dmmeta.Cafter.String
void                 Cafter_Print(dmmeta::Cafter & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cascdel
struct Cascdel { // dmmeta.Cascdel: Request cascading delete of referenced rows
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Cascdel(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Cascdel();
};

bool                 Cascdel_ReadFieldMaybe(dmmeta::Cascdel &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cascdel from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cascdel_ReadStrptrMaybe(dmmeta::Cascdel &parent, algo::strptr in_str);
// print string representation of dmmeta::Cascdel to string LHS, no header -- cprint:dmmeta.Cascdel.String
void                 Cascdel_Print(dmmeta::Cascdel & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ccmp
struct Ccmp { // dmmeta.Ccmp: Generate hash function
    algo::Smallstr50   ctype;     // Target ctype
    bool               extrn;     //   false  Whether implementation is external
    bool               genop;     //   false  Generate C++ comparison operators (<,>, etc)
    bool               order;     //   false
    bool               minmax;    //   false
    algo::Comment      comment;   //
    explicit Ccmp(const algo::strptr&            in_ctype
        ,bool                           in_extrn
        ,bool                           in_genop
        ,bool                           in_order
        ,bool                           in_minmax
        ,const algo::Comment&           in_comment);
    Ccmp();
};

bool                 Ccmp_ReadFieldMaybe(dmmeta::Ccmp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ccmp from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ccmp_ReadStrptrMaybe(dmmeta::Ccmp &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ccmp_Init(dmmeta::Ccmp& parent);
// print string representation of dmmeta::Ccmp to string LHS, no header -- cprint:dmmeta.Ccmp.String
void                 Ccmp_Print(dmmeta::Ccmp & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cdflt
struct Cdflt { // dmmeta.Cdflt: Specify default value for single-value types that lack fields
    algo::Smallstr50   ctype;      //
    algo::CppExpr      dflt;       //
    algo::CppExpr      cppdflt;    //
    algo::Smallstr50   ssimdflt;   //
    algo::Smallstr50   jsdflt;     //
    algo::Comment      comment;    //
    Cdflt();
};

bool                 Cdflt_ReadFieldMaybe(dmmeta::Cdflt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cdflt from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cdflt_ReadStrptrMaybe(dmmeta::Cdflt &parent, algo::strptr in_str);
// print string representation of dmmeta::Cdflt to string LHS, no header -- cprint:dmmeta.Cdflt.String
void                 Cdflt_Print(dmmeta::Cdflt & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cextern
struct Cextern { // dmmeta.Cextern: Externally defined ctype (a struct from system header, or from a c++ library)
    algo::Smallstr50   ctype;        // Ctype in question
    bool               initmemset;   //   false  Initialize using memset? (set this to Y for all C structs)
    bool               isstruct;     //   false
    explicit Cextern(const algo::strptr&            in_ctype
        ,bool                           in_initmemset
        ,bool                           in_isstruct);
    Cextern();
};

bool                 Cextern_ReadFieldMaybe(dmmeta::Cextern &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cextern from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cextern_ReadStrptrMaybe(dmmeta::Cextern &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cextern_Init(dmmeta::Cextern& parent);
// print string representation of dmmeta::Cextern to string LHS, no header -- cprint:dmmeta.Cextern.String
void                 Cextern_Print(dmmeta::Cextern & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cfmt
struct Cfmt { // dmmeta.Cfmt: Specify options for printing/reading ctypes into multiple formats
    algo::Smallstr100   cfmt;       //
    algo::Smallstr50    printfmt;   //
    bool                read;       //   false
    bool                print;      //   false
    algo::Smallstr20    sep;        //
    bool                genop;      //   false
    algo::Comment       comment;    //
    explicit Cfmt(const algo::strptr&            in_cfmt
        ,const algo::strptr&            in_printfmt
        ,bool                           in_read
        ,bool                           in_print
        ,const algo::strptr&            in_sep
        ,bool                           in_genop
        ,const algo::Comment&           in_comment);
    Cfmt();
};

algo::Smallstr50     ctype_Get(dmmeta::Cfmt& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cfmt_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     strfmt_Get(dmmeta::Cfmt& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cfmt_strfmt_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Cfmt_Concat_ctype_strfmt( const algo::strptr& ctype ,const algo::strptr& strfmt );
bool                 Cfmt_ReadFieldMaybe(dmmeta::Cfmt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cfmt from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cfmt_ReadStrptrMaybe(dmmeta::Cfmt &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cfmt_Init(dmmeta::Cfmt& parent);
// print string representation of dmmeta::Cfmt to string LHS, no header -- cprint:dmmeta.Cfmt.String
void                 Cfmt_Print(dmmeta::Cfmt & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cget
struct Cget { // dmmeta.Cget: Generate state functions for these ctypes
    algo::Smallstr50   ctype;     //
    algo::Comment      comment;   //
    Cget();
};

bool                 Cget_ReadFieldMaybe(dmmeta::Cget &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cget from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cget_ReadStrptrMaybe(dmmeta::Cget &parent, algo::strptr in_str);
// print string representation of dmmeta::Cget to string LHS, no header -- cprint:dmmeta.Cget.String
void                 Cget_Print(dmmeta::Cget & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Charset
struct Charset { // dmmeta.Charset: Generate functions to determine if a character is a member of a set
    algo::Smallstr100   field;       //
    algo::Smallstr100   expr;        //
    bool                charrange;   //   false
    bool                calc;        //   false
    algo::Comment       comment;     //
    Charset();
};

bool                 Charset_ReadFieldMaybe(dmmeta::Charset &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Charset from an ascii string.
// The format of the string is an ssim Tuple
bool                 Charset_ReadStrptrMaybe(dmmeta::Charset &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Charset_Init(dmmeta::Charset& parent);
// print string representation of dmmeta::Charset to string LHS, no header -- cprint:dmmeta.Charset.String
void                 Charset_Print(dmmeta::Charset & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Chash
struct Chash { // dmmeta.Chash: Generate hash function
    algo::Smallstr50   ctype;      // Target ctype
    algo::Smallstr50   hashtype;   // Hash type
    algo::Comment      comment;    //
    explicit Chash(const algo::strptr&            in_ctype
        ,const algo::strptr&            in_hashtype
        ,const algo::Comment&           in_comment);
    Chash();
};

bool                 Chash_ReadFieldMaybe(dmmeta::Chash &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Chash from an ascii string.
// The format of the string is an ssim Tuple
bool                 Chash_ReadStrptrMaybe(dmmeta::Chash &parent, algo::strptr in_str);
// print string representation of dmmeta::Chash to string LHS, no header -- cprint:dmmeta.Chash.String
void                 Chash_Print(dmmeta::Chash & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cppfunc
struct Cppfunc { // dmmeta.Cppfunc: Value of field provided by this expression
    algo::Smallstr100   field;   //
    algo::CppExpr       expr;    //
    Cppfunc();
};

bool                 Cppfunc_ReadFieldMaybe(dmmeta::Cppfunc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cppfunc from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cppfunc_ReadStrptrMaybe(dmmeta::Cppfunc &parent, algo::strptr in_str);
// print string representation of dmmeta::Cppfunc to string LHS, no header -- cprint:dmmeta.Cppfunc.String
void                 Cppfunc_Print(dmmeta::Cppfunc & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cppkeyword
struct Cppkeyword { // dmmeta.Cppkeyword: Built-in C++ keyword
    algo::Smallstr20   cppkeyword;   //
    explicit Cppkeyword(const algo::strptr&            in_cppkeyword);
    Cppkeyword();
};

bool                 Cppkeyword_ReadFieldMaybe(dmmeta::Cppkeyword &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cppkeyword from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cppkeyword_ReadStrptrMaybe(dmmeta::Cppkeyword &parent, algo::strptr in_str);
// print string representation of dmmeta::Cppkeyword to string LHS, no header -- cprint:dmmeta.Cppkeyword.String
void                 Cppkeyword_Print(dmmeta::Cppkeyword & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cpptype
struct Cpptype { // dmmeta.Cpptype: Specify whether a ctype can be passed by value, and other c++ options
    algo::Smallstr50   ctype;        //
    bool               ctor;         //   false  if true, generate non-default constructor from all fields
    bool               dtor;         //   true  generate non-default destructor
    bool               cheap_copy;   //   false  Pass by value whenever possible
    explicit Cpptype(const algo::strptr&            in_ctype
        ,bool                           in_ctor
        ,bool                           in_dtor
        ,bool                           in_cheap_copy);
    Cpptype();
};

bool                 Cpptype_ReadFieldMaybe(dmmeta::Cpptype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cpptype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cpptype_ReadStrptrMaybe(dmmeta::Cpptype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cpptype_Init(dmmeta::Cpptype& parent);
// print string representation of dmmeta::Cpptype to string LHS, no header -- cprint:dmmeta.Cpptype.String
void                 Cpptype_Print(dmmeta::Cpptype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Csize
struct Csize { // dmmeta.Csize: Specify size/alignment for built-in C++ types
    algo::Smallstr50   ctype;       //
    u32                size;        //   0
    u32                alignment;   //   1
    algo::Comment      comment;     //
    explicit Csize(const algo::strptr&            in_ctype
        ,u32                            in_size
        ,u32                            in_alignment
        ,const algo::Comment&           in_comment);
    Csize();
};

bool                 Csize_ReadFieldMaybe(dmmeta::Csize &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Csize from an ascii string.
// The format of the string is an ssim Tuple
bool                 Csize_ReadStrptrMaybe(dmmeta::Csize &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Csize_Init(dmmeta::Csize& parent);
// print string representation of dmmeta::Csize to string LHS, no header -- cprint:dmmeta.Csize.String
void                 Csize_Print(dmmeta::Csize & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cstr
struct Cstr { // dmmeta.Cstr: Specify that type behaves like a string
    algo::Smallstr50   ctype;      //
    bool               strequiv;   //   false  Use strptr instead of this type when possible
    algo::Comment      comment;    //
    Cstr();
};

bool                 Cstr_ReadFieldMaybe(dmmeta::Cstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cstr_ReadStrptrMaybe(dmmeta::Cstr &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cstr_Init(dmmeta::Cstr& parent);
// print string representation of dmmeta::Cstr to string LHS, no header -- cprint:dmmeta.Cstr.String
void                 Cstr_Print(dmmeta::Cstr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ctype
struct Ctype { // dmmeta.Ctype: Conceptual type (or C type)
    algo::Smallstr50   ctype;     // Identifier. must be ns.typename
    algo::Comment      comment;   //
    explicit Ctype(const algo::strptr&            in_ctype
        ,const algo::Comment&           in_comment);
    Ctype();
};

algo::Smallstr16     ns_Get(dmmeta::Ctype& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Ctype_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Ctype& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Ctype_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Ctype_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Ctype_ReadFieldMaybe(dmmeta::Ctype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ctype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ctype_ReadStrptrMaybe(dmmeta::Ctype &parent, algo::strptr in_str);
// print string representation of dmmeta::Ctype to string LHS, no header -- cprint:dmmeta.Ctype.String
void                 Ctype_Print(dmmeta::Ctype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ctypelen
struct Ctypelen { // dmmeta.Ctypelen: Size of Ctype
    algo::Smallstr50   ctype;       // Identifies the Ctype
    u32                len;         //   0
    i32                alignment;   //   0
    i32                padbytes;    //   0
    explicit Ctypelen(const algo::strptr&            in_ctype
        ,u32                            in_len
        ,i32                            in_alignment
        ,i32                            in_padbytes);
    Ctypelen();
};

bool                 Ctypelen_ReadFieldMaybe(dmmeta::Ctypelen &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ctypelen from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ctypelen_ReadStrptrMaybe(dmmeta::Ctypelen &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ctypelen_Init(dmmeta::Ctypelen& parent);
// print string representation of dmmeta::Ctypelen to string LHS, no header -- cprint:dmmeta.Ctypelen.String
void                 Ctypelen_Print(dmmeta::Ctypelen & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispatch
struct Dispatch { // dmmeta.Dispatch: Generate code for a multi-way branch
    algo::Smallstr50   dispatch;   //
    bool               unk;        //   false  Want default case?
    bool               read;       //   false
    bool               print;      //   false
    bool               haslen;     //   false
    bool               call;       //   false
    bool               strict;     //   false  Only dispatch if length matches exactly
    algo::Comment      comment;    //
    explicit Dispatch(const algo::strptr&            in_dispatch
        ,bool                           in_unk
        ,bool                           in_read
        ,bool                           in_print
        ,bool                           in_haslen
        ,bool                           in_call
        ,bool                           in_strict
        ,const algo::Comment&           in_comment);
    Dispatch();
};

algo::Smallstr16     ns_Get(dmmeta::Dispatch& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Dispatch_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Dispatch& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Dispatch_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Dispatch_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Dispatch_ReadFieldMaybe(dmmeta::Dispatch &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispatch from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispatch_ReadStrptrMaybe(dmmeta::Dispatch &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Dispatch_Init(dmmeta::Dispatch& parent);
// print string representation of dmmeta::Dispatch to string LHS, no header -- cprint:dmmeta.Dispatch.String
void                 Dispatch_Print(dmmeta::Dispatch & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.DispatchMsg
struct DispatchMsg { // dmmeta.DispatchMsg: Add message to a dispatch
    algo::Smallstr100   dispatch_msg;   //
    algo::Comment       comment;        //
    explicit DispatchMsg(const algo::strptr&            in_dispatch_msg
        ,const algo::Comment&           in_comment);
    DispatchMsg();
};

algo::Smallstr50     dispatch_Get(dmmeta::DispatchMsg& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     DispatchMsg_dispatch_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::DispatchMsg& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     DispatchMsg_ctype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              DispatchMsg_Concat_dispatch_ctype( const algo::strptr& dispatch ,const algo::strptr& ctype );
bool                 DispatchMsg_ReadFieldMaybe(dmmeta::DispatchMsg &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::DispatchMsg from an ascii string.
// The format of the string is an ssim Tuple
bool                 DispatchMsg_ReadStrptrMaybe(dmmeta::DispatchMsg &parent, algo::strptr in_str);
// print string representation of dmmeta::DispatchMsg to string LHS, no header -- cprint:dmmeta.DispatchMsg.String
void                 DispatchMsg_Print(dmmeta::DispatchMsg & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispctx
struct Dispctx { // dmmeta.Dispctx: Use context with dispatch
    algo::Smallstr50   dispatch;   //
    algo::Smallstr50   ctype;      //
    algo::Comment      comment;    //
    Dispctx();
};

bool                 Dispctx_ReadFieldMaybe(dmmeta::Dispctx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispctx from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispctx_ReadStrptrMaybe(dmmeta::Dispctx &parent, algo::strptr in_str);
// print string representation of dmmeta::Dispctx to string LHS, no header -- cprint:dmmeta.Dispctx.String
void                 Dispctx_Print(dmmeta::Dispctx & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispfilter
struct Dispfilter { // dmmeta.Dispfilter: Generate filter function on dispatch
    algo::Smallstr50   dispatch;    //
    bool               match_all;   //   false
    algo::Comment      comment;     //
    Dispfilter();
};

bool                 Dispfilter_ReadFieldMaybe(dmmeta::Dispfilter &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispfilter from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispfilter_ReadStrptrMaybe(dmmeta::Dispfilter &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Dispfilter_Init(dmmeta::Dispfilter& parent);
// print string representation of dmmeta::Dispfilter to string LHS, no header -- cprint:dmmeta.Dispfilter.String
void                 Dispfilter_Print(dmmeta::Dispfilter & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispsig
struct Dispsig { // dmmeta.Dispsig: Cryptographic signature of all dispatches
    algo::Smallstr50   dispsig;     //
    algo::Sha1sig      signature;   //
    Dispsig();
};

algo::Smallstr16     ns_Get(dmmeta::Dispsig& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Dispsig_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Dispsig& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Dispsig_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Dispsig_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Dispsig_ReadFieldMaybe(dmmeta::Dispsig &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispsig from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispsig_ReadStrptrMaybe(dmmeta::Dispsig &parent, algo::strptr in_str);
// print string representation of dmmeta::Dispsig to string LHS, no header -- cprint:dmmeta.Dispsig.String
void                 Dispsig_Print(dmmeta::Dispsig & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispsigcheck
struct Dispsigcheck { // dmmeta.Dispsigcheck: Check signature of input data against executable's version
    algo::Smallstr50   dispsig;     //
    algo::Sha1sig      signature;   //
    explicit Dispsigcheck(const algo::strptr&            in_dispsig
        ,const algo::Sha1sig&           in_signature);
    Dispsigcheck();
};

bool                 Dispsigcheck_ReadFieldMaybe(dmmeta::Dispsigcheck &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispsigcheck from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispsigcheck_ReadStrptrMaybe(dmmeta::Dispsigcheck &parent, algo::strptr in_str);
// print string representation of dmmeta::Dispsigcheck to string LHS, no header -- cprint:dmmeta.Dispsigcheck.String
void                 Dispsigcheck_Print(dmmeta::Dispsigcheck & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Disptrace
struct Disptrace { // dmmeta.Disptrace: Generate trace fields (cycles, counts) for all dispatch branches
    algo::Smallstr50   dispatch;   //
    bool               cycle;      //   false
    algo::Comment      comment;    //
    Disptrace();
};

bool                 Disptrace_ReadFieldMaybe(dmmeta::Disptrace &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Disptrace from an ascii string.
// The format of the string is an ssim Tuple
bool                 Disptrace_ReadStrptrMaybe(dmmeta::Disptrace &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Disptrace_Init(dmmeta::Disptrace& parent);
// print string representation of dmmeta::Disptrace to string LHS, no header -- cprint:dmmeta.Disptrace.String
void                 Disptrace_Print(dmmeta::Disptrace & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Falias
struct Falias { // dmmeta.Falias: Alias field
    algo::Smallstr100   field;      //
    algo::Smallstr100   srcfield;   //
    algo::Comment       comment;    //
    Falias();
};

bool                 Falias_ReadFieldMaybe(dmmeta::Falias &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Falias from an ascii string.
// The format of the string is an ssim Tuple
bool                 Falias_ReadStrptrMaybe(dmmeta::Falias &parent, algo::strptr in_str);
// print string representation of dmmeta::Falias to string LHS, no header -- cprint:dmmeta.Falias.String
void                 Falias_Print(dmmeta::Falias & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbase
struct Fbase { // dmmeta.Fbase: Customize imported Base fields
    algo::Smallstr100   field;          //
    bool                stripcomment;   //   false
    algo::Comment       comment;        //
    Fbase();
};

bool                 Fbase_ReadFieldMaybe(dmmeta::Fbase &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbase from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbase_ReadStrptrMaybe(dmmeta::Fbase &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbase_Init(dmmeta::Fbase& parent);
// print string representation of dmmeta::Fbase to string LHS, no header -- cprint:dmmeta.Fbase.String
void                 Fbase_Print(dmmeta::Fbase & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbigend
struct Fbigend { // dmmeta.Fbigend: Annotate field as having big-endian storage
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fbigend();
};

bool                 Fbigend_ReadFieldMaybe(dmmeta::Fbigend &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbigend from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbigend_ReadStrptrMaybe(dmmeta::Fbigend &parent, algo::strptr in_str);
// print string representation of dmmeta::Fbigend to string LHS, no header -- cprint:dmmeta.Fbigend.String
void                 Fbigend_Print(dmmeta::Fbigend & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbitset
struct Fbitset { // dmmeta.Fbitset: Generate bitset functions over integer field or array
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Fbitset(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Fbitset();
};

bool                 Fbitset_ReadFieldMaybe(dmmeta::Fbitset &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbitset from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbitset_ReadStrptrMaybe(dmmeta::Fbitset &parent, algo::strptr in_str);
// print string representation of dmmeta::Fbitset to string LHS, no header -- cprint:dmmeta.Fbitset.String
void                 Fbitset_Print(dmmeta::Fbitset & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbuf
struct Fbuf { // dmmeta.Fbuf: Buffer for reading/writing messages, works with Iohook
    algo::Smallstr100   field;      //
    u32                 max;        //   0  Size of buffer in bytes
    algo::Smallstr50    fbuftype;   // Type of buffer
    algo::Smallstr100   insready;   //
    algo::Smallstr100   inseof;     //
    algo::Comment       comment;    //
    Fbuf();
};

algo::Smallstr50     fbufdir_Get(dmmeta::Fbuf& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fbuf_fbufdir_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Fbuf_ReadFieldMaybe(dmmeta::Fbuf &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbuf from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbuf_ReadStrptrMaybe(dmmeta::Fbuf &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbuf_Init(dmmeta::Fbuf& parent);
// print string representation of dmmeta::Fbuf to string LHS, no header -- cprint:dmmeta.Fbuf.String
void                 Fbuf_Print(dmmeta::Fbuf & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbufdir
struct Fbufdir { // dmmeta.Fbufdir: Buffer direction (in,out)
    algo::Smallstr50   fbufdir;   //
    bool               read;      //   false
    algo::Comment      comment;   //
    Fbufdir();
};

bool                 Fbufdir_ReadFieldMaybe(dmmeta::Fbufdir &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbufdir from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbufdir_ReadStrptrMaybe(dmmeta::Fbufdir &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbufdir_Init(dmmeta::Fbufdir& parent);
// print string representation of dmmeta::Fbufdir to string LHS, no header -- cprint:dmmeta.Fbufdir.String
void                 Fbufdir_Print(dmmeta::Fbufdir & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbuftype
struct Fbuftype { // dmmeta.Fbuftype: Buffer type
    algo::Smallstr50   fbuftype;    //
    bool               getmsg;      //   false  Has getmsg function?
    bool               skipbytes;   //   false  Has skipbytes function?
    bool               read;        //   false
    algo::Comment      comment;     //
    Fbuftype();
};

bool                 Fbuftype_ReadFieldMaybe(dmmeta::Fbuftype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbuftype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbuftype_ReadStrptrMaybe(dmmeta::Fbuftype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbuftype_Init(dmmeta::Fbuftype& parent);
// print string representation of dmmeta::Fbuftype to string LHS, no header -- cprint:dmmeta.Fbuftype.String
void                 Fbuftype_Print(dmmeta::Fbuftype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcast
struct Fcast { // dmmeta.Fcast: Generate implicit conversion from field to c++ expression
    algo::Smallstr100   field;     //
    algo::Smallstr100   expr;      //
    algo::Comment       comment;   //
    explicit Fcast(const algo::strptr&            in_field
        ,const algo::strptr&            in_expr
        ,const algo::Comment&           in_comment);
    Fcast();
};

bool                 Fcast_ReadFieldMaybe(dmmeta::Fcast &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcast from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcast_ReadStrptrMaybe(dmmeta::Fcast &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcast to string LHS, no header -- cprint:dmmeta.Fcast.String
void                 Fcast_Print(dmmeta::Fcast & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcleanup
struct Fcleanup { // dmmeta.Fcleanup: Request user-implemented function to be called at Uninit time for a field
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fcleanup();
};

bool                 Fcleanup_ReadFieldMaybe(dmmeta::Fcleanup &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcleanup from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcleanup_ReadStrptrMaybe(dmmeta::Fcleanup &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcleanup to string LHS, no header -- cprint:dmmeta.Fcleanup.String
void                 Fcleanup_Print(dmmeta::Fcleanup & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcmap
struct Fcmap { // dmmeta.Fcmap: Bidirectional mapping between fconst values
    algo::Smallstr250   fcmap;     // cstring maybe?
    bool                bidir;     //   true
    algo::Comment       comment;   //
    Fcmap();
};

algo::Smallstr100    leftField_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fcmap_leftField_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr40     leftVal_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr40     Fcmap_leftVal_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr40     rightVal_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr40     Fcmap_rightVal_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    rightField_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fcmap_rightField_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fcmap_Concat_leftField_leftVal_rightField_rightVal( const algo::strptr& leftField ,const algo::strptr& leftVal ,const algo::strptr& rightField ,const algo::strptr& rightVal );
bool                 Fcmap_ReadFieldMaybe(dmmeta::Fcmap &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmap from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcmap_ReadStrptrMaybe(dmmeta::Fcmap &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fcmap_Init(dmmeta::Fcmap& parent);
// print string representation of dmmeta::Fcmap to string LHS, no header -- cprint:dmmeta.Fcmap.String
void                 Fcmap_Print(dmmeta::Fcmap & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcmdline
struct Fcmdline { // dmmeta.Fcmdline: Annotate field that holds process command line
    algo::Smallstr100   field;         //
    bool                read;          //   true
    algo::Smallstr100   basecmdline;   //
    algo::Comment       comment;       //
    Fcmdline();
};

algo::Smallstr16     ns_Get(dmmeta::Fcmdline& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Fcmdline_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Fcmdline_ReadFieldMaybe(dmmeta::Fcmdline &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmdline from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcmdline_ReadStrptrMaybe(dmmeta::Fcmdline &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fcmdline_Init(dmmeta::Fcmdline& parent);
// print string representation of dmmeta::Fcmdline to string LHS, no header -- cprint:dmmeta.Fcmdline.String
void                 Fcmdline_Print(dmmeta::Fcmdline & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcmp
struct Fcmp { // dmmeta.Fcmp: Request versionsort or case-insensitive sort for field
    algo::Smallstr100   field;         // Target field
    bool                versionsort;   //   false  Use version sort (detect embedded integers in string)
    bool                casesens;      //   true  Comparison is case-sensitive
    bool                extrn;         //   false  Whether implementation is external
    algo::Comment       comment;       //
    explicit Fcmp(const algo::strptr&            in_field
        ,bool                           in_versionsort
        ,bool                           in_casesens
        ,bool                           in_extrn
        ,const algo::Comment&           in_comment);
    Fcmp();
};

bool                 Fcmp_ReadFieldMaybe(dmmeta::Fcmp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmp from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcmp_ReadStrptrMaybe(dmmeta::Fcmp &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fcmp_Init(dmmeta::Fcmp& parent);
// print string representation of dmmeta::Fcmp to string LHS, no header -- cprint:dmmeta.Fcmp.String
void                 Fcmp_Print(dmmeta::Fcmp & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcompact
struct Fcompact { // dmmeta.Fcompact: Request compaction upon removal from index
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fcompact();
};

bool                 Fcompact_ReadFieldMaybe(dmmeta::Fcompact &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcompact from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcompact_ReadStrptrMaybe(dmmeta::Fcompact &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcompact to string LHS, no header -- cprint:dmmeta.Fcompact.String
void                 Fcompact_Print(dmmeta::Fcompact & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fconst
struct Fconst { // dmmeta.Fconst: Specify enum value (integer + string constant) for a field
    algo::Smallstr100   fconst;    //
    algo::CppExpr       value;     //
    inline operator algo::CppExpr() const;
    algo::Comment       comment;   //
    explicit Fconst(const algo::strptr&            in_fconst
        ,const algo::CppExpr&           in_value
        ,const algo::Comment&           in_comment);
    Fconst();
};

algo::Smallstr100    field_Get(dmmeta::Fconst& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fconst_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    name_Get(dmmeta::Fconst& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fconst_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fconst_Concat_field_name( const algo::strptr& field ,const algo::strptr& name );
bool                 Fconst_ReadFieldMaybe(dmmeta::Fconst &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fconst from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fconst_ReadStrptrMaybe(dmmeta::Fconst &parent, algo::strptr in_str);
// print string representation of dmmeta::Fconst to string LHS, no header -- cprint:dmmeta.Fconst.String
void                 Fconst_Print(dmmeta::Fconst & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcurs
struct Fcurs { // dmmeta.Fcurs: Request generation of custom cursor
    algo::Smallstr50   fcurs;     //
    algo::Comment      comment;   //
    Fcurs();
};

algo::Smallstr100    field_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fcurs_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fcurs_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     curstype_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fcurs_curstype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fcurs_Concat_field_curstype( const algo::strptr& field ,const algo::strptr& curstype );
bool                 Fcurs_ReadFieldMaybe(dmmeta::Fcurs &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcurs from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcurs_ReadStrptrMaybe(dmmeta::Fcurs &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcurs to string LHS, no header -- cprint:dmmeta.Fcurs.String
void                 Fcurs_Print(dmmeta::Fcurs & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fdec
struct Fdec { // dmmeta.Fdec: Specify that field has an implied # of decimal places and specify formatting options
    algo::Smallstr100   field;      // Target field
    i32                 nplace;     //   0  Number of implied decimal places
    bool                fixedfmt;   //   false  Print exactly SCALE chars after decimal point
    algo::Comment       comment;    //
    Fdec();
};

bool                 Fdec_ReadFieldMaybe(dmmeta::Fdec &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fdec from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fdec_ReadStrptrMaybe(dmmeta::Fdec &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fdec_Init(dmmeta::Fdec& parent);
// print string representation of dmmeta::Fdec to string LHS, no header -- cprint:dmmeta.Fdec.String
void                 Fdec_Print(dmmeta::Fdec & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fdelay
struct Fdelay { // dmmeta.Fdelay: Control elapsed time between execution of a step
    algo::Smallstr100   fstep;     //
    algo::I64Dec9       delay;     // Delay between steps in seconds
    bool                scale;     //   false  Does delay apply to the whole list?
    algo::Comment       comment;   //
    Fdelay();
};

bool                 Fdelay_ReadFieldMaybe(dmmeta::Fdelay &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fdelay from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fdelay_ReadStrptrMaybe(dmmeta::Fdelay &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fdelay_Init(dmmeta::Fdelay& parent);
// print string representation of dmmeta::Fdelay to string LHS, no header -- cprint:dmmeta.Fdelay.String
void                 Fdelay_Print(dmmeta::Fdelay & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fflag
struct Fflag { // dmmeta.Fflag: Options for command-line flags
    algo::Smallstr100   field;        //
    bool                cumulative;   //   false  Accumulate on every read
    algo::cstring       emptyval;     //   ""
    algo::Comment       comment;      //
    Fflag();
};

bool                 Fflag_ReadFieldMaybe(dmmeta::Fflag &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fflag from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fflag_ReadStrptrMaybe(dmmeta::Fflag &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fflag_Init(dmmeta::Fflag& parent);
// print string representation of dmmeta::Fflag to string LHS, no header -- cprint:dmmeta.Fflag.String
void                 Fflag_Print(dmmeta::Fflag & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Field
struct Field { // dmmeta.Field: Specify field of a struct
    algo::Smallstr100   field;     //
    algo::Smallstr50    arg;       // type of field
    algo::Smallstr50    reftype;   //   "Val"
    algo::CppExpr       dflt;      // default value (c++ expression)
    algo::Comment       comment;   //
    explicit Field(const algo::strptr&            in_field
        ,const algo::strptr&            in_arg
        ,const algo::strptr&            in_reftype
        ,const algo::CppExpr&           in_dflt
        ,const algo::Comment&           in_comment);
    Field();
};

algo::Smallstr50     ctype_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Field_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Field_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Field_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Field_Concat_ctype_name( const algo::strptr& ctype ,const algo::strptr& name );
bool                 Field_ReadFieldMaybe(dmmeta::Field &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Field from an ascii string.
// The format of the string is an ssim Tuple
bool                 Field_ReadStrptrMaybe(dmmeta::Field &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Field_Init(dmmeta::Field& parent);
// print string representation of dmmeta::Field to string LHS, no header -- cprint:dmmeta.Field.String
void                 Field_Print(dmmeta::Field & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.FieldId
#pragma pack(push,1)
struct FieldId { // dmmeta.FieldId: Field read helper
    i32   value;   //   -1
    inline operator dmmeta_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(dmmeta_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
dmmeta_FieldIdEnum   value_GetEnum(const dmmeta::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(dmmeta::FieldId& parent, dmmeta_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const dmmeta::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const dmmeta::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(dmmeta::FieldId& parent, algo::strptr rhs, dmmeta_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of dmmeta::FieldId from an ascii string.
// The format of the string is the format of the dmmeta::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(dmmeta::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(dmmeta::FieldId& parent);
// print string representation of dmmeta::FieldId to string LHS, no header -- cprint:dmmeta.FieldId.String
void                 FieldId_Print(dmmeta::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Findrem
struct Findrem { // dmmeta.Findrem: Request generation of FindRemove function
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Findrem();
};

bool                 Findrem_ReadFieldMaybe(dmmeta::Findrem &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Findrem from an ascii string.
// The format of the string is an ssim Tuple
bool                 Findrem_ReadStrptrMaybe(dmmeta::Findrem &parent, algo::strptr in_str);
// print string representation of dmmeta::Findrem to string LHS, no header -- cprint:dmmeta.Findrem.String
void                 Findrem_Print(dmmeta::Findrem & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Finput
struct Finput { // dmmeta.Finput: Describe input table of a program
    algo::Smallstr100   field;     // Target field to read
    bool                extrn;     //   false  Call user-provided function
    bool                update;    //   false
    bool                strict;    //   true  Exist process if record contains error
    algo::Comment       comment;   //
    explicit Finput(const algo::strptr&            in_field
        ,bool                           in_extrn
        ,bool                           in_update
        ,bool                           in_strict
        ,const algo::Comment&           in_comment);
    Finput();
};

algo::Smallstr16     ns_Get(dmmeta::Finput& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Finput_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Finput_ReadFieldMaybe(dmmeta::Finput &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Finput from an ascii string.
// The format of the string is an ssim Tuple
bool                 Finput_ReadStrptrMaybe(dmmeta::Finput &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Finput_Init(dmmeta::Finput& parent);
// print string representation of dmmeta::Finput to string LHS, no header -- cprint:dmmeta.Finput.String
void                 Finput_Print(dmmeta::Finput & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fldoffset
struct Fldoffset { // dmmeta.Fldoffset: Assert field offset - will result in compile-time error if violated
    algo::Smallstr100   field;    //
    i32                 offset;   //   0
    explicit Fldoffset(const algo::strptr&            in_field
        ,i32                            in_offset);
    Fldoffset();
};

bool                 Fldoffset_ReadFieldMaybe(dmmeta::Fldoffset &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fldoffset from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fldoffset_ReadStrptrMaybe(dmmeta::Fldoffset &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fldoffset_Init(dmmeta::Fldoffset& parent);
// print string representation of dmmeta::Fldoffset to string LHS, no header -- cprint:dmmeta.Fldoffset.String
void                 Fldoffset_Print(dmmeta::Fldoffset & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Floadtuples
struct Floadtuples { // dmmeta.Floadtuples: Request that process automatically load any input tables on startup
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Floadtuples();
};

algo::Smallstr50     ctype_Get(dmmeta::Floadtuples& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Floadtuples_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Floadtuples_ReadFieldMaybe(dmmeta::Floadtuples &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Floadtuples from an ascii string.
// The format of the string is an ssim Tuple
bool                 Floadtuples_ReadStrptrMaybe(dmmeta::Floadtuples &parent, algo::strptr in_str);
// print string representation of dmmeta::Floadtuples to string LHS, no header -- cprint:dmmeta.Floadtuples.String
void                 Floadtuples_Print(dmmeta::Floadtuples & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fnoremove
struct Fnoremove { // dmmeta.Fnoremove: Omit any functions for removing elements from table; Table is append-only
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fnoremove();
};

bool                 Fnoremove_ReadFieldMaybe(dmmeta::Fnoremove &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fnoremove from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fnoremove_ReadStrptrMaybe(dmmeta::Fnoremove &parent, algo::strptr in_str);
// print string representation of dmmeta::Fnoremove to string LHS, no header -- cprint:dmmeta.Fnoremove.String
void                 Fnoremove_Print(dmmeta::Fnoremove & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Foutput
struct Foutput { // dmmeta.Foutput: Generate function to save index/table back to disk
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Foutput();
};

algo::Smallstr16     ns_Get(dmmeta::Foutput& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Foutput_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Foutput_ReadFieldMaybe(dmmeta::Foutput &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Foutput from an ascii string.
// The format of the string is an ssim Tuple
bool                 Foutput_ReadStrptrMaybe(dmmeta::Foutput &parent, algo::strptr in_str);
// print string representation of dmmeta::Foutput to string LHS, no header -- cprint:dmmeta.Foutput.String
void                 Foutput_Print(dmmeta::Foutput & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fprefix
struct Fprefix { // dmmeta.Fprefix: Mapping between field prefix and Reftype
    algo::Smallstr5    fprefix;   //
    algo::Smallstr50   reftype;   //
    algo::Comment      comment;   //
    Fprefix();
};

bool                 Fprefix_ReadFieldMaybe(dmmeta::Fprefix &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fprefix from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fprefix_ReadStrptrMaybe(dmmeta::Fprefix &parent, algo::strptr in_str);
// print string representation of dmmeta::Fprefix to string LHS, no header -- cprint:dmmeta.Fprefix.String
void                 Fprefix_Print(dmmeta::Fprefix & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fregx
struct Fregx { // dmmeta.Fregx: Specify options for command-line regx field
    algo::Smallstr100   field;      //
    bool                partial;    //   false
    algo::Smallstr50    regxtype;   //
    algo::Comment       comment;    //
    Fregx();
};

bool                 Fregx_ReadFieldMaybe(dmmeta::Fregx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fregx from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fregx_ReadStrptrMaybe(dmmeta::Fregx &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fregx_Init(dmmeta::Fregx& parent);
// print string representation of dmmeta::Fregx to string LHS, no header -- cprint:dmmeta.Fregx.String
void                 Fregx_Print(dmmeta::Fregx & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fsort
struct Fsort { // dmmeta.Fsort: Generate custom sort function for array field
    algo::Smallstr100   field;      // Field (array etc) being sorted
    algo::Smallstr50    sorttype;   // Kind of sort to generate
    algo::Smallstr100   sortfld;    // Field to sort on
    algo::Comment       comment;    //
    Fsort();
};

bool                 Fsort_ReadFieldMaybe(dmmeta::Fsort &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fsort from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fsort_ReadStrptrMaybe(dmmeta::Fsort &parent, algo::strptr in_str);
// print string representation of dmmeta::Fsort to string LHS, no header -- cprint:dmmeta.Fsort.String
void                 Fsort_Print(dmmeta::Fsort & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fstep
struct Fstep { // dmmeta.Fstep: Generate a main loop step to be executed whenever a field is non-empty
    algo::Smallstr100   fstep;      //
    algo::Smallstr50    steptype;   //
    algo::Comment       comment;    //
    Fstep();
};

algo::Smallstr100    field_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fstep_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Fstep_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fstep_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fstep_Concat_field( const algo::strptr& field );
bool                 Fstep_ReadFieldMaybe(dmmeta::Fstep &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fstep from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fstep_ReadStrptrMaybe(dmmeta::Fstep &parent, algo::strptr in_str);
// print string representation of dmmeta::Fstep to string LHS, no header -- cprint:dmmeta.Fstep.String
void                 Fstep_Print(dmmeta::Fstep & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ftrace
struct Ftrace { // dmmeta.Ftrace: Generate cycle/step counting fields for a step
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Ftrace();
};

bool                 Ftrace_ReadFieldMaybe(dmmeta::Ftrace &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ftrace from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ftrace_ReadStrptrMaybe(dmmeta::Ftrace &parent, algo::strptr in_str);
// print string representation of dmmeta::Ftrace to string LHS, no header -- cprint:dmmeta.Ftrace.String
void                 Ftrace_Print(dmmeta::Ftrace & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ftuple
struct Ftuple { // dmmeta.Ftuple
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Ftuple();
};

bool                 Ftuple_ReadFieldMaybe(dmmeta::Ftuple &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ftuple from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ftuple_ReadStrptrMaybe(dmmeta::Ftuple &parent, algo::strptr in_str);
// print string representation of dmmeta::Ftuple to string LHS, no header -- cprint:dmmeta.Ftuple.String
void                 Ftuple_Print(dmmeta::Ftuple & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Func
struct Func { // dmmeta.Func
    algo::Smallstr100   func;        // Primary key
    bool                inl;         //   false  Make inline?
    algo::cstring       proto;       // Prototype
    algo::cstring       body;        // Body of function
    bool                deprecate;   //   false  Make deprecated?
    bool                ismacro;     //   false  Always inline.
    bool                extrn;       //   false  Implemented externally by user
    bool                glob;        //   false  Function is not attached to a field (EXPLAIN!!)
    bool                priv;        //   false  Private to translateion unit (static)
    algo::cstring       ret;         // Return type
    algo::cstring       comment;     // Description (keep it as algo.comment)
    Func();
};

algo::Smallstr100    field_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Func_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Func_name_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Func_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Func_ns_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Func_Concat_field_name( const algo::strptr& field ,const algo::strptr& name );
bool                 Func_ReadFieldMaybe(dmmeta::Func &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Func from an ascii string.
// The format of the string is an ssim Tuple
bool                 Func_ReadStrptrMaybe(dmmeta::Func &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Func_Init(dmmeta::Func& parent);
// print string representation of dmmeta::Func to string LHS, no header -- cprint:dmmeta.Func.String
void                 Func_Print(dmmeta::Func & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Funique
struct Funique { // dmmeta.Funique: This field must be unique in the table. Not needed for primary key
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Funique();
};

bool                 Funique_ReadFieldMaybe(dmmeta::Funique &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Funique from an ascii string.
// The format of the string is an ssim Tuple
bool                 Funique_ReadStrptrMaybe(dmmeta::Funique &parent, algo::strptr in_str);
// print string representation of dmmeta::Funique to string LHS, no header -- cprint:dmmeta.Funique.String
void                 Funique_Print(dmmeta::Funique & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fuserinit
struct Fuserinit { // dmmeta.Fuserinit: Add user-defined initialization function for field (see fcleanup)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fuserinit();
};

bool                 Fuserinit_ReadFieldMaybe(dmmeta::Fuserinit &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fuserinit from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fuserinit_ReadStrptrMaybe(dmmeta::Fuserinit &parent, algo::strptr in_str);
// print string representation of dmmeta::Fuserinit to string LHS, no header -- cprint:dmmeta.Fuserinit.String
void                 Fuserinit_Print(dmmeta::Fuserinit & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fwddecl
struct Fwddecl { // dmmeta.Fwddecl: Request forward declaration of a field
    algo::Smallstr100   fwddecl;   //
    algo::Comment       comment;   //
    Fwddecl();
};

algo::Smallstr16     ns_Get(dmmeta::Fwddecl& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Fwddecl_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Fwddecl& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fwddecl_ctype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fwddecl_Concat_ns_ctype( const algo::strptr& ns ,const algo::strptr& ctype );
bool                 Fwddecl_ReadFieldMaybe(dmmeta::Fwddecl &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fwddecl from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fwddecl_ReadStrptrMaybe(dmmeta::Fwddecl &parent, algo::strptr in_str);
// print string representation of dmmeta::Fwddecl to string LHS, no header -- cprint:dmmeta.Fwddecl.String
void                 Fwddecl_Print(dmmeta::Fwddecl & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Gconst
struct Gconst { // dmmeta.Gconst: Import ssim table columns as fconst for a field
    algo::Smallstr100   field;      // Field with which to associate constants
    algo::Smallstr100   namefld;    // Field which gives the name of the constant
    algo::Smallstr100   idfld;      // Optional attribute of namefld that gives numeric ID for gconst
    bool                wantenum;   //   true
    explicit Gconst(const algo::strptr&            in_field
        ,const algo::strptr&            in_namefld
        ,const algo::strptr&            in_idfld
        ,bool                           in_wantenum);
    Gconst();
};

algo::Smallstr50     namefldctyp_Get(dmmeta::Gconst& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Gconst_namefldctyp_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Gconst_ReadFieldMaybe(dmmeta::Gconst &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gconst from an ascii string.
// The format of the string is an ssim Tuple
bool                 Gconst_ReadStrptrMaybe(dmmeta::Gconst &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Gconst_Init(dmmeta::Gconst& parent);
// print string representation of dmmeta::Gconst to string LHS, no header -- cprint:dmmeta.Gconst.String
void                 Gconst_Print(dmmeta::Gconst & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Gstatic
struct Gstatic { // dmmeta.Gstatic: Load entries for this table at startup time
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Gstatic(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Gstatic();
};

algo::Smallstr16     ns_Get(dmmeta::Gstatic& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Gstatic_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Gstatic_ReadFieldMaybe(dmmeta::Gstatic &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gstatic from an ascii string.
// The format of the string is an ssim Tuple
bool                 Gstatic_ReadStrptrMaybe(dmmeta::Gstatic &parent, algo::strptr in_str);
// print string representation of dmmeta::Gstatic to string LHS, no header -- cprint:dmmeta.Gstatic.String
void                 Gstatic_Print(dmmeta::Gstatic & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Gsymbol
struct Gsymbol { // dmmeta.Gsymbol: Create C++ symbols from entries in ssim table
    algo::Smallstr50    gsymbol;      //
    algo::Smallstr100   inc;          // Regex to filter rows
    algo::Smallstr50    symboltype;   //
    algo::Comment       comment;      //
    Gsymbol();
};

algo::Smallstr16     ns_Get(dmmeta::Gsymbol& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Gsymbol_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ssimfile_Get(dmmeta::Gsymbol& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Gsymbol_ssimfile_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Gsymbol_Concat_ns_ssimfile( const algo::strptr& ns ,const algo::strptr& ssimfile );
bool                 Gsymbol_ReadFieldMaybe(dmmeta::Gsymbol &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gsymbol from an ascii string.
// The format of the string is an ssim Tuple
bool                 Gsymbol_ReadStrptrMaybe(dmmeta::Gsymbol &parent, algo::strptr in_str);
// print string representation of dmmeta::Gsymbol to string LHS, no header -- cprint:dmmeta.Gsymbol.String
void                 Gsymbol_Print(dmmeta::Gsymbol & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Hashtype
struct Hashtype { // dmmeta.Hashtype
    algo::Smallstr50   hashtype;   //
    algo::Comment      comment;    //
    explicit Hashtype(const algo::strptr&            in_hashtype
        ,const algo::Comment&           in_comment);
    Hashtype();
};

bool                 Hashtype_ReadFieldMaybe(dmmeta::Hashtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Hashtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Hashtype_ReadStrptrMaybe(dmmeta::Hashtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Hashtype to string LHS, no header -- cprint:dmmeta.Hashtype.String
void                 Hashtype_Print(dmmeta::Hashtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Hook
struct Hook { // dmmeta.Hook: Required on Hook fields
    algo::Smallstr100   field;     // The field
    algo::Comment       comment;   //
    Hook();
};

bool                 Hook_ReadFieldMaybe(dmmeta::Hook &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Hook from an ascii string.
// The format of the string is an ssim Tuple
bool                 Hook_ReadStrptrMaybe(dmmeta::Hook &parent, algo::strptr in_str);
// print string representation of dmmeta::Hook to string LHS, no header -- cprint:dmmeta.Hook.String
void                 Hook_Print(dmmeta::Hook & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Inlary
struct Inlary { // dmmeta.Inlary: Generate inline array of fixed or variable length (all entries fit within parent struct)
    algo::Smallstr100   field;     //
    i32                 min;       //   0  Min. elements to preallocate
    i32                 max;       //   0  Max. elements
    algo::Comment       comment;   //
    explicit Inlary(const algo::strptr&            in_field
        ,i32                            in_min
        ,i32                            in_max
        ,const algo::Comment&           in_comment);
    Inlary();
};

bool                 Inlary_ReadFieldMaybe(dmmeta::Inlary &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Inlary from an ascii string.
// The format of the string is an ssim Tuple
bool                 Inlary_ReadStrptrMaybe(dmmeta::Inlary &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Inlary_Init(dmmeta::Inlary& parent);
// print string representation of dmmeta::Inlary to string LHS, no header -- cprint:dmmeta.Inlary.String
void                 Inlary_Print(dmmeta::Inlary & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Lenfld
struct Lenfld { // dmmeta.Lenfld: Specify which gives length of varlen portion in bytes
    algo::Smallstr100   field;   // Name of length field
    i32                 extra;   //   0  Extra #bytes to add
    explicit Lenfld(const algo::strptr&            in_field
        ,i32                            in_extra);
    Lenfld();
};

algo::Smallstr50     ctype_Get(dmmeta::Lenfld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Lenfld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Lenfld_ReadFieldMaybe(dmmeta::Lenfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Lenfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Lenfld_ReadStrptrMaybe(dmmeta::Lenfld &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Lenfld_Init(dmmeta::Lenfld& parent);
// print string representation of dmmeta::Lenfld to string LHS, no header -- cprint:dmmeta.Lenfld.String
void                 Lenfld_Print(dmmeta::Lenfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Listtype
struct Listtype { // dmmeta.Listtype: Specify structure of linked list based on field prefix
    algo::Smallstr5   listtype;   //
    bool              circular;   //   false  Circular list
    bool              haveprev;   //   false  Previous link
    bool              instail;    //   false  Queue
    algo::Comment     comment;    //
    Listtype();
};

bool                 Listtype_ReadFieldMaybe(dmmeta::Listtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Listtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Listtype_ReadStrptrMaybe(dmmeta::Listtype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Listtype_Init(dmmeta::Listtype& parent);
// print string representation of dmmeta::Listtype to string LHS, no header -- cprint:dmmeta.Listtype.String
void                 Listtype_Print(dmmeta::Listtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Llist
struct Llist { // dmmeta.Llist: Options for Llist field
    algo::Smallstr100   field;       // Index in question
    bool                havetail;    //   true  Generate 'tail' field
    bool                havecount;   //   false  Generate count of elements
    algo::Comment       comment;     //
    explicit Llist(const algo::strptr&            in_field
        ,bool                           in_havetail
        ,bool                           in_havecount
        ,const algo::Comment&           in_comment);
    Llist();
};

algo::Smallstr5      listtype_Get(dmmeta::Llist& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr5      Llist_listtype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Llist_ReadFieldMaybe(dmmeta::Llist &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Llist from an ascii string.
// The format of the string is an ssim Tuple
bool                 Llist_ReadStrptrMaybe(dmmeta::Llist &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Llist_Init(dmmeta::Llist& parent);
// print string representation of dmmeta::Llist to string LHS, no header -- cprint:dmmeta.Llist.String
void                 Llist_Print(dmmeta::Llist & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Logcat
struct Logcat { // dmmeta.Logcat
    algo::Smallstr50   logcat;    //
    bool               enabled;   //   false
    bool               builtin;   //   false
    algo::Comment      comment;   //
    Logcat();
};

bool                 Logcat_ReadFieldMaybe(dmmeta::Logcat &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Logcat from an ascii string.
// The format of the string is an ssim Tuple
bool                 Logcat_ReadStrptrMaybe(dmmeta::Logcat &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Logcat_Init(dmmeta::Logcat& parent);
// print string representation of dmmeta::Logcat to string LHS, no header -- cprint:dmmeta.Logcat.String
void                 Logcat_Print(dmmeta::Logcat & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Main
struct Main { // dmmeta.Main: Generate Main function for namespace
    algo::Smallstr16   ns;         //
    bool               ismodule;   //   false
    explicit Main(const algo::strptr&            in_ns
        ,bool                           in_ismodule);
    Main();
};

bool                 Main_ReadFieldMaybe(dmmeta::Main &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Main from an ascii string.
// The format of the string is an ssim Tuple
bool                 Main_ReadStrptrMaybe(dmmeta::Main &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Main_Init(dmmeta::Main& parent);
// print string representation of dmmeta::Main to string LHS, no header -- cprint:dmmeta.Main.String
void                 Main_Print(dmmeta::Main & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Msgtype
struct Msgtype { // dmmeta.Msgtype: Specify message type for each eligible message, controls dispatch
    algo::Smallstr50   ctype;   //
    algo::CppExpr      type;    //
    explicit Msgtype(const algo::strptr&            in_ctype
        ,const algo::CppExpr&           in_type);
    Msgtype();
};

bool                 Msgtype_ReadFieldMaybe(dmmeta::Msgtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Msgtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Msgtype_ReadStrptrMaybe(dmmeta::Msgtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Msgtype to string LHS, no header -- cprint:dmmeta.Msgtype.String
void                 Msgtype_Print(dmmeta::Msgtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nocascdel
struct Nocascdel { // dmmeta.Nocascdel: Remove cascade delete for this index
    algo::Smallstr100   xref;      //
    algo::Comment       comment;   //
    Nocascdel();
};

bool                 Nocascdel_ReadFieldMaybe(dmmeta::Nocascdel &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nocascdel from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nocascdel_ReadStrptrMaybe(dmmeta::Nocascdel &parent, algo::strptr in_str);
// print string representation of dmmeta::Nocascdel to string LHS, no header -- cprint:dmmeta.Nocascdel.String
void                 Nocascdel_Print(dmmeta::Nocascdel & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nossimfile
struct Nossimfile { // dmmeta.Nossimfile: Indicates that ssimfile does not exist for this ssimdb ctype
    algo::Smallstr50   ctype;     //
    algo::Comment      comment;   //
    Nossimfile();
};

bool                 Nossimfile_ReadFieldMaybe(dmmeta::Nossimfile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nossimfile from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nossimfile_ReadStrptrMaybe(dmmeta::Nossimfile &parent, algo::strptr in_str);
// print string representation of dmmeta::Nossimfile to string LHS, no header -- cprint:dmmeta.Nossimfile.String
void                 Nossimfile_Print(dmmeta::Nossimfile & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Noxref
struct Noxref { // dmmeta.Noxref: Explicitly specify that no x-ref exists between tables (don't use unless forced)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Noxref();
};

bool                 Noxref_ReadFieldMaybe(dmmeta::Noxref &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Noxref from an ascii string.
// The format of the string is an ssim Tuple
bool                 Noxref_ReadStrptrMaybe(dmmeta::Noxref &parent, algo::strptr in_str);
// print string representation of dmmeta::Noxref to string LHS, no header -- cprint:dmmeta.Noxref.String
void                 Noxref_Print(dmmeta::Noxref & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ns
struct Ns { // dmmeta.Ns: Namespace (for in-memory database, protocol, etc)
    algo::Smallstr16   ns;        // Namespace name (primary key)
    algo::Smallstr50   nstype;    //
    algo::Smallstr50   license;   //
    algo::Comment      comment;   //
    explicit Ns(const algo::strptr&            in_ns
        ,const algo::strptr&            in_nstype
        ,const algo::strptr&            in_license
        ,const algo::Comment&           in_comment);
    Ns();
};

bool                 Ns_ReadFieldMaybe(dmmeta::Ns &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ns from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ns_ReadStrptrMaybe(dmmeta::Ns &parent, algo::strptr in_str);
// print string representation of dmmeta::Ns to string LHS, no header -- cprint:dmmeta.Ns.String
void                 Ns_Print(dmmeta::Ns & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nscpp
struct Nscpp { // dmmeta.Nscpp: Generate C++ code for this namespace
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    explicit Nscpp(const algo::strptr&            in_ns
        ,const algo::Comment&           in_comment);
    Nscpp();
};

bool                 Nscpp_ReadFieldMaybe(dmmeta::Nscpp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nscpp from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nscpp_ReadStrptrMaybe(dmmeta::Nscpp &parent, algo::strptr in_str);
// print string representation of dmmeta::Nscpp to string LHS, no header -- cprint:dmmeta.Nscpp.String
void                 Nscpp_Print(dmmeta::Nscpp & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsdb
struct Nsdb { // dmmeta.Nsdb: Annotate ssimdb namespaces
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    Nsdb();
};

bool                 Nsdb_ReadFieldMaybe(dmmeta::Nsdb &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsdb from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsdb_ReadStrptrMaybe(dmmeta::Nsdb &parent, algo::strptr in_str);
// print string representation of dmmeta::Nsdb to string LHS, no header -- cprint:dmmeta.Nsdb.String
void                 Nsdb_Print(dmmeta::Nsdb & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsinclude
struct Nsinclude { // dmmeta.Nsinclude: Explicitly specify a C++ include file for namespace
    algo::Smallstr50   nsinclude;   //
    bool               sys;         //   false
    algo::Comment      comment;     //
    Nsinclude();
};

algo::Smallstr16     ns_Get(dmmeta::Nsinclude& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Nsinclude_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Nsinclude& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Nsinclude_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Nsinclude_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Nsinclude_ReadFieldMaybe(dmmeta::Nsinclude &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsinclude from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsinclude_ReadStrptrMaybe(dmmeta::Nsinclude &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Nsinclude_Init(dmmeta::Nsinclude& parent);
// print string representation of dmmeta::Nsinclude to string LHS, no header -- cprint:dmmeta.Nsinclude.String
void                 Nsinclude_Print(dmmeta::Nsinclude & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsproto
struct Nsproto { // dmmeta.Nsproto: Annotate protocol namespace (collection of types, no state)
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    explicit Nsproto(const algo::strptr&            in_ns
        ,const algo::Comment&           in_comment);
    Nsproto();
};

bool                 Nsproto_ReadFieldMaybe(dmmeta::Nsproto &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsproto from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsproto_ReadStrptrMaybe(dmmeta::Nsproto &parent, algo::strptr in_str);
// print string representation of dmmeta::Nsproto to string LHS, no header -- cprint:dmmeta.Nsproto.String
void                 Nsproto_Print(dmmeta::Nsproto & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nstype
struct Nstype { // dmmeta.Nstype
    algo::Smallstr50   nstype;    //
    algo::Comment      comment;   //
    explicit Nstype(const algo::strptr&            in_nstype
        ,const algo::Comment&           in_comment);
    Nstype();
};

bool                 Nstype_ReadFieldMaybe(dmmeta::Nstype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nstype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nstype_ReadStrptrMaybe(dmmeta::Nstype &parent, algo::strptr in_str);
// print string representation of dmmeta::Nstype to string LHS, no header -- cprint:dmmeta.Nstype.String
void                 Nstype_Print(dmmeta::Nstype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsversion
struct Nsversion { // dmmeta.Nsversion
    algo::Smallstr16   ns;        //
    algo::Smallstr10   version;   //
    algo::Comment      comment;   //
    Nsversion();
};

bool                 Nsversion_ReadFieldMaybe(dmmeta::Nsversion &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsversion from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsversion_ReadStrptrMaybe(dmmeta::Nsversion &parent, algo::strptr in_str);
// print string representation of dmmeta::Nsversion to string LHS, no header -- cprint:dmmeta.Nsversion.String
void                 Nsversion_Print(dmmeta::Nsversion & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsx
struct Nsx { // dmmeta.Nsx: Control code-generation and exception handling options for process/library
    algo::Smallstr16    ns;                    //
    bool                genthrow;              //   false
    bool                correct_getorcreate;   //   false
    algo::Smallstr100   pool;                  //
    bool                sortxref;              //   false
    bool                pack;                  //   false
    algo::Comment       comment;               //
    explicit Nsx(const algo::strptr&            in_ns
        ,bool                           in_genthrow
        ,bool                           in_correct_getorcreate
        ,const algo::strptr&            in_pool
        ,bool                           in_sortxref
        ,bool                           in_pack
        ,const algo::Comment&           in_comment);
    Nsx();
};

bool                 Nsx_ReadFieldMaybe(dmmeta::Nsx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsx from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsx_ReadStrptrMaybe(dmmeta::Nsx &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Nsx_Init(dmmeta::Nsx& parent);
// print string representation of dmmeta::Nsx to string LHS, no header -- cprint:dmmeta.Nsx.String
void                 Nsx_Print(dmmeta::Nsx & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Numstr
struct Numstr { // dmmeta.Numstr: Add functions to read numbers out of a string field
    algo::Smallstr100   field;     // String type
    algo::Smallstr50    numtype;   // Corresponding numeric type
    i32                 base;      //   0  Base for conversion
    i32                 min_len;   //   0  Mininum length of string
    explicit Numstr(const algo::strptr&            in_field
        ,const algo::strptr&            in_numtype
        ,i32                            in_base
        ,i32                            in_min_len);
    Numstr();
};

bool                 Numstr_ReadFieldMaybe(dmmeta::Numstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Numstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Numstr_ReadStrptrMaybe(dmmeta::Numstr &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Numstr_Init(dmmeta::Numstr& parent);
// print string representation of dmmeta::Numstr to string LHS, no header -- cprint:dmmeta.Numstr.String
void                 Numstr_Print(dmmeta::Numstr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Pack
struct Pack { // dmmeta.Pack: Request byte-packing of structure fields
    algo::Smallstr50   ctype;     // Target ctype
    algo::Comment      comment;   //
    explicit Pack(const algo::strptr&            in_ctype
        ,const algo::Comment&           in_comment);
    Pack();
};

bool                 Pack_ReadFieldMaybe(dmmeta::Pack &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pack from an ascii string.
// The format of the string is an ssim Tuple
bool                 Pack_ReadStrptrMaybe(dmmeta::Pack &parent, algo::strptr in_str);
// print string representation of dmmeta::Pack to string LHS, no header -- cprint:dmmeta.Pack.String
void                 Pack_Print(dmmeta::Pack & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Pmaskfld
struct Pmaskfld { // dmmeta.Pmaskfld: Specify which fields holds presence mask bits (one for each field in struct)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Pmaskfld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Pmaskfld();
};

algo::Smallstr50     ctype_Get(dmmeta::Pmaskfld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Pmaskfld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Pmaskfld_ReadFieldMaybe(dmmeta::Pmaskfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pmaskfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Pmaskfld_ReadStrptrMaybe(dmmeta::Pmaskfld &parent, algo::strptr in_str);
// print string representation of dmmeta::Pmaskfld to string LHS, no header -- cprint:dmmeta.Pmaskfld.String
void                 Pmaskfld_Print(dmmeta::Pmaskfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Pnew
struct Pnew { // dmmeta.Pnew: Generate custom constructor (placement new), for use with binary protocols
    algo::Smallstr100   pnew;      //
    algo::Comment       comment;   //
    explicit Pnew(const algo::strptr&            in_pnew
        ,const algo::Comment&           in_comment);
    Pnew();
};

algo::Smallstr16     ns_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Pnew_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Pnew_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     buftype_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Pnew_buftype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Pnew_Concat_ns_ctype_buftype( const algo::strptr& ns ,const algo::strptr& ctype ,const algo::strptr& buftype );
bool                 Pnew_ReadFieldMaybe(dmmeta::Pnew &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pnew from an ascii string.
// The format of the string is an ssim Tuple
bool                 Pnew_ReadStrptrMaybe(dmmeta::Pnew &parent, algo::strptr in_str);
// print string representation of dmmeta::Pnew to string LHS, no header -- cprint:dmmeta.Pnew.String
void                 Pnew_Print(dmmeta::Pnew & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Printfmt
struct Printfmt { // dmmeta.Printfmt
    algo::Smallstr50   printfmt;   //
    algo::Comment      comment;    //
    Printfmt();
};

bool                 Printfmt_ReadFieldMaybe(dmmeta::Printfmt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Printfmt from an ascii string.
// The format of the string is an ssim Tuple
bool                 Printfmt_ReadStrptrMaybe(dmmeta::Printfmt &parent, algo::strptr in_str);
// print string representation of dmmeta::Printfmt to string LHS, no header -- cprint:dmmeta.Printfmt.String
void                 Printfmt_Print(dmmeta::Printfmt & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ptrary
struct Ptrary { // dmmeta.Ptrary: Required for fields with reftype:Ptrary
    algo::Smallstr100   field;    //
    bool                unique;   //   false  Search for and ignore duplicates
    explicit Ptrary(const algo::strptr&            in_field
        ,bool                           in_unique);
    Ptrary();
};

bool                 Ptrary_ReadFieldMaybe(dmmeta::Ptrary &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ptrary from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ptrary_ReadStrptrMaybe(dmmeta::Ptrary &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ptrary_Init(dmmeta::Ptrary& parent);
// print string representation of dmmeta::Ptrary to string LHS, no header -- cprint:dmmeta.Ptrary.String
void                 Ptrary_Print(dmmeta::Ptrary & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Reftype
struct Reftype { // dmmeta.Reftype
    algo::Smallstr50   reftype;       //   "Val"
    bool               isval;         //   false  True if field makes values of target type
    bool               cascins;       //   false  Field is cascade-insert
    bool               usebasepool;   //   false
    bool               cancopy;       //   false
    bool               isxref;        //   false
    bool               del;           //   false  Supports random deletion?
    bool               up;            //   false
    bool               isnew;         //   false
    bool               hasalloc;      //   false
    bool               inst;          //   false
    bool               varlen;        //   false
    Reftype();
};

bool                 Reftype_ReadFieldMaybe(dmmeta::Reftype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Reftype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Reftype_ReadStrptrMaybe(dmmeta::Reftype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Reftype_Init(dmmeta::Reftype& parent);
// print string representation of dmmeta::Reftype to string LHS, no header -- cprint:dmmeta.Reftype.String
void                 Reftype_Print(dmmeta::Reftype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.ReftypeCase
#pragma pack(push,1)
struct ReftypeCase { // dmmeta.ReftypeCase: enum helper 
    u8   reftype;   //   0
    inline operator dmmeta_ReftypeCaseEnum() const;
    explicit ReftypeCase(u8                             in_reftype);
    ReftypeCase(dmmeta_ReftypeCaseEnum arg);
    ReftypeCase();
};
#pragma pack(pop)

// Get value of field as enum type
dmmeta_ReftypeCaseEnum reftype_GetEnum(const dmmeta::ReftypeCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 reftype_SetEnum(dmmeta::ReftypeCase& parent, dmmeta_ReftypeCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          reftype_ToCstr(const dmmeta::ReftypeCase& parent) __attribute__((nothrow));
// Convert reftype to a string. First, attempt conversion to a known string.
// If no string matches, print reftype as a numeric value.
void                 reftype_Print(const dmmeta::ReftypeCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 reftype_SetStrptrMaybe(dmmeta::ReftypeCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 reftype_SetStrptr(dmmeta::ReftypeCase& parent, algo::strptr rhs, dmmeta_ReftypeCaseEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 ReftypeCase_Init(dmmeta::ReftypeCase& parent);

// --- dmmeta.Rowid
struct Rowid { // dmmeta.Rowid: Initialize field to row id of element
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Rowid();
};

bool                 Rowid_ReadFieldMaybe(dmmeta::Rowid &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Rowid from an ascii string.
// The format of the string is an ssim Tuple
bool                 Rowid_ReadStrptrMaybe(dmmeta::Rowid &parent, algo::strptr in_str);
// print string representation of dmmeta::Rowid to string LHS, no header -- cprint:dmmeta.Rowid.String
void                 Rowid_Print(dmmeta::Rowid & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Smallstr
struct Smallstr { // dmmeta.Smallstr: Generated fixed-length padded or length-delimited string field
    algo::Smallstr100   field;     //
    i32                 length;    //   0  Maximum characters in the string
    algo::Smallstr50    strtype;   // Data format for string
    algo::CppExpr       pad;       // Pad character (if applicable)
    bool                strict;    //   false
    Smallstr();
};

algo::Smallstr50     ctype_Get(dmmeta::Smallstr& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Smallstr_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Smallstr_ReadFieldMaybe(dmmeta::Smallstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Smallstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Smallstr_ReadStrptrMaybe(dmmeta::Smallstr &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Smallstr_Init(dmmeta::Smallstr& parent);
// print string representation of dmmeta::Smallstr to string LHS, no header -- cprint:dmmeta.Smallstr.String
void                 Smallstr_Print(dmmeta::Smallstr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Sortfld
struct Sortfld { // dmmeta.Sortfld: Specify what field an index (Bheap,Atree) is sorted on
    algo::Smallstr100   field;     //
    algo::Smallstr100   sortfld;   // Field to sort by
    explicit Sortfld(const algo::strptr&            in_field
        ,const algo::strptr&            in_sortfld);
    Sortfld();
};

bool                 Sortfld_ReadFieldMaybe(dmmeta::Sortfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sortfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Sortfld_ReadStrptrMaybe(dmmeta::Sortfld &parent, algo::strptr in_str);
// print string representation of dmmeta::Sortfld to string LHS, no header -- cprint:dmmeta.Sortfld.String
void                 Sortfld_Print(dmmeta::Sortfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Sorttype
struct Sorttype { // dmmeta.Sorttype
    algo::Smallstr50   sorttype;   //
    algo::Comment      comment;    //
    Sorttype();
};

bool                 Sorttype_ReadFieldMaybe(dmmeta::Sorttype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sorttype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Sorttype_ReadStrptrMaybe(dmmeta::Sorttype &parent, algo::strptr in_str);
// print string representation of dmmeta::Sorttype to string LHS, no header -- cprint:dmmeta.Sorttype.String
void                 Sorttype_Print(dmmeta::Sorttype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Sqltype
struct Sqltype { // dmmeta.Sqltype
    algo::Smallstr50    ctype;     //
    algo::Smallstr100   expr;      //
    algo::Comment       comment;   //
    Sqltype();
};

bool                 Sqltype_ReadFieldMaybe(dmmeta::Sqltype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sqltype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Sqltype_ReadStrptrMaybe(dmmeta::Sqltype &parent, algo::strptr in_str);
// print string representation of dmmeta::Sqltype to string LHS, no header -- cprint:dmmeta.Sqltype.String
void                 Sqltype_Print(dmmeta::Sqltype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimfile
struct Ssimfile { // dmmeta.Ssimfile: Ssim tuple name for structure
    algo::Smallstr50   ssimfile;   //
    algo::Smallstr50   ctype;      //
    explicit Ssimfile(const algo::strptr&            in_ssimfile
        ,const algo::strptr&            in_ctype);
    Ssimfile();
};

algo::Smallstr16     ssimns_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Ssimfile_ssimns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Ssimfile_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Ssimfile_name_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Ssimfile_ReadFieldMaybe(dmmeta::Ssimfile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimfile from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimfile_ReadStrptrMaybe(dmmeta::Ssimfile &parent, algo::strptr in_str);
// print string representation of dmmeta::Ssimfile to string LHS, no header -- cprint:dmmeta.Ssimfile.String
void                 Ssimfile_Print(dmmeta::Ssimfile & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimreq
struct Ssimreq { // dmmeta.Ssimreq: Presence of ssimfile requires that superset field has a certain value
    algo::Smallstr50    ssimfile;   // Ssimfile with constraint
    algo::Smallstr100   field;      // Field (must belong to pkey superset)
    algo::Smallstr100   value;      // Required value
    bool                bidir;      //   false  Constraint is bidirectional
    algo::Comment       comment;    //
    Ssimreq();
};

bool                 Ssimreq_ReadFieldMaybe(dmmeta::Ssimreq &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimreq from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimreq_ReadStrptrMaybe(dmmeta::Ssimreq &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ssimreq_Init(dmmeta::Ssimreq& parent);
// print string representation of dmmeta::Ssimreq to string LHS, no header -- cprint:dmmeta.Ssimreq.String
void                 Ssimreq_Print(dmmeta::Ssimreq & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimsort
struct Ssimsort { // dmmeta.Ssimsort
    algo::Smallstr50    ssimfile;   //
    algo::Smallstr100   sortfld;    //
    algo::Comment       comment;    //
    Ssimsort();
};

bool                 Ssimsort_ReadFieldMaybe(dmmeta::Ssimsort &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimsort from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimsort_ReadStrptrMaybe(dmmeta::Ssimsort &parent, algo::strptr in_str);
// print string representation of dmmeta::Ssimsort to string LHS, no header -- cprint:dmmeta.Ssimsort.String
void                 Ssimsort_Print(dmmeta::Ssimsort & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimvolatile
struct Ssimvolatile { // dmmeta.Ssimvolatile: Types based on ssim files marked this way cannot be cross-referenced
    algo::Smallstr50   ssimfile;   //
    algo::Comment      comment;    //
    Ssimvolatile();
};

bool                 Ssimvolatile_ReadFieldMaybe(dmmeta::Ssimvolatile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimvolatile from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimvolatile_ReadStrptrMaybe(dmmeta::Ssimvolatile &parent, algo::strptr in_str);
// print string representation of dmmeta::Ssimvolatile to string LHS, no header -- cprint:dmmeta.Ssimvolatile.String
void                 Ssimvolatile_Print(dmmeta::Ssimvolatile & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Steptype
struct Steptype { // dmmeta.Steptype
    algo::Smallstr50   steptype;   //
    algo::Comment      comment;    //
    explicit Steptype(const algo::strptr&            in_steptype
        ,const algo::Comment&           in_comment);
    Steptype();
};

bool                 Steptype_ReadFieldMaybe(dmmeta::Steptype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Steptype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Steptype_ReadStrptrMaybe(dmmeta::Steptype &parent, algo::strptr in_str);
// print string representation of dmmeta::Steptype to string LHS, no header -- cprint:dmmeta.Steptype.String
void                 Steptype_Print(dmmeta::Steptype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Strfmt
struct Strfmt { // dmmeta.Strfmt
    algo::Smallstr50   strfmt;    //
    algo::Comment      comment;   //
    explicit Strfmt(const algo::strptr&            in_strfmt
        ,const algo::Comment&           in_comment);
    Strfmt();
};


// --- dmmeta.Strtype
struct Strtype { // dmmeta.Strtype
    algo::Smallstr50   strtype;   //
    algo::Comment      comment;   //
    explicit Strtype(const algo::strptr&            in_strtype
        ,const algo::Comment&           in_comment);
    Strtype();
};

bool                 Strtype_ReadFieldMaybe(dmmeta::Strtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Strtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Strtype_ReadStrptrMaybe(dmmeta::Strtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Strtype to string LHS, no header -- cprint:dmmeta.Strtype.String
void                 Strtype_Print(dmmeta::Strtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Substr
struct Substr { // dmmeta.Substr: Specify that the field value is computed from a substring of another field
    algo::Smallstr100   field;      //
    algo::CppExpr       expr;       //
    algo::Smallstr100   srcfield;   //
    explicit Substr(const algo::strptr&            in_field
        ,const algo::CppExpr&           in_expr
        ,const algo::strptr&            in_srcfield);
    Substr();
};

bool                 Substr_ReadFieldMaybe(dmmeta::Substr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Substr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Substr_ReadStrptrMaybe(dmmeta::Substr &parent, algo::strptr in_str);
// print string representation of dmmeta::Substr to string LHS, no header -- cprint:dmmeta.Substr.String
void                 Substr_Print(dmmeta::Substr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Svtype
struct Svtype { // dmmeta.Svtype: Table for determining ctype from separated value file
    algo::Smallstr50   ctype;       // Type to choose
    i32                maxwid;      //   0  Maximum width in chars of input field
    i32                fixedwid1;   //   0  Max chars before decimal point
    i32                fixedwid2;   //   0  Max chars after decimal point
    algo::Comment      comment;     //
    Svtype();
};

bool                 Svtype_ReadFieldMaybe(dmmeta::Svtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Svtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Svtype_ReadStrptrMaybe(dmmeta::Svtype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Svtype_Init(dmmeta::Svtype& parent);
// print string representation of dmmeta::Svtype to string LHS, no header -- cprint:dmmeta.Svtype.String
void                 Svtype_Print(dmmeta::Svtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Tary
struct Tary { // dmmeta.Tary: Indirect linear dynamically alocated array (used for strings, arrays of data, etc)
    algo::Smallstr100   field;     //
    bool                aliased;   //   false  Geneate functions to copy from aryptr
    algo::Comment       comment;   //
    Tary();
};

bool                 Tary_ReadFieldMaybe(dmmeta::Tary &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tary from an ascii string.
// The format of the string is an ssim Tuple
bool                 Tary_ReadStrptrMaybe(dmmeta::Tary &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Tary_Init(dmmeta::Tary& parent);
// print string representation of dmmeta::Tary to string LHS, no header -- cprint:dmmeta.Tary.String
void                 Tary_Print(dmmeta::Tary & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Thash
struct Thash { // dmmeta.Thash: Hash index, required for fields with reftype Thash
    algo::Smallstr100   field;     //
    algo::Smallstr100   hashfld;   // Field on which hash function is computed
    bool                unique;    //   true  Enforce uniqueness of member elements
    algo::Comment       comment;   //
    explicit Thash(const algo::strptr&            in_field
        ,const algo::strptr&            in_hashfld
        ,bool                           in_unique
        ,const algo::Comment&           in_comment);
    Thash();
};

bool                 Thash_ReadFieldMaybe(dmmeta::Thash &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Thash from an ascii string.
// The format of the string is an ssim Tuple
bool                 Thash_ReadStrptrMaybe(dmmeta::Thash &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Thash_Init(dmmeta::Thash& parent);
// print string representation of dmmeta::Thash to string LHS, no header -- cprint:dmmeta.Thash.String
void                 Thash_Print(dmmeta::Thash & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Tracefld
struct Tracefld { // dmmeta.Tracefld: Trace fields
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
    explicit Tracefld(const algo::strptr&            in_tracefld
        ,const algo::Comment&           in_comment);
    Tracefld();
};

algo::Smallstr50     tracerec_Get(dmmeta::Tracefld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Tracefld_tracerec_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Tracefld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Tracefld_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Tracefld_Concat_tracerec_name( const algo::strptr& tracerec ,const algo::strptr& name );
bool                 Tracefld_ReadFieldMaybe(dmmeta::Tracefld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tracefld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Tracefld_ReadStrptrMaybe(dmmeta::Tracefld &parent, algo::strptr in_str);
// print string representation of dmmeta::Tracefld to string LHS, no header -- cprint:dmmeta.Tracefld.String
void                 Tracefld_Print(dmmeta::Tracefld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Tracerec
struct Tracerec { // dmmeta.Tracerec
    algo::Smallstr50   tracerec;   // e.g. rl_lib.trace
    algo::Comment      comment;    //
    explicit Tracerec(const algo::strptr&            in_tracerec
        ,const algo::Comment&           in_comment);
    Tracerec();
};

algo::Smallstr50     name_Get(dmmeta::Tracerec& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Tracerec_name_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Tracerec_ReadFieldMaybe(dmmeta::Tracerec &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tracerec from an ascii string.
// The format of the string is an ssim Tuple
bool                 Tracerec_ReadStrptrMaybe(dmmeta::Tracerec &parent, algo::strptr in_str);
// print string representation of dmmeta::Tracerec to string LHS, no header -- cprint:dmmeta.Tracerec.String
void                 Tracerec_Print(dmmeta::Tracerec & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Typefld
struct Typefld { // dmmeta.Typefld: Specifies which field of a message carries the type
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Typefld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Typefld();
};

algo::Smallstr50     ctype_Get(dmmeta::Typefld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Typefld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Typefld_ReadFieldMaybe(dmmeta::Typefld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Typefld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Typefld_ReadStrptrMaybe(dmmeta::Typefld &parent, algo::strptr in_str);
// print string representation of dmmeta::Typefld to string LHS, no header -- cprint:dmmeta.Typefld.String
void                 Typefld_Print(dmmeta::Typefld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Usertracefld
struct Usertracefld { // dmmeta.Usertracefld: Add custom user trace fields to process's trace struct
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
    Usertracefld();
};

bool                 Usertracefld_ReadFieldMaybe(dmmeta::Usertracefld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Usertracefld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Usertracefld_ReadStrptrMaybe(dmmeta::Usertracefld &parent, algo::strptr in_str);
// print string representation of dmmeta::Usertracefld to string LHS, no header -- cprint:dmmeta.Usertracefld.String
void                 Usertracefld_Print(dmmeta::Usertracefld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Xref
struct Xref { // dmmeta.Xref: Specify how to cross-reference (i.e. project, or group-by) one record with another
    algo::Smallstr100   field;     //
    algo::CppExpr       inscond;   //   "true"  Insert condition
    algo::Smallstr200   via;       //
    explicit Xref(const algo::strptr&            in_field
        ,const algo::CppExpr&           in_inscond
        ,const algo::strptr&            in_via);
    Xref();
};

algo::Smallstr50     name_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Xref_name_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Xref_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    viafld_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Xref_viafld_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    keyfld_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Xref_keyfld_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Xref_ReadFieldMaybe(dmmeta::Xref &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Xref from an ascii string.
// The format of the string is an ssim Tuple
bool                 Xref_ReadStrptrMaybe(dmmeta::Xref &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Xref_Init(dmmeta::Xref& parent);
// print string representation of dmmeta::Xref to string LHS, no header -- cprint:dmmeta.Xref.String
void                 Xref_Print(dmmeta::Xref & row, algo::cstring &str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace dmmeta { // gen:ns_func
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Anonfld &row);// cfmt:dmmeta.Anonfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Argvtype &row);// cfmt:dmmeta.Argvtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Basepool &row);// cfmt:dmmeta.Basepool.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Bitfld &row);// cfmt:dmmeta.Bitfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Buftype &row);// cfmt:dmmeta.Buftype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cafter &row);// cfmt:dmmeta.Cafter.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cascdel &row);// cfmt:dmmeta.Cascdel.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ccmp &row);// cfmt:dmmeta.Ccmp.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cdflt &row);// cfmt:dmmeta.Cdflt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cextern &row);// cfmt:dmmeta.Cextern.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cfmt &row);// cfmt:dmmeta.Cfmt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cget &row);// cfmt:dmmeta.Cget.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Charset &row);// cfmt:dmmeta.Charset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Chash &row);// cfmt:dmmeta.Chash.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cppfunc &row);// cfmt:dmmeta.Cppfunc.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cppkeyword &row);// cfmt:dmmeta.Cppkeyword.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cpptype &row);// cfmt:dmmeta.Cpptype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Csize &row);// cfmt:dmmeta.Csize.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cstr &row);// cfmt:dmmeta.Cstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ctype &row);// cfmt:dmmeta.Ctype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ctypelen &row);// cfmt:dmmeta.Ctypelen.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispatch &row);// cfmt:dmmeta.Dispatch.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::DispatchMsg &row);// cfmt:dmmeta.DispatchMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispctx &row);// cfmt:dmmeta.Dispctx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispfilter &row);// cfmt:dmmeta.Dispfilter.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispsig &row);// cfmt:dmmeta.Dispsig.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispsigcheck &row);// cfmt:dmmeta.Dispsigcheck.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Disptrace &row);// cfmt:dmmeta.Disptrace.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Falias &row);// cfmt:dmmeta.Falias.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbase &row);// cfmt:dmmeta.Fbase.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbigend &row);// cfmt:dmmeta.Fbigend.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbitset &row);// cfmt:dmmeta.Fbitset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbuf &row);// cfmt:dmmeta.Fbuf.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbufdir &row);// cfmt:dmmeta.Fbufdir.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbuftype &row);// cfmt:dmmeta.Fbuftype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcast &row);// cfmt:dmmeta.Fcast.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcleanup &row);// cfmt:dmmeta.Fcleanup.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcmap &row);// cfmt:dmmeta.Fcmap.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcmdline &row);// cfmt:dmmeta.Fcmdline.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcmp &row);// cfmt:dmmeta.Fcmp.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcompact &row);// cfmt:dmmeta.Fcompact.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fconst &row);// cfmt:dmmeta.Fconst.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcurs &row);// cfmt:dmmeta.Fcurs.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fdec &row);// cfmt:dmmeta.Fdec.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fdelay &row);// cfmt:dmmeta.Fdelay.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fflag &row);// cfmt:dmmeta.Fflag.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Field &row);// cfmt:dmmeta.Field.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::FieldId &row);// cfmt:dmmeta.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Findrem &row);// cfmt:dmmeta.Findrem.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Finput &row);// cfmt:dmmeta.Finput.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fldoffset &row);// cfmt:dmmeta.Fldoffset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Floadtuples &row);// cfmt:dmmeta.Floadtuples.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fnoremove &row);// cfmt:dmmeta.Fnoremove.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Foutput &row);// cfmt:dmmeta.Foutput.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fprefix &row);// cfmt:dmmeta.Fprefix.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fregx &row);// cfmt:dmmeta.Fregx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fsort &row);// cfmt:dmmeta.Fsort.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fstep &row);// cfmt:dmmeta.Fstep.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ftrace &row);// cfmt:dmmeta.Ftrace.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ftuple &row);// cfmt:dmmeta.Ftuple.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Func &row);// cfmt:dmmeta.Func.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Funique &row);// cfmt:dmmeta.Funique.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fuserinit &row);// cfmt:dmmeta.Fuserinit.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fwddecl &row);// cfmt:dmmeta.Fwddecl.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gconst &row);// cfmt:dmmeta.Gconst.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gstatic &row);// cfmt:dmmeta.Gstatic.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gsymbol &row);// cfmt:dmmeta.Gsymbol.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Hashtype &row);// cfmt:dmmeta.Hashtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Hook &row);// cfmt:dmmeta.Hook.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Inlary &row);// cfmt:dmmeta.Inlary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Lenfld &row);// cfmt:dmmeta.Lenfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Listtype &row);// cfmt:dmmeta.Listtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Llist &row);// cfmt:dmmeta.Llist.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Logcat &row);// cfmt:dmmeta.Logcat.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Main &row);// cfmt:dmmeta.Main.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Msgtype &row);// cfmt:dmmeta.Msgtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nocascdel &row);// cfmt:dmmeta.Nocascdel.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nossimfile &row);// cfmt:dmmeta.Nossimfile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Noxref &row);// cfmt:dmmeta.Noxref.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ns &row);// cfmt:dmmeta.Ns.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nscpp &row);// cfmt:dmmeta.Nscpp.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsdb &row);// cfmt:dmmeta.Nsdb.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsinclude &row);// cfmt:dmmeta.Nsinclude.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsproto &row);// cfmt:dmmeta.Nsproto.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nstype &row);// cfmt:dmmeta.Nstype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsversion &row);// cfmt:dmmeta.Nsversion.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsx &row);// cfmt:dmmeta.Nsx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Numstr &row);// cfmt:dmmeta.Numstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Pack &row);// cfmt:dmmeta.Pack.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Pmaskfld &row);// cfmt:dmmeta.Pmaskfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Pnew &row);// cfmt:dmmeta.Pnew.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Printfmt &row);// cfmt:dmmeta.Printfmt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ptrary &row);// cfmt:dmmeta.Ptrary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Reftype &row);// cfmt:dmmeta.Reftype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Rowid &row);// cfmt:dmmeta.Rowid.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Smallstr &row);// cfmt:dmmeta.Smallstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sortfld &row);// cfmt:dmmeta.Sortfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sorttype &row);// cfmt:dmmeta.Sorttype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sqltype &row);// cfmt:dmmeta.Sqltype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimfile &row);// cfmt:dmmeta.Ssimfile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimreq &row);// cfmt:dmmeta.Ssimreq.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimsort &row);// cfmt:dmmeta.Ssimsort.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimvolatile &row);// cfmt:dmmeta.Ssimvolatile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Steptype &row);// cfmt:dmmeta.Steptype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Strtype &row);// cfmt:dmmeta.Strtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Substr &row);// cfmt:dmmeta.Substr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Svtype &row);// cfmt:dmmeta.Svtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tary &row);// cfmt:dmmeta.Tary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Thash &row);// cfmt:dmmeta.Thash.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tracefld &row);// cfmt:dmmeta.Tracefld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tracerec &row);// cfmt:dmmeta.Tracerec.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Typefld &row);// cfmt:dmmeta.Typefld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Usertracefld &row);// cfmt:dmmeta.Usertracefld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Xref &row);// cfmt:dmmeta.Xref.String
}
