//
// include/gen/dmmeta_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
//#pragma endinclude
// gen:ns_enums
extern const char *  dmmeta_Buftype_pnewtype_Memptr;      // Memptr       fconst:dmmeta.Buftype.pnewtype/Memptr
extern const char *  dmmeta_Buftype_pnewtype_AmsStream;   // AmsStream    fconst:dmmeta.Buftype.pnewtype/AmsStream
extern const char *  dmmeta_Buftype_pnewtype_Fixed;       // Fixed        fconst:dmmeta.Buftype.pnewtype/Fixed
extern const char *  dmmeta_Buftype_pnewtype_Dynamic;     // Dynamic      fconst:dmmeta.Buftype.pnewtype/Dynamic
extern const char *  dmmeta_Buftype_pnewtype_ByteAry;     // ByteAry      fconst:dmmeta.Buftype.pnewtype/ByteAry
extern const char *  dmmeta_Buftype_pnewtype_Append;      // Append       fconst:dmmeta.Buftype.pnewtype/Append
extern const char *  dmmeta_Fastenc_fastenc_byteVector;   // byteVector    fconst:dmmeta.Fastenc.fastenc/byteVector
extern const char *  dmmeta_Fastenc_fastenc_group;        // group         fconst:dmmeta.Fastenc.fastenc/group
extern const char *  dmmeta_Fastenc_fastenc_scaled;       // scaled        fconst:dmmeta.Fastenc.fastenc/scaled
extern const char *  dmmeta_Fastenc_fastenc_sequence;     // sequence      fconst:dmmeta.Fastenc.fastenc/sequence
extern const char *  dmmeta_Fastenc_fastenc_signed;       // signed        fconst:dmmeta.Fastenc.fastenc/signed
extern const char *  dmmeta_Fastenc_fastenc_string;       // string        fconst:dmmeta.Fastenc.fastenc/string
extern const char *  dmmeta_Fastenc_fastenc_template;     // template      fconst:dmmeta.Fastenc.fastenc/template
extern const char *  dmmeta_Fastenc_fastenc_type;         // type          fconst:dmmeta.Fastenc.fastenc/type
extern const char *  dmmeta_Fastenc_fastenc_unsigned;     // unsigned      fconst:dmmeta.Fastenc.fastenc/unsigned

// --- dmmeta_FastencCaseEnum

enum dmmeta_FastencCaseEnum {              // dmmeta.FastencCase.fastenc
     dmmeta_FastencCase_byteVector   = 1   // Byte vector length-value encoding
    ,dmmeta_FastencCase_group        = 2   // Group encoding (segment or inline)
    ,dmmeta_FastencCase_scaled       = 3   // Scaled number encoding (exponent,mantissa)
    ,dmmeta_FastencCase_sequence     = 4   // Sequence encoding (length,segments)
    ,dmmeta_FastencCase_signed       = 5   // Signed stop-byte encoding
    ,dmmeta_FastencCase_string       = 6   // 7-bit ASCII string stop-byte encoding
    ,dmmeta_FastencCase_template     = 7   // Template segment encoding
    ,dmmeta_FastencCase_type         = 8   // Defined type: enum, set
    ,dmmeta_FastencCase_unsigned     = 9   // Unsigned stop-byte encoding
};

enum { dmmeta_FastencCaseEnum_N = 9 };

extern const char *  dmmeta_Fastinstr_fastinstr_field;      // field       fconst:dmmeta.Fastinstr.fastinstr/field
extern const char *  dmmeta_Fastinstr_fastinstr_length;     // length      fconst:dmmeta.Fastinstr.fastinstr/length
extern const char *  dmmeta_Fastinstr_fastinstr_mantissa;   // mantissa    fconst:dmmeta.Fastinstr.fastinstr/mantissa

// --- dmmeta_FastinstrCaseEnum

enum dmmeta_FastinstrCaseEnum {            // dmmeta.FastinstrCase.fastinstr
     dmmeta_FastinstrCase_field      = 1   // Field
    ,dmmeta_FastinstrCase_length     = 2   // Length of group or byteVector
    ,dmmeta_FastinstrCase_mantissa   = 3   // Individual operator for decimal mantissa
};

enum { dmmeta_FastinstrCaseEnum_N = 3 };

extern const char *  dmmeta_Fastop_fastop_constant;    // constant     fconst:dmmeta.Fastop.fastop/constant
extern const char *  dmmeta_Fastop_fastop_copy;        // copy         fconst:dmmeta.Fastop.fastop/copy
extern const char *  dmmeta_Fastop_fastop_default;     // default      fconst:dmmeta.Fastop.fastop/default
extern const char *  dmmeta_Fastop_fastop_delta;       // delta        fconst:dmmeta.Fastop.fastop/delta
extern const char *  dmmeta_Fastop_fastop_increment;   // increment    fconst:dmmeta.Fastop.fastop/increment
extern const char *  dmmeta_Fastop_fastop_none;        // none         fconst:dmmeta.Fastop.fastop/none
extern const char *  dmmeta_Fastop_fastop_tail;        // tail         fconst:dmmeta.Fastop.fastop/tail

// --- dmmeta_FastopCaseEnum

enum dmmeta_FastopCaseEnum {             // dmmeta.FastopCase.fastop
     dmmeta_FastopCase_constant    = 1   // Constant
    ,dmmeta_FastopCase_copy        = 2   // Copy
    ,dmmeta_FastopCase_default     = 3   // Default
    ,dmmeta_FastopCase_delta       = 4   // Delta
    ,dmmeta_FastopCase_increment   = 5   // Increment
    ,dmmeta_FastopCase_none        = 6   // Unspecified
    ,dmmeta_FastopCase_tail        = 7   // Tail
};

enum { dmmeta_FastopCaseEnum_N = 7 };

extern const char *  dmmeta_Fbufdir_fbufdir_in;    // in     fconst:dmmeta.Fbufdir.fbufdir/in
extern const char *  dmmeta_Fbufdir_fbufdir_out;   // out    fconst:dmmeta.Fbufdir.fbufdir/out
extern const char *  dmmeta_Fbuftype_fbuftype_Bytebuf;   // Bytebuf    fconst:dmmeta.Fbuftype.fbuftype/Bytebuf
extern const char *  dmmeta_Fbuftype_fbuftype_Linebuf;   // Linebuf    fconst:dmmeta.Fbuftype.fbuftype/Linebuf
extern const char *  dmmeta_Fbuftype_fbuftype_Msgbuf;    // Msgbuf     fconst:dmmeta.Fbuftype.fbuftype/Msgbuf

// --- dmmeta_FieldIdEnum

enum dmmeta_FieldIdEnum {                        // dmmeta.FieldId.value
     dmmeta_FieldId_field                 = 0
    ,dmmeta_FieldId_comment               = 1
    ,dmmeta_FieldId_ctype                 = 2
    ,dmmeta_FieldId_argvtype              = 3
    ,dmmeta_FieldId_base                  = 4
    ,dmmeta_FieldId_name                  = 5
    ,dmmeta_FieldId_offset                = 6
    ,dmmeta_FieldId_width                 = 7
    ,dmmeta_FieldId_srcfield              = 8
    ,dmmeta_FieldId_pnewtype              = 9
    ,dmmeta_FieldId_cafter                = 10
    ,dmmeta_FieldId_after                 = 11
    ,dmmeta_FieldId_extrn                 = 12
    ,dmmeta_FieldId_genop                 = 13
    ,dmmeta_FieldId_order                 = 14
    ,dmmeta_FieldId_minmax                = 15
    ,dmmeta_FieldId_dflt                  = 16
    ,dmmeta_FieldId_cppdflt               = 17
    ,dmmeta_FieldId_ssimdflt              = 18
    ,dmmeta_FieldId_jsdflt                = 19
    ,dmmeta_FieldId_initmemset            = 20
    ,dmmeta_FieldId_isstruct              = 21
    ,dmmeta_FieldId_id                    = 22
    ,dmmeta_FieldId_encoding              = 23
    ,dmmeta_FieldId_reset                 = 24
    ,dmmeta_FieldId_cfmt                  = 25
    ,dmmeta_FieldId_strfmt                = 26
    ,dmmeta_FieldId_printfmt              = 27
    ,dmmeta_FieldId_read                  = 28
    ,dmmeta_FieldId_print                 = 29
    ,dmmeta_FieldId_sep                   = 30
    ,dmmeta_FieldId_expr                  = 31
    ,dmmeta_FieldId_charrange             = 32
    ,dmmeta_FieldId_calc                  = 33
    ,dmmeta_FieldId_hashtype              = 34
    ,dmmeta_FieldId_set                   = 35
    ,dmmeta_FieldId_cppkeyword            = 36
    ,dmmeta_FieldId_ctor                  = 37
    ,dmmeta_FieldId_dtor                  = 38
    ,dmmeta_FieldId_cheap_copy            = 39
    ,dmmeta_FieldId_size                  = 40
    ,dmmeta_FieldId_alignment             = 41
    ,dmmeta_FieldId_strequiv              = 42
    ,dmmeta_FieldId_ns                    = 43
    ,dmmeta_FieldId_len                   = 44
    ,dmmeta_FieldId_padbytes              = 45
    ,dmmeta_FieldId_dispatch              = 46
    ,dmmeta_FieldId_unk                   = 47
    ,dmmeta_FieldId_haslen                = 48
    ,dmmeta_FieldId_call                  = 49
    ,dmmeta_FieldId_strict                = 50
    ,dmmeta_FieldId_dispatch_msg          = 51
    ,dmmeta_FieldId_match_all             = 52
    ,dmmeta_FieldId_dispsig               = 53
    ,dmmeta_FieldId_signature             = 54
    ,dmmeta_FieldId_cycle                 = 55
    ,dmmeta_FieldId_fastenc               = 56
    ,dmmeta_FieldId_fastinstr             = 57
    ,dmmeta_FieldId_fastop                = 58
    ,dmmeta_FieldId_stripcomment          = 59
    ,dmmeta_FieldId_fbufdir               = 60
    ,dmmeta_FieldId_max                   = 61
    ,dmmeta_FieldId_fbuftype              = 62
    ,dmmeta_FieldId_insready              = 63
    ,dmmeta_FieldId_inseof                = 64
    ,dmmeta_FieldId_getmsg                = 65
    ,dmmeta_FieldId_skipbytes             = 66
    ,dmmeta_FieldId_fcmap                 = 67
    ,dmmeta_FieldId_leftField             = 68
    ,dmmeta_FieldId_leftVal               = 69
    ,dmmeta_FieldId_rightVal              = 70
    ,dmmeta_FieldId_rightField            = 71
    ,dmmeta_FieldId_bidir                 = 72
    ,dmmeta_FieldId_basecmdline           = 73
    ,dmmeta_FieldId_versionsort           = 74
    ,dmmeta_FieldId_casesens              = 75
    ,dmmeta_FieldId_fconst                = 76
    ,dmmeta_FieldId_value                 = 77
    ,dmmeta_FieldId_fcurs                 = 78
    ,dmmeta_FieldId_curstype              = 79
    ,dmmeta_FieldId_nplace                = 80
    ,dmmeta_FieldId_fixedfmt              = 81
    ,dmmeta_FieldId_fstep                 = 82
    ,dmmeta_FieldId_delay                 = 83
    ,dmmeta_FieldId_scale                 = 84
    ,dmmeta_FieldId_ffast                 = 85
    ,dmmeta_FieldId_pos                   = 86
    ,dmmeta_FieldId_optional              = 87
    ,dmmeta_FieldId_op                    = 88
    ,dmmeta_FieldId_cumulative            = 89
    ,dmmeta_FieldId_emptyval              = 90
    ,dmmeta_FieldId_arg                   = 91
    ,dmmeta_FieldId_reftype               = 92
    ,dmmeta_FieldId_update                = 93
    ,dmmeta_FieldId_fprefix               = 94
    ,dmmeta_FieldId_partial               = 95
    ,dmmeta_FieldId_regxtype              = 96
    ,dmmeta_FieldId_sorttype              = 97
    ,dmmeta_FieldId_sortfld               = 98
    ,dmmeta_FieldId_steptype              = 99
    ,dmmeta_FieldId_func                  = 100
    ,dmmeta_FieldId_inl                   = 101
    ,dmmeta_FieldId_proto                 = 102
    ,dmmeta_FieldId_body                  = 103
    ,dmmeta_FieldId_deprecate             = 104
    ,dmmeta_FieldId_ismacro               = 105
    ,dmmeta_FieldId_glob                  = 106
    ,dmmeta_FieldId_priv                  = 107
    ,dmmeta_FieldId_ret                   = 108
    ,dmmeta_FieldId_fwddecl               = 109
    ,dmmeta_FieldId_namefld               = 110
    ,dmmeta_FieldId_idfld                 = 111
    ,dmmeta_FieldId_wantenum              = 112
    ,dmmeta_FieldId_namefldctyp           = 113
    ,dmmeta_FieldId_gsymbol               = 114
    ,dmmeta_FieldId_ssimfile              = 115
    ,dmmeta_FieldId_inc                   = 116
    ,dmmeta_FieldId_symboltype            = 117
    ,dmmeta_FieldId_min                   = 118
    ,dmmeta_FieldId_extra                 = 119
    ,dmmeta_FieldId_listtype              = 120
    ,dmmeta_FieldId_circular              = 121
    ,dmmeta_FieldId_haveprev              = 122
    ,dmmeta_FieldId_instail               = 123
    ,dmmeta_FieldId_havetail              = 124
    ,dmmeta_FieldId_havecount             = 125
    ,dmmeta_FieldId_logcat                = 126
    ,dmmeta_FieldId_enabled               = 127
    ,dmmeta_FieldId_builtin               = 128
    ,dmmeta_FieldId_ismodule              = 129
    ,dmmeta_FieldId_type                  = 130
    ,dmmeta_FieldId_xref                  = 131
    ,dmmeta_FieldId_nstype                = 132
    ,dmmeta_FieldId_license               = 133
    ,dmmeta_FieldId_nsinclude             = 134
    ,dmmeta_FieldId_sys                   = 135
    ,dmmeta_FieldId_version               = 136
    ,dmmeta_FieldId_genthrow              = 137
    ,dmmeta_FieldId_correct_getorcreate   = 138
    ,dmmeta_FieldId_pool                  = 139
    ,dmmeta_FieldId_sortxref              = 140
    ,dmmeta_FieldId_pack                  = 141
    ,dmmeta_FieldId_numtype               = 142
    ,dmmeta_FieldId_min_len               = 143
    ,dmmeta_FieldId_filter_print          = 144
    ,dmmeta_FieldId_pmaskfld_member       = 145
    ,dmmeta_FieldId_pmaskfld              = 146
    ,dmmeta_FieldId_pnew                  = 147
    ,dmmeta_FieldId_buftype               = 148
    ,dmmeta_FieldId_unique                = 149
    ,dmmeta_FieldId_isval                 = 150
    ,dmmeta_FieldId_cascins               = 151
    ,dmmeta_FieldId_usebasepool           = 152
    ,dmmeta_FieldId_cancopy               = 153
    ,dmmeta_FieldId_isxref                = 154
    ,dmmeta_FieldId_del                   = 155
    ,dmmeta_FieldId_up                    = 156
    ,dmmeta_FieldId_isnew                 = 157
    ,dmmeta_FieldId_hasalloc              = 158
    ,dmmeta_FieldId_inst                  = 159
    ,dmmeta_FieldId_varlen                = 160
    ,dmmeta_FieldId_length                = 161
    ,dmmeta_FieldId_strtype               = 162
    ,dmmeta_FieldId_pad                   = 163
    ,dmmeta_FieldId_ssimns                = 164
    ,dmmeta_FieldId_ssimreq               = 165
    ,dmmeta_FieldId_parent                = 166
    ,dmmeta_FieldId_parent_field          = 167
    ,dmmeta_FieldId_parent_ctype          = 168
    ,dmmeta_FieldId_child_ssimfile        = 169
    ,dmmeta_FieldId_child_key             = 170
    ,dmmeta_FieldId_reqchild              = 171
    ,dmmeta_FieldId_maxwid                = 172
    ,dmmeta_FieldId_fixedwid1             = 173
    ,dmmeta_FieldId_fixedwid2             = 174
    ,dmmeta_FieldId_aliased               = 175
    ,dmmeta_FieldId_hashfld               = 176
    ,dmmeta_FieldId_tracefld              = 177
    ,dmmeta_FieldId_tracerec              = 178
    ,dmmeta_FieldId_inscond               = 179
    ,dmmeta_FieldId_via                   = 180
    ,dmmeta_FieldId_viafld                = 181
    ,dmmeta_FieldId_keyfld                = 182
};

enum { dmmeta_FieldIdEnum_N = 183 };

extern const char *  dmmeta_Hashtype_hashtype_Extern;   // Extern    fconst:dmmeta.Hashtype.hashtype/Extern
extern const char *  dmmeta_Hashtype_hashtype_CRC32;    // CRC32     fconst:dmmeta.Hashtype.hashtype/CRC32
extern const char *  dmmeta_Ns_ns_;               //                 fconst:dmmeta.Ns.ns/
extern const char *  dmmeta_Ns_ns_abt;            // abt             fconst:dmmeta.Ns.ns/abt
extern const char *  dmmeta_Ns_ns_abt_md;         // abt_md          fconst:dmmeta.Ns.ns/abt_md
extern const char *  dmmeta_Ns_ns_acr;            // acr             fconst:dmmeta.Ns.ns/acr
extern const char *  dmmeta_Ns_ns_acr_compl;      // acr_compl       fconst:dmmeta.Ns.ns/acr_compl
extern const char *  dmmeta_Ns_ns_acr_dm;         // acr_dm          fconst:dmmeta.Ns.ns/acr_dm
extern const char *  dmmeta_Ns_ns_acr_ed;         // acr_ed          fconst:dmmeta.Ns.ns/acr_ed
extern const char *  dmmeta_Ns_ns_acr_in;         // acr_in          fconst:dmmeta.Ns.ns/acr_in
extern const char *  dmmeta_Ns_ns_acr_my;         // acr_my          fconst:dmmeta.Ns.ns/acr_my
extern const char *  dmmeta_Ns_ns_algo;           // algo            fconst:dmmeta.Ns.ns/algo
extern const char *  dmmeta_Ns_ns_algo_lib;       // algo_lib        fconst:dmmeta.Ns.ns/algo_lib
extern const char *  dmmeta_Ns_ns_amc;            // amc             fconst:dmmeta.Ns.ns/amc
extern const char *  dmmeta_Ns_ns_amc_gc;         // amc_gc          fconst:dmmeta.Ns.ns/amc_gc
extern const char *  dmmeta_Ns_ns_amc_vis;        // amc_vis         fconst:dmmeta.Ns.ns/amc_vis
extern const char *  dmmeta_Ns_ns_amcdb;          // amcdb           fconst:dmmeta.Ns.ns/amcdb
extern const char *  dmmeta_Ns_ns_ams;            // ams             fconst:dmmeta.Ns.ns/ams
extern const char *  dmmeta_Ns_ns_ams_cat;        // ams_cat         fconst:dmmeta.Ns.ns/ams_cat
extern const char *  dmmeta_Ns_ns_ams_sendtest;   // ams_sendtest    fconst:dmmeta.Ns.ns/ams_sendtest
extern const char *  dmmeta_Ns_ns_amsdb;          // amsdb           fconst:dmmeta.Ns.ns/amsdb
extern const char *  dmmeta_Ns_ns_apm;            // apm             fconst:dmmeta.Ns.ns/apm
extern const char *  dmmeta_Ns_ns_atf;            // atf             fconst:dmmeta.Ns.ns/atf
extern const char *  dmmeta_Ns_ns_atf_amc;        // atf_amc         fconst:dmmeta.Ns.ns/atf_amc
extern const char *  dmmeta_Ns_ns_atf_ci;         // atf_ci          fconst:dmmeta.Ns.ns/atf_ci
extern const char *  dmmeta_Ns_ns_atf_cmdline;    // atf_cmdline     fconst:dmmeta.Ns.ns/atf_cmdline
extern const char *  dmmeta_Ns_ns_atf_comp;       // atf_comp        fconst:dmmeta.Ns.ns/atf_comp
extern const char *  dmmeta_Ns_ns_atf_cov;        // atf_cov         fconst:dmmeta.Ns.ns/atf_cov
extern const char *  dmmeta_Ns_ns_atf_fuzz;       // atf_fuzz        fconst:dmmeta.Ns.ns/atf_fuzz
extern const char *  dmmeta_Ns_ns_atf_gcli;       // atf_gcli        fconst:dmmeta.Ns.ns/atf_gcli
extern const char *  dmmeta_Ns_ns_atf_nrun;       // atf_nrun        fconst:dmmeta.Ns.ns/atf_nrun
extern const char *  dmmeta_Ns_ns_atf_unit;       // atf_unit        fconst:dmmeta.Ns.ns/atf_unit
extern const char *  dmmeta_Ns_ns_atfdb;          // atfdb           fconst:dmmeta.Ns.ns/atfdb
extern const char *  dmmeta_Ns_ns_bash2html;      // bash2html       fconst:dmmeta.Ns.ns/bash2html
extern const char *  dmmeta_Ns_ns_command;        // command         fconst:dmmeta.Ns.ns/command
extern const char *  dmmeta_Ns_ns_dev;            // dev             fconst:dmmeta.Ns.ns/dev
extern const char *  dmmeta_Ns_ns_dmmeta;         // dmmeta          fconst:dmmeta.Ns.ns/dmmeta
extern const char *  dmmeta_Ns_ns_fm;             // fm              fconst:dmmeta.Ns.ns/fm
extern const char *  dmmeta_Ns_ns_fmdb;           // fmdb            fconst:dmmeta.Ns.ns/fmdb
extern const char *  dmmeta_Ns_ns_gcache;         // gcache          fconst:dmmeta.Ns.ns/gcache
extern const char *  dmmeta_Ns_ns_gcli;           // gcli            fconst:dmmeta.Ns.ns/gcli
extern const char *  dmmeta_Ns_ns_gclidb;         // gclidb          fconst:dmmeta.Ns.ns/gclidb
extern const char *  dmmeta_Ns_ns_ietf;           // ietf            fconst:dmmeta.Ns.ns/ietf
extern const char *  dmmeta_Ns_ns_lib_amcdb;      // lib_amcdb       fconst:dmmeta.Ns.ns/lib_amcdb
extern const char *  dmmeta_Ns_ns_lib_ams;        // lib_ams         fconst:dmmeta.Ns.ns/lib_ams
extern const char *  dmmeta_Ns_ns_lib_ctype;      // lib_ctype       fconst:dmmeta.Ns.ns/lib_ctype
extern const char *  dmmeta_Ns_ns_lib_exec;       // lib_exec        fconst:dmmeta.Ns.ns/lib_exec
extern const char *  dmmeta_Ns_ns_lib_fm;         // lib_fm          fconst:dmmeta.Ns.ns/lib_fm
extern const char *  dmmeta_Ns_ns_lib_git;        // lib_git         fconst:dmmeta.Ns.ns/lib_git
extern const char *  dmmeta_Ns_ns_lib_iconv;      // lib_iconv       fconst:dmmeta.Ns.ns/lib_iconv
extern const char *  dmmeta_Ns_ns_lib_json;       // lib_json        fconst:dmmeta.Ns.ns/lib_json
extern const char *  dmmeta_Ns_ns_lib_mysql;      // lib_mysql       fconst:dmmeta.Ns.ns/lib_mysql
extern const char *  dmmeta_Ns_ns_lib_prot;       // lib_prot        fconst:dmmeta.Ns.ns/lib_prot
extern const char *  dmmeta_Ns_ns_lib_sql;        // lib_sql         fconst:dmmeta.Ns.ns/lib_sql
extern const char *  dmmeta_Ns_ns_mdbg;           // mdbg            fconst:dmmeta.Ns.ns/mdbg
extern const char *  dmmeta_Ns_ns_mysql2ssim;     // mysql2ssim      fconst:dmmeta.Ns.ns/mysql2ssim
extern const char *  dmmeta_Ns_ns_orgfile;        // orgfile         fconst:dmmeta.Ns.ns/orgfile
extern const char *  dmmeta_Ns_ns_report;         // report          fconst:dmmeta.Ns.ns/report
extern const char *  dmmeta_Ns_ns_samp_regx;      // samp_regx       fconst:dmmeta.Ns.ns/samp_regx
extern const char *  dmmeta_Ns_ns_sandbox;        // sandbox         fconst:dmmeta.Ns.ns/sandbox
extern const char *  dmmeta_Ns_ns_src_func;       // src_func        fconst:dmmeta.Ns.ns/src_func
extern const char *  dmmeta_Ns_ns_src_hdr;        // src_hdr         fconst:dmmeta.Ns.ns/src_hdr
extern const char *  dmmeta_Ns_ns_src_lim;        // src_lim         fconst:dmmeta.Ns.ns/src_lim
extern const char *  dmmeta_Ns_ns_ssim2csv;       // ssim2csv        fconst:dmmeta.Ns.ns/ssim2csv
extern const char *  dmmeta_Ns_ns_ssim2mysql;     // ssim2mysql      fconst:dmmeta.Ns.ns/ssim2mysql
extern const char *  dmmeta_Ns_ns_ssimfilt;       // ssimfilt        fconst:dmmeta.Ns.ns/ssimfilt
extern const char *  dmmeta_Ns_ns_strconv;        // strconv         fconst:dmmeta.Ns.ns/strconv
extern const char *  dmmeta_Ns_ns_sv2ssim;        // sv2ssim         fconst:dmmeta.Ns.ns/sv2ssim
extern const char *  dmmeta_Nstype_nstype_exe;        // exe         fconst:dmmeta.Nstype.nstype/exe
extern const char *  dmmeta_Nstype_nstype_lib;        // lib         fconst:dmmeta.Nstype.nstype/lib
extern const char *  dmmeta_Nstype_nstype_none;       // none        fconst:dmmeta.Nstype.nstype/none
extern const char *  dmmeta_Nstype_nstype_objlist;    // objlist     fconst:dmmeta.Nstype.nstype/objlist
extern const char *  dmmeta_Nstype_nstype_protocol;   // protocol    fconst:dmmeta.Nstype.nstype/protocol
extern const char *  dmmeta_Nstype_nstype_ssimdb;     // ssimdb      fconst:dmmeta.Nstype.nstype/ssimdb
extern const char *  dmmeta_Printfmt_printfmt_Auto;         // Auto          fconst:dmmeta.Printfmt.printfmt/Auto
extern const char *  dmmeta_Printfmt_printfmt_Bitset;       // Bitset        fconst:dmmeta.Printfmt.printfmt/Bitset
extern const char *  dmmeta_Printfmt_printfmt_CompactSep;   // CompactSep    fconst:dmmeta.Printfmt.printfmt/CompactSep
extern const char *  dmmeta_Printfmt_printfmt_Extern;       // Extern        fconst:dmmeta.Printfmt.printfmt/Extern
extern const char *  dmmeta_Printfmt_printfmt_Raw;          // Raw           fconst:dmmeta.Printfmt.printfmt/Raw
extern const char *  dmmeta_Printfmt_printfmt_Sep;          // Sep           fconst:dmmeta.Printfmt.printfmt/Sep
extern const char *  dmmeta_Printfmt_printfmt_Tuple;        // Tuple         fconst:dmmeta.Printfmt.printfmt/Tuple
extern const char *  dmmeta_Reftype_reftype_Alias;      // Alias       fconst:dmmeta.Reftype.reftype/Alias
extern const char *  dmmeta_Reftype_reftype_Atree;      // Atree       fconst:dmmeta.Reftype.reftype/Atree
extern const char *  dmmeta_Reftype_reftype_Base;       // Base        fconst:dmmeta.Reftype.reftype/Base
extern const char *  dmmeta_Reftype_reftype_Bheap;      // Bheap       fconst:dmmeta.Reftype.reftype/Bheap
extern const char *  dmmeta_Reftype_reftype_Bitfld;     // Bitfld      fconst:dmmeta.Reftype.reftype/Bitfld
extern const char *  dmmeta_Reftype_reftype_Blkpool;    // Blkpool     fconst:dmmeta.Reftype.reftype/Blkpool
extern const char *  dmmeta_Reftype_reftype_Charset;    // Charset     fconst:dmmeta.Reftype.reftype/Charset
extern const char *  dmmeta_Reftype_reftype_Count;      // Count       fconst:dmmeta.Reftype.reftype/Count
extern const char *  dmmeta_Reftype_reftype_Cppstack;   // Cppstack    fconst:dmmeta.Reftype.reftype/Cppstack
extern const char *  dmmeta_Reftype_reftype_Delptr;     // Delptr      fconst:dmmeta.Reftype.reftype/Delptr
extern const char *  dmmeta_Reftype_reftype_Exec;       // Exec        fconst:dmmeta.Reftype.reftype/Exec
extern const char *  dmmeta_Reftype_reftype_Fbuf;       // Fbuf        fconst:dmmeta.Reftype.reftype/Fbuf
extern const char *  dmmeta_Reftype_reftype_Global;     // Global      fconst:dmmeta.Reftype.reftype/Global
extern const char *  dmmeta_Reftype_reftype_Hook;       // Hook        fconst:dmmeta.Reftype.reftype/Hook
extern const char *  dmmeta_Reftype_reftype_Inlary;     // Inlary      fconst:dmmeta.Reftype.reftype/Inlary
extern const char *  dmmeta_Reftype_reftype_Lary;       // Lary        fconst:dmmeta.Reftype.reftype/Lary
extern const char *  dmmeta_Reftype_reftype_Llist;      // Llist       fconst:dmmeta.Reftype.reftype/Llist
extern const char *  dmmeta_Reftype_reftype_Lpool;      // Lpool       fconst:dmmeta.Reftype.reftype/Lpool
extern const char *  dmmeta_Reftype_reftype_Malloc;     // Malloc      fconst:dmmeta.Reftype.reftype/Malloc
extern const char *  dmmeta_Reftype_reftype_Opt;        // Opt         fconst:dmmeta.Reftype.reftype/Opt
extern const char *  dmmeta_Reftype_reftype_Pkey;       // Pkey        fconst:dmmeta.Reftype.reftype/Pkey
extern const char *  dmmeta_Reftype_reftype_Protocol;   // Protocol    fconst:dmmeta.Reftype.reftype/Protocol
extern const char *  dmmeta_Reftype_reftype_Ptr;        // Ptr         fconst:dmmeta.Reftype.reftype/Ptr
extern const char *  dmmeta_Reftype_reftype_Ptrary;     // Ptrary      fconst:dmmeta.Reftype.reftype/Ptrary
extern const char *  dmmeta_Reftype_reftype_Regx;       // Regx        fconst:dmmeta.Reftype.reftype/Regx
extern const char *  dmmeta_Reftype_reftype_RegxSql;    // RegxSql     fconst:dmmeta.Reftype.reftype/RegxSql
extern const char *  dmmeta_Reftype_reftype_Sbrk;       // Sbrk        fconst:dmmeta.Reftype.reftype/Sbrk
extern const char *  dmmeta_Reftype_reftype_Smallstr;   // Smallstr    fconst:dmmeta.Reftype.reftype/Smallstr
extern const char *  dmmeta_Reftype_reftype_Tary;       // Tary        fconst:dmmeta.Reftype.reftype/Tary
extern const char *  dmmeta_Reftype_reftype_Thash;      // Thash       fconst:dmmeta.Reftype.reftype/Thash
extern const char *  dmmeta_Reftype_reftype_Tpool;      // Tpool       fconst:dmmeta.Reftype.reftype/Tpool
extern const char *  dmmeta_Reftype_reftype_Upptr;      // Upptr       fconst:dmmeta.Reftype.reftype/Upptr
extern const char *  dmmeta_Reftype_reftype_Val;        // Val         fconst:dmmeta.Reftype.reftype/Val
extern const char *  dmmeta_Reftype_reftype_Varlen;     // Varlen      fconst:dmmeta.Reftype.reftype/Varlen
extern const char *  dmmeta_Reftype_reftype_ZSListMT;   // ZSListMT    fconst:dmmeta.Reftype.reftype/ZSListMT

// --- dmmeta_ReftypeCaseEnum

enum dmmeta_ReftypeCaseEnum {            // dmmeta.ReftypeCase.reftype
     dmmeta_ReftypeCase_Alias      = 1
    ,dmmeta_ReftypeCase_Atree      = 2
    ,dmmeta_ReftypeCase_Base       = 3
    ,dmmeta_ReftypeCase_Bheap      = 4
    ,dmmeta_ReftypeCase_Bitfld     = 5
    ,dmmeta_ReftypeCase_Blkpool    = 6
    ,dmmeta_ReftypeCase_Charset    = 7
    ,dmmeta_ReftypeCase_Count      = 8
    ,dmmeta_ReftypeCase_Cppstack   = 9
    ,dmmeta_ReftypeCase_Delptr     = 10
    ,dmmeta_ReftypeCase_Exec       = 11
    ,dmmeta_ReftypeCase_Fbuf       = 12
    ,dmmeta_ReftypeCase_Global     = 13
    ,dmmeta_ReftypeCase_Hook       = 14
    ,dmmeta_ReftypeCase_Inlary     = 15
    ,dmmeta_ReftypeCase_Lary       = 16
    ,dmmeta_ReftypeCase_Llist      = 17
    ,dmmeta_ReftypeCase_Lpool      = 18
    ,dmmeta_ReftypeCase_Malloc     = 19
    ,dmmeta_ReftypeCase_Opt        = 20
    ,dmmeta_ReftypeCase_Pkey       = 21
    ,dmmeta_ReftypeCase_Protocol   = 22
    ,dmmeta_ReftypeCase_Ptr        = 23
    ,dmmeta_ReftypeCase_Ptrary     = 24
    ,dmmeta_ReftypeCase_Regx       = 25
    ,dmmeta_ReftypeCase_RegxSql    = 26
    ,dmmeta_ReftypeCase_Sbrk       = 27
    ,dmmeta_ReftypeCase_Smallstr   = 28
    ,dmmeta_ReftypeCase_Tary       = 29
    ,dmmeta_ReftypeCase_Thash      = 30
    ,dmmeta_ReftypeCase_Tpool      = 31
    ,dmmeta_ReftypeCase_Upptr      = 32
    ,dmmeta_ReftypeCase_Val        = 33
    ,dmmeta_ReftypeCase_Varlen     = 34
    ,dmmeta_ReftypeCase_ZSListMT   = 35
};

enum { dmmeta_ReftypeCaseEnum_N = 35 };

extern const char *  dmmeta_Sorttype_sorttype_QuickSort;       // QuickSort        fconst:dmmeta.Sorttype.sorttype/QuickSort
extern const char *  dmmeta_Sorttype_sorttype_InsertionSort;   // InsertionSort    fconst:dmmeta.Sorttype.sorttype/InsertionSort
extern const char *  dmmeta_Sorttype_sorttype_HeapSort;        // HeapSort         fconst:dmmeta.Sorttype.sorttype/HeapSort
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_bltin;                 // amcdb.bltin                  fconst:dmmeta.Ssimfile.ssimfile/amcdb.bltin
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_curstype;              // amcdb.curstype               fconst:dmmeta.Ssimfile.ssimfile/amcdb.curstype
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_gen;                   // amcdb.gen                    fconst:dmmeta.Ssimfile.ssimfile/amcdb.gen
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_regxtype;              // amcdb.regxtype               fconst:dmmeta.Ssimfile.ssimfile/amcdb.regxtype
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tclass;                // amcdb.tclass                 fconst:dmmeta.Ssimfile.ssimfile/amcdb.tclass
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tcurs;                 // amcdb.tcurs                  fconst:dmmeta.Ssimfile.ssimfile/amcdb.tcurs
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tfunc;                 // amcdb.tfunc                  fconst:dmmeta.Ssimfile.ssimfile/amcdb.tfunc
extern const char *  dmmeta_Ssimfile_ssimfile_amsdb_proctype;              // amsdb.proctype               fconst:dmmeta.Ssimfile.ssimfile/amsdb.proctype
extern const char *  dmmeta_Ssimfile_ssimfile_amsdb_streamtype;            // amsdb.streamtype             fconst:dmmeta.Ssimfile.ssimfile/amsdb.streamtype
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_amctest;               // atfdb.amctest                fconst:dmmeta.Ssimfile.ssimfile/atfdb.amctest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_cijob;                 // atfdb.cijob                  fconst:dmmeta.Ssimfile.ssimfile/atfdb.cijob
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_cipackage;             // atfdb.cipackage              fconst:dmmeta.Ssimfile.ssimfile/atfdb.cipackage
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_citest;                // atfdb.citest                 fconst:dmmeta.Ssimfile.ssimfile/atfdb.citest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_comptest;              // atfdb.comptest               fconst:dmmeta.Ssimfile.ssimfile/atfdb.comptest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_fuzzstrat;             // atfdb.fuzzstrat              fconst:dmmeta.Ssimfile.ssimfile/atfdb.fuzzstrat
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_msgdir;                // atfdb.msgdir                 fconst:dmmeta.Ssimfile.ssimfile/atfdb.msgdir
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_targs;                 // atfdb.targs                  fconst:dmmeta.Ssimfile.ssimfile/atfdb.targs
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_char;     // atfdb.test_gsymbol_char      fconst:dmmeta.Ssimfile.ssimfile/atfdb.test_gsymbol_char
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_pkey;     // atfdb.test_gsymbol_pkey      fconst:dmmeta.Ssimfile.ssimfile/atfdb.test_gsymbol_pkey
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_test_gsymbol_strptr;   // atfdb.test_gsymbol_strptr    fconst:dmmeta.Ssimfile.ssimfile/atfdb.test_gsymbol_strptr
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_tfilt;                 // atfdb.tfilt                  fconst:dmmeta.Ssimfile.ssimfile/atfdb.tfilt
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_tmsg;                  // atfdb.tmsg                   fconst:dmmeta.Ssimfile.ssimfile/atfdb.tmsg
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_unittest;              // atfdb.unittest               fconst:dmmeta.Ssimfile.ssimfile/atfdb.unittest
extern const char *  dmmeta_Ssimfile_ssimfile_dev_arch;                    // dev.arch                     fconst:dmmeta.Ssimfile.ssimfile/dev.arch
extern const char *  dmmeta_Ssimfile_ssimfile_dev_badline;                 // dev.badline                  fconst:dmmeta.Ssimfile.ssimfile/dev.badline
extern const char *  dmmeta_Ssimfile_ssimfile_dev_builddir;                // dev.builddir                 fconst:dmmeta.Ssimfile.ssimfile/dev.builddir
extern const char *  dmmeta_Ssimfile_ssimfile_dev_cfg;                     // dev.cfg                      fconst:dmmeta.Ssimfile.ssimfile/dev.cfg
extern const char *  dmmeta_Ssimfile_ssimfile_dev_compiler;                // dev.compiler                 fconst:dmmeta.Ssimfile.ssimfile/dev.compiler
extern const char *  dmmeta_Ssimfile_ssimfile_dev_copyright;               // dev.copyright                fconst:dmmeta.Ssimfile.ssimfile/dev.copyright
extern const char *  dmmeta_Ssimfile_ssimfile_dev_covfile;                 // dev.covfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.covfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_covline;                 // dev.covline                  fconst:dmmeta.Ssimfile.ssimfile/dev.covline
extern const char *  dmmeta_Ssimfile_ssimfile_dev_covtarget;               // dev.covtarget                fconst:dmmeta.Ssimfile.ssimfile/dev.covtarget
extern const char *  dmmeta_Ssimfile_ssimfile_dev_edaction;                // dev.edaction                 fconst:dmmeta.Ssimfile.ssimfile/dev.edaction
extern const char *  dmmeta_Ssimfile_ssimfile_dev_edacttype;               // dev.edacttype                fconst:dmmeta.Ssimfile.ssimfile/dev.edacttype
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitfile;                 // dev.gitfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.gitfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitinfo;                 // dev.gitinfo                  fconst:dmmeta.Ssimfile.ssimfile/dev.gitinfo
extern const char *  dmmeta_Ssimfile_ssimfile_dev_hilite;                  // dev.hilite                   fconst:dmmeta.Ssimfile.ssimfile/dev.hilite
extern const char *  dmmeta_Ssimfile_ssimfile_dev_htmlentity;              // dev.htmlentity               fconst:dmmeta.Ssimfile.ssimfile/dev.htmlentity
extern const char *  dmmeta_Ssimfile_ssimfile_dev_include;                 // dev.include                  fconst:dmmeta.Ssimfile.ssimfile/dev.include
extern const char *  dmmeta_Ssimfile_ssimfile_dev_license;                 // dev.license                  fconst:dmmeta.Ssimfile.ssimfile/dev.license
extern const char *  dmmeta_Ssimfile_ssimfile_dev_linelim;                 // dev.linelim                  fconst:dmmeta.Ssimfile.ssimfile/dev.linelim
extern const char *  dmmeta_Ssimfile_ssimfile_dev_mdsection;               // dev.mdsection                fconst:dmmeta.Ssimfile.ssimfile/dev.mdsection
extern const char *  dmmeta_Ssimfile_ssimfile_dev_msgfile;                 // dev.msgfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.msgfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_noindent;                // dev.noindent                 fconst:dmmeta.Ssimfile.ssimfile/dev.noindent
extern const char *  dmmeta_Ssimfile_ssimfile_dev_opt_type;                // dev.opt_type                 fconst:dmmeta.Ssimfile.ssimfile/dev.opt_type
extern const char *  dmmeta_Ssimfile_ssimfile_dev_package;                 // dev.package                  fconst:dmmeta.Ssimfile.ssimfile/dev.package
extern const char *  dmmeta_Ssimfile_ssimfile_dev_pkgdep;                  // dev.pkgdep                   fconst:dmmeta.Ssimfile.ssimfile/dev.pkgdep
extern const char *  dmmeta_Ssimfile_ssimfile_dev_pkgkey;                  // dev.pkgkey                   fconst:dmmeta.Ssimfile.ssimfile/dev.pkgkey
extern const char *  dmmeta_Ssimfile_ssimfile_dev_readme;                  // dev.readme                   fconst:dmmeta.Ssimfile.ssimfile/dev.readme
extern const char *  dmmeta_Ssimfile_ssimfile_dev_sandbox;                 // dev.sandbox                  fconst:dmmeta.Ssimfile.ssimfile/dev.sandbox
extern const char *  dmmeta_Ssimfile_ssimfile_dev_sbpath;                  // dev.sbpath                   fconst:dmmeta.Ssimfile.ssimfile/dev.sbpath
extern const char *  dmmeta_Ssimfile_ssimfile_dev_scriptfile;              // dev.scriptfile               fconst:dmmeta.Ssimfile.ssimfile/dev.scriptfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_srcfile;                 // dev.srcfile                  fconst:dmmeta.Ssimfile.ssimfile/dev.srcfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syscmd;                  // dev.syscmd                   fconst:dmmeta.Ssimfile.ssimfile/dev.syscmd
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syscmddep;               // dev.syscmddep                fconst:dmmeta.Ssimfile.ssimfile/dev.syscmddep
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syslib;                  // dev.syslib                   fconst:dmmeta.Ssimfile.ssimfile/dev.syslib
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targdep;                 // dev.targdep                  fconst:dmmeta.Ssimfile.ssimfile/dev.targdep
extern const char *  dmmeta_Ssimfile_ssimfile_dev_target;                  // dev.target                   fconst:dmmeta.Ssimfile.ssimfile/dev.target
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targsrc;                 // dev.targsrc                  fconst:dmmeta.Ssimfile.ssimfile/dev.targsrc
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targsyslib;              // dev.targsyslib               fconst:dmmeta.Ssimfile.ssimfile/dev.targsyslib
extern const char *  dmmeta_Ssimfile_ssimfile_dev_tgtcov;                  // dev.tgtcov                   fconst:dmmeta.Ssimfile.ssimfile/dev.tgtcov
extern const char *  dmmeta_Ssimfile_ssimfile_dev_timefmt;                 // dev.timefmt                  fconst:dmmeta.Ssimfile.ssimfile/dev.timefmt
extern const char *  dmmeta_Ssimfile_ssimfile_dev_tool_opt;                // dev.tool_opt                 fconst:dmmeta.Ssimfile.ssimfile/dev.tool_opt
extern const char *  dmmeta_Ssimfile_ssimfile_dev_uname;                   // dev.uname                    fconst:dmmeta.Ssimfile.ssimfile/dev.uname
extern const char *  dmmeta_Ssimfile_ssimfile_dev_unstablefld;             // dev.unstablefld              fconst:dmmeta.Ssimfile.ssimfile/dev.unstablefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_anonfld;              // dmmeta.anonfld               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.anonfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_argvtype;             // dmmeta.argvtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.argvtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_basepool;             // dmmeta.basepool              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.basepool
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_bitfld;               // dmmeta.bitfld                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.bitfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cafter;               // dmmeta.cafter                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cafter
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cascdel;              // dmmeta.cascdel               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cascdel
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ccmp;                 // dmmeta.ccmp                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ccmp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cdflt;                // dmmeta.cdflt                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cdflt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cextern;              // dmmeta.cextern               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cextern
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cfast;                // dmmeta.cfast                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cfast
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cfmt;                 // dmmeta.cfmt                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cget;                 // dmmeta.cget                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cget
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_charset;              // dmmeta.charset               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.charset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_chash;                // dmmeta.chash                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.chash
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cppfunc;              // dmmeta.cppfunc               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cppfunc
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cppkeyword;           // dmmeta.cppkeyword            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cppkeyword
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cpptype;              // dmmeta.cpptype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cpptype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_csize;                // dmmeta.csize                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.csize
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cstr;                 // dmmeta.cstr                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ctype;                // dmmeta.ctype                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ctype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ctypelen;             // dmmeta.ctypelen              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ctypelen
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispatch;             // dmmeta.dispatch              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispatch
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispatch_msg;         // dmmeta.dispatch_msg          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispatch_msg
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispctx;              // dmmeta.dispctx               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispctx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispfilter;           // dmmeta.dispfilter            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispfilter
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispsig;              // dmmeta.dispsig               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispsig
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispsigcheck;         // dmmeta.dispsigcheck          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispsigcheck
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_disptrace;            // dmmeta.disptrace             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.disptrace
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_falias;               // dmmeta.falias                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.falias
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fastenc;              // dmmeta.fastenc               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fastenc
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fastinstr;            // dmmeta.fastinstr             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fastinstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fastop;               // dmmeta.fastop                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fastop
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbase;                // dmmeta.fbase                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbase
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbigend;              // dmmeta.fbigend               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbigend
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbitset;              // dmmeta.fbitset               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbitset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbuf;                 // dmmeta.fbuf                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbuf
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbufdir;              // dmmeta.fbufdir               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbufdir
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbuftype;             // dmmeta.fbuftype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbuftype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcast;                // dmmeta.fcast                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcast
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcleanup;             // dmmeta.fcleanup              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcleanup
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmap;                // dmmeta.fcmap                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmap
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmdline;             // dmmeta.fcmdline              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmdline
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmp;                 // dmmeta.fcmp                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcompact;             // dmmeta.fcompact              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcompact
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fconst;               // dmmeta.fconst                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fconst
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcurs;                // dmmeta.fcurs                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcurs
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fdec;                 // dmmeta.fdec                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fdec
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fdelay;               // dmmeta.fdelay                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fdelay
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ffast;                // dmmeta.ffast                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ffast
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fflag;                // dmmeta.fflag                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fflag
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_field;                // dmmeta.field                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.field
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_findrem;              // dmmeta.findrem               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.findrem
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_finput;               // dmmeta.finput                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.finput
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fldoffset;            // dmmeta.fldoffset             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fldoffset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_floadtuples;          // dmmeta.floadtuples           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.floadtuples
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fnoremove;            // dmmeta.fnoremove             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fnoremove
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_foutput;              // dmmeta.foutput               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.foutput
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fprefix;              // dmmeta.fprefix               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fprefix
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fregx;                // dmmeta.fregx                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fregx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fsort;                // dmmeta.fsort                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fsort
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fstep;                // dmmeta.fstep                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fstep
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ftrace;               // dmmeta.ftrace                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ftrace
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ftuple;               // dmmeta.ftuple                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ftuple
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_func;                 // dmmeta.func                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.func
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_funique;              // dmmeta.funique               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.funique
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fuserinit;            // dmmeta.fuserinit             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fuserinit
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fwddecl;              // dmmeta.fwddecl               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fwddecl
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gconst;               // dmmeta.gconst                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gconst
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gstatic;              // dmmeta.gstatic               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gstatic
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gsymbol;              // dmmeta.gsymbol               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gsymbol
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_hashtype;             // dmmeta.hashtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.hashtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_hook;                 // dmmeta.hook                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.hook
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_inlary;               // dmmeta.inlary                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.inlary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_lenfld;               // dmmeta.lenfld                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.lenfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_listtype;             // dmmeta.listtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.listtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_llist;                // dmmeta.llist                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.llist
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_logcat;               // dmmeta.logcat                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.logcat
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_main;                 // dmmeta.main                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.main
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_msgtype;              // dmmeta.msgtype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.msgtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nocascdel;            // dmmeta.nocascdel             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nocascdel
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nossimfile;           // dmmeta.nossimfile            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nossimfile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_noxref;               // dmmeta.noxref                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.noxref
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ns;                   // dmmeta.ns                    fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ns
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nscpp;                // dmmeta.nscpp                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nscpp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsdb;                 // dmmeta.nsdb                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsdb
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsfast;               // dmmeta.nsfast                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsfast
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsinclude;            // dmmeta.nsinclude             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsinclude
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsproto;              // dmmeta.nsproto               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsproto
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nstype;               // dmmeta.nstype                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nstype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsversion;            // dmmeta.nsversion             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsversion
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsx;                  // dmmeta.nsx                   fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_numstr;               // dmmeta.numstr                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.numstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pack;                 // dmmeta.pack                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pack
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld;             // dmmeta.pmaskfld              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pmaskfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld_member;      // dmmeta.pmaskfld_member       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pmaskfld_member
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pnew;                 // dmmeta.pnew                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pnew
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pnewtype;             // dmmeta.pnewtype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pnewtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_printfmt;             // dmmeta.printfmt              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.printfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ptrary;               // dmmeta.ptrary                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ptrary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_reftype;              // dmmeta.reftype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.reftype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_rowid;                // dmmeta.rowid                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.rowid
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_smallstr;             // dmmeta.smallstr              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.smallstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sortfld;              // dmmeta.sortfld               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sortfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sorttype;             // dmmeta.sorttype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sorttype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sqltype;              // dmmeta.sqltype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sqltype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimfile;             // dmmeta.ssimfile              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimfile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimreq;              // dmmeta.ssimreq               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimreq
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimsort;             // dmmeta.ssimsort              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimsort
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimvolatile;         // dmmeta.ssimvolatile          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimvolatile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_steptype;             // dmmeta.steptype              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.steptype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_strfmt;               // dmmeta.strfmt                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.strfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_strtype;              // dmmeta.strtype               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.strtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_substr;               // dmmeta.substr                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.substr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_svtype;               // dmmeta.svtype                fconst:dmmeta.Ssimfile.ssimfile/dmmeta.svtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tary;                 // dmmeta.tary                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_thash;                // dmmeta.thash                 fconst:dmmeta.Ssimfile.ssimfile/dmmeta.thash
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tracefld;             // dmmeta.tracefld              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tracefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tracerec;             // dmmeta.tracerec              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tracerec
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_typefld;              // dmmeta.typefld               fconst:dmmeta.Ssimfile.ssimfile/dmmeta.typefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_usertracefld;         // dmmeta.usertracefld          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.usertracefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_xref;                 // dmmeta.xref                  fconst:dmmeta.Ssimfile.ssimfile/dmmeta.xref
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alarm;                  // fmdb.alarm                   fconst:dmmeta.Ssimfile.ssimfile/fmdb.alarm
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alm_code;               // fmdb.alm_code                fconst:dmmeta.Ssimfile.ssimfile/fmdb.alm_code
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alm_objtype;            // fmdb.alm_objtype             fconst:dmmeta.Ssimfile.ssimfile/fmdb.alm_objtype
extern const char *  dmmeta_Ssimfile_ssimfile_fmdb_alm_source;             // fmdb.alm_source              fconst:dmmeta.Ssimfile.ssimfile/fmdb.alm_source
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gact;                 // gclidb.gact                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gact
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gatv;                 // gclidb.gatv                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gatv
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclicmd;              // gclidb.gclicmd               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclicmd
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclicmdf2j;           // gclidb.gclicmdf2j            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclicmdf2j
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclicmdt;             // gclidb.gclicmdt              fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclicmdt
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclienv;              // gclidb.gclienv               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclienv
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclienvsub;           // gclidb.gclienvsub            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclienvsub
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gclisub;              // gclidb.gclisub               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gclisub
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gfld;                 // gclidb.gfld                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gfld
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_githost;              // gclidb.githost               fconst:dmmeta.Ssimfile.ssimfile/gclidb.githost
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gmethod;              // gclidb.gmethod               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gmethod
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_grepo;                // gclidb.grepo                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.grepo
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_grepogitport;         // gclidb.grepogitport          fconst:dmmeta.Ssimfile.ssimfile/gclidb.grepogitport
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_grepossh;             // gclidb.grepossh              fconst:dmmeta.Ssimfile.ssimfile/gclidb.grepossh
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gstate;               // gclidb.gstate                fconst:dmmeta.Ssimfile.ssimfile/gclidb.gstate
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gstatet;              // gclidb.gstatet               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gstatet
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtbl;                 // gclidb.gtbl                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtbl
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblact;              // gclidb.gtblact               fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblact
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblactfld;           // gclidb.gtblactfld            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblactfld
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblacttst;           // gclidb.gtblacttst            fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblacttst
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtblacttstout;        // gclidb.gtblacttstout         fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtblacttstout
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtype;                // gclidb.gtype                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtype
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtypeh;               // gclidb.gtypeh                fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtypeh
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_gtypeprefix;          // gclidb.gtypeprefix           fconst:dmmeta.Ssimfile.ssimfile/gclidb.gtypeprefix
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_issue;                // gclidb.issue                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.issue
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_issuenote;            // gclidb.issuenote             fconst:dmmeta.Ssimfile.ssimfile/gclidb.issuenote
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_issuepipeline;        // gclidb.issuepipeline         fconst:dmmeta.Ssimfile.ssimfile/gclidb.issuepipeline
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_label;                // gclidb.label                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.label
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_milestone;            // gclidb.milestone             fconst:dmmeta.Ssimfile.ssimfile/gclidb.milestone
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_mr;                   // gclidb.mr                    fconst:dmmeta.Ssimfile.ssimfile/gclidb.mr
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_mrjob;                // gclidb.mrjob                 fconst:dmmeta.Ssimfile.ssimfile/gclidb.mrjob
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_mrnote;               // gclidb.mrnote                fconst:dmmeta.Ssimfile.ssimfile/gclidb.mrnote
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_project;              // gclidb.project               fconst:dmmeta.Ssimfile.ssimfile/gclidb.project
extern const char *  dmmeta_Ssimfile_ssimfile_gclidb_user;                 // gclidb.user                  fconst:dmmeta.Ssimfile.ssimfile/gclidb.user
extern const char *  dmmeta_Steptype_steptype_Callback;        // Callback         fconst:dmmeta.Steptype.steptype/Callback
extern const char *  dmmeta_Steptype_steptype_Extern;          // Extern           fconst:dmmeta.Steptype.steptype/Extern
extern const char *  dmmeta_Steptype_steptype_Inline;          // Inline           fconst:dmmeta.Steptype.steptype/Inline
extern const char *  dmmeta_Steptype_steptype_InlineOnce;      // InlineOnce       fconst:dmmeta.Steptype.steptype/InlineOnce
extern const char *  dmmeta_Steptype_steptype_InlineRecur;     // InlineRecur      fconst:dmmeta.Steptype.steptype/InlineRecur
extern const char *  dmmeta_Steptype_steptype_TimeHookRecur;   // TimeHookRecur    fconst:dmmeta.Steptype.steptype/TimeHookRecur
extern const char *  dmmeta_Strfmt_strfmt_Argv;      // Argv       fconst:dmmeta.Strfmt.strfmt/Argv
extern const char *  dmmeta_Strfmt_strfmt_ArgvGnu;   // ArgvGnu    fconst:dmmeta.Strfmt.strfmt/ArgvGnu
extern const char *  dmmeta_Strfmt_strfmt_Json;      // Json       fconst:dmmeta.Strfmt.strfmt/Json
extern const char *  dmmeta_Strfmt_strfmt_String;    // String     fconst:dmmeta.Strfmt.strfmt/String
extern const char *  dmmeta_Strfmt_strfmt_Tuple;     // Tuple      fconst:dmmeta.Strfmt.strfmt/Tuple
extern const char *  dmmeta_Strtype_strtype_rpascal;    // rpascal     fconst:dmmeta.Strtype.strtype/rpascal
extern const char *  dmmeta_Strtype_strtype_rightpad;   // rightpad    fconst:dmmeta.Strtype.strtype/rightpad
extern const char *  dmmeta_Strtype_strtype_leftpad;    // leftpad     fconst:dmmeta.Strtype.strtype/leftpad
namespace dmmeta { // gen:ns_pkeytypedef
    typedef algo::Smallstr50 BuftypePkey;
    typedef algo::Smallstr50 CafterPkey;
    typedef algo::Smallstr100 CfmtPkey;
    typedef algo::Smallstr20 CppkeywordPkey;
    typedef algo::Smallstr100 CtypePkey;
    typedef algo::Smallstr50 DispatchPkey;
    typedef algo::Smallstr100 DispatchMsgPkey;
    typedef algo::Smallstr50 DispsigPkey;
    typedef algo::Smallstr50 FastencPkey;
    typedef algo::Smallstr50 FastinstrPkey;
    typedef algo::Smallstr50 FastopPkey;
    typedef algo::Smallstr50 FbufdirPkey;
    typedef algo::Smallstr50 FbuftypePkey;
    typedef algo::Smallstr250 FcmapPkey;
    typedef algo::Smallstr100 FconstPkey;
    typedef algo::Smallstr50 FcursPkey;
    typedef algo::Smallstr100 FfastPkey;
    typedef algo::Smallstr100 FieldPkey;
    typedef algo::Smallstr5 FprefixPkey;
    typedef algo::Smallstr100 FstepPkey;
    typedef algo::Smallstr100 FuncPkey;
    typedef algo::Smallstr100 FwddeclPkey;
    typedef algo::Smallstr50 GsymbolPkey;
    typedef algo::Smallstr50 HashtypePkey;
    typedef algo::Smallstr5 ListtypePkey;
    typedef algo::Smallstr50 LogcatPkey;
    typedef algo::Smallstr16 NsPkey;
    typedef algo::Smallstr16 NsdbPkey;
    typedef algo::Smallstr50 NsincludePkey;
    typedef algo::Smallstr50 NstypePkey;
    typedef algo::Smallstr100 PmaskfldPkey;
    typedef algo::Smallstr100 PmaskfldMemberPkey;
    typedef algo::Smallstr100 PnewPkey;
    typedef algo::Smallstr50 PrintfmtPkey;
    typedef algo::Smallstr50 ReftypePkey;
    typedef algo::Smallstr100 SmallstrPkey;
    typedef algo::Smallstr50 SorttypePkey;
    typedef algo::Smallstr50 SsimfilePkey;
    typedef algo::Smallstr100 SsimreqPkey;
    typedef algo::Smallstr50 SteptypePkey;
    typedef algo::Smallstr50 StrfmtPkey;
    typedef algo::Smallstr50 StrtypePkey;
    typedef algo::Smallstr100 SubstrPkey;
    typedef algo::Smallstr100 TracefldPkey;
    typedef algo::Smallstr50 TracerecPkey;
    typedef algo::Smallstr100 XrefPkey;
} // gen:ns_pkeytypedef
namespace dmmeta { // gen:ns_field
} // gen:ns_field
// gen:ns_fwddecl2
namespace dmmeta { struct Anonfld; }
namespace dmmeta { struct Argvtype; }
namespace dmmeta { struct Basepool; }
namespace dmmeta { struct Bitfld; }
namespace dmmeta { struct Buftype; }
namespace dmmeta { struct Cafter; }
namespace dmmeta { struct Cascdel; }
namespace dmmeta { struct Ccmp; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cextern; }
namespace dmmeta { struct Cfast; }
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cget; }
namespace dmmeta { struct Charset; }
namespace dmmeta { struct Chash; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Cppkeyword; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Csize; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace dmmeta { struct Ctypelen; }
namespace dmmeta { struct Dispatch; }
namespace dmmeta { struct DispatchMsg; }
namespace dmmeta { struct Dispctx; }
namespace dmmeta { struct Dispfilter; }
namespace dmmeta { struct Dispsig; }
namespace dmmeta { struct Dispsigcheck; }
namespace dmmeta { struct Disptrace; }
namespace dmmeta { struct Falias; }
namespace dmmeta { struct Fastenc; }
namespace dmmeta { struct FastencCase; }
namespace dmmeta { struct Fastinstr; }
namespace dmmeta { struct FastinstrCase; }
namespace dmmeta { struct Fastop; }
namespace dmmeta { struct FastopCase; }
namespace dmmeta { struct Fbase; }
namespace dmmeta { struct Fbigend; }
namespace dmmeta { struct Fbitset; }
namespace dmmeta { struct Fbuf; }
namespace dmmeta { struct Fbufdir; }
namespace dmmeta { struct Fbuftype; }
namespace dmmeta { struct Fcast; }
namespace dmmeta { struct Fcleanup; }
namespace dmmeta { struct Fcmap; }
namespace dmmeta { struct Fcmdline; }
namespace dmmeta { struct Fcmp; }
namespace dmmeta { struct Fcompact; }
namespace dmmeta { struct Fconst; }
namespace dmmeta { struct Fcurs; }
namespace dmmeta { struct Fdec; }
namespace dmmeta { struct Fdelay; }
namespace dmmeta { struct Ffast; }
namespace dmmeta { struct Fflag; }
namespace dmmeta { struct Field; }
namespace dmmeta { struct FieldId; }
namespace dmmeta { struct Findrem; }
namespace dmmeta { struct Finput; }
namespace dmmeta { struct Fldoffset; }
namespace dmmeta { struct Floadtuples; }
namespace dmmeta { struct Fnoremove; }
namespace dmmeta { struct Foutput; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Fregx; }
namespace dmmeta { struct Fsort; }
namespace dmmeta { struct Fstep; }
namespace dmmeta { struct Ftrace; }
namespace dmmeta { struct Ftuple; }
namespace dmmeta { struct Func; }
namespace dmmeta { struct Funique; }
namespace dmmeta { struct Fuserinit; }
namespace dmmeta { struct Fwddecl; }
namespace dmmeta { struct Gconst; }
namespace dmmeta { struct Gstatic; }
namespace dmmeta { struct Gsymbol; }
namespace dmmeta { struct Hashtype; }
namespace dmmeta { struct Hook; }
namespace dmmeta { struct Inlary; }
namespace dmmeta { struct Lenfld; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Llist; }
namespace dmmeta { struct Logcat; }
namespace dmmeta { struct Main; }
namespace dmmeta { struct Msgtype; }
namespace dmmeta { struct Nocascdel; }
namespace dmmeta { struct Nossimfile; }
namespace dmmeta { struct Noxref; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Nscpp; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Nsfast; }
namespace dmmeta { struct Nsinclude; }
namespace dmmeta { struct Nsproto; }
namespace dmmeta { struct Nstype; }
namespace dmmeta { struct Nsversion; }
namespace dmmeta { struct Nsx; }
namespace dmmeta { struct Numstr; }
namespace dmmeta { struct Pack; }
namespace dmmeta { struct Pmaskfld; }
namespace dmmeta { struct PmaskfldMember; }
namespace dmmeta { struct Pnew; }
namespace dmmeta { struct Printfmt; }
namespace dmmeta { struct Ptrary; }
namespace dmmeta { struct Reftype; }
namespace dmmeta { struct ReftypeCase; }
namespace dmmeta { struct Rowid; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Sortfld; }
namespace dmmeta { struct Sorttype; }
namespace dmmeta { struct Sqltype; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimreq; }
namespace dmmeta { struct Ssimsort; }
namespace dmmeta { struct Ssimvolatile; }
namespace dmmeta { struct Steptype; }
namespace dmmeta { struct Strfmt; }
namespace dmmeta { struct Strtype; }
namespace dmmeta { struct Substr; }
namespace dmmeta { struct Svtype; }
namespace dmmeta { struct Tary; }
namespace dmmeta { struct Thash; }
namespace dmmeta { struct Tracefld; }
namespace dmmeta { struct Tracerec; }
namespace dmmeta { struct Typefld; }
namespace dmmeta { struct Usertracefld; }
namespace dmmeta { struct Xref; }
namespace dmmeta { // gen:ns_print_struct

// --- dmmeta.Anonfld
struct Anonfld { // dmmeta.Anonfld: Omit field name where possible (command line, enums, constants)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Anonfld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Anonfld();
};

// func:dmmeta.Anonfld..ReadFieldMaybe
bool                 Anonfld_ReadFieldMaybe(dmmeta::Anonfld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Anonfld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Anonfld..ReadStrptrMaybe
bool                 Anonfld_ReadStrptrMaybe(dmmeta::Anonfld &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Anonfld.String  printfmt:Tuple
// func:dmmeta.Anonfld..Print
void                 Anonfld_Print(dmmeta::Anonfld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Argvtype
struct Argvtype { // dmmeta.Argvtype: Customize parsing of command lines (rarely used)
    algo::Smallstr100   ctype;      //
    algo::Smallstr50    argvtype;   //
    algo::Comment       comment;    //
    Argvtype();
};

// func:dmmeta.Argvtype..ReadFieldMaybe
bool                 Argvtype_ReadFieldMaybe(dmmeta::Argvtype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Argvtype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Argvtype..ReadStrptrMaybe
bool                 Argvtype_ReadStrptrMaybe(dmmeta::Argvtype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Argvtype.String  printfmt:Tuple
// func:dmmeta.Argvtype..Print
void                 Argvtype_Print(dmmeta::Argvtype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Basepool
struct Basepool { // dmmeta.Basepool: Specify pool to be used for allocating elements of a type
    algo::Smallstr100   field;   //
    algo::Smallstr100   base;    //
    explicit Basepool(const algo::strptr&            in_field
        ,const algo::strptr&            in_base);
    Basepool();
};

// func:dmmeta.Basepool..ReadFieldMaybe
bool                 Basepool_ReadFieldMaybe(dmmeta::Basepool& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Basepool from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Basepool..ReadStrptrMaybe
bool                 Basepool_ReadStrptrMaybe(dmmeta::Basepool &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Basepool.String  printfmt:Tuple
// func:dmmeta.Basepool..Print
void                 Basepool_Print(dmmeta::Basepool& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Bitfld
struct Bitfld { // dmmeta.Bitfld: Specify offset/width of a bitfield within another field
    algo::Smallstr100   field;      //
    i32                 offset;     //   0  Offset, in bits, within parent field
    i32                 width;      //   0  Width, in bits, within parent field.
    algo::Smallstr100   srcfield;   //
    algo::Comment       comment;    //
    explicit Bitfld(const algo::strptr&            in_field
        ,i32                            in_offset
        ,i32                            in_width
        ,const algo::strptr&            in_srcfield
        ,const algo::Comment&           in_comment);
    Bitfld();
};

// func:dmmeta.Bitfld.name.Get
algo::Smallstr50     name_Get(dmmeta::Bitfld& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Bitfld.name.Get2
algo::Smallstr50     Bitfld_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Bitfld..ReadFieldMaybe
bool                 Bitfld_ReadFieldMaybe(dmmeta::Bitfld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Bitfld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Bitfld..ReadStrptrMaybe
bool                 Bitfld_ReadStrptrMaybe(dmmeta::Bitfld &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Bitfld..Init
void                 Bitfld_Init(dmmeta::Bitfld& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Bitfld.String  printfmt:Tuple
// func:dmmeta.Bitfld..Print
void                 Bitfld_Print(dmmeta::Bitfld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Buftype
struct Buftype { // dmmeta.Buftype: Type of fbuf
    algo::Smallstr50   pnewtype;   //
    algo::Comment      comment;    //
    explicit Buftype(const algo::strptr&            in_pnewtype
        ,const algo::Comment&           in_comment);
    Buftype();
};

// func:dmmeta.Buftype..ReadFieldMaybe
bool                 Buftype_ReadFieldMaybe(dmmeta::Buftype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Buftype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Buftype..ReadStrptrMaybe
bool                 Buftype_ReadStrptrMaybe(dmmeta::Buftype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Buftype.String  printfmt:Tuple
// func:dmmeta.Buftype..Print
void                 Buftype_Print(dmmeta::Buftype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cafter
struct Cafter { // dmmeta.Cafter: Control amc processing order for unrelated types (used in rare situations)
    algo::Smallstr50   cafter;    //
    algo::Comment      comment;   //
    Cafter();
};

// func:dmmeta.Cafter.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Cafter& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Cafter.ctype.Get2
algo::Smallstr100    Cafter_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Cafter.after.Get
algo::Smallstr100    after_Get(dmmeta::Cafter& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Cafter.after.Get2
algo::Smallstr100    Cafter_after_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Cafter..Concat_ctype_after
tempstr              Cafter_Concat_ctype_after( const algo::strptr& ctype ,const algo::strptr& after );
// func:dmmeta.Cafter..ReadFieldMaybe
bool                 Cafter_ReadFieldMaybe(dmmeta::Cafter& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cafter from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cafter..ReadStrptrMaybe
bool                 Cafter_ReadStrptrMaybe(dmmeta::Cafter &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Cafter.String  printfmt:Tuple
// func:dmmeta.Cafter..Print
void                 Cafter_Print(dmmeta::Cafter& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cascdel
struct Cascdel { // dmmeta.Cascdel: Request cascading delete of referenced rows
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Cascdel(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Cascdel();
};

// func:dmmeta.Cascdel..ReadFieldMaybe
bool                 Cascdel_ReadFieldMaybe(dmmeta::Cascdel& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cascdel from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cascdel..ReadStrptrMaybe
bool                 Cascdel_ReadStrptrMaybe(dmmeta::Cascdel &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Cascdel.String  printfmt:Tuple
// func:dmmeta.Cascdel..Print
void                 Cascdel_Print(dmmeta::Cascdel& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ccmp
struct Ccmp { // dmmeta.Ccmp: Generate hash function
    algo::Smallstr100   ctype;     // Target ctype
    bool                extrn;     //   false  Whether implementation is external
    bool                genop;     //   false  Generate C++ comparison operators (<,>, etc)
    bool                order;     //   false
    bool                minmax;    //   false
    algo::Comment       comment;   //
    explicit Ccmp(const algo::strptr&            in_ctype
        ,bool                           in_extrn
        ,bool                           in_genop
        ,bool                           in_order
        ,bool                           in_minmax
        ,const algo::Comment&           in_comment);
    Ccmp();
};

// func:dmmeta.Ccmp..ReadFieldMaybe
bool                 Ccmp_ReadFieldMaybe(dmmeta::Ccmp& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ccmp from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ccmp..ReadStrptrMaybe
bool                 Ccmp_ReadStrptrMaybe(dmmeta::Ccmp &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Ccmp..Init
void                 Ccmp_Init(dmmeta::Ccmp& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Ccmp.String  printfmt:Tuple
// func:dmmeta.Ccmp..Print
void                 Ccmp_Print(dmmeta::Ccmp& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cdflt
struct Cdflt { // dmmeta.Cdflt: Specify default value for single-value types that lack fields
    algo::Smallstr100   ctype;      //
    algo::CppExpr       dflt;       //
    algo::CppExpr       cppdflt;    //
    algo::Smallstr50    ssimdflt;   //
    algo::Smallstr50    jsdflt;     //
    algo::Comment       comment;    //
    Cdflt();
};

// func:dmmeta.Cdflt..ReadFieldMaybe
bool                 Cdflt_ReadFieldMaybe(dmmeta::Cdflt& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cdflt from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cdflt..ReadStrptrMaybe
bool                 Cdflt_ReadStrptrMaybe(dmmeta::Cdflt &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Cdflt.String  printfmt:Tuple
// func:dmmeta.Cdflt..Print
void                 Cdflt_Print(dmmeta::Cdflt& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cextern
struct Cextern { // dmmeta.Cextern: Externally defined ctype (a struct from system header, or from a c++ library)
    algo::Smallstr100   ctype;        // Ctype in question
    bool                initmemset;   //   false  Initialize using memset? (set this to Y for all C structs)
    bool                isstruct;     //   false
    explicit Cextern(const algo::strptr&            in_ctype
        ,bool                           in_initmemset
        ,bool                           in_isstruct);
    Cextern();
};

// func:dmmeta.Cextern..ReadFieldMaybe
bool                 Cextern_ReadFieldMaybe(dmmeta::Cextern& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cextern from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cextern..ReadStrptrMaybe
bool                 Cextern_ReadStrptrMaybe(dmmeta::Cextern &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Cextern..Init
void                 Cextern_Init(dmmeta::Cextern& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Cextern.String  printfmt:Tuple
// func:dmmeta.Cextern..Print
void                 Cextern_Print(dmmeta::Cextern& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cfast
struct Cfast { // dmmeta.Cfast: FAST properties for ctype
    algo::Smallstr100   ctype;      //
    u32                 id;         //   0
    algo::Smallstr50    encoding;   //
    bool                reset;      //   false
    algo::Comment       comment;    //
    Cfast();
};

// func:dmmeta.Cfast..ReadFieldMaybe
bool                 Cfast_ReadFieldMaybe(dmmeta::Cfast& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cfast from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cfast..ReadStrptrMaybe
bool                 Cfast_ReadStrptrMaybe(dmmeta::Cfast &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Cfast..Init
void                 Cfast_Init(dmmeta::Cfast& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Cfast.String  printfmt:Tuple
// func:dmmeta.Cfast..Print
void                 Cfast_Print(dmmeta::Cfast& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cfmt
struct Cfmt { // dmmeta.Cfmt: Specify options for printing/reading ctypes into multiple formats
    algo::Smallstr100   cfmt;       //
    algo::Smallstr50    printfmt;   //
    bool                read;       //   false
    bool                print;      //   false
    algo::Smallstr20    sep;        //
    bool                genop;      //   false
    algo::Comment       comment;    //
    explicit Cfmt(const algo::strptr&            in_cfmt
        ,const algo::strptr&            in_printfmt
        ,bool                           in_read
        ,bool                           in_print
        ,const algo::strptr&            in_sep
        ,bool                           in_genop
        ,const algo::Comment&           in_comment);
    Cfmt();
};

// func:dmmeta.Cfmt.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Cfmt& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Cfmt.ctype.Get2
algo::Smallstr100    Cfmt_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Cfmt.strfmt.Get
algo::Smallstr50     strfmt_Get(dmmeta::Cfmt& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Cfmt.strfmt.Get2
algo::Smallstr50     Cfmt_strfmt_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Cfmt..Concat_ctype_strfmt
tempstr              Cfmt_Concat_ctype_strfmt( const algo::strptr& ctype ,const algo::strptr& strfmt );
// func:dmmeta.Cfmt..ReadFieldMaybe
bool                 Cfmt_ReadFieldMaybe(dmmeta::Cfmt& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cfmt from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cfmt..ReadStrptrMaybe
bool                 Cfmt_ReadStrptrMaybe(dmmeta::Cfmt &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Cfmt..Init
void                 Cfmt_Init(dmmeta::Cfmt& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Cfmt.String  printfmt:Tuple
// func:dmmeta.Cfmt..Print
void                 Cfmt_Print(dmmeta::Cfmt& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cget
struct Cget { // dmmeta.Cget: Generate state functions for these ctypes
    algo::Smallstr100   ctype;     //
    algo::Comment       comment;   //
    Cget();
};

// func:dmmeta.Cget..ReadFieldMaybe
bool                 Cget_ReadFieldMaybe(dmmeta::Cget& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cget from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cget..ReadStrptrMaybe
bool                 Cget_ReadStrptrMaybe(dmmeta::Cget &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Cget.String  printfmt:Tuple
// func:dmmeta.Cget..Print
void                 Cget_Print(dmmeta::Cget& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Charset
struct Charset { // dmmeta.Charset: Generate functions to determine if a character is a member of a set
    algo::Smallstr100   field;       //
    algo::Smallstr100   expr;        //
    bool                charrange;   //   false
    bool                calc;        //   false
    algo::Comment       comment;     //
    Charset();
};

// func:dmmeta.Charset..ReadFieldMaybe
bool                 Charset_ReadFieldMaybe(dmmeta::Charset& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Charset from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Charset..ReadStrptrMaybe
bool                 Charset_ReadStrptrMaybe(dmmeta::Charset &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Charset..Init
void                 Charset_Init(dmmeta::Charset& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Charset.String  printfmt:Tuple
// func:dmmeta.Charset..Print
void                 Charset_Print(dmmeta::Charset& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Chash
struct Chash { // dmmeta.Chash: Generate hash function
    algo::Smallstr100   ctype;      // Target ctype
    algo::Smallstr50    hashtype;   // Hash type
    algo::Comment       comment;    //
    explicit Chash(const algo::strptr&            in_ctype
        ,const algo::strptr&            in_hashtype
        ,const algo::Comment&           in_comment);
    Chash();
};

// func:dmmeta.Chash..ReadFieldMaybe
bool                 Chash_ReadFieldMaybe(dmmeta::Chash& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Chash from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Chash..ReadStrptrMaybe
bool                 Chash_ReadStrptrMaybe(dmmeta::Chash &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Chash.String  printfmt:Tuple
// func:dmmeta.Chash..Print
void                 Chash_Print(dmmeta::Chash& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cppfunc
struct Cppfunc { // dmmeta.Cppfunc: Value of field provided by this expression
    algo::Smallstr100   field;   //
    algo::CppExpr       expr;    //
    bool                print;   //   false
    bool                set;     //   false
    Cppfunc();
};

// func:dmmeta.Cppfunc..ReadFieldMaybe
bool                 Cppfunc_ReadFieldMaybe(dmmeta::Cppfunc& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cppfunc from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cppfunc..ReadStrptrMaybe
bool                 Cppfunc_ReadStrptrMaybe(dmmeta::Cppfunc &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Cppfunc..Init
void                 Cppfunc_Init(dmmeta::Cppfunc& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Cppfunc.String  printfmt:Tuple
// func:dmmeta.Cppfunc..Print
void                 Cppfunc_Print(dmmeta::Cppfunc& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cppkeyword
struct Cppkeyword { // dmmeta.Cppkeyword: Built-in C++ keyword
    algo::Smallstr20   cppkeyword;   //
    explicit Cppkeyword(const algo::strptr&            in_cppkeyword);
    Cppkeyword();
};

// func:dmmeta.Cppkeyword..ReadFieldMaybe
bool                 Cppkeyword_ReadFieldMaybe(dmmeta::Cppkeyword& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cppkeyword from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cppkeyword..ReadStrptrMaybe
bool                 Cppkeyword_ReadStrptrMaybe(dmmeta::Cppkeyword &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Cppkeyword.String  printfmt:Tuple
// func:dmmeta.Cppkeyword..Print
void                 Cppkeyword_Print(dmmeta::Cppkeyword& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cpptype
struct Cpptype { // dmmeta.Cpptype: Specify whether a ctype can be passed by value, and other c++ options
    algo::Smallstr100   ctype;        //
    bool                ctor;         //   false  if true, generate non-default constructor from all fields
    bool                dtor;         //   true  generate non-default destructor
    bool                cheap_copy;   //   false  Pass by value whenever possible
    explicit Cpptype(const algo::strptr&            in_ctype
        ,bool                           in_ctor
        ,bool                           in_dtor
        ,bool                           in_cheap_copy);
    Cpptype();
};

// func:dmmeta.Cpptype..ReadFieldMaybe
bool                 Cpptype_ReadFieldMaybe(dmmeta::Cpptype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cpptype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cpptype..ReadStrptrMaybe
bool                 Cpptype_ReadStrptrMaybe(dmmeta::Cpptype &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Cpptype..Init
void                 Cpptype_Init(dmmeta::Cpptype& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Cpptype.String  printfmt:Tuple
// func:dmmeta.Cpptype..Print
void                 Cpptype_Print(dmmeta::Cpptype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Csize
struct Csize { // dmmeta.Csize: Specify size/alignment for built-in C++ types
    algo::Smallstr100   ctype;       //
    u32                 size;        //   0
    u32                 alignment;   //   1
    algo::Comment       comment;     //
    explicit Csize(const algo::strptr&            in_ctype
        ,u32                            in_size
        ,u32                            in_alignment
        ,const algo::Comment&           in_comment);
    Csize();
};

// func:dmmeta.Csize..ReadFieldMaybe
bool                 Csize_ReadFieldMaybe(dmmeta::Csize& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Csize from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Csize..ReadStrptrMaybe
bool                 Csize_ReadStrptrMaybe(dmmeta::Csize &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Csize..Init
void                 Csize_Init(dmmeta::Csize& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Csize.String  printfmt:Tuple
// func:dmmeta.Csize..Print
void                 Csize_Print(dmmeta::Csize& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Cstr
struct Cstr { // dmmeta.Cstr: Specify that type behaves like a string
    algo::Smallstr100   ctype;      //
    bool                strequiv;   //   false  Use strptr instead of this type when possible
    algo::Comment       comment;    //
    Cstr();
};

// func:dmmeta.Cstr..ReadFieldMaybe
bool                 Cstr_ReadFieldMaybe(dmmeta::Cstr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cstr from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Cstr..ReadStrptrMaybe
bool                 Cstr_ReadStrptrMaybe(dmmeta::Cstr &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Cstr..Init
void                 Cstr_Init(dmmeta::Cstr& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Cstr.String  printfmt:Tuple
// func:dmmeta.Cstr..Print
void                 Cstr_Print(dmmeta::Cstr& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ctype
struct Ctype { // dmmeta.Ctype: Struct
    algo::Smallstr100   ctype;     // Identifier. must be ns.typename
    algo::Comment       comment;   //
    explicit Ctype(const algo::strptr&            in_ctype
        ,const algo::Comment&           in_comment);
    Ctype();
};

// func:dmmeta.Ctype.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Ctype& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ctype.ns.Get2
algo::Smallstr16     Ctype_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ctype.name.Get
algo::Smallstr100    name_Get(dmmeta::Ctype& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ctype.name.Get2
algo::Smallstr100    Ctype_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ctype..Concat_ns_name
tempstr              Ctype_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
// func:dmmeta.Ctype..ReadFieldMaybe
bool                 Ctype_ReadFieldMaybe(dmmeta::Ctype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ctype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ctype..ReadStrptrMaybe
bool                 Ctype_ReadStrptrMaybe(dmmeta::Ctype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ctype.String  printfmt:Tuple
// func:dmmeta.Ctype..Print
void                 Ctype_Print(dmmeta::Ctype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ctypelen
struct Ctypelen { // dmmeta.Ctypelen: Size of Ctype
    algo::Smallstr100   ctype;       // Identifies the Ctype
    u32                 len;         //   0
    i32                 alignment;   //   0
    i32                 padbytes;    //   0
    explicit Ctypelen(const algo::strptr&            in_ctype
        ,u32                            in_len
        ,i32                            in_alignment
        ,i32                            in_padbytes);
    Ctypelen();
};

// func:dmmeta.Ctypelen..ReadFieldMaybe
bool                 Ctypelen_ReadFieldMaybe(dmmeta::Ctypelen& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ctypelen from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ctypelen..ReadStrptrMaybe
bool                 Ctypelen_ReadStrptrMaybe(dmmeta::Ctypelen &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Ctypelen..Init
void                 Ctypelen_Init(dmmeta::Ctypelen& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Ctypelen.String  printfmt:Tuple
// func:dmmeta.Ctypelen..Print
void                 Ctypelen_Print(dmmeta::Ctypelen& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Dispatch
struct Dispatch { // dmmeta.Dispatch: Generate code for a multi-way branch
    algo::Smallstr50   dispatch;   // Primary key (ns.name)
    bool               unk;        //   false  Want default case?
    bool               read;       //   false  Generate read function
    bool               print;      //   false  Generate print function
    bool               haslen;     //   false  Include length in dispatch function
    bool               call;       //   false  Generate call to user-defined function
    bool               strict;     //   false  Only dispatch if length matches exactly
    algo::Comment      comment;    //
    explicit Dispatch(const algo::strptr&            in_dispatch
        ,bool                           in_unk
        ,bool                           in_read
        ,bool                           in_print
        ,bool                           in_haslen
        ,bool                           in_call
        ,bool                           in_strict
        ,const algo::Comment&           in_comment);
    Dispatch();
};

// func:dmmeta.Dispatch.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Dispatch& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Dispatch.ns.Get2
algo::Smallstr16     Dispatch_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Dispatch.name.Get
algo::Smallstr50     name_Get(dmmeta::Dispatch& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Dispatch.name.Get2
algo::Smallstr50     Dispatch_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Dispatch..Concat_ns_name
tempstr              Dispatch_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
// func:dmmeta.Dispatch..ReadFieldMaybe
bool                 Dispatch_ReadFieldMaybe(dmmeta::Dispatch& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispatch from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Dispatch..ReadStrptrMaybe
bool                 Dispatch_ReadStrptrMaybe(dmmeta::Dispatch &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Dispatch..Init
void                 Dispatch_Init(dmmeta::Dispatch& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispatch.String  printfmt:Tuple
// func:dmmeta.Dispatch..Print
void                 Dispatch_Print(dmmeta::Dispatch& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.DispatchMsg
struct DispatchMsg { // dmmeta.DispatchMsg: Add message to a dispatch
    algo::Smallstr100   dispatch_msg;   //
    algo::Comment       comment;        //
    explicit DispatchMsg(const algo::strptr&            in_dispatch_msg
        ,const algo::Comment&           in_comment);
    DispatchMsg();
};

// func:dmmeta.DispatchMsg.dispatch.Get
algo::Smallstr50     dispatch_Get(dmmeta::DispatchMsg& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.DispatchMsg.dispatch.Get2
algo::Smallstr50     DispatchMsg_dispatch_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.DispatchMsg.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::DispatchMsg& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.DispatchMsg.ctype.Get2
algo::Smallstr100    DispatchMsg_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.DispatchMsg..Concat_dispatch_ctype
tempstr              DispatchMsg_Concat_dispatch_ctype( const algo::strptr& dispatch ,const algo::strptr& ctype );
// func:dmmeta.DispatchMsg..ReadFieldMaybe
bool                 DispatchMsg_ReadFieldMaybe(dmmeta::DispatchMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::DispatchMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.DispatchMsg..ReadStrptrMaybe
bool                 DispatchMsg_ReadStrptrMaybe(dmmeta::DispatchMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.DispatchMsg.String  printfmt:Tuple
// func:dmmeta.DispatchMsg..Print
void                 DispatchMsg_Print(dmmeta::DispatchMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Dispctx
struct Dispctx { // dmmeta.Dispctx: Use context with dispatch
    algo::Smallstr50    dispatch;   //
    algo::Smallstr100   ctype;      //
    algo::Comment       comment;    //
    Dispctx();
};

// func:dmmeta.Dispctx..ReadFieldMaybe
bool                 Dispctx_ReadFieldMaybe(dmmeta::Dispctx& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispctx from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Dispctx..ReadStrptrMaybe
bool                 Dispctx_ReadStrptrMaybe(dmmeta::Dispctx &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispctx.String  printfmt:Tuple
// func:dmmeta.Dispctx..Print
void                 Dispctx_Print(dmmeta::Dispctx& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Dispfilter
struct Dispfilter { // dmmeta.Dispfilter: Generate filter function on dispatch
    algo::Smallstr50   dispatch;    //
    bool               match_all;   //   false
    algo::Comment      comment;     //
    Dispfilter();
};

// func:dmmeta.Dispfilter..ReadFieldMaybe
bool                 Dispfilter_ReadFieldMaybe(dmmeta::Dispfilter& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispfilter from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Dispfilter..ReadStrptrMaybe
bool                 Dispfilter_ReadStrptrMaybe(dmmeta::Dispfilter &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Dispfilter..Init
void                 Dispfilter_Init(dmmeta::Dispfilter& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispfilter.String  printfmt:Tuple
// func:dmmeta.Dispfilter..Print
void                 Dispfilter_Print(dmmeta::Dispfilter& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Dispsig
struct Dispsig { // dmmeta.Dispsig: Cryptographic signature of all dispatches
    algo::Smallstr50   dispsig;     //
    algo::Sha1sig      signature;   //
    Dispsig();
};

// func:dmmeta.Dispsig.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Dispsig& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Dispsig.ns.Get2
algo::Smallstr16     Dispsig_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Dispsig.name.Get
algo::Smallstr50     name_Get(dmmeta::Dispsig& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Dispsig.name.Get2
algo::Smallstr50     Dispsig_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Dispsig..Concat_ns_name
tempstr              Dispsig_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
// func:dmmeta.Dispsig..ReadFieldMaybe
bool                 Dispsig_ReadFieldMaybe(dmmeta::Dispsig& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispsig from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Dispsig..ReadStrptrMaybe
bool                 Dispsig_ReadStrptrMaybe(dmmeta::Dispsig &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispsig.String  printfmt:Tuple
// func:dmmeta.Dispsig..Print
void                 Dispsig_Print(dmmeta::Dispsig& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Dispsigcheck
struct Dispsigcheck { // dmmeta.Dispsigcheck: Check signature of input data against executable's version
    algo::Smallstr50   dispsig;     //
    algo::Sha1sig      signature;   //
    explicit Dispsigcheck(const algo::strptr&            in_dispsig
        ,const algo::Sha1sig&           in_signature);
    Dispsigcheck();
};

// func:dmmeta.Dispsigcheck..ReadFieldMaybe
bool                 Dispsigcheck_ReadFieldMaybe(dmmeta::Dispsigcheck& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispsigcheck from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Dispsigcheck..ReadStrptrMaybe
bool                 Dispsigcheck_ReadStrptrMaybe(dmmeta::Dispsigcheck &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Dispsigcheck.String  printfmt:Tuple
// func:dmmeta.Dispsigcheck..Print
void                 Dispsigcheck_Print(dmmeta::Dispsigcheck& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Disptrace
struct Disptrace { // dmmeta.Disptrace: Generate trace fields (cycles, counts) for all dispatch branches
    algo::Smallstr50   dispatch;   //
    bool               cycle;      //   false
    algo::Comment      comment;    //
    Disptrace();
};

// func:dmmeta.Disptrace..ReadFieldMaybe
bool                 Disptrace_ReadFieldMaybe(dmmeta::Disptrace& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Disptrace from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Disptrace..ReadStrptrMaybe
bool                 Disptrace_ReadStrptrMaybe(dmmeta::Disptrace &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Disptrace..Init
void                 Disptrace_Init(dmmeta::Disptrace& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Disptrace.String  printfmt:Tuple
// func:dmmeta.Disptrace..Print
void                 Disptrace_Print(dmmeta::Disptrace& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Falias
struct Falias { // dmmeta.Falias: Alias field
    algo::Smallstr100   field;      //
    algo::Smallstr100   srcfield;   //
    algo::Comment       comment;    //
    Falias();
};

// func:dmmeta.Falias..ReadFieldMaybe
bool                 Falias_ReadFieldMaybe(dmmeta::Falias& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Falias from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Falias..ReadStrptrMaybe
bool                 Falias_ReadStrptrMaybe(dmmeta::Falias &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Falias.String  printfmt:Tuple
// func:dmmeta.Falias..Print
void                 Falias_Print(dmmeta::Falias& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fastenc
struct Fastenc { // dmmeta.Fastenc
    algo::Smallstr50   fastenc;   //
    algo::Comment      comment;   //
    Fastenc();
};

// func:dmmeta.Fastenc..ReadFieldMaybe
bool                 Fastenc_ReadFieldMaybe(dmmeta::Fastenc& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fastenc from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fastenc..ReadStrptrMaybe
bool                 Fastenc_ReadStrptrMaybe(dmmeta::Fastenc &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fastenc.String  printfmt:Tuple
// func:dmmeta.Fastenc..Print
void                 Fastenc_Print(dmmeta::Fastenc& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.FastencCase
#pragma pack(push,1)
struct FastencCase { // dmmeta.FastencCase: enum helper 
    u8   fastenc;   //   0
    inline operator dmmeta_FastencCaseEnum() const;
    explicit FastencCase(u8                             in_fastenc);
    FastencCase(dmmeta_FastencCaseEnum arg);
    FastencCase();
};
#pragma pack(pop)

// Get value of field as enum type
// func:dmmeta.FastencCase.fastenc.GetEnum
dmmeta_FastencCaseEnum fastenc_GetEnum(const dmmeta::FastencCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:dmmeta.FastencCase.fastenc.SetEnum
void                 fastenc_SetEnum(dmmeta::FastencCase& parent, dmmeta_FastencCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:dmmeta.FastencCase.fastenc.ToCstr
const char*          fastenc_ToCstr(const dmmeta::FastencCase& parent) __attribute__((nothrow));
// Convert fastenc to a string. First, attempt conversion to a known string.
// If no string matches, print fastenc as a numeric value.
// func:dmmeta.FastencCase.fastenc.Print
void                 fastenc_Print(const dmmeta::FastencCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:dmmeta.FastencCase.fastenc.SetStrptrMaybe
bool                 fastenc_SetStrptrMaybe(dmmeta::FastencCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:dmmeta.FastencCase.fastenc.SetStrptr
void                 fastenc_SetStrptr(dmmeta::FastencCase& parent, algo::strptr rhs, dmmeta_FastencCaseEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
// func:dmmeta.FastencCase..Init
void                 FastencCase_Init(dmmeta::FastencCase& parent);

// --- dmmeta.Fastinstr
struct Fastinstr { // dmmeta.Fastinstr
    algo::Smallstr50   fastinstr;   //
    algo::Comment      comment;     //
    Fastinstr();
};

// func:dmmeta.Fastinstr..ReadFieldMaybe
bool                 Fastinstr_ReadFieldMaybe(dmmeta::Fastinstr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fastinstr from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fastinstr..ReadStrptrMaybe
bool                 Fastinstr_ReadStrptrMaybe(dmmeta::Fastinstr &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fastinstr.String  printfmt:Tuple
// func:dmmeta.Fastinstr..Print
void                 Fastinstr_Print(dmmeta::Fastinstr& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.FastinstrCase
#pragma pack(push,1)
struct FastinstrCase { // dmmeta.FastinstrCase: enum helper 
    u8   fastinstr;   //   0
    inline operator dmmeta_FastinstrCaseEnum() const;
    explicit FastinstrCase(u8                             in_fastinstr);
    FastinstrCase(dmmeta_FastinstrCaseEnum arg);
    FastinstrCase();
};
#pragma pack(pop)

// Get value of field as enum type
// func:dmmeta.FastinstrCase.fastinstr.GetEnum
dmmeta_FastinstrCaseEnum fastinstr_GetEnum(const dmmeta::FastinstrCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:dmmeta.FastinstrCase.fastinstr.SetEnum
void                 fastinstr_SetEnum(dmmeta::FastinstrCase& parent, dmmeta_FastinstrCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:dmmeta.FastinstrCase.fastinstr.ToCstr
const char*          fastinstr_ToCstr(const dmmeta::FastinstrCase& parent) __attribute__((nothrow));
// Convert fastinstr to a string. First, attempt conversion to a known string.
// If no string matches, print fastinstr as a numeric value.
// func:dmmeta.FastinstrCase.fastinstr.Print
void                 fastinstr_Print(const dmmeta::FastinstrCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:dmmeta.FastinstrCase.fastinstr.SetStrptrMaybe
bool                 fastinstr_SetStrptrMaybe(dmmeta::FastinstrCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:dmmeta.FastinstrCase.fastinstr.SetStrptr
void                 fastinstr_SetStrptr(dmmeta::FastinstrCase& parent, algo::strptr rhs, dmmeta_FastinstrCaseEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
// func:dmmeta.FastinstrCase..Init
void                 FastinstrCase_Init(dmmeta::FastinstrCase& parent);

// --- dmmeta.Fastop
struct Fastop { // dmmeta.Fastop
    algo::Smallstr50   fastop;    //
    algo::Comment      comment;   //
    Fastop();
};

// func:dmmeta.Fastop..ReadFieldMaybe
bool                 Fastop_ReadFieldMaybe(dmmeta::Fastop& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fastop from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fastop..ReadStrptrMaybe
bool                 Fastop_ReadStrptrMaybe(dmmeta::Fastop &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fastop.String  printfmt:Tuple
// func:dmmeta.Fastop..Print
void                 Fastop_Print(dmmeta::Fastop& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.FastopCase
#pragma pack(push,1)
struct FastopCase { // dmmeta.FastopCase: enum helper 
    u8   fastop;   //   0
    inline operator dmmeta_FastopCaseEnum() const;
    explicit FastopCase(u8                             in_fastop);
    FastopCase(dmmeta_FastopCaseEnum arg);
    FastopCase();
};
#pragma pack(pop)

// Get value of field as enum type
// func:dmmeta.FastopCase.fastop.GetEnum
dmmeta_FastopCaseEnum fastop_GetEnum(const dmmeta::FastopCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:dmmeta.FastopCase.fastop.SetEnum
void                 fastop_SetEnum(dmmeta::FastopCase& parent, dmmeta_FastopCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:dmmeta.FastopCase.fastop.ToCstr
const char*          fastop_ToCstr(const dmmeta::FastopCase& parent) __attribute__((nothrow));
// Convert fastop to a string. First, attempt conversion to a known string.
// If no string matches, print fastop as a numeric value.
// func:dmmeta.FastopCase.fastop.Print
void                 fastop_Print(const dmmeta::FastopCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:dmmeta.FastopCase.fastop.SetStrptrMaybe
bool                 fastop_SetStrptrMaybe(dmmeta::FastopCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:dmmeta.FastopCase.fastop.SetStrptr
void                 fastop_SetStrptr(dmmeta::FastopCase& parent, algo::strptr rhs, dmmeta_FastopCaseEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
// func:dmmeta.FastopCase..Init
void                 FastopCase_Init(dmmeta::FastopCase& parent);

// --- dmmeta.Fbase
struct Fbase { // dmmeta.Fbase: Customize imported Base fields
    algo::Smallstr100   field;          //
    bool                stripcomment;   //   false
    algo::Comment       comment;        //
    Fbase();
};

// func:dmmeta.Fbase..ReadFieldMaybe
bool                 Fbase_ReadFieldMaybe(dmmeta::Fbase& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbase from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fbase..ReadStrptrMaybe
bool                 Fbase_ReadStrptrMaybe(dmmeta::Fbase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fbase..Init
void                 Fbase_Init(dmmeta::Fbase& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbase.String  printfmt:Tuple
// func:dmmeta.Fbase..Print
void                 Fbase_Print(dmmeta::Fbase& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fbigend
struct Fbigend { // dmmeta.Fbigend: Annotate field as having big-endian storage
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fbigend();
};

// func:dmmeta.Fbigend..ReadFieldMaybe
bool                 Fbigend_ReadFieldMaybe(dmmeta::Fbigend& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbigend from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fbigend..ReadStrptrMaybe
bool                 Fbigend_ReadStrptrMaybe(dmmeta::Fbigend &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbigend.String  printfmt:Tuple
// func:dmmeta.Fbigend..Print
void                 Fbigend_Print(dmmeta::Fbigend& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fbitset
struct Fbitset { // dmmeta.Fbitset: Generate bitset functions over integer field or array
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Fbitset(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Fbitset();
};

// func:dmmeta.Fbitset..ReadFieldMaybe
bool                 Fbitset_ReadFieldMaybe(dmmeta::Fbitset& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbitset from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fbitset..ReadStrptrMaybe
bool                 Fbitset_ReadStrptrMaybe(dmmeta::Fbitset &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbitset.String  printfmt:Tuple
// func:dmmeta.Fbitset..Print
void                 Fbitset_Print(dmmeta::Fbitset& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fbuf
struct Fbuf { // dmmeta.Fbuf: Buffer for reading/writing messages, works with Iohook
    algo::Smallstr100   field;      //
    u32                 max;        //   0  Size of buffer in bytes
    algo::Smallstr50    fbuftype;   // Type of buffer
    algo::Smallstr100   insready;   //
    algo::Smallstr100   inseof;     //
    algo::Comment       comment;    //
    Fbuf();
};

// func:dmmeta.Fbuf.fbufdir.Get
algo::Smallstr50     fbufdir_Get(dmmeta::Fbuf& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fbuf.fbufdir.Get2
algo::Smallstr50     Fbuf_fbufdir_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fbuf..ReadFieldMaybe
bool                 Fbuf_ReadFieldMaybe(dmmeta::Fbuf& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbuf from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fbuf..ReadStrptrMaybe
bool                 Fbuf_ReadStrptrMaybe(dmmeta::Fbuf &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fbuf..Init
void                 Fbuf_Init(dmmeta::Fbuf& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbuf.String  printfmt:Tuple
// func:dmmeta.Fbuf..Print
void                 Fbuf_Print(dmmeta::Fbuf& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fbufdir
struct Fbufdir { // dmmeta.Fbufdir: Buffer direction (in,out)
    algo::Smallstr50   fbufdir;   //
    bool               read;      //   false
    algo::Comment      comment;   //
    Fbufdir();
};

// func:dmmeta.Fbufdir..ReadFieldMaybe
bool                 Fbufdir_ReadFieldMaybe(dmmeta::Fbufdir& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbufdir from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fbufdir..ReadStrptrMaybe
bool                 Fbufdir_ReadStrptrMaybe(dmmeta::Fbufdir &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fbufdir..Init
void                 Fbufdir_Init(dmmeta::Fbufdir& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbufdir.String  printfmt:Tuple
// func:dmmeta.Fbufdir..Print
void                 Fbufdir_Print(dmmeta::Fbufdir& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fbuftype
struct Fbuftype { // dmmeta.Fbuftype: Buffer type
    algo::Smallstr50   fbuftype;    //
    bool               getmsg;      //   false  Has getmsg function?
    bool               skipbytes;   //   false  Has skipbytes function?
    bool               read;        //   false
    algo::Comment      comment;     //
    Fbuftype();
};

// func:dmmeta.Fbuftype..ReadFieldMaybe
bool                 Fbuftype_ReadFieldMaybe(dmmeta::Fbuftype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbuftype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fbuftype..ReadStrptrMaybe
bool                 Fbuftype_ReadStrptrMaybe(dmmeta::Fbuftype &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fbuftype..Init
void                 Fbuftype_Init(dmmeta::Fbuftype& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fbuftype.String  printfmt:Tuple
// func:dmmeta.Fbuftype..Print
void                 Fbuftype_Print(dmmeta::Fbuftype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcast
struct Fcast { // dmmeta.Fcast: Generate implicit conversion from field to c++ expression
    algo::Smallstr100   field;     //
    algo::Smallstr100   expr;      //
    algo::Comment       comment;   //
    explicit Fcast(const algo::strptr&            in_field
        ,const algo::strptr&            in_expr
        ,const algo::Comment&           in_comment);
    Fcast();
};

// func:dmmeta.Fcast..ReadFieldMaybe
bool                 Fcast_ReadFieldMaybe(dmmeta::Fcast& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcast from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcast..ReadStrptrMaybe
bool                 Fcast_ReadStrptrMaybe(dmmeta::Fcast &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcast.String  printfmt:Tuple
// func:dmmeta.Fcast..Print
void                 Fcast_Print(dmmeta::Fcast& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcleanup
struct Fcleanup { // dmmeta.Fcleanup: Request user-implemented function to be called at Uninit time for a field
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fcleanup();
};

// func:dmmeta.Fcleanup..ReadFieldMaybe
bool                 Fcleanup_ReadFieldMaybe(dmmeta::Fcleanup& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcleanup from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcleanup..ReadStrptrMaybe
bool                 Fcleanup_ReadStrptrMaybe(dmmeta::Fcleanup &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcleanup.String  printfmt:Tuple
// func:dmmeta.Fcleanup..Print
void                 Fcleanup_Print(dmmeta::Fcleanup& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcmap
struct Fcmap { // dmmeta.Fcmap: Bidirectional mapping between fconst values
    algo::Smallstr250   fcmap;     // cstring maybe?
    bool                bidir;     //   true
    algo::Comment       comment;   //
    Fcmap();
};

// func:dmmeta.Fcmap.leftField.Get
algo::Smallstr100    leftField_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcmap.leftField.Get2
algo::Smallstr100    Fcmap_leftField_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcmap.leftVal.Get
algo::Smallstr40     leftVal_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcmap.leftVal.Get2
algo::Smallstr40     Fcmap_leftVal_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcmap.rightVal.Get
algo::Smallstr40     rightVal_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcmap.rightVal.Get2
algo::Smallstr40     Fcmap_rightVal_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcmap.rightField.Get
algo::Smallstr100    rightField_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcmap.rightField.Get2
algo::Smallstr100    Fcmap_rightField_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcmap..Concat_leftField_leftVal_rightField_rightVal
tempstr              Fcmap_Concat_leftField_leftVal_rightField_rightVal( const algo::strptr& leftField ,const algo::strptr& leftVal ,const algo::strptr& rightField ,const algo::strptr& rightVal );
// func:dmmeta.Fcmap..ReadFieldMaybe
bool                 Fcmap_ReadFieldMaybe(dmmeta::Fcmap& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmap from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcmap..ReadStrptrMaybe
bool                 Fcmap_ReadStrptrMaybe(dmmeta::Fcmap &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fcmap..Init
void                 Fcmap_Init(dmmeta::Fcmap& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcmap.String  printfmt:Tuple
// func:dmmeta.Fcmap..Print
void                 Fcmap_Print(dmmeta::Fcmap& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcmdline
struct Fcmdline { // dmmeta.Fcmdline: Annotate field that holds process command line
    algo::Smallstr100   field;         // Parent field
    bool                read;          //   true  Read the command line automatically from main?
    algo::Smallstr100   basecmdline;   // Optional command line to merge with this one
    algo::Comment       comment;       //
    Fcmdline();
};

// func:dmmeta.Fcmdline.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Fcmdline& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcmdline.ns.Get2
algo::Smallstr16     Fcmdline_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcmdline..ReadFieldMaybe
bool                 Fcmdline_ReadFieldMaybe(dmmeta::Fcmdline& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmdline from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcmdline..ReadStrptrMaybe
bool                 Fcmdline_ReadStrptrMaybe(dmmeta::Fcmdline &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fcmdline..Init
void                 Fcmdline_Init(dmmeta::Fcmdline& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcmdline.String  printfmt:Tuple
// func:dmmeta.Fcmdline..Print
void                 Fcmdline_Print(dmmeta::Fcmdline& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcmp
struct Fcmp { // dmmeta.Fcmp: Request versionsort or case-insensitive sort for field
    algo::Smallstr100   field;         // Target field
    bool                versionsort;   //   false  Use version sort (detect embedded integers in string)
    bool                casesens;      //   true  Comparison is case-sensitive
    bool                extrn;         //   false  Whether implementation is external
    algo::Comment       comment;       //
    explicit Fcmp(const algo::strptr&            in_field
        ,bool                           in_versionsort
        ,bool                           in_casesens
        ,bool                           in_extrn
        ,const algo::Comment&           in_comment);
    Fcmp();
};

// func:dmmeta.Fcmp..ReadFieldMaybe
bool                 Fcmp_ReadFieldMaybe(dmmeta::Fcmp& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmp from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcmp..ReadStrptrMaybe
bool                 Fcmp_ReadStrptrMaybe(dmmeta::Fcmp &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fcmp..Init
void                 Fcmp_Init(dmmeta::Fcmp& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcmp.String  printfmt:Tuple
// func:dmmeta.Fcmp..Print
void                 Fcmp_Print(dmmeta::Fcmp& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcompact
struct Fcompact { // dmmeta.Fcompact: Request compaction upon removal from index
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fcompact();
};

// func:dmmeta.Fcompact..ReadFieldMaybe
bool                 Fcompact_ReadFieldMaybe(dmmeta::Fcompact& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcompact from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcompact..ReadStrptrMaybe
bool                 Fcompact_ReadStrptrMaybe(dmmeta::Fcompact &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcompact.String  printfmt:Tuple
// func:dmmeta.Fcompact..Print
void                 Fcompact_Print(dmmeta::Fcompact& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fconst
struct Fconst { // dmmeta.Fconst: Specify enum value (integer + string constant) for a field
    algo::Smallstr100   fconst;    //
    algo::CppExpr       value;     //
    inline operator algo::CppExpr() const;
    algo::Comment       comment;   //
    explicit Fconst(const algo::strptr&            in_fconst
        ,const algo::CppExpr&           in_value
        ,const algo::Comment&           in_comment);
    Fconst();
};

// func:dmmeta.Fconst.field.Get
algo::Smallstr100    field_Get(dmmeta::Fconst& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fconst.field.Get2
algo::Smallstr100    Fconst_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fconst.name.Get
algo::Smallstr100    name_Get(dmmeta::Fconst& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fconst.name.Get2
algo::Smallstr100    Fconst_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fconst..Concat_field_name
tempstr              Fconst_Concat_field_name( const algo::strptr& field ,const algo::strptr& name );
// func:dmmeta.Fconst..ReadFieldMaybe
bool                 Fconst_ReadFieldMaybe(dmmeta::Fconst& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fconst from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fconst..ReadStrptrMaybe
bool                 Fconst_ReadStrptrMaybe(dmmeta::Fconst &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fconst.String  printfmt:Tuple
// func:dmmeta.Fconst..Print
void                 Fconst_Print(dmmeta::Fconst& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fcurs
struct Fcurs { // dmmeta.Fcurs: Request generation of custom cursor
    algo::Smallstr50   fcurs;     //
    algo::Comment      comment;   //
    Fcurs();
};

// func:dmmeta.Fcurs.field.Get
algo::Smallstr100    field_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcurs.field.Get2
algo::Smallstr100    Fcurs_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcurs.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcurs.ctype.Get2
algo::Smallstr100    Fcurs_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcurs.curstype.Get
algo::Smallstr50     curstype_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fcurs.curstype.Get2
algo::Smallstr50     Fcurs_curstype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fcurs..Concat_field_curstype
tempstr              Fcurs_Concat_field_curstype( const algo::strptr& field ,const algo::strptr& curstype );
// func:dmmeta.Fcurs..ReadFieldMaybe
bool                 Fcurs_ReadFieldMaybe(dmmeta::Fcurs& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcurs from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fcurs..ReadStrptrMaybe
bool                 Fcurs_ReadStrptrMaybe(dmmeta::Fcurs &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fcurs.String  printfmt:Tuple
// func:dmmeta.Fcurs..Print
void                 Fcurs_Print(dmmeta::Fcurs& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fdec
struct Fdec { // dmmeta.Fdec: Specify that field has an implied # of decimal places and specify formatting options
    algo::Smallstr100   field;      // Target field
    i32                 nplace;     //   0  Number of implied decimal places
    bool                fixedfmt;   //   false  Print exactly SCALE chars after decimal point
    algo::Comment       comment;    //
    Fdec();
};

// func:dmmeta.Fdec..ReadFieldMaybe
bool                 Fdec_ReadFieldMaybe(dmmeta::Fdec& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fdec from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fdec..ReadStrptrMaybe
bool                 Fdec_ReadStrptrMaybe(dmmeta::Fdec &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fdec..Init
void                 Fdec_Init(dmmeta::Fdec& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fdec.String  printfmt:Tuple
// func:dmmeta.Fdec..Print
void                 Fdec_Print(dmmeta::Fdec& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fdelay
struct Fdelay { // dmmeta.Fdelay: Control elapsed time between execution of a step
    algo::Smallstr100   fstep;     //
    algo::I64Dec9       delay;     // Delay between steps in seconds
    bool                scale;     //   false  Does delay apply to the whole list?
    algo::Comment       comment;   //
    Fdelay();
};

// func:dmmeta.Fdelay..ReadFieldMaybe
bool                 Fdelay_ReadFieldMaybe(dmmeta::Fdelay& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fdelay from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fdelay..ReadStrptrMaybe
bool                 Fdelay_ReadStrptrMaybe(dmmeta::Fdelay &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fdelay..Init
void                 Fdelay_Init(dmmeta::Fdelay& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fdelay.String  printfmt:Tuple
// func:dmmeta.Fdelay..Print
void                 Fdelay_Print(dmmeta::Fdelay& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ffast
struct Ffast { // dmmeta.Ffast: FAST properties for field
    algo::Smallstr100   ffast;      //
    algo::Smallstr50    name;       //
    u32                 id;         //   0
    u32                 pos;        //   0
    bool                optional;   //   false
    algo::Smallstr50    encoding;   //
    algo::Smallstr50    op;         //
    algo::CppExpr       value;      //
    algo::Comment       comment;    //
    Ffast();
};

// func:dmmeta.Ffast.field.Get
algo::Smallstr100    field_Get(dmmeta::Ffast& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ffast.field.Get2
algo::Smallstr100    Ffast_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ffast.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Ffast& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ffast.ctype.Get2
algo::Smallstr100    Ffast_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ffast.fastinstr.Get
algo::Smallstr50     fastinstr_Get(dmmeta::Ffast& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ffast.fastinstr.Get2
algo::Smallstr50     Ffast_fastinstr_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ffast..Concat_field_fastinstr
tempstr              Ffast_Concat_field_fastinstr( const algo::strptr& field ,const algo::strptr& fastinstr );
// func:dmmeta.Ffast..ReadFieldMaybe
bool                 Ffast_ReadFieldMaybe(dmmeta::Ffast& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ffast from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ffast..ReadStrptrMaybe
bool                 Ffast_ReadStrptrMaybe(dmmeta::Ffast &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Ffast..Init
void                 Ffast_Init(dmmeta::Ffast& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Ffast.String  printfmt:Tuple
// func:dmmeta.Ffast..Print
void                 Ffast_Print(dmmeta::Ffast& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fflag
struct Fflag { // dmmeta.Fflag: Options for command-line flags
    algo::Smallstr100   field;        //
    bool                cumulative;   //   false  Accumulate on every read
    algo::cstring       emptyval;     //   ""
    algo::Comment       comment;      //
    Fflag();
};

// func:dmmeta.Fflag..ReadFieldMaybe
bool                 Fflag_ReadFieldMaybe(dmmeta::Fflag& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fflag from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fflag..ReadStrptrMaybe
bool                 Fflag_ReadStrptrMaybe(dmmeta::Fflag &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fflag..Init
void                 Fflag_Init(dmmeta::Fflag& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fflag.String  printfmt:Tuple
// func:dmmeta.Fflag..Print
void                 Fflag_Print(dmmeta::Fflag& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Field
struct Field { // dmmeta.Field: Specify field of a struct
    algo::Smallstr100   field;     // Primary key, as ctype.name
    algo::Smallstr100   arg;       // Type of field
    algo::Smallstr50    reftype;   //   "Val"  Type constructor
    algo::CppExpr       dflt;      // Default value (c++ expression)
    algo::Comment       comment;   //
    explicit Field(const algo::strptr&            in_field
        ,const algo::strptr&            in_arg
        ,const algo::strptr&            in_reftype
        ,const algo::CppExpr&           in_dflt
        ,const algo::Comment&           in_comment);
    Field();
};

// func:dmmeta.Field.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Field.ctype.Get2
algo::Smallstr100    Field_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Field.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Field.ns.Get2
algo::Smallstr16     Field_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Field.name.Get
algo::Smallstr50     name_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Field.name.Get2
algo::Smallstr50     Field_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Field..Concat_ctype_name
tempstr              Field_Concat_ctype_name( const algo::strptr& ctype ,const algo::strptr& name );
// func:dmmeta.Field..ReadFieldMaybe
bool                 Field_ReadFieldMaybe(dmmeta::Field& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Field from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Field..ReadStrptrMaybe
bool                 Field_ReadStrptrMaybe(dmmeta::Field &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Field..Init
void                 Field_Init(dmmeta::Field& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Field.String  printfmt:Tuple
// func:dmmeta.Field..Print
void                 Field_Print(dmmeta::Field& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.FieldId
#pragma pack(push,1)
struct FieldId { // dmmeta.FieldId: Field read helper
    i32   value;   //   -1
    inline operator dmmeta_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(dmmeta_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
// func:dmmeta.FieldId.value.GetEnum
dmmeta_FieldIdEnum   value_GetEnum(const dmmeta::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:dmmeta.FieldId.value.SetEnum
void                 value_SetEnum(dmmeta::FieldId& parent, dmmeta_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:dmmeta.FieldId.value.ToCstr
const char*          value_ToCstr(const dmmeta::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:dmmeta.FieldId.value.Print
void                 value_Print(const dmmeta::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:dmmeta.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:dmmeta.FieldId.value.SetStrptr
void                 value_SetStrptr(dmmeta::FieldId& parent, algo::strptr rhs, dmmeta_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:dmmeta.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of dmmeta::FieldId from an ascii string.
// The format of the string is the format of the dmmeta::FieldId's only field
// func:dmmeta.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(dmmeta::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.FieldId..Init
void                 FieldId_Init(dmmeta::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.FieldId.String  printfmt:Raw
// func:dmmeta.FieldId..Print
void                 FieldId_Print(dmmeta::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Findrem
struct Findrem { // dmmeta.Findrem: Request generation of FindRemove function
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Findrem();
};

// func:dmmeta.Findrem..ReadFieldMaybe
bool                 Findrem_ReadFieldMaybe(dmmeta::Findrem& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Findrem from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Findrem..ReadStrptrMaybe
bool                 Findrem_ReadStrptrMaybe(dmmeta::Findrem &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Findrem.String  printfmt:Tuple
// func:dmmeta.Findrem..Print
void                 Findrem_Print(dmmeta::Findrem& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Finput
struct Finput { // dmmeta.Finput: Describe input table of a program
    algo::Smallstr100   field;     // Target field to read
    bool                extrn;     //   false  Call user-provided function
    bool                update;    //   false
    bool                strict;    //   true  Exist process if record contains error
    algo::Comment       comment;   //
    explicit Finput(const algo::strptr&            in_field
        ,bool                           in_extrn
        ,bool                           in_update
        ,bool                           in_strict
        ,const algo::Comment&           in_comment);
    Finput();
};

// func:dmmeta.Finput.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Finput& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Finput.ns.Get2
algo::Smallstr16     Finput_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Finput..ReadFieldMaybe
bool                 Finput_ReadFieldMaybe(dmmeta::Finput& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Finput from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Finput..ReadStrptrMaybe
bool                 Finput_ReadStrptrMaybe(dmmeta::Finput &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Finput..Init
void                 Finput_Init(dmmeta::Finput& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Finput.String  printfmt:Tuple
// func:dmmeta.Finput..Print
void                 Finput_Print(dmmeta::Finput& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fldoffset
struct Fldoffset { // dmmeta.Fldoffset: Assert field offset - will result in compile-time error if violated
    algo::Smallstr100   field;    //
    i32                 offset;   //   0
    explicit Fldoffset(const algo::strptr&            in_field
        ,i32                            in_offset);
    Fldoffset();
};

// func:dmmeta.Fldoffset..ReadFieldMaybe
bool                 Fldoffset_ReadFieldMaybe(dmmeta::Fldoffset& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fldoffset from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fldoffset..ReadStrptrMaybe
bool                 Fldoffset_ReadStrptrMaybe(dmmeta::Fldoffset &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fldoffset..Init
void                 Fldoffset_Init(dmmeta::Fldoffset& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fldoffset.String  printfmt:Tuple
// func:dmmeta.Fldoffset..Print
void                 Fldoffset_Print(dmmeta::Fldoffset& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Floadtuples
struct Floadtuples { // dmmeta.Floadtuples: Request that process automatically load any input tables on startup
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Floadtuples();
};

// func:dmmeta.Floadtuples.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Floadtuples& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Floadtuples.ctype.Get2
algo::Smallstr100    Floadtuples_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Floadtuples..ReadFieldMaybe
bool                 Floadtuples_ReadFieldMaybe(dmmeta::Floadtuples& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Floadtuples from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Floadtuples..ReadStrptrMaybe
bool                 Floadtuples_ReadStrptrMaybe(dmmeta::Floadtuples &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Floadtuples.String  printfmt:Tuple
// func:dmmeta.Floadtuples..Print
void                 Floadtuples_Print(dmmeta::Floadtuples& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fnoremove
struct Fnoremove { // dmmeta.Fnoremove: Omit any functions for removing elements from table; Table is append-only
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fnoremove();
};

// func:dmmeta.Fnoremove..ReadFieldMaybe
bool                 Fnoremove_ReadFieldMaybe(dmmeta::Fnoremove& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fnoremove from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fnoremove..ReadStrptrMaybe
bool                 Fnoremove_ReadStrptrMaybe(dmmeta::Fnoremove &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fnoremove.String  printfmt:Tuple
// func:dmmeta.Fnoremove..Print
void                 Fnoremove_Print(dmmeta::Fnoremove& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Foutput
struct Foutput { // dmmeta.Foutput: Generate function to save index/table back to disk
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Foutput();
};

// func:dmmeta.Foutput.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Foutput& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Foutput.ns.Get2
algo::Smallstr16     Foutput_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Foutput..ReadFieldMaybe
bool                 Foutput_ReadFieldMaybe(dmmeta::Foutput& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Foutput from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Foutput..ReadStrptrMaybe
bool                 Foutput_ReadStrptrMaybe(dmmeta::Foutput &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Foutput.String  printfmt:Tuple
// func:dmmeta.Foutput..Print
void                 Foutput_Print(dmmeta::Foutput& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fprefix
struct Fprefix { // dmmeta.Fprefix: Mapping between field prefix and Reftype
    algo::Smallstr5    fprefix;   //
    algo::Smallstr50   reftype;   //
    algo::Comment      comment;   //
    Fprefix();
};

// func:dmmeta.Fprefix..ReadFieldMaybe
bool                 Fprefix_ReadFieldMaybe(dmmeta::Fprefix& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fprefix from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fprefix..ReadStrptrMaybe
bool                 Fprefix_ReadStrptrMaybe(dmmeta::Fprefix &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fprefix.String  printfmt:Tuple
// func:dmmeta.Fprefix..Print
void                 Fprefix_Print(dmmeta::Fprefix& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fregx
struct Fregx { // dmmeta.Fregx: Specify options for command-line regx field
    algo::Smallstr100   field;      //
    bool                partial;    //   false
    algo::Smallstr50    regxtype;   //
    algo::Comment       comment;    //
    Fregx();
};

// func:dmmeta.Fregx..ReadFieldMaybe
bool                 Fregx_ReadFieldMaybe(dmmeta::Fregx& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fregx from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fregx..ReadStrptrMaybe
bool                 Fregx_ReadStrptrMaybe(dmmeta::Fregx &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Fregx..Init
void                 Fregx_Init(dmmeta::Fregx& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Fregx.String  printfmt:Tuple
// func:dmmeta.Fregx..Print
void                 Fregx_Print(dmmeta::Fregx& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fsort
struct Fsort { // dmmeta.Fsort: Generate custom sort function for array field
    algo::Smallstr100   field;      // Field (array etc) being sorted
    algo::Smallstr50    sorttype;   // Kind of sort to generate
    algo::Smallstr100   sortfld;    // Field to sort on
    algo::Comment       comment;    //
    Fsort();
};

// func:dmmeta.Fsort..ReadFieldMaybe
bool                 Fsort_ReadFieldMaybe(dmmeta::Fsort& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fsort from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fsort..ReadStrptrMaybe
bool                 Fsort_ReadStrptrMaybe(dmmeta::Fsort &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fsort.String  printfmt:Tuple
// func:dmmeta.Fsort..Print
void                 Fsort_Print(dmmeta::Fsort& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fstep
struct Fstep { // dmmeta.Fstep: Generate a main loop step to be executed whenever a field is non-empty
    algo::Smallstr100   fstep;      //
    algo::Smallstr50    steptype;   //
    algo::Comment       comment;    //
    Fstep();
};

// func:dmmeta.Fstep.field.Get
algo::Smallstr100    field_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fstep.field.Get2
algo::Smallstr100    Fstep_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fstep.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fstep.ns.Get2
algo::Smallstr16     Fstep_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fstep.name.Get
algo::Smallstr50     name_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fstep.name.Get2
algo::Smallstr50     Fstep_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fstep..Concat_field
tempstr              Fstep_Concat_field( const algo::strptr& field );
// func:dmmeta.Fstep..ReadFieldMaybe
bool                 Fstep_ReadFieldMaybe(dmmeta::Fstep& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fstep from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fstep..ReadStrptrMaybe
bool                 Fstep_ReadStrptrMaybe(dmmeta::Fstep &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fstep.String  printfmt:Tuple
// func:dmmeta.Fstep..Print
void                 Fstep_Print(dmmeta::Fstep& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ftrace
struct Ftrace { // dmmeta.Ftrace: Generate cycle/step counting fields for a step
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Ftrace();
};

// func:dmmeta.Ftrace..ReadFieldMaybe
bool                 Ftrace_ReadFieldMaybe(dmmeta::Ftrace& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ftrace from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ftrace..ReadStrptrMaybe
bool                 Ftrace_ReadStrptrMaybe(dmmeta::Ftrace &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ftrace.String  printfmt:Tuple
// func:dmmeta.Ftrace..Print
void                 Ftrace_Print(dmmeta::Ftrace& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ftuple
struct Ftuple { // dmmeta.Ftuple
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Ftuple();
};

// func:dmmeta.Ftuple..ReadFieldMaybe
bool                 Ftuple_ReadFieldMaybe(dmmeta::Ftuple& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ftuple from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ftuple..ReadStrptrMaybe
bool                 Ftuple_ReadStrptrMaybe(dmmeta::Ftuple &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ftuple.String  printfmt:Tuple
// func:dmmeta.Ftuple..Print
void                 Ftuple_Print(dmmeta::Ftuple& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Func
struct Func { // dmmeta.Func
    algo::Smallstr100   func;        // Primary key
    bool                inl;         //   false  Make inline?
    algo::cstring       proto;       // Prototype
    algo::cstring       body;        // Body of function
    bool                deprecate;   //   false  Make deprecated?
    bool                ismacro;     //   false  Always inline.
    bool                extrn;       //   false  Implemented externally by user
    bool                glob;        //   false  Function is not attached to a field (EXPLAIN!!)
    bool                priv;        //   false  Private to translateion unit (static)
    algo::cstring       ret;         // Return type (c++ expression)
    algo::cstring       comment;     // Description
    Func();
};

// func:dmmeta.Func.field.Get
algo::Smallstr100    field_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Func.field.Get2
algo::Smallstr100    Func_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Func.name.Get
algo::Smallstr50     name_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Func.name.Get2
algo::Smallstr50     Func_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Func.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Func.ctype.Get2
algo::Smallstr100    Func_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Func.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Func.ns.Get2
algo::Smallstr16     Func_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Func..Concat_field_name
tempstr              Func_Concat_field_name( const algo::strptr& field ,const algo::strptr& name );
// func:dmmeta.Func..ReadFieldMaybe
bool                 Func_ReadFieldMaybe(dmmeta::Func& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Func from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Func..ReadStrptrMaybe
bool                 Func_ReadStrptrMaybe(dmmeta::Func &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Func..Init
void                 Func_Init(dmmeta::Func& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Func.String  printfmt:Tuple
// func:dmmeta.Func..Print
void                 Func_Print(dmmeta::Func& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Funique
struct Funique { // dmmeta.Funique: This field must be unique in the table. Not needed for primary key
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Funique();
};

// func:dmmeta.Funique..ReadFieldMaybe
bool                 Funique_ReadFieldMaybe(dmmeta::Funique& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Funique from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Funique..ReadStrptrMaybe
bool                 Funique_ReadStrptrMaybe(dmmeta::Funique &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Funique.String  printfmt:Tuple
// func:dmmeta.Funique..Print
void                 Funique_Print(dmmeta::Funique& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fuserinit
struct Fuserinit { // dmmeta.Fuserinit: Add user-defined initialization function for field (see fcleanup)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fuserinit();
};

// func:dmmeta.Fuserinit..ReadFieldMaybe
bool                 Fuserinit_ReadFieldMaybe(dmmeta::Fuserinit& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fuserinit from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fuserinit..ReadStrptrMaybe
bool                 Fuserinit_ReadStrptrMaybe(dmmeta::Fuserinit &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fuserinit.String  printfmt:Tuple
// func:dmmeta.Fuserinit..Print
void                 Fuserinit_Print(dmmeta::Fuserinit& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Fwddecl
struct Fwddecl { // dmmeta.Fwddecl: Request forward declaration of a field
    algo::Smallstr100   fwddecl;   //
    algo::Comment       comment;   //
    Fwddecl();
};

// func:dmmeta.Fwddecl.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Fwddecl& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fwddecl.ns.Get2
algo::Smallstr16     Fwddecl_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fwddecl.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Fwddecl& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Fwddecl.ctype.Get2
algo::Smallstr100    Fwddecl_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Fwddecl..Concat_ns_ctype
tempstr              Fwddecl_Concat_ns_ctype( const algo::strptr& ns ,const algo::strptr& ctype );
// func:dmmeta.Fwddecl..ReadFieldMaybe
bool                 Fwddecl_ReadFieldMaybe(dmmeta::Fwddecl& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fwddecl from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Fwddecl..ReadStrptrMaybe
bool                 Fwddecl_ReadStrptrMaybe(dmmeta::Fwddecl &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Fwddecl.String  printfmt:Tuple
// func:dmmeta.Fwddecl..Print
void                 Fwddecl_Print(dmmeta::Fwddecl& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Gconst
struct Gconst { // dmmeta.Gconst: Import ssim table columns as fconst for a field
    algo::Smallstr100   field;      // Field with which to associate constants
    algo::Smallstr100   namefld;    // Field which gives the name of the constant
    algo::Smallstr100   idfld;      // Optional attribute of namefld that gives numeric ID for gconst
    bool                wantenum;   //   true
    explicit Gconst(const algo::strptr&            in_field
        ,const algo::strptr&            in_namefld
        ,const algo::strptr&            in_idfld
        ,bool                           in_wantenum);
    Gconst();
};

// func:dmmeta.Gconst.namefldctyp.Get
algo::Smallstr100    namefldctyp_Get(dmmeta::Gconst& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Gconst.namefldctyp.Get2
algo::Smallstr100    Gconst_namefldctyp_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Gconst..ReadFieldMaybe
bool                 Gconst_ReadFieldMaybe(dmmeta::Gconst& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gconst from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Gconst..ReadStrptrMaybe
bool                 Gconst_ReadStrptrMaybe(dmmeta::Gconst &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Gconst..Init
void                 Gconst_Init(dmmeta::Gconst& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Gconst.String  printfmt:Tuple
// func:dmmeta.Gconst..Print
void                 Gconst_Print(dmmeta::Gconst& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Gstatic
struct Gstatic { // dmmeta.Gstatic: Load entries for this table at startup time
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Gstatic(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Gstatic();
};

// func:dmmeta.Gstatic.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Gstatic& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Gstatic.ns.Get2
algo::Smallstr16     Gstatic_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Gstatic..ReadFieldMaybe
bool                 Gstatic_ReadFieldMaybe(dmmeta::Gstatic& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gstatic from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Gstatic..ReadStrptrMaybe
bool                 Gstatic_ReadStrptrMaybe(dmmeta::Gstatic &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Gstatic.String  printfmt:Tuple
// func:dmmeta.Gstatic..Print
void                 Gstatic_Print(dmmeta::Gstatic& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Gsymbol
struct Gsymbol { // dmmeta.Gsymbol: Create C++ symbols from entries in ssim table
    algo::Smallstr50    gsymbol;      //
    algo::Smallstr100   inc;          // Regex to filter rows
    algo::Smallstr100   symboltype;   //
    algo::Comment       comment;      //
    Gsymbol();
};

// func:dmmeta.Gsymbol.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Gsymbol& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Gsymbol.ns.Get2
algo::Smallstr16     Gsymbol_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Gsymbol.ssimfile.Get
algo::Smallstr50     ssimfile_Get(dmmeta::Gsymbol& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Gsymbol.ssimfile.Get2
algo::Smallstr50     Gsymbol_ssimfile_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Gsymbol..Concat_ns_ssimfile
tempstr              Gsymbol_Concat_ns_ssimfile( const algo::strptr& ns ,const algo::strptr& ssimfile );
// func:dmmeta.Gsymbol..ReadFieldMaybe
bool                 Gsymbol_ReadFieldMaybe(dmmeta::Gsymbol& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gsymbol from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Gsymbol..ReadStrptrMaybe
bool                 Gsymbol_ReadStrptrMaybe(dmmeta::Gsymbol &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Gsymbol.String  printfmt:Tuple
// func:dmmeta.Gsymbol..Print
void                 Gsymbol_Print(dmmeta::Gsymbol& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Hashtype
struct Hashtype { // dmmeta.Hashtype: Hash function type
    algo::Smallstr50   hashtype;   //
    algo::Comment      comment;    //
    explicit Hashtype(const algo::strptr&            in_hashtype
        ,const algo::Comment&           in_comment);
    Hashtype();
};

// func:dmmeta.Hashtype..ReadFieldMaybe
bool                 Hashtype_ReadFieldMaybe(dmmeta::Hashtype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Hashtype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Hashtype..ReadStrptrMaybe
bool                 Hashtype_ReadStrptrMaybe(dmmeta::Hashtype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Hashtype.String  printfmt:Tuple
// func:dmmeta.Hashtype..Print
void                 Hashtype_Print(dmmeta::Hashtype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Hook
struct Hook { // dmmeta.Hook: Required on Hook fields
    algo::Smallstr100   field;     // The field
    algo::Comment       comment;   //
    Hook();
};

// func:dmmeta.Hook..ReadFieldMaybe
bool                 Hook_ReadFieldMaybe(dmmeta::Hook& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Hook from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Hook..ReadStrptrMaybe
bool                 Hook_ReadStrptrMaybe(dmmeta::Hook &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Hook.String  printfmt:Tuple
// func:dmmeta.Hook..Print
void                 Hook_Print(dmmeta::Hook& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Inlary
struct Inlary { // dmmeta.Inlary: Generate inline array of fixed or variable length (all entries fit within parent struct)
    algo::Smallstr100   field;     //
    i32                 min;       //   0  Min. elements to preallocate
    i32                 max;       //   0  Max. elements
    algo::Comment       comment;   //
    explicit Inlary(const algo::strptr&            in_field
        ,i32                            in_min
        ,i32                            in_max
        ,const algo::Comment&           in_comment);
    Inlary();
};

// func:dmmeta.Inlary..ReadFieldMaybe
bool                 Inlary_ReadFieldMaybe(dmmeta::Inlary& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Inlary from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Inlary..ReadStrptrMaybe
bool                 Inlary_ReadStrptrMaybe(dmmeta::Inlary &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Inlary..Init
void                 Inlary_Init(dmmeta::Inlary& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Inlary.String  printfmt:Tuple
// func:dmmeta.Inlary..Print
void                 Inlary_Print(dmmeta::Inlary& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Lenfld
struct Lenfld { // dmmeta.Lenfld: Specify which gives length of varlen portion in bytes
    algo::Smallstr100   field;   // Name of length field
    i32                 extra;   //   0  Extra #bytes to add
    explicit Lenfld(const algo::strptr&            in_field
        ,i32                            in_extra);
    Lenfld();
};

// func:dmmeta.Lenfld.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Lenfld& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Lenfld.ctype.Get2
algo::Smallstr100    Lenfld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Lenfld..ReadFieldMaybe
bool                 Lenfld_ReadFieldMaybe(dmmeta::Lenfld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Lenfld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Lenfld..ReadStrptrMaybe
bool                 Lenfld_ReadStrptrMaybe(dmmeta::Lenfld &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Lenfld..Init
void                 Lenfld_Init(dmmeta::Lenfld& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Lenfld.String  printfmt:Tuple
// func:dmmeta.Lenfld..Print
void                 Lenfld_Print(dmmeta::Lenfld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Listtype
struct Listtype { // dmmeta.Listtype: Specify structure of linked list based on field prefix
    algo::Smallstr5   listtype;   //
    bool              circular;   //   false  Circular list
    bool              haveprev;   //   false  Previous link
    bool              instail;    //   false  Queue
    algo::Comment     comment;    //
    Listtype();
};

// func:dmmeta.Listtype..ReadFieldMaybe
bool                 Listtype_ReadFieldMaybe(dmmeta::Listtype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Listtype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Listtype..ReadStrptrMaybe
bool                 Listtype_ReadStrptrMaybe(dmmeta::Listtype &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Listtype..Init
void                 Listtype_Init(dmmeta::Listtype& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Listtype.String  printfmt:Tuple
// func:dmmeta.Listtype..Print
void                 Listtype_Print(dmmeta::Listtype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Llist
struct Llist { // dmmeta.Llist: Options for Llist field
    algo::Smallstr100   field;       // Index in question
    bool                havetail;    //   true  Generate 'tail' field
    bool                havecount;   //   false  Generate count of elements
    algo::Comment       comment;     //
    explicit Llist(const algo::strptr&            in_field
        ,bool                           in_havetail
        ,bool                           in_havecount
        ,const algo::Comment&           in_comment);
    Llist();
};

// func:dmmeta.Llist.listtype.Get
algo::Smallstr5      listtype_Get(dmmeta::Llist& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Llist.listtype.Get2
algo::Smallstr5      Llist_listtype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Llist..ReadFieldMaybe
bool                 Llist_ReadFieldMaybe(dmmeta::Llist& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Llist from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Llist..ReadStrptrMaybe
bool                 Llist_ReadStrptrMaybe(dmmeta::Llist &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Llist..Init
void                 Llist_Init(dmmeta::Llist& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Llist.String  printfmt:Tuple
// func:dmmeta.Llist..Print
void                 Llist_Print(dmmeta::Llist& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Logcat
struct Logcat { // dmmeta.Logcat: Log category
    algo::Smallstr50   logcat;    //
    bool               enabled;   //   false
    bool               builtin;   //   false
    algo::Comment      comment;   //
    Logcat();
};

// func:dmmeta.Logcat..ReadFieldMaybe
bool                 Logcat_ReadFieldMaybe(dmmeta::Logcat& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Logcat from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Logcat..ReadStrptrMaybe
bool                 Logcat_ReadStrptrMaybe(dmmeta::Logcat &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Logcat..Init
void                 Logcat_Init(dmmeta::Logcat& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Logcat.String  printfmt:Tuple
// func:dmmeta.Logcat..Print
void                 Logcat_Print(dmmeta::Logcat& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Main
struct Main { // dmmeta.Main: Generate Main function for namespace
    algo::Smallstr16   ns;         //
    bool               ismodule;   //   false
    explicit Main(const algo::strptr&            in_ns
        ,bool                           in_ismodule);
    Main();
};

// func:dmmeta.Main..ReadFieldMaybe
bool                 Main_ReadFieldMaybe(dmmeta::Main& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Main from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Main..ReadStrptrMaybe
bool                 Main_ReadStrptrMaybe(dmmeta::Main &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Main..Init
void                 Main_Init(dmmeta::Main& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Main.String  printfmt:Tuple
// func:dmmeta.Main..Print
void                 Main_Print(dmmeta::Main& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Msgtype
struct Msgtype { // dmmeta.Msgtype: Specify message type for each eligible message, controls dispatch
    algo::Smallstr100   ctype;   //
    algo::CppExpr       type;    //
    explicit Msgtype(const algo::strptr&            in_ctype
        ,const algo::CppExpr&           in_type);
    Msgtype();
};

// func:dmmeta.Msgtype..ReadFieldMaybe
bool                 Msgtype_ReadFieldMaybe(dmmeta::Msgtype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Msgtype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Msgtype..ReadStrptrMaybe
bool                 Msgtype_ReadStrptrMaybe(dmmeta::Msgtype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Msgtype.String  printfmt:Tuple
// func:dmmeta.Msgtype..Print
void                 Msgtype_Print(dmmeta::Msgtype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nocascdel
struct Nocascdel { // dmmeta.Nocascdel: Remove cascade delete for this index
    algo::Smallstr100   xref;      //
    algo::Comment       comment;   //
    Nocascdel();
};

// func:dmmeta.Nocascdel..ReadFieldMaybe
bool                 Nocascdel_ReadFieldMaybe(dmmeta::Nocascdel& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nocascdel from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nocascdel..ReadStrptrMaybe
bool                 Nocascdel_ReadStrptrMaybe(dmmeta::Nocascdel &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nocascdel.String  printfmt:Tuple
// func:dmmeta.Nocascdel..Print
void                 Nocascdel_Print(dmmeta::Nocascdel& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nossimfile
struct Nossimfile { // dmmeta.Nossimfile: Indicates that ssimfile does not exist for this ssimdb ctype
    algo::Smallstr100   ctype;     //
    algo::Comment       comment;   //
    Nossimfile();
};

// func:dmmeta.Nossimfile..ReadFieldMaybe
bool                 Nossimfile_ReadFieldMaybe(dmmeta::Nossimfile& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nossimfile from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nossimfile..ReadStrptrMaybe
bool                 Nossimfile_ReadStrptrMaybe(dmmeta::Nossimfile &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nossimfile.String  printfmt:Tuple
// func:dmmeta.Nossimfile..Print
void                 Nossimfile_Print(dmmeta::Nossimfile& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Noxref
struct Noxref { // dmmeta.Noxref: Explicitly specify that no x-ref exists between tables (don't use unless forced)
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Noxref();
};

// func:dmmeta.Noxref..ReadFieldMaybe
bool                 Noxref_ReadFieldMaybe(dmmeta::Noxref& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Noxref from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Noxref..ReadStrptrMaybe
bool                 Noxref_ReadStrptrMaybe(dmmeta::Noxref &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Noxref.String  printfmt:Tuple
// func:dmmeta.Noxref..Print
void                 Noxref_Print(dmmeta::Noxref& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ns
struct Ns { // dmmeta.Ns: Namespace (for in-memory database, protocol, etc)
    algo::Smallstr16   ns;        // Namespace name (primary key)
    algo::Smallstr50   nstype;    // Namespace type
    algo::Smallstr50   license;   // Associated license
    algo::Comment      comment;   //
    explicit Ns(const algo::strptr&            in_ns
        ,const algo::strptr&            in_nstype
        ,const algo::strptr&            in_license
        ,const algo::Comment&           in_comment);
    Ns();
};

// func:dmmeta.Ns..ReadFieldMaybe
bool                 Ns_ReadFieldMaybe(dmmeta::Ns& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ns from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ns..ReadStrptrMaybe
bool                 Ns_ReadStrptrMaybe(dmmeta::Ns &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ns.String  printfmt:Tuple
// func:dmmeta.Ns..Print
void                 Ns_Print(dmmeta::Ns& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nscpp
struct Nscpp { // dmmeta.Nscpp: Generate C++ code for this namespace
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    explicit Nscpp(const algo::strptr&            in_ns
        ,const algo::Comment&           in_comment);
    Nscpp();
};

// func:dmmeta.Nscpp..ReadFieldMaybe
bool                 Nscpp_ReadFieldMaybe(dmmeta::Nscpp& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nscpp from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nscpp..ReadStrptrMaybe
bool                 Nscpp_ReadStrptrMaybe(dmmeta::Nscpp &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nscpp.String  printfmt:Tuple
// func:dmmeta.Nscpp..Print
void                 Nscpp_Print(dmmeta::Nscpp& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nsdb
struct Nsdb { // dmmeta.Nsdb: Annotate ssimdb namespaces
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    Nsdb();
};

// func:dmmeta.Nsdb..ReadFieldMaybe
bool                 Nsdb_ReadFieldMaybe(dmmeta::Nsdb& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsdb from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nsdb..ReadStrptrMaybe
bool                 Nsdb_ReadStrptrMaybe(dmmeta::Nsdb &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsdb.String  printfmt:Tuple
// func:dmmeta.Nsdb..Print
void                 Nsdb_Print(dmmeta::Nsdb& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nsfast
struct Nsfast { // dmmeta.Nsfast: Whether namespace is FAST
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    Nsfast();
};

// func:dmmeta.Nsfast..ReadFieldMaybe
bool                 Nsfast_ReadFieldMaybe(dmmeta::Nsfast& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsfast from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nsfast..ReadStrptrMaybe
bool                 Nsfast_ReadStrptrMaybe(dmmeta::Nsfast &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsfast.String  printfmt:Tuple
// func:dmmeta.Nsfast..Print
void                 Nsfast_Print(dmmeta::Nsfast& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nsinclude
struct Nsinclude { // dmmeta.Nsinclude: Explicitly specify a C++ include file for namespace
    algo::Smallstr50   nsinclude;   //
    bool               sys;         //   false
    algo::Comment      comment;     //
    Nsinclude();
};

// func:dmmeta.Nsinclude.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Nsinclude& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Nsinclude.ns.Get2
algo::Smallstr16     Nsinclude_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Nsinclude.name.Get
algo::Smallstr50     name_Get(dmmeta::Nsinclude& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Nsinclude.name.Get2
algo::Smallstr50     Nsinclude_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Nsinclude..Concat_ns_name
tempstr              Nsinclude_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
// func:dmmeta.Nsinclude..ReadFieldMaybe
bool                 Nsinclude_ReadFieldMaybe(dmmeta::Nsinclude& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsinclude from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nsinclude..ReadStrptrMaybe
bool                 Nsinclude_ReadStrptrMaybe(dmmeta::Nsinclude &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Nsinclude..Init
void                 Nsinclude_Init(dmmeta::Nsinclude& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsinclude.String  printfmt:Tuple
// func:dmmeta.Nsinclude..Print
void                 Nsinclude_Print(dmmeta::Nsinclude& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nsproto
struct Nsproto { // dmmeta.Nsproto: Annotate protocol namespace (collection of types, no state)
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    explicit Nsproto(const algo::strptr&            in_ns
        ,const algo::Comment&           in_comment);
    Nsproto();
};

// func:dmmeta.Nsproto..ReadFieldMaybe
bool                 Nsproto_ReadFieldMaybe(dmmeta::Nsproto& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsproto from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nsproto..ReadStrptrMaybe
bool                 Nsproto_ReadStrptrMaybe(dmmeta::Nsproto &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsproto.String  printfmt:Tuple
// func:dmmeta.Nsproto..Print
void                 Nsproto_Print(dmmeta::Nsproto& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nstype
struct Nstype { // dmmeta.Nstype: Namespace type
    algo::Smallstr50   nstype;    //
    algo::Comment      comment;   //
    explicit Nstype(const algo::strptr&            in_nstype
        ,const algo::Comment&           in_comment);
    Nstype();
};

// func:dmmeta.Nstype..ReadFieldMaybe
bool                 Nstype_ReadFieldMaybe(dmmeta::Nstype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nstype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nstype..ReadStrptrMaybe
bool                 Nstype_ReadStrptrMaybe(dmmeta::Nstype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nstype.String  printfmt:Tuple
// func:dmmeta.Nstype..Print
void                 Nstype_Print(dmmeta::Nstype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nsversion
struct Nsversion { // dmmeta.Nsversion: Namespace version
    algo::Smallstr16   ns;        //
    algo::Smallstr10   version;   //
    algo::Comment      comment;   //
    Nsversion();
};

// func:dmmeta.Nsversion..ReadFieldMaybe
bool                 Nsversion_ReadFieldMaybe(dmmeta::Nsversion& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsversion from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nsversion..ReadStrptrMaybe
bool                 Nsversion_ReadStrptrMaybe(dmmeta::Nsversion &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsversion.String  printfmt:Tuple
// func:dmmeta.Nsversion..Print
void                 Nsversion_Print(dmmeta::Nsversion& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Nsx
struct Nsx { // dmmeta.Nsx: Control code-generation and exception handling options for process/library
    algo::Smallstr16    ns;                    //
    bool                genthrow;              //   false
    bool                correct_getorcreate;   //   false
    algo::Smallstr100   pool;                  //
    bool                sortxref;              //   false
    bool                pack;                  //   false
    algo::Comment       comment;               //
    explicit Nsx(const algo::strptr&            in_ns
        ,bool                           in_genthrow
        ,bool                           in_correct_getorcreate
        ,const algo::strptr&            in_pool
        ,bool                           in_sortxref
        ,bool                           in_pack
        ,const algo::Comment&           in_comment);
    Nsx();
};

// func:dmmeta.Nsx..ReadFieldMaybe
bool                 Nsx_ReadFieldMaybe(dmmeta::Nsx& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsx from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Nsx..ReadStrptrMaybe
bool                 Nsx_ReadStrptrMaybe(dmmeta::Nsx &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Nsx..Init
void                 Nsx_Init(dmmeta::Nsx& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Nsx.String  printfmt:Tuple
// func:dmmeta.Nsx..Print
void                 Nsx_Print(dmmeta::Nsx& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Numstr
struct Numstr { // dmmeta.Numstr: Add functions to read numbers out of a string field
    algo::Smallstr100   field;     // String type
    algo::Smallstr100   numtype;   // Corresponding numeric type
    i32                 base;      //   0  Base for conversion
    i32                 min_len;   //   0  Mininum length of string
    explicit Numstr(const algo::strptr&            in_field
        ,const algo::strptr&            in_numtype
        ,i32                            in_base
        ,i32                            in_min_len);
    Numstr();
};

// func:dmmeta.Numstr..ReadFieldMaybe
bool                 Numstr_ReadFieldMaybe(dmmeta::Numstr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Numstr from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Numstr..ReadStrptrMaybe
bool                 Numstr_ReadStrptrMaybe(dmmeta::Numstr &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Numstr..Init
void                 Numstr_Init(dmmeta::Numstr& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Numstr.String  printfmt:Tuple
// func:dmmeta.Numstr..Print
void                 Numstr_Print(dmmeta::Numstr& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Pack
struct Pack { // dmmeta.Pack: Request byte-packing of structure fields
    algo::Smallstr100   ctype;     // Target ctype
    algo::Comment       comment;   //
    explicit Pack(const algo::strptr&            in_ctype
        ,const algo::Comment&           in_comment);
    Pack();
};

// func:dmmeta.Pack..ReadFieldMaybe
bool                 Pack_ReadFieldMaybe(dmmeta::Pack& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pack from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Pack..ReadStrptrMaybe
bool                 Pack_ReadStrptrMaybe(dmmeta::Pack &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Pack.String  printfmt:Tuple
// func:dmmeta.Pack..Print
void                 Pack_Print(dmmeta::Pack& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Pmaskfld
struct Pmaskfld { // dmmeta.Pmaskfld: Specify which field holds presence mask bits (one for each field in struct)
    algo::Smallstr100   field;          //
    bool                filter_print;   //   true  Omit non-present fields when printing
    algo::Comment       comment;        //
    explicit Pmaskfld(const algo::strptr&            in_field
        ,bool                           in_filter_print
        ,const algo::Comment&           in_comment);
    Pmaskfld();
};

// func:dmmeta.Pmaskfld.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Pmaskfld& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Pmaskfld.ctype.Get2
algo::Smallstr100    Pmaskfld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Pmaskfld..ReadFieldMaybe
bool                 Pmaskfld_ReadFieldMaybe(dmmeta::Pmaskfld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pmaskfld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Pmaskfld..ReadStrptrMaybe
bool                 Pmaskfld_ReadStrptrMaybe(dmmeta::Pmaskfld &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Pmaskfld..Init
void                 Pmaskfld_Init(dmmeta::Pmaskfld& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Pmaskfld.String  printfmt:Tuple
// func:dmmeta.Pmaskfld..Print
void                 Pmaskfld_Print(dmmeta::Pmaskfld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.PmaskfldMember
struct PmaskfldMember { // dmmeta.PmaskfldMember: Explicit field-to-pmask association
    algo::Smallstr100   pmaskfld_member;   //
    algo::Comment       comment;           //
    PmaskfldMember();
};

// func:dmmeta.PmaskfldMember.pmaskfld.Get
algo::Smallstr100    pmaskfld_Get(dmmeta::PmaskfldMember& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.PmaskfldMember.pmaskfld.Get2
algo::Smallstr100    PmaskfldMember_pmaskfld_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.PmaskfldMember.field.Get
algo::Smallstr100    field_Get(dmmeta::PmaskfldMember& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.PmaskfldMember.field.Get2
algo::Smallstr100    PmaskfldMember_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.PmaskfldMember..Concat_pmaskfld_field
tempstr              PmaskfldMember_Concat_pmaskfld_field( const algo::strptr& pmaskfld ,const algo::strptr& field );
// func:dmmeta.PmaskfldMember..ReadFieldMaybe
bool                 PmaskfldMember_ReadFieldMaybe(dmmeta::PmaskfldMember& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::PmaskfldMember from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.PmaskfldMember..ReadStrptrMaybe
bool                 PmaskfldMember_ReadStrptrMaybe(dmmeta::PmaskfldMember &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.PmaskfldMember.String  printfmt:Tuple
// func:dmmeta.PmaskfldMember..Print
void                 PmaskfldMember_Print(dmmeta::PmaskfldMember& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Pnew
struct Pnew { // dmmeta.Pnew: Generate custom constructor (placement new), for use with binary protocols
    algo::Smallstr100   pnew;      //
    algo::Comment       comment;   //
    explicit Pnew(const algo::strptr&            in_pnew
        ,const algo::Comment&           in_comment);
    Pnew();
};

// func:dmmeta.Pnew.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Pnew.ns.Get2
algo::Smallstr16     Pnew_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Pnew.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Pnew.ctype.Get2
algo::Smallstr100    Pnew_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Pnew.buftype.Get
algo::Smallstr50     buftype_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Pnew.buftype.Get2
algo::Smallstr50     Pnew_buftype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Pnew..Concat_ns_ctype_buftype
tempstr              Pnew_Concat_ns_ctype_buftype( const algo::strptr& ns ,const algo::strptr& ctype ,const algo::strptr& buftype );
// func:dmmeta.Pnew..ReadFieldMaybe
bool                 Pnew_ReadFieldMaybe(dmmeta::Pnew& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pnew from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Pnew..ReadStrptrMaybe
bool                 Pnew_ReadStrptrMaybe(dmmeta::Pnew &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Pnew.String  printfmt:Tuple
// func:dmmeta.Pnew..Print
void                 Pnew_Print(dmmeta::Pnew& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Printfmt
struct Printfmt { // dmmeta.Printfmt: Print format
    algo::Smallstr50   printfmt;   //
    algo::Comment      comment;    //
    Printfmt();
};

// func:dmmeta.Printfmt..ReadFieldMaybe
bool                 Printfmt_ReadFieldMaybe(dmmeta::Printfmt& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Printfmt from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Printfmt..ReadStrptrMaybe
bool                 Printfmt_ReadStrptrMaybe(dmmeta::Printfmt &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Printfmt.String  printfmt:Tuple
// func:dmmeta.Printfmt..Print
void                 Printfmt_Print(dmmeta::Printfmt& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ptrary
struct Ptrary { // dmmeta.Ptrary: Required for fields with reftype:Ptrary
    algo::Smallstr100   field;    //
    bool                unique;   //   false  Search for and ignore duplicates
    explicit Ptrary(const algo::strptr&            in_field
        ,bool                           in_unique);
    Ptrary();
};

// func:dmmeta.Ptrary..ReadFieldMaybe
bool                 Ptrary_ReadFieldMaybe(dmmeta::Ptrary& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ptrary from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ptrary..ReadStrptrMaybe
bool                 Ptrary_ReadStrptrMaybe(dmmeta::Ptrary &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Ptrary..Init
void                 Ptrary_Init(dmmeta::Ptrary& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Ptrary.String  printfmt:Tuple
// func:dmmeta.Ptrary..Print
void                 Ptrary_Print(dmmeta::Ptrary& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Reftype
struct Reftype { // dmmeta.Reftype: Field type constructor (e.g. reference type)
    algo::Smallstr50   reftype;       //   "Val"
    bool               isval;         //   false  True if field makes values of target type
    bool               cascins;       //   false  Field is cascade-insert
    bool               usebasepool;   //   false  Fields with this type make use of dmmeta.basepool
    bool               cancopy;       //   false  This type of field can be copied
    bool               isxref;        //   false  This type of field is an x-ref
    bool               del;           //   false  Supports random deletion?
    bool               up;            //   false  This type of field is a reference
    bool               isnew;         //   false  If set, skip this relation in amc_vis
    bool               hasalloc;      //   false  Generte Alloc/Delete functions for arg type
    bool               inst;          //   false  Field creates an instance of arg type (directly or indirectly)
    bool               varlen;        //   false  This pool supports varlen allocations
    Reftype();
};

// func:dmmeta.Reftype..ReadFieldMaybe
bool                 Reftype_ReadFieldMaybe(dmmeta::Reftype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Reftype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Reftype..ReadStrptrMaybe
bool                 Reftype_ReadStrptrMaybe(dmmeta::Reftype &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Reftype..Init
void                 Reftype_Init(dmmeta::Reftype& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Reftype.String  printfmt:Tuple
// func:dmmeta.Reftype..Print
void                 Reftype_Print(dmmeta::Reftype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.ReftypeCase
#pragma pack(push,1)
struct ReftypeCase { // dmmeta.ReftypeCase: enum helper Field type constructor (e.g. reference type)
    u8   reftype;   //   0
    inline operator dmmeta_ReftypeCaseEnum() const;
    explicit ReftypeCase(u8                             in_reftype);
    ReftypeCase(dmmeta_ReftypeCaseEnum arg);
    ReftypeCase();
};
#pragma pack(pop)

// Get value of field as enum type
// func:dmmeta.ReftypeCase.reftype.GetEnum
dmmeta_ReftypeCaseEnum reftype_GetEnum(const dmmeta::ReftypeCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:dmmeta.ReftypeCase.reftype.SetEnum
void                 reftype_SetEnum(dmmeta::ReftypeCase& parent, dmmeta_ReftypeCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:dmmeta.ReftypeCase.reftype.ToCstr
const char*          reftype_ToCstr(const dmmeta::ReftypeCase& parent) __attribute__((nothrow));
// Convert reftype to a string. First, attempt conversion to a known string.
// If no string matches, print reftype as a numeric value.
// func:dmmeta.ReftypeCase.reftype.Print
void                 reftype_Print(const dmmeta::ReftypeCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:dmmeta.ReftypeCase.reftype.SetStrptrMaybe
bool                 reftype_SetStrptrMaybe(dmmeta::ReftypeCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:dmmeta.ReftypeCase.reftype.SetStrptr
void                 reftype_SetStrptr(dmmeta::ReftypeCase& parent, algo::strptr rhs, dmmeta_ReftypeCaseEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
// func:dmmeta.ReftypeCase..Init
void                 ReftypeCase_Init(dmmeta::ReftypeCase& parent);

// --- dmmeta.Rowid
struct Rowid { // dmmeta.Rowid: Initialize field to row id of element
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Rowid();
};

// func:dmmeta.Rowid..ReadFieldMaybe
bool                 Rowid_ReadFieldMaybe(dmmeta::Rowid& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Rowid from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Rowid..ReadStrptrMaybe
bool                 Rowid_ReadStrptrMaybe(dmmeta::Rowid &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Rowid.String  printfmt:Tuple
// func:dmmeta.Rowid..Print
void                 Rowid_Print(dmmeta::Rowid& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Smallstr
struct Smallstr { // dmmeta.Smallstr: Generated fixed-length padded or length-delimited string field
    algo::Smallstr100   field;     //
    i32                 length;    //   0  Maximum characters in the string
    algo::Smallstr50    strtype;   // Data format for string
    algo::CppExpr       pad;       // Pad character (if applicable)
    bool                strict;    //   false
    Smallstr();
};

// func:dmmeta.Smallstr.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Smallstr& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Smallstr.ctype.Get2
algo::Smallstr100    Smallstr_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Smallstr..ReadFieldMaybe
bool                 Smallstr_ReadFieldMaybe(dmmeta::Smallstr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Smallstr from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Smallstr..ReadStrptrMaybe
bool                 Smallstr_ReadStrptrMaybe(dmmeta::Smallstr &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Smallstr..Init
void                 Smallstr_Init(dmmeta::Smallstr& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Smallstr.String  printfmt:Tuple
// func:dmmeta.Smallstr..Print
void                 Smallstr_Print(dmmeta::Smallstr& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Sortfld
struct Sortfld { // dmmeta.Sortfld: Specify what field an index (Bheap,Atree) is sorted on
    algo::Smallstr100   field;     //
    algo::Smallstr100   sortfld;   // Field to sort by
    explicit Sortfld(const algo::strptr&            in_field
        ,const algo::strptr&            in_sortfld);
    Sortfld();
};

// func:dmmeta.Sortfld..ReadFieldMaybe
bool                 Sortfld_ReadFieldMaybe(dmmeta::Sortfld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sortfld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Sortfld..ReadStrptrMaybe
bool                 Sortfld_ReadStrptrMaybe(dmmeta::Sortfld &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Sortfld.String  printfmt:Tuple
// func:dmmeta.Sortfld..Print
void                 Sortfld_Print(dmmeta::Sortfld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Sorttype
struct Sorttype { // dmmeta.Sorttype: Sort type
    algo::Smallstr50   sorttype;   //
    algo::Comment      comment;    //
    Sorttype();
};

// func:dmmeta.Sorttype..ReadFieldMaybe
bool                 Sorttype_ReadFieldMaybe(dmmeta::Sorttype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sorttype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Sorttype..ReadStrptrMaybe
bool                 Sorttype_ReadStrptrMaybe(dmmeta::Sorttype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Sorttype.String  printfmt:Tuple
// func:dmmeta.Sorttype..Print
void                 Sorttype_Print(dmmeta::Sorttype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Sqltype
struct Sqltype { // dmmeta.Sqltype: Mapping of ctype -> SQL expression
    algo::Smallstr100   ctype;     //
    algo::Smallstr100   expr;      //
    algo::Comment       comment;   //
    Sqltype();
};

// func:dmmeta.Sqltype..ReadFieldMaybe
bool                 Sqltype_ReadFieldMaybe(dmmeta::Sqltype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sqltype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Sqltype..ReadStrptrMaybe
bool                 Sqltype_ReadStrptrMaybe(dmmeta::Sqltype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Sqltype.String  printfmt:Tuple
// func:dmmeta.Sqltype..Print
void                 Sqltype_Print(dmmeta::Sqltype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ssimfile
struct Ssimfile { // dmmeta.Ssimfile: File with ssim tuples
    algo::Smallstr50    ssimfile;   //
    algo::Smallstr100   ctype;      //
    explicit Ssimfile(const algo::strptr&            in_ssimfile
        ,const algo::strptr&            in_ctype);
    Ssimfile();
};

// func:dmmeta.Ssimfile.ssimns.Get
algo::Smallstr16     ssimns_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimfile.ssimns.Get2
algo::Smallstr16     Ssimfile_ssimns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimfile.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimfile.ns.Get2
algo::Smallstr16     Ssimfile_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimfile.name.Get
algo::Smallstr50     name_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimfile.name.Get2
algo::Smallstr50     Ssimfile_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimfile..ReadFieldMaybe
bool                 Ssimfile_ReadFieldMaybe(dmmeta::Ssimfile& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimfile from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ssimfile..ReadStrptrMaybe
bool                 Ssimfile_ReadStrptrMaybe(dmmeta::Ssimfile &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimfile.String  printfmt:Tuple
// func:dmmeta.Ssimfile..Print
void                 Ssimfile_Print(dmmeta::Ssimfile& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ssimreq
struct Ssimreq { // dmmeta.Ssimreq: Extended constraints for ssim records
    algo::Smallstr100   ssimreq;    //
    algo::Smallstr100   parent;     //
    bool                reqchild;   //   false
    bool                bidir;      //   false
    algo::Comment       comment;    //
    Ssimreq();
};

// func:dmmeta.Ssimreq.parent_field.Get
algo::Smallstr100    parent_field_Get(dmmeta::Ssimreq& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimreq.parent_field.Get2
algo::Smallstr100    Ssimreq_parent_field_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimreq.parent_ctype.Get
algo::Smallstr100    parent_ctype_Get(dmmeta::Ssimreq& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimreq.parent_ctype.Get2
algo::Smallstr100    Ssimreq_parent_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimreq.value.Get
algo::Smallstr100    value_Get(dmmeta::Ssimreq& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimreq.value.Get2
algo::Smallstr100    Ssimreq_value_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimreq.child_ssimfile.Get
algo::Smallstr50     child_ssimfile_Get(dmmeta::Ssimreq& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimreq.child_ssimfile.Get2
algo::Smallstr50     Ssimreq_child_ssimfile_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimreq.child_key.Get
algo::Smallstr100    child_key_Get(dmmeta::Ssimreq& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Ssimreq.child_key.Get2
algo::Smallstr100    Ssimreq_child_key_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Ssimreq..Concat_parent_field_value
tempstr              Ssimreq_Concat_parent_field_value( const algo::strptr& parent_field ,const algo::strptr& value );
// func:dmmeta.Ssimreq..ReadFieldMaybe
bool                 Ssimreq_ReadFieldMaybe(dmmeta::Ssimreq& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimreq from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ssimreq..ReadStrptrMaybe
bool                 Ssimreq_ReadStrptrMaybe(dmmeta::Ssimreq &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Ssimreq..Init
void                 Ssimreq_Init(dmmeta::Ssimreq& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimreq.String  printfmt:Tuple
// func:dmmeta.Ssimreq..Print
void                 Ssimreq_Print(dmmeta::Ssimreq& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ssimsort
struct Ssimsort { // dmmeta.Ssimsort: Define sort order for ssimfile
    algo::Smallstr50    ssimfile;   //
    algo::Smallstr100   sortfld;    //
    algo::Comment       comment;    //
    Ssimsort();
};

// func:dmmeta.Ssimsort..ReadFieldMaybe
bool                 Ssimsort_ReadFieldMaybe(dmmeta::Ssimsort& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimsort from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ssimsort..ReadStrptrMaybe
bool                 Ssimsort_ReadStrptrMaybe(dmmeta::Ssimsort &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimsort.String  printfmt:Tuple
// func:dmmeta.Ssimsort..Print
void                 Ssimsort_Print(dmmeta::Ssimsort& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Ssimvolatile
struct Ssimvolatile { // dmmeta.Ssimvolatile: Types based on ssim files marked this way cannot be cross-referenced
    algo::Smallstr50   ssimfile;   //
    algo::Comment      comment;    //
    Ssimvolatile();
};

// func:dmmeta.Ssimvolatile..ReadFieldMaybe
bool                 Ssimvolatile_ReadFieldMaybe(dmmeta::Ssimvolatile& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimvolatile from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Ssimvolatile..ReadStrptrMaybe
bool                 Ssimvolatile_ReadStrptrMaybe(dmmeta::Ssimvolatile &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Ssimvolatile.String  printfmt:Tuple
// func:dmmeta.Ssimvolatile..Print
void                 Ssimvolatile_Print(dmmeta::Ssimvolatile& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Steptype
struct Steptype { // dmmeta.Steptype: Type of scheduler step
    algo::Smallstr50   steptype;   //
    algo::Comment      comment;    //
    explicit Steptype(const algo::strptr&            in_steptype
        ,const algo::Comment&           in_comment);
    Steptype();
};

// func:dmmeta.Steptype..ReadFieldMaybe
bool                 Steptype_ReadFieldMaybe(dmmeta::Steptype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Steptype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Steptype..ReadStrptrMaybe
bool                 Steptype_ReadStrptrMaybe(dmmeta::Steptype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Steptype.String  printfmt:Tuple
// func:dmmeta.Steptype..Print
void                 Steptype_Print(dmmeta::Steptype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Strfmt
struct Strfmt { // dmmeta.Strfmt: Cfmt conversion type (misnomer, not necessarily a string)
    algo::Smallstr50   strfmt;    //
    algo::Comment      comment;   //
    explicit Strfmt(const algo::strptr&            in_strfmt
        ,const algo::Comment&           in_comment);
    Strfmt();
};


// --- dmmeta.Strtype
struct Strtype { // dmmeta.Strtype: Type of small string
    algo::Smallstr50   strtype;   //
    algo::Comment      comment;   //
    explicit Strtype(const algo::strptr&            in_strtype
        ,const algo::Comment&           in_comment);
    Strtype();
};

// func:dmmeta.Strtype..ReadFieldMaybe
bool                 Strtype_ReadFieldMaybe(dmmeta::Strtype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Strtype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Strtype..ReadStrptrMaybe
bool                 Strtype_ReadStrptrMaybe(dmmeta::Strtype &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Strtype.String  printfmt:Tuple
// func:dmmeta.Strtype..Print
void                 Strtype_Print(dmmeta::Strtype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Substr
struct Substr { // dmmeta.Substr: Specify that the field value is computed from a substring of another field
    algo::Smallstr100   field;      //
    algo::CppExpr       expr;       //
    algo::Smallstr100   srcfield;   //
    explicit Substr(const algo::strptr&            in_field
        ,const algo::CppExpr&           in_expr
        ,const algo::strptr&            in_srcfield);
    Substr();
};

// func:dmmeta.Substr..ReadFieldMaybe
bool                 Substr_ReadFieldMaybe(dmmeta::Substr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Substr from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Substr..ReadStrptrMaybe
bool                 Substr_ReadStrptrMaybe(dmmeta::Substr &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Substr.String  printfmt:Tuple
// func:dmmeta.Substr..Print
void                 Substr_Print(dmmeta::Substr& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Svtype
struct Svtype { // dmmeta.Svtype: Table for determining ctype from separated value file
    algo::Smallstr100   ctype;       // Type to choose
    i32                 maxwid;      //   0  Maximum width in chars of input field
    i32                 fixedwid1;   //   0  Max chars before decimal point
    i32                 fixedwid2;   //   0  Max chars after decimal point
    algo::Comment       comment;     //
    Svtype();
};

// func:dmmeta.Svtype..ReadFieldMaybe
bool                 Svtype_ReadFieldMaybe(dmmeta::Svtype& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Svtype from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Svtype..ReadStrptrMaybe
bool                 Svtype_ReadStrptrMaybe(dmmeta::Svtype &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Svtype..Init
void                 Svtype_Init(dmmeta::Svtype& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Svtype.String  printfmt:Tuple
// func:dmmeta.Svtype..Print
void                 Svtype_Print(dmmeta::Svtype& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Tary
struct Tary { // dmmeta.Tary: Indirect linear dynamically alocated array (used for strings, arrays of data, etc)
    algo::Smallstr100   field;     //
    bool                aliased;   //   false  Geneate functions to copy from aryptr
    algo::Comment       comment;   //
    Tary();
};

// func:dmmeta.Tary..ReadFieldMaybe
bool                 Tary_ReadFieldMaybe(dmmeta::Tary& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tary from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Tary..ReadStrptrMaybe
bool                 Tary_ReadStrptrMaybe(dmmeta::Tary &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Tary..Init
void                 Tary_Init(dmmeta::Tary& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Tary.String  printfmt:Tuple
// func:dmmeta.Tary..Print
void                 Tary_Print(dmmeta::Tary& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Thash
struct Thash { // dmmeta.Thash: Hash index, required for fields with reftype Thash
    algo::Smallstr100   field;     //
    algo::Smallstr100   hashfld;   // Field on which hash function is computed
    bool                unique;    //   true  Enforce uniqueness of member elements
    algo::Comment       comment;   //
    explicit Thash(const algo::strptr&            in_field
        ,const algo::strptr&            in_hashfld
        ,bool                           in_unique
        ,const algo::Comment&           in_comment);
    Thash();
};

// func:dmmeta.Thash..ReadFieldMaybe
bool                 Thash_ReadFieldMaybe(dmmeta::Thash& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Thash from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Thash..ReadStrptrMaybe
bool                 Thash_ReadStrptrMaybe(dmmeta::Thash &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Thash..Init
void                 Thash_Init(dmmeta::Thash& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Thash.String  printfmt:Tuple
// func:dmmeta.Thash..Print
void                 Thash_Print(dmmeta::Thash& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Tracefld
struct Tracefld { // dmmeta.Tracefld: Trace fields
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
    explicit Tracefld(const algo::strptr&            in_tracefld
        ,const algo::Comment&           in_comment);
    Tracefld();
};

// func:dmmeta.Tracefld.tracerec.Get
algo::Smallstr50     tracerec_Get(dmmeta::Tracefld& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Tracefld.tracerec.Get2
algo::Smallstr50     Tracefld_tracerec_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Tracefld.name.Get
algo::Smallstr50     name_Get(dmmeta::Tracefld& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Tracefld.name.Get2
algo::Smallstr50     Tracefld_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Tracefld..Concat_tracerec_name
tempstr              Tracefld_Concat_tracerec_name( const algo::strptr& tracerec ,const algo::strptr& name );
// func:dmmeta.Tracefld..ReadFieldMaybe
bool                 Tracefld_ReadFieldMaybe(dmmeta::Tracefld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tracefld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Tracefld..ReadStrptrMaybe
bool                 Tracefld_ReadStrptrMaybe(dmmeta::Tracefld &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Tracefld.String  printfmt:Tuple
// func:dmmeta.Tracefld..Print
void                 Tracefld_Print(dmmeta::Tracefld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Tracerec
struct Tracerec { // dmmeta.Tracerec: Trace record
    algo::Smallstr50   tracerec;   // e.g. rl_lib.trace
    algo::Comment      comment;    //
    explicit Tracerec(const algo::strptr&            in_tracerec
        ,const algo::Comment&           in_comment);
    Tracerec();
};

// func:dmmeta.Tracerec.name.Get
algo::Smallstr50     name_Get(dmmeta::Tracerec& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Tracerec.name.Get2
algo::Smallstr50     Tracerec_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Tracerec.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Tracerec& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Tracerec.ns.Get2
algo::Smallstr16     Tracerec_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Tracerec..Concat_ns_name
tempstr              Tracerec_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
// func:dmmeta.Tracerec..ReadFieldMaybe
bool                 Tracerec_ReadFieldMaybe(dmmeta::Tracerec& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tracerec from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Tracerec..ReadStrptrMaybe
bool                 Tracerec_ReadStrptrMaybe(dmmeta::Tracerec &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Tracerec.String  printfmt:Tuple
// func:dmmeta.Tracerec..Print
void                 Tracerec_Print(dmmeta::Tracerec& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Typefld
struct Typefld { // dmmeta.Typefld: Specifies which field of a message carries the type
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Typefld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Typefld();
};

// func:dmmeta.Typefld.ctype.Get
algo::Smallstr100    ctype_Get(dmmeta::Typefld& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Typefld.ctype.Get2
algo::Smallstr100    Typefld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Typefld..ReadFieldMaybe
bool                 Typefld_ReadFieldMaybe(dmmeta::Typefld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Typefld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Typefld..ReadStrptrMaybe
bool                 Typefld_ReadStrptrMaybe(dmmeta::Typefld &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Typefld.String  printfmt:Tuple
// func:dmmeta.Typefld..Print
void                 Typefld_Print(dmmeta::Typefld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Usertracefld
struct Usertracefld { // dmmeta.Usertracefld: Add custom user trace fields to process's trace struct
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
    Usertracefld();
};

// func:dmmeta.Usertracefld..ReadFieldMaybe
bool                 Usertracefld_ReadFieldMaybe(dmmeta::Usertracefld& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Usertracefld from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Usertracefld..ReadStrptrMaybe
bool                 Usertracefld_ReadStrptrMaybe(dmmeta::Usertracefld &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:dmmeta.Usertracefld.String  printfmt:Tuple
// func:dmmeta.Usertracefld..Print
void                 Usertracefld_Print(dmmeta::Usertracefld& row, algo::cstring& str) __attribute__((nothrow));

// --- dmmeta.Xref
struct Xref { // dmmeta.Xref: Specify how to cross-reference (i.e. project, or group-by) one record with another
    algo::Smallstr100   field;     //
    algo::CppExpr       inscond;   //   "true"  Insert condition
    algo::Smallstr200   via;       //
    explicit Xref(const algo::strptr&            in_field
        ,const algo::CppExpr&           in_inscond
        ,const algo::strptr&            in_via);
    Xref();
};

// func:dmmeta.Xref.name.Get
algo::Smallstr50     name_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Xref.name.Get2
algo::Smallstr50     Xref_name_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Xref.ns.Get
algo::Smallstr16     ns_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Xref.ns.Get2
algo::Smallstr16     Xref_ns_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Xref.viafld.Get
algo::Smallstr100    viafld_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Xref.viafld.Get2
algo::Smallstr100    Xref_viafld_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Xref.keyfld.Get
algo::Smallstr100    keyfld_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
// func:dmmeta.Xref.keyfld.Get2
algo::Smallstr100    Xref_keyfld_Get(algo::strptr arg) __attribute__((nothrow));

// func:dmmeta.Xref..ReadFieldMaybe
bool                 Xref_ReadFieldMaybe(dmmeta::Xref& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Xref from an ascii string.
// The format of the string is an ssim Tuple
// func:dmmeta.Xref..ReadStrptrMaybe
bool                 Xref_ReadStrptrMaybe(dmmeta::Xref &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:dmmeta.Xref..Init
void                 Xref_Init(dmmeta::Xref& parent);
// print string representation of ROW to string STR
// cfmt:dmmeta.Xref.String  printfmt:Tuple
// func:dmmeta.Xref..Print
void                 Xref_Print(dmmeta::Xref& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace dmmeta { // gen:ns_func
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Anonfld &row);// cfmt:dmmeta.Anonfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Argvtype &row);// cfmt:dmmeta.Argvtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Basepool &row);// cfmt:dmmeta.Basepool.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Bitfld &row);// cfmt:dmmeta.Bitfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Buftype &row);// cfmt:dmmeta.Buftype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cafter &row);// cfmt:dmmeta.Cafter.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cascdel &row);// cfmt:dmmeta.Cascdel.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ccmp &row);// cfmt:dmmeta.Ccmp.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cdflt &row);// cfmt:dmmeta.Cdflt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cextern &row);// cfmt:dmmeta.Cextern.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cfast &row);// cfmt:dmmeta.Cfast.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cfmt &row);// cfmt:dmmeta.Cfmt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cget &row);// cfmt:dmmeta.Cget.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Charset &row);// cfmt:dmmeta.Charset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Chash &row);// cfmt:dmmeta.Chash.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cppfunc &row);// cfmt:dmmeta.Cppfunc.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cppkeyword &row);// cfmt:dmmeta.Cppkeyword.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cpptype &row);// cfmt:dmmeta.Cpptype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Csize &row);// cfmt:dmmeta.Csize.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cstr &row);// cfmt:dmmeta.Cstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ctype &row);// cfmt:dmmeta.Ctype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ctypelen &row);// cfmt:dmmeta.Ctypelen.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispatch &row);// cfmt:dmmeta.Dispatch.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::DispatchMsg &row);// cfmt:dmmeta.DispatchMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispctx &row);// cfmt:dmmeta.Dispctx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispfilter &row);// cfmt:dmmeta.Dispfilter.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispsig &row);// cfmt:dmmeta.Dispsig.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispsigcheck &row);// cfmt:dmmeta.Dispsigcheck.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Disptrace &row);// cfmt:dmmeta.Disptrace.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Falias &row);// cfmt:dmmeta.Falias.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fastenc &row);// cfmt:dmmeta.Fastenc.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fastinstr &row);// cfmt:dmmeta.Fastinstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fastop &row);// cfmt:dmmeta.Fastop.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbase &row);// cfmt:dmmeta.Fbase.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbigend &row);// cfmt:dmmeta.Fbigend.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbitset &row);// cfmt:dmmeta.Fbitset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbuf &row);// cfmt:dmmeta.Fbuf.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbufdir &row);// cfmt:dmmeta.Fbufdir.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbuftype &row);// cfmt:dmmeta.Fbuftype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcast &row);// cfmt:dmmeta.Fcast.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcleanup &row);// cfmt:dmmeta.Fcleanup.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcmap &row);// cfmt:dmmeta.Fcmap.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcmdline &row);// cfmt:dmmeta.Fcmdline.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcmp &row);// cfmt:dmmeta.Fcmp.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcompact &row);// cfmt:dmmeta.Fcompact.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fconst &row);// cfmt:dmmeta.Fconst.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fcurs &row);// cfmt:dmmeta.Fcurs.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fdec &row);// cfmt:dmmeta.Fdec.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fdelay &row);// cfmt:dmmeta.Fdelay.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ffast &row);// cfmt:dmmeta.Ffast.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fflag &row);// cfmt:dmmeta.Fflag.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Field &row);// cfmt:dmmeta.Field.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::FieldId &row);// cfmt:dmmeta.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Findrem &row);// cfmt:dmmeta.Findrem.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Finput &row);// cfmt:dmmeta.Finput.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fldoffset &row);// cfmt:dmmeta.Fldoffset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Floadtuples &row);// cfmt:dmmeta.Floadtuples.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fnoremove &row);// cfmt:dmmeta.Fnoremove.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Foutput &row);// cfmt:dmmeta.Foutput.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fprefix &row);// cfmt:dmmeta.Fprefix.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fregx &row);// cfmt:dmmeta.Fregx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fsort &row);// cfmt:dmmeta.Fsort.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fstep &row);// cfmt:dmmeta.Fstep.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ftrace &row);// cfmt:dmmeta.Ftrace.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ftuple &row);// cfmt:dmmeta.Ftuple.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Func &row);// cfmt:dmmeta.Func.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Funique &row);// cfmt:dmmeta.Funique.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fuserinit &row);// cfmt:dmmeta.Fuserinit.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fwddecl &row);// cfmt:dmmeta.Fwddecl.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gconst &row);// cfmt:dmmeta.Gconst.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gstatic &row);// cfmt:dmmeta.Gstatic.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gsymbol &row);// cfmt:dmmeta.Gsymbol.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Hashtype &row);// cfmt:dmmeta.Hashtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Hook &row);// cfmt:dmmeta.Hook.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Inlary &row);// cfmt:dmmeta.Inlary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Lenfld &row);// cfmt:dmmeta.Lenfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Listtype &row);// cfmt:dmmeta.Listtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Llist &row);// cfmt:dmmeta.Llist.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Logcat &row);// cfmt:dmmeta.Logcat.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Main &row);// cfmt:dmmeta.Main.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Msgtype &row);// cfmt:dmmeta.Msgtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nocascdel &row);// cfmt:dmmeta.Nocascdel.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nossimfile &row);// cfmt:dmmeta.Nossimfile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Noxref &row);// cfmt:dmmeta.Noxref.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ns &row);// cfmt:dmmeta.Ns.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nscpp &row);// cfmt:dmmeta.Nscpp.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsdb &row);// cfmt:dmmeta.Nsdb.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsfast &row);// cfmt:dmmeta.Nsfast.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsinclude &row);// cfmt:dmmeta.Nsinclude.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsproto &row);// cfmt:dmmeta.Nsproto.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nstype &row);// cfmt:dmmeta.Nstype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsversion &row);// cfmt:dmmeta.Nsversion.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsx &row);// cfmt:dmmeta.Nsx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Numstr &row);// cfmt:dmmeta.Numstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Pack &row);// cfmt:dmmeta.Pack.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Pmaskfld &row);// cfmt:dmmeta.Pmaskfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::PmaskfldMember &row);// cfmt:dmmeta.PmaskfldMember.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Pnew &row);// cfmt:dmmeta.Pnew.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Printfmt &row);// cfmt:dmmeta.Printfmt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ptrary &row);// cfmt:dmmeta.Ptrary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Reftype &row);// cfmt:dmmeta.Reftype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Rowid &row);// cfmt:dmmeta.Rowid.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Smallstr &row);// cfmt:dmmeta.Smallstr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sortfld &row);// cfmt:dmmeta.Sortfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sorttype &row);// cfmt:dmmeta.Sorttype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sqltype &row);// cfmt:dmmeta.Sqltype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimfile &row);// cfmt:dmmeta.Ssimfile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimreq &row);// cfmt:dmmeta.Ssimreq.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimsort &row);// cfmt:dmmeta.Ssimsort.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimvolatile &row);// cfmt:dmmeta.Ssimvolatile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Steptype &row);// cfmt:dmmeta.Steptype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Strtype &row);// cfmt:dmmeta.Strtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Substr &row);// cfmt:dmmeta.Substr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Svtype &row);// cfmt:dmmeta.Svtype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tary &row);// cfmt:dmmeta.Tary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Thash &row);// cfmt:dmmeta.Thash.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tracefld &row);// cfmt:dmmeta.Tracefld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tracerec &row);// cfmt:dmmeta.Tracerec.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Typefld &row);// cfmt:dmmeta.Typefld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Usertracefld &row);// cfmt:dmmeta.Usertracefld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Xref &row);// cfmt:dmmeta.Xref.String
}
