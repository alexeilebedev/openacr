//
// include/gen/dmmeta_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.h"
//#pragma endinclude
extern const char *  dmmeta_Buftype_pnewtype_Memptr;    // Memptr     fconst:dmmeta.Buftype.pnewtype/Memptr
extern const char *  dmmeta_Buftype_pnewtype_Pcbuf;     // Pcbuf      fconst:dmmeta.Buftype.pnewtype/Pcbuf
extern const char *  dmmeta_Buftype_pnewtype_Shbuf;     // Shbuf      fconst:dmmeta.Buftype.pnewtype/Shbuf
extern const char *  dmmeta_Buftype_pnewtype_Fixed;     // Fixed      fconst:dmmeta.Buftype.pnewtype/Fixed
extern const char *  dmmeta_Buftype_pnewtype_Dynamic;   // Dynamic    fconst:dmmeta.Buftype.pnewtype/Dynamic
extern const char *  dmmeta_Buftype_pnewtype_ByteAry;   // ByteAry    fconst:dmmeta.Buftype.pnewtype/ByteAry

// --- dmmeta_BuftypeIdEnum

enum dmmeta_BuftypeIdEnum {           // dmmeta.BuftypeId.value
     dmmeta_BuftypeId_Memptr    = 0   // Some region in memory
    ,dmmeta_BuftypeId_Pcbuf     = 1   // Producer-consumer shared memory buffer (lossless)
    ,dmmeta_BuftypeId_Shbuf     = 2   // Shared memory lossy buffer
    ,dmmeta_BuftypeId_Fixed     = 3   // Fixed buffer
    ,dmmeta_BuftypeId_Dynamic   = 4   // Dynamic buffer
    ,dmmeta_BuftypeId_ByteAry   = 5   // ByteAry
};

enum { dmmeta_BuftypeIdEnum_N = 6 };

extern const char *  dmmeta_Fbufdir_fbufdir_in;    // in     fconst:dmmeta.Fbufdir.fbufdir/in
extern const char *  dmmeta_Fbufdir_fbufdir_out;   // out    fconst:dmmeta.Fbufdir.fbufdir/out
extern const char *  dmmeta_Fbuftype_fbuftype_Bytebuf;   // Bytebuf    fconst:dmmeta.Fbuftype.fbuftype/Bytebuf
extern const char *  dmmeta_Fbuftype_fbuftype_Linebuf;   // Linebuf    fconst:dmmeta.Fbuftype.fbuftype/Linebuf
extern const char *  dmmeta_Fbuftype_fbuftype_Msgbuf;    // Msgbuf     fconst:dmmeta.Fbuftype.fbuftype/Msgbuf

// --- dmmeta_FieldIdEnum

enum dmmeta_FieldIdEnum {                        // dmmeta.FieldId.value
     dmmeta_FieldId_field                 = 0
    ,dmmeta_FieldId_comment               = 1
    ,dmmeta_FieldId_ctype                 = 2
    ,dmmeta_FieldId_argvtype              = 3
    ,dmmeta_FieldId_base                  = 4
    ,dmmeta_FieldId_name                  = 5
    ,dmmeta_FieldId_offset                = 6
    ,dmmeta_FieldId_width                 = 7
    ,dmmeta_FieldId_srcfield              = 8
    ,dmmeta_FieldId_pnewtype              = 9
    ,dmmeta_FieldId_value                 = 10
    ,dmmeta_FieldId_cafter                = 11
    ,dmmeta_FieldId_after                 = 12
    ,dmmeta_FieldId_extrn                 = 13
    ,dmmeta_FieldId_genop                 = 14
    ,dmmeta_FieldId_order                 = 15
    ,dmmeta_FieldId_minmax                = 16
    ,dmmeta_FieldId_fwddecl               = 17
    ,dmmeta_FieldId_gen_using             = 18
    ,dmmeta_FieldId_dflt                  = 19
    ,dmmeta_FieldId_cppdflt               = 20
    ,dmmeta_FieldId_ssimdflt              = 21
    ,dmmeta_FieldId_initmemset            = 22
    ,dmmeta_FieldId_isstruct              = 23
    ,dmmeta_FieldId_cfmt                  = 24
    ,dmmeta_FieldId_strfmt                = 25
    ,dmmeta_FieldId_printfmt              = 26
    ,dmmeta_FieldId_read                  = 27
    ,dmmeta_FieldId_print                 = 28
    ,dmmeta_FieldId_sep                   = 29
    ,dmmeta_FieldId_expr                  = 30
    ,dmmeta_FieldId_charrange             = 31
    ,dmmeta_FieldId_calc                  = 32
    ,dmmeta_FieldId_hashtype              = 33
    ,dmmeta_FieldId_cppkeyword            = 34
    ,dmmeta_FieldId_ctor                  = 35
    ,dmmeta_FieldId_dtor                  = 36
    ,dmmeta_FieldId_cheap_copy            = 37
    ,dmmeta_FieldId_size                  = 38
    ,dmmeta_FieldId_alignment             = 39
    ,dmmeta_FieldId_strequiv              = 40
    ,dmmeta_FieldId_ns                    = 41
    ,dmmeta_FieldId_len                   = 42
    ,dmmeta_FieldId_padbytes              = 43
    ,dmmeta_FieldId_dispatch              = 44
    ,dmmeta_FieldId_unk                   = 45
    ,dmmeta_FieldId_haslen                = 46
    ,dmmeta_FieldId_call                  = 47
    ,dmmeta_FieldId_strict                = 48
    ,dmmeta_FieldId_dispatch_msg          = 49
    ,dmmeta_FieldId_match_all             = 50
    ,dmmeta_FieldId_dispsig               = 51
    ,dmmeta_FieldId_signature             = 52
    ,dmmeta_FieldId_cycle                 = 53
    ,dmmeta_FieldId_stripcomment          = 54
    ,dmmeta_FieldId_fbufdir               = 55
    ,dmmeta_FieldId_max                   = 56
    ,dmmeta_FieldId_fbuftype              = 57
    ,dmmeta_FieldId_insready              = 58
    ,dmmeta_FieldId_inseof                = 59
    ,dmmeta_FieldId_getmsg                = 60
    ,dmmeta_FieldId_skipbytes             = 61
    ,dmmeta_FieldId_fcmap                 = 62
    ,dmmeta_FieldId_leftField             = 63
    ,dmmeta_FieldId_leftVal               = 64
    ,dmmeta_FieldId_rightVal              = 65
    ,dmmeta_FieldId_rightField            = 66
    ,dmmeta_FieldId_bidir                 = 67
    ,dmmeta_FieldId_versionsort           = 68
    ,dmmeta_FieldId_casesens              = 69
    ,dmmeta_FieldId_fconst                = 70
    ,dmmeta_FieldId_fcurs                 = 71
    ,dmmeta_FieldId_curs                  = 72
    ,dmmeta_FieldId_nplace                = 73
    ,dmmeta_FieldId_fixedfmt              = 74
    ,dmmeta_FieldId_fstep                 = 75
    ,dmmeta_FieldId_delay                 = 76
    ,dmmeta_FieldId_scale                 = 77
    ,dmmeta_FieldId_arg                   = 78
    ,dmmeta_FieldId_reftype               = 79
    ,dmmeta_FieldId_update                = 80
    ,dmmeta_FieldId_fprefix               = 81
    ,dmmeta_FieldId_partial               = 82
    ,dmmeta_FieldId_sorttype              = 83
    ,dmmeta_FieldId_sortfld               = 84
    ,dmmeta_FieldId_steptype              = 85
    ,dmmeta_FieldId_func                  = 86
    ,dmmeta_FieldId_inl                   = 87
    ,dmmeta_FieldId_proto                 = 88
    ,dmmeta_FieldId_body                  = 89
    ,dmmeta_FieldId_deprecate             = 90
    ,dmmeta_FieldId_ismacro               = 91
    ,dmmeta_FieldId_glob                  = 92
    ,dmmeta_FieldId_priv                  = 93
    ,dmmeta_FieldId_ret                   = 94
    ,dmmeta_FieldId_namefld               = 95
    ,dmmeta_FieldId_idfld                 = 96
    ,dmmeta_FieldId_wantenum              = 97
    ,dmmeta_FieldId_namefldctyp           = 98
    ,dmmeta_FieldId_gsymbol               = 99
    ,dmmeta_FieldId_ssimfile              = 100
    ,dmmeta_FieldId_inc                   = 101
    ,dmmeta_FieldId_min                   = 102
    ,dmmeta_FieldId_extra                 = 103
    ,dmmeta_FieldId_listtype              = 104
    ,dmmeta_FieldId_circular              = 105
    ,dmmeta_FieldId_haveprev              = 106
    ,dmmeta_FieldId_instail               = 107
    ,dmmeta_FieldId_havetail              = 108
    ,dmmeta_FieldId_havecount             = 109
    ,dmmeta_FieldId_ismodule              = 110
    ,dmmeta_FieldId_type                  = 111
    ,dmmeta_FieldId_xref                  = 112
    ,dmmeta_FieldId_nstype                = 113
    ,dmmeta_FieldId_nsinclude             = 114
    ,dmmeta_FieldId_sys                   = 115
    ,dmmeta_FieldId_version               = 116
    ,dmmeta_FieldId_genthrow              = 117
    ,dmmeta_FieldId_correct_getorcreate   = 118
    ,dmmeta_FieldId_pool                  = 119
    ,dmmeta_FieldId_sortxref              = 120
    ,dmmeta_FieldId_pack                  = 121
    ,dmmeta_FieldId_fldoffset_asserts     = 122
    ,dmmeta_FieldId_numtype               = 123
    ,dmmeta_FieldId_min_len               = 124
    ,dmmeta_FieldId_pnew                  = 125
    ,dmmeta_FieldId_buftype               = 126
    ,dmmeta_FieldId_unique                = 127
    ,dmmeta_FieldId_isval                 = 128
    ,dmmeta_FieldId_cascins               = 129
    ,dmmeta_FieldId_usebasepool           = 130
    ,dmmeta_FieldId_cancopy               = 131
    ,dmmeta_FieldId_isxref                = 132
    ,dmmeta_FieldId_del                   = 133
    ,dmmeta_FieldId_up                    = 134
    ,dmmeta_FieldId_isnew                 = 135
    ,dmmeta_FieldId_hasalloc              = 136
    ,dmmeta_FieldId_inst                  = 137
    ,dmmeta_FieldId_varlen                = 138
    ,dmmeta_FieldId_length                = 139
    ,dmmeta_FieldId_strtype               = 140
    ,dmmeta_FieldId_pad                   = 141
    ,dmmeta_FieldId_ssimns                = 142
    ,dmmeta_FieldId_aliased               = 143
    ,dmmeta_FieldId_hashfld               = 144
    ,dmmeta_FieldId_tracefld              = 145
    ,dmmeta_FieldId_tracerec              = 146
    ,dmmeta_FieldId_inscond               = 147
    ,dmmeta_FieldId_via                   = 148
    ,dmmeta_FieldId_viafld                = 149
    ,dmmeta_FieldId_keyfld                = 150
};

enum { dmmeta_FieldIdEnum_N = 151 };

extern const char *  dmmeta_Hashtype_hashtype_Extern;   // Extern    fconst:dmmeta.Hashtype.hashtype/Extern
extern const char *  dmmeta_Hashtype_hashtype_CRC32;    // CRC32     fconst:dmmeta.Hashtype.hashtype/CRC32
extern const char *  dmmeta_Ns_ns_;             //               fconst:dmmeta.Ns.ns/
extern const char *  dmmeta_Ns_ns_abt;          // abt           fconst:dmmeta.Ns.ns/abt
extern const char *  dmmeta_Ns_ns_acr;          // acr           fconst:dmmeta.Ns.ns/acr
extern const char *  dmmeta_Ns_ns_acr_compl;    // acr_compl     fconst:dmmeta.Ns.ns/acr_compl
extern const char *  dmmeta_Ns_ns_acr_ed;       // acr_ed        fconst:dmmeta.Ns.ns/acr_ed
extern const char *  dmmeta_Ns_ns_acr_in;       // acr_in        fconst:dmmeta.Ns.ns/acr_in
extern const char *  dmmeta_Ns_ns_acr_my;       // acr_my        fconst:dmmeta.Ns.ns/acr_my
extern const char *  dmmeta_Ns_ns_algo;         // algo          fconst:dmmeta.Ns.ns/algo
extern const char *  dmmeta_Ns_ns_algo_lib;     // algo_lib      fconst:dmmeta.Ns.ns/algo_lib
extern const char *  dmmeta_Ns_ns_algo_pch;     // algo_pch      fconst:dmmeta.Ns.ns/algo_pch
extern const char *  dmmeta_Ns_ns_amc;          // amc           fconst:dmmeta.Ns.ns/amc
extern const char *  dmmeta_Ns_ns_amc_gc;       // amc_gc        fconst:dmmeta.Ns.ns/amc_gc
extern const char *  dmmeta_Ns_ns_amc_vis;      // amc_vis       fconst:dmmeta.Ns.ns/amc_vis
extern const char *  dmmeta_Ns_ns_amcdb;        // amcdb         fconst:dmmeta.Ns.ns/amcdb
extern const char *  dmmeta_Ns_ns_atf;          // atf           fconst:dmmeta.Ns.ns/atf
extern const char *  dmmeta_Ns_ns_atf_amc;      // atf_amc       fconst:dmmeta.Ns.ns/atf_amc
extern const char *  dmmeta_Ns_ns_atf_norm;     // atf_norm      fconst:dmmeta.Ns.ns/atf_norm
extern const char *  dmmeta_Ns_ns_atf_nrun;     // atf_nrun      fconst:dmmeta.Ns.ns/atf_nrun
extern const char *  dmmeta_Ns_ns_atf_unit;     // atf_unit      fconst:dmmeta.Ns.ns/atf_unit
extern const char *  dmmeta_Ns_ns_atfdb;        // atfdb         fconst:dmmeta.Ns.ns/atfdb
extern const char *  dmmeta_Ns_ns_bash2html;    // bash2html     fconst:dmmeta.Ns.ns/bash2html
extern const char *  dmmeta_Ns_ns_command;      // command       fconst:dmmeta.Ns.ns/command
extern const char *  dmmeta_Ns_ns_dev;          // dev           fconst:dmmeta.Ns.ns/dev
extern const char *  dmmeta_Ns_ns_dmmeta;       // dmmeta        fconst:dmmeta.Ns.ns/dmmeta
extern const char *  dmmeta_Ns_ns_gitlab;       // gitlab        fconst:dmmeta.Ns.ns/gitlab
extern const char *  dmmeta_Ns_ns_ietf;         // ietf          fconst:dmmeta.Ns.ns/ietf
extern const char *  dmmeta_Ns_ns_lib_ctype;    // lib_ctype     fconst:dmmeta.Ns.ns/lib_ctype
extern const char *  dmmeta_Ns_ns_lib_exec;     // lib_exec      fconst:dmmeta.Ns.ns/lib_exec
extern const char *  dmmeta_Ns_ns_lib_git;      // lib_git       fconst:dmmeta.Ns.ns/lib_git
extern const char *  dmmeta_Ns_ns_lib_iconv;    // lib_iconv     fconst:dmmeta.Ns.ns/lib_iconv
extern const char *  dmmeta_Ns_ns_lib_json;     // lib_json      fconst:dmmeta.Ns.ns/lib_json
extern const char *  dmmeta_Ns_ns_lib_mysql;    // lib_mysql     fconst:dmmeta.Ns.ns/lib_mysql
extern const char *  dmmeta_Ns_ns_lib_prot;     // lib_prot      fconst:dmmeta.Ns.ns/lib_prot
extern const char *  dmmeta_Ns_ns_lib_sql;      // lib_sql       fconst:dmmeta.Ns.ns/lib_sql
extern const char *  dmmeta_Ns_ns_mdbg;         // mdbg          fconst:dmmeta.Ns.ns/mdbg
extern const char *  dmmeta_Ns_ns_mysql2ssim;   // mysql2ssim    fconst:dmmeta.Ns.ns/mysql2ssim
extern const char *  dmmeta_Ns_ns_ntup;         // ntup          fconst:dmmeta.Ns.ns/ntup
extern const char *  dmmeta_Ns_ns_orgfile;      // orgfile       fconst:dmmeta.Ns.ns/orgfile
extern const char *  dmmeta_Ns_ns_report;       // report        fconst:dmmeta.Ns.ns/report
extern const char *  dmmeta_Ns_ns_src_func;     // src_func      fconst:dmmeta.Ns.ns/src_func
extern const char *  dmmeta_Ns_ns_src_hdr;      // src_hdr       fconst:dmmeta.Ns.ns/src_hdr
extern const char *  dmmeta_Ns_ns_src_lim;      // src_lim       fconst:dmmeta.Ns.ns/src_lim
extern const char *  dmmeta_Ns_ns_ssim2csv;     // ssim2csv      fconst:dmmeta.Ns.ns/ssim2csv
extern const char *  dmmeta_Ns_ns_ssim2mysql;   // ssim2mysql    fconst:dmmeta.Ns.ns/ssim2mysql
extern const char *  dmmeta_Ns_ns_strconv;      // strconv       fconst:dmmeta.Ns.ns/strconv
extern const char *  dmmeta_Nstype_nstype_exe;        // exe         fconst:dmmeta.Nstype.nstype/exe
extern const char *  dmmeta_Nstype_nstype_lib;        // lib         fconst:dmmeta.Nstype.nstype/lib
extern const char *  dmmeta_Nstype_nstype_none;       // none        fconst:dmmeta.Nstype.nstype/none
extern const char *  dmmeta_Nstype_nstype_objlist;    // objlist     fconst:dmmeta.Nstype.nstype/objlist
extern const char *  dmmeta_Nstype_nstype_pch;        // pch         fconst:dmmeta.Nstype.nstype/pch
extern const char *  dmmeta_Nstype_nstype_protocol;   // protocol    fconst:dmmeta.Nstype.nstype/protocol
extern const char *  dmmeta_Nstype_nstype_ssimdb;     // ssimdb      fconst:dmmeta.Nstype.nstype/ssimdb
extern const char *  dmmeta_Printfmt_printfmt_Auto;         // Auto          fconst:dmmeta.Printfmt.printfmt/Auto
extern const char *  dmmeta_Printfmt_printfmt_Bitset;       // Bitset        fconst:dmmeta.Printfmt.printfmt/Bitset
extern const char *  dmmeta_Printfmt_printfmt_CompactSep;   // CompactSep    fconst:dmmeta.Printfmt.printfmt/CompactSep
extern const char *  dmmeta_Printfmt_printfmt_Extern;       // Extern        fconst:dmmeta.Printfmt.printfmt/Extern
extern const char *  dmmeta_Printfmt_printfmt_Raw;          // Raw           fconst:dmmeta.Printfmt.printfmt/Raw
extern const char *  dmmeta_Printfmt_printfmt_Sep;          // Sep           fconst:dmmeta.Printfmt.printfmt/Sep
extern const char *  dmmeta_Printfmt_printfmt_Tuple;        // Tuple         fconst:dmmeta.Printfmt.printfmt/Tuple
extern const char *  dmmeta_Reftype_reftype_Atree;      // Atree       fconst:dmmeta.Reftype.reftype/Atree
extern const char *  dmmeta_Reftype_reftype_Base;       // Base        fconst:dmmeta.Reftype.reftype/Base
extern const char *  dmmeta_Reftype_reftype_Bheap;      // Bheap       fconst:dmmeta.Reftype.reftype/Bheap
extern const char *  dmmeta_Reftype_reftype_Bitfld;     // Bitfld      fconst:dmmeta.Reftype.reftype/Bitfld
extern const char *  dmmeta_Reftype_reftype_Blkpool;    // Blkpool     fconst:dmmeta.Reftype.reftype/Blkpool
extern const char *  dmmeta_Reftype_reftype_Charset;    // Charset     fconst:dmmeta.Reftype.reftype/Charset
extern const char *  dmmeta_Reftype_reftype_Count;      // Count       fconst:dmmeta.Reftype.reftype/Count
extern const char *  dmmeta_Reftype_reftype_Cppstack;   // Cppstack    fconst:dmmeta.Reftype.reftype/Cppstack
extern const char *  dmmeta_Reftype_reftype_Delptr;     // Delptr      fconst:dmmeta.Reftype.reftype/Delptr
extern const char *  dmmeta_Reftype_reftype_Exec;       // Exec        fconst:dmmeta.Reftype.reftype/Exec
extern const char *  dmmeta_Reftype_reftype_Fbuf;       // Fbuf        fconst:dmmeta.Reftype.reftype/Fbuf
extern const char *  dmmeta_Reftype_reftype_Global;     // Global      fconst:dmmeta.Reftype.reftype/Global
extern const char *  dmmeta_Reftype_reftype_Hook;       // Hook        fconst:dmmeta.Reftype.reftype/Hook
extern const char *  dmmeta_Reftype_reftype_Inlary;     // Inlary      fconst:dmmeta.Reftype.reftype/Inlary
extern const char *  dmmeta_Reftype_reftype_Lary;       // Lary        fconst:dmmeta.Reftype.reftype/Lary
extern const char *  dmmeta_Reftype_reftype_Llist;      // Llist       fconst:dmmeta.Reftype.reftype/Llist
extern const char *  dmmeta_Reftype_reftype_Lpool;      // Lpool       fconst:dmmeta.Reftype.reftype/Lpool
extern const char *  dmmeta_Reftype_reftype_Malloc;     // Malloc      fconst:dmmeta.Reftype.reftype/Malloc
extern const char *  dmmeta_Reftype_reftype_Opt;        // Opt         fconst:dmmeta.Reftype.reftype/Opt
extern const char *  dmmeta_Reftype_reftype_Pkey;       // Pkey        fconst:dmmeta.Reftype.reftype/Pkey
extern const char *  dmmeta_Reftype_reftype_Protocol;   // Protocol    fconst:dmmeta.Reftype.reftype/Protocol
extern const char *  dmmeta_Reftype_reftype_Ptr;        // Ptr         fconst:dmmeta.Reftype.reftype/Ptr
extern const char *  dmmeta_Reftype_reftype_Ptrary;     // Ptrary      fconst:dmmeta.Reftype.reftype/Ptrary
extern const char *  dmmeta_Reftype_reftype_RegxSql;    // RegxSql     fconst:dmmeta.Reftype.reftype/RegxSql
extern const char *  dmmeta_Reftype_reftype_Sbrk;       // Sbrk        fconst:dmmeta.Reftype.reftype/Sbrk
extern const char *  dmmeta_Reftype_reftype_Smallstr;   // Smallstr    fconst:dmmeta.Reftype.reftype/Smallstr
extern const char *  dmmeta_Reftype_reftype_Tary;       // Tary        fconst:dmmeta.Reftype.reftype/Tary
extern const char *  dmmeta_Reftype_reftype_Thash;      // Thash       fconst:dmmeta.Reftype.reftype/Thash
extern const char *  dmmeta_Reftype_reftype_Tpool;      // Tpool       fconst:dmmeta.Reftype.reftype/Tpool
extern const char *  dmmeta_Reftype_reftype_Upptr;      // Upptr       fconst:dmmeta.Reftype.reftype/Upptr
extern const char *  dmmeta_Reftype_reftype_Val;        // Val         fconst:dmmeta.Reftype.reftype/Val
extern const char *  dmmeta_Reftype_reftype_Varlen;     // Varlen      fconst:dmmeta.Reftype.reftype/Varlen
extern const char *  dmmeta_Reftype_reftype_ZSListMT;   // ZSListMT    fconst:dmmeta.Reftype.reftype/ZSListMT

// --- dmmeta_ReftypeCaseEnum

enum dmmeta_ReftypeCaseEnum {            // dmmeta.ReftypeCase.reftype
     dmmeta_ReftypeCase_Atree      = 1
    ,dmmeta_ReftypeCase_Base       = 2
    ,dmmeta_ReftypeCase_Bheap      = 3
    ,dmmeta_ReftypeCase_Bitfld     = 4
    ,dmmeta_ReftypeCase_Blkpool    = 5
    ,dmmeta_ReftypeCase_Charset    = 6
    ,dmmeta_ReftypeCase_Count      = 7
    ,dmmeta_ReftypeCase_Cppstack   = 8
    ,dmmeta_ReftypeCase_Delptr     = 9
    ,dmmeta_ReftypeCase_Exec       = 10
    ,dmmeta_ReftypeCase_Fbuf       = 11
    ,dmmeta_ReftypeCase_Global     = 12
    ,dmmeta_ReftypeCase_Hook       = 13
    ,dmmeta_ReftypeCase_Inlary     = 14
    ,dmmeta_ReftypeCase_Lary       = 15
    ,dmmeta_ReftypeCase_Llist      = 16
    ,dmmeta_ReftypeCase_Lpool      = 17
    ,dmmeta_ReftypeCase_Malloc     = 18
    ,dmmeta_ReftypeCase_Opt        = 19
    ,dmmeta_ReftypeCase_Pkey       = 20
    ,dmmeta_ReftypeCase_Protocol   = 21
    ,dmmeta_ReftypeCase_Ptr        = 22
    ,dmmeta_ReftypeCase_Ptrary     = 23
    ,dmmeta_ReftypeCase_RegxSql    = 24
    ,dmmeta_ReftypeCase_Sbrk       = 25
    ,dmmeta_ReftypeCase_Smallstr   = 26
    ,dmmeta_ReftypeCase_Tary       = 27
    ,dmmeta_ReftypeCase_Thash      = 28
    ,dmmeta_ReftypeCase_Tpool      = 29
    ,dmmeta_ReftypeCase_Upptr      = 30
    ,dmmeta_ReftypeCase_Val        = 31
    ,dmmeta_ReftypeCase_Varlen     = 32
    ,dmmeta_ReftypeCase_ZSListMT   = 33
};

enum { dmmeta_ReftypeCaseEnum_N = 33 };


// --- dmmeta_ReftypeIdEnum

enum dmmeta_ReftypeIdEnum {            // dmmeta.ReftypeId.value
     dmmeta_ReftypeId_Atree      = 0
    ,dmmeta_ReftypeId_Base       = 1
    ,dmmeta_ReftypeId_Bheap      = 2
    ,dmmeta_ReftypeId_Bitfld     = 3
    ,dmmeta_ReftypeId_Blkpool    = 4
    ,dmmeta_ReftypeId_Charset    = 5
    ,dmmeta_ReftypeId_Count      = 6
    ,dmmeta_ReftypeId_Cppstack   = 7
    ,dmmeta_ReftypeId_Delptr     = 8
    ,dmmeta_ReftypeId_Exec       = 9
    ,dmmeta_ReftypeId_Fbuf       = 10
    ,dmmeta_ReftypeId_Global     = 11
    ,dmmeta_ReftypeId_Hook       = 12
    ,dmmeta_ReftypeId_Inlary     = 13
    ,dmmeta_ReftypeId_Lary       = 14
    ,dmmeta_ReftypeId_Llist      = 15
    ,dmmeta_ReftypeId_Lpool      = 16
    ,dmmeta_ReftypeId_Malloc     = 17
    ,dmmeta_ReftypeId_Opt        = 18
    ,dmmeta_ReftypeId_Pkey       = 19
    ,dmmeta_ReftypeId_Protocol   = 20
    ,dmmeta_ReftypeId_Ptr        = 21
    ,dmmeta_ReftypeId_Ptrary     = 22
    ,dmmeta_ReftypeId_RegxSql    = 23
    ,dmmeta_ReftypeId_Sbrk       = 24
    ,dmmeta_ReftypeId_Smallstr   = 25
    ,dmmeta_ReftypeId_Tary       = 26
    ,dmmeta_ReftypeId_Thash      = 27
    ,dmmeta_ReftypeId_Tpool      = 28
    ,dmmeta_ReftypeId_Upptr      = 29
    ,dmmeta_ReftypeId_Val        = 30
    ,dmmeta_ReftypeId_Varlen     = 31
    ,dmmeta_ReftypeId_ZSListMT   = 32
};

enum { dmmeta_ReftypeIdEnum_N = 33 };

extern const char *  dmmeta_Sorttype_sorttype_QuickSort;       // QuickSort        fconst:dmmeta.Sorttype.sorttype/QuickSort
extern const char *  dmmeta_Sorttype_sorttype_InsertionSort;   // InsertionSort    fconst:dmmeta.Sorttype.sorttype/InsertionSort
extern const char *  dmmeta_Sorttype_sorttype_HeapSort;        // HeapSort         fconst:dmmeta.Sorttype.sorttype/HeapSort
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_bltin;           // amcdb.bltin            fconst:dmmeta.Ssimfile.ssimfile/amcdb.bltin
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_curs;            // amcdb.curs             fconst:dmmeta.Ssimfile.ssimfile/amcdb.curs
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_gen;             // amcdb.gen              fconst:dmmeta.Ssimfile.ssimfile/amcdb.gen
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tclass;          // amcdb.tclass           fconst:dmmeta.Ssimfile.ssimfile/amcdb.tclass
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tcursor;         // amcdb.tcursor          fconst:dmmeta.Ssimfile.ssimfile/amcdb.tcursor
extern const char *  dmmeta_Ssimfile_ssimfile_amcdb_tfunc;           // amcdb.tfunc            fconst:dmmeta.Ssimfile.ssimfile/amcdb.tfunc
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_amctest;         // atfdb.amctest          fconst:dmmeta.Ssimfile.ssimfile/atfdb.amctest
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_normcheck;       // atfdb.normcheck        fconst:dmmeta.Ssimfile.ssimfile/atfdb.normcheck
extern const char *  dmmeta_Ssimfile_ssimfile_atfdb_unittest;        // atfdb.unittest         fconst:dmmeta.Ssimfile.ssimfile/atfdb.unittest
extern const char *  dmmeta_Ssimfile_ssimfile_dev_arch;              // dev.arch               fconst:dmmeta.Ssimfile.ssimfile/dev.arch
extern const char *  dmmeta_Ssimfile_ssimfile_dev_badline;           // dev.badline            fconst:dmmeta.Ssimfile.ssimfile/dev.badline
extern const char *  dmmeta_Ssimfile_ssimfile_dev_builddir;          // dev.builddir           fconst:dmmeta.Ssimfile.ssimfile/dev.builddir
extern const char *  dmmeta_Ssimfile_ssimfile_dev_cfg;               // dev.cfg                fconst:dmmeta.Ssimfile.ssimfile/dev.cfg
extern const char *  dmmeta_Ssimfile_ssimfile_dev_compiler;          // dev.compiler           fconst:dmmeta.Ssimfile.ssimfile/dev.compiler
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitfile;           // dev.gitfile            fconst:dmmeta.Ssimfile.ssimfile/dev.gitfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitinfo;           // dev.gitinfo            fconst:dmmeta.Ssimfile.ssimfile/dev.gitinfo
extern const char *  dmmeta_Ssimfile_ssimfile_dev_gitlab_auth;       // dev.gitlab_auth        fconst:dmmeta.Ssimfile.ssimfile/dev.gitlab_auth
extern const char *  dmmeta_Ssimfile_ssimfile_dev_htmlentity;        // dev.htmlentity         fconst:dmmeta.Ssimfile.ssimfile/dev.htmlentity
extern const char *  dmmeta_Ssimfile_ssimfile_dev_license;           // dev.license            fconst:dmmeta.Ssimfile.ssimfile/dev.license
extern const char *  dmmeta_Ssimfile_ssimfile_dev_linelim;           // dev.linelim            fconst:dmmeta.Ssimfile.ssimfile/dev.linelim
extern const char *  dmmeta_Ssimfile_ssimfile_dev_noindent;          // dev.noindent           fconst:dmmeta.Ssimfile.ssimfile/dev.noindent
extern const char *  dmmeta_Ssimfile_ssimfile_dev_opt_type;          // dev.opt_type           fconst:dmmeta.Ssimfile.ssimfile/dev.opt_type
extern const char *  dmmeta_Ssimfile_ssimfile_dev_readme;            // dev.readme             fconst:dmmeta.Ssimfile.ssimfile/dev.readme
extern const char *  dmmeta_Ssimfile_ssimfile_dev_sandbox;           // dev.sandbox            fconst:dmmeta.Ssimfile.ssimfile/dev.sandbox
extern const char *  dmmeta_Ssimfile_ssimfile_dev_scriptfile;        // dev.scriptfile         fconst:dmmeta.Ssimfile.ssimfile/dev.scriptfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_srcfile;           // dev.srcfile            fconst:dmmeta.Ssimfile.ssimfile/dev.srcfile
extern const char *  dmmeta_Ssimfile_ssimfile_dev_syslib;            // dev.syslib             fconst:dmmeta.Ssimfile.ssimfile/dev.syslib
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targdep;           // dev.targdep            fconst:dmmeta.Ssimfile.ssimfile/dev.targdep
extern const char *  dmmeta_Ssimfile_ssimfile_dev_target;            // dev.target             fconst:dmmeta.Ssimfile.ssimfile/dev.target
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targsrc;           // dev.targsrc            fconst:dmmeta.Ssimfile.ssimfile/dev.targsrc
extern const char *  dmmeta_Ssimfile_ssimfile_dev_targsyslib;        // dev.targsyslib         fconst:dmmeta.Ssimfile.ssimfile/dev.targsyslib
extern const char *  dmmeta_Ssimfile_ssimfile_dev_timefmt;           // dev.timefmt            fconst:dmmeta.Ssimfile.ssimfile/dev.timefmt
extern const char *  dmmeta_Ssimfile_ssimfile_dev_tool_opt;          // dev.tool_opt           fconst:dmmeta.Ssimfile.ssimfile/dev.tool_opt
extern const char *  dmmeta_Ssimfile_ssimfile_dev_uname;             // dev.uname              fconst:dmmeta.Ssimfile.ssimfile/dev.uname
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_anonfld;        // dmmeta.anonfld         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.anonfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_argvtype;       // dmmeta.argvtype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.argvtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_basepool;       // dmmeta.basepool        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.basepool
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_bitfld;         // dmmeta.bitfld          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.bitfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cafter;         // dmmeta.cafter          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cafter
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cascdel;        // dmmeta.cascdel         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cascdel
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ccmp;           // dmmeta.ccmp            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ccmp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cdecl;          // dmmeta.cdecl           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cdecl
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cdflt;          // dmmeta.cdflt           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cdflt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cextern;        // dmmeta.cextern         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cextern
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cfmt;           // dmmeta.cfmt            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cget;           // dmmeta.cget            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cget
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_charset;        // dmmeta.charset         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.charset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_chash;          // dmmeta.chash           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.chash
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cppfunc;        // dmmeta.cppfunc         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cppfunc
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cppkeyword;     // dmmeta.cppkeyword      fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cppkeyword
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cpptype;        // dmmeta.cpptype         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cpptype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_csize;          // dmmeta.csize           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.csize
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_cstr;           // dmmeta.cstr            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.cstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ctype;          // dmmeta.ctype           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ctype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ctypelen;       // dmmeta.ctypelen        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ctypelen
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispatch;       // dmmeta.dispatch        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispatch
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispatch_msg;   // dmmeta.dispatch_msg    fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispatch_msg
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispctx;        // dmmeta.dispctx         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispctx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispfilter;     // dmmeta.dispfilter      fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispfilter
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_dispsig;        // dmmeta.dispsig         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.dispsig
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_disptrace;      // dmmeta.disptrace       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.disptrace
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbase;          // dmmeta.fbase           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbase
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbigend;        // dmmeta.fbigend         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbigend
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbitset;        // dmmeta.fbitset         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbitset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbuf;           // dmmeta.fbuf            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbuf
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbufdir;        // dmmeta.fbufdir         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbufdir
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fbuftype;       // dmmeta.fbuftype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fbuftype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcast;          // dmmeta.fcast           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcast
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcleanup;       // dmmeta.fcleanup        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcleanup
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmap;          // dmmeta.fcmap           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmap
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmdline;       // dmmeta.fcmdline        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmdline
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcmp;           // dmmeta.fcmp            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcmp
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcompact;       // dmmeta.fcompact        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcompact
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fconst;         // dmmeta.fconst          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fconst
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fcurs;          // dmmeta.fcurs           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fcurs
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fdec;           // dmmeta.fdec            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fdec
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fdelay;         // dmmeta.fdelay          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fdelay
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_field;          // dmmeta.field           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.field
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_findrem;        // dmmeta.findrem         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.findrem
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_finput;         // dmmeta.finput          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.finput
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fldoffset;      // dmmeta.fldoffset       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fldoffset
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_floadtuples;    // dmmeta.floadtuples     fconst:dmmeta.Ssimfile.ssimfile/dmmeta.floadtuples
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fnoremove;      // dmmeta.fnoremove       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fnoremove
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_foutput;        // dmmeta.foutput         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.foutput
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fprefix;        // dmmeta.fprefix         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fprefix
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fregx;          // dmmeta.fregx           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fregx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fsort;          // dmmeta.fsort           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fsort
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fstep;          // dmmeta.fstep           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fstep
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ftrace;         // dmmeta.ftrace          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ftrace
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ftuple;         // dmmeta.ftuple          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ftuple
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_funique;        // dmmeta.funique         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.funique
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fuserinit;      // dmmeta.fuserinit       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fuserinit
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_fwddecl;        // dmmeta.fwddecl         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.fwddecl
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gconst;         // dmmeta.gconst          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gconst
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gstatic;        // dmmeta.gstatic         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gstatic
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_gsymbol;        // dmmeta.gsymbol         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.gsymbol
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_hashtype;       // dmmeta.hashtype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.hashtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_hook;           // dmmeta.hook            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.hook
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_inlary;         // dmmeta.inlary          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.inlary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_lenfld;         // dmmeta.lenfld          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.lenfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_listtype;       // dmmeta.listtype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.listtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_llist;          // dmmeta.llist           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.llist
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_main;           // dmmeta.main            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.main
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_msgtype;        // dmmeta.msgtype         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.msgtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nocascdel;      // dmmeta.nocascdel       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nocascdel
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nossimfile;     // dmmeta.nossimfile      fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nossimfile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_noxref;         // dmmeta.noxref          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.noxref
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ns;             // dmmeta.ns              fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ns
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsdb;           // dmmeta.nsdb            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsdb
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsinclude;      // dmmeta.nsinclude       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsinclude
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsproto;        // dmmeta.nsproto         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsproto
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nstype;         // dmmeta.nstype          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nstype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsversion;      // dmmeta.nsversion       fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsversion
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_nsx;            // dmmeta.nsx             fconst:dmmeta.Ssimfile.ssimfile/dmmeta.nsx
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_numstr;         // dmmeta.numstr          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.numstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pack;           // dmmeta.pack            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pack
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pmaskfld;       // dmmeta.pmaskfld        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pmaskfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pnew;           // dmmeta.pnew            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pnew
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_pnewtype;       // dmmeta.pnewtype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.pnewtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_printfmt;       // dmmeta.printfmt        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.printfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ptrary;         // dmmeta.ptrary          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ptrary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_reftype;        // dmmeta.reftype         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.reftype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_rowid;          // dmmeta.rowid           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.rowid
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_smallstr;       // dmmeta.smallstr        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.smallstr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sortfld;        // dmmeta.sortfld         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sortfld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sorttype;       // dmmeta.sorttype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sorttype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_sqltype;        // dmmeta.sqltype         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.sqltype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimfile;       // dmmeta.ssimfile        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimfile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimsort;       // dmmeta.ssimsort        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimsort
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_ssimvolatile;   // dmmeta.ssimvolatile    fconst:dmmeta.Ssimfile.ssimfile/dmmeta.ssimvolatile
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_steptype;       // dmmeta.steptype        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.steptype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_strfmt;         // dmmeta.strfmt          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.strfmt
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_strtype;        // dmmeta.strtype         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.strtype
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_substr;         // dmmeta.substr          fconst:dmmeta.Ssimfile.ssimfile/dmmeta.substr
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tary;           // dmmeta.tary            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tary
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_thash;          // dmmeta.thash           fconst:dmmeta.Ssimfile.ssimfile/dmmeta.thash
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tracefld;       // dmmeta.tracefld        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tracefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_tracerec;       // dmmeta.tracerec        fconst:dmmeta.Ssimfile.ssimfile/dmmeta.tracerec
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_typefld;        // dmmeta.typefld         fconst:dmmeta.Ssimfile.ssimfile/dmmeta.typefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_usertracefld;   // dmmeta.usertracefld    fconst:dmmeta.Ssimfile.ssimfile/dmmeta.usertracefld
extern const char *  dmmeta_Ssimfile_ssimfile_dmmeta_xref;           // dmmeta.xref            fconst:dmmeta.Ssimfile.ssimfile/dmmeta.xref
extern const char *  dmmeta_Steptype_steptype_Callback;        // Callback         fconst:dmmeta.Steptype.steptype/Callback
extern const char *  dmmeta_Steptype_steptype_Extern;          // Extern           fconst:dmmeta.Steptype.steptype/Extern
extern const char *  dmmeta_Steptype_steptype_Inline;          // Inline           fconst:dmmeta.Steptype.steptype/Inline
extern const char *  dmmeta_Steptype_steptype_InlineOnce;      // InlineOnce       fconst:dmmeta.Steptype.steptype/InlineOnce
extern const char *  dmmeta_Steptype_steptype_InlineRecur;     // InlineRecur      fconst:dmmeta.Steptype.steptype/InlineRecur
extern const char *  dmmeta_Steptype_steptype_TimeHookRecur;   // TimeHookRecur    fconst:dmmeta.Steptype.steptype/TimeHookRecur
extern const char *  dmmeta_Strfmt_strfmt_Argv;      // Argv       fconst:dmmeta.Strfmt.strfmt/Argv
extern const char *  dmmeta_Strfmt_strfmt_ArgvGnu;   // ArgvGnu    fconst:dmmeta.Strfmt.strfmt/ArgvGnu
extern const char *  dmmeta_Strfmt_strfmt_Json;      // Json       fconst:dmmeta.Strfmt.strfmt/Json
extern const char *  dmmeta_Strfmt_strfmt_String;    // String     fconst:dmmeta.Strfmt.strfmt/String
extern const char *  dmmeta_Strfmt_strfmt_Tuple;     // Tuple      fconst:dmmeta.Strfmt.strfmt/Tuple
extern const char *  dmmeta_Strtype_strtype_rpascal;    // rpascal     fconst:dmmeta.Strtype.strtype/rpascal
extern const char *  dmmeta_Strtype_strtype_rightpad;   // rightpad    fconst:dmmeta.Strtype.strtype/rightpad
extern const char *  dmmeta_Strtype_strtype_leftpad;    // leftpad     fconst:dmmeta.Strtype.strtype/leftpad
namespace dmmeta { struct Anonfld; }
namespace dmmeta { struct Argvtype; }
namespace dmmeta { struct Basepool; }
namespace dmmeta { struct Bitfld; }
namespace dmmeta { struct Buftype; }
namespace dmmeta { struct BuftypeId; }
namespace dmmeta { struct Cafter; }
namespace dmmeta { struct Cascdel; }
namespace dmmeta { struct Ccmp; }
namespace dmmeta { struct Cdecl; }
namespace dmmeta { struct CppExpr; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cextern; }
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cget; }
namespace dmmeta { struct Charset; }
namespace dmmeta { struct Chash; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Cppkeyword; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Csize; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace dmmeta { struct Ctypelen; }
namespace dmmeta { struct Dispatch; }
namespace dmmeta { struct DispatchMsg; }
namespace dmmeta { struct Dispctx; }
namespace dmmeta { struct Dispfilter; }
namespace dmmeta { struct Dispsig; }
namespace dmmeta { struct Dispsigcheck; }
namespace dmmeta { struct Disptrace; }
namespace dmmeta { struct Fbase; }
namespace dmmeta { struct Fbigend; }
namespace dmmeta { struct Fbitset; }
namespace dmmeta { struct Fbuf; }
namespace dmmeta { struct Fbufdir; }
namespace dmmeta { struct Fbuftype; }
namespace dmmeta { struct Fcast; }
namespace dmmeta { struct Fcleanup; }
namespace dmmeta { struct Fcmap; }
namespace dmmeta { struct Fcmdline; }
namespace dmmeta { struct Fcmp; }
namespace dmmeta { struct Fcompact; }
namespace dmmeta { struct Fconst; }
namespace dmmeta { struct Fcurs; }
namespace dmmeta { struct Fdec; }
namespace dmmeta { struct Fdelay; }
namespace dmmeta { struct Field; }
namespace dmmeta { struct FieldId; }
namespace dmmeta { struct Findrem; }
namespace dmmeta { struct Finput; }
namespace dmmeta { struct Fldoffset; }
namespace dmmeta { struct Floadtuples; }
namespace dmmeta { struct Fnoremove; }
namespace dmmeta { struct Foutput; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Fregx; }
namespace dmmeta { struct Fsort; }
namespace dmmeta { struct Fstep; }
namespace dmmeta { struct Ftrace; }
namespace dmmeta { struct Ftuple; }
namespace dmmeta { struct Func; }
namespace dmmeta { struct Funique; }
namespace dmmeta { struct Fuserinit; }
namespace dmmeta { struct Fwddecl; }
namespace dmmeta { struct Gconst; }
namespace dmmeta { struct Gstatic; }
namespace dmmeta { struct Gsymbol; }
namespace dmmeta { struct Hashtype; }
namespace dmmeta { struct Hook; }
namespace dmmeta { struct Inlary; }
namespace dmmeta { struct Lenfld; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Llist; }
namespace dmmeta { struct Main; }
namespace dmmeta { struct Msgtype; }
namespace dmmeta { struct Nocascdel; }
namespace dmmeta { struct Nossimfile; }
namespace dmmeta { struct Noxref; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Nsinclude; }
namespace dmmeta { struct Nsproto; }
namespace dmmeta { struct Nstype; }
namespace dmmeta { struct Nsversion; }
namespace dmmeta { struct Nsx; }
namespace dmmeta { struct Numstr; }
namespace dmmeta { struct Pack; }
namespace dmmeta { struct Pmaskfld; }
namespace dmmeta { struct Pnew; }
namespace dmmeta { struct Printfmt; }
namespace dmmeta { struct Ptrary; }
namespace dmmeta { struct Reftype; }
namespace dmmeta { struct ReftypeCase; }
namespace dmmeta { struct ReftypeId; }
namespace dmmeta { struct Rowid; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Sortfld; }
namespace dmmeta { struct Sorttype; }
namespace dmmeta { struct Sqltype; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimsort; }
namespace dmmeta { struct Ssimvolatile; }
namespace dmmeta { struct Steptype; }
namespace dmmeta { struct Strfmt; }
namespace dmmeta { struct Strtype; }
namespace dmmeta { struct Substr; }
namespace dmmeta { struct Tary; }
namespace dmmeta { struct Thash; }
namespace dmmeta { struct Tracefld; }
namespace dmmeta { struct Tracerec; }
namespace dmmeta { struct Typefld; }
namespace dmmeta { struct Usertracefld; }
namespace dmmeta { struct Xref; }
namespace dmmeta {
    typedef algo::Smallstr50 BuftypePkey;
    typedef u8 BuftypeIdPkey;
    typedef algo::Smallstr50 CafterPkey;
    typedef algo::Smallstr250 CppExprPkey;
    typedef algo::Smallstr50 CfmtPkey;
    typedef algo::Smallstr20 CppkeywordPkey;
    typedef algo::Smallstr50 CtypePkey;
    typedef algo::Smallstr50 DispatchPkey;
    typedef algo::Smallstr100 DispatchMsgPkey;
    typedef algo::Smallstr50 DispsigPkey;
    typedef algo::Smallstr50 FbufdirPkey;
    typedef algo::Smallstr50 FbuftypePkey;
    typedef algo::Smallstr250 FcmapPkey;
    typedef algo::Smallstr100 FconstPkey;
    typedef algo::Smallstr50 FcursPkey;
    typedef algo::Smallstr100 FieldPkey;
    typedef algo::Smallstr5 FprefixPkey;
    typedef algo::Smallstr100 FstepPkey;
    typedef algo::Smallstr100 FuncPkey;
    typedef algo::Smallstr100 FwddeclPkey;
    typedef algo::Smallstr50 GsymbolPkey;
    typedef algo::Smallstr50 HashtypePkey;
    typedef algo::Smallstr5 ListtypePkey;
    typedef algo::Smallstr16 NsPkey;
    typedef algo::Smallstr16 NsdbPkey;
    typedef algo::Smallstr50 NsincludePkey;
    typedef algo::Smallstr50 NstypePkey;
    typedef algo::Smallstr100 PnewPkey;
    typedef algo::Smallstr50 PrintfmtPkey;
    typedef algo::Smallstr50 ReftypePkey;
    typedef u8 ReftypeIdPkey;
    typedef algo::Smallstr100 SmallstrPkey;
    typedef algo::Smallstr50 SorttypePkey;
    typedef algo::Smallstr50 SsimfilePkey;
    typedef algo::Smallstr50 SteptypePkey;
    typedef algo::Smallstr50 StrfmtPkey;
    typedef algo::Smallstr50 StrtypePkey;
    typedef algo::Smallstr100 SubstrPkey;
    typedef algo::Smallstr100 TracefldPkey;
    typedef algo::Smallstr50 TracerecPkey;
    typedef algo::Smallstr100 XrefPkey;
}//pkey typedefs
namespace dmmeta {

// --- dmmeta.Anonfld
struct Anonfld { // dmmeta.Anonfld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Anonfld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Anonfld();
};

bool                 Anonfld_ReadFieldMaybe(dmmeta::Anonfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Anonfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Anonfld_ReadStrptrMaybe(dmmeta::Anonfld &parent, algo::strptr in_str);
// print string representation of dmmeta::Anonfld to string LHS, no header -- cprint:dmmeta.Anonfld.String
void                 Anonfld_Print(dmmeta::Anonfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Argvtype
struct Argvtype { // dmmeta.Argvtype
    algo::Smallstr50   ctype;      //
    algo::Smallstr50   argvtype;   //
    algo::Comment      comment;    //
    Argvtype();
};

bool                 Argvtype_ReadFieldMaybe(dmmeta::Argvtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Argvtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Argvtype_ReadStrptrMaybe(dmmeta::Argvtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Argvtype to string LHS, no header -- cprint:dmmeta.Argvtype.String
void                 Argvtype_Print(dmmeta::Argvtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Basepool
struct Basepool { // dmmeta.Basepool
    algo::Smallstr100   field;   //
    algo::Smallstr100   base;    //
    explicit Basepool(const algo::strptr&            in_field
        ,const algo::strptr&            in_base);
    Basepool();
};

bool                 Basepool_ReadFieldMaybe(dmmeta::Basepool &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Basepool from an ascii string.
// The format of the string is an ssim Tuple
bool                 Basepool_ReadStrptrMaybe(dmmeta::Basepool &parent, algo::strptr in_str);
// print string representation of dmmeta::Basepool to string LHS, no header -- cprint:dmmeta.Basepool.String
void                 Basepool_Print(dmmeta::Basepool & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Bitfld
struct Bitfld { // dmmeta.Bitfld
    algo::Smallstr100   field;      //
    i32                 offset;     //   0  Offset, in bits, within parent field
    i32                 width;      //   0  Width, in bits, within parent field.
    algo::Smallstr100   srcfield;   //
    algo::Comment       comment;    //
    explicit Bitfld(const algo::strptr&            in_field
        ,i32                            in_offset
        ,i32                            in_width
        ,const algo::strptr&            in_srcfield
        ,const algo::Comment&           in_comment);
    Bitfld();
};

algo::Smallstr50     name_Get(dmmeta::Bitfld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Bitfld_name_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Bitfld_ReadFieldMaybe(dmmeta::Bitfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Bitfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Bitfld_ReadStrptrMaybe(dmmeta::Bitfld &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Bitfld_Init(dmmeta::Bitfld& parent);
// print string representation of dmmeta::Bitfld to string LHS, no header -- cprint:dmmeta.Bitfld.String
void                 Bitfld_Print(dmmeta::Bitfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Buftype
struct Buftype { // dmmeta.Buftype
    algo::Smallstr50   pnewtype;   //
    algo::Comment      comment;    //
    explicit Buftype(const algo::strptr&            in_pnewtype
        ,const algo::Comment&           in_comment);
    Buftype();
};

bool                 Buftype_ReadFieldMaybe(dmmeta::Buftype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Buftype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Buftype_ReadStrptrMaybe(dmmeta::Buftype &parent, algo::strptr in_str);
// print string representation of dmmeta::Buftype to string LHS, no header -- cprint:dmmeta.Buftype.String
void                 Buftype_Print(dmmeta::Buftype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.BuftypeId
struct BuftypeId { // dmmeta.BuftypeId
    u8   value;   //   0
    inline operator dmmeta_BuftypeIdEnum() const;
    explicit BuftypeId(u8                             in_value);
    BuftypeId(dmmeta_BuftypeIdEnum arg);
    BuftypeId();
};

// Get value of field as enum type
dmmeta_BuftypeIdEnum value_GetEnum(const dmmeta::BuftypeId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(dmmeta::BuftypeId& parent, dmmeta_BuftypeIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const dmmeta::BuftypeId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const dmmeta::BuftypeId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(dmmeta::BuftypeId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(dmmeta::BuftypeId& parent, algo::strptr rhs, dmmeta_BuftypeIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(dmmeta::BuftypeId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of dmmeta::BuftypeId from an ascii string.
// The format of the string is the format of the dmmeta::BuftypeId's only field
bool                 BuftypeId_ReadStrptrMaybe(dmmeta::BuftypeId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 BuftypeId_Init(dmmeta::BuftypeId& parent);
// print string representation of dmmeta::BuftypeId to string LHS, no header -- cprint:dmmeta.BuftypeId.String
void                 BuftypeId_Print(dmmeta::BuftypeId row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cafter
struct Cafter { // dmmeta.Cafter
    algo::Smallstr50   cafter;    //
    algo::Comment      comment;   //
    Cafter();
};

algo::Smallstr50     ctype_Get(dmmeta::Cafter& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cafter_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     after_Get(dmmeta::Cafter& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cafter_after_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Cafter_Concat_ctype_after( const algo::strptr& ctype ,const algo::strptr& after );
bool                 Cafter_ReadFieldMaybe(dmmeta::Cafter &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cafter from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cafter_ReadStrptrMaybe(dmmeta::Cafter &parent, algo::strptr in_str);
// print string representation of dmmeta::Cafter to string LHS, no header -- cprint:dmmeta.Cafter.String
void                 Cafter_Print(dmmeta::Cafter & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cascdel
struct Cascdel { // dmmeta.Cascdel: Request cascading delete of referenced rows
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Cascdel(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Cascdel();
};

bool                 Cascdel_ReadFieldMaybe(dmmeta::Cascdel &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cascdel from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cascdel_ReadStrptrMaybe(dmmeta::Cascdel &parent, algo::strptr in_str);
// print string representation of dmmeta::Cascdel to string LHS, no header -- cprint:dmmeta.Cascdel.String
void                 Cascdel_Print(dmmeta::Cascdel & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ccmp
struct Ccmp { // dmmeta.Ccmp: Generate hash function
    algo::Smallstr50   ctype;     // Target ctype
    bool               extrn;     //   false  Whether implementation is external
    bool               genop;     //   false  Generate C++ comparison operators (<,>, etc)
    bool               order;     //   false
    bool               minmax;    //   false
    algo::Comment      comment;   //
    explicit Ccmp(const algo::strptr&            in_ctype
        ,bool                           in_extrn
        ,bool                           in_genop
        ,bool                           in_order
        ,bool                           in_minmax
        ,const algo::Comment&           in_comment);
    Ccmp();
};

bool                 Ccmp_ReadFieldMaybe(dmmeta::Ccmp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ccmp from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ccmp_ReadStrptrMaybe(dmmeta::Ccmp &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ccmp_Init(dmmeta::Ccmp& parent);
// print string representation of dmmeta::Ccmp to string LHS, no header -- cprint:dmmeta.Ccmp.String
void                 Ccmp_Print(dmmeta::Ccmp & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cdecl
struct Cdecl { // dmmeta.Cdecl
    algo::Smallstr50   ctype;       //
    bool               fwddecl;     //   false
    bool               gen_using;   //   false
    algo::Comment      comment;     //
    Cdecl();
};

bool                 Cdecl_ReadFieldMaybe(dmmeta::Cdecl &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cdecl from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cdecl_ReadStrptrMaybe(dmmeta::Cdecl &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cdecl_Init(dmmeta::Cdecl& parent);
// print string representation of dmmeta::Cdecl to string LHS, no header -- cprint:dmmeta.Cdecl.String
void                 Cdecl_Print(dmmeta::Cdecl & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.CppExpr
struct CppExpr { // dmmeta.CppExpr
    algo::Smallstr250   value;   // expression
    explicit CppExpr(const algo::strptr&            in_value);
    CppExpr();
};

// Read fields of dmmeta::CppExpr from an ascii string.
// The format of the string is the format of the dmmeta::CppExpr's only field
bool                 CppExpr_ReadStrptrMaybe(dmmeta::CppExpr &parent, algo::strptr in_str);
// print string representation of dmmeta::CppExpr to string LHS, no header -- cprint:dmmeta.CppExpr.String
void                 CppExpr_Print(dmmeta::CppExpr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cdflt
struct Cdflt { // dmmeta.Cdflt
    algo::Smallstr50   ctype;      //
    dmmeta::CppExpr    dflt;       //
    dmmeta::CppExpr    cppdflt;    //
    algo::Smallstr50   ssimdflt;   //
    algo::Comment      comment;    //
    Cdflt();
};

bool                 Cdflt_ReadFieldMaybe(dmmeta::Cdflt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cdflt from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cdflt_ReadStrptrMaybe(dmmeta::Cdflt &parent, algo::strptr in_str);
// print string representation of dmmeta::Cdflt to string LHS, no header -- cprint:dmmeta.Cdflt.String
void                 Cdflt_Print(dmmeta::Cdflt & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cextern
struct Cextern { // dmmeta.Cextern: Externally defined ctype (a struct from system header, or from a c++ library)
    algo::Smallstr50   ctype;        // Ctype in question
    bool               initmemset;   //   false  Initialize using memset? (set this to Y for all C structs)
    bool               isstruct;     //   false
    explicit Cextern(const algo::strptr&            in_ctype
        ,bool                           in_initmemset
        ,bool                           in_isstruct);
    Cextern();
};

bool                 Cextern_ReadFieldMaybe(dmmeta::Cextern &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cextern from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cextern_ReadStrptrMaybe(dmmeta::Cextern &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cextern_Init(dmmeta::Cextern& parent);
// print string representation of dmmeta::Cextern to string LHS, no header -- cprint:dmmeta.Cextern.String
void                 Cextern_Print(dmmeta::Cextern & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cfmt
struct Cfmt { // dmmeta.Cfmt
    algo::Smallstr50   cfmt;       //
    algo::Smallstr50   printfmt;   //
    bool               read;       //   false
    bool               print;      //   false
    algo::Smallstr20   sep;        //
    bool               genop;      //   false
    algo::Comment      comment;    //
    explicit Cfmt(const algo::strptr&            in_cfmt
        ,const algo::strptr&            in_printfmt
        ,bool                           in_read
        ,bool                           in_print
        ,const algo::strptr&            in_sep
        ,bool                           in_genop
        ,const algo::Comment&           in_comment);
    Cfmt();
};

algo::Smallstr50     ctype_Get(dmmeta::Cfmt& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cfmt_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     strfmt_Get(dmmeta::Cfmt& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Cfmt_strfmt_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Cfmt_Concat_ctype_strfmt( const algo::strptr& ctype ,const algo::strptr& strfmt );
bool                 Cfmt_ReadFieldMaybe(dmmeta::Cfmt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cfmt from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cfmt_ReadStrptrMaybe(dmmeta::Cfmt &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cfmt_Init(dmmeta::Cfmt& parent);
// print string representation of dmmeta::Cfmt to string LHS, no header -- cprint:dmmeta.Cfmt.String
void                 Cfmt_Print(dmmeta::Cfmt & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cget
struct Cget { // dmmeta.Cget: Generate state functions for these ctypes
    algo::Smallstr50   ctype;     //
    algo::Comment      comment;   //
    Cget();
};

bool                 Cget_ReadFieldMaybe(dmmeta::Cget &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cget from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cget_ReadStrptrMaybe(dmmeta::Cget &parent, algo::strptr in_str);
// print string representation of dmmeta::Cget to string LHS, no header -- cprint:dmmeta.Cget.String
void                 Cget_Print(dmmeta::Cget & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Charset
struct Charset { // dmmeta.Charset
    algo::Smallstr100   field;       //
    algo::Smallstr100   expr;        //
    bool                charrange;   //   false
    bool                calc;        //   false
    algo::Comment       comment;     //
    Charset();
};

bool                 Charset_ReadFieldMaybe(dmmeta::Charset &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Charset from an ascii string.
// The format of the string is an ssim Tuple
bool                 Charset_ReadStrptrMaybe(dmmeta::Charset &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Charset_Init(dmmeta::Charset& parent);
// print string representation of dmmeta::Charset to string LHS, no header -- cprint:dmmeta.Charset.String
void                 Charset_Print(dmmeta::Charset & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Chash
struct Chash { // dmmeta.Chash: Generate hash function
    algo::Smallstr50   ctype;      // Target ctype
    algo::Smallstr50   hashtype;   // Hash type
    algo::Comment      comment;    //
    explicit Chash(const algo::strptr&            in_ctype
        ,const algo::strptr&            in_hashtype
        ,const algo::Comment&           in_comment);
    Chash();
};

bool                 Chash_ReadFieldMaybe(dmmeta::Chash &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Chash from an ascii string.
// The format of the string is an ssim Tuple
bool                 Chash_ReadStrptrMaybe(dmmeta::Chash &parent, algo::strptr in_str);
// print string representation of dmmeta::Chash to string LHS, no header -- cprint:dmmeta.Chash.String
void                 Chash_Print(dmmeta::Chash & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cppfunc
struct Cppfunc { // dmmeta.Cppfunc: Value of field provided by this expression
    algo::Smallstr100   field;   //
    dmmeta::CppExpr     expr;    //
    Cppfunc();
};

bool                 Cppfunc_ReadFieldMaybe(dmmeta::Cppfunc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cppfunc from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cppfunc_ReadStrptrMaybe(dmmeta::Cppfunc &parent, algo::strptr in_str);
// print string representation of dmmeta::Cppfunc to string LHS, no header -- cprint:dmmeta.Cppfunc.String
void                 Cppfunc_Print(dmmeta::Cppfunc & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cppkeyword
struct Cppkeyword { // dmmeta.Cppkeyword
    algo::Smallstr20   cppkeyword;   //
    explicit Cppkeyword(const algo::strptr&            in_cppkeyword);
    Cppkeyword();
};

bool                 Cppkeyword_ReadFieldMaybe(dmmeta::Cppkeyword &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cppkeyword from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cppkeyword_ReadStrptrMaybe(dmmeta::Cppkeyword &parent, algo::strptr in_str);
// print string representation of dmmeta::Cppkeyword to string LHS, no header -- cprint:dmmeta.Cppkeyword.String
void                 Cppkeyword_Print(dmmeta::Cppkeyword & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cpptype
struct Cpptype { // dmmeta.Cpptype
    algo::Smallstr50   ctype;        //
    bool               ctor;         //   false  if true, generate non-default constructor from all fields
    bool               dtor;         //   true  generate non-default destructor
    bool               cheap_copy;   //   false  Pass by value whenever possible
    explicit Cpptype(const algo::strptr&            in_ctype
        ,bool                           in_ctor
        ,bool                           in_dtor
        ,bool                           in_cheap_copy);
    Cpptype();
};

bool                 Cpptype_ReadFieldMaybe(dmmeta::Cpptype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cpptype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cpptype_ReadStrptrMaybe(dmmeta::Cpptype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cpptype_Init(dmmeta::Cpptype& parent);
// print string representation of dmmeta::Cpptype to string LHS, no header -- cprint:dmmeta.Cpptype.String
void                 Cpptype_Print(dmmeta::Cpptype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Csize
struct Csize { // dmmeta.Csize
    algo::Smallstr50   ctype;       //
    u32                size;        //   0
    u32                alignment;   //   1
    algo::Comment      comment;     //
    explicit Csize(const algo::strptr&            in_ctype
        ,u32                            in_size
        ,u32                            in_alignment
        ,const algo::Comment&           in_comment);
    Csize();
};

bool                 Csize_ReadFieldMaybe(dmmeta::Csize &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Csize from an ascii string.
// The format of the string is an ssim Tuple
bool                 Csize_ReadStrptrMaybe(dmmeta::Csize &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Csize_Init(dmmeta::Csize& parent);
// print string representation of dmmeta::Csize to string LHS, no header -- cprint:dmmeta.Csize.String
void                 Csize_Print(dmmeta::Csize & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Cstr
struct Cstr { // dmmeta.Cstr
    algo::Smallstr50   ctype;      //
    bool               strequiv;   //   false  Use strptr instead of this type when possible
    algo::Comment      comment;    //
    Cstr();
};

bool                 Cstr_ReadFieldMaybe(dmmeta::Cstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Cstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Cstr_ReadStrptrMaybe(dmmeta::Cstr &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Cstr_Init(dmmeta::Cstr& parent);
// print string representation of dmmeta::Cstr to string LHS, no header -- cprint:dmmeta.Cstr.String
void                 Cstr_Print(dmmeta::Cstr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ctype
struct Ctype { // dmmeta.Ctype: C structure
    algo::Smallstr50   ctype;     // Identifier. must be ns.typename
    algo::Comment      comment;   //
    explicit Ctype(const algo::strptr&            in_ctype
        ,const algo::Comment&           in_comment);
    Ctype();
};

algo::Smallstr16     ns_Get(dmmeta::Ctype& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Ctype_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Ctype& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Ctype_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Ctype_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Ctype_ReadFieldMaybe(dmmeta::Ctype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ctype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ctype_ReadStrptrMaybe(dmmeta::Ctype &parent, algo::strptr in_str);
// print string representation of dmmeta::Ctype to string LHS, no header -- cprint:dmmeta.Ctype.String
void                 Ctype_Print(dmmeta::Ctype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ctypelen
struct Ctypelen { // dmmeta.Ctypelen: Size of Ctype
    algo::Smallstr50   ctype;       // Identifies the Ctype
    u32                len;         //   0
    i32                alignment;   //   0
    i32                padbytes;    //   0
    explicit Ctypelen(const algo::strptr&            in_ctype
        ,u32                            in_len
        ,i32                            in_alignment
        ,i32                            in_padbytes);
    Ctypelen();
};

bool                 Ctypelen_ReadFieldMaybe(dmmeta::Ctypelen &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ctypelen from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ctypelen_ReadStrptrMaybe(dmmeta::Ctypelen &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ctypelen_Init(dmmeta::Ctypelen& parent);
// print string representation of dmmeta::Ctypelen to string LHS, no header -- cprint:dmmeta.Ctypelen.String
void                 Ctypelen_Print(dmmeta::Ctypelen & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispatch
struct Dispatch { // dmmeta.Dispatch: Multi-way branch
    algo::Smallstr50   dispatch;   //
    bool               unk;        //   false  Want default case?
    bool               read;       //   false
    bool               print;      //   false
    bool               haslen;     //   false
    bool               call;       //   false
    bool               strict;     //   false  Only dispatch if length matches exactly
    algo::Comment      comment;    //
    explicit Dispatch(const algo::strptr&            in_dispatch
        ,bool                           in_unk
        ,bool                           in_read
        ,bool                           in_print
        ,bool                           in_haslen
        ,bool                           in_call
        ,bool                           in_strict
        ,const algo::Comment&           in_comment);
    Dispatch();
};

algo::Smallstr16     ns_Get(dmmeta::Dispatch& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Dispatch_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Dispatch& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Dispatch_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Dispatch_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Dispatch_ReadFieldMaybe(dmmeta::Dispatch &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispatch from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispatch_ReadStrptrMaybe(dmmeta::Dispatch &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Dispatch_Init(dmmeta::Dispatch& parent);
// print string representation of dmmeta::Dispatch to string LHS, no header -- cprint:dmmeta.Dispatch.String
void                 Dispatch_Print(dmmeta::Dispatch & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.DispatchMsg
struct DispatchMsg { // dmmeta.DispatchMsg
    algo::Smallstr100   dispatch_msg;   //
    algo::Comment       comment;        //
    explicit DispatchMsg(const algo::strptr&            in_dispatch_msg
        ,const algo::Comment&           in_comment);
    DispatchMsg();
};

algo::Smallstr50     dispatch_Get(dmmeta::DispatchMsg& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     DispatchMsg_dispatch_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::DispatchMsg& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     DispatchMsg_ctype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              DispatchMsg_Concat_dispatch_ctype( const algo::strptr& dispatch ,const algo::strptr& ctype );
bool                 DispatchMsg_ReadFieldMaybe(dmmeta::DispatchMsg &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::DispatchMsg from an ascii string.
// The format of the string is an ssim Tuple
bool                 DispatchMsg_ReadStrptrMaybe(dmmeta::DispatchMsg &parent, algo::strptr in_str);
// print string representation of dmmeta::DispatchMsg to string LHS, no header -- cprint:dmmeta.DispatchMsg.String
void                 DispatchMsg_Print(dmmeta::DispatchMsg & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispctx
struct Dispctx { // dmmeta.Dispctx: Use context with dispatch
    algo::Smallstr50   dispatch;   //
    algo::Smallstr50   ctype;      //
    algo::Comment      comment;    //
    Dispctx();
};

bool                 Dispctx_ReadFieldMaybe(dmmeta::Dispctx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispctx from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispctx_ReadStrptrMaybe(dmmeta::Dispctx &parent, algo::strptr in_str);
// print string representation of dmmeta::Dispctx to string LHS, no header -- cprint:dmmeta.Dispctx.String
void                 Dispctx_Print(dmmeta::Dispctx & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispfilter
struct Dispfilter { // dmmeta.Dispfilter
    algo::Smallstr50   dispatch;    //
    bool               match_all;   //   false
    algo::Comment      comment;     //
    Dispfilter();
};

bool                 Dispfilter_ReadFieldMaybe(dmmeta::Dispfilter &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispfilter from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispfilter_ReadStrptrMaybe(dmmeta::Dispfilter &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Dispfilter_Init(dmmeta::Dispfilter& parent);
// print string representation of dmmeta::Dispfilter to string LHS, no header -- cprint:dmmeta.Dispfilter.String
void                 Dispfilter_Print(dmmeta::Dispfilter & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispsig
struct Dispsig { // dmmeta.Dispsig
    algo::Smallstr50   dispsig;     //
    algo::Sha1sig      signature;   //
    Dispsig();
};

algo::Smallstr16     ns_Get(dmmeta::Dispsig& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Dispsig_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Dispsig& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Dispsig_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Dispsig_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Dispsig_ReadFieldMaybe(dmmeta::Dispsig &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispsig from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispsig_ReadStrptrMaybe(dmmeta::Dispsig &parent, algo::strptr in_str);
// print string representation of dmmeta::Dispsig to string LHS, no header -- cprint:dmmeta.Dispsig.String
void                 Dispsig_Print(dmmeta::Dispsig & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Dispsigcheck
struct Dispsigcheck { // dmmeta.Dispsigcheck
    algo::Smallstr50   dispsig;     //
    algo::Sha1sig      signature;   //
    explicit Dispsigcheck(const algo::strptr&            in_dispsig
        ,const algo::Sha1sig&           in_signature);
    Dispsigcheck();
};

bool                 Dispsigcheck_ReadFieldMaybe(dmmeta::Dispsigcheck &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Dispsigcheck from an ascii string.
// The format of the string is an ssim Tuple
bool                 Dispsigcheck_ReadStrptrMaybe(dmmeta::Dispsigcheck &parent, algo::strptr in_str);
// print string representation of dmmeta::Dispsigcheck to string LHS, no header -- cprint:dmmeta.Dispsigcheck.String
void                 Dispsigcheck_Print(dmmeta::Dispsigcheck & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Disptrace
struct Disptrace { // dmmeta.Disptrace
    algo::Smallstr50   dispatch;   //
    bool               cycle;      //   false
    algo::Comment      comment;    //
    Disptrace();
};

bool                 Disptrace_ReadFieldMaybe(dmmeta::Disptrace &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Disptrace from an ascii string.
// The format of the string is an ssim Tuple
bool                 Disptrace_ReadStrptrMaybe(dmmeta::Disptrace &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Disptrace_Init(dmmeta::Disptrace& parent);
// print string representation of dmmeta::Disptrace to string LHS, no header -- cprint:dmmeta.Disptrace.String
void                 Disptrace_Print(dmmeta::Disptrace & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbase
struct Fbase { // dmmeta.Fbase
    algo::Smallstr100   field;          //
    bool                stripcomment;   //   false
    algo::Comment       comment;        //
    Fbase();
};

bool                 Fbase_ReadFieldMaybe(dmmeta::Fbase &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbase from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbase_ReadStrptrMaybe(dmmeta::Fbase &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbase_Init(dmmeta::Fbase& parent);
// print string representation of dmmeta::Fbase to string LHS, no header -- cprint:dmmeta.Fbase.String
void                 Fbase_Print(dmmeta::Fbase & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbigend
struct Fbigend { // dmmeta.Fbigend
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fbigend();
};

bool                 Fbigend_ReadFieldMaybe(dmmeta::Fbigend &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbigend from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbigend_ReadStrptrMaybe(dmmeta::Fbigend &parent, algo::strptr in_str);
// print string representation of dmmeta::Fbigend to string LHS, no header -- cprint:dmmeta.Fbigend.String
void                 Fbigend_Print(dmmeta::Fbigend & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbitset
struct Fbitset { // dmmeta.Fbitset
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Fbitset(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Fbitset();
};

bool                 Fbitset_ReadFieldMaybe(dmmeta::Fbitset &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbitset from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbitset_ReadStrptrMaybe(dmmeta::Fbitset &parent, algo::strptr in_str);
// print string representation of dmmeta::Fbitset to string LHS, no header -- cprint:dmmeta.Fbitset.String
void                 Fbitset_Print(dmmeta::Fbitset & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbuf
struct Fbuf { // dmmeta.Fbuf
    algo::Smallstr100   field;      //
    u32                 max;        //   0  Size of buffer in bytes
    algo::Smallstr50    fbuftype;   // Type of buffer
    algo::Smallstr100   insready;   //
    algo::Smallstr100   inseof;     //
    algo::Comment       comment;    //
    Fbuf();
};

algo::Smallstr50     fbufdir_Get(dmmeta::Fbuf& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fbuf_fbufdir_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Fbuf_ReadFieldMaybe(dmmeta::Fbuf &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbuf from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbuf_ReadStrptrMaybe(dmmeta::Fbuf &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbuf_Init(dmmeta::Fbuf& parent);
// print string representation of dmmeta::Fbuf to string LHS, no header -- cprint:dmmeta.Fbuf.String
void                 Fbuf_Print(dmmeta::Fbuf & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbufdir
struct Fbufdir { // dmmeta.Fbufdir
    algo::Smallstr50   fbufdir;   //
    bool               read;      //   false
    algo::Comment      comment;   //
    Fbufdir();
};

bool                 Fbufdir_ReadFieldMaybe(dmmeta::Fbufdir &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbufdir from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbufdir_ReadStrptrMaybe(dmmeta::Fbufdir &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbufdir_Init(dmmeta::Fbufdir& parent);
// print string representation of dmmeta::Fbufdir to string LHS, no header -- cprint:dmmeta.Fbufdir.String
void                 Fbufdir_Print(dmmeta::Fbufdir & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fbuftype
struct Fbuftype { // dmmeta.Fbuftype
    algo::Smallstr50   fbuftype;    //
    bool               getmsg;      //   false  Has getmsg function?
    bool               skipbytes;   //   false  Has skipbytes function?
    bool               read;        //   false
    algo::Comment      comment;     //
    Fbuftype();
};

bool                 Fbuftype_ReadFieldMaybe(dmmeta::Fbuftype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fbuftype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fbuftype_ReadStrptrMaybe(dmmeta::Fbuftype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fbuftype_Init(dmmeta::Fbuftype& parent);
// print string representation of dmmeta::Fbuftype to string LHS, no header -- cprint:dmmeta.Fbuftype.String
void                 Fbuftype_Print(dmmeta::Fbuftype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcast
struct Fcast { // dmmeta.Fcast
    algo::Smallstr100   field;     //
    algo::Smallstr100   expr;      //
    algo::Comment       comment;   //
    explicit Fcast(const algo::strptr&            in_field
        ,const algo::strptr&            in_expr
        ,const algo::Comment&           in_comment);
    Fcast();
};

bool                 Fcast_ReadFieldMaybe(dmmeta::Fcast &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcast from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcast_ReadStrptrMaybe(dmmeta::Fcast &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcast to string LHS, no header -- cprint:dmmeta.Fcast.String
void                 Fcast_Print(dmmeta::Fcast & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcleanup
struct Fcleanup { // dmmeta.Fcleanup
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fcleanup();
};

bool                 Fcleanup_ReadFieldMaybe(dmmeta::Fcleanup &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcleanup from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcleanup_ReadStrptrMaybe(dmmeta::Fcleanup &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcleanup to string LHS, no header -- cprint:dmmeta.Fcleanup.String
void                 Fcleanup_Print(dmmeta::Fcleanup & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcmap
struct Fcmap { // dmmeta.Fcmap
    algo::Smallstr250   fcmap;     // cstring maybe?
    bool                bidir;     //   true
    algo::Comment       comment;   //
    Fcmap();
};

algo::Smallstr100    leftField_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fcmap_leftField_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr40     leftVal_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr40     Fcmap_leftVal_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr40     rightVal_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr40     Fcmap_rightVal_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    rightField_Get(dmmeta::Fcmap& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fcmap_rightField_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fcmap_Concat_leftField_leftVal_rightField_rightVal( const algo::strptr& leftField ,const algo::strptr& leftVal ,const algo::strptr& rightField ,const algo::strptr& rightVal );
bool                 Fcmap_ReadFieldMaybe(dmmeta::Fcmap &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmap from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcmap_ReadStrptrMaybe(dmmeta::Fcmap &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fcmap_Init(dmmeta::Fcmap& parent);
// print string representation of dmmeta::Fcmap to string LHS, no header -- cprint:dmmeta.Fcmap.String
void                 Fcmap_Print(dmmeta::Fcmap & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcmdline
struct Fcmdline { // dmmeta.Fcmdline
    algo::Smallstr100   field;     //
    bool                read;      //   true
    algo::Comment       comment;   //
    Fcmdline();
};

bool                 Fcmdline_ReadFieldMaybe(dmmeta::Fcmdline &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmdline from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcmdline_ReadStrptrMaybe(dmmeta::Fcmdline &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fcmdline_Init(dmmeta::Fcmdline& parent);
// print string representation of dmmeta::Fcmdline to string LHS, no header -- cprint:dmmeta.Fcmdline.String
void                 Fcmdline_Print(dmmeta::Fcmdline & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcmp
struct Fcmp { // dmmeta.Fcmp: Generate hash function
    algo::Smallstr100   field;         // Target field
    bool                versionsort;   //   false  Use version sort (detect embedded integers in string)
    bool                casesens;      //   true  Comparison is case-sensitive
    bool                extrn;         //   false  Whether implementation is external
    algo::Comment       comment;       //
    explicit Fcmp(const algo::strptr&            in_field
        ,bool                           in_versionsort
        ,bool                           in_casesens
        ,bool                           in_extrn
        ,const algo::Comment&           in_comment);
    Fcmp();
};

bool                 Fcmp_ReadFieldMaybe(dmmeta::Fcmp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcmp from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcmp_ReadStrptrMaybe(dmmeta::Fcmp &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fcmp_Init(dmmeta::Fcmp& parent);
// print string representation of dmmeta::Fcmp to string LHS, no header -- cprint:dmmeta.Fcmp.String
void                 Fcmp_Print(dmmeta::Fcmp & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcompact
struct Fcompact { // dmmeta.Fcompact
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fcompact();
};

bool                 Fcompact_ReadFieldMaybe(dmmeta::Fcompact &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcompact from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcompact_ReadStrptrMaybe(dmmeta::Fcompact &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcompact to string LHS, no header -- cprint:dmmeta.Fcompact.String
void                 Fcompact_Print(dmmeta::Fcompact & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fconst
struct Fconst { // dmmeta.Fconst
    algo::Smallstr100   fconst;    //
    dmmeta::CppExpr     value;     //
    inline operator dmmeta::CppExpr() const;
    algo::Comment       comment;   //
    explicit Fconst(const algo::strptr&            in_fconst
        ,const dmmeta::CppExpr&         in_value
        ,const algo::Comment&           in_comment);
    Fconst();
};

algo::Smallstr100    field_Get(dmmeta::Fconst& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fconst_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    name_Get(dmmeta::Fconst& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fconst_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fconst_Concat_field_name( const algo::strptr& field ,const algo::strptr& name );
bool                 Fconst_ReadFieldMaybe(dmmeta::Fconst &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fconst from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fconst_ReadStrptrMaybe(dmmeta::Fconst &parent, algo::strptr in_str);
// print string representation of dmmeta::Fconst to string LHS, no header -- cprint:dmmeta.Fconst.String
void                 Fconst_Print(dmmeta::Fconst & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fcurs
struct Fcurs { // dmmeta.Fcurs
    algo::Smallstr50   fcurs;     //
    algo::Comment      comment;   //
    Fcurs();
};

algo::Smallstr100    field_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fcurs_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fcurs_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     curs_Get(dmmeta::Fcurs& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fcurs_curs_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fcurs_Concat_field_curs( const algo::strptr& field ,const algo::strptr& curs );
bool                 Fcurs_ReadFieldMaybe(dmmeta::Fcurs &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fcurs from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fcurs_ReadStrptrMaybe(dmmeta::Fcurs &parent, algo::strptr in_str);
// print string representation of dmmeta::Fcurs to string LHS, no header -- cprint:dmmeta.Fcurs.String
void                 Fcurs_Print(dmmeta::Fcurs & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fdec
struct Fdec { // dmmeta.Fdec
    algo::Smallstr100   field;      // Target field
    i32                 nplace;     //   0  Number of implied decimal places
    bool                fixedfmt;   //   false  Print exactly SCALE chars after decimal point
    algo::Comment       comment;    //
    Fdec();
};

bool                 Fdec_ReadFieldMaybe(dmmeta::Fdec &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fdec from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fdec_ReadStrptrMaybe(dmmeta::Fdec &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fdec_Init(dmmeta::Fdec& parent);
// print string representation of dmmeta::Fdec to string LHS, no header -- cprint:dmmeta.Fdec.String
void                 Fdec_Print(dmmeta::Fdec & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fdelay
struct Fdelay { // dmmeta.Fdelay
    algo::Smallstr100   fstep;     //
    algo::I64Dec9       delay;     // Delay between steps in seconds
    bool                scale;     //   false  Does delay apply to the whole list?
    algo::Comment       comment;   //
    Fdelay();
};

bool                 Fdelay_ReadFieldMaybe(dmmeta::Fdelay &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fdelay from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fdelay_ReadStrptrMaybe(dmmeta::Fdelay &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fdelay_Init(dmmeta::Fdelay& parent);
// print string representation of dmmeta::Fdelay to string LHS, no header -- cprint:dmmeta.Fdelay.String
void                 Fdelay_Print(dmmeta::Fdelay & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Field
struct Field { // dmmeta.Field: Ctype attribute
    algo::Smallstr100   field;     //
    algo::Smallstr50    arg;       // type of field
    algo::Smallstr50    reftype;   //   "Val"
    dmmeta::CppExpr     dflt;      // default value (c++ expression)
    algo::Comment       comment;   //
    explicit Field(const algo::strptr&            in_field
        ,const algo::strptr&            in_arg
        ,const algo::strptr&            in_reftype
        ,const dmmeta::CppExpr&         in_dflt
        ,const algo::Comment&           in_comment);
    Field();
};

algo::Smallstr50     ctype_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Field_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Field_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Field& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Field_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Field_Concat_ctype_name( const algo::strptr& ctype ,const algo::strptr& name );
bool                 Field_ReadFieldMaybe(dmmeta::Field &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Field from an ascii string.
// The format of the string is an ssim Tuple
bool                 Field_ReadStrptrMaybe(dmmeta::Field &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Field_Init(dmmeta::Field& parent);
// print string representation of dmmeta::Field to string LHS, no header -- cprint:dmmeta.Field.String
void                 Field_Print(dmmeta::Field & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.FieldId
#pragma pack(push,1)
struct FieldId { // dmmeta.FieldId: Field read helper
    i32   value;   //   -1
    inline operator dmmeta_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(dmmeta_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
dmmeta_FieldIdEnum   value_GetEnum(const dmmeta::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(dmmeta::FieldId& parent, dmmeta_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const dmmeta::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const dmmeta::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(dmmeta::FieldId& parent, algo::strptr rhs, dmmeta_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(dmmeta::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of dmmeta::FieldId from an ascii string.
// The format of the string is the format of the dmmeta::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(dmmeta::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(dmmeta::FieldId& parent);
// print string representation of dmmeta::FieldId to string LHS, no header -- cprint:dmmeta.FieldId.String
void                 FieldId_Print(dmmeta::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Findrem
struct Findrem { // dmmeta.Findrem
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Findrem();
};

bool                 Findrem_ReadFieldMaybe(dmmeta::Findrem &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Findrem from an ascii string.
// The format of the string is an ssim Tuple
bool                 Findrem_ReadStrptrMaybe(dmmeta::Findrem &parent, algo::strptr in_str);
// print string representation of dmmeta::Findrem to string LHS, no header -- cprint:dmmeta.Findrem.String
void                 Findrem_Print(dmmeta::Findrem & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Finput
struct Finput { // dmmeta.Finput: Describe input table of a program
    algo::Smallstr100   field;     // Target field to read
    bool                extrn;     //   false  Call user-provided function
    bool                update;    //   false
    bool                strict;    //   true  Exist process if record contains error
    algo::Comment       comment;   //
    explicit Finput(const algo::strptr&            in_field
        ,bool                           in_extrn
        ,bool                           in_update
        ,bool                           in_strict
        ,const algo::Comment&           in_comment);
    Finput();
};

algo::Smallstr16     ns_Get(dmmeta::Finput& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Finput_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Finput_ReadFieldMaybe(dmmeta::Finput &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Finput from an ascii string.
// The format of the string is an ssim Tuple
bool                 Finput_ReadStrptrMaybe(dmmeta::Finput &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Finput_Init(dmmeta::Finput& parent);
// print string representation of dmmeta::Finput to string LHS, no header -- cprint:dmmeta.Finput.String
void                 Finput_Print(dmmeta::Finput & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fldoffset
struct Fldoffset { // dmmeta.Fldoffset: Offset assertion
    algo::Smallstr100   field;    //
    i32                 offset;   //   0
    explicit Fldoffset(const algo::strptr&            in_field
        ,i32                            in_offset);
    Fldoffset();
};

bool                 Fldoffset_ReadFieldMaybe(dmmeta::Fldoffset &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fldoffset from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fldoffset_ReadStrptrMaybe(dmmeta::Fldoffset &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fldoffset_Init(dmmeta::Fldoffset& parent);
// print string representation of dmmeta::Fldoffset to string LHS, no header -- cprint:dmmeta.Fldoffset.String
void                 Fldoffset_Print(dmmeta::Fldoffset & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Floadtuples
struct Floadtuples { // dmmeta.Floadtuples
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Floadtuples();
};

algo::Smallstr50     ctype_Get(dmmeta::Floadtuples& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Floadtuples_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Floadtuples_ReadFieldMaybe(dmmeta::Floadtuples &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Floadtuples from an ascii string.
// The format of the string is an ssim Tuple
bool                 Floadtuples_ReadStrptrMaybe(dmmeta::Floadtuples &parent, algo::strptr in_str);
// print string representation of dmmeta::Floadtuples to string LHS, no header -- cprint:dmmeta.Floadtuples.String
void                 Floadtuples_Print(dmmeta::Floadtuples & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fnoremove
struct Fnoremove { // dmmeta.Fnoremove
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fnoremove();
};

bool                 Fnoremove_ReadFieldMaybe(dmmeta::Fnoremove &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fnoremove from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fnoremove_ReadStrptrMaybe(dmmeta::Fnoremove &parent, algo::strptr in_str);
// print string representation of dmmeta::Fnoremove to string LHS, no header -- cprint:dmmeta.Fnoremove.String
void                 Fnoremove_Print(dmmeta::Fnoremove & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Foutput
struct Foutput { // dmmeta.Foutput
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Foutput();
};

algo::Smallstr16     ns_Get(dmmeta::Foutput& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Foutput_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Foutput_ReadFieldMaybe(dmmeta::Foutput &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Foutput from an ascii string.
// The format of the string is an ssim Tuple
bool                 Foutput_ReadStrptrMaybe(dmmeta::Foutput &parent, algo::strptr in_str);
// print string representation of dmmeta::Foutput to string LHS, no header -- cprint:dmmeta.Foutput.String
void                 Foutput_Print(dmmeta::Foutput & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fprefix
struct Fprefix { // dmmeta.Fprefix
    algo::Smallstr5    fprefix;   //
    algo::Smallstr50   reftype;   //
    algo::Comment      comment;   //
    Fprefix();
};

bool                 Fprefix_ReadFieldMaybe(dmmeta::Fprefix &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fprefix from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fprefix_ReadStrptrMaybe(dmmeta::Fprefix &parent, algo::strptr in_str);
// print string representation of dmmeta::Fprefix to string LHS, no header -- cprint:dmmeta.Fprefix.String
void                 Fprefix_Print(dmmeta::Fprefix & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fregx
struct Fregx { // dmmeta.Fregx
    algo::Smallstr100   field;     //
    bool                partial;   //   false
    algo::Comment       comment;   //
    Fregx();
};

bool                 Fregx_ReadFieldMaybe(dmmeta::Fregx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fregx from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fregx_ReadStrptrMaybe(dmmeta::Fregx &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Fregx_Init(dmmeta::Fregx& parent);
// print string representation of dmmeta::Fregx to string LHS, no header -- cprint:dmmeta.Fregx.String
void                 Fregx_Print(dmmeta::Fregx & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fsort
struct Fsort { // dmmeta.Fsort
    algo::Smallstr100   field;      // Field (array etc) being sorted
    algo::Smallstr50    sorttype;   // Kind of sort to generate
    algo::Smallstr100   sortfld;    // Field to sort on
    algo::Comment       comment;    //
    Fsort();
};

bool                 Fsort_ReadFieldMaybe(dmmeta::Fsort &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fsort from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fsort_ReadStrptrMaybe(dmmeta::Fsort &parent, algo::strptr in_str);
// print string representation of dmmeta::Fsort to string LHS, no header -- cprint:dmmeta.Fsort.String
void                 Fsort_Print(dmmeta::Fsort & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fstep
struct Fstep { // dmmeta.Fstep
    algo::Smallstr100   fstep;      //
    algo::Smallstr50    steptype;   //
    algo::Comment       comment;    //
    Fstep();
};

algo::Smallstr100    field_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Fstep_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Fstep_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Fstep& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fstep_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fstep_Concat_field( const algo::strptr& field );
bool                 Fstep_ReadFieldMaybe(dmmeta::Fstep &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fstep from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fstep_ReadStrptrMaybe(dmmeta::Fstep &parent, algo::strptr in_str);
// print string representation of dmmeta::Fstep to string LHS, no header -- cprint:dmmeta.Fstep.String
void                 Fstep_Print(dmmeta::Fstep & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ftrace
struct Ftrace { // dmmeta.Ftrace
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Ftrace();
};

bool                 Ftrace_ReadFieldMaybe(dmmeta::Ftrace &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ftrace from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ftrace_ReadStrptrMaybe(dmmeta::Ftrace &parent, algo::strptr in_str);
// print string representation of dmmeta::Ftrace to string LHS, no header -- cprint:dmmeta.Ftrace.String
void                 Ftrace_Print(dmmeta::Ftrace & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ftuple
struct Ftuple { // dmmeta.Ftuple
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Ftuple();
};

bool                 Ftuple_ReadFieldMaybe(dmmeta::Ftuple &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ftuple from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ftuple_ReadStrptrMaybe(dmmeta::Ftuple &parent, algo::strptr in_str);
// print string representation of dmmeta::Ftuple to string LHS, no header -- cprint:dmmeta.Ftuple.String
void                 Ftuple_Print(dmmeta::Ftuple & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Func
struct Func { // dmmeta.Func
    algo::Smallstr100   func;        // Primary key
    bool                inl;         //   false  Make inline?
    algo::cstring       proto;       // Prototype
    algo::cstring       body;        // Body of function
    bool                deprecate;   //   false  Make deprecated?
    bool                ismacro;     //   false  Always inline.
    bool                extrn;       //   false  Implemented externally by user
    bool                glob;        //   false  Function is not attached to a field (EXPLAIN!!)
    bool                priv;        //   false  Private to translateion unit (static)
    algo::cstring       ret;         // Return type
    algo::cstring       comment;     // Description (keep it as algo.comment)
    Func();
};

algo::Smallstr100    field_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Func_field_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Func_name_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Func_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Func& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Func_ns_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Func_Concat_field_name( const algo::strptr& field ,const algo::strptr& name );
bool                 Func_ReadFieldMaybe(dmmeta::Func &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Func from an ascii string.
// The format of the string is an ssim Tuple
bool                 Func_ReadStrptrMaybe(dmmeta::Func &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Func_Init(dmmeta::Func& parent);
// print string representation of dmmeta::Func to string LHS, no header -- cprint:dmmeta.Func.String
void                 Func_Print(dmmeta::Func & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Funique
struct Funique { // dmmeta.Funique
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Funique();
};

bool                 Funique_ReadFieldMaybe(dmmeta::Funique &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Funique from an ascii string.
// The format of the string is an ssim Tuple
bool                 Funique_ReadStrptrMaybe(dmmeta::Funique &parent, algo::strptr in_str);
// print string representation of dmmeta::Funique to string LHS, no header -- cprint:dmmeta.Funique.String
void                 Funique_Print(dmmeta::Funique & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fuserinit
struct Fuserinit { // dmmeta.Fuserinit
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Fuserinit();
};

bool                 Fuserinit_ReadFieldMaybe(dmmeta::Fuserinit &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fuserinit from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fuserinit_ReadStrptrMaybe(dmmeta::Fuserinit &parent, algo::strptr in_str);
// print string representation of dmmeta::Fuserinit to string LHS, no header -- cprint:dmmeta.Fuserinit.String
void                 Fuserinit_Print(dmmeta::Fuserinit & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Fwddecl
struct Fwddecl { // dmmeta.Fwddecl
    algo::Smallstr100   fwddecl;   //
    algo::Comment       comment;   //
    Fwddecl();
};

algo::Smallstr16     ns_Get(dmmeta::Fwddecl& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Fwddecl_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Fwddecl& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Fwddecl_ctype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Fwddecl_Concat_ns_ctype( const algo::strptr& ns ,const algo::strptr& ctype );
bool                 Fwddecl_ReadFieldMaybe(dmmeta::Fwddecl &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Fwddecl from an ascii string.
// The format of the string is an ssim Tuple
bool                 Fwddecl_ReadStrptrMaybe(dmmeta::Fwddecl &parent, algo::strptr in_str);
// print string representation of dmmeta::Fwddecl to string LHS, no header -- cprint:dmmeta.Fwddecl.String
void                 Fwddecl_Print(dmmeta::Fwddecl & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Gconst
struct Gconst { // dmmeta.Gconst
    algo::Smallstr100   field;      // Field with which to associate constants
    algo::Smallstr100   namefld;    // Field which gives the name of the constant
    algo::Smallstr100   idfld;      // Optional attribute of namefld that gives numeric ID for gconst
    bool                wantenum;   //   true
    explicit Gconst(const algo::strptr&            in_field
        ,const algo::strptr&            in_namefld
        ,const algo::strptr&            in_idfld
        ,bool                           in_wantenum);
    Gconst();
};

algo::Smallstr50     namefldctyp_Get(dmmeta::Gconst& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Gconst_namefldctyp_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Gconst_ReadFieldMaybe(dmmeta::Gconst &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gconst from an ascii string.
// The format of the string is an ssim Tuple
bool                 Gconst_ReadStrptrMaybe(dmmeta::Gconst &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Gconst_Init(dmmeta::Gconst& parent);
// print string representation of dmmeta::Gconst to string LHS, no header -- cprint:dmmeta.Gconst.String
void                 Gconst_Print(dmmeta::Gconst & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Gstatic
struct Gstatic { // dmmeta.Gstatic
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Gstatic(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Gstatic();
};

algo::Smallstr16     ns_Get(dmmeta::Gstatic& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Gstatic_ns_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Gstatic_ReadFieldMaybe(dmmeta::Gstatic &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gstatic from an ascii string.
// The format of the string is an ssim Tuple
bool                 Gstatic_ReadStrptrMaybe(dmmeta::Gstatic &parent, algo::strptr in_str);
// print string representation of dmmeta::Gstatic to string LHS, no header -- cprint:dmmeta.Gstatic.String
void                 Gstatic_Print(dmmeta::Gstatic & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Gsymbol
struct Gsymbol { // dmmeta.Gsymbol: Create C++ symbols from entries in table
    algo::Smallstr50    gsymbol;   //
    algo::Smallstr100   inc;       // Regex to filter rows
    algo::Comment       comment;   //
    Gsymbol();
};

algo::Smallstr16     ns_Get(dmmeta::Gsymbol& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Gsymbol_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ssimfile_Get(dmmeta::Gsymbol& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Gsymbol_ssimfile_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Gsymbol_Concat_ns_ssimfile( const algo::strptr& ns ,const algo::strptr& ssimfile );
bool                 Gsymbol_ReadFieldMaybe(dmmeta::Gsymbol &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Gsymbol from an ascii string.
// The format of the string is an ssim Tuple
bool                 Gsymbol_ReadStrptrMaybe(dmmeta::Gsymbol &parent, algo::strptr in_str);
// print string representation of dmmeta::Gsymbol to string LHS, no header -- cprint:dmmeta.Gsymbol.String
void                 Gsymbol_Print(dmmeta::Gsymbol & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Hashtype
struct Hashtype { // dmmeta.Hashtype
    algo::Smallstr50   hashtype;   //
    algo::Comment      comment;    //
    explicit Hashtype(const algo::strptr&            in_hashtype
        ,const algo::Comment&           in_comment);
    Hashtype();
};

bool                 Hashtype_ReadFieldMaybe(dmmeta::Hashtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Hashtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Hashtype_ReadStrptrMaybe(dmmeta::Hashtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Hashtype to string LHS, no header -- cprint:dmmeta.Hashtype.String
void                 Hashtype_Print(dmmeta::Hashtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Hook
struct Hook { // dmmeta.Hook
    algo::Smallstr100   field;     // The field
    algo::Comment       comment;   //
    Hook();
};

bool                 Hook_ReadFieldMaybe(dmmeta::Hook &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Hook from an ascii string.
// The format of the string is an ssim Tuple
bool                 Hook_ReadStrptrMaybe(dmmeta::Hook &parent, algo::strptr in_str);
// print string representation of dmmeta::Hook to string LHS, no header -- cprint:dmmeta.Hook.String
void                 Hook_Print(dmmeta::Hook & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Inlary
struct Inlary { // dmmeta.Inlary
    algo::Smallstr100   field;     //
    i32                 min;       //   0  Min. elements to preallocate
    i32                 max;       //   0  Max. elements
    algo::Comment       comment;   //
    explicit Inlary(const algo::strptr&            in_field
        ,i32                            in_min
        ,i32                            in_max
        ,const algo::Comment&           in_comment);
    Inlary();
};

bool                 Inlary_ReadFieldMaybe(dmmeta::Inlary &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Inlary from an ascii string.
// The format of the string is an ssim Tuple
bool                 Inlary_ReadStrptrMaybe(dmmeta::Inlary &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Inlary_Init(dmmeta::Inlary& parent);
// print string representation of dmmeta::Inlary to string LHS, no header -- cprint:dmmeta.Inlary.String
void                 Inlary_Print(dmmeta::Inlary & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Lenfld
struct Lenfld { // dmmeta.Lenfld: Specify which gives length of varlen portion in bytes
    algo::Smallstr100   field;   // Name of length field
    i32                 extra;   //   0  Extra #bytes to add
    explicit Lenfld(const algo::strptr&            in_field
        ,i32                            in_extra);
    Lenfld();
};

algo::Smallstr50     ctype_Get(dmmeta::Lenfld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Lenfld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Lenfld_ReadFieldMaybe(dmmeta::Lenfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Lenfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Lenfld_ReadStrptrMaybe(dmmeta::Lenfld &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Lenfld_Init(dmmeta::Lenfld& parent);
// print string representation of dmmeta::Lenfld to string LHS, no header -- cprint:dmmeta.Lenfld.String
void                 Lenfld_Print(dmmeta::Lenfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Listtype
struct Listtype { // dmmeta.Listtype
    algo::Smallstr5   listtype;   //
    bool              circular;   //   false  Circular list
    bool              haveprev;   //   false  Previous link
    bool              instail;    //   false  Queue
    algo::Comment     comment;    //
    Listtype();
};

bool                 Listtype_ReadFieldMaybe(dmmeta::Listtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Listtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Listtype_ReadStrptrMaybe(dmmeta::Listtype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Listtype_Init(dmmeta::Listtype& parent);
// print string representation of dmmeta::Listtype to string LHS, no header -- cprint:dmmeta.Listtype.String
void                 Listtype_Print(dmmeta::Listtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Llist
struct Llist { // dmmeta.Llist
    algo::Smallstr100   field;       // Index in question
    bool                havetail;    //   true  Generate 'tail' field
    bool                havecount;   //   false  Generate count of elements
    algo::Comment       comment;     //
    explicit Llist(const algo::strptr&            in_field
        ,bool                           in_havetail
        ,bool                           in_havecount
        ,const algo::Comment&           in_comment);
    Llist();
};

algo::Smallstr5      listtype_Get(dmmeta::Llist& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr5      Llist_listtype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Llist_ReadFieldMaybe(dmmeta::Llist &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Llist from an ascii string.
// The format of the string is an ssim Tuple
bool                 Llist_ReadStrptrMaybe(dmmeta::Llist &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Llist_Init(dmmeta::Llist& parent);
// print string representation of dmmeta::Llist to string LHS, no header -- cprint:dmmeta.Llist.String
void                 Llist_Print(dmmeta::Llist & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Main
struct Main { // dmmeta.Main
    algo::Smallstr16   ns;         //
    bool               ismodule;   //   false
    explicit Main(const algo::strptr&            in_ns
        ,bool                           in_ismodule);
    Main();
};

bool                 Main_ReadFieldMaybe(dmmeta::Main &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Main from an ascii string.
// The format of the string is an ssim Tuple
bool                 Main_ReadStrptrMaybe(dmmeta::Main &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Main_Init(dmmeta::Main& parent);
// print string representation of dmmeta::Main to string LHS, no header -- cprint:dmmeta.Main.String
void                 Main_Print(dmmeta::Main & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Msgtype
struct Msgtype { // dmmeta.Msgtype: Specify message type for each eligible message
    algo::Smallstr50   ctype;   //
    dmmeta::CppExpr    type;    //
    explicit Msgtype(const algo::strptr&            in_ctype
        ,const dmmeta::CppExpr&         in_type);
    Msgtype();
};

bool                 Msgtype_ReadFieldMaybe(dmmeta::Msgtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Msgtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Msgtype_ReadStrptrMaybe(dmmeta::Msgtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Msgtype to string LHS, no header -- cprint:dmmeta.Msgtype.String
void                 Msgtype_Print(dmmeta::Msgtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nocascdel
struct Nocascdel { // dmmeta.Nocascdel
    algo::Smallstr100   xref;      //
    algo::Comment       comment;   //
    Nocascdel();
};

bool                 Nocascdel_ReadFieldMaybe(dmmeta::Nocascdel &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nocascdel from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nocascdel_ReadStrptrMaybe(dmmeta::Nocascdel &parent, algo::strptr in_str);
// print string representation of dmmeta::Nocascdel to string LHS, no header -- cprint:dmmeta.Nocascdel.String
void                 Nocascdel_Print(dmmeta::Nocascdel & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nossimfile
struct Nossimfile { // dmmeta.Nossimfile: Indicates that ssimfile does not exist for this ssimdb ctype
    algo::Smallstr50   ctype;     //
    algo::Comment      comment;   //
    Nossimfile();
};

bool                 Nossimfile_ReadFieldMaybe(dmmeta::Nossimfile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nossimfile from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nossimfile_ReadStrptrMaybe(dmmeta::Nossimfile &parent, algo::strptr in_str);
// print string representation of dmmeta::Nossimfile to string LHS, no header -- cprint:dmmeta.Nossimfile.String
void                 Nossimfile_Print(dmmeta::Nossimfile & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Noxref
struct Noxref { // dmmeta.Noxref
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Noxref();
};

bool                 Noxref_ReadFieldMaybe(dmmeta::Noxref &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Noxref from an ascii string.
// The format of the string is an ssim Tuple
bool                 Noxref_ReadStrptrMaybe(dmmeta::Noxref &parent, algo::strptr in_str);
// print string representation of dmmeta::Noxref to string LHS, no header -- cprint:dmmeta.Noxref.String
void                 Noxref_Print(dmmeta::Noxref & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ns
struct Ns { // dmmeta.Ns: Namespace (for in-memory database, protocol, etc)
    algo::Smallstr16   ns;        // Namespace name (primary key)
    algo::Smallstr50   nstype;    //
    algo::Comment      comment;   //
    explicit Ns(const algo::strptr&            in_ns
        ,const algo::strptr&            in_nstype
        ,const algo::Comment&           in_comment);
    Ns();
};

bool                 Ns_ReadFieldMaybe(dmmeta::Ns &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ns from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ns_ReadStrptrMaybe(dmmeta::Ns &parent, algo::strptr in_str);
// print string representation of dmmeta::Ns to string LHS, no header -- cprint:dmmeta.Ns.String
void                 Ns_Print(dmmeta::Ns & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsdb
struct Nsdb { // dmmeta.Nsdb
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    Nsdb();
};

bool                 Nsdb_ReadFieldMaybe(dmmeta::Nsdb &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsdb from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsdb_ReadStrptrMaybe(dmmeta::Nsdb &parent, algo::strptr in_str);
// print string representation of dmmeta::Nsdb to string LHS, no header -- cprint:dmmeta.Nsdb.String
void                 Nsdb_Print(dmmeta::Nsdb & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsinclude
struct Nsinclude { // dmmeta.Nsinclude
    algo::Smallstr50   nsinclude;   //
    bool               sys;         //   false
    algo::Comment      comment;     //
    Nsinclude();
};

algo::Smallstr16     ns_Get(dmmeta::Nsinclude& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Nsinclude_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Nsinclude& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Nsinclude_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Nsinclude_Concat_ns_name( const algo::strptr& ns ,const algo::strptr& name );
bool                 Nsinclude_ReadFieldMaybe(dmmeta::Nsinclude &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsinclude from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsinclude_ReadStrptrMaybe(dmmeta::Nsinclude &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Nsinclude_Init(dmmeta::Nsinclude& parent);
// print string representation of dmmeta::Nsinclude to string LHS, no header -- cprint:dmmeta.Nsinclude.String
void                 Nsinclude_Print(dmmeta::Nsinclude & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsproto
struct Nsproto { // dmmeta.Nsproto
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    explicit Nsproto(const algo::strptr&            in_ns
        ,const algo::Comment&           in_comment);
    Nsproto();
};

bool                 Nsproto_ReadFieldMaybe(dmmeta::Nsproto &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsproto from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsproto_ReadStrptrMaybe(dmmeta::Nsproto &parent, algo::strptr in_str);
// print string representation of dmmeta::Nsproto to string LHS, no header -- cprint:dmmeta.Nsproto.String
void                 Nsproto_Print(dmmeta::Nsproto & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nstype
struct Nstype { // dmmeta.Nstype
    algo::Smallstr50   nstype;    //
    algo::Comment      comment;   //
    explicit Nstype(const algo::strptr&            in_nstype
        ,const algo::Comment&           in_comment);
    Nstype();
};

bool                 Nstype_ReadFieldMaybe(dmmeta::Nstype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nstype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nstype_ReadStrptrMaybe(dmmeta::Nstype &parent, algo::strptr in_str);
// print string representation of dmmeta::Nstype to string LHS, no header -- cprint:dmmeta.Nstype.String
void                 Nstype_Print(dmmeta::Nstype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsversion
struct Nsversion { // dmmeta.Nsversion
    algo::Smallstr16   ns;        //
    algo::Smallstr10   version;   //
    algo::Comment      comment;   //
    Nsversion();
};

bool                 Nsversion_ReadFieldMaybe(dmmeta::Nsversion &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsversion from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsversion_ReadStrptrMaybe(dmmeta::Nsversion &parent, algo::strptr in_str);
// print string representation of dmmeta::Nsversion to string LHS, no header -- cprint:dmmeta.Nsversion.String
void                 Nsversion_Print(dmmeta::Nsversion & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Nsx
struct Nsx { // dmmeta.Nsx
    algo::Smallstr16    ns;                    //
    bool                genthrow;              //   false
    bool                correct_getorcreate;   //   false
    algo::Smallstr100   pool;                  //
    bool                sortxref;              //   false
    bool                pack;                  //   false
    bool                fldoffset_asserts;     //   false
    algo::Comment       comment;               //
    explicit Nsx(const algo::strptr&            in_ns
        ,bool                           in_genthrow
        ,bool                           in_correct_getorcreate
        ,const algo::strptr&            in_pool
        ,bool                           in_sortxref
        ,bool                           in_pack
        ,bool                           in_fldoffset_asserts
        ,const algo::Comment&           in_comment);
    Nsx();
};

bool                 Nsx_ReadFieldMaybe(dmmeta::Nsx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Nsx from an ascii string.
// The format of the string is an ssim Tuple
bool                 Nsx_ReadStrptrMaybe(dmmeta::Nsx &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Nsx_Init(dmmeta::Nsx& parent);
// print string representation of dmmeta::Nsx to string LHS, no header -- cprint:dmmeta.Nsx.String
void                 Nsx_Print(dmmeta::Nsx & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Numstr
struct Numstr { // dmmeta.Numstr
    algo::Smallstr100   field;     // String type
    algo::Smallstr50    numtype;   // Corresponding numeric type
    i32                 base;      //   0  Base for conversion
    i32                 min_len;   //   0  Mininum length of string
    explicit Numstr(const algo::strptr&            in_field
        ,const algo::strptr&            in_numtype
        ,i32                            in_base
        ,i32                            in_min_len);
    Numstr();
};

bool                 Numstr_ReadFieldMaybe(dmmeta::Numstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Numstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Numstr_ReadStrptrMaybe(dmmeta::Numstr &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Numstr_Init(dmmeta::Numstr& parent);
// print string representation of dmmeta::Numstr to string LHS, no header -- cprint:dmmeta.Numstr.String
void                 Numstr_Print(dmmeta::Numstr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Pack
struct Pack { // dmmeta.Pack: Request byte-packing of structure fields
    algo::Smallstr50   ctype;     // Target ctype
    algo::Comment      comment;   //
    explicit Pack(const algo::strptr&            in_ctype
        ,const algo::Comment&           in_comment);
    Pack();
};

bool                 Pack_ReadFieldMaybe(dmmeta::Pack &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pack from an ascii string.
// The format of the string is an ssim Tuple
bool                 Pack_ReadStrptrMaybe(dmmeta::Pack &parent, algo::strptr in_str);
// print string representation of dmmeta::Pack to string LHS, no header -- cprint:dmmeta.Pack.String
void                 Pack_Print(dmmeta::Pack & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Pmaskfld
struct Pmaskfld { // dmmeta.Pmaskfld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Pmaskfld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Pmaskfld();
};

algo::Smallstr50     ctype_Get(dmmeta::Pmaskfld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Pmaskfld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Pmaskfld_ReadFieldMaybe(dmmeta::Pmaskfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pmaskfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Pmaskfld_ReadStrptrMaybe(dmmeta::Pmaskfld &parent, algo::strptr in_str);
// print string representation of dmmeta::Pmaskfld to string LHS, no header -- cprint:dmmeta.Pmaskfld.String
void                 Pmaskfld_Print(dmmeta::Pmaskfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Pnew
struct Pnew { // dmmeta.Pnew: placement new
    algo::Smallstr100   pnew;      //
    algo::Comment       comment;   //
    explicit Pnew(const algo::strptr&            in_pnew
        ,const algo::Comment&           in_comment);
    Pnew();
};

algo::Smallstr16     ns_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Pnew_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Pnew_ctype_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     buftype_Get(dmmeta::Pnew& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Pnew_buftype_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Pnew_Concat_ns_ctype_buftype( const algo::strptr& ns ,const algo::strptr& ctype ,const algo::strptr& buftype );
bool                 Pnew_ReadFieldMaybe(dmmeta::Pnew &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Pnew from an ascii string.
// The format of the string is an ssim Tuple
bool                 Pnew_ReadStrptrMaybe(dmmeta::Pnew &parent, algo::strptr in_str);
// print string representation of dmmeta::Pnew to string LHS, no header -- cprint:dmmeta.Pnew.String
void                 Pnew_Print(dmmeta::Pnew & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Printfmt
struct Printfmt { // dmmeta.Printfmt
    algo::Smallstr50   printfmt;   //
    algo::Comment      comment;    //
    Printfmt();
};

bool                 Printfmt_ReadFieldMaybe(dmmeta::Printfmt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Printfmt from an ascii string.
// The format of the string is an ssim Tuple
bool                 Printfmt_ReadStrptrMaybe(dmmeta::Printfmt &parent, algo::strptr in_str);
// print string representation of dmmeta::Printfmt to string LHS, no header -- cprint:dmmeta.Printfmt.String
void                 Printfmt_Print(dmmeta::Printfmt & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ptrary
struct Ptrary { // dmmeta.Ptrary
    algo::Smallstr100   field;    //
    bool                unique;   //   false  Search for and ignore duplicates
    explicit Ptrary(const algo::strptr&            in_field
        ,bool                           in_unique);
    Ptrary();
};

bool                 Ptrary_ReadFieldMaybe(dmmeta::Ptrary &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ptrary from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ptrary_ReadStrptrMaybe(dmmeta::Ptrary &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Ptrary_Init(dmmeta::Ptrary& parent);
// print string representation of dmmeta::Ptrary to string LHS, no header -- cprint:dmmeta.Ptrary.String
void                 Ptrary_Print(dmmeta::Ptrary & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Reftype
struct Reftype { // dmmeta.Reftype
    algo::Smallstr50   reftype;       //   "Val"
    bool               isval;         //   false  True if field makes values of target type
    bool               cascins;       //   false  Field is cascade-insert
    bool               usebasepool;   //   false
    bool               cancopy;       //   false
    bool               isxref;        //   false
    bool               del;           //   false  Supports random deletion?
    bool               up;            //   false
    bool               isnew;         //   false
    bool               hasalloc;      //   false
    bool               inst;          //   false
    bool               varlen;        //   false
    Reftype();
};

bool                 Reftype_ReadFieldMaybe(dmmeta::Reftype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Reftype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Reftype_ReadStrptrMaybe(dmmeta::Reftype &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Reftype_Init(dmmeta::Reftype& parent);
// print string representation of dmmeta::Reftype to string LHS, no header -- cprint:dmmeta.Reftype.String
void                 Reftype_Print(dmmeta::Reftype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.ReftypeCase
#pragma pack(push,1)
struct ReftypeCase { // dmmeta.ReftypeCase: enum helper 
    u8   reftype;   //   0
    inline operator dmmeta_ReftypeCaseEnum() const;
    explicit ReftypeCase(u8                             in_reftype);
    ReftypeCase(dmmeta_ReftypeCaseEnum arg);
    ReftypeCase();
};
#pragma pack(pop)

// Get value of field as enum type
dmmeta_ReftypeCaseEnum reftype_GetEnum(const dmmeta::ReftypeCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 reftype_SetEnum(dmmeta::ReftypeCase& parent, dmmeta_ReftypeCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          reftype_ToCstr(const dmmeta::ReftypeCase& parent) __attribute__((nothrow));
// Convert reftype to a string. First, attempt conversion to a known string.
// If no string matches, print reftype as a numeric value.
void                 reftype_Print(const dmmeta::ReftypeCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 reftype_SetStrptrMaybe(dmmeta::ReftypeCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 reftype_SetStrptr(dmmeta::ReftypeCase& parent, algo::strptr rhs, dmmeta_ReftypeCaseEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 ReftypeCase_Init(dmmeta::ReftypeCase& parent);

// --- dmmeta.ReftypeId
struct ReftypeId { // dmmeta.ReftypeId
    u8   value;   //   0
    inline operator dmmeta_ReftypeIdEnum() const;
    explicit ReftypeId(u8                             in_value);
    ReftypeId(dmmeta_ReftypeIdEnum arg);
    ReftypeId();
};

// Get value of field as enum type
dmmeta_ReftypeIdEnum value_GetEnum(const dmmeta::ReftypeId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(dmmeta::ReftypeId& parent, dmmeta_ReftypeIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const dmmeta::ReftypeId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const dmmeta::ReftypeId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(dmmeta::ReftypeId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(dmmeta::ReftypeId& parent, algo::strptr rhs, dmmeta_ReftypeIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(dmmeta::ReftypeId& parent, algo::strptr rhs) __attribute__((nothrow));

u32                  ReftypeId_Hash(u32 prev, dmmeta::ReftypeId rhs) __attribute__((nothrow));
// Read fields of dmmeta::ReftypeId from an ascii string.
// The format of the string is the format of the dmmeta::ReftypeId's only field
bool                 ReftypeId_ReadStrptrMaybe(dmmeta::ReftypeId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 ReftypeId_Init(dmmeta::ReftypeId& parent);
// print string representation of dmmeta::ReftypeId to string LHS, no header -- cprint:dmmeta.ReftypeId.String
void                 ReftypeId_Print(dmmeta::ReftypeId row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Rowid
struct Rowid { // dmmeta.Rowid: Initialize field to row id of element
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    Rowid();
};

bool                 Rowid_ReadFieldMaybe(dmmeta::Rowid &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Rowid from an ascii string.
// The format of the string is an ssim Tuple
bool                 Rowid_ReadStrptrMaybe(dmmeta::Rowid &parent, algo::strptr in_str);
// print string representation of dmmeta::Rowid to string LHS, no header -- cprint:dmmeta.Rowid.String
void                 Rowid_Print(dmmeta::Rowid & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Smallstr
struct Smallstr { // dmmeta.Smallstr
    algo::Smallstr100   field;     //
    i32                 length;    //   0  Maximum characters in the string
    algo::Smallstr50    strtype;   // Data format for string
    dmmeta::CppExpr     pad;       // Pad character (if applicable)
    bool                strict;    //   false
    Smallstr();
};

algo::Smallstr50     ctype_Get(dmmeta::Smallstr& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Smallstr_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Smallstr_ReadFieldMaybe(dmmeta::Smallstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Smallstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Smallstr_ReadStrptrMaybe(dmmeta::Smallstr &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Smallstr_Init(dmmeta::Smallstr& parent);
// print string representation of dmmeta::Smallstr to string LHS, no header -- cprint:dmmeta.Smallstr.String
void                 Smallstr_Print(dmmeta::Smallstr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Sortfld
struct Sortfld { // dmmeta.Sortfld
    algo::Smallstr100   field;     //
    algo::Smallstr100   sortfld;   // Field to sort by
    explicit Sortfld(const algo::strptr&            in_field
        ,const algo::strptr&            in_sortfld);
    Sortfld();
};

bool                 Sortfld_ReadFieldMaybe(dmmeta::Sortfld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sortfld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Sortfld_ReadStrptrMaybe(dmmeta::Sortfld &parent, algo::strptr in_str);
// print string representation of dmmeta::Sortfld to string LHS, no header -- cprint:dmmeta.Sortfld.String
void                 Sortfld_Print(dmmeta::Sortfld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Sorttype
struct Sorttype { // dmmeta.Sorttype
    algo::Smallstr50   sorttype;   //
    algo::Comment      comment;    //
    Sorttype();
};

bool                 Sorttype_ReadFieldMaybe(dmmeta::Sorttype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sorttype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Sorttype_ReadStrptrMaybe(dmmeta::Sorttype &parent, algo::strptr in_str);
// print string representation of dmmeta::Sorttype to string LHS, no header -- cprint:dmmeta.Sorttype.String
void                 Sorttype_Print(dmmeta::Sorttype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Sqltype
struct Sqltype { // dmmeta.Sqltype
    algo::Smallstr50    ctype;     //
    algo::Smallstr100   expr;      //
    algo::Comment       comment;   //
    Sqltype();
};

bool                 Sqltype_ReadFieldMaybe(dmmeta::Sqltype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Sqltype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Sqltype_ReadStrptrMaybe(dmmeta::Sqltype &parent, algo::strptr in_str);
// print string representation of dmmeta::Sqltype to string LHS, no header -- cprint:dmmeta.Sqltype.String
void                 Sqltype_Print(dmmeta::Sqltype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimfile
struct Ssimfile { // dmmeta.Ssimfile: Ssim tuple name for structure
    algo::Smallstr50   ssimfile;   //
    algo::Smallstr50   ctype;      //
    explicit Ssimfile(const algo::strptr&            in_ssimfile
        ,const algo::strptr&            in_ctype);
    Ssimfile();
};

algo::Smallstr16     ssimns_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Ssimfile_ssimns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Ssimfile_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Ssimfile& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Ssimfile_name_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Ssimfile_ReadFieldMaybe(dmmeta::Ssimfile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimfile from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimfile_ReadStrptrMaybe(dmmeta::Ssimfile &parent, algo::strptr in_str);
// print string representation of dmmeta::Ssimfile to string LHS, no header -- cprint:dmmeta.Ssimfile.String
void                 Ssimfile_Print(dmmeta::Ssimfile & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimsort
struct Ssimsort { // dmmeta.Ssimsort
    algo::Smallstr50    ssimfile;   //
    algo::Smallstr100   sortfld;    //
    algo::Comment       comment;    //
    Ssimsort();
};

bool                 Ssimsort_ReadFieldMaybe(dmmeta::Ssimsort &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimsort from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimsort_ReadStrptrMaybe(dmmeta::Ssimsort &parent, algo::strptr in_str);
// print string representation of dmmeta::Ssimsort to string LHS, no header -- cprint:dmmeta.Ssimsort.String
void                 Ssimsort_Print(dmmeta::Ssimsort & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Ssimvolatile
struct Ssimvolatile { // dmmeta.Ssimvolatile
    algo::Smallstr50   ssimfile;   //
    algo::Comment      comment;    //
    Ssimvolatile();
};

bool                 Ssimvolatile_ReadFieldMaybe(dmmeta::Ssimvolatile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Ssimvolatile from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ssimvolatile_ReadStrptrMaybe(dmmeta::Ssimvolatile &parent, algo::strptr in_str);
// print string representation of dmmeta::Ssimvolatile to string LHS, no header -- cprint:dmmeta.Ssimvolatile.String
void                 Ssimvolatile_Print(dmmeta::Ssimvolatile & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Steptype
struct Steptype { // dmmeta.Steptype
    algo::Smallstr50   steptype;   //
    algo::Comment      comment;    //
    explicit Steptype(const algo::strptr&            in_steptype
        ,const algo::Comment&           in_comment);
    Steptype();
};

bool                 Steptype_ReadFieldMaybe(dmmeta::Steptype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Steptype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Steptype_ReadStrptrMaybe(dmmeta::Steptype &parent, algo::strptr in_str);
// print string representation of dmmeta::Steptype to string LHS, no header -- cprint:dmmeta.Steptype.String
void                 Steptype_Print(dmmeta::Steptype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Strfmt
struct Strfmt { // dmmeta.Strfmt
    algo::Smallstr50   strfmt;    //
    algo::Comment      comment;   //
    explicit Strfmt(const algo::strptr&            in_strfmt
        ,const algo::Comment&           in_comment);
    Strfmt();
};


// --- dmmeta.Strtype
struct Strtype { // dmmeta.Strtype
    algo::Smallstr50   strtype;   //
    algo::Comment      comment;   //
    explicit Strtype(const algo::strptr&            in_strtype
        ,const algo::Comment&           in_comment);
    Strtype();
};

bool                 Strtype_ReadFieldMaybe(dmmeta::Strtype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Strtype from an ascii string.
// The format of the string is an ssim Tuple
bool                 Strtype_ReadStrptrMaybe(dmmeta::Strtype &parent, algo::strptr in_str);
// print string representation of dmmeta::Strtype to string LHS, no header -- cprint:dmmeta.Strtype.String
void                 Strtype_Print(dmmeta::Strtype & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Substr
struct Substr { // dmmeta.Substr: Computed field
    algo::Smallstr100   field;      //
    dmmeta::CppExpr     expr;       //
    algo::Smallstr100   srcfield;   //
    explicit Substr(const algo::strptr&            in_field
        ,const dmmeta::CppExpr&         in_expr
        ,const algo::strptr&            in_srcfield);
    Substr();
};

bool                 Substr_ReadFieldMaybe(dmmeta::Substr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Substr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Substr_ReadStrptrMaybe(dmmeta::Substr &parent, algo::strptr in_str);
// print string representation of dmmeta::Substr to string LHS, no header -- cprint:dmmeta.Substr.String
void                 Substr_Print(dmmeta::Substr & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Tary
struct Tary { // dmmeta.Tary: Indirect linear array
    algo::Smallstr100   field;     //
    bool                aliased;   //   false  Geneate functions to copy from aryptr
    algo::Comment       comment;   //
    Tary();
};

bool                 Tary_ReadFieldMaybe(dmmeta::Tary &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tary from an ascii string.
// The format of the string is an ssim Tuple
bool                 Tary_ReadStrptrMaybe(dmmeta::Tary &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Tary_Init(dmmeta::Tary& parent);
// print string representation of dmmeta::Tary to string LHS, no header -- cprint:dmmeta.Tary.String
void                 Tary_Print(dmmeta::Tary & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Thash
struct Thash { // dmmeta.Thash
    algo::Smallstr100   field;     //
    algo::Smallstr100   hashfld;   // Field on which hash function is computed
    bool                unique;    //   true  Enforce uniqueness of member elements
    algo::Comment       comment;   //
    explicit Thash(const algo::strptr&            in_field
        ,const algo::strptr&            in_hashfld
        ,bool                           in_unique
        ,const algo::Comment&           in_comment);
    Thash();
};

bool                 Thash_ReadFieldMaybe(dmmeta::Thash &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Thash from an ascii string.
// The format of the string is an ssim Tuple
bool                 Thash_ReadStrptrMaybe(dmmeta::Thash &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Thash_Init(dmmeta::Thash& parent);
// print string representation of dmmeta::Thash to string LHS, no header -- cprint:dmmeta.Thash.String
void                 Thash_Print(dmmeta::Thash & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Tracefld
struct Tracefld { // dmmeta.Tracefld: Trace fields
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
    explicit Tracefld(const algo::strptr&            in_tracefld
        ,const algo::Comment&           in_comment);
    Tracefld();
};

algo::Smallstr50     tracerec_Get(dmmeta::Tracefld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Tracefld_tracerec_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr50     name_Get(dmmeta::Tracefld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Tracefld_name_Get(algo::strptr arg) __attribute__((nothrow));

tempstr              Tracefld_Concat_tracerec_name( const algo::strptr& tracerec ,const algo::strptr& name );
bool                 Tracefld_ReadFieldMaybe(dmmeta::Tracefld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tracefld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Tracefld_ReadStrptrMaybe(dmmeta::Tracefld &parent, algo::strptr in_str);
// print string representation of dmmeta::Tracefld to string LHS, no header -- cprint:dmmeta.Tracefld.String
void                 Tracefld_Print(dmmeta::Tracefld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Tracerec
struct Tracerec { // dmmeta.Tracerec
    algo::Smallstr50   tracerec;   // e.g. rl_lib.trace
    algo::Comment      comment;    //
    explicit Tracerec(const algo::strptr&            in_tracerec
        ,const algo::Comment&           in_comment);
    Tracerec();
};

algo::Smallstr50     name_Get(dmmeta::Tracerec& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Tracerec_name_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Tracerec_ReadFieldMaybe(dmmeta::Tracerec &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Tracerec from an ascii string.
// The format of the string is an ssim Tuple
bool                 Tracerec_ReadStrptrMaybe(dmmeta::Tracerec &parent, algo::strptr in_str);
// print string representation of dmmeta::Tracerec to string LHS, no header -- cprint:dmmeta.Tracerec.String
void                 Tracerec_Print(dmmeta::Tracerec & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Typefld
struct Typefld { // dmmeta.Typefld: Specifies which field of a message carries the type
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    explicit Typefld(const algo::strptr&            in_field
        ,const algo::Comment&           in_comment);
    Typefld();
};

algo::Smallstr50     ctype_Get(dmmeta::Typefld& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Typefld_ctype_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Typefld_ReadFieldMaybe(dmmeta::Typefld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Typefld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Typefld_ReadStrptrMaybe(dmmeta::Typefld &parent, algo::strptr in_str);
// print string representation of dmmeta::Typefld to string LHS, no header -- cprint:dmmeta.Typefld.String
void                 Typefld_Print(dmmeta::Typefld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Usertracefld
struct Usertracefld { // dmmeta.Usertracefld
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
    Usertracefld();
};

bool                 Usertracefld_ReadFieldMaybe(dmmeta::Usertracefld &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Usertracefld from an ascii string.
// The format of the string is an ssim Tuple
bool                 Usertracefld_ReadStrptrMaybe(dmmeta::Usertracefld &parent, algo::strptr in_str);
// print string representation of dmmeta::Usertracefld to string LHS, no header -- cprint:dmmeta.Usertracefld.String
void                 Usertracefld_Print(dmmeta::Usertracefld & row, algo::cstring &str) __attribute__((nothrow));

// --- dmmeta.Xref
struct Xref { // dmmeta.Xref: X-reference
    algo::Smallstr100   field;     //
    dmmeta::CppExpr     inscond;   //   "true"  Insert condition
    algo::Smallstr200   via;       //
    explicit Xref(const algo::strptr&            in_field
        ,const dmmeta::CppExpr&         in_inscond
        ,const algo::strptr&            in_via);
    Xref();
};

algo::Smallstr50     name_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr50     Xref_name_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr16     ns_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr16     Xref_ns_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    viafld_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Xref_viafld_Get(algo::strptr arg) __attribute__((nothrow));

algo::Smallstr100    keyfld_Get(dmmeta::Xref& parent) __attribute__((__warn_unused_result__, nothrow));
algo::Smallstr100    Xref_keyfld_Get(algo::strptr arg) __attribute__((nothrow));

bool                 Xref_ReadFieldMaybe(dmmeta::Xref &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of dmmeta::Xref from an ascii string.
// The format of the string is an ssim Tuple
bool                 Xref_ReadStrptrMaybe(dmmeta::Xref &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Xref_Init(dmmeta::Xref& parent);
// print string representation of dmmeta::Xref to string LHS, no header -- cprint:dmmeta.Xref.String
void                 Xref_Print(dmmeta::Xref & row, algo::cstring &str) __attribute__((nothrow));
} // end namespace dmmeta
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Anonfld &row);// cfmt:dmmeta.Anonfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::BuftypeId &row);// cfmt:dmmeta.BuftypeId.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cascdel &row);// cfmt:dmmeta.Cascdel.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cdecl &row);// cfmt:dmmeta.Cdecl.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::CppExpr &row);// cfmt:dmmeta.CppExpr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Cfmt &row);// cfmt:dmmeta.Cfmt.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Charset &row);// cfmt:dmmeta.Charset.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ctype &row);// cfmt:dmmeta.Ctype.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ctypelen &row);// cfmt:dmmeta.Ctypelen.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Dispsigcheck &row);// cfmt:dmmeta.Dispsigcheck.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbase &row);// cfmt:dmmeta.Fbase.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fbigend &row);// cfmt:dmmeta.Fbigend.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fconst &row);// cfmt:dmmeta.Fconst.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Field &row);// cfmt:dmmeta.Field.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::FieldId &row);// cfmt:dmmeta.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Finput &row);// cfmt:dmmeta.Finput.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fnoremove &row);// cfmt:dmmeta.Fnoremove.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fstep &row);// cfmt:dmmeta.Fstep.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Funique &row);// cfmt:dmmeta.Funique.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Fuserinit &row);// cfmt:dmmeta.Fuserinit.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gstatic &row);// cfmt:dmmeta.Gstatic.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Gsymbol &row);// cfmt:dmmeta.Gsymbol.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Hook &row);// cfmt:dmmeta.Hook.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Llist &row);// cfmt:dmmeta.Llist.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Main &row);// cfmt:dmmeta.Main.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nossimfile &row);// cfmt:dmmeta.Nossimfile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ns &row);// cfmt:dmmeta.Ns.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsinclude &row);// cfmt:dmmeta.Nsinclude.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsproto &row);// cfmt:dmmeta.Nsproto.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Nsx &row);// cfmt:dmmeta.Nsx.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ptrary &row);// cfmt:dmmeta.Ptrary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::ReftypeId &row);// cfmt:dmmeta.ReftypeId.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Sortfld &row);// cfmt:dmmeta.Sortfld.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimfile &row);// cfmt:dmmeta.Ssimfile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimsort &row);// cfmt:dmmeta.Ssimsort.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Ssimvolatile &row);// cfmt:dmmeta.Ssimvolatile.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Substr &row);// cfmt:dmmeta.Substr.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Tary &row);// cfmt:dmmeta.Tary.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Thash &row);// cfmt:dmmeta.Thash.String
inline algo::cstring &operator <<(algo::cstring &str, const dmmeta::Xref &row);// cfmt:dmmeta.Xref.String
}
