//
// include/gen/atf_amc_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/lib/lib_json.h"
#include "include/gen/algo_gen.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/dmmeta_gen.h"
//#pragma endinclude

// --- atf_amc_DispCaseEnum

enum atf_amc_DispCaseEnum {                    // atf_amc.DispCase.value
     atf_amc_DispCase_atf_amc_DispType1   = 1
    ,atf_amc_DispCase_atf_amc_DispType2   = 2
    ,atf_amc_DispCase_atf_amc_DispType3   = 3
};

enum { atf_amc_DispCaseEnum_N = 3 };


// --- atf_amc_FCascdel_type_Enum

enum atf_amc_FCascdel_type_Enum {        // atf_amc.FCascdel.type
     atf_amc_FCascdel_type_none     = 0
    ,atf_amc_FCascdel_type_ptr      = 1
    ,atf_amc_FCascdel_type_ptrary   = 2
    ,atf_amc_FCascdel_type_thash    = 3
    ,atf_amc_FCascdel_type_bheap    = 4
    ,atf_amc_FCascdel_type_zdlist   = 6
    ,atf_amc_FCascdel_type_atree    = 6
};

enum { atf_amc_FCascdel_type_Enum_N = 7 };


// --- atf_amc_FieldIdEnum

enum atf_amc_FieldIdEnum {                  // atf_amc.FieldId.value
     atf_amc_FieldId_value           = 0
    ,atf_amc_FieldId_bit1            = 1
    ,atf_amc_FieldId_bits5           = 2
    ,atf_amc_FieldId_attr1           = 3
    ,atf_amc_FieldId_attr2           = 4
    ,atf_amc_FieldId_strval          = 5
    ,atf_amc_FieldId_strval2         = 6
    ,atf_amc_FieldId_dateval         = 7
    ,atf_amc_FieldId_intval          = 8
    ,atf_amc_FieldId_fixary          = 9
    ,atf_amc_FieldId_inlary          = 10
    ,atf_amc_FieldId_type            = 11
    ,atf_amc_FieldId_length          = 12
    ,atf_amc_FieldId_typeg           = 13
    ,atf_amc_FieldId_optg            = 14
    ,atf_amc_FieldId_pmask           = 15
    ,atf_amc_FieldId_value2          = 16
    ,atf_amc_FieldId_value3          = 17
    ,atf_amc_FieldId_value21         = 18
    ,atf_amc_FieldId_value22         = 19
    ,atf_amc_FieldId_value23         = 20
    ,atf_amc_FieldId_value24         = 21
    ,atf_amc_FieldId_value25         = 22
    ,atf_amc_FieldId_value26         = 23
    ,atf_amc_FieldId_value20         = 24
    ,atf_amc_FieldId_value28         = 25
    ,atf_amc_FieldId_value29         = 26
    ,atf_amc_FieldId_value30         = 27
    ,atf_amc_FieldId_value31         = 28
    ,atf_amc_FieldId_value32         = 29
    ,atf_amc_FieldId_value27         = 30
    ,atf_amc_FieldId_value19         = 31
    ,atf_amc_FieldId_value18         = 32
    ,atf_amc_FieldId_value4          = 33
    ,atf_amc_FieldId_value5          = 34
    ,atf_amc_FieldId_value6          = 35
    ,atf_amc_FieldId_value7          = 36
    ,atf_amc_FieldId_value8          = 37
    ,atf_amc_FieldId_value9          = 38
    ,atf_amc_FieldId_value69         = 39
    ,atf_amc_FieldId_value11         = 40
    ,atf_amc_FieldId_value12         = 41
    ,atf_amc_FieldId_value13         = 42
    ,atf_amc_FieldId_value14         = 43
    ,atf_amc_FieldId_value15         = 44
    ,atf_amc_FieldId_value16         = 45
    ,atf_amc_FieldId_value33         = 46
    ,atf_amc_FieldId_value10         = 47
    ,atf_amc_FieldId_value17         = 48
    ,atf_amc_FieldId_value35         = 49
    ,atf_amc_FieldId_value55         = 50
    ,atf_amc_FieldId_value56         = 51
    ,atf_amc_FieldId_value57         = 52
    ,atf_amc_FieldId_value58         = 53
    ,atf_amc_FieldId_value59         = 54
    ,atf_amc_FieldId_value60         = 55
    ,atf_amc_FieldId_value54         = 56
    ,atf_amc_FieldId_value62         = 57
    ,atf_amc_FieldId_value63         = 58
    ,atf_amc_FieldId_value64         = 59
    ,atf_amc_FieldId_value65         = 60
    ,atf_amc_FieldId_value66         = 61
    ,atf_amc_FieldId_value67         = 62
    ,atf_amc_FieldId_value68         = 63
    ,atf_amc_FieldId_value61         = 64
    ,atf_amc_FieldId_value34         = 65
    ,atf_amc_FieldId_value52         = 66
    ,atf_amc_FieldId_value36         = 67
    ,atf_amc_FieldId_value37         = 68
    ,atf_amc_FieldId_value38         = 69
    ,atf_amc_FieldId_value39         = 70
    ,atf_amc_FieldId_value40         = 71
    ,atf_amc_FieldId_value41         = 72
    ,atf_amc_FieldId_value42         = 73
    ,atf_amc_FieldId_value53         = 74
    ,atf_amc_FieldId_value44         = 75
    ,atf_amc_FieldId_value45         = 76
    ,atf_amc_FieldId_value46         = 77
    ,atf_amc_FieldId_value47         = 78
    ,atf_amc_FieldId_value48         = 79
    ,atf_amc_FieldId_value49         = 80
    ,atf_amc_FieldId_value50         = 81
    ,atf_amc_FieldId_value51         = 82
    ,atf_amc_FieldId_value43         = 83
    ,atf_amc_FieldId_value70         = 84
    ,atf_amc_FieldId_value71         = 85
    ,atf_amc_FieldId_ch              = 86
    ,atf_amc_FieldId_val1            = 87
    ,atf_amc_FieldId_val2            = 88
    ,atf_amc_FieldId_val3            = 89
    ,atf_amc_FieldId_msghdr          = 90
    ,atf_amc_FieldId_payload         = 91
    ,atf_amc_FieldId_val             = 92
    ,atf_amc_FieldId_text            = 93
    ,atf_amc_FieldId_typea           = 94
    ,atf_amc_FieldId_j               = 95
    ,atf_amc_FieldId_typec           = 96
    ,atf_amc_FieldId_typeh           = 97
    ,atf_amc_FieldId_types           = 98
    ,atf_amc_FieldId_comment         = 99
    ,atf_amc_FieldId_i               = 100
    ,atf_amc_FieldId_strval_regx     = 101
    ,atf_amc_FieldId_strval2_regx    = 102
    ,atf_amc_FieldId_start_dateval   = 103
    ,atf_amc_FieldId_end_dateval     = 104
    ,atf_amc_FieldId_start_intval    = 105
    ,atf_amc_FieldId_end_intval      = 106
};

enum { atf_amc_FieldIdEnum_N = 107 };


// --- atf_amc_MsgTypeEnum

enum atf_amc_MsgTypeEnum {                       // atf_amc.MsgType.value
     atf_amc_MsgType_atf_amc_Seqmsg   = 0x0905   // Sequenced message for stream
    ,atf_amc_MsgType_atf_amc_Text     = 0x0412
};

enum { atf_amc_MsgTypeEnum_N = 2 };


// --- atf_amc_MsgsCaseEnum

enum atf_amc_MsgsCaseEnum {                  // atf_amc.MsgsCase.value
     atf_amc_MsgsCase_atf_amc_VarlenK   = 1
};

enum { atf_amc_MsgsCaseEnum_N = 1 };


// --- atf_amc_PooledBE64_value_Enum

enum atf_amc_PooledBE64_value_Enum {       // atf_amc.PooledBE64.value
     atf_amc_PooledBE64_value_A       = 3
    ,atf_amc_PooledBE64_value_B       = 4
};

enum { atf_amc_PooledBE64_value_Enum_N = 2 };


// --- atf_amc_SsimfilesCaseEnum

enum atf_amc_SsimfilesCaseEnum {               // atf_amc.SsimfilesCase.value
     atf_amc_SsimfilesCase_dmmeta_Ctype   = 1
    ,atf_amc_SsimfilesCase_dmmeta_ctype   = 1
};

enum { atf_amc_SsimfilesCaseEnum_N = 2 };


// --- atf_amc_TableIdEnum

enum atf_amc_TableIdEnum {                 // atf_amc.TableId.value
     atf_amc_TableId_atf_amc_TypeS   = 0   // atf_amc.TypeS -> atf_amc.FTypeS
    ,atf_amc_TableId_atf_amc_TypeT   = 1   // atf_amc.TypeT -> atf_amc.FTypeT
};

enum { atf_amc_TableIdEnum_N = 2 };


// --- atf_amc_TypeBE64en_value_Enum

enum atf_amc_TypeBE64en_value_Enum {                        // atf_amc.TypeBE64en.value
     atf_amc_TypeBE64en_value_val1    = 0xfedcba9876543210
    ,atf_amc_TypeBE64en_value_val2    = 0x1032547698badcfe
};

enum { atf_amc_TypeBE64en_value_Enum_N = 2 };


// --- atf_amc_Typefconst_value_Enum

enum atf_amc_Typefconst_value_Enum {         // atf_amc.Typefconst.value
     atf_amc_Typefconst_value_strval1   = 1
    ,atf_amc_Typefconst_value_strval2   = 2
};

enum { atf_amc_Typefconst_value_Enum_N = 2 };

namespace atfdb { struct Amctest; }
namespace atf_amc { struct FCascdel; }
namespace atf_amc { struct Cstring; }
namespace dmmeta { struct Listtype; }
namespace atf_amc { struct OptG; }
namespace atf_amc { struct TypeG; }
namespace atf_amc { struct TypeA; }
namespace atf_amc { struct TypeB; }
namespace atf_amc { struct TypeC; }
namespace atf_amc { struct TypeS; }
namespace atf_amc { struct TypeT; }
namespace atf_amc { struct MsgHeader; }
namespace atf_amc { struct TypeH; }
namespace atf_amc { struct DispType1; }
namespace atf_amc { struct DispType2; }
namespace atf_amc { struct DispType3; }
namespace atf_amc { struct VarlenK; }
namespace dmmeta { struct Ctype; }
namespace atf_amc { struct Seqmsg; }
namespace atf_amc { struct Text; }
namespace atf_amc { struct OptOptG; }
namespace atf_amc { struct MsgType; }
namespace atf_amc { struct MsgLength; }
namespace atf_amc { struct AmcCleanup2; }
namespace atf_amc { struct AmcSubstr1; }
namespace atf_amc { struct BitfldType1; }
namespace atf_amc { struct BitfldU128; }
namespace atf_amc { struct BitfldU16; }
namespace atf_amc { struct Bytebuf; }
namespace atf_amc { struct Cstr; }
namespace atf_amc { struct Ctype1Attr; }
namespace atf_amc { struct Ctype2Attr; }
namespace atf_amc { struct DelType1; }
namespace atf_amc { struct DispCase; }
namespace atf_amc { struct DispFilter; }
namespace atf_amc { struct FAmctest; }
namespace atf_amc { struct FAvl; }
namespace atf_amc { struct FCstring; }
namespace atf_amc { struct FListtype; }
namespace atf_amc { struct trace; }
namespace atf_amc { struct FDb; }
namespace atf_amc { struct FOptG; }
namespace atf_amc { struct FPerfSortString; }
namespace atf_amc { struct FTypeC; }
namespace atf_amc { struct FTypeA; }
namespace atf_amc { struct FTypeB; }
namespace atf_amc { struct FTypeK; }
namespace atf_amc { struct FTypeS; }
namespace atf_amc { struct FTypeT; }
namespace atf_amc { struct FUnitSort; }
namespace atf_amc { struct FieldId; }
namespace atf_amc { struct Hooktype; }
namespace atf_amc { struct InlaryPrint; }
namespace atf_amc { struct Lary32; }
namespace atf_amc { struct Linebuf; }
namespace atf_amc { struct MsgHeader_curs; }
namespace atf_amc { struct Msgbuf; }
namespace atf_amc { struct MsgsCase; }
namespace atf_amc { struct NetBitfld1; }
namespace atf_amc { struct OptAlloc; }
namespace atf_amc { struct PmaskU128; }
namespace atf_amc { struct PmaskU32; }
namespace atf_amc { struct PmaskU555; }
namespace atf_amc { struct PooledBE64; }
namespace atf_amc { struct RnullStr6_U32; }
namespace atf_amc { struct RpasU32Str6; }
namespace atf_amc { struct Sep1; }
namespace atf_amc { struct SortedStr; }
namespace atf_amc { struct SsimfilesCase; }
namespace atf_amc { struct TableId; }
namespace atf_amc { struct TaryU32; }
namespace atf_amc { struct TaryU8; }
namespace atf_amc { struct TestRegx1; }
namespace atf_amc { struct TestType; }
namespace atf_amc { struct TypeBE16; }
namespace atf_amc { struct TypeBE32; }
namespace atf_amc { struct TypeBE64; }
namespace atf_amc { struct TypeBE64dflt; }
namespace atf_amc { struct TypeBE64en; }
namespace atf_amc { struct TypeBE64sf; }
namespace atf_amc { struct Typefconst; }
namespace atf_amc { struct VarlenAlloc; }
namespace atf_amc { struct VarlenExtern; }
namespace atf_amc { struct VarlenH; }
namespace atf_amc { struct DispFilter_pmask_curs; }
namespace atf_amc { struct cascdel_c_child_ptrary_curs; }
namespace atf_amc { struct cascdel_ind_child_thash_curs; }
namespace atf_amc { struct cascdel_bh_child_bheap_curs; }
namespace atf_amc { struct cascdel_bh_child_bheap_unordcurs; }
namespace atf_amc { struct cascdel_zd_childlist_curs; }
namespace atf_amc { struct cascdel_tr_child_atree_curs; }
namespace atf_amc { struct _db_bh_typec_curs; }
namespace atf_amc { struct _db_bh_typec_unordcurs; }
namespace atf_amc { struct _db_zdl_h_typec_curs; }
namespace atf_amc { struct _db_zd_t_typec_curs; }
namespace atf_amc { struct _db_zsl_h_typec_curs; }
namespace atf_amc { struct _db_zs_t_typec_curs; }
namespace atf_amc { struct _db_zdl_hnt_typec_curs; }
namespace atf_amc { struct _db_cdl_h_typec_curs; }
namespace atf_amc { struct _db_cd_t_typec_curs; }
namespace atf_amc { struct _db_csl_h_typec_curs; }
namespace atf_amc { struct _db_cs_t_typec_curs; }
namespace atf_amc { struct _db_typea_curs; }
namespace atf_amc { struct _db_types_curs; }
namespace atf_amc { struct _db_ind_types_curs; }
namespace atf_amc { struct _db_ind_typea_curs; }
namespace atf_amc { struct _db_typet_curs; }
namespace atf_amc { struct _db_cstring_curs; }
namespace atf_amc { struct _db_ind_cstring_curs; }
namespace atf_amc { struct _db_cd_in_msg_curs; }
namespace atf_amc { struct _db_amctest_curs; }
namespace atf_amc { struct _db_c_typek_curs; }
namespace atf_amc { struct _db_avl_curs; }
namespace atf_amc { struct _db_tr_avl_curs; }
namespace atf_amc { struct _db_listtype_curs; }
namespace atf_amc { struct FPerfSortString_orig_curs; }
namespace atf_amc { struct FPerfSortString_sorted1_curs; }
namespace atf_amc { struct typea_typec_curs; }
namespace atf_amc { struct typea_zdl_typeb_curs; }
namespace atf_amc { struct typea_bh_typeb_curs; }
namespace atf_amc { struct typea_bh_typeb_unordcurs; }
namespace atf_amc { struct types_zdl_typet_curs; }
namespace atf_amc { struct FUnitSort_tary_curs; }
namespace atf_amc { struct FUnitSort_c_ptrary_curs; }
namespace atf_amc { struct FUnitSort_fixary_curs; }
namespace atf_amc { struct InlaryPrint_fixary_curs; }
namespace atf_amc { struct InlaryPrint_inlary_curs; }
namespace atf_amc { struct Lary32_lary_curs; }
namespace atf_amc { struct PmaskU555_pmask_curs; }
namespace atf_amc { struct TaryU32_tary_u32_curs; }
namespace atf_amc { struct TaryU8_ary_curs; }
namespace atf_amc { struct Text_text_curs; }
namespace atf_amc { struct varlenalloc_elem_curs; }
namespace atf_amc { struct varlen_extern_varlen_curs; }
namespace atf_amc { struct VarlenH_typeh_curs; }
namespace atf_amc { struct VarlenK_i_curs; }
namespace atf_amc {
    typedef i32 TypeAPkey;
    typedef i32 TypeSPkey;
}//pkey typedefs
namespace atf_amc {
typedef void (*amctest_step_hook)();
typedef void (*listtype_step_hook)(atf_amc::FListtype& arg);
extern const char *atf_amc_help;
extern const char *atf_amc_syntax;
extern FDb _db;
struct varlen_extern_Lpblock {
    varlen_extern_Lpblock* next;
};
struct optalloc_Lpblock {
    optalloc_Lpblock* next;
};
struct varlenalloc_Lpblock {
    varlenalloc_Lpblock* next;
};
struct optg_Lpblock {
    optg_Lpblock* next;
};
typedef void (*parent_callback_hook)(void* userctx, atf_amc::Hooktype& arg);

// sizes types appearing as Opt or Varlen; these need to be here
// to allow inline implementations of _Get functions and avoid
// a circular dependency between headers
enum {
    sizeof_atf_amc_TypeG = 4
    , sizeof_atf_amc_OptG = 4
    , sizeof_atf_amc_MsgHeader = 4
};

// --- atf_amc.AmcCleanup2
struct AmcCleanup2 { // atf_amc.AmcCleanup2
    i32   field1;   //   0
    i32   field2;   //   0
    AmcCleanup2();
    ~AmcCleanup2();
private:
    // user-defined fcleanup on atf_amc.AmcCleanup2.field1 prevents copy
    // user-defined fcleanup on atf_amc.AmcCleanup2.field2 prevents copy
    AmcCleanup2(const AmcCleanup2&){ /*disallow copy constructor */}
    void operator =(const AmcCleanup2&){ /*disallow direct assignment */}
};

// User-defined cleanup function invoked for field field1 of atf_amc::AmcCleanup2
void                 field1_Cleanup(atf_amc::AmcCleanup2& parent) __attribute__((nothrow));

// User-defined cleanup function invoked for field field2 of atf_amc::AmcCleanup2
void                 field2_Cleanup(atf_amc::AmcCleanup2& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 AmcCleanup2_Init(atf_amc::AmcCleanup2& parent);
void                 AmcCleanup2_Uninit(atf_amc::AmcCleanup2& parent) __attribute__((nothrow));

// --- atf_amc.AmcSubstr1
struct AmcSubstr1 { // atf_amc.AmcSubstr1
    algo::cstring   strval;   //
    AmcSubstr1();
};

bool                 boolval_Get(atf_amc::AmcSubstr1& parent) __attribute__((__warn_unused_result__, nothrow));

i32                  intval_Get(atf_amc::AmcSubstr1& parent) __attribute__((__warn_unused_result__, nothrow));


// --- atf_amc.BitfldType1
struct BitfldType1 { // atf_amc.BitfldType1: Test type for testing reading/printing bitfields to tuple
    u64   value;   //   0
    BitfldType1();
};

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
u64                  bit1_Get(const atf_amc::BitfldType1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
void                 bit1_Set(atf_amc::BitfldType1& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    10 bits starting at bit 5.
u64                  bits5_Get(const atf_amc::BitfldType1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    10 bits starting at bit 5.
void                 bits5_Set(atf_amc::BitfldType1& parent, u64 rhs) __attribute__((nothrow));

bool                 BitfldType1_ReadFieldMaybe(atf_amc::BitfldType1 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::BitfldType1 from an ascii string.
// The format of the string is an ssim Tuple
bool                 BitfldType1_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 BitfldType1_Init(atf_amc::BitfldType1& parent);
// print string representation of atf_amc::BitfldType1 to string LHS, no header -- cprint:atf_amc.BitfldType1.String
void                 BitfldType1_Print(atf_amc::BitfldType1 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.BitfldU128
struct BitfldU128 { // atf_amc.BitfldU128: Test of bitfield functionality
    u128   value;   //   0
    BitfldU128();
};

// Retrieve bitfield from value of field value
//    64 bits starting at bit 1.
u64                  bits1_65_Get(const atf_amc::BitfldU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    64 bits starting at bit 1.
void                 bits1_65_Set(atf_amc::BitfldU128& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    63 bits starting at bit 65.
u64                  bits65_128_Get(const atf_amc::BitfldU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    63 bits starting at bit 65.
void                 bits65_128_Set(atf_amc::BitfldU128& parent, u64 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 BitfldU128_Init(atf_amc::BitfldU128& parent);

// --- atf_amc.BitfldU16
struct BitfldU16 { // atf_amc.BitfldU16: Test of bitfield functionality
    u16   value;   //   0
    BitfldU16();
};

// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
u8                   bits0_4_Get(const atf_amc::BitfldU16& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
void                 bits0_4_Set(atf_amc::BitfldU16& parent, u8 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 8.
u8                   bits8_12_Get(const atf_amc::BitfldU16& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 8.
void                 bits8_12_Set(atf_amc::BitfldU16& parent, u8 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 BitfldU16_Init(atf_amc::BitfldU16& parent);

// --- atf_amc.Bytebuf
// create: atf_amc.FDb.bytebuf (Cppstack)
struct Bytebuf { // atf_amc.Bytebuf
    u8              in_elems[64];      // pointer to elements of inline array
    i32             in_start;          // beginning of valid bytes (in bytes)
    i32             in_end;            // end of valid bytes (in bytes)
    bool            in_eof;            // no more data will be written to buffer
    algo::Errcode   in_err;            // system error code
    bool            in_epoll_enable;   // use epoll?
    enum { in_max = 64 };
    Bytebuf();
private:
    // reftype of atf_amc.Bytebuf.in prohibits copy
    Bytebuf(const Bytebuf&){ /*disallow copy constructor */}
    void operator =(const Bytebuf&){ /*disallow direct assignment */}
};

// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is any number of bytes > 0
//
aryptr<char>         in_GetMsg(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
i32                  in_Max(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
i32                  in_N(atf_amc::Bytebuf& bytebuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Discard contents of the buffer.
void                 in_RemoveAll(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Mark some buffer contents as read.
//
void                 in_SkipBytes(atf_amc::Bytebuf& bytebuf, int n) __attribute__((nothrow));
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
bool                 in_WriteAll(atf_amc::Bytebuf& bytebuf, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
void                 Bytebuf_Init(atf_amc::Bytebuf& bytebuf);
// print string representation of atf_amc::Bytebuf to string LHS, no header -- cprint:atf_amc.Bytebuf.String
void                 Bytebuf_Print(atf_amc::Bytebuf & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Cstr
// create: atf_amc.FPerfSortString.orig (Tary)
// create: atf_amc.FPerfSortString.sorted1 (Tary)
struct Cstr { // atf_amc.Cstr
    algo::cstring   val;   //
    inline operator algo::strptr() const;
    explicit Cstr(const algo::strptr&            in_val);
    bool operator ==(const atf_amc::Cstr &rhs) const;
    bool operator <(const atf_amc::Cstr &rhs) const;
    Cstr();
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 val_Lt(atf_amc::Cstr& orig, atf_amc::Cstr &rhs) __attribute__((nothrow));
// Compare two fields.
i32                  val_Cmp(atf_amc::Cstr& orig, atf_amc::Cstr &rhs) __attribute__((nothrow));

u32                  Cstr_Hash(u32 prev, const atf_amc::Cstr & rhs) __attribute__((nothrow));
bool                 Cstr_Lt(atf_amc::Cstr & lhs, atf_amc::Cstr & rhs) __attribute__((nothrow));
i32                  Cstr_Cmp(atf_amc::Cstr & lhs, atf_amc::Cstr & rhs) __attribute__((nothrow));
bool                 Cstr_Eq(const atf_amc::Cstr & lhs,const atf_amc::Cstr & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Cstr_Update(atf_amc::Cstr &lhs, atf_amc::Cstr & rhs) __attribute__((nothrow));
// Create JSON representation of atf_amc::Cstr under PARENT node -- cprint:atf_amc.Cstr.Json
lib_json::FNode *    Cstr_FmtJson(atf_amc::Cstr & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_amc.Cstring
// access: atf_amc.FCstring.msghdr (Base)
struct Cstring { // atf_amc.Cstring
    algo::cstring   str;   //
    Cstring();
};


// --- atf_amc.Ctype1Attr
struct Ctype1Attr { // atf_amc.Ctype1Attr
    u32   attr1;   //   0
    inline operator u32() const;
    explicit Ctype1Attr(u32                            in_attr1);
    bool operator ==(const atf_amc::Ctype1Attr &rhs) const;
    bool operator <(const atf_amc::Ctype1Attr &rhs) const;
    Ctype1Attr();
};

u32                  Ctype1Attr_Hash(u32 prev, const atf_amc::Ctype1Attr & rhs) __attribute__((nothrow));
// Read fields of atf_amc::Ctype1Attr from an ascii string.
// The format of the string is the format of the atf_amc::Ctype1Attr's only field
bool                 Ctype1Attr_ReadStrptrMaybe(atf_amc::Ctype1Attr &parent, algo::strptr in_str);
bool                 Ctype1Attr_Lt(atf_amc::Ctype1Attr & lhs, atf_amc::Ctype1Attr & rhs) __attribute__((nothrow));
i32                  Ctype1Attr_Cmp(atf_amc::Ctype1Attr & lhs, atf_amc::Ctype1Attr & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Ctype1Attr_Init(atf_amc::Ctype1Attr& parent);
bool                 Ctype1Attr_Eq(const atf_amc::Ctype1Attr & lhs,const atf_amc::Ctype1Attr & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Ctype1Attr_Update(atf_amc::Ctype1Attr &lhs, atf_amc::Ctype1Attr & rhs) __attribute__((nothrow));
// print string representation of atf_amc::Ctype1Attr to string LHS, no header -- cprint:atf_amc.Ctype1Attr.String
void                 Ctype1Attr_Print(atf_amc::Ctype1Attr & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Ctype2Attr
struct Ctype2Attr { // atf_amc.Ctype2Attr
    u32   attr1;   //   0
    u32   attr2;   //   0
    explicit Ctype2Attr(u32                            in_attr1
        ,u32                            in_attr2);
    bool operator ==(const atf_amc::Ctype2Attr &rhs) const;
    bool operator <(const atf_amc::Ctype2Attr &rhs) const;
    Ctype2Attr();
};

u32                  Ctype2Attr_Hash(u32 prev, const atf_amc::Ctype2Attr & rhs) __attribute__((nothrow));
bool                 Ctype2Attr_ReadFieldMaybe(atf_amc::Ctype2Attr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Ctype2Attr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Ctype2Attr_ReadStrptrMaybe(atf_amc::Ctype2Attr &parent, algo::strptr in_str);
// Read fields of atf_amc::Ctype2Attr from attributes of ascii tuple TUPLE
bool                 Ctype2Attr_ReadTupleMaybe(atf_amc::Ctype2Attr &parent, algo::Tuple &tuple) __attribute__((nothrow));
bool                 Ctype2Attr_Lt(atf_amc::Ctype2Attr & lhs, atf_amc::Ctype2Attr & rhs) __attribute__((nothrow));
i32                  Ctype2Attr_Cmp(atf_amc::Ctype2Attr & lhs, atf_amc::Ctype2Attr & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Ctype2Attr_Init(atf_amc::Ctype2Attr& parent);
bool                 Ctype2Attr_Eq(const atf_amc::Ctype2Attr & lhs,const atf_amc::Ctype2Attr & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Ctype2Attr_Update(atf_amc::Ctype2Attr &lhs, atf_amc::Ctype2Attr & rhs) __attribute__((nothrow));
// print string representation of atf_amc::Ctype2Attr to string LHS, no header -- cprint:atf_amc.Ctype2Attr.String
void                 Ctype2Attr_Print(atf_amc::Ctype2Attr & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.DelType1
struct DelType1 { // atf_amc.DelType1: Delptr test 1
    u32*   u32val;   // Private pointer to value
    DelType1();
    ~DelType1();
private:
    // reftype of atf_amc.DelType1.u32val prohibits copy
    DelType1(const DelType1&){ /*disallow copy constructor */}
    void operator =(const DelType1&){ /*disallow direct assignment */}
};

// Get or Create
// Access value, creating it if necessary. Process dies if not successful.
u32&                 u32val_Access(atf_amc::DelType1& parent) __attribute__((nothrow));
// Delete value.
void                 u32val_Delete(atf_amc::DelType1& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 DelType1_Init(atf_amc::DelType1& parent);
void                 DelType1_Uninit(atf_amc::DelType1& parent) __attribute__((nothrow));

// --- atf_amc.DispCase
#pragma pack(push,1)
struct DispCase { // atf_amc.DispCase: Enum for dispatch atf_amc.Disp
    u32   value;   //   0
    inline operator atf_amc_DispCaseEnum() const;
    explicit DispCase(u32                            in_value);
    DispCase(atf_amc_DispCaseEnum arg);
    DispCase();
};
#pragma pack(pop)

// Get value of field as enum type
atf_amc_DispCaseEnum value_GetEnum(const atf_amc::DispCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::DispCase& parent, atf_amc_DispCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::DispCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::DispCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::DispCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::DispCase& parent, algo::strptr rhs, atf_amc_DispCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::DispCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::DispCase from an ascii string.
// The format of the string is the format of the atf_amc::DispCase's only field
bool                 DispCase_ReadStrptrMaybe(atf_amc::DispCase &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 DispCase_Init(atf_amc::DispCase& parent);

// --- atf_amc.DispFilter
struct DispFilter { // atf_amc.DispFilter
    u64                pmask_elems[1];   //   0  fixed array
    algo::Smallstr20   strval;           //
    algo_lib::Regx     strval_regx;      //
    algo::Smallstr20   strval2;          //
    algo_lib::Regx     strval2_regx;     //
    algo::UnTime       start_dateval;    //
    algo::UnTime       end_dateval;      //
    algo::UnTime       dateval;          //
    u32                start_intval;     //   0
    u32                end_intval;       //   0
    u32                intval;           //   0
    DispFilter();
private:
    // value field atf_amc.DispFilter.strval_regx is not copiable
    // value field atf_amc.DispFilter.strval2_regx is not copiable
    DispFilter(const DispFilter&){ /*disallow copy constructor */}
    void operator =(const DispFilter&){ /*disallow direct assignment */}
};

// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  pmask_Nbits(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 pmask_qGetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 pmask_GetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 pmask_BitsEmptyQ(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  pmask_Sum1s(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qClearBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 pmask_ClearBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 pmask_SetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBitVal(atf_amc::DispFilter& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qOrBitVal(atf_amc::DispFilter& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 pmask_ClearBitsAll(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 pmask_ClearBits(atf_amc::DispFilter& parent, atf_amc::DispFilter &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 pmask_OrBits(atf_amc::DispFilter& parent, atf_amc::DispFilter &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  pmask_Sup(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
void                 pmask_Fill(atf_amc::DispFilter& parent, const u64 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u64*                 pmask_Find(atf_amc::DispFilter& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array pmask as aryptr.
algo::aryptr<u64>    pmask_Getary(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  pmask_Max(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  pmask_N(const atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 pmask_Setary(atf_amc::DispFilter& parent, const algo::aryptr<u64> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u64&                 pmask_qFind(atf_amc::DispFilter& parent, u64 t) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 strval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 strval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 strval_Set(atf_amc::DispFilter& parent, const algo::strptr& rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 strval_regx_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 strval_regx_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 strval2_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 strval2_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 strval2_Set(atf_amc::DispFilter& parent, const algo::strptr& rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 strval2_regx_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 strval2_regx_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 start_dateval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 start_dateval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 start_dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 end_dateval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 end_dateval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 end_dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 dateval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 dateval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 start_intval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 start_intval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 start_intval_Set(atf_amc::DispFilter& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 end_intval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 end_intval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 end_intval_Set(atf_amc::DispFilter& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 intval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 intval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
void                 intval_Set(atf_amc::DispFilter& parent, u32 rhs) __attribute__((nothrow));

// cursor points to valid item
void                 DispFilter_pmask_curs_Reset(DispFilter_pmask_curs &curs, atf_amc::DispFilter &parent);
// cursor points to valid item
bool                 DispFilter_pmask_curs_ValidQ(DispFilter_pmask_curs &curs);
// proceed to next item
void                 DispFilter_pmask_curs_Next(DispFilter_pmask_curs &curs);
// item access
u64&                 DispFilter_pmask_curs_Access(DispFilter_pmask_curs &curs);
bool                 DispFilter_ReadFieldMaybe(atf_amc::DispFilter &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::DispFilter from attributes of ascii tuple TUPLE
bool                 DispFilter_ReadTupleMaybe(atf_amc::DispFilter &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 DispFilter_Init(atf_amc::DispFilter& parent);
bool                 DispFilter_MatchDispType1(atf_amc::DispFilter &parent, atf_amc::DispType1 &msg);
bool                 DispFilter_MatchDispType2(atf_amc::DispFilter &parent, atf_amc::DispType2 &msg);
bool                 DispFilter_MatchDispType3(atf_amc::DispFilter &parent, atf_amc::DispType3 &msg);

// --- atf_amc.DispType1
struct DispType1 { // atf_amc.DispType1: Dispfilter test 1
    algo::Smallstr20   strval;    //
    algo::Smallstr20   strval2;   //
    algo::UnTime       dateval;   //
    DispType1();
};

bool                 DispType1_ReadFieldMaybe(atf_amc::DispType1 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::DispType1 from an ascii string.
// The format of the string is an ssim Tuple
bool                 DispType1_ReadStrptrMaybe(atf_amc::DispType1 &parent, algo::strptr in_str);
// print string representation of atf_amc::DispType1 to string LHS, no header -- cprint:atf_amc.DispType1.String
void                 DispType1_Print(atf_amc::DispType1 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.DispType2
struct DispType2 { // atf_amc.DispType2: Dispfilter test 2
    u32   intval;   //   0
    DispType2();
};

// Read fields of atf_amc::DispType2 from an ascii string.
// The format of the string is the format of the atf_amc::DispType2's only field
bool                 DispType2_ReadStrptrMaybe(atf_amc::DispType2 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 DispType2_Init(atf_amc::DispType2& parent);
// print string representation of atf_amc::DispType2 to string LHS, no header -- cprint:atf_amc.DispType2.String
void                 DispType2_Print(atf_amc::DispType2 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.DispType3
struct DispType3 { // atf_amc.DispType3: Dispfilter test 3
    u32                intval;   //   0  Repeats type in DispType2
    algo::Smallstr20   strval;   // Repeats type in DispType1
    DispType3();
};

bool                 DispType3_ReadFieldMaybe(atf_amc::DispType3 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::DispType3 from an ascii string.
// The format of the string is an ssim Tuple
bool                 DispType3_ReadStrptrMaybe(atf_amc::DispType3 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 DispType3_Init(atf_amc::DispType3& parent);
// print string representation of atf_amc::DispType3 to string LHS, no header -- cprint:atf_amc.DispType3.String
void                 DispType3_Print(atf_amc::DispType3 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FAmctest
// create: atf_amc.FDb.amctest (Lary)
struct FAmctest { // atf_amc.FAmctest: Test function
    algo::Smallstr50             amctest;   //
    algo::Comment                comment;   //
    bool                         select;    //   false  Select test for running?
    atf_amc::amctest_step_hook   step;      //   NULL  Pointer to a function
private:
    friend atf_amc::FAmctest&   amctest_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FAmctest*   amctest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 amctest_RemoveAll() __attribute__((nothrow));
    friend void                 amctest_RemoveLast() __attribute__((nothrow));
    FAmctest();
    // reftype of atf_amc.FAmctest.step prohibits copy
    FAmctest(const FAmctest&){ /*disallow copy constructor */}
    void operator =(const FAmctest&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 amctest_CopyOut(atf_amc::FAmctest &row, atfdb::Amctest &out) __attribute__((nothrow));
// Copy fields in to row
void                 amctest_CopyIn(atf_amc::FAmctest &row, atfdb::Amctest &in) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(atf_amc::FAmctest& amctest) __attribute__((nothrow));

// Set all fields to initial values.
void                 FAmctest_Init(atf_amc::FAmctest& amctest);
// print string representation of atf_amc::FAmctest to string LHS, no header -- cprint:atf_amc.FAmctest.String
void                 FAmctest_Print(atf_amc::FAmctest & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FAvl
// create: atf_amc.FDb.avl (Lary)
// global access: tr_avl (Atree)
struct FAvl { // atf_amc.FAvl
    i32              n;              //   0
    atf_amc::FAvl*   tr_avl_up;      // pointer to parent
    atf_amc::FAvl*   tr_avl_left;    // Left child
    atf_amc::FAvl*   tr_avl_right;   // Right child
    i32              tr_avl_depth;   // Depth
private:
    friend atf_amc::FAvl&       avl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FAvl*       avl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 avl_RemoveAll() __attribute__((nothrow));
    friend void                 avl_RemoveLast() __attribute__((nothrow));
    FAvl();
    ~FAvl();
    FAvl(const FAvl&){ /*disallow copy constructor */}
    void operator =(const FAvl&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FAvl_Init(atf_amc::FAvl& avl);
void                 FAvl_Uninit(atf_amc::FAvl& avl) __attribute__((nothrow));

// --- atf_amc.FCascdel
// create: atf_amc.FDb.cascdel (Tpool)
// access: atf_amc.FCascdel.p_parent (Upptr)
// access: atf_amc.FCascdel.child_ptr (Ptr)
// access: atf_amc.FCascdel.c_child_ptrary (Ptrary)
// access: atf_amc.FCascdel.ind_child_thash (Thash)
// access: atf_amc.FCascdel.bh_child_bheap (Bheap)
// access: atf_amc.FCascdel.zd_childlist (Llist)
// access: atf_amc.FCascdel.tr_child_atree (Atree)
struct FCascdel { // atf_amc.FCascdel: Test type for cascade delete
    atf_amc::FCascdel*    p_parent;                        // reference to parent row
    u32                   key;                             //   0
    u32                   type;                            //   0
    atf_amc::FCascdel*    child_ptr;                       // optional pointer
    atf_amc::FCascdel**   c_child_ptrary_elems;            // array of pointers
    u32                   c_child_ptrary_n;                // array of pointers
    u32                   c_child_ptrary_max;              // capacity of allocated array
    atf_amc::FCascdel**   ind_child_thash_buckets_elems;   // pointer to bucket array
    i32                   ind_child_thash_buckets_n;       // number of elements in bucket array
    i32                   ind_child_thash_n;               // number of elements in the hash table
    atf_amc::FCascdel*    ind_child_thash_next;            // hash next
    atf_amc::FCascdel**   bh_child_bheap_elems;            // binary heap by key
    i32                   bh_child_bheap_n;                // number of elements in the heap
    i32                   bh_child_bheap_max;              // max elements in bh_child_bheap_elems
    i32                   bh_child_bheap_idx;              // index in heap; -1 means not-in-heap
    atf_amc::FCascdel*    zd_childlist_head;               // zero-terminated doubly linked list
    i32                   zd_childlist_n;                  // zero-terminated doubly linked list
    atf_amc::FCascdel*    zd_childlist_tail;               // pointer to last element
    atf_amc::FCascdel*    zd_childlist_next;               // zslist link; -1 means not-in-list
    atf_amc::FCascdel*    zd_childlist_prev;               // previous element
    atf_amc::FCascdel*    tr_child_atree_root;             // Root of the tree
    i32                   tr_child_atree_n;                // number of elements in the tree
    atf_amc::FCascdel*    tr_child_atree_up;               // pointer to parent
    atf_amc::FCascdel*    tr_child_atree_left;             // Left child
    atf_amc::FCascdel*    tr_child_atree_right;            // Right child
    i32                   tr_child_atree_depth;            // Depth
    bool                  cascdel_c_child_ptrary_in_ary;   //   false  membership flag
    atf_amc::FCascdel*    cascdel_next;                    // Pointer to next free element int tpool
private:
    friend atf_amc::FCascdel&   cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FCascdel*   cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cascdel_Delete(atf_amc::FCascdel &row) __attribute__((nothrow));
    FCascdel();
    ~FCascdel();
    FCascdel(const FCascdel&){ /*disallow copy constructor */}
    void operator =(const FCascdel&){ /*disallow direct assignment */}
};

// User-defined cleanup function invoked for field key of atf_amc::FCascdel
void                 key_Cleanup(atf_amc::FCascdel& cascdel) __attribute__((nothrow));

// Get value of field as enum type
atf_amc_FCascdel_type_Enum type_GetEnum(const atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Set value of field from enum type.
void                 type_SetEnum(atf_amc::FCascdel& cascdel, atf_amc_FCascdel_type_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          type_ToCstr(const atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
void                 type_Print(const atf_amc::FCascdel& cascdel, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 type_SetStrptrMaybe(atf_amc::FCascdel& cascdel, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 type_SetStrptr(atf_amc::FCascdel& cascdel, algo::strptr rhs, atf_amc_FCascdel_type_Enum dflt) __attribute__((nothrow));

// Delete referred-to items.
// Deleted pointed-to item.
void                 child_ptr_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Insert row into pointer index. Return final membership status.
bool                 child_ptr_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 child_ptr_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));

// Delete all elements pointed to by the index.
void                 c_child_ptrary_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
bool                 c_child_ptrary_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FCascdel*   c_child_ptrary_Find(atf_amc::FCascdel& cascdel, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<atf_amc::FCascdel*> c_child_ptrary_Getary(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_child_ptrary_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_child_ptrary_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_child_ptrary_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_child_ptrary_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_child_ptrary_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_child_ptrary_Reserve(atf_amc::FCascdel& cascdel, u32 n) __attribute__((nothrow));

// Delete all rows reachable through the hash index
void                 ind_child_thash_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if hash is empty
bool                 ind_child_thash_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_amc::FCascdel*   ind_child_thash_Find(atf_amc::FCascdel& cascdel, u32 key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_child_thash_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_child_thash_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_child_thash_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_child_thash_Reserve(atf_amc::FCascdel& cascdel, int n) __attribute__((nothrow));

// Delete referred-to items.
// Delete all elements referenced by the heap.
void                 bh_child_bheap_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Remove all elements from heap and free memory used by the array.
void                 bh_child_bheap_Dealloc(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
bool                 bh_child_bheap_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FCascdel*   bh_child_bheap_First(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_child_bheap_InBheapQ(atf_amc::FCascdel& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_child_bheap_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_child_bheap_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_child_bheap_Reheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_child_bheap_ReheapFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_child_bheap_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_child_bheap_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
atf_amc::FCascdel*   bh_child_bheap_RemoveFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_child_bheap_Reserve(atf_amc::FCascdel& cascdel, int n) __attribute__((nothrow));
// Set row key to new value.
// Update heap membership based on insert condition [row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap]
void                 key_Set(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &row, u32 new_key) __attribute__((nothrow));
// Set row key to new value. If row not in heap, the key is set to new value
// Otherwise, the key is changed only if the new key is better than the old.
// Update heap membership based on insert condition [row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap]
void                 key_SetIfBetter(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &row, u32 new_key) __attribute__((nothrow));

// Delete all elements in the linked list.
void                 zd_childlist_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
bool                 zd_childlist_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FCascdel*   zd_childlist_First(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_childlist_InLlistQ(atf_amc::FCascdel& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_childlist_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FCascdel*   zd_childlist_Last(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_childlist_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FCascdel*   zd_childlist_Next(atf_amc::FCascdel &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FCascdel*   zd_childlist_Prev(atf_amc::FCascdel &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_childlist_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_childlist_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FCascdel*   zd_childlist_RemoveFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FCascdel&   zd_childlist_qLast(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));

// Delete all elements in the tree.
void                 tr_child_atree_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
bool                 tr_child_atree_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
atf_amc::FCascdel*   tr_child_atree_FirstImpl(atf_amc::FCascdel* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the first(smallest) element in the tree
atf_amc::FCascdel*   tr_child_atree_First(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
// Return true if row is in the tree, false otherwise
bool                 tr_child_atree_InTreeQ(atf_amc::FCascdel& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
void                 tr_child_atree_InsertImpl(atf_amc::FCascdel& cascdel, atf_amc::FCascdel* parent, atf_amc::FCascdel& row) __attribute__((nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
void                 tr_child_atree_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 tr_child_atree_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 tr_child_atree_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
void                 tr_child_atree_RemoveFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
i32                  tr_child_atree_Balance(atf_amc::FCascdel& row) __attribute__((nothrow));
// Recalculate depth and keep rebalancing if needed
atf_amc::FCascdel*   tr_child_atree_Propagate(atf_amc::FCascdel& pnode) __attribute__((nothrow));
// Rebalances the node if needed.
void                 tr_child_atree_Rebalance(atf_amc::FCascdel& node) __attribute__((nothrow));
atf_amc::FCascdel*   tr_child_atree_Next(atf_amc::FCascdel& node) __attribute__((__warn_unused_result__, nothrow));
atf_amc::FCascdel*   tr_child_atree_Prev(atf_amc::FCascdel& node) __attribute__((__warn_unused_result__, nothrow));
atf_amc::FCascdel*   tr_child_atree_LastImpl(atf_amc::FCascdel* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the last(largest) element in tree
atf_amc::FCascdel*   tr_child_atree_Last(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
// Empty the index. (rows may be deleted if cascdel)
void                 tr_child_atree_RemoveAllImpl(atf_amc::FCascdel& cascdel, atf_amc::FCascdel* root, bool del) __attribute__((nothrow));
// Reinsert a row with modified key(Reheap semantics)
void                 tr_child_atree_Reinsert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& node) __attribute__((nothrow));
// Find the first element that is greater or equal to a sortfld value
atf_amc::FCascdel*   tr_child_atree_FirstGe(atf_amc::FCascdel& cascdel, const u32& val) __attribute__((nothrow));
// Find the last element that is smaller or equal to a sortfld value
atf_amc::FCascdel*   tr_child_atree_LastLt(atf_amc::FCascdel& cascdel, const u32& val) __attribute__((nothrow));

void                 cascdel_c_child_ptrary_curs_Reset(cascdel_c_child_ptrary_curs &curs, atf_amc::FCascdel &parent);
// cursor points to valid item
bool                 cascdel_c_child_ptrary_curs_ValidQ(cascdel_c_child_ptrary_curs &curs);
// proceed to next item
void                 cascdel_c_child_ptrary_curs_Next(cascdel_c_child_ptrary_curs &curs);
// item access
atf_amc::FCascdel&   cascdel_c_child_ptrary_curs_Access(cascdel_c_child_ptrary_curs &curs);
// Set all fields to initial values.
void                 FCascdel_Init(atf_amc::FCascdel& cascdel);
void                 cascdel_bh_child_bheap_curs_Reserve(cascdel_bh_child_bheap_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 cascdel_bh_child_bheap_curs_Reset(cascdel_bh_child_bheap_curs &curs, atf_amc::FCascdel &parent);
// Advance cursor.
void                 cascdel_bh_child_bheap_curs_Next(cascdel_bh_child_bheap_curs &curs);
// Access current element. If not more elements, return NULL
atf_amc::FCascdel&   cascdel_bh_child_bheap_curs_Access(cascdel_bh_child_bheap_curs &curs);
// Return true if Access() will return non-NULL.
bool                 cascdel_bh_child_bheap_curs_ValidQ(cascdel_bh_child_bheap_curs &curs);
// cursor points to valid item
void                 cascdel_zd_childlist_curs_Reset(cascdel_zd_childlist_curs &curs, atf_amc::FCascdel &parent);
// cursor points to valid item
bool                 cascdel_zd_childlist_curs_ValidQ(cascdel_zd_childlist_curs &curs);
// proceed to next item
void                 cascdel_zd_childlist_curs_Next(cascdel_zd_childlist_curs &curs);
// item access
atf_amc::FCascdel&   cascdel_zd_childlist_curs_Access(cascdel_zd_childlist_curs &curs);
// cursor points to valid item
void                 cascdel_tr_child_atree_curs_Reset(cascdel_tr_child_atree_curs &curs, atf_amc::FCascdel& parent);
// cursor points to valid item
bool                 cascdel_tr_child_atree_curs_ValidQ(cascdel_tr_child_atree_curs &curs);
// proceed to next item
void                 cascdel_tr_child_atree_curs_Next(cascdel_tr_child_atree_curs &curs);
// item access
atf_amc::FCascdel&   cascdel_tr_child_atree_curs_Access(cascdel_tr_child_atree_curs &curs);
void                 FCascdel_Uninit(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// print string representation of atf_amc::FCascdel to string LHS, no header -- cprint:atf_amc.FCascdel.String
void                 FCascdel_Print(atf_amc::FCascdel & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FCstring
// create: atf_amc.FDb.cstring (Lary)
// global access: ind_cstring (Thash)
struct FCstring { // atf_amc.FCstring
    algo::cstring        str;                //
    atf_amc::FCstring*   ind_cstring_next;   // hash next
private:
    friend atf_amc::FCstring&   cstring_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FCstring*   cstring_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstring_RemoveAll() __attribute__((nothrow));
    friend void                 cstring_RemoveLast() __attribute__((nothrow));
    FCstring();
    ~FCstring();
    FCstring(const FCstring&){ /*disallow copy constructor */}
    void operator =(const FCstring&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cstring_CopyOut(atf_amc::FCstring &row, atf_amc::Cstring &out) __attribute__((nothrow));
// Copy fields in to row
void                 cstring_CopyIn(atf_amc::FCstring &row, atf_amc::Cstring &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCstring_Init(atf_amc::FCstring& cstring);
void                 FCstring_Uninit(atf_amc::FCstring& cstring) __attribute__((nothrow));

// --- atf_amc.FListtype
// create: atf_amc.FDb.listtype (Inlary)
// access: atf_amc.FListtype.step (Hook)
struct FListtype { // atf_amc.FListtype
    algo::Smallstr5               listtype;   //
    bool                          circular;   //   false  Circular list
    bool                          haveprev;   //   false  Previous link
    bool                          instail;    //   false  Queue
    algo::Comment                 comment;    //
    atf_amc::listtype_step_hook   step;       //   NULL  Pointer to a function
    bool                          seen;       //   false
    FListtype();
private:
    // reftype of atf_amc.FListtype.step prohibits copy
    FListtype(const FListtype&){ /*disallow copy constructor */}
    void operator =(const FListtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 listtype_CopyOut(atf_amc::FListtype &row, dmmeta::Listtype &out) __attribute__((nothrow));
// Copy fields in to row
void                 listtype_CopyIn(atf_amc::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(atf_amc::FListtype& listtype, atf_amc::FListtype& arg) __attribute__((nothrow));

// Set all fields to initial values.
void                 FListtype_Init(atf_amc::FListtype& listtype);

// --- atf_amc.trace
#pragma pack(push,1)
struct trace { // atf_amc.trace
    u64   step_bh_typec;             //   0
    u64   step_bh_typec_cycles;      //   0
    u64   step_zsl_h_typec;          //   0
    u64   step_zsl_h_typec_cycles;   //   0
    u64   step_zs_t_typec;           //   0
    u64   step_zs_t_typec_cycles;    //   0
    u64   step_csl_h_typec;          //   0
    u64   step_csl_h_typec_cycles;   //   0
    u64   step_cs_t_typec;           //   0
    u64   step_cs_t_typec_cycles;    //   0
    u64   step_cd_in_msg;            //   0
    u64   step_cd_in_msg_cycles;     //   0
    trace();
};
#pragma pack(pop)

// Set all fields to initial values.
void                 trace_Init(atf_amc::trace& parent);
// print string representation of atf_amc::trace to string LHS, no header -- cprint:atf_amc.trace.String
void                 trace_Print(atf_amc::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FDb
// create: atf_amc.FDb._db (Global)
struct FDb { // atf_amc.FDb
    command::atf_amc         cmdline;                                          //
    atf_amc::FTypeC**        bh_typec_elems;                                   // binary heap by typec
    i32                      bh_typec_n;                                       // number of elements in the heap
    i32                      bh_typec_max;                                     // max elements in bh_typec_elems
    atf_amc::FTypeC*         zdl_h_typec_head;                                 // zero-terminated doubly linked list
    i32                      zdl_h_typec_n;                                    // zero-terminated doubly linked list
    atf_amc::FTypeC*         zdl_h_typec_tail;                                 // pointer to last element
    atf_amc::FTypeC*         zd_t_typec_head;                                  // zero-terminated doubly linked list
    i32                      zd_t_typec_n;                                     // zero-terminated doubly linked list
    atf_amc::FTypeC*         zd_t_typec_tail;                                  // pointer to last element
    atf_amc::FTypeC*         zsl_h_typec_head;                                 // zero-terminated singly linked list
    i32                      zsl_h_typec_n;                                    // zero-terminated singly linked list
    atf_amc::FTypeC*         zsl_h_typec_tail;                                 // pointer to last element
    atf_amc::FTypeC*         zs_t_typec_head;                                  // zero-terminated singly linked list
    i32                      zs_t_typec_n;                                     // zero-terminated singly linked list
    atf_amc::FTypeC*         zs_t_typec_tail;                                  // pointer to last element

    atf_amc::FTypeC*         zs_mt_typec_head;                                 // ZSListMT - zero-terminated singly linked list -- read side
    atf_amc::FTypeC*         zs_mt_typec_mt;                                   // elements inserted here from another thread -- write side
    atf_amc::FTypeC*         zdl_hnt_typec_head;                               // zero-terminated doubly linked list
    i32                      zdl_hnt_typec_n;                                  // zero-terminated doubly linked list
    atf_amc::FTypeC*         cdl_h_typec_head;                                 // zero-terminated doubly linked list
    i32                      cdl_h_typec_n;                                    // zero-terminated doubly linked list
    atf_amc::FTypeC*         cd_t_typec_head;                                  // zero-terminated doubly linked list
    i32                      cd_t_typec_n;                                     // zero-terminated doubly linked list
    atf_amc::FTypeC*         csl_h_typec_head;                                 // zero-terminated singly linked list
    i32                      csl_h_typec_n;                                    // zero-terminated singly linked list
    atf_amc::FTypeC*         csl_h_typec_tail;                                 // pointer to last element
    atf_amc::FTypeC*         cs_t_typec_head;                                  // zero-terminated singly linked list
    i32                      cs_t_typec_n;                                     // zero-terminated singly linked list
    atf_amc::FTypeC*         cs_t_typec_tail;                                  // pointer to last element
    atf_amc::FTypeA*         typea_lary[32];                                   // level array
    i32                      typea_n;                                          // number of elements in array
    atf_amc::FTypeS*         types_lary[32];                                   // level array
    i32                      types_n;                                          // number of elements in array
    atf_amc::FTypeS**        ind_types_buckets_elems;                          // pointer to bucket array
    i32                      ind_types_buckets_n;                              // number of elements in bucket array
    i32                      ind_types_n;                                      // number of elements in the hash table
    atf_amc::FTypeA**        ind_typea_buckets_elems;                          // pointer to bucket array
    i32                      ind_typea_buckets_n;                              // number of elements in bucket array
    i32                      ind_typea_n;                                      // number of elements in the hash table
    i32                      cs_h_count;                                       //   0  FirstChanged trigger fire count
    i32                      cs_t_count;                                       //   0  FirstChanged trigger fire count
    i32                      zs_h_count;                                       //   0  FirstChanged trigger fire count
    i32                      zs_t_count;                                       //   0  FirstChanged trigger fire count
    i32                      zs_mt_count;                                      //   0  FirstChanged trigger fire count
    i32                      bh_count;                                         //   0  FirstChanged trigger fire count
    atf_amc::FTypeT*         typet_lary[32];                                   // level array
    i32                      typet_n;                                          // number of elements in array
    atf_amc::FCstring*       cstring_lary[32];                                 // level array
    i32                      cstring_n;                                        // number of elements in array
    atf_amc::FCstring**      ind_cstring_buckets_elems;                        // pointer to bucket array
    i32                      ind_cstring_buckets_n;                            // number of elements in bucket array
    i32                      ind_cstring_n;                                    // number of elements in the hash table
    atf_amc::Msgbuf*         cd_in_msg_head;                                   // zero-terminated doubly linked list
    u32                      typeb_blocksize;                                  // # bytes per block
    atf_amc::FTypeB*         typeb_free;                                       //
    u32                      pooledbe64_blocksize;                             // # bytes per block
    atf_amc::PooledBE64*     pooledbe64_free;                                  //
    i64                      varlen_extern_n;                                  // Number of elements
    varlen_extern_Lpblock*   varlen_extern_free[31];                           // Lpool levels
    atf_amc::FAmctest*       amctest_lary[32];                                 // level array
    i32                      amctest_n;                                        // number of elements in array
    u32                      cascdel_blocksize;                                // # bytes per block
    atf_amc::FCascdel*       cascdel_free;                                     //
    algo_lib::Bitset         cascdel_check;                                    // Bitset of FCascdel records in existence
    u32                      cascdel_next_key;                                 //   0  Next sequence number for FCascdel record
    i64                      optalloc_n;                                       // Number of elements
    optalloc_Lpblock*        optalloc_free[31];                                // Lpool levels
    i64                      varlenalloc_n;                                    // Number of elements
    varlenalloc_Lpblock*     varlenalloc_free[31];                             // Lpool levels
    i64                      optg_n;                                           // Number of elements
    optg_Lpblock*            optg_free[31];                                    // Lpool levels
    atf_amc::FTypeK**        c_typek_elems;                                    // array of pointers
    u32                      c_typek_n;                                        // array of pointers
    u32                      c_typek_max;                                      // capacity of allocated array
    atf_amc::FAvl*           avl_lary[32];                                     // level array
    i32                      avl_n;                                            // number of elements in array
    atf_amc::FAvl*           tr_avl_root;                                      // Root of the tree
    i32                      tr_avl_n;                                         // number of elements in the tree
    u128                     listtype_data[sizeu128(atf_amc::FListtype,10)];   // place for data
    i32                      listtype_n;                                       // number of elems current in existence
    enum { listtype_max = 10 };
    atf_amc::trace           trace;                                            //
};

// Remove all elements from heap and free memory used by the array.
void                 bh_typec_Dealloc() __attribute__((nothrow));
// Return true if index is empty
bool                 bh_typec_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     bh_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_typec_InBheapQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// If first item of the is changed, update fstep:atf_amc.FDb.bh_typec
i32                  bh_typec_Reheap(atf_amc::FTypeC& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// Update fstep:atf_amc.FDb.bh_typec
i32                  bh_typec_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_typec_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
atf_amc::FTypeC*     bh_typec_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_typec_Reserve(int n) __attribute__((nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
void                 bh_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
void                 bh_typec_UpdateCycles() __attribute__((nothrow));
void                 bh_typec_Step() __attribute__((nothrow));
void                 bh_typec_Call() __attribute__((nothrow));

// Return true if index is empty
bool                 zdl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     zdl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zdl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zdl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     zdl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zdl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     zdl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeC*     zdl_h_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zdl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zdl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC*     zdl_h_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     zdl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zd_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     zd_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     zd_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     zd_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeC*     zd_t_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC*     zd_t_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     zd_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zsl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     zsl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zsl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zsl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     zsl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zsl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     zsl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zsl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zsl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC*     zsl_h_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     zsl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
void                 zsl_h_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
void                 zsl_h_typec_UpdateCycles() __attribute__((nothrow));
void                 zsl_h_typec_Step() __attribute__((nothrow));
void                 zsl_h_typec_Call() __attribute__((nothrow));

// Return true if index is empty
bool                 zs_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     zs_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     zs_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zs_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     zs_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC*     zs_t_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     zs_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
void                 zs_t_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
void                 zs_t_typec_UpdateCycles() __attribute__((nothrow));
void                 zs_t_typec_Step() __attribute__((nothrow));
void                 zs_t_typec_Call() __attribute__((nothrow));

// If index is empty, return NULL
// Otherwise return first key in index.
// NOTE: this function must be called from the reading thread.
// NOTE: if called from the writing thread, it might result in loss of data.
atf_amc::FTypeC*     zs_mt_typec_DestructiveFirst() __attribute__((nothrow));
// Return true if row is in index, false otherwise. Row must be non-NULL.
bool                 zs_mt_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, the behavior is undefined.
void                 zs_mt_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If element is not in index, do nothing.
// Otherwise, throw exception: ZSListMT elements cannot
// be removed from the list except via RemoveFIrst.
void                 zs_mt_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
atf_amc::FTypeC*     zs_mt_typec_RemoveFirst() __attribute__((nothrow));

// Return true if index is empty
bool                 zdl_hnt_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     zdl_hnt_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zdl_hnt_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zdl_hnt_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// Return number of items in the linked list
i32                  zdl_hnt_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     zdl_hnt_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeC*     zdl_hnt_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zdl_hnt_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zdl_hnt_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC*     zdl_hnt_typec_RemoveFirst() __attribute__((nothrow));

// Return true if index is empty
bool                 cdl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     cdl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 cdl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 cdl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     cdl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  cdl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     cdl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeC*     cdl_h_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 cdl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 cdl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC*     cdl_h_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC*     cdl_h_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     cdl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 cd_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     cd_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 cd_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 cd_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     cd_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  cd_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     cd_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeC*     cd_t_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 cd_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 cd_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeC*     cd_t_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC*     cd_t_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     cd_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 csl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     csl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 csl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 csl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     csl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  csl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     csl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 csl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 csl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC*     csl_h_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC*     csl_h_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     csl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
void                 csl_h_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
void                 csl_h_typec_UpdateCycles() __attribute__((nothrow));
void                 csl_h_typec_Step() __attribute__((nothrow));
void                 csl_h_typec_Call() __attribute__((nothrow));

// Return true if index is empty
bool                 cs_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeC*     cs_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 cs_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 cs_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeC*     cs_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  cs_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeC*     cs_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 cs_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 cs_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::FTypeC*     cs_t_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::FTypeC*     cs_t_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeC&     cs_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
void                 cs_t_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
void                 cs_t_typec_UpdateCycles() __attribute__((nothrow));
void                 cs_t_typec_Step() __attribute__((nothrow));
void                 cs_t_typec_Call() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeA&     typea_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeA*     typea_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeA*     typea_InsertMaybe(const atf_amc::TypeA &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                typea_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 typea_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FTypeA*     typea_Find(i32 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::FTypeA*     typea_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  typea_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 typea_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 typea_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::FTypeA&     typea_qFind(i32 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typea_XrefMaybe(atf_amc::FTypeA &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeS&     types_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeS*     types_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeS*     types_InsertMaybe(const atf_amc::TypeS &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                types_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 types_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FTypeS*     types_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::FTypeS*     types_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  types_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 types_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 types_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::FTypeS&     types_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 types_XrefMaybe(atf_amc::FTypeS &row);

// Return true if hash is empty
bool                 ind_types_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_amc::FTypeS*     ind_types_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FTypeS&     ind_types_GetOrCreate(i32 key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_types_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_types_InsertMaybe(atf_amc::FTypeS& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_types_Remove(atf_amc::FTypeS& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_types_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_typea_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_amc::FTypeA*     ind_typea_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FTypeA&     ind_typea_GetOrCreate(i32 key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_typea_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_typea_InsertMaybe(atf_amc::FTypeA& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_typea_Remove(atf_amc::FTypeA& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_typea_Reserve(int n) __attribute__((nothrow));

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeT&     typet_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeT*     typet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeT*     typet_InsertMaybe(const atf_amc::TypeT &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                typet_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 typet_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FTypeT*     typet_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::FTypeT*     typet_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  typet_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 typet_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 typet_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::FTypeT&     typet_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typet_XrefMaybe(atf_amc::FTypeT &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FCstring&   cstring_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FCstring*   cstring_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FCstring*   cstring_InsertMaybe(const atf_amc::Cstring &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cstring_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cstring_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FCstring*   cstring_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::FCstring*   cstring_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cstring_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cstring_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cstring_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::FCstring&   cstring_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cstring_XrefMaybe(atf_amc::FCstring &row);

// Return true if hash is empty
bool                 ind_cstring_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_amc::FCstring*   ind_cstring_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_amc::FCstring&   ind_cstring_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_cstring_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_cstring_InsertMaybe(atf_amc::FCstring& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_cstring_Remove(atf_amc::FCstring& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_cstring_Reserve(int n) __attribute__((nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 msgbuf_XrefMaybe(atf_amc::Msgbuf &row);

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 bytebuf_XrefMaybe(atf_amc::Bytebuf &row);

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 linebuf_XrefMaybe(atf_amc::Linebuf &row);

// Return true if index is empty
bool                 cd_in_msg_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::Msgbuf*     cd_in_msg_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 cd_in_msg_InLlistQ(atf_amc::Msgbuf& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 cd_in_msg_Insert(atf_amc::Msgbuf& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::Msgbuf*     cd_in_msg_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::Msgbuf*     cd_in_msg_Next(atf_amc::Msgbuf &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::Msgbuf*     cd_in_msg_Prev(atf_amc::Msgbuf &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 cd_in_msg_Remove(atf_amc::Msgbuf& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 cd_in_msg_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
atf_amc::Msgbuf*     cd_in_msg_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
atf_amc::Msgbuf*     cd_in_msg_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::Msgbuf&     cd_in_msg_qLast() __attribute__((__warn_unused_result__, nothrow));
void                 cd_in_msg_Step() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeB&     typeb_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeB*     typeb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeB*     typeb_InsertMaybe(const atf_amc::TypeB &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 typeb_Delete(atf_amc::FTypeB &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                typeb_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 typeb_FreeMem(atf_amc::FTypeB &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  typeb_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  typeb_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typeb_XrefMaybe(atf_amc::FTypeB &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::PooledBE64& pooledbe64_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::PooledBE64* pooledbe64_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 pooledbe64_Delete(atf_amc::PooledBE64 &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                pooledbe64_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 pooledbe64_FreeMem(atf_amc::PooledBE64 &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  pooledbe64_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  pooledbe64_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 pooledbe64_XrefMaybe(atf_amc::PooledBE64 &row);

// Free block of memory previously returned by Lpool.
void                 varlen_extern_FreeMem(void *mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void*                varlen_extern_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
bool                 varlen_extern_ReserveBuffers(int nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void*                varlen_extern_ReallocMem(void *oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// Allocate memory for a new row with N_VARFLD var-len elements
// If out of memory, process is killed.
atf_amc::VarlenExtern& varlen_extern_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::VarlenExtern* varlen_extern_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
atf_amc::VarlenExtern& varlen_extern_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::VarlenExtern* varlen_extern_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, return NULL.
// Allocate memory for a new row; Copy var-len portion from varlen.
// This is a convenience function that uses varlen_extern_Alloc
atf_amc::VarlenExtern* varlen_extern_AllocVarlenMaybe(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, terminate process.
atf_amc::VarlenExtern& varlen_extern_AllocVarlen(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__));
// Remove row from all global and cross indices, then deallocate row
void                 varlen_extern_Delete(atf_amc::VarlenExtern &row) __attribute__((nothrow));
// Return number of items in the pool
i64                  varlen_extern_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 varlen_extern_XrefMaybe(atf_amc::VarlenExtern &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FAmctest&   amctest_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FAmctest*   amctest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FAmctest*   amctest_InsertMaybe(const atfdb::Amctest &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                amctest_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 amctest_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FAmctest*   amctest_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::FAmctest*   amctest_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  amctest_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 amctest_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 amctest_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::FAmctest&   amctest_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 amctest_XrefMaybe(atf_amc::FAmctest &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FCascdel&   cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FCascdel*   cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 cascdel_Delete(atf_amc::FCascdel &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                cascdel_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 cascdel_FreeMem(atf_amc::FCascdel &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  cascdel_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  cascdel_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cascdel_XrefMaybe(atf_amc::FCascdel &row);

// Free block of memory previously returned by Lpool.
void                 optalloc_FreeMem(void *mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void*                optalloc_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
bool                 optalloc_ReserveBuffers(int nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void*                optalloc_ReallocMem(void *oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
atf_amc::OptAlloc&   optalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::OptAlloc*   optalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 optalloc_Delete(atf_amc::OptAlloc &row) __attribute__((nothrow));
// Return number of items in the pool
i64                  optalloc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 optalloc_XrefMaybe(atf_amc::OptAlloc &row);

// Free block of memory previously returned by Lpool.
void                 varlenalloc_FreeMem(void *mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void*                varlenalloc_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
bool                 varlenalloc_ReserveBuffers(int nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void*                varlenalloc_ReallocMem(void *oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// Allocate memory for a new row with N_VARFLD var-len elements
// If out of memory, process is killed.
atf_amc::VarlenAlloc& varlenalloc_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::VarlenAlloc* varlenalloc_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
atf_amc::VarlenAlloc& varlenalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::VarlenAlloc* varlenalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, return NULL.
// Allocate memory for a new row; Copy var-len portion from elem.
// This is a convenience function that uses varlenalloc_Alloc
atf_amc::VarlenAlloc* varlenalloc_AllocVarlenMaybe(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, terminate process.
atf_amc::VarlenAlloc& varlenalloc_AllocVarlen(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__));
// Remove row from all global and cross indices, then deallocate row
void                 varlenalloc_Delete(atf_amc::VarlenAlloc &row) __attribute__((nothrow));
// Return number of items in the pool
i64                  varlenalloc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 varlenalloc_XrefMaybe(atf_amc::VarlenAlloc &row);

// Free block of memory previously returned by Lpool.
void                 optg_FreeMem(void *mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void*                optg_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
bool                 optg_ReserveBuffers(int nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void*                optg_ReallocMem(void *oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
atf_amc::FOptG&      optg_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FOptG*      optg_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FOptG*      optg_InsertMaybe(const atf_amc::OptG &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 optg_Delete(atf_amc::FOptG &row) __attribute__((nothrow));
// Return number of items in the pool
i64                  optg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 optg_XrefMaybe(atf_amc::FOptG &row);

// Return true if index is empty
bool                 c_typek_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FTypeK*     c_typek_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<atf_amc::FTypeK*> c_typek_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_typek_Insert(atf_amc::FTypeK& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_typek_InsertMaybe(atf_amc::FTypeK& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_typek_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_typek_Remove(atf_amc::FTypeK& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_typek_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_typek_Reserve(u32 n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FAvl&       avl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FAvl*       avl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                avl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 avl_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FAvl*       avl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::FAvl*       avl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  avl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 avl_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 avl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::FAvl&       avl_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 avl_XrefMaybe(atf_amc::FAvl &row);

// Return true if index is empty
bool                 tr_avl_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
atf_amc::FAvl*       tr_avl_FirstImpl(atf_amc::FAvl* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the first(smallest) element in the tree
atf_amc::FAvl*       tr_avl_First() __attribute__((__warn_unused_result__, nothrow));
// Return true if row is in the tree, false otherwise
bool                 tr_avl_InTreeQ(atf_amc::FAvl& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
void                 tr_avl_InsertImpl(atf_amc::FAvl* parent, atf_amc::FAvl& row) __attribute__((nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
void                 tr_avl_Insert(atf_amc::FAvl& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 tr_avl_Remove(atf_amc::FAvl& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 tr_avl_RemoveAll() __attribute__((nothrow));
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
void                 tr_avl_RemoveFirst() __attribute__((nothrow));
i32                  tr_avl_Balance(atf_amc::FAvl& row) __attribute__((nothrow));
// Recalculate depth and keep rebalancing if needed
atf_amc::FAvl*       tr_avl_Propagate(atf_amc::FAvl& pnode) __attribute__((nothrow));
// Rebalances the node if needed.
void                 tr_avl_Rebalance(atf_amc::FAvl& node) __attribute__((nothrow));
atf_amc::FAvl*       tr_avl_Next(atf_amc::FAvl& node) __attribute__((__warn_unused_result__, nothrow));
atf_amc::FAvl*       tr_avl_Prev(atf_amc::FAvl& node) __attribute__((__warn_unused_result__, nothrow));
atf_amc::FAvl*       tr_avl_LastImpl(atf_amc::FAvl* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the last(largest) element in tree
atf_amc::FAvl*       tr_avl_Last() __attribute__((__warn_unused_result__, nothrow));
// Empty the index. (rows may be deleted if cascdel)
void                 tr_avl_RemoveAllImpl(atf_amc::FAvl* root, bool del) __attribute__((nothrow));
// Reinsert a row with modified key(Reheap semantics)
void                 tr_avl_Reinsert(atf_amc::FAvl& node) __attribute__((nothrow));
// Find the first element that is greater or equal to a sortfld value
atf_amc::FAvl*       tr_avl_FirstGe(const i32& val) __attribute__((nothrow));
// Find the last element that is smaller or equal to a sortfld value
atf_amc::FAvl*       tr_avl_LastLt(const i32& val) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FListtype&  listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FListtype*  listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FListtype*  listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 listtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FListtype*  listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_amc::FListtype> listtype_Getary() __attribute__((nothrow));
// Return constant 10 -- max. number of items in the pool
i32                  listtype_Max() __attribute__((nothrow));
// Return number of items in the array
i32                  listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
void                 listtype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
atf_amc::FListtype&  listtype_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
u64                  listtype_rowid_Get(atf_amc::FListtype &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 listtype_XrefMaybe(atf_amc::FListtype &row);

void                 _db_bh_typec_curs_Reserve(_db_bh_typec_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 _db_bh_typec_curs_Reset(_db_bh_typec_curs &curs, atf_amc::FDb &parent);
// Advance cursor.
void                 _db_bh_typec_curs_Next(_db_bh_typec_curs &curs);
// Access current element. If not more elements, return NULL
atf_amc::FTypeC&     _db_bh_typec_curs_Access(_db_bh_typec_curs &curs);
// Return true if Access() will return non-NULL.
bool                 _db_bh_typec_curs_ValidQ(_db_bh_typec_curs &curs);
// cursor points to valid item
void                 _db_zdl_h_typec_curs_Reset(_db_zdl_h_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_zdl_h_typec_curs_ValidQ(_db_zdl_h_typec_curs &curs);
// proceed to next item
void                 _db_zdl_h_typec_curs_Next(_db_zdl_h_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_zdl_h_typec_curs_Access(_db_zdl_h_typec_curs &curs);
// cursor points to valid item
void                 _db_zd_t_typec_curs_Reset(_db_zd_t_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_zd_t_typec_curs_ValidQ(_db_zd_t_typec_curs &curs);
// proceed to next item
void                 _db_zd_t_typec_curs_Next(_db_zd_t_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_zd_t_typec_curs_Access(_db_zd_t_typec_curs &curs);
// cursor points to valid item
void                 _db_zsl_h_typec_curs_Reset(_db_zsl_h_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_zsl_h_typec_curs_ValidQ(_db_zsl_h_typec_curs &curs);
// proceed to next item
void                 _db_zsl_h_typec_curs_Next(_db_zsl_h_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_zsl_h_typec_curs_Access(_db_zsl_h_typec_curs &curs);
// cursor points to valid item
void                 _db_zs_t_typec_curs_Reset(_db_zs_t_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_zs_t_typec_curs_ValidQ(_db_zs_t_typec_curs &curs);
// proceed to next item
void                 _db_zs_t_typec_curs_Next(_db_zs_t_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_zs_t_typec_curs_Access(_db_zs_t_typec_curs &curs);
// cursor points to valid item
void                 _db_zdl_hnt_typec_curs_Reset(_db_zdl_hnt_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_zdl_hnt_typec_curs_ValidQ(_db_zdl_hnt_typec_curs &curs);
// proceed to next item
void                 _db_zdl_hnt_typec_curs_Next(_db_zdl_hnt_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_zdl_hnt_typec_curs_Access(_db_zdl_hnt_typec_curs &curs);
// cursor points to valid item
void                 _db_cdl_h_typec_curs_Reset(_db_cdl_h_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_cdl_h_typec_curs_ValidQ(_db_cdl_h_typec_curs &curs);
// proceed to next item
void                 _db_cdl_h_typec_curs_Next(_db_cdl_h_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_cdl_h_typec_curs_Access(_db_cdl_h_typec_curs &curs);
// cursor points to valid item
void                 _db_cd_t_typec_curs_Reset(_db_cd_t_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_cd_t_typec_curs_ValidQ(_db_cd_t_typec_curs &curs);
// proceed to next item
void                 _db_cd_t_typec_curs_Next(_db_cd_t_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_cd_t_typec_curs_Access(_db_cd_t_typec_curs &curs);
// cursor points to valid item
void                 _db_csl_h_typec_curs_Reset(_db_csl_h_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_csl_h_typec_curs_ValidQ(_db_csl_h_typec_curs &curs);
// proceed to next item
void                 _db_csl_h_typec_curs_Next(_db_csl_h_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_csl_h_typec_curs_Access(_db_csl_h_typec_curs &curs);
// cursor points to valid item
void                 _db_cs_t_typec_curs_Reset(_db_cs_t_typec_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_cs_t_typec_curs_ValidQ(_db_cs_t_typec_curs &curs);
// proceed to next item
void                 _db_cs_t_typec_curs_Next(_db_cs_t_typec_curs &curs);
// item access
atf_amc::FTypeC&     _db_cs_t_typec_curs_Access(_db_cs_t_typec_curs &curs);
// cursor points to valid item
void                 _db_typea_curs_Reset(_db_typea_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_typea_curs_ValidQ(_db_typea_curs &curs);
// proceed to next item
void                 _db_typea_curs_Next(_db_typea_curs &curs);
// item access
atf_amc::FTypeA&     _db_typea_curs_Access(_db_typea_curs &curs);
// cursor points to valid item
void                 _db_types_curs_Reset(_db_types_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_types_curs_ValidQ(_db_types_curs &curs);
// proceed to next item
void                 _db_types_curs_Next(_db_types_curs &curs);
// item access
atf_amc::FTypeS&     _db_types_curs_Access(_db_types_curs &curs);
// cursor points to valid item
void                 _db_typet_curs_Reset(_db_typet_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_typet_curs_ValidQ(_db_typet_curs &curs);
// proceed to next item
void                 _db_typet_curs_Next(_db_typet_curs &curs);
// item access
atf_amc::FTypeT&     _db_typet_curs_Access(_db_typet_curs &curs);
// cursor points to valid item
void                 _db_cstring_curs_Reset(_db_cstring_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_cstring_curs_ValidQ(_db_cstring_curs &curs);
// proceed to next item
void                 _db_cstring_curs_Next(_db_cstring_curs &curs);
// item access
atf_amc::FCstring&   _db_cstring_curs_Access(_db_cstring_curs &curs);
// cursor points to valid item
void                 _db_cd_in_msg_curs_Reset(_db_cd_in_msg_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_cd_in_msg_curs_ValidQ(_db_cd_in_msg_curs &curs);
// proceed to next item
void                 _db_cd_in_msg_curs_Next(_db_cd_in_msg_curs &curs);
// item access
atf_amc::Msgbuf&     _db_cd_in_msg_curs_Access(_db_cd_in_msg_curs &curs);
// cursor points to valid item
void                 _db_amctest_curs_Reset(_db_amctest_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_amctest_curs_ValidQ(_db_amctest_curs &curs);
// proceed to next item
void                 _db_amctest_curs_Next(_db_amctest_curs &curs);
// item access
atf_amc::FAmctest&   _db_amctest_curs_Access(_db_amctest_curs &curs);
void                 _db_c_typek_curs_Reset(_db_c_typek_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_typek_curs_ValidQ(_db_c_typek_curs &curs);
// proceed to next item
void                 _db_c_typek_curs_Next(_db_c_typek_curs &curs);
// item access
atf_amc::FTypeK&     _db_c_typek_curs_Access(_db_c_typek_curs &curs);
// cursor points to valid item
void                 _db_avl_curs_Reset(_db_avl_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_avl_curs_ValidQ(_db_avl_curs &curs);
// proceed to next item
void                 _db_avl_curs_Next(_db_avl_curs &curs);
// item access
atf_amc::FAvl&       _db_avl_curs_Access(_db_avl_curs &curs);
// cursor points to valid item
void                 _db_tr_avl_curs_Reset(_db_tr_avl_curs &curs, atf_amc::FDb& );
// cursor points to valid item
bool                 _db_tr_avl_curs_ValidQ(_db_tr_avl_curs &curs);
// proceed to next item
void                 _db_tr_avl_curs_Next(_db_tr_avl_curs &curs);
// item access
atf_amc::FAvl&       _db_tr_avl_curs_Access(_db_tr_avl_curs &curs);
// cursor points to valid item
void                 _db_listtype_curs_Reset(_db_listtype_curs &curs, atf_amc::FDb &parent);
// cursor points to valid item
bool                 _db_listtype_curs_ValidQ(_db_listtype_curs &curs);
// proceed to next item
void                 _db_listtype_curs_Next(_db_listtype_curs &curs);
// item access
atf_amc::FListtype&  _db_listtype_curs_Access(_db_listtype_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- atf_amc.TypeG
// create: atf_amc.OptAlloc.typeg (Opt)
// create: atf_amc.OptG.typeg (Opt)
// create: atf_amc.FOptG.typeg (Opt)
#pragma pack(push,1)
struct TypeG { // atf_amc.TypeG
    i32   typeg;   //   0
    bool operator ==(const atf_amc::TypeG &rhs) const;
    bool operator <(const atf_amc::TypeG &rhs) const;
    TypeG();
};
#pragma pack(pop)

u32                  TypeG_Hash(u32 prev, const atf_amc::TypeG & rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeG from an ascii string.
// The format of the string is the format of the atf_amc::TypeG's only field
bool                 TypeG_ReadStrptrMaybe(atf_amc::TypeG &parent, algo::strptr in_str);
bool                 TypeG_Lt(atf_amc::TypeG & lhs, atf_amc::TypeG & rhs) __attribute__((nothrow));
i32                  TypeG_Cmp(atf_amc::TypeG & lhs, atf_amc::TypeG & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeG_Init(atf_amc::TypeG& typeg);
bool                 TypeG_Eq(const atf_amc::TypeG & lhs,const atf_amc::TypeG & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeG_Update(atf_amc::TypeG &lhs, atf_amc::TypeG & rhs) __attribute__((nothrow));
// print string representation of atf_amc::TypeG to string LHS, no header -- cprint:atf_amc.TypeG.String
void                 TypeG_Print(atf_amc::TypeG & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FOptG
// create: atf_amc.FDb.optg (Lpool)
struct FOptG { // atf_amc.FOptG: Something derived from OptG
    u32                    length;    //   0
    // atf_amc::TypeG      typeg[];                optional field
private:
    friend atf_amc::FOptG&      optg_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FOptG*      optg_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend void                 optg_Delete(atf_amc::FOptG &row) __attribute__((nothrow));
    FOptG();
};

// Copy fields out of row
void                 optg_CopyOut(atf_amc::FOptG &row, atf_amc::OptG &out) __attribute__((nothrow));
// Copy fields in to row
void                 optg_CopyIn(atf_amc::FOptG &row, atf_amc::OptG &in) __attribute__((nothrow));

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
atf_amc::TypeG*      typeg_Get(atf_amc::FOptG& optg) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
algo::aryptr<u8>     typeg_Getary(atf_amc::FOptG& optg) __attribute__((nothrow));

// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::FOptG& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::FOptG& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 FOptG_Init(atf_amc::FOptG& optg);

// --- atf_amc.FPerfSortString
struct FPerfSortString { // atf_amc.FPerfSortString: Function to test string sorting
    atf_amc::Cstr*   orig_elems;      // pointer to elements
    u32              orig_n;          // number of elements in array
    u32              orig_max;        // max. capacity of array before realloc
    atf_amc::Cstr*   sorted1_elems;   // pointer to elements
    u32              sorted1_n;       // number of elements in array
    u32              sorted1_max;     // max. capacity of array before realloc
    FPerfSortString();
    ~FPerfSortString();
private:
    // reftype of atf_amc.FPerfSortString.orig prohibits copy
    // reftype of atf_amc.FPerfSortString.sorted1 prohibits copy
    FPerfSortString(const FPerfSortString&){ /*disallow copy constructor */}
    void operator =(const FPerfSortString&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_amc::Cstr&       orig_Alloc(atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_amc::Cstr&       orig_AllocAt(atf_amc::FPerfSortString& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::Cstr> orig_AllocN(atf_amc::FPerfSortString& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 orig_EmptyQ(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::Cstr*       orig_Find(atf_amc::FPerfSortString& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_amc::Cstr> orig_Getary(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::Cstr*       orig_Last(atf_amc::FPerfSortString& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  orig_Max(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  orig_N(const atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 orig_Remove(atf_amc::FPerfSortString& parent, u32 i) __attribute__((nothrow));
void                 orig_RemoveAll(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 orig_RemoveLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 orig_Reserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 orig_AbsReserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 orig_Setary(atf_amc::FPerfSortString& parent, atf_amc::FPerfSortString &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::Cstr&       orig_qFind(atf_amc::FPerfSortString& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
atf_amc::Cstr&       orig_qLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  orig_rowid_Get(atf_amc::FPerfSortString& parent, atf_amc::Cstr &elem) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 orig_XrefMaybe(atf_amc::Cstr &row);

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<atf_amc::Cstr> sorted1_Addary(atf_amc::FPerfSortString& parent, algo::aryptr<atf_amc::Cstr> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_amc::Cstr&       sorted1_Alloc(atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_amc::Cstr&       sorted1_AllocAt(atf_amc::FPerfSortString& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::Cstr> sorted1_AllocN(atf_amc::FPerfSortString& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 sorted1_EmptyQ(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::Cstr*       sorted1_Find(atf_amc::FPerfSortString& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_amc::Cstr> sorted1_Getary(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::Cstr*       sorted1_Last(atf_amc::FPerfSortString& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  sorted1_Max(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  sorted1_N(const atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 sorted1_Remove(atf_amc::FPerfSortString& parent, u32 i) __attribute__((nothrow));
void                 sorted1_RemoveAll(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 sorted1_RemoveLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 sorted1_Reserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 sorted1_AbsReserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 sorted1_Setary(atf_amc::FPerfSortString& parent, atf_amc::FPerfSortString &rhs) __attribute__((nothrow));
// Copy specified array into sorted1, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 sorted1_Setary(atf_amc::FPerfSortString& parent, const algo::aryptr<atf_amc::Cstr> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::Cstr&       sorted1_qFind(atf_amc::FPerfSortString& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
atf_amc::Cstr&       sorted1_qLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  sorted1_rowid_Get(atf_amc::FPerfSortString& parent, atf_amc::Cstr &elem) __attribute__((nothrow));
// Verify whether array is sorted
bool                 sorted1_SortedQ(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Insertion sort
void                 sorted1_InsertionSort(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Heap sort
void                 sorted1_HeapSort(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Quick sort
void                 sorted1_QuickSort(atf_amc::FPerfSortString& parent) __attribute__((nothrow));

// proceed to next item
void                 FPerfSortString_orig_curs_Next(FPerfSortString_orig_curs &curs);
void                 FPerfSortString_orig_curs_Reset(FPerfSortString_orig_curs &curs, atf_amc::FPerfSortString &parent);
// cursor points to valid item
bool                 FPerfSortString_orig_curs_ValidQ(FPerfSortString_orig_curs &curs);
// item access
atf_amc::Cstr&       FPerfSortString_orig_curs_Access(FPerfSortString_orig_curs &curs);
// proceed to next item
void                 FPerfSortString_sorted1_curs_Next(FPerfSortString_sorted1_curs &curs);
void                 FPerfSortString_sorted1_curs_Reset(FPerfSortString_sorted1_curs &curs, atf_amc::FPerfSortString &parent);
// cursor points to valid item
bool                 FPerfSortString_sorted1_curs_ValidQ(FPerfSortString_sorted1_curs &curs);
// item access
atf_amc::Cstr&       FPerfSortString_sorted1_curs_Access(FPerfSortString_sorted1_curs &curs);
// Set all fields to initial values.
void                 FPerfSortString_Init(atf_amc::FPerfSortString& parent);
void                 FPerfSortString_Uninit(atf_amc::FPerfSortString& parent) __attribute__((nothrow));

// --- atf_amc.FTypeC
// create: atf_amc.FTypeA.typec (Inlary)
// global access: bh_typec (Bheap)
// global access: zdl_h_typec (Llist)
// global access: zd_t_typec (Llist)
// global access: zsl_h_typec (Llist)
// global access: zs_t_typec (Llist)
// global access: zs_mt_typec (ZSListMT)
// global access: zdl_hnt_typec (Llist)
// global access: cdl_h_typec (Llist)
// global access: cd_t_typec (Llist)
// global access: csl_h_typec (Llist)
// global access: cs_t_typec (Llist)
struct FTypeC { // atf_amc.FTypeC
    i32                bh_typec_idx;         // index in heap; -1 means not-in-heap
    atf_amc::FTypeC*   zdl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zdl_h_typec_prev;     // previous element
    atf_amc::FTypeC*   zd_t_typec_next;      // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zd_t_typec_prev;      // previous element
    atf_amc::FTypeC*   zsl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zs_t_typec_next;      // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zs_mt_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zdl_hnt_typec_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zdl_hnt_typec_prev;   // previous element
    atf_amc::FTypeC*   cdl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   cdl_h_typec_prev;     // previous element
    atf_amc::FTypeC*   cd_t_typec_next;      // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   cd_t_typec_prev;      // previous element
    atf_amc::FTypeC*   csl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   cs_t_typec_next;      // zslist link; -1 means not-in-list
    i32                typec;                //   0
    FTypeC();
    ~FTypeC();
private:
    FTypeC(const FTypeC&){ /*disallow copy constructor */}
    void operator =(const FTypeC&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 typec_CopyOut(atf_amc::FTypeC &row, atf_amc::TypeC &out) __attribute__((nothrow));
// Copy fields in to row
void                 typec_CopyIn(atf_amc::FTypeC &row, atf_amc::TypeC &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTypeC_Init(atf_amc::FTypeC& typec);
void                 FTypeC_Uninit(atf_amc::FTypeC& typec) __attribute__((nothrow));
// print string representation of atf_amc::FTypeC to string LHS, no header -- cprint:atf_amc.FTypeC.String
void                 FTypeC_Print(atf_amc::FTypeC & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FTypeA
// create: atf_amc.FDb.typea (Lary)
// global access: ind_typea (Thash)
struct FTypeA { // atf_amc.FTypeA
    atf_amc::FTypeA*    ind_typea_next;                             // hash next
    i32                 typea;                                      //   0
    u128                typec_data[sizeu128(atf_amc::FTypeC,10)];   // place for data
    i32                 typec_n;                                    // number of elems current in existence
    enum { typec_max = 10 };
    atf_amc::FTypeB*    zdl_typeb_head;                             // zero-terminated doubly linked list
    i32                 zdl_typeb_n;                                // zero-terminated doubly linked list
    atf_amc::FTypeB*    zdl_typeb_tail;                             // pointer to last element
    i32                 rowid;                                      //   0
    atf_amc::FTypeB**   bh_typeb_elems;                             // binary heap by j
    i32                 bh_typeb_n;                                 // number of elements in the heap
    i32                 bh_typeb_max;                               // max elements in bh_typeb_elems
private:
    friend atf_amc::FTypeA&     typea_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeA*     typea_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typea_RemoveAll() __attribute__((nothrow));
    friend void                 typea_RemoveLast() __attribute__((nothrow));
    FTypeA();
    ~FTypeA();
    FTypeA(const FTypeA&){ /*disallow copy constructor */}
    void operator =(const FTypeA&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 typea_CopyOut(atf_amc::FTypeA &row, atf_amc::TypeA &out) __attribute__((nothrow));
// Copy fields in to row
void                 typea_CopyIn(atf_amc::FTypeA &row, atf_amc::TypeA &in) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_amc::FTypeC&     typec_Alloc(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_amc::FTypeC*     typec_AllocMaybe(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_amc::FTypeC*     typec_InsertMaybe(atf_amc::FTypeA& typea, const atf_amc::TypeC &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                typec_AllocMem(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 typec_EmptyQ(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::FTypeC*     typec_Find(atf_amc::FTypeA& typea, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_amc::FTypeC> typec_Getary(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return constant 10 -- max. number of items in the pool
i32                  typec_Max(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return number of items in the array
i32                  typec_N(const atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
void                 typec_RemoveAll(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 typec_RemoveLast(atf_amc::FTypeA& typea) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
atf_amc::FTypeC&     typec_qFind(atf_amc::FTypeA& typea, u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
u64                  typec_rowid_Get(atf_amc::FTypeA& typea, atf_amc::FTypeC &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typec_XrefMaybe(atf_amc::FTypeC &row);

// Delete all elements in the linked list.
void                 zdl_typeb_Cascdel(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return true if index is empty
bool                 zdl_typeb_EmptyQ(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeB*     zdl_typeb_First(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zdl_typeb_InLlistQ(atf_amc::FTypeB& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zdl_typeb_Insert(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeB*     zdl_typeb_Last(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zdl_typeb_N(const atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeB*     zdl_typeb_Next(atf_amc::FTypeB &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeB*     zdl_typeb_Prev(atf_amc::FTypeB &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zdl_typeb_Remove(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zdl_typeb_RemoveAll(atf_amc::FTypeA& typea) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeB*     zdl_typeb_RemoveFirst(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeB&     zdl_typeb_qLast(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));

// Delete referred-to items.
// Delete all elements referenced by the heap.
void                 bh_typeb_Cascdel(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Remove all elements from heap and free memory used by the array.
void                 bh_typeb_Dealloc(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return true if index is empty
bool                 bh_typeb_EmptyQ(atf_amc::FTypeA& typea) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeB*     bh_typeb_First(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_typeb_InBheapQ(atf_amc::FTypeB& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_typeb_Insert(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_typeb_N(const atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_typeb_Reheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_typeb_ReheapFirst(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_typeb_Remove(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_typeb_RemoveAll(atf_amc::FTypeA& typea) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
atf_amc::FTypeB*     bh_typeb_RemoveFirst(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_typeb_Reserve(atf_amc::FTypeA& typea, int n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTypeA_Init(atf_amc::FTypeA& typea);
// cursor points to valid item
void                 typea_typec_curs_Reset(typea_typec_curs &curs, atf_amc::FTypeA &parent);
// cursor points to valid item
bool                 typea_typec_curs_ValidQ(typea_typec_curs &curs);
// proceed to next item
void                 typea_typec_curs_Next(typea_typec_curs &curs);
// item access
atf_amc::FTypeC&     typea_typec_curs_Access(typea_typec_curs &curs);
// cursor points to valid item
void                 typea_zdl_typeb_curs_Reset(typea_zdl_typeb_curs &curs, atf_amc::FTypeA &parent);
// cursor points to valid item
bool                 typea_zdl_typeb_curs_ValidQ(typea_zdl_typeb_curs &curs);
// proceed to next item
void                 typea_zdl_typeb_curs_Next(typea_zdl_typeb_curs &curs);
// item access
atf_amc::FTypeB&     typea_zdl_typeb_curs_Access(typea_zdl_typeb_curs &curs);
void                 typea_bh_typeb_curs_Reserve(typea_bh_typeb_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 typea_bh_typeb_curs_Reset(typea_bh_typeb_curs &curs, atf_amc::FTypeA &parent);
// Advance cursor.
void                 typea_bh_typeb_curs_Next(typea_bh_typeb_curs &curs);
// Access current element. If not more elements, return NULL
atf_amc::FTypeB&     typea_bh_typeb_curs_Access(typea_bh_typeb_curs &curs);
// Return true if Access() will return non-NULL.
bool                 typea_bh_typeb_curs_ValidQ(typea_bh_typeb_curs &curs);
void                 FTypeA_Uninit(atf_amc::FTypeA& typea) __attribute__((nothrow));
// print string representation of atf_amc::FTypeA to string LHS, no header -- cprint:atf_amc.FTypeA.String
void                 FTypeA_Print(atf_amc::FTypeA & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FTypeB
// create: atf_amc.FDb.typeb (Tpool)
// access: atf_amc.FTypeA.zdl_typeb (Llist)
// access: atf_amc.FTypeA.bh_typeb (Bheap)
struct FTypeB { // atf_amc.FTypeB
    atf_amc::FTypeB*   typeb_next;       // Pointer to next free element int tpool
    atf_amc::FTypeB*   zdl_typeb_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeB*   zdl_typeb_prev;   // previous element
    i32                bh_typeb_idx;     // index in heap; -1 means not-in-heap
    i32                typea;            //   0
    i32                j;                //   0
private:
    friend atf_amc::FTypeB&     typeb_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeB*     typeb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typeb_Delete(atf_amc::FTypeB &row) __attribute__((nothrow));
    FTypeB();
    ~FTypeB();
    FTypeB(const FTypeB&){ /*disallow copy constructor */}
    void operator =(const FTypeB&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 typeb_CopyOut(atf_amc::FTypeB &row, atf_amc::TypeB &out) __attribute__((nothrow));
// Copy fields in to row
void                 typeb_CopyIn(atf_amc::FTypeB &row, atf_amc::TypeB &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTypeB_Init(atf_amc::FTypeB& typeb);
void                 FTypeB_Uninit(atf_amc::FTypeB& typeb) __attribute__((nothrow));
// print string representation of atf_amc::FTypeB to string LHS, no header -- cprint:atf_amc.FTypeB.String
void                 FTypeB_Print(atf_amc::FTypeB & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FTypeK
// global access: c_typek (Ptrary)
struct FTypeK { // atf_amc.FTypeK
    u32    value;                //   0
    bool   _db_c_typek_in_ary;   //   false  membership flag
    FTypeK();
};

// Set all fields to initial values.
void                 FTypeK_Init(atf_amc::FTypeK& parent);

// --- atf_amc.FTypeS
// create: atf_amc.FDb.types (Lary)
// global access: ind_types (Thash)
struct FTypeS { // atf_amc.FTypeS
    atf_amc::FTypeS*   ind_types_next;   // hash next
    i32                types;            //   0
    algo::Comment      comment;          //
    atf_amc::FTypeT*   zdl_typet_head;   // zero-terminated doubly linked list
    i32                zdl_typet_n;      // zero-terminated doubly linked list
    atf_amc::FTypeT*   zdl_typet_tail;   // pointer to last element
private:
    friend atf_amc::FTypeS&     types_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeS*     types_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 types_RemoveAll() __attribute__((nothrow));
    friend void                 types_RemoveLast() __attribute__((nothrow));
    FTypeS();
    ~FTypeS();
    FTypeS(const FTypeS&){ /*disallow copy constructor */}
    void operator =(const FTypeS&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 types_CopyOut(atf_amc::FTypeS &row, atf_amc::TypeS &out) __attribute__((nothrow));
// Copy fields in to row
void                 types_CopyIn(atf_amc::FTypeS &row, atf_amc::TypeS &in) __attribute__((nothrow));

// Return true if index is empty
bool                 zdl_typet_EmptyQ(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
atf_amc::FTypeT*     zdl_typet_First(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zdl_typet_InLlistQ(atf_amc::FTypeT& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zdl_typet_Insert(atf_amc::FTypeS& types, atf_amc::FTypeT& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
atf_amc::FTypeT*     zdl_typet_Last(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zdl_typet_N(const atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
atf_amc::FTypeT*     zdl_typet_Next(atf_amc::FTypeT &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
atf_amc::FTypeT*     zdl_typet_Prev(atf_amc::FTypeT &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zdl_typet_Remove(atf_amc::FTypeS& types, atf_amc::FTypeT& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zdl_typet_RemoveAll(atf_amc::FTypeS& types) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
atf_amc::FTypeT*     zdl_typet_RemoveFirst(atf_amc::FTypeS& types) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
atf_amc::FTypeT&     zdl_typet_qLast(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FTypeS_Init(atf_amc::FTypeS& types);
// cursor points to valid item
void                 types_zdl_typet_curs_Reset(types_zdl_typet_curs &curs, atf_amc::FTypeS &parent);
// cursor points to valid item
bool                 types_zdl_typet_curs_ValidQ(types_zdl_typet_curs &curs);
// proceed to next item
void                 types_zdl_typet_curs_Next(types_zdl_typet_curs &curs);
// item access
atf_amc::FTypeT&     types_zdl_typet_curs_Access(types_zdl_typet_curs &curs);
void                 FTypeS_Uninit(atf_amc::FTypeS& types) __attribute__((nothrow));
// print string representation of atf_amc::FTypeS to string LHS, no header -- cprint:atf_amc.FTypeS.String
void                 FTypeS_Print(atf_amc::FTypeS & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.FTypeT
// create: atf_amc.FDb.typet (Lary)
// access: atf_amc.FTypeS.zdl_typet (Llist)
struct FTypeT { // atf_amc.FTypeT
    atf_amc::FTypeT*   zdl_typet_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeT*   zdl_typet_prev;   // previous element
    i32                types;            //   0
    i32                j;                //   0
private:
    friend atf_amc::FTypeT&     typet_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeT*     typet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typet_RemoveAll() __attribute__((nothrow));
    friend void                 typet_RemoveLast() __attribute__((nothrow));
    FTypeT();
    ~FTypeT();
    FTypeT(const FTypeT&){ /*disallow copy constructor */}
    void operator =(const FTypeT&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 typet_CopyOut(atf_amc::FTypeT &row, atf_amc::TypeT &out) __attribute__((nothrow));
// Copy fields in to row
void                 typet_CopyIn(atf_amc::FTypeT &row, atf_amc::TypeT &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTypeT_Init(atf_amc::FTypeT& typet);
void                 FTypeT_Uninit(atf_amc::FTypeT& typet) __attribute__((nothrow));
// print string representation of atf_amc::FTypeT to string LHS, no header -- cprint:atf_amc.FTypeT.String
void                 FTypeT_Print(atf_amc::FTypeT & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeA
// create: atf_amc.FUnitSort.tary (Tary)
// create: atf_amc.FUnitSort.fixary (Inlary)
// access: atf_amc.FTypeA.msghdr (Base)
// access: atf_amc.FUnitSort.c_ptrary (Ptrary)
struct TypeA { // atf_amc.TypeA
    i32   typea;   //   0
    bool operator ==(const atf_amc::TypeA &rhs) const;
    bool operator <(const atf_amc::TypeA &rhs) const;
    TypeA();
};

u32                  TypeA_Hash(u32 prev, const atf_amc::TypeA & rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeA from an ascii string.
// The format of the string is the format of the atf_amc::TypeA's only field
bool                 TypeA_ReadStrptrMaybe(atf_amc::TypeA &parent, algo::strptr in_str);
bool                 TypeA_Lt(atf_amc::TypeA & lhs, atf_amc::TypeA & rhs) __attribute__((nothrow));
i32                  TypeA_Cmp(atf_amc::TypeA & lhs, atf_amc::TypeA & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeA_Init(atf_amc::TypeA& tary);
bool                 TypeA_Eq(const atf_amc::TypeA & lhs,const atf_amc::TypeA & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeA_Update(atf_amc::TypeA &lhs, atf_amc::TypeA & rhs) __attribute__((nothrow));
// print string representation of atf_amc::TypeA to string LHS, no header -- cprint:atf_amc.TypeA.String
void                 TypeA_Print(atf_amc::TypeA & row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of atf_amc::TypeA under PARENT node -- cprint:atf_amc.TypeA.Json
lib_json::FNode *    TypeA_FmtJson(atf_amc::TypeA & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_amc.FUnitSort
struct FUnitSort { // atf_amc.FUnitSort
    atf_amc::TypeA*    tary_elems;          // pointer to elements
    u32                tary_n;              // number of elements in array
    u32                tary_max;            // max. capacity of array before realloc
    atf_amc::TypeA**   c_ptrary_elems;      // array of pointers
    u32                c_ptrary_n;          // array of pointers
    u32                c_ptrary_max;        // capacity of allocated array
    atf_amc::TypeA     fixary_elems[100];   // fixed array
    FUnitSort();
    ~FUnitSort();
private:
    // reftype of atf_amc.FUnitSort.tary prohibits copy
    // reftype of atf_amc.FUnitSort.c_ptrary prohibits copy
    FUnitSort(const FUnitSort&){ /*disallow copy constructor */}
    void operator =(const FUnitSort&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_amc::TypeA&      tary_Alloc(atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_amc::TypeA&      tary_AllocAt(atf_amc::FUnitSort& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_amc::TypeA> tary_AllocN(atf_amc::FUnitSort& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tary_EmptyQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::TypeA*      tary_Find(atf_amc::FUnitSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_amc::TypeA> tary_Getary(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_amc::TypeA*      tary_Last(atf_amc::FUnitSort& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  tary_Max(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  tary_N(const atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 tary_Remove(atf_amc::FUnitSort& parent, u32 i) __attribute__((nothrow));
void                 tary_RemoveAll(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tary_RemoveLast(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 tary_Reserve(atf_amc::FUnitSort& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 tary_AbsReserve(atf_amc::FUnitSort& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 tary_Setary(atf_amc::FUnitSort& parent, atf_amc::FUnitSort &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_amc::TypeA&      tary_qFind(atf_amc::FUnitSort& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
atf_amc::TypeA&      tary_qLast(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  tary_rowid_Get(atf_amc::FUnitSort& parent, atf_amc::TypeA &elem) __attribute__((nothrow));
// Verify whether array is sorted
bool                 tary_SortedQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insertion sort
void                 tary_InsertionSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Heap sort
void                 tary_HeapSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Quick sort
void                 tary_QuickSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 tary_XrefMaybe(atf_amc::TypeA &row);

// Return true if index is empty
bool                 c_ptrary_EmptyQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::TypeA*      c_ptrary_Find(atf_amc::FUnitSort& parent, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<atf_amc::TypeA*> c_ptrary_Getary(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ptrary_Insert(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_ptrary_ScanInsertMaybe(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ptrary_N(const atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ptrary_Remove(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ptrary_RemoveAll(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ptrary_Reserve(atf_amc::FUnitSort& parent, u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_ptrary_SortedQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insertion sort
void                 c_ptrary_InsertionSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Heap sort
void                 c_ptrary_HeapSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Quick sort
void                 c_ptrary_QuickSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));

// Set all elements of fixed array to value RHS
void                 fixary_Fill(atf_amc::FUnitSort& parent, const atf_amc::TypeA &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_amc::TypeA*      fixary_Find(atf_amc::FUnitSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array fixary as aryptr.
algo::aryptr<atf_amc::TypeA> fixary_Getary(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  fixary_Max(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  fixary_N(const atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 fixary_Setary(atf_amc::FUnitSort& parent, const algo::aryptr<atf_amc::TypeA> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
atf_amc::TypeA&      fixary_qFind(atf_amc::FUnitSort& parent, u64 t) __attribute__((nothrow));
// Verify whether array is sorted
bool                 fixary_SortedQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insertion sort
void                 fixary_InsertionSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Heap sort
void                 fixary_HeapSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Quick sort
void                 fixary_QuickSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));

// proceed to next item
void                 FUnitSort_tary_curs_Next(FUnitSort_tary_curs &curs);
void                 FUnitSort_tary_curs_Reset(FUnitSort_tary_curs &curs, atf_amc::FUnitSort &parent);
// cursor points to valid item
bool                 FUnitSort_tary_curs_ValidQ(FUnitSort_tary_curs &curs);
// item access
atf_amc::TypeA&      FUnitSort_tary_curs_Access(FUnitSort_tary_curs &curs);
void                 FUnitSort_c_ptrary_curs_Reset(FUnitSort_c_ptrary_curs &curs, atf_amc::FUnitSort &parent);
// cursor points to valid item
bool                 FUnitSort_c_ptrary_curs_ValidQ(FUnitSort_c_ptrary_curs &curs);
// proceed to next item
void                 FUnitSort_c_ptrary_curs_Next(FUnitSort_c_ptrary_curs &curs);
// item access
atf_amc::TypeA&      FUnitSort_c_ptrary_curs_Access(FUnitSort_c_ptrary_curs &curs);
// cursor points to valid item
void                 FUnitSort_fixary_curs_Reset(FUnitSort_fixary_curs &curs, atf_amc::FUnitSort &parent);
// cursor points to valid item
bool                 FUnitSort_fixary_curs_ValidQ(FUnitSort_fixary_curs &curs);
// proceed to next item
void                 FUnitSort_fixary_curs_Next(FUnitSort_fixary_curs &curs);
// item access
atf_amc::TypeA&      FUnitSort_fixary_curs_Access(FUnitSort_fixary_curs &curs);
// Set all fields to initial values.
void                 FUnitSort_Init(atf_amc::FUnitSort& parent);
void                 FUnitSort_Uninit(atf_amc::FUnitSort& parent) __attribute__((nothrow));

// --- atf_amc.FieldId
#pragma pack(push,1)
struct FieldId { // atf_amc.FieldId: Field read helper
    i32   value;   //   -1
    inline operator atf_amc_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(atf_amc_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
atf_amc_FieldIdEnum  value_GetEnum(const atf_amc::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::FieldId& parent, atf_amc_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::FieldId& parent, algo::strptr rhs, atf_amc_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::FieldId from an ascii string.
// The format of the string is the format of the atf_amc::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(atf_amc::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(atf_amc::FieldId& parent);
// print string representation of atf_amc::FieldId to string LHS, no header -- cprint:atf_amc.FieldId.String
void                 FieldId_Print(atf_amc::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Hooktype
// access: atf_amc.Hooktype.callback (Hook)
struct Hooktype { // atf_amc.Hooktype
    atf_amc::parent_callback_hook   callback;       //   NULL  Pointer to a function
    u64                             callback_ctx;   //   0  Callback context
    i32                             value;          //   0
    Hooktype();
private:
    // reftype of atf_amc.Hooktype.callback prohibits copy
    Hooktype(const Hooktype&){ /*disallow copy constructor */}
    void operator =(const Hooktype&){ /*disallow direct assignment */}
};

// Invoke function by pointer
void                 callback_Call(atf_amc::Hooktype& parent, atf_amc::Hooktype& arg) __attribute__((nothrow));
// Assign 0-argument hook with no context pointer
void                 callback_Set0(atf_amc::Hooktype& parent, void (*fcn)() ) __attribute__((nothrow));
// Assign 1-argument hook with context pointer
template<class T> void callback_Set1(atf_amc::Hooktype& parent, T& ctx, void (*fcn)(T&) ) __attribute__((nothrow));
// Assign 2-argument hook with context pointer
template<class T> void callback_Set2(atf_amc::Hooktype& parent, T& ctx, void (*fcn)(T&, atf_amc::Hooktype& arg) ) __attribute__((nothrow));

// Set all fields to initial values.
void                 Hooktype_Init(atf_amc::Hooktype& parent);

// --- atf_amc.InlaryPrint
struct InlaryPrint { // atf_amc.InlaryPrint
    u32    fixary_elems[3];                 //   0  fixed array
    u128   inlary_data[sizeu128(u32,10)];   // place for data
    i32    inlary_n;                        // number of elems current in existence
    enum { inlary_max = 10 };
    InlaryPrint();
    ~InlaryPrint();
};

// Set all elements of fixed array to value RHS
void                 fixary_Fill(atf_amc::InlaryPrint& parent, const u32 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u32*                 fixary_Find(atf_amc::InlaryPrint& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array fixary as aryptr.
algo::aryptr<u32>    fixary_Getary(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  fixary_Max(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  fixary_N(const atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 fixary_Setary(atf_amc::InlaryPrint& parent, const algo::aryptr<u32> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u32&                 fixary_qFind(atf_amc::InlaryPrint& parent, u64 t) __attribute__((nothrow));
// Convert fixary to a string. Parent's separator is used.
void                 fixary_Print(atf_amc::InlaryPrint& parent, algo::cstring &lhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
bool                 fixary_ReadStrptrMaybe(atf_amc::InlaryPrint& parent, algo::strptr in_str) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
u32&                 inlary_Alloc(atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
u32*                 inlary_AllocMaybe(atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                inlary_AllocMem(atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 inlary_EmptyQ(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u32*                 inlary_Find(atf_amc::InlaryPrint& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<u32>    inlary_Getary(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return constant 10 -- max. number of items in the pool
i32                  inlary_Max(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  inlary_N(const atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
void                 inlary_RemoveAll(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 inlary_RemoveLast(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u32&                 inlary_qFind(atf_amc::InlaryPrint& parent, u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
u64                  inlary_rowid_Get(atf_amc::InlaryPrint& parent, u32 &row) __attribute__((nothrow));
// Convert inlary to a string. Parent's separator is used.
void                 inlary_Print(atf_amc::InlaryPrint& parent, algo::cstring &lhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
bool                 inlary_ReadStrptrMaybe(atf_amc::InlaryPrint& parent, algo::strptr in_str) __attribute__((nothrow));

// cursor points to valid item
void                 InlaryPrint_fixary_curs_Reset(InlaryPrint_fixary_curs &curs, atf_amc::InlaryPrint &parent);
// cursor points to valid item
bool                 InlaryPrint_fixary_curs_ValidQ(InlaryPrint_fixary_curs &curs);
// proceed to next item
void                 InlaryPrint_fixary_curs_Next(InlaryPrint_fixary_curs &curs);
// item access
u32&                 InlaryPrint_fixary_curs_Access(InlaryPrint_fixary_curs &curs);
// cursor points to valid item
void                 InlaryPrint_inlary_curs_Reset(InlaryPrint_inlary_curs &curs, atf_amc::InlaryPrint &parent);
// cursor points to valid item
bool                 InlaryPrint_inlary_curs_ValidQ(InlaryPrint_inlary_curs &curs);
// proceed to next item
void                 InlaryPrint_inlary_curs_Next(InlaryPrint_inlary_curs &curs);
// item access
u32&                 InlaryPrint_inlary_curs_Access(InlaryPrint_inlary_curs &curs);
bool                 InlaryPrint_ReadFieldMaybe(atf_amc::InlaryPrint &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::InlaryPrint from an ascii string.
// The format of the string is an ssim Tuple
bool                 InlaryPrint_ReadStrptrMaybe(atf_amc::InlaryPrint &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 InlaryPrint_Init(atf_amc::InlaryPrint& parent);
void                 InlaryPrint_Uninit(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// print string representation of atf_amc::InlaryPrint to string LHS, no header -- cprint:atf_amc.InlaryPrint.String
void                 InlaryPrint_Print(atf_amc::InlaryPrint & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Lary32
struct Lary32 { // atf_amc.Lary32
    u32*   lary_lary[32];   // level array
    i32    lary_n;          // number of elements in array
    Lary32();
    ~Lary32();
private:
    // reftype of atf_amc.Lary32.lary prohibits copy
    Lary32(const Lary32&){ /*disallow copy constructor */}
    void operator =(const Lary32&){ /*disallow direct assignment */}
};

// Allocate memory for new default row.
// If out of memory, process is killed.
u32&                 lary_Alloc(atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
u32*                 lary_AllocMaybe(atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                lary_AllocMem(atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 lary_EmptyQ(atf_amc::Lary32& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u32*                 lary_Find(atf_amc::Lary32& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
u32*                 lary_Last(atf_amc::Lary32& parent) __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  lary_N(const atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 lary_RemoveAll(atf_amc::Lary32& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 lary_RemoveLast(atf_amc::Lary32& parent) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
u32&                 lary_qFind(atf_amc::Lary32& parent, u64 t) __attribute__((nothrow));

// cursor points to valid item
void                 Lary32_lary_curs_Reset(Lary32_lary_curs &curs, atf_amc::Lary32 &parent);
// cursor points to valid item
bool                 Lary32_lary_curs_ValidQ(Lary32_lary_curs &curs);
// proceed to next item
void                 Lary32_lary_curs_Next(Lary32_lary_curs &curs);
// item access
u32&                 Lary32_lary_curs_Access(Lary32_lary_curs &curs);
// Set all fields to initial values.
void                 Lary32_Init(atf_amc::Lary32& parent);
void                 Lary32_Uninit(atf_amc::Lary32& parent) __attribute__((nothrow));

// --- atf_amc.Linebuf
// create: atf_amc.FDb.linebuf (Cppstack)
struct Linebuf { // atf_amc.Linebuf
    u8              in_elems[64];      // pointer to elements of inline array
    i32             in_start;          // beginning of valid bytes (in bytes)
    i32             in_end;            // end of valid bytes (in bytes)
    bool            in_eof;            // no more data will be written to buffer
    algo::Errcode   in_err;            // system error code
    bool            in_msgvalid;       // current message is valid
    i32             in_msglen;         // current message length
    bool            in_epoll_enable;   // use epoll?
    enum { in_max = 64 };
    Linebuf();
private:
    // reftype of atf_amc.Linebuf.in prohibits copy
    Linebuf(const Linebuf&){ /*disallow copy constructor */}
    void operator =(const Linebuf&){ /*disallow direct assignment */}
};

// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
//
aryptr<char>         in_GetMsg(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
i32                  in_Max(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
i32                  in_N(atf_amc::Linebuf& linebuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Discard contents of the buffer.
void                 in_RemoveAll(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Mark some buffer contents as read.
//
void                 in_SkipBytes(atf_amc::Linebuf& linebuf, int n) __attribute__((nothrow));
// Skip current message, if any.
void                 in_SkipMsg(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
bool                 in_WriteAll(atf_amc::Linebuf& linebuf, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
void                 Linebuf_Init(atf_amc::Linebuf& linebuf);
// print string representation of atf_amc::Linebuf to string LHS, no header -- cprint:atf_amc.Linebuf.String
void                 Linebuf_Print(atf_amc::Linebuf & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.MsgType
#pragma pack(push,1)
struct MsgType { // atf_amc.MsgType
    u16   value;   //   0
    inline operator atf_amc_MsgTypeEnum() const;
    explicit MsgType(u16                            in_value);
    MsgType(atf_amc_MsgTypeEnum arg);
    bool operator ==(const atf_amc::MsgType &rhs) const;
    bool operator <(const atf_amc::MsgType &rhs) const;
    bool operator ==(atf_amc_MsgTypeEnum rhs) const;
    MsgType();
};
#pragma pack(pop)

// Get value of field as enum type
atf_amc_MsgTypeEnum  value_GetEnum(const atf_amc::MsgType& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::MsgType& parent, atf_amc_MsgTypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::MsgType& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::MsgType& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::MsgType& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::MsgType& parent, algo::strptr rhs, atf_amc_MsgTypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::MsgType& parent, algo::strptr rhs) __attribute__((nothrow));

u32                  MsgType_Hash(u32 prev, atf_amc::MsgType rhs) __attribute__((nothrow));
// Read fields of atf_amc::MsgType from an ascii string.
// The format of the string is the format of the atf_amc::MsgType's only field
bool                 MsgType_ReadStrptrMaybe(atf_amc::MsgType &parent, algo::strptr in_str);
bool                 MsgType_Lt(atf_amc::MsgType lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
i32                  MsgType_Cmp(atf_amc::MsgType lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 MsgType_Init(atf_amc::MsgType& parent);
bool                 MsgType_Eq(atf_amc::MsgType lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 MsgType_Update(atf_amc::MsgType &lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// print string representation of atf_amc::MsgType to string LHS, no header -- cprint:atf_amc.MsgType.String
void                 MsgType_Print(atf_amc::MsgType row, algo::cstring &str) __attribute__((nothrow));
// define enum comparison operator to avoid ambiguity
bool                 MsgType_EqEnum(atf_amc::MsgType lhs, atf_amc_MsgTypeEnum rhs) __attribute__((nothrow));

// --- atf_amc.MsgLength
#pragma pack(push,1)
struct MsgLength { // atf_amc.MsgLength
    u16   value;   //   0
    inline operator u16() const;
    explicit MsgLength(u16                            in_value);
    MsgLength();
};
#pragma pack(pop)

u32                  MsgLength_Hash(u32 prev, atf_amc::MsgLength rhs) __attribute__((nothrow));
// Read fields of atf_amc::MsgLength from an ascii string.
// The format of the string is the format of the atf_amc::MsgLength's only field
bool                 MsgLength_ReadStrptrMaybe(atf_amc::MsgLength &parent, algo::strptr in_str);
bool                 MsgLength_Lt(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
i32                  MsgLength_Cmp(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 MsgLength_Init(atf_amc::MsgLength& parent);
bool                 MsgLength_Eq(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 MsgLength_Update(atf_amc::MsgLength &lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// print string representation of atf_amc::MsgLength to string LHS, no header -- cprint:atf_amc.MsgLength.String
void                 MsgLength_Print(atf_amc::MsgLength row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.MsgHeader
// create: atf_amc.Msgbuf.in (Fbuf)
// create: atf_amc.Seqmsg.payload (Opt)
// access: atf_amc.Seqmsg.msghdr (Base)
// access: atf_amc.Text.msghdr (Base)
// access: atf_amc.MsgHeader_curs.msg (Ptr)
#pragma pack(push,1)
struct MsgHeader { // atf_amc.MsgHeader
    atf_amc::MsgType     type;     // Message type
    atf_amc::MsgLength   length;   // Total message length, including this header
    explicit MsgHeader(atf_amc::MsgType               in_type
        ,atf_amc::MsgLength             in_length);
    bool operator ==(const atf_amc::MsgHeader &rhs) const;
    MsgHeader();
};
#pragma pack(pop)

u32                  MsgHeader_Hash(u32 prev, const atf_amc::MsgHeader & rhs) __attribute__((nothrow));
bool                 MsgHeader_ReadFieldMaybe(atf_amc::MsgHeader &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
bool                 MsgHeader_ReadStrptrMaybe(atf_amc::MsgHeader &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::MsgHeader& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::MsgHeader& row) __attribute__((nothrow));
i32                  MsgHeader_Cmp(atf_amc::MsgHeader & lhs, atf_amc::MsgHeader & rhs) __attribute__((nothrow));
bool                 MsgHeader_Eq(const atf_amc::MsgHeader & lhs,const atf_amc::MsgHeader & rhs) __attribute__((nothrow));
// print string representation of atf_amc::MsgHeader to string LHS, no header -- cprint:atf_amc.MsgHeader.String
void                 MsgHeader_Print(atf_amc::MsgHeader & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.MsgHeader_curs
#pragma pack(push,1)
struct MsgHeader_curs { // atf_amc.MsgHeader_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::MsgHeader *ChildType;
    atf_amc::MsgHeader*   msg;      // Pointer to current message. optional pointer
    u8*                   bytes;    // Beginning of region. optional pointer
    i32                   limit;    //   0  # Of bytes in the region
    i32                   msglen;   //   0  Length of current message (if any)
    MsgHeader_curs();
};
#pragma pack(pop)

bool                 MsgHeader_curs_ValidQ(atf_amc::MsgHeader_curs& curs) __attribute__((nothrow));
void                 MsgHeader_curs_Reset(atf_amc::MsgHeader_curs& curs, memptr buf) __attribute__((nothrow));
atf_amc::MsgHeader*& MsgHeader_curs_Access(atf_amc::MsgHeader_curs& curs) __attribute__((nothrow));
void                 MsgHeader_curs_Next(atf_amc::MsgHeader_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
void                 MsgHeader_curs_Init(atf_amc::MsgHeader_curs& parent);

// --- atf_amc.Msgbuf
// create: atf_amc.FDb.msgbuf (Cppstack)
// global access: cd_in_msg (Llist)
struct Msgbuf { // atf_amc.Msgbuf
    atf_amc::Msgbuf*    cd_in_msg_next;    // zslist link; -1 means not-in-list
    atf_amc::Msgbuf*    cd_in_msg_prev;    // previous element
    u8                  in_elems[64];      // pointer to elements of inline array
    i32                 in_start;          // beginning of valid bytes (in bytes)
    i32                 in_end;            // end of valid bytes (in bytes)
    bool                in_eof;            // no more data will be written to buffer
    algo::Errcode       in_err;            // system error code
    bool                in_msgvalid;       // current message is valid
    i32                 in_msglen;         // current message length
    algo_lib::FIohook   in_iohook;         // edge-triggered hook for refilling buffer
    bool                in_epoll_enable;   // use epoll?
    enum { in_max = 64 };
    Msgbuf();
    ~Msgbuf();
private:
    Msgbuf(const Msgbuf&){ /*disallow copy constructor */}
    void operator =(const Msgbuf&){ /*disallow direct assignment */}
};

// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by atf_amc::MsgHeader via FIohook field.
// Whenever the file descriptor becomes readable, insert msgbuf into cd_in_msg.
void                 in_BeginRead(atf_amc::Msgbuf& msgbuf, algo::Fildes fd) __attribute__((nothrow));
// Set EOF flag
void                 in_EndRead(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is length-delimited based on field length field
//
atf_amc::MsgHeader*  in_GetMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
i32                  in_Max(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
i32                  in_N(atf_amc::Msgbuf& msgbuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
bool                 in_Refill(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Discard contents of the buffer.
void                 in_RemoveAll(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Skip current message, if any.
void                 in_SkipMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
bool                 in_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 in_XrefMaybe(atf_amc::MsgHeader &row);

// Set all fields to initial values.
void                 Msgbuf_Init(atf_amc::Msgbuf& msgbuf);
void                 Msgbuf_Uninit(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// print string representation of atf_amc::Msgbuf to string LHS, no header -- cprint:atf_amc.Msgbuf.String
void                 Msgbuf_Print(atf_amc::Msgbuf & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.MsgsCase
#pragma pack(push,1)
struct MsgsCase { // atf_amc.MsgsCase: Enum for dispatch atf_amc.Msgs
    u32   value;   //   0
    inline operator atf_amc_MsgsCaseEnum() const;
    explicit MsgsCase(u32                            in_value);
    MsgsCase(atf_amc_MsgsCaseEnum arg);
    MsgsCase();
};
#pragma pack(pop)

// Get value of field as enum type
atf_amc_MsgsCaseEnum value_GetEnum(const atf_amc::MsgsCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::MsgsCase& parent, atf_amc_MsgsCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::MsgsCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::MsgsCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::MsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::MsgsCase& parent, algo::strptr rhs, atf_amc_MsgsCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::MsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::MsgsCase from an ascii string.
// The format of the string is the format of the atf_amc::MsgsCase's only field
bool                 MsgsCase_ReadStrptrMaybe(atf_amc::MsgsCase &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 MsgsCase_Init(atf_amc::MsgsCase& parent);

// --- atf_amc.NetBitfld1
struct NetBitfld1 { // atf_amc.NetBitfld1
    u16   value_be;   //   0
    NetBitfld1();
};

u16                  value_Get(const atf_amc::NetBitfld1& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::NetBitfld1& parent, u16 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u8                   bits0_4_Get(const atf_amc::NetBitfld1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits0_4_Set(atf_amc::NetBitfld1& parent, u8 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 8.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u8                   bits8_12_Get(const atf_amc::NetBitfld1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 8.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits8_12_Set(atf_amc::NetBitfld1& parent, u8 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 NetBitfld1_Init(atf_amc::NetBitfld1& parent);
// print string representation of atf_amc::NetBitfld1 to string LHS, no header -- cprint:atf_amc.NetBitfld1.String
void                 NetBitfld1_Print(atf_amc::NetBitfld1 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.OptAlloc
// create: atf_amc.FDb.optalloc (Lpool)
#pragma pack(push,1)
struct OptAlloc { // atf_amc.OptAlloc: An optional instance of atf_unit.A
    u32                    length;    //   0
    // atf_amc::TypeG      typeg[];                optional field
private:
    friend atf_amc::OptAlloc&   optalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::OptAlloc*   optalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend void                 optalloc_Delete(atf_amc::OptAlloc &row) __attribute__((nothrow));
    OptAlloc();
};
#pragma pack(pop)

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
atf_amc::TypeG*      typeg_Get(atf_amc::OptAlloc& optalloc) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
algo::aryptr<u8>     typeg_Getary(atf_amc::OptAlloc& optalloc) __attribute__((nothrow));
void                 typeg_Print(atf_amc::OptAlloc& optalloc, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 typeg_ReadStrptrMaybe(atf_amc::OptAlloc &parent, algo::strptr in_str) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typeg_XrefMaybe(atf_amc::TypeG &row);

bool                 OptAlloc_ReadFieldMaybe(atf_amc::OptAlloc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf
// Read fields of atf_amc::OptAlloc from an ascii string.
// The format of the string is an ssim Tuple
bool                 OptAlloc_ReadStrptrMaybe(atf_amc::OptAlloc &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::OptAlloc& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::OptAlloc& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 OptAlloc_Init(atf_amc::OptAlloc& optalloc);
// print string representation of atf_amc::OptAlloc to string LHS, no header -- cprint:atf_amc.OptAlloc.String
void                 OptAlloc_Print(atf_amc::OptAlloc & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.OptG
// create: atf_amc.OptOptG.optg (Opt)
// access: atf_amc.FOptG.optg (Base)
#pragma pack(push,1)
struct OptG { // atf_amc.OptG: An optional instance of atf_unit.A
    u32                    length;    //   0
    // atf_amc::TypeG      typeg[];                optional field
    OptG();
};
#pragma pack(pop)

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
atf_amc::TypeG*      typeg_Get(atf_amc::OptG& optg) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
algo::aryptr<u8>     typeg_Getary(atf_amc::OptG& optg) __attribute__((nothrow));
void                 typeg_Print(atf_amc::OptG& optg, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 typeg_ReadStrptrMaybe(atf_amc::OptG &parent, algo::strptr in_str) __attribute__((nothrow));

bool                 OptG_ReadFieldMaybe(atf_amc::OptG &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf
// Read fields of atf_amc::OptG from an ascii string.
// The format of the string is an ssim Tuple
bool                 OptG_ReadStrptrMaybe(atf_amc::OptG &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::OptG& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::OptG& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 OptG_Init(atf_amc::OptG& optg);
// print string representation of atf_amc::OptG to string LHS, no header -- cprint:atf_amc.OptG.String
void                 OptG_Print(atf_amc::OptG & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.OptOptG
#pragma pack(push,1)
struct OptOptG { // atf_amc.OptOptG: An optional instance of atf_unit.Optg (recursive)
    u32                   length;   //   0
    // atf_amc::OptG      optg[];                optional field
    OptOptG();
};
#pragma pack(pop)

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized optg, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If optg's length field value is too short, return NULL.
// If optg's length field value extends past parent's allowed length, return NULL.
atf_amc::OptG*       optg_Get(atf_amc::OptOptG& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
algo::aryptr<u8>     optg_Getary(atf_amc::OptOptG& parent) __attribute__((nothrow));
void                 optg_Print(atf_amc::OptOptG& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 optg_ReadStrptrMaybe(atf_amc::OptOptG &parent, algo::strptr in_str) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 optg_XrefMaybe(atf_amc::OptG &row);

bool                 OptOptG_ReadFieldMaybe(atf_amc::OptOptG &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf
// Read fields of atf_amc::OptOptG from an ascii string.
// The format of the string is an ssim Tuple
bool                 OptOptG_ReadStrptrMaybe(atf_amc::OptOptG &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::OptOptG& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::OptOptG& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 OptOptG_Init(atf_amc::OptOptG& parent);
// print string representation of atf_amc::OptOptG to string LHS, no header -- cprint:atf_amc.OptOptG.String
void                 OptOptG_Print(atf_amc::OptOptG & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.PmaskU128
#pragma pack(push,1)
struct PmaskU128 { // atf_amc.PmaskU128: A field controlled by a bitmask.
    u128   pmask;     //   0
    u32    value;     //   0
    u32    value2;    //   0
    u32    value3;    //   0
    u32    value21;   //   0
    u32    value22;   //   0
    u32    value23;   //   0
    u32    value24;   //   0
    u32    value25;   //   0
    u32    value26;   //   0
    u32    value20;   //   0
    u32    value28;   //   0
    u32    value29;   //   0
    u32    value30;   //   0
    u32    value31;   //   0
    u32    value32;   //   0
    u32    value27;   //   0
    u32    value19;   //   0
    u32    value18;   //   0
    u32    value4;    //   0
    u32    value5;    //   0
    u32    value6;    //   0
    u32    value7;    //   0
    u32    value8;    //   0
    u32    value9;    //   0
    u32    value69;   //   0
    u32    value11;   //   0
    u32    value12;   //   0
    u32    value13;   //   0
    u32    value14;   //   0
    u32    value15;   //   0
    u32    value16;   //   0
    u32    value33;   //   0
    u32    value10;   //   0
    u32    value17;   //   0
    u32    value35;   //   0
    u32    value55;   //   0
    u32    value56;   //   0
    u32    value57;   //   0
    u32    value58;   //   0
    u32    value59;   //   0
    u32    value60;   //   0
    u32    value54;   //   0
    u32    value62;   //   0
    u32    value63;   //   0
    u32    value64;   //   0
    u32    value65;   //   0
    u32    value66;   //   0
    u32    value67;   //   0
    u32    value68;   //   0
    u32    value61;   //   0
    u32    value34;   //   0
    u32    value52;   //   0
    u32    value36;   //   0
    u32    value37;   //   0
    u32    value38;   //   0
    u32    value39;   //   0
    u32    value40;   //   0
    u32    value41;   //   0
    u32    value42;   //   0
    u32    value53;   //   0
    u32    value44;   //   0
    u32    value45;   //   0
    u32    value46;   //   0
    u32    value47;   //   0
    u32    value48;   //   0
    u32    value49;   //   0
    u32    value50;   //   0
    u32    value51;   //   0
    u32    value43;   //   0
    u32    value70;   //   0
    u32    value71;   //   0
    PmaskU128();
};
#pragma pack(pop)

// Return constant 1
int                  pmask_N(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
u128&                pmask_qFind(atf_amc::PmaskU128& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  pmask_Nbits(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 pmask_qGetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 pmask_GetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 pmask_BitsEmptyQ(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  pmask_Sum1s(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qClearBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 pmask_ClearBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 pmask_SetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBitVal(atf_amc::PmaskU128& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qOrBitVal(atf_amc::PmaskU128& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 pmask_ClearBitsAll(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 pmask_ClearBits(atf_amc::PmaskU128& parent, atf_amc::PmaskU128 &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 pmask_OrBits(atf_amc::PmaskU128& parent, atf_amc::PmaskU128 &rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value2_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value2_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value2_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value3_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value3_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value3_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value21_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value21_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value21_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value22_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value22_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value22_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value23_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value23_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value23_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value24_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value24_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value24_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value25_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value25_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value25_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value26_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value26_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value26_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value20_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value20_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value20_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value28_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value28_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value28_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value29_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value29_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value29_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value30_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value30_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value30_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value31_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value31_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value31_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value32_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value32_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value32_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value27_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value27_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value27_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value19_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value19_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value19_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value18_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value18_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value18_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value4_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value4_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value4_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value5_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value5_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value5_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value6_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value6_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value6_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value7_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value7_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value7_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value8_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value8_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value8_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value9_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value9_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value9_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value69_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value69_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value69_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value11_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value11_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value11_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value12_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value12_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value12_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value13_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value13_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value13_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value14_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value14_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value14_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value15_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value15_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value15_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value16_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value16_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value16_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value33_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value33_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value33_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value10_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value10_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value10_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value17_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value17_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value17_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value35_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value35_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value35_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value55_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value55_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value55_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value56_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value56_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value56_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value57_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value57_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value57_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value58_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value58_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value58_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value59_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value59_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value59_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value60_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value60_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value60_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value54_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value54_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value54_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value62_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value62_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value62_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value63_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value63_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value63_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value64_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value64_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value64_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value65_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value65_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value65_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value66_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value66_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value66_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value67_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value67_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value67_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value68_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value68_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value68_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value61_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value61_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value61_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value34_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value34_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value34_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value52_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value52_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value52_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value36_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value36_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value36_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value37_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value37_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value37_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value38_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value38_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value38_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value39_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value39_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value39_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value40_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value40_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value40_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value41_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value41_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value41_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value42_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value42_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value42_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value53_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value53_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value53_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value44_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value44_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value44_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value45_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value45_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value45_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value46_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value46_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value46_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value47_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value47_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value47_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value48_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value48_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value48_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value49_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value49_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value49_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value50_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value50_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value50_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value51_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value51_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value51_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value43_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value43_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value43_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value70_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value70_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value70_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value71_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value71_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
void                 value71_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

bool                 PmaskU128_ReadFieldMaybe(atf_amc::PmaskU128 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PmaskU128 from an ascii string.
// The format of the string is an ssim Tuple
bool                 PmaskU128_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 PmaskU128_Init(atf_amc::PmaskU128& parent);
// print string representation of atf_amc::PmaskU128 to string LHS, no header -- cprint:atf_amc.PmaskU128.String
void                 PmaskU128_Print(atf_amc::PmaskU128 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.PmaskU32
#pragma pack(push,1)
struct PmaskU32 { // atf_amc.PmaskU32: A field controlled by a bitmask.
    u32   pmask;    //   0
    u32   value;    //   0
    u32   value2;   //   0
    u32   value3;   //   0
    u32   value4;   //   0
    u32   value5;   //   0
    PmaskU32();
};
#pragma pack(pop)

// Return constant 1
int                  pmask_N(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
u32&                 pmask_qFind(atf_amc::PmaskU32& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  pmask_Nbits(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 pmask_qGetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 pmask_GetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 pmask_BitsEmptyQ(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  pmask_Sum1s(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qClearBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 pmask_ClearBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 pmask_SetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBitVal(atf_amc::PmaskU32& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qOrBitVal(atf_amc::PmaskU32& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 pmask_ClearBitsAll(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 pmask_ClearBits(atf_amc::PmaskU32& parent, atf_amc::PmaskU32 &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 pmask_OrBits(atf_amc::PmaskU32& parent, atf_amc::PmaskU32 &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  pmask_Sup(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));

// Return true if the field is marked in the presence mask
bool                 value_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value2_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value2_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value2_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value3_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value3_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value3_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value4_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value4_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value4_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
bool                 value5_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value5_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
void                 value5_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

bool                 PmaskU32_ReadFieldMaybe(atf_amc::PmaskU32 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PmaskU32 from an ascii string.
// The format of the string is an ssim Tuple
bool                 PmaskU32_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 PmaskU32_Init(atf_amc::PmaskU32& parent);
// print string representation of atf_amc::PmaskU32 to string LHS, no header -- cprint:atf_amc.PmaskU32.String
void                 PmaskU32_Print(atf_amc::PmaskU32 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.PmaskU555
#pragma pack(push,1)
struct PmaskU555 { // atf_amc.PmaskU555: Check pmask with 555 bits
    u32   value;             //   0
    u64   pmask_elems[10];   //   0  fixed array
    PmaskU555();
};
#pragma pack(pop)

// Return true if the field is marked in the presence mask
bool                 value_PresentQ(atf_amc::PmaskU555& parent) __attribute__((nothrow));
void                 value_SetPresent(atf_amc::PmaskU555& parent) __attribute__((nothrow));
void                 value_Set(atf_amc::PmaskU555& parent, u32 rhs) __attribute__((nothrow));

// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  pmask_Nbits(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 pmask_qGetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 pmask_GetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 pmask_BitsEmptyQ(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  pmask_Sum1s(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qClearBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 pmask_ClearBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 pmask_SetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qSetBitVal(atf_amc::PmaskU555& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 pmask_qOrBitVal(atf_amc::PmaskU555& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 pmask_ClearBitsAll(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 pmask_ClearBits(atf_amc::PmaskU555& parent, atf_amc::PmaskU555 &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 pmask_OrBits(atf_amc::PmaskU555& parent, atf_amc::PmaskU555 &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  pmask_Sup(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
void                 pmask_Fill(atf_amc::PmaskU555& parent, const u64 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u64*                 pmask_Find(atf_amc::PmaskU555& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array pmask as aryptr.
algo::aryptr<u64>    pmask_Getary(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  pmask_Max(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  pmask_N(const atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 pmask_Setary(atf_amc::PmaskU555& parent, const algo::aryptr<u64> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u64&                 pmask_qFind(atf_amc::PmaskU555& parent, u64 t) __attribute__((nothrow));

// cursor points to valid item
void                 PmaskU555_pmask_curs_Reset(PmaskU555_pmask_curs &curs, atf_amc::PmaskU555 &parent);
// cursor points to valid item
bool                 PmaskU555_pmask_curs_ValidQ(PmaskU555_pmask_curs &curs);
// proceed to next item
void                 PmaskU555_pmask_curs_Next(PmaskU555_pmask_curs &curs);
// item access
u64&                 PmaskU555_pmask_curs_Access(PmaskU555_pmask_curs &curs);
// Set all fields to initial values.
void                 PmaskU555_Init(atf_amc::PmaskU555& parent);

// --- atf_amc.PooledBE64
// create: atf_amc.FDb.pooledbe64 (Tpool)
struct PooledBE64 { // atf_amc.PooledBE64
    atf_amc::PooledBE64*   pooledbe64_next;   // Pointer to next free element int tpool
    u64                    value_be;          //   0
private:
    friend atf_amc::PooledBE64& pooledbe64_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::PooledBE64* pooledbe64_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pooledbe64_Delete(atf_amc::PooledBE64 &row) __attribute__((nothrow));
    PooledBE64();
};

u64                  value_Get(const atf_amc::PooledBE64& pooledbe64) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::PooledBE64& pooledbe64, u64 rhs) __attribute__((nothrow));
// Get value of field as enum type
atf_amc_PooledBE64_value_Enum value_GetEnum(const atf_amc::PooledBE64& pooledbe64) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::PooledBE64& pooledbe64, atf_amc_PooledBE64_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::PooledBE64& pooledbe64) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::PooledBE64& pooledbe64, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs, atf_amc_PooledBE64_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 PooledBE64_Init(atf_amc::PooledBE64& pooledbe64);
bool                 PooledBE64_ReadFieldMaybe(atf_amc::PooledBE64 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PooledBE64 from an ascii string.
// The format of the string is an ssim Tuple
bool                 PooledBE64_ReadStrptrMaybe(atf_amc::PooledBE64 &parent, algo::strptr in_str);
// print string representation of atf_amc::PooledBE64 to string LHS, no header -- cprint:atf_amc.PooledBE64.String
void                 PooledBE64_Print(atf_amc::PooledBE64 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.RnullStr6_U32
struct RnullStr6_U32 { // atf_amc.RnullStr6_U32: number stored as ascii digits, right pad with NUL
    enum { ch_max = 6 };
    u8 ch[6];
    bool operator ==(const atf_amc::RnullStr6_U32 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const atf_amc::RnullStr6_U32 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const atf_amc::RnullStr6_U32& parent) __attribute__((nothrow));
    RnullStr6_U32(const atf_amc::RnullStr6_U32 &rhs) __attribute__((nothrow));
    RnullStr6_U32(const algo::strptr &rhs) __attribute__((nothrow));
    RnullStr6_U32();
};

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const atf_amc::RnullStr6_U32& parent) __attribute__((nothrow));
u32                  RnullStr6_U32_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(atf_amc::RnullStr6_U32 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(atf_amc::RnullStr6_U32& parent) __attribute__((nothrow));
int                  ch_N(const atf_amc::RnullStr6_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(atf_amc::RnullStr6_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(atf_amc::RnullStr6_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(atf_amc::RnullStr6_U32& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(atf_amc::RnullStr6_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(atf_amc::RnullStr6_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(atf_amc::RnullStr6_U32& parent, i64 rhs) __attribute__((nothrow));

u32                  RnullStr6_U32_Hash(u32 prev, const atf_amc::RnullStr6_U32 & rhs) __attribute__((nothrow));
// Read fields of atf_amc::RnullStr6_U32 from an ascii string.
// The format of the string is the format of the atf_amc::RnullStr6_U32's only field
bool                 RnullStr6_U32_ReadStrptrMaybe(atf_amc::RnullStr6_U32 &parent, algo::strptr in_str);
bool                 RnullStr6_U32_Lt(atf_amc::RnullStr6_U32 & lhs, atf_amc::RnullStr6_U32 & rhs) __attribute__((nothrow));
i32                  RnullStr6_U32_Cmp(atf_amc::RnullStr6_U32 & lhs, atf_amc::RnullStr6_U32 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RnullStr6_U32_Init(atf_amc::RnullStr6_U32& parent);
bool                 RnullStr6_U32_Eq(const atf_amc::RnullStr6_U32 & lhs,const atf_amc::RnullStr6_U32 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RnullStr6_U32_Update(atf_amc::RnullStr6_U32 &lhs, atf_amc::RnullStr6_U32 & rhs) __attribute__((nothrow));
bool                 RnullStr6_U32_EqStrptr(atf_amc::RnullStr6_U32 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of atf_amc::RnullStr6_U32 to string LHS, no header -- cprint:atf_amc.RnullStr6_U32.String
void                 RnullStr6_U32_Print(atf_amc::RnullStr6_U32 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.RpasU32Str6
struct RpasU32Str6 { // atf_amc.RpasU32Str6: number stored as ascii digits, right pad with NUL
    enum { ch_max = 6 };
    u8 ch[6+1];
    u8 n_ch;

    bool operator ==(const atf_amc::RpasU32Str6 &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    bool operator <(const atf_amc::RpasU32Str6 &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const atf_amc::RpasU32Str6& parent) __attribute__((nothrow));
    RpasU32Str6(const atf_amc::RpasU32Str6 &rhs) __attribute__((nothrow));
    RpasU32Str6(const algo::strptr &rhs) __attribute__((nothrow));
    RpasU32Str6();
};

// Append character to string.
// If there is no space for an extra character, do nothing.
void                 ch_Add(atf_amc::RpasU32Str6& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
void                 ch_AddStrptr(atf_amc::RpasU32Str6& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
algo::aryptr<char>   ch_Getary(const atf_amc::RpasU32Str6& parent) __attribute__((nothrow));
u32                  RpasU32Str6_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(atf_amc::RpasU32Str6 &parent) __attribute__((nothrow));
// always return constant 6
int                  ch_Max(atf_amc::RpasU32Str6& parent) __attribute__((nothrow));
int                  ch_N(const atf_amc::RpasU32Str6& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(atf_amc::RpasU32Str6& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(atf_amc::RpasU32Str6& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(atf_amc::RpasU32Str6& parent, const algo::strptr &rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
u32                  ch_GetnumDflt(atf_amc::RpasU32Str6& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
i64                  ch_Geti64(atf_amc::RpasU32Str6& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
bool                 ch_SetnumMaybe(atf_amc::RpasU32Str6& parent, i64 rhs) __attribute__((nothrow));

u32                  RpasU32Str6_Hash(u32 prev, const atf_amc::RpasU32Str6 & rhs) __attribute__((nothrow));
// Read fields of atf_amc::RpasU32Str6 from an ascii string.
// The format of the string is the format of the atf_amc::RpasU32Str6's only field
bool                 RpasU32Str6_ReadStrptrMaybe(atf_amc::RpasU32Str6 &parent, algo::strptr in_str);
bool                 RpasU32Str6_Lt(atf_amc::RpasU32Str6 & lhs, atf_amc::RpasU32Str6 & rhs) __attribute__((nothrow));
i32                  RpasU32Str6_Cmp(atf_amc::RpasU32Str6 & lhs, atf_amc::RpasU32Str6 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RpasU32Str6_Init(atf_amc::RpasU32Str6& parent);
bool                 RpasU32Str6_Eq(const atf_amc::RpasU32Str6 & lhs,const atf_amc::RpasU32Str6 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RpasU32Str6_Update(atf_amc::RpasU32Str6 &lhs, atf_amc::RpasU32Str6 & rhs) __attribute__((nothrow));
bool                 RpasU32Str6_EqStrptr(atf_amc::RpasU32Str6 & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of atf_amc::RpasU32Str6 to string LHS, no header -- cprint:atf_amc.RpasU32Str6.String
void                 RpasU32Str6_Print(atf_amc::RpasU32Str6 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Sep1
struct Sep1 { // atf_amc.Sep1: Check printing/reading of types with separators
    u32   val1;   //   0
    u32   val2;   //   0
    u32   val3;   //   0
    explicit Sep1(u32                            in_val1
        ,u32                            in_val2
        ,u32                            in_val3);
    bool operator ==(const atf_amc::Sep1 &rhs) const;
    bool operator <(const atf_amc::Sep1 &rhs) const;
    Sep1();
};

u32                  Sep1_Hash(u32 prev, const atf_amc::Sep1 & rhs) __attribute__((nothrow));
bool                 Sep1_ReadFieldMaybe(atf_amc::Sep1 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Sep1 from an ascii string.
// The format of the string is a string with separated values
bool                 Sep1_ReadStrptrMaybe(atf_amc::Sep1 &parent, algo::strptr in_str);
bool                 Sep1_Lt(atf_amc::Sep1 & lhs, atf_amc::Sep1 & rhs) __attribute__((nothrow));
i32                  Sep1_Cmp(atf_amc::Sep1 & lhs, atf_amc::Sep1 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Sep1_Init(atf_amc::Sep1& parent);
bool                 Sep1_Eq(const atf_amc::Sep1 & lhs,const atf_amc::Sep1 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Sep1_Update(atf_amc::Sep1 &lhs, atf_amc::Sep1 & rhs) __attribute__((nothrow));
// print string representation of atf_amc::Sep1 to string LHS, no header -- cprint:atf_amc.Sep1.String
void                 Sep1_Print(atf_amc::Sep1 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Seqmsg
#pragma pack(push,1)
struct Seqmsg { // atf_amc.Seqmsg: Sequenced message for stream
    atf_amc::MsgType           type;        //   0x0905  Message type
    atf_amc::MsgLength         length;      //   sizeof(parent) + (0)  Total message length, including this header
    // atf_amc::MsgHeader      payload[];                                                                              optional field
    Seqmsg();
};
#pragma pack(pop)

// Check if atf_amc::MsgHeader is an instance of Seqmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Seqmsg.
// If not successful, quietly return NULL.
atf_amc::Seqmsg*     Seqmsg_Castdown(atf_amc::MsgHeader &hdr);
atf_amc::MsgHeader&  Castbase(atf_amc::Seqmsg& parent);

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
atf_amc::MsgHeader*  payload_Get(atf_amc::Seqmsg& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
algo::aryptr<u8>     payload_Getary(atf_amc::Seqmsg& parent) __attribute__((nothrow));
void                 payload_Print(atf_amc::Seqmsg& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 payload_ReadStrptrMaybe(atf_amc::Seqmsg &parent, algo::strptr in_str) __attribute__((nothrow));

bool                 Seqmsg_ReadFieldMaybe(atf_amc::Seqmsg &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf
// Read fields of atf_amc::Seqmsg from an ascii string.
// The format of the string is an ssim Tuple
bool                 Seqmsg_ReadStrptrMaybe(atf_amc::Seqmsg &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::Seqmsg& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::Seqmsg& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 Seqmsg_Init(atf_amc::Seqmsg& parent);
// print string representation of atf_amc::Seqmsg to string LHS, no header -- cprint:atf_amc.Seqmsg.String
void                 Seqmsg_Print(atf_amc::Seqmsg & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.SortedStr
struct SortedStr { // atf_amc.SortedStr
    algo::cstring   novs;   //
    algo::cstring   vs;     //
    explicit SortedStr(const algo::strptr&            in_novs
        ,const algo::strptr&            in_vs);
    bool operator ==(const atf_amc::SortedStr &rhs) const;
    bool operator <(const atf_amc::SortedStr &rhs) const;
    SortedStr();
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 novs_Lt(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));
// Compare two fields.
i32                  novs_Cmp(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 vs_Lt(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));
// Compare two fields.
// Comparison uses version sort (detect embedded integers).
// Comparison is case-insensitive.
i32                  vs_Cmp(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));

bool                 SortedStr_Lt(atf_amc::SortedStr & lhs, atf_amc::SortedStr & rhs) __attribute__((nothrow));
i32                  SortedStr_Cmp(atf_amc::SortedStr & lhs, atf_amc::SortedStr & rhs) __attribute__((nothrow));
bool                 SortedStr_Eq(const atf_amc::SortedStr & lhs,const atf_amc::SortedStr & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 SortedStr_Update(atf_amc::SortedStr &lhs, atf_amc::SortedStr & rhs) __attribute__((nothrow));

// --- atf_amc.SsimfilesCase
#pragma pack(push,1)
struct SsimfilesCase { // atf_amc.SsimfilesCase: Enum for dispatch atf_amc.Ssimfiles
    u32   value;   //   0
    inline operator atf_amc_SsimfilesCaseEnum() const;
    explicit SsimfilesCase(u32                            in_value);
    SsimfilesCase(atf_amc_SsimfilesCaseEnum arg);
    SsimfilesCase();
};
#pragma pack(pop)

// Get value of field as enum type
atf_amc_SsimfilesCaseEnum value_GetEnum(const atf_amc::SsimfilesCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::SsimfilesCase& parent, atf_amc_SsimfilesCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::SsimfilesCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::SsimfilesCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::SsimfilesCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::SsimfilesCase& parent, algo::strptr rhs, atf_amc_SsimfilesCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::SsimfilesCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::SsimfilesCase from an ascii string.
// The format of the string is the format of the atf_amc::SsimfilesCase's only field
bool                 SsimfilesCase_ReadStrptrMaybe(atf_amc::SsimfilesCase &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 SsimfilesCase_Init(atf_amc::SsimfilesCase& parent);

// --- atf_amc.TableId
struct TableId { // atf_amc.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator atf_amc_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(atf_amc_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
atf_amc_TableIdEnum  value_GetEnum(const atf_amc::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::TableId& parent, atf_amc_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::TableId& parent, algo::strptr rhs, atf_amc_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::TableId from an ascii string.
// The format of the string is the format of the atf_amc::TableId's only field
bool                 TableId_ReadStrptrMaybe(atf_amc::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(atf_amc::TableId& parent);
// print string representation of atf_amc::TableId to string LHS, no header -- cprint:atf_amc.TableId.String
void                 TableId_Print(atf_amc::TableId & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TaryU32
struct TaryU32 { // atf_amc.TaryU32
    u32*   tary_u32_elems;   // pointer to elements
    u32    tary_u32_n;       // number of elements in array
    u32    tary_u32_max;     // max. capacity of array before realloc
    TaryU32();
    ~TaryU32();
private:
    // reftype of atf_amc.TaryU32.tary_u32 prohibits copy
    TaryU32(const TaryU32&){ /*disallow copy constructor */}
    void operator =(const TaryU32&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
u32&                 tary_u32_Alloc(atf_amc::TaryU32& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u32&                 tary_u32_AllocAt(atf_amc::TaryU32& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u32>    tary_u32_AllocN(atf_amc::TaryU32& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tary_u32_EmptyQ(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u32*                 tary_u32_Find(atf_amc::TaryU32& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<u32>    tary_u32_Getary(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
u32*                 tary_u32_Last(atf_amc::TaryU32& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  tary_u32_Max(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  tary_u32_N(const atf_amc::TaryU32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 tary_u32_Remove(atf_amc::TaryU32& parent, u32 i) __attribute__((nothrow));
void                 tary_u32_RemoveAll(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tary_u32_RemoveLast(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 tary_u32_Reserve(atf_amc::TaryU32& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 tary_u32_AbsReserve(atf_amc::TaryU32& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 tary_u32_Setary(atf_amc::TaryU32& parent, atf_amc::TaryU32 &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
u32&                 tary_u32_qFind(atf_amc::TaryU32& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
u32&                 tary_u32_qLast(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  tary_u32_rowid_Get(atf_amc::TaryU32& parent, u32 &elem) __attribute__((nothrow));

// proceed to next item
void                 TaryU32_tary_u32_curs_Next(TaryU32_tary_u32_curs &curs);
void                 TaryU32_tary_u32_curs_Reset(TaryU32_tary_u32_curs &curs, atf_amc::TaryU32 &parent);
// cursor points to valid item
bool                 TaryU32_tary_u32_curs_ValidQ(TaryU32_tary_u32_curs &curs);
// item access
u32&                 TaryU32_tary_u32_curs_Access(TaryU32_tary_u32_curs &curs);
// Set all fields to initial values.
void                 TaryU32_Init(atf_amc::TaryU32& parent);
void                 TaryU32_Uninit(atf_amc::TaryU32& parent) __attribute__((nothrow));

// --- atf_amc.TaryU8
struct TaryU8 { // atf_amc.TaryU8
    u8*   ary_elems;   // pointer to elements
    u32   ary_n;       // number of elements in array
    u32   ary_max;     // max. capacity of array before realloc
    TaryU8();
    ~TaryU8();
private:
    // reftype of atf_amc.TaryU8.ary prohibits copy
    TaryU8(const TaryU8&){ /*disallow copy constructor */}
    void operator =(const TaryU8&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
u8&                  ary_Alloc(atf_amc::TaryU8& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
u8&                  ary_AllocAt(atf_amc::TaryU8& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<u8>     ary_AllocN(atf_amc::TaryU8& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ary_EmptyQ(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u8*                  ary_Find(atf_amc::TaryU8& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<u8>     ary_Getary(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
u8*                  ary_Last(atf_amc::TaryU8& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  ary_Max(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  ary_N(const atf_amc::TaryU8& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 ary_Remove(atf_amc::TaryU8& parent, u32 i) __attribute__((nothrow));
void                 ary_RemoveAll(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ary_RemoveLast(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 ary_Reserve(atf_amc::TaryU8& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 ary_AbsReserve(atf_amc::TaryU8& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 ary_Setary(atf_amc::TaryU8& parent, atf_amc::TaryU8 &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
u8&                  ary_qFind(atf_amc::TaryU8& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
u8&                  ary_qLast(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  ary_rowid_Get(atf_amc::TaryU8& parent, u8 &elem) __attribute__((nothrow));

// proceed to next item
void                 TaryU8_ary_curs_Next(TaryU8_ary_curs &curs);
void                 TaryU8_ary_curs_Reset(TaryU8_ary_curs &curs, atf_amc::TaryU8 &parent);
// cursor points to valid item
bool                 TaryU8_ary_curs_ValidQ(TaryU8_ary_curs &curs);
// item access
u8&                  TaryU8_ary_curs_Access(TaryU8_ary_curs &curs);
// Set all fields to initial values.
void                 TaryU8_Init(atf_amc::TaryU8& parent);
void                 TaryU8_Uninit(atf_amc::TaryU8& parent) __attribute__((nothrow));

// --- atf_amc.TestRegx1
struct TestRegx1 { // atf_amc.TestRegx1: Test automatic reading of Regx
    algo_lib::Regx   val;   // Regx of dev::Target
    TestRegx1();
};

// Print back to string
void                 val_Print(atf_amc::TestRegx1& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 val_ReadStrptrMaybe(atf_amc::TestRegx1& parent, algo::strptr in) __attribute__((nothrow));

bool                 TestRegx1_ReadFieldMaybe(atf_amc::TestRegx1 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TestRegx1 from an ascii string.
// The format of the string is an ssim Tuple
bool                 TestRegx1_ReadStrptrMaybe(atf_amc::TestRegx1 &parent, algo::strptr in_str);
// print string representation of atf_amc::TestRegx1 to string LHS, no header -- cprint:atf_amc.TestRegx1.String
void                 TestRegx1_Print(atf_amc::TestRegx1 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TestType
struct TestType { // atf_amc.TestType
    TestType();
};

// Read fields of atf_amc::TestType from an ascii string.
bool                 TestType_ReadStrptrMaybe(atf_amc::TestType &parent, algo::strptr in_str);
// print string representation of atf_amc::TestType to string LHS, no header -- cprint:atf_amc.TestType.String
void                 TestType_Print(atf_amc::TestType & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Text
#pragma pack(push,1)
struct Text { // atf_amc.Text
    atf_amc::MsgType     type;     //   0x0412  Message type
    atf_amc::MsgLength   length;   //   sizeof(parent) + (0)  Total message length, including this header
    // var-length field atf_amc.Text.text starts here. access it with text_Addr
    Text();
};
#pragma pack(pop)

// Check if atf_amc::MsgHeader is an instance of Text by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Text.
// If not successful, quietly return NULL.
atf_amc::Text*       Text_Castdown(atf_amc::MsgHeader &hdr);
atf_amc::MsgHeader&  Castbase(atf_amc::Text& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<char>   text_Getary(atf_amc::Text& parent) __attribute__((nothrow));
char*                text_Addr(atf_amc::Text& parent);
// Return number of elements in varlen field
u32                  text_N(const atf_amc::Text& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
bool                 text_ReadStrptrMaybe(atf_amc::Text& parent, algo::strptr in_str) __attribute__((nothrow));

void                 Text_text_curs_Reset(Text_text_curs &curs, atf_amc::Text &parent);
// cursor points to valid item
bool                 Text_text_curs_ValidQ(Text_text_curs &curs);
// proceed to next item
void                 Text_text_curs_Next(Text_text_curs &curs);
// item access
char&                Text_text_curs_Access(Text_text_curs &curs);
bool                 Text_ReadFieldMaybe(atf_amc::Text &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf
// Read fields of atf_amc::Text from an ascii string.
// The format of the string is an ssim Tuple
bool                 Text_ReadStrptrMaybe(atf_amc::Text &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::Text& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::Text& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 Text_Init(atf_amc::Text& parent);
// print string representation of atf_amc::Text to string LHS, no header -- cprint:atf_amc.Text.String
void                 Text_Print(atf_amc::Text & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeB
// access: atf_amc.FTypeB.msghdr (Base)
struct TypeB { // atf_amc.TypeB
    i32   typea;   //   0
    i32   j;       //   0
    bool operator ==(const atf_amc::TypeB &rhs) const;
    bool operator <(const atf_amc::TypeB &rhs) const;
    TypeB();
};

u32                  TypeB_Hash(u32 prev, const atf_amc::TypeB & rhs) __attribute__((nothrow));
bool                 TypeB_ReadFieldMaybe(atf_amc::TypeB &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeB from an ascii string.
// The format of the string is an ssim Tuple
bool                 TypeB_ReadStrptrMaybe(atf_amc::TypeB &parent, algo::strptr in_str);
bool                 TypeB_Lt(atf_amc::TypeB & lhs, atf_amc::TypeB & rhs) __attribute__((nothrow));
i32                  TypeB_Cmp(atf_amc::TypeB & lhs, atf_amc::TypeB & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeB_Init(atf_amc::TypeB& parent);
bool                 TypeB_Eq(const atf_amc::TypeB & lhs,const atf_amc::TypeB & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeB_Update(atf_amc::TypeB &lhs, atf_amc::TypeB & rhs) __attribute__((nothrow));
// print string representation of atf_amc::TypeB to string LHS, no header -- cprint:atf_amc.TypeB.String
void                 TypeB_Print(atf_amc::TypeB & row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of atf_amc::TypeB under PARENT node -- cprint:atf_amc.TypeB.Json
lib_json::FNode *    TypeB_FmtJson(atf_amc::TypeB & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_amc.TypeBE16
struct TypeBE16 { // atf_amc.TypeBE16
    u16   value_be;   //   0
    TypeBE16();
};

u16                  value_Get(const atf_amc::TypeBE16& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::TypeBE16& parent, u16 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 TypeBE16_Init(atf_amc::TypeBE16& parent);

// --- atf_amc.TypeBE32
struct TypeBE32 { // atf_amc.TypeBE32
    u32   value_be;   //   0
    TypeBE32();
};

u32                  value_Get(const atf_amc::TypeBE32& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::TypeBE32& parent, u32 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 TypeBE32_Init(atf_amc::TypeBE32& parent);

// --- atf_amc.TypeBE64
struct TypeBE64 { // atf_amc.TypeBE64
    u64   value_be;   //   0
    inline operator u64() const;
    explicit TypeBE64(u64                            in_value);
    bool operator ==(const atf_amc::TypeBE64 &rhs) const;
    bool operator <(const atf_amc::TypeBE64 &rhs) const;
    TypeBE64();
};

u64                  value_Get(const atf_amc::TypeBE64& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::TypeBE64& parent, u64 rhs) __attribute__((nothrow));

u32                  TypeBE64_Hash(u32 prev, const atf_amc::TypeBE64 & rhs) __attribute__((nothrow));
bool                 TypeBE64_ReadFieldMaybe(atf_amc::TypeBE64 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeBE64 from an ascii string.
// The format of the string is the format of the atf_amc::TypeBE64's only field
bool                 TypeBE64_ReadStrptrMaybe(atf_amc::TypeBE64 &parent, algo::strptr in_str);
// Read fields of atf_amc::TypeBE64 from attributes of ascii tuple TUPLE
bool                 TypeBE64_ReadTupleMaybe(atf_amc::TypeBE64 &parent, algo::Tuple &tuple) __attribute__((nothrow));
bool                 TypeBE64_Lt(atf_amc::TypeBE64 & lhs, atf_amc::TypeBE64 & rhs) __attribute__((nothrow));
i32                  TypeBE64_Cmp(atf_amc::TypeBE64 & lhs, atf_amc::TypeBE64 & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeBE64_Init(atf_amc::TypeBE64& parent);
bool                 TypeBE64_Eq(const atf_amc::TypeBE64 & lhs,const atf_amc::TypeBE64 & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeBE64_Update(atf_amc::TypeBE64 &lhs, atf_amc::TypeBE64 & rhs) __attribute__((nothrow));
// print string representation of atf_amc::TypeBE64 to string LHS, no header -- cprint:atf_amc.TypeBE64.String
void                 TypeBE64_Print(atf_amc::TypeBE64 & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeBE64dflt
struct TypeBE64dflt { // atf_amc.TypeBE64dflt
    u64   value_be;   //   0xfedcba9876543210
    inline operator u64() const;
    explicit TypeBE64dflt(u64                            in_value);
    TypeBE64dflt();
};

u64                  value_Get(const atf_amc::TypeBE64dflt& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::TypeBE64dflt& parent, u64 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 TypeBE64dflt_Init(atf_amc::TypeBE64dflt& parent);

// --- atf_amc.TypeBE64en
struct TypeBE64en { // atf_amc.TypeBE64en
    u64   value_be;   //   0
    inline operator atf_amc_TypeBE64en_value_Enum() const;
    explicit TypeBE64en(u64                            in_value);
    TypeBE64en(atf_amc_TypeBE64en_value_Enum arg);
    TypeBE64en();
};

u64                  value_Get(const atf_amc::TypeBE64en& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::TypeBE64en& parent, u64 rhs) __attribute__((nothrow));
// Get value of field as enum type
atf_amc_TypeBE64en_value_Enum value_GetEnum(const atf_amc::TypeBE64en& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::TypeBE64en& parent, atf_amc_TypeBE64en_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::TypeBE64en& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::TypeBE64en& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::TypeBE64en& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::TypeBE64en& parent, algo::strptr rhs, atf_amc_TypeBE64en_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::TypeBE64en& parent, algo::strptr rhs) __attribute__((nothrow));

u32                  TypeBE64en_Hash(u32 prev, const atf_amc::TypeBE64en & rhs) __attribute__((nothrow));
bool                 TypeBE64en_ReadFieldMaybe(atf_amc::TypeBE64en &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeBE64en from an ascii string.
// The format of the string is the format of the atf_amc::TypeBE64en's only field
bool                 TypeBE64en_ReadStrptrMaybe(atf_amc::TypeBE64en &parent, algo::strptr in_str);
// Read fields of atf_amc::TypeBE64en from attributes of ascii tuple TUPLE
bool                 TypeBE64en_ReadTupleMaybe(atf_amc::TypeBE64en &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeBE64en_Init(atf_amc::TypeBE64en& parent);
// print string representation of atf_amc::TypeBE64en to string LHS, no header -- cprint:atf_amc.TypeBE64en.String
void                 TypeBE64en_Print(atf_amc::TypeBE64en & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeBE64sf
struct TypeBE64sf { // atf_amc.TypeBE64sf
    u64   value_be;   //   0
    TypeBE64sf();
};

u64                  value_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
void                 value_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 63.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bit63_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 63.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bit63_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    2 bits starting at bit 61.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits62_61_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    2 bits starting at bit 61.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits62_61_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    3 bits starting at bit 58.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits60_58_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    3 bits starting at bit 58.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits60_58_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    5 bits starting at bit 53.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits57_53_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    5 bits starting at bit 53.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits57_53_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    8 bits starting at bit 45.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits52_45_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    8 bits starting at bit 45.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits52_45_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    13 bits starting at bit 32.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits44_32_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    13 bits starting at bit 32.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits44_32_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    21 bits starting at bit 11.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits31_11_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    21 bits starting at bit 11.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits31_11_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    11 bits starting at bit 0.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
u64                  bits10_0_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    11 bits starting at bit 0.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
void                 bits10_0_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 TypeBE64sf_Init(atf_amc::TypeBE64sf& parent);

// --- atf_amc.TypeC
// access: atf_amc.FTypeC.msghdr (Base)
struct TypeC { // atf_amc.TypeC
    i32   typec;   //   0
    bool operator ==(const atf_amc::TypeC &rhs) const;
    bool operator <(const atf_amc::TypeC &rhs) const;
    TypeC();
};

u32                  TypeC_Hash(u32 prev, const atf_amc::TypeC & rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeC from an ascii string.
// The format of the string is the format of the atf_amc::TypeC's only field
bool                 TypeC_ReadStrptrMaybe(atf_amc::TypeC &parent, algo::strptr in_str);
bool                 TypeC_Lt(atf_amc::TypeC & lhs, atf_amc::TypeC & rhs) __attribute__((nothrow));
i32                  TypeC_Cmp(atf_amc::TypeC & lhs, atf_amc::TypeC & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeC_Init(atf_amc::TypeC& parent);
bool                 TypeC_Eq(const atf_amc::TypeC & lhs,const atf_amc::TypeC & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeC_Update(atf_amc::TypeC &lhs, atf_amc::TypeC & rhs) __attribute__((nothrow));
// print string representation of atf_amc::TypeC to string LHS, no header -- cprint:atf_amc.TypeC.String
void                 TypeC_Print(atf_amc::TypeC & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeH
// create: atf_amc.VarlenH.typeh (Varlen)
struct TypeH { // atf_amc.TypeH
    i32   typeh;   //   0
    bool operator ==(const atf_amc::TypeH &rhs) const;
    bool operator <(const atf_amc::TypeH &rhs) const;
    TypeH();
};

u32                  TypeH_Hash(u32 prev, const atf_amc::TypeH & rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeH from an ascii string.
// The format of the string is the format of the atf_amc::TypeH's only field
bool                 TypeH_ReadStrptrMaybe(atf_amc::TypeH &parent, algo::strptr in_str);
bool                 TypeH_Lt(atf_amc::TypeH & lhs, atf_amc::TypeH & rhs) __attribute__((nothrow));
i32                  TypeH_Cmp(atf_amc::TypeH & lhs, atf_amc::TypeH & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeH_Init(atf_amc::TypeH& typeh);
bool                 TypeH_Eq(const atf_amc::TypeH & lhs,const atf_amc::TypeH & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeH_Update(atf_amc::TypeH &lhs, atf_amc::TypeH & rhs) __attribute__((nothrow));
// print string representation of atf_amc::TypeH to string LHS, no header -- cprint:atf_amc.TypeH.String
void                 TypeH_Print(atf_amc::TypeH & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeS
// access: atf_amc.FTypeS.msghdr (Base)
struct TypeS { // atf_amc.TypeS
    i32             types;     //   0
    algo::Comment   comment;   //
    TypeS();
};

bool                 TypeS_ReadFieldMaybe(atf_amc::TypeS &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeS from an ascii string.
// The format of the string is an ssim Tuple
bool                 TypeS_ReadStrptrMaybe(atf_amc::TypeS &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TypeS_Init(atf_amc::TypeS& parent);
// print string representation of atf_amc::TypeS to string LHS, no header -- cprint:atf_amc.TypeS.String
void                 TypeS_Print(atf_amc::TypeS & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.TypeT
// access: atf_amc.FTypeT.msghdr (Base)
struct TypeT { // atf_amc.TypeT: Refers to TypeA
    i32   types;   //   0
    i32   j;       //   0
    TypeT();
};

u32                  TypeT_Hash(u32 prev, const atf_amc::TypeT & rhs) __attribute__((nothrow));
bool                 TypeT_ReadFieldMaybe(atf_amc::TypeT &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeT from an ascii string.
// The format of the string is an ssim Tuple
bool                 TypeT_ReadStrptrMaybe(atf_amc::TypeT &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TypeT_Init(atf_amc::TypeT& parent);
// print string representation of atf_amc::TypeT to string LHS, no header -- cprint:atf_amc.TypeT.String
void                 TypeT_Print(atf_amc::TypeT & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.Typefconst
struct Typefconst { // atf_amc.Typefconst
    u32   value;   //   0
    inline operator atf_amc_Typefconst_value_Enum() const;
    explicit Typefconst(u32                            in_value);
    Typefconst(atf_amc_Typefconst_value_Enum arg);
    Typefconst();
};

// Get value of field as enum type
atf_amc_Typefconst_value_Enum value_GetEnum(const atf_amc::Typefconst& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_amc::Typefconst& parent, atf_amc_Typefconst_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_amc::Typefconst& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_amc::Typefconst& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_amc::Typefconst& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_amc::Typefconst& parent, algo::strptr rhs, atf_amc_Typefconst_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_amc::Typefconst& parent, algo::strptr rhs) __attribute__((nothrow));

bool                 Typefconst_ReadFieldMaybe(atf_amc::Typefconst &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Typefconst from an ascii string.
// The format of the string is the format of the atf_amc::Typefconst's only field
bool                 Typefconst_ReadStrptrMaybe(atf_amc::Typefconst &parent, algo::strptr in_str);
// Read fields of atf_amc::Typefconst from attributes of ascii tuple TUPLE
bool                 Typefconst_ReadTupleMaybe(atf_amc::Typefconst &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 Typefconst_Init(atf_amc::Typefconst& parent);
// print string representation of atf_amc::Typefconst to string LHS, no header -- cprint:atf_amc.Typefconst.String
void                 Typefconst_Print(atf_amc::Typefconst & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_amc.VarlenAlloc
// create: atf_amc.FDb.varlenalloc (Lpool)
#pragma pack(push,1)
struct VarlenAlloc { // atf_amc.VarlenAlloc: An optional instance of atf_unit.A
    u32   length;   //   0
    // var-length field atf_amc.VarlenAlloc.elem starts here. access it with elem_Addr
private:
    friend atf_amc::VarlenAlloc& varlenalloc_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc* varlenalloc_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc& varlenalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc* varlenalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc* varlenalloc_AllocVarlenMaybe(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc& varlenalloc_AllocVarlen(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__));
    friend void                 varlenalloc_Delete(atf_amc::VarlenAlloc &row) __attribute__((nothrow));
    VarlenAlloc();
};
#pragma pack(pop)

// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<i32>    elem_Getary(atf_amc::VarlenAlloc& varlenalloc) __attribute__((nothrow));
i32*                 elem_Addr(atf_amc::VarlenAlloc& varlenalloc);
// Return number of elements in varlen field
u32                  elem_N(const atf_amc::VarlenAlloc& varlenalloc) __attribute__((__warn_unused_result__, nothrow, pure));

void                 varlenalloc_elem_curs_Reset(varlenalloc_elem_curs &curs, atf_amc::VarlenAlloc &parent);
// cursor points to valid item
bool                 varlenalloc_elem_curs_ValidQ(varlenalloc_elem_curs &curs);
// proceed to next item
void                 varlenalloc_elem_curs_Next(varlenalloc_elem_curs &curs);
// item access
i32&                 varlenalloc_elem_curs_Access(varlenalloc_elem_curs &curs);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::VarlenAlloc& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::VarlenAlloc& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 VarlenAlloc_Init(atf_amc::VarlenAlloc& varlenalloc);

// --- atf_amc.VarlenExtern
// create: atf_amc.FDb.varlen_extern (Lpool)
#pragma pack(push,1)
struct VarlenExtern { // atf_amc.VarlenExtern: A varlen array at the end of a struct, but lenfld is external
    u32   n_elems;   //   0
    // var-length field atf_amc.VarlenExtern.varlen starts here. access it with varlen_Addr
private:
    friend atf_amc::VarlenExtern& varlen_extern_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern* varlen_extern_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern& varlen_extern_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern* varlen_extern_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern* varlen_extern_AllocVarlenMaybe(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern& varlen_extern_AllocVarlen(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__));
    friend void                 varlen_extern_Delete(atf_amc::VarlenExtern &row) __attribute__((nothrow));
    VarlenExtern();
};
#pragma pack(pop)

u32                  length_Get(atf_amc::VarlenExtern& varlen_extern) __attribute__((__warn_unused_result__, nothrow));
void                 length_Set(atf_amc::VarlenExtern& varlen_extern, u32 rhs) __attribute__((nothrow));

// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u32>    varlen_Getary(atf_amc::VarlenExtern& varlen_extern) __attribute__((nothrow));
u32*                 varlen_Addr(atf_amc::VarlenExtern& varlen_extern);
// Return number of elements in varlen field
u32                  varlen_N(const atf_amc::VarlenExtern& varlen_extern) __attribute__((__warn_unused_result__, nothrow, pure));

void                 varlen_extern_varlen_curs_Reset(varlen_extern_varlen_curs &curs, atf_amc::VarlenExtern &parent);
// cursor points to valid item
bool                 varlen_extern_varlen_curs_ValidQ(varlen_extern_varlen_curs &curs);
// proceed to next item
void                 varlen_extern_varlen_curs_Next(varlen_extern_varlen_curs &curs);
// item access
u32&                 varlen_extern_varlen_curs_Access(varlen_extern_varlen_curs &curs);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::VarlenExtern& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::VarlenExtern& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 VarlenExtern_Init(atf_amc::VarlenExtern& varlen_extern);

// --- atf_amc.VarlenH
struct VarlenH { // atf_amc.VarlenH
    u32   length;   //   0
    // var-length field atf_amc.VarlenH.typeh starts here. access it with typeh_Addr
    VarlenH();
};

// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<atf_amc::TypeH> typeh_Getary(atf_amc::VarlenH& parent) __attribute__((nothrow));
atf_amc::TypeH*      typeh_Addr(atf_amc::VarlenH& parent);
// Return number of elements in varlen field
u32                  typeh_N(const atf_amc::VarlenH& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Verify whether array is sorted
bool                 typeh_SortedQ(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Insertion sort
void                 typeh_InsertionSort(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Heap sort
void                 typeh_HeapSort(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Quick sort
void                 typeh_QuickSort(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typeh_XrefMaybe(atf_amc::TypeH &row);

void                 VarlenH_typeh_curs_Reset(VarlenH_typeh_curs &curs, atf_amc::VarlenH &parent);
// cursor points to valid item
bool                 VarlenH_typeh_curs_ValidQ(VarlenH_typeh_curs &curs);
// proceed to next item
void                 VarlenH_typeh_curs_Next(VarlenH_typeh_curs &curs);
// item access
atf_amc::TypeH&      VarlenH_typeh_curs_Access(VarlenH_typeh_curs &curs);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::VarlenH& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::VarlenH& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 VarlenH_Init(atf_amc::VarlenH& parent);

// --- atf_amc.VarlenK
#pragma pack(push,1)
struct VarlenK { // atf_amc.VarlenK: An optional instance of atf_unit.A
    u32   length;   //   0
    // var-length field atf_amc.VarlenK.i starts here. access it with i_Addr
    VarlenK();
};
#pragma pack(pop)

// Access var-length portion as an aryptr. Length is determined from one of the fields.
algo::aryptr<u32>    i_Getary(atf_amc::VarlenK& parent) __attribute__((nothrow));
u32*                 i_Addr(atf_amc::VarlenK& parent);
// Return number of elements in varlen field
u32                  i_N(const atf_amc::VarlenK& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
bool                 i_ReadStrptrMaybe(atf_amc::VarlenK& parent, algo::strptr in_str) __attribute__((nothrow));

void                 VarlenK_i_curs_Reset(VarlenK_i_curs &curs, atf_amc::VarlenK &parent);
// cursor points to valid item
bool                 VarlenK_i_curs_ValidQ(VarlenK_i_curs &curs);
// proceed to next item
void                 VarlenK_i_curs_Next(VarlenK_i_curs &curs);
// item access
u32&                 VarlenK_i_curs_Access(VarlenK_i_curs &curs);
bool                 VarlenK_ReadFieldMaybe(atf_amc::VarlenK &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf
// Read fields of atf_amc::VarlenK from an ascii string.
// The format of the string is an ssim Tuple
bool                 VarlenK_ReadStrptrMaybe(atf_amc::VarlenK &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const atf_amc::VarlenK& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const atf_amc::VarlenK& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 VarlenK_Init(atf_amc::VarlenK& parent);
// print string representation of atf_amc::VarlenK to string LHS, no header -- cprint:atf_amc.VarlenK.String
void                 VarlenK_Print(atf_amc::VarlenK & row, algo::cstring &str) __attribute__((nothrow));

struct DispFilter_pmask_curs {// cursor
    typedef u64 ChildType;
    int index;
    atf_amc::DispFilter *parent;
    DispFilter_pmask_curs() { parent=NULL; index=0; }
};


struct cascdel_c_child_ptrary_curs {// cursor
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel** elems;
    u32 n_elems;
    u32 index;
    cascdel_c_child_ptrary_curs() { elems=NULL; n_elems=0; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct cascdel_bh_child_bheap_curs {
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel      *parent;        // parent
    atf_amc::FCascdel*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    cascdel_bh_child_bheap_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~cascdel_bh_child_bheap_curs();
};


struct cascdel_zd_childlist_curs {// cursor
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel* row;
    cascdel_zd_childlist_curs() {
        row = NULL;
    }
};


struct cascdel_tr_child_atree_curs {// cursor
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel* row;
    cascdel_tr_child_atree_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_typec_curs {
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FDb      *parent;        // parent
    atf_amc::FTypeC*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_typec_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_typec_curs();
};


struct _db_zdl_h_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zdl_h_typec_curs() {
        row = NULL;
    }
};


struct _db_zd_t_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zd_t_typec_curs() {
        row = NULL;
    }
};


struct _db_zsl_h_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zsl_h_typec_curs() {
        row = NULL;
    }
};


struct _db_zs_t_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zs_t_typec_curs() {
        row = NULL;
    }
};


struct _db_zdl_hnt_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zdl_hnt_typec_curs() {
        row = NULL;
    }
};


struct _db_cdl_h_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC* head;
    _db_cdl_h_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_t_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC* head;
    _db_cd_t_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_csl_h_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC* head;
    _db_csl_h_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cs_t_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC* head;
    _db_cs_t_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_typea_curs {// cursor
    typedef atf_amc::FTypeA ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_typea_curs(){ parent=NULL; index=0; }
};


struct _db_types_curs {// cursor
    typedef atf_amc::FTypeS ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_types_curs(){ parent=NULL; index=0; }
};


struct _db_typet_curs {// cursor
    typedef atf_amc::FTypeT ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_typet_curs(){ parent=NULL; index=0; }
};


struct _db_cstring_curs {// cursor
    typedef atf_amc::FCstring ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_cstring_curs(){ parent=NULL; index=0; }
};


struct _db_cd_in_msg_curs {// cursor
    typedef atf_amc::Msgbuf ChildType;
    atf_amc::Msgbuf* row;
    atf_amc::Msgbuf* head;
    _db_cd_in_msg_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_amctest_curs {// cursor
    typedef atf_amc::FAmctest ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_amctest_curs(){ parent=NULL; index=0; }
};


struct _db_c_typek_curs {// cursor
    typedef atf_amc::FTypeK ChildType;
    atf_amc::FTypeK** elems;
    u32 n_elems;
    u32 index;
    _db_c_typek_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_avl_curs {// cursor
    typedef atf_amc::FAvl ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_avl_curs(){ parent=NULL; index=0; }
};


struct _db_tr_avl_curs {// cursor
    typedef atf_amc::FAvl ChildType;
    atf_amc::FAvl* row;
    _db_tr_avl_curs() {
        row = NULL;
    }
};


struct _db_listtype_curs {// cursor
    typedef atf_amc::FListtype ChildType;
    int index;
    atf_amc::FDb *parent;
    _db_listtype_curs() { parent=NULL; index=0; }
};


struct FPerfSortString_orig_curs {// cursor
    typedef atf_amc::Cstr ChildType;
    atf_amc::Cstr* elems;
    int n_elems;
    int index;
    FPerfSortString_orig_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FPerfSortString_sorted1_curs {// cursor
    typedef atf_amc::Cstr ChildType;
    atf_amc::Cstr* elems;
    int n_elems;
    int index;
    FPerfSortString_sorted1_curs() { elems=NULL; n_elems=0; index=0; }
};


struct typea_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    int index;
    atf_amc::FTypeA *parent;
    typea_typec_curs() { parent=NULL; index=0; }
};


struct typea_zdl_typeb_curs {// cursor
    typedef atf_amc::FTypeB ChildType;
    atf_amc::FTypeB* row;
    typea_zdl_typeb_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct typea_bh_typeb_curs {
    typedef atf_amc::FTypeB ChildType;
    atf_amc::FTypeA      *parent;        // parent
    atf_amc::FTypeB*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    typea_bh_typeb_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~typea_bh_typeb_curs();
};


struct types_zdl_typet_curs {// cursor
    typedef atf_amc::FTypeT ChildType;
    atf_amc::FTypeT* row;
    types_zdl_typet_curs() {
        row = NULL;
    }
};


struct FUnitSort_tary_curs {// cursor
    typedef atf_amc::TypeA ChildType;
    atf_amc::TypeA* elems;
    int n_elems;
    int index;
    FUnitSort_tary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FUnitSort_c_ptrary_curs {// cursor
    typedef atf_amc::TypeA ChildType;
    atf_amc::TypeA** elems;
    u32 n_elems;
    u32 index;
    FUnitSort_c_ptrary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FUnitSort_fixary_curs {// cursor
    typedef atf_amc::TypeA ChildType;
    int index;
    atf_amc::FUnitSort *parent;
    FUnitSort_fixary_curs() { parent=NULL; index=0; }
};


struct InlaryPrint_fixary_curs {// cursor
    typedef u32 ChildType;
    int index;
    atf_amc::InlaryPrint *parent;
    InlaryPrint_fixary_curs() { parent=NULL; index=0; }
};


struct InlaryPrint_inlary_curs {// cursor
    typedef u32 ChildType;
    int index;
    atf_amc::InlaryPrint *parent;
    InlaryPrint_inlary_curs() { parent=NULL; index=0; }
};


struct Lary32_lary_curs {// cursor
    typedef u32 ChildType;
    atf_amc::Lary32 *parent;
    i64 index;
    Lary32_lary_curs(){ parent=NULL; index=0; }
};


struct PmaskU555_pmask_curs {// cursor
    typedef u64 ChildType;
    int index;
    atf_amc::PmaskU555 *parent;
    PmaskU555_pmask_curs() { parent=NULL; index=0; }
};


struct TaryU32_tary_u32_curs {// cursor
    typedef u32 ChildType;
    u32* elems;
    int n_elems;
    int index;
    TaryU32_tary_u32_curs() { elems=NULL; n_elems=0; index=0; }
};


struct TaryU8_ary_curs {// cursor
    typedef u8 ChildType;
    u8* elems;
    int n_elems;
    int index;
    TaryU8_ary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct Text_text_curs {// cursor
    typedef char ChildType;
    char* elems;
    int n_elems;
    int index;
    Text_text_curs() { elems=NULL; n_elems=0; index=0; }
};


struct varlenalloc_elem_curs {// cursor
    typedef i32 ChildType;
    i32* elems;
    int n_elems;
    int index;
    varlenalloc_elem_curs() { elems=NULL; n_elems=0; index=0; }
};


struct varlen_extern_varlen_curs {// cursor
    typedef u32 ChildType;
    u32* elems;
    int n_elems;
    int index;
    varlen_extern_varlen_curs() { elems=NULL; n_elems=0; index=0; }
};


struct VarlenH_typeh_curs {// cursor
    typedef atf_amc::TypeH ChildType;
    atf_amc::TypeH* elems;
    int n_elems;
    int index;
    VarlenH_typeh_curs() { elems=NULL; n_elems=0; index=0; }
};


struct VarlenK_i_curs {// cursor
    typedef u32 ChildType;
    u32* elems;
    int n_elems;
    int index;
    VarlenK_i_curs() { elems=NULL; n_elems=0; index=0; }
};

// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_AmcSort();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BhFirstChanged1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BhFirstChanged2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BhFirstChanged3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BheapCursor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BheapInsert100();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BigEndian();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BigendFconst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BitfldNet();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_BitfldTuple();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelAtree();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelBheap();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelBheapChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelPtr();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelPtrary();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelPtraryChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelThash();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelThashChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelZdlist();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelZdlistChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelZslist();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CascdelZslistChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CastDown();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CastDownFail();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CastDownTooShort();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CastUp();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistFlush100();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistFlushEmpty();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistInsertMaybe();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistItemDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CdlistRotateFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CleanupOrder();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CopyOut1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CopyOut2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CopyOut3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistFirstChangedFlush();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistFirstChangedRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistFirstChangedRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistHeadFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_CslistRotateFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Delptr();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_DispRead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_DispRead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_DispRead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_DispRead4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_DispReadSsimfile();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ExecSh();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Exec_Status();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Fcmp();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Fconst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Hook1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Hook2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ImdXref();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Inlary_ReadPrint();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_LaryFind();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_LineIter();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Lpool();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Minmax();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_MsgCurs();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_MsgCurs2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_MsgCurs3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_MsgCurs4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_MsgLength();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Numstr();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_NumstrCorruption();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptAlloc();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptG();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptG2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptG8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptG9();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG6();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG7();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_OptOptG9();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_PerfSortString();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_PrintBase36();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_PrintRawGconst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_PtraryInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ReadProc();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ReadTuple1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ReadTuple2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ReadTuple3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ReadTuple4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ReadTuple5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Scratch();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_SetGetnumBase10();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_SubstrDfltval();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TaryInit();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TaryInit2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TaryInit3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TaryInit4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TaryReserve();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestBitfld();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestBitfld2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestCstring1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestCstring2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestDispFilter();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestDispFilter2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestDispFilter3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestDispFilter4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestInsertX2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestInsertX3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask6();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask7();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestPmask8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestRegx1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestSep1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestSep2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_TestString();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Typetag();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_VarlenAlloc();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_VarlenExternLength();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistFlush100();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistFlushEmpty();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertHeadNoTail1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertHeadNoTail2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertHeadNoTail3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistInsertMaybe();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistItemDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZdlistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistFirstChangedFlush();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistFirstChangedRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistFirstChangedRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistHeadFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Zslistmt1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Zslistmt2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_Zslistmt3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistmtDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_ZslistmtItemDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_atree_RangeSearch();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_atree_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_atree_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_bytebuf_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_bytebuf_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_fstep_Inline();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_fstep_InlineOnce();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_fstep_InlineRecur();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_fstep_TimeHookRecur();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_linebuf_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_linebuf_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_linebuf_test3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_linebuf_test4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_linebuf_test5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test0();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test10();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test1_1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test1_2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test6();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test7();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
void                 amctest_msgbuf_test9();
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_cd(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_cdl(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_cs(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_csl(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_zd(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_zdl(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_zs(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
void                 listtype_zsl(atf_amc::FListtype&);
int                  main(int argc, char **argv);
// Test string conversion
void                 ForAllStrings(void (*fcn)(algo::StringDesc&) );
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
bool                 MsgHeaderMsgs_Print(algo::cstring &str, atf_amc::MsgHeader &msg, u32 msg_len);
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::MsgsCase    Msgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
bool                 Msgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::SsimfilesCase Ssimfiles_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
bool                 Ssimfiles_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
atf_amc::MsgType     MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
bool                 MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Construct a new atf_amc::OptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::OptG *      OptG_FmtByteAry(algo::ByteAry &buf, atf_amc::TypeG* typeg, int opt_len);
// Construct a new atf_amc::OptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
atf_amc::OptG *      OptG_FmtMemptr(algo::memptr &buf, atf_amc::TypeG* typeg, int opt_len);
// Construct a new atf_amc::OptOptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::OptOptG *   OptOptG_FmtByteAry(algo::ByteAry &buf, atf_amc::OptG* optg);
// Construct a new atf_amc::OptOptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
atf_amc::OptOptG *   OptOptG_FmtMemptr(algo::memptr &buf, atf_amc::OptG* optg);
// Construct a new atf_amc::Text in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::Text *      Text_FmtByteAry(algo::ByteAry &buf, algo::aryptr<char > text);
// Construct a new atf_amc::VarlenK in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
atf_amc::VarlenK *   VarlenK_FmtByteAry(algo::ByteAry &buf, algo::aryptr<u32 > i);
// Construct a new atf_amc::VarlenK in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
atf_amc::VarlenK *   VarlenK_FmtMemptr(algo::memptr &buf, algo::aryptr<u32 > i);
} // end namespace atf_amc
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::BitfldType1 &row);// cfmt:atf_amc.BitfldType1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Ctype1Attr &row);// cfmt:atf_amc.Ctype1Attr.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Ctype2Attr &row);// cfmt:atf_amc.Ctype2Attr.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::trace &row);// cfmt:atf_amc.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TypeG &row);// cfmt:atf_amc.TypeG.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::FieldId &row);// cfmt:atf_amc.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgType &row);// cfmt:atf_amc.MsgType.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgLength &row);// cfmt:atf_amc.MsgLength.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgHeader &row);// cfmt:atf_amc.MsgHeader.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::OptAlloc &row);// cfmt:atf_amc.OptAlloc.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::OptG &row);// cfmt:atf_amc.OptG.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::OptOptG &row);// cfmt:atf_amc.OptOptG.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::PooledBE64 &row);// cfmt:atf_amc.PooledBE64.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Sep1 &row);// cfmt:atf_amc.Sep1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Seqmsg &row);// cfmt:atf_amc.Seqmsg.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TableId &row);// cfmt:atf_amc.TableId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TestRegx1 &row);// cfmt:atf_amc.TestRegx1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TypeBE64 &row);// cfmt:atf_amc.TypeBE64.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TypeBE64en &row);// cfmt:atf_amc.TypeBE64en.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Typefconst &row);// cfmt:atf_amc.Typefconst.String
}
