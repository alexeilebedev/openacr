//
// include/gen/atf_amc_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/lib_json.h"
#include "include/gen/algo_gen.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/lib_exec_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/dmmeta_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- atf_amc_BitfldType2_value_Enum

enum atf_amc_BitfldType2_value_Enum {                  // atf_amc.BitfldType2.value
     atf_amc_BitfldType2_value_bit0    = (u64(1)<<0)   // atf_amc.BitfldType2.bit0
    ,atf_amc_BitfldType2_value_bit1    = (u64(1)<<1)   // atf_amc.BitfldType2.bit1
};

enum { atf_amc_BitfldType2_value_Enum_N = 2 };


// --- atf_amc_DispCaseEnum

enum atf_amc_DispCaseEnum {                    // atf_amc.DispCase.value
     atf_amc_DispCase_atf_amc_DispType1   = 1
    ,atf_amc_DispCase_atf_amc_DispType2   = 2
    ,atf_amc_DispCase_atf_amc_DispType3   = 3
};

enum { atf_amc_DispCaseEnum_N = 3 };


// --- atf_amc_FCascdel_type_Enum

enum atf_amc_FCascdel_type_Enum {        // atf_amc.FCascdel.type
     atf_amc_FCascdel_type_none     = 0
    ,atf_amc_FCascdel_type_ptr      = 1
    ,atf_amc_FCascdel_type_ptrary   = 2
    ,atf_amc_FCascdel_type_thash    = 3
    ,atf_amc_FCascdel_type_bheap    = 4
    ,atf_amc_FCascdel_type_zdlist   = 6
    ,atf_amc_FCascdel_type_atree    = 6
};

enum { atf_amc_FCascdel_type_Enum_N = 7 };


// --- atf_amc_FieldIdEnum

enum atf_amc_FieldIdEnum {                  // atf_amc.FieldId.value
     atf_amc_FieldId_value           = 0
    ,atf_amc_FieldId_bit1            = 1
    ,atf_amc_FieldId_bits5           = 2
    ,atf_amc_FieldId_bit0            = 3
    ,atf_amc_FieldId_freebool        = 4
    ,atf_amc_FieldId_attr1           = 5
    ,atf_amc_FieldId_attr2           = 6
    ,atf_amc_FieldId_strval          = 7
    ,atf_amc_FieldId_strval2         = 8
    ,atf_amc_FieldId_dateval         = 9
    ,atf_amc_FieldId_intval          = 10
    ,atf_amc_FieldId_fixary          = 11
    ,atf_amc_FieldId_inlary          = 12
    ,atf_amc_FieldId_len             = 13
    ,atf_amc_FieldId_type            = 14
    ,atf_amc_FieldId_length          = 15
    ,atf_amc_FieldId_base            = 16
    ,atf_amc_FieldId_a               = 17
    ,atf_amc_FieldId_b               = 18
    ,atf_amc_FieldId_o               = 19
    ,atf_amc_FieldId_v               = 20
    ,atf_amc_FieldId_typeg           = 21
    ,atf_amc_FieldId_optg            = 22
    ,atf_amc_FieldId_present         = 23
    ,atf_amc_FieldId_assigned        = 24
    ,atf_amc_FieldId_nullable        = 25
    ,atf_amc_FieldId_value1          = 26
    ,atf_amc_FieldId_value2          = 27
    ,atf_amc_FieldId_value3          = 28
    ,atf_amc_FieldId_value4          = 29
    ,atf_amc_FieldId_value5          = 30
    ,atf_amc_FieldId_value6          = 31
    ,atf_amc_FieldId_value7          = 32
    ,atf_amc_FieldId_pmask           = 33
    ,atf_amc_FieldId_value21         = 34
    ,atf_amc_FieldId_value22         = 35
    ,atf_amc_FieldId_value23         = 36
    ,atf_amc_FieldId_value24         = 37
    ,atf_amc_FieldId_value25         = 38
    ,atf_amc_FieldId_value26         = 39
    ,atf_amc_FieldId_value20         = 40
    ,atf_amc_FieldId_value28         = 41
    ,atf_amc_FieldId_value29         = 42
    ,atf_amc_FieldId_value30         = 43
    ,atf_amc_FieldId_value31         = 44
    ,atf_amc_FieldId_value32         = 45
    ,atf_amc_FieldId_value27         = 46
    ,atf_amc_FieldId_value19         = 47
    ,atf_amc_FieldId_value18         = 48
    ,atf_amc_FieldId_value8          = 49
    ,atf_amc_FieldId_value9          = 50
    ,atf_amc_FieldId_value69         = 51
    ,atf_amc_FieldId_value11         = 52
    ,atf_amc_FieldId_value12         = 53
    ,atf_amc_FieldId_value13         = 54
    ,atf_amc_FieldId_value14         = 55
    ,atf_amc_FieldId_value15         = 56
    ,atf_amc_FieldId_value16         = 57
    ,atf_amc_FieldId_value33         = 58
    ,atf_amc_FieldId_value10         = 59
    ,atf_amc_FieldId_value17         = 60
    ,atf_amc_FieldId_value35         = 61
    ,atf_amc_FieldId_value55         = 62
    ,atf_amc_FieldId_value56         = 63
    ,atf_amc_FieldId_value57         = 64
    ,atf_amc_FieldId_value58         = 65
    ,atf_amc_FieldId_value59         = 66
    ,atf_amc_FieldId_value60         = 67
    ,atf_amc_FieldId_value54         = 68
    ,atf_amc_FieldId_value62         = 69
    ,atf_amc_FieldId_value63         = 70
    ,atf_amc_FieldId_value64         = 71
    ,atf_amc_FieldId_value65         = 72
    ,atf_amc_FieldId_value66         = 73
    ,atf_amc_FieldId_value67         = 74
    ,atf_amc_FieldId_value68         = 75
    ,atf_amc_FieldId_value61         = 76
    ,atf_amc_FieldId_value34         = 77
    ,atf_amc_FieldId_value52         = 78
    ,atf_amc_FieldId_value36         = 79
    ,atf_amc_FieldId_value37         = 80
    ,atf_amc_FieldId_value38         = 81
    ,atf_amc_FieldId_value39         = 82
    ,atf_amc_FieldId_value40         = 83
    ,atf_amc_FieldId_value41         = 84
    ,atf_amc_FieldId_value42         = 85
    ,atf_amc_FieldId_value53         = 86
    ,atf_amc_FieldId_value44         = 87
    ,atf_amc_FieldId_value45         = 88
    ,atf_amc_FieldId_value46         = 89
    ,atf_amc_FieldId_value47         = 90
    ,atf_amc_FieldId_value48         = 91
    ,atf_amc_FieldId_value49         = 92
    ,atf_amc_FieldId_value50         = 93
    ,atf_amc_FieldId_value51         = 94
    ,atf_amc_FieldId_value43         = 95
    ,atf_amc_FieldId_value70         = 96
    ,atf_amc_FieldId_value71         = 97
    ,atf_amc_FieldId_ch              = 98
    ,atf_amc_FieldId_val1            = 99
    ,atf_amc_FieldId_val2            = 100
    ,atf_amc_FieldId_val3            = 101
    ,atf_amc_FieldId_msghdr          = 102
    ,atf_amc_FieldId_payload         = 103
    ,atf_amc_FieldId_val             = 104
    ,atf_amc_FieldId_text            = 105
    ,atf_amc_FieldId_typea           = 106
    ,atf_amc_FieldId_j               = 107
    ,atf_amc_FieldId_typec           = 108
    ,atf_amc_FieldId_typeh           = 109
    ,atf_amc_FieldId_types           = 110
    ,atf_amc_FieldId_comment         = 111
    ,atf_amc_FieldId_i               = 112
    ,atf_amc_FieldId_k               = 113
    ,atf_amc_FieldId_strval_regx     = 114
    ,atf_amc_FieldId_strval2_regx    = 115
    ,atf_amc_FieldId_start_dateval   = 116
    ,atf_amc_FieldId_end_dateval     = 117
    ,atf_amc_FieldId_start_intval    = 118
    ,atf_amc_FieldId_end_intval      = 119
};

enum { atf_amc_FieldIdEnum_N = 120 };


// --- atf_amc_MsgHdrLT_type_Enum

enum atf_amc_MsgHdrLT_type_Enum {                  // atf_amc.MsgHdrLT.type
     atf_amc_MsgHdrLT_type_atf_amc_MsgLTA   = 'A'
    ,atf_amc_MsgHdrLT_type_atf_amc_MsgLTB   = 'B'
    ,atf_amc_MsgHdrLT_type_atf_amc_MsgLTO   = 'O'
    ,atf_amc_MsgHdrLT_type_atf_amc_MsgLTV   = 'V'
};

enum { atf_amc_MsgHdrLT_type_Enum_N = 4 };


// --- atf_amc_MsgHdrLTMsgsCaseEnum

enum atf_amc_MsgHdrLTMsgsCaseEnum {                   // atf_amc.MsgHdrLTMsgsCase.value
     atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTA   = 'A'
    ,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTB   = 'B'
    ,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTO   = 'O'
    ,atf_amc_MsgHdrLTMsgsCase_atf_amc_MsgLTV   = 'V'
};

enum { atf_amc_MsgHdrLTMsgsCaseEnum_N = 4 };


// --- atf_amc_MsgTypeEnum

enum atf_amc_MsgTypeEnum {                          // atf_amc.MsgType.value
     atf_amc_MsgType_atf_amc_Seqmsg      = 0x0905   // Sequenced message for stream
    ,atf_amc_MsgType_atf_amc_Text        = 0x0412
    ,atf_amc_MsgType_atf_amc_VarlenMsg   = 0x1000
};

enum { atf_amc_MsgTypeEnum_N = 3 };


// --- atf_amc_MsgsCaseEnum

enum atf_amc_MsgsCaseEnum {                  // atf_amc.MsgsCase.value
     atf_amc_MsgsCase_atf_amc_VarlenK   = 1
};

enum { atf_amc_MsgsCaseEnum_N = 1 };


// --- atf_amc_PooledBE64_value_Enum

enum atf_amc_PooledBE64_value_Enum {       // atf_amc.PooledBE64.value
     atf_amc_PooledBE64_value_A       = 3
    ,atf_amc_PooledBE64_value_B       = 4
};

enum { atf_amc_PooledBE64_value_Enum_N = 2 };


// --- atf_amc_SsimfilesCaseEnum

enum atf_amc_SsimfilesCaseEnum {               // atf_amc.SsimfilesCase.value
     atf_amc_SsimfilesCase_dmmeta_Ctype   = 1
    ,atf_amc_SsimfilesCase_dmmeta_ctype   = 1
};

enum { atf_amc_SsimfilesCaseEnum_N = 2 };


// --- atf_amc_TableIdEnum

enum atf_amc_TableIdEnum {                 // atf_amc.TableId.value
     atf_amc_TableId_atf_amc_TypeS   = 0   // atf_amc.TypeS -> atf_amc.FTypeS
    ,atf_amc_TableId_atf_amc_TypeT   = 1   // atf_amc.TypeT -> atf_amc.FTypeT
};

enum { atf_amc_TableIdEnum_N = 2 };


// --- atf_amc_TypeBE32en_value_Enum

enum atf_amc_TypeBE32en_value_Enum {                // atf_amc.TypeBE32en.value
     atf_amc_TypeBE32en_value_val1    = 0x12345678
    ,atf_amc_TypeBE32en_value_val2    = 0xabcdef01
};

enum { atf_amc_TypeBE32en_value_Enum_N = 2 };


// --- atf_amc_Typefconst_value_Enum

enum atf_amc_Typefconst_value_Enum {         // atf_amc.Typefconst.value
     atf_amc_Typefconst_value_strval1   = 1
    ,atf_amc_Typefconst_value_strval2   = 2
};

enum { atf_amc_Typefconst_value_Enum_N = 2 };

namespace atf_amc { // gen:ns_pkeytypedef
    typedef i32 TypeAPkey;
    typedef i32 TypeSPkey;
} // gen:ns_pkeytypedef
namespace atf_amc { // gen:ns_tclass_field
extern const char *atf_amc_help;
struct varlen_extern_Lpblock {
    varlen_extern_Lpblock* next;
};
struct optalloc_Lpblock {
    optalloc_Lpblock* next;
};
struct varlenalloc_Lpblock {
    varlenalloc_Lpblock* next;
};
struct optg_Lpblock {
    optg_Lpblock* next;
};
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace atfdb { struct Amctest; }
namespace atf_amc { struct FCascdel; }
namespace atf_amc { struct Cstring; }
namespace dmmeta { struct Listtype; }
namespace atf_amc { struct OptG; }
namespace atf_amc { struct TypeG; }
namespace atf_amc { struct TypeA; }
namespace atf_amc { struct TypeB; }
namespace atf_amc { struct TypeC; }
namespace atf_amc { struct TypeS; }
namespace atf_amc { struct TypeT; }
namespace atf_amc { struct MsgHdrLT; }
namespace atf_amc { struct MsgHeader; }
namespace atf_amc { struct TypeH; }
namespace atf_amc { struct VarlenK; }
namespace atf_amc { struct DispType1; }
namespace atf_amc { struct DispType2; }
namespace atf_amc { struct DispType3; }
namespace dmmeta { struct Ctype; }
namespace atf_amc { struct MsgLTA; }
namespace atf_amc { struct MsgLTB; }
namespace atf_amc { struct MsgLTO; }
namespace atf_amc { struct MsgLTV; }
namespace atf_amc { struct Seqmsg; }
namespace atf_amc { struct Text; }
namespace atf_amc { struct VarlenMsg; }
namespace atf_amc { struct OptOptG; }
namespace atf_amc { struct MsgType; }
namespace atf_amc { struct MsgLength; }
namespace atf_amc { struct Bitset_fld1_bitcurs; }
namespace atf_amc { struct Bitset_fld1_curs; }
namespace atf_amc { struct Bitset_fld8_bitcurs; }
namespace atf_amc { struct Bitset_fld64_bitcurs; }
namespace atf_amc { struct Bitset_fld128_bitcurs; }
namespace atf_amc { struct DispFilter_pmask_bitcurs; }
namespace atf_amc { struct DispFilter_pmask_curs; }
namespace atf_amc { struct cascdel_c_child_ptrary_curs; }
namespace atf_amc { struct cascdel_bh_child_bheap_curs; }
namespace atf_amc { struct cascdel_zd_childlist_curs; }
namespace atf_amc { struct cascdel_tr_child_atree_curs; }
namespace atf_amc { struct _db_bh_typec_curs; }
namespace atf_amc { struct _db_zdl_h_typec_curs; }
namespace atf_amc { struct _db_zd_t_typec_curs; }
namespace atf_amc { struct _db_zd_typed_curs; }
namespace atf_amc { struct _db_zd_typed_delcurs; }
namespace atf_amc { struct _db_zs_t_typed_curs; }
namespace atf_amc { struct _db_zs_t_typed_delcurs; }
namespace atf_amc { struct _db_cd_typed_curs; }
namespace atf_amc { struct _db_cd_typed_delcurs; }
namespace atf_amc { struct _db_zsl_h_typec_curs; }
namespace atf_amc { struct _db_zs_t_typec_curs; }
namespace atf_amc { struct _db_zdl_hnt_typec_curs; }
namespace atf_amc { struct _db_cdl_h_typec_curs; }
namespace atf_amc { struct _db_cd_t_typec_curs; }
namespace atf_amc { struct _db_csl_h_typec_curs; }
namespace atf_amc { struct _db_cs_t_typec_curs; }
namespace atf_amc { struct _db_typea_curs; }
namespace atf_amc { struct _db_types_curs; }
namespace atf_amc { struct _db_typet_curs; }
namespace atf_amc { struct _db_cstring_curs; }
namespace atf_amc { struct _db_cd_in_msg_curs; }
namespace atf_amc { struct _db_amctest_curs; }
namespace atf_amc { struct _db_c_typek_curs; }
namespace atf_amc { struct _db_c_typek_oncecurs; }
namespace atf_amc { struct _db_avl_curs; }
namespace atf_amc { struct _db_tr_avl_curs; }
namespace atf_amc { struct _db_listtype_curs; }
namespace atf_amc { struct _db_thash_elem_curs; }
namespace atf_amc { struct FPerfSortString_orig_curs; }
namespace atf_amc { struct FPerfSortString_sorted1_curs; }
namespace atf_amc { struct typea_typec_curs; }
namespace atf_amc { struct typea_zdl_typeb_curs; }
namespace atf_amc { struct typea_bh_typeb_curs; }
namespace atf_amc { struct types_zdl_typet_curs; }
namespace atf_amc { struct FUnitSort_tary_curs; }
namespace atf_amc { struct FUnitSort_c_ptrary_curs; }
namespace atf_amc { struct FUnitSort_fixary_curs; }
namespace atf_amc { struct InlaryPrint_fixary_curs; }
namespace atf_amc { struct InlaryPrint_inlary_curs; }
namespace atf_amc { struct Lary32_lary_curs; }
namespace atf_amc { struct MsgLTV_v_curs; }
namespace atf_amc { struct PmaskMultiple_present_bitcurs; }
namespace atf_amc { struct PmaskMultiple_assigned_bitcurs; }
namespace atf_amc { struct PmaskMultiple_nullable_bitcurs; }
namespace atf_amc { struct PmaskU128_pmask_bitcurs; }
namespace atf_amc { struct PmaskU32_pmask_bitcurs; }
namespace atf_amc { struct PmaskU555_pmask_bitcurs; }
namespace atf_amc { struct PmaskU555_pmask_curs; }
namespace atf_amc { struct TaryU32_tary_u32_curs; }
namespace atf_amc { struct TaryU8_ary_curs; }
namespace atf_amc { struct Text_text_curs; }
namespace atf_amc { struct varlenalloc_elem_curs; }
namespace atf_amc { struct varlen_extern_varlen_curs; }
namespace atf_amc { struct VarlenH_typeh_curs; }
namespace atf_amc { struct k_i_curs; }
namespace atf_amc { struct VarlenMsg_k_curs; }
namespace atf_amc { struct AmcCleanup2; }
namespace atf_amc { struct AmcSubstr1; }
namespace atf_amc { struct BitfldType1; }
namespace atf_amc { struct BitfldType2; }
namespace atf_amc { struct BitfldU128; }
namespace atf_amc { struct BitfldU16; }
namespace atf_amc { struct Bitset; }
namespace atf_amc { struct Bytebuf; }
namespace atf_amc { struct BytebufDyn; }
namespace atf_amc { struct Cstr; }
namespace atf_amc { struct Ctype1Attr; }
namespace atf_amc { struct Ctype2Attr; }
namespace atf_amc { struct Ctype2AttrAnon; }
namespace atf_amc { struct DelType1; }
namespace atf_amc { struct DispCase; }
namespace atf_amc { struct DispFilter; }
namespace atf_amc { struct FAmctest; }
namespace atf_amc { struct FAvl; }
namespace atf_amc { struct FCstring; }
namespace atf_amc { struct FListtype; }
namespace atf_amc { struct trace; }
namespace atf_amc { struct FDb; }
namespace atf_amc { struct FOptG; }
namespace atf_amc { struct FPerfSortString; }
namespace atf_amc { struct FThashElem; }
namespace atf_amc { struct FTypeC; }
namespace atf_amc { struct FTypeA; }
namespace atf_amc { struct FTypeB; }
namespace atf_amc { struct FTypeD; }
namespace atf_amc { struct FTypeK; }
namespace atf_amc { struct FTypeS; }
namespace atf_amc { struct FTypeT; }
namespace atf_amc { struct FUnitSort; }
namespace atf_amc { struct FieldId; }
namespace atf_amc { struct Hooktype; }
namespace atf_amc { struct InlaryPrint; }
namespace atf_amc { struct Lary32; }
namespace atf_amc { struct Linebuf; }
namespace atf_amc { struct MsgHdrLTMsgsCase; }
namespace atf_amc { struct MsgHdrLT_curs; }
namespace atf_amc { struct MsgHeader_curs; }
namespace atf_amc { struct Msgbuf; }
namespace atf_amc { struct MsgsCase; }
namespace atf_amc { struct NetBitfld1; }
namespace atf_amc { struct OptAlloc; }
namespace atf_amc { struct OptAlloc_curs; }
namespace atf_amc { struct OptG_curs; }
namespace atf_amc { struct OptOptG_curs; }
namespace atf_amc { struct PmaskMultiple; }
namespace atf_amc { struct PmaskU128; }
namespace atf_amc { struct PmaskU32; }
namespace atf_amc { struct PmaskU555; }
namespace atf_amc { struct PooledBE64; }
namespace atf_amc { struct RnullStr6_U32; }
namespace atf_amc { struct RpasU32Str6; }
namespace atf_amc { struct Sep1; }
namespace atf_amc { struct SortedStr; }
namespace atf_amc { struct SsimfilesCase; }
namespace atf_amc { struct TableId; }
namespace atf_amc { struct TaryU32; }
namespace atf_amc { struct TaryU8; }
namespace atf_amc { struct TestRegx1; }
namespace atf_amc { struct TestType; }
namespace atf_amc { struct TypeBE16; }
namespace atf_amc { struct TypeBE32; }
namespace atf_amc { struct TypeBE32en; }
namespace atf_amc { struct TypeBE64; }
namespace atf_amc { struct TypeBE64dflt; }
namespace atf_amc { struct TypeBE64sf; }
namespace atf_amc { struct TypeTVal; }
namespace atf_amc { struct Typefconst; }
namespace atf_amc { struct VarlenAlloc; }
namespace atf_amc { struct VarlenAlloc_curs; }
namespace atf_amc { struct VarlenExtern; }
namespace atf_amc { struct VarlenExtern_curs; }
namespace atf_amc { struct VarlenH; }
namespace atf_amc { struct VarlenH_curs; }
namespace atf_amc { struct VarlenK_curs; }
namespace atf_amc { extern struct atf_amc::FDb _db; }
namespace atf_amc { // hook_fcn_typedef
    typedef void (*amctest_step_hook)(); // hook:atf_amc.FAmctest.step
    typedef void (*listtype_step_hook)(atf_amc::FListtype& arg); // hook:atf_amc.FListtype.step
    typedef void (*parent_callback_hook)(void* userctx, atf_amc::Hooktype& arg); // hook:atf_amc.Hooktype.callback
} // hook_decl
namespace atf_amc { // gen:ns_gsymbol
    extern const char* atfdb_test_gsymbol_char_TestChar; // "TestChar"
} // gen:ns_gsymbol
namespace atf_amc { // gen:ns_gsymbol
    extern const atfdb::TestGsymbolPkeyPkey atfdb_test_gsymbol_pkey_TestPkey; // "TestPkey"
} // gen:ns_gsymbol
namespace atf_amc { // gen:ns_gsymbol
    extern const algo::strptr atfdb_test_gsymbol_strptr_TestStrptr; // "TestStrptr"
} // gen:ns_gsymbol
namespace atf_amc { // gen:ns_size_enums

// sizes types appearing as Opt or Varlen; these need to be here
// to allow inline implementations of _Get functions and avoid
// a circular dependency between headers
enum {
    sizeof_atf_amc_TypeG = 4
    , sizeof_atf_amc_MsgHdrLT = 2
    , sizeof_atf_amc_OptG = 4
    , sizeof_atf_amc_MsgHeader = 4
};
} // gen:ns_size_enums
namespace atf_amc { // gen:ns_print_struct

// --- atf_amc.AmcCleanup2
struct AmcCleanup2 { // atf_amc.AmcCleanup2
    i32   field1;   //   0
    i32   field2;   //   0
    // func:atf_amc.AmcCleanup2..Ctor
    inline               AmcCleanup2() __attribute__((nothrow));
    // func:atf_amc.AmcCleanup2..Dtor
    inline               ~AmcCleanup2() __attribute__((nothrow));
};

// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field field1 of atf_amc::AmcCleanup2
// func:atf_amc.AmcCleanup2.field1.Cleanup
// this function is 'extrn' and implemented by user
void                 field1_Cleanup(atf_amc::AmcCleanup2& parent) __attribute__((nothrow));

// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field field2 of atf_amc::AmcCleanup2
// func:atf_amc.AmcCleanup2.field2.Cleanup
// this function is 'extrn' and implemented by user
void                 field2_Cleanup(atf_amc::AmcCleanup2& parent) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.AmcCleanup2..Init
inline void          AmcCleanup2_Init(atf_amc::AmcCleanup2& parent);
// func:atf_amc.AmcCleanup2..Uninit
inline void          AmcCleanup2_Uninit(atf_amc::AmcCleanup2& parent) __attribute__((nothrow));

// --- atf_amc.AmcSubstr1
struct AmcSubstr1 { // atf_amc.AmcSubstr1
    algo::cstring   strval;   //
    // func:atf_amc.AmcSubstr1..Ctor
    inline               AmcSubstr1() __attribute__((nothrow));
};

// func:atf_amc.AmcSubstr1.boolval.Get
bool                 boolval_Get(atf_amc::AmcSubstr1& parent) __attribute__((__warn_unused_result__, nothrow));

// func:atf_amc.AmcSubstr1.intval.Get
i32                  intval_Get(atf_amc::AmcSubstr1& parent) __attribute__((__warn_unused_result__, nothrow));


// --- atf_amc.BitfldType1
struct BitfldType1 { // atf_amc.BitfldType1: Test type for testing reading/printing bitfields to tuple
    u64   value;   //   0
    // func:atf_amc.BitfldType1..Ctor
    inline               BitfldType1() __attribute__((nothrow));
};

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
// func:atf_amc.BitfldType1.bit1.Get
inline u64           bit1_Get(const atf_amc::BitfldType1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
// func:atf_amc.BitfldType1.bit1.Set
inline void          bit1_Set(atf_amc::BitfldType1& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    10 bits starting at bit 5.
// func:atf_amc.BitfldType1.bits5.Get
inline u64           bits5_Get(const atf_amc::BitfldType1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    10 bits starting at bit 5.
// func:atf_amc.BitfldType1.bits5.Set
inline void          bits5_Set(atf_amc::BitfldType1& parent, u64 rhs) __attribute__((nothrow));

// func:atf_amc.BitfldType1..ReadFieldMaybe
bool                 BitfldType1_ReadFieldMaybe(atf_amc::BitfldType1& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::BitfldType1 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.BitfldType1..ReadStrptrMaybe
bool                 BitfldType1_ReadStrptrMaybe(atf_amc::BitfldType1 &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.BitfldType1..Init
inline void          BitfldType1_Init(atf_amc::BitfldType1& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.BitfldType1.String  printfmt:Tuple
// func:atf_amc.BitfldType1..Print
void                 BitfldType1_Print(atf_amc::BitfldType1& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.BitfldType2
struct BitfldType2 { // atf_amc.BitfldType2: Test type 2 for testing reading/printing bitfields to tuple
    u64    value;      //   0
    bool   freebool;   //   false
    // func:atf_amc.BitfldType2..Ctor
    inline               BitfldType2() __attribute__((nothrow));
};

// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
// func:atf_amc.BitfldType2.bit0.Get
inline bool          bit0_Get(const atf_amc::BitfldType2& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
// func:atf_amc.BitfldType2.bit0.Set
inline void          bit0_Set(atf_amc::BitfldType2& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
// func:atf_amc.BitfldType2.bit1.Get
inline bool          bit1_Get(const atf_amc::BitfldType2& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
// func:atf_amc.BitfldType2.bit1.Set
inline void          bit1_Set(atf_amc::BitfldType2& parent, bool rhs) __attribute__((nothrow));

// func:atf_amc.BitfldType2..ReadFieldMaybe
bool                 BitfldType2_ReadFieldMaybe(atf_amc::BitfldType2& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::BitfldType2 from an ascii string.
// func:atf_amc.BitfldType2..ReadStrptrMaybe
bool                 BitfldType2_ReadStrptrMaybe(atf_amc::BitfldType2 &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.BitfldType2..Init
inline void          BitfldType2_Init(atf_amc::BitfldType2& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.BitfldType2.String  printfmt:Bitset
// func:atf_amc.BitfldType2..Print
void                 BitfldType2_Print(atf_amc::BitfldType2& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.BitfldU128
struct BitfldU128 { // atf_amc.BitfldU128: Test of bitfield functionality
    u128   value;   //   0
    // func:atf_amc.BitfldU128..Ctor
    inline               BitfldU128() __attribute__((nothrow));
};

// Retrieve bitfield from value of field value
//    64 bits starting at bit 1.
// func:atf_amc.BitfldU128.bits1_65.Get
inline u64           bits1_65_Get(const atf_amc::BitfldU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    64 bits starting at bit 1.
// func:atf_amc.BitfldU128.bits1_65.Set
inline void          bits1_65_Set(atf_amc::BitfldU128& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    63 bits starting at bit 65.
// func:atf_amc.BitfldU128.bits65_128.Get
inline u64           bits65_128_Get(const atf_amc::BitfldU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    63 bits starting at bit 65.
// func:atf_amc.BitfldU128.bits65_128.Set
inline void          bits65_128_Set(atf_amc::BitfldU128& parent, u64 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.BitfldU128..Init
inline void          BitfldU128_Init(atf_amc::BitfldU128& parent);

// --- atf_amc.BitfldU16
struct BitfldU16 { // atf_amc.BitfldU16: Test of bitfield functionality
    u16   value;   //   0
    // func:atf_amc.BitfldU16..Ctor
    inline               BitfldU16() __attribute__((nothrow));
};

// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
// func:atf_amc.BitfldU16.bits0_4.Get
inline u8            bits0_4_Get(const atf_amc::BitfldU16& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
// func:atf_amc.BitfldU16.bits0_4.Set
inline void          bits0_4_Set(atf_amc::BitfldU16& parent, u8 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 8.
// func:atf_amc.BitfldU16.bits8_12.Get
inline u8            bits8_12_Get(const atf_amc::BitfldU16& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 8.
// func:atf_amc.BitfldU16.bits8_12.Set
inline void          bits8_12_Set(atf_amc::BitfldU16& parent, u8 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.BitfldU16..Init
inline void          BitfldU16_Init(atf_amc::BitfldU16& parent);

// --- atf_amc.Bitset
struct Bitset { // atf_amc.Bitset: Test bitset
    u16    fld1_elems[4];   //   0  fixed array
    u8     fld8;            //   0  Bitset field
    u64    fld64;           //   0  Bitset field
    u128   fld128;          //   0  Bitset field 128 bits
    // func:atf_amc.Bitset..Ctor
    inline               Bitset() __attribute__((nothrow));
};

// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.Bitset.fld1.NBits
inline int           fld1_Nbits(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld1.qGetBit
inline bool          fld1_qGetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.Bitset.fld1.GetBit
inline bool          fld1_GetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.Bitset.fld1.BitsEmptyQ
inline bool          fld1_BitsEmptyQ(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.Bitset.fld1.Sum1s
inline u64           fld1_Sum1s(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld1.qClearBit
inline void          fld1_qClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.Bitset.fld1.ClearBit
inline void          fld1_ClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld1.qSetBit
inline void          fld1_qSetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.Bitset.fld1.SetBit
inline void          fld1_SetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld1.qSetBitVal
inline void          fld1_qSetBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld1.qOrBitVal
inline void          fld1_qOrBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.Bitset.fld1.ClearBitsAll
inline void          fld1_ClearBitsAll(atf_amc::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.Bitset.fld1.ClearBits
inline void          fld1_ClearBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.Bitset.fld1.OrBits
inline void          fld1_OrBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.Bitset.fld1.Sup
inline i32           fld1_Sup(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
// func:atf_amc.Bitset.fld1.Fill
inline void          fld1_Fill(atf_amc::Bitset& parent, const u16 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.Bitset.fld1.Find
inline u16*          fld1_Find(atf_amc::Bitset& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array fld1 as aryptr.
// func:atf_amc.Bitset.fld1.Getary
inline algo::aryptr<u16> fld1_Getary(atf_amc::Bitset& parent) __attribute__((nothrow));
// Return max number of items in the array
// func:atf_amc.Bitset.fld1.Max
inline i32           fld1_Max(atf_amc::Bitset& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.Bitset.fld1.N
inline i32           fld1_N(const atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
// func:atf_amc.Bitset.fld1.Setary
inline void          fld1_Setary(atf_amc::Bitset& parent, const algo::aryptr<u16> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.Bitset.fld1.qFind
inline u16&          fld1_qFind(atf_amc::Bitset& parent, u64 t) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
// func:atf_amc.Bitset.fld1.ReadStrptrMaybe
bool                 fld1_ReadStrptrMaybe(atf_amc::Bitset& parent, algo::strptr in_str) __attribute__((nothrow));

// Return constant 1
// func:atf_amc.Bitset.fld8.N
inline int           fld8_N(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.Bitset.fld8.qFind
inline u8&           fld8_qFind(atf_amc::Bitset& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.Bitset.fld8.NBits
inline int           fld8_Nbits(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld8.qGetBit
inline bool          fld8_qGetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.Bitset.fld8.GetBit
inline bool          fld8_GetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.Bitset.fld8.BitsEmptyQ
inline bool          fld8_BitsEmptyQ(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.Bitset.fld8.Sum1s
inline u64           fld8_Sum1s(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld8.qClearBit
inline void          fld8_qClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.Bitset.fld8.ClearBit
inline void          fld8_ClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld8.qSetBit
inline void          fld8_qSetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.Bitset.fld8.SetBit
inline void          fld8_SetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld8.qSetBitVal
inline void          fld8_qSetBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld8.qOrBitVal
inline void          fld8_qOrBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.Bitset.fld8.ClearBitsAll
inline void          fld8_ClearBitsAll(atf_amc::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.Bitset.fld8.ClearBits
inline void          fld8_ClearBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.Bitset.fld8.OrBits
inline void          fld8_OrBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.Bitset.fld8.Sup
inline i32           fld8_Sup(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));

// Return constant 1
// func:atf_amc.Bitset.fld64.N
inline int           fld64_N(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.Bitset.fld64.qFind
inline u64&          fld64_qFind(atf_amc::Bitset& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.Bitset.fld64.NBits
inline int           fld64_Nbits(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld64.qGetBit
inline bool          fld64_qGetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.Bitset.fld64.GetBit
inline bool          fld64_GetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.Bitset.fld64.BitsEmptyQ
inline bool          fld64_BitsEmptyQ(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.Bitset.fld64.Sum1s
inline u64           fld64_Sum1s(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld64.qClearBit
inline void          fld64_qClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.Bitset.fld64.ClearBit
inline void          fld64_ClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld64.qSetBit
inline void          fld64_qSetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.Bitset.fld64.SetBit
inline void          fld64_SetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld64.qSetBitVal
inline void          fld64_qSetBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld64.qOrBitVal
inline void          fld64_qOrBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.Bitset.fld64.ClearBitsAll
inline void          fld64_ClearBitsAll(atf_amc::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.Bitset.fld64.ClearBits
inline void          fld64_ClearBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.Bitset.fld64.OrBits
inline void          fld64_OrBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.Bitset.fld64.Sup
inline i32           fld64_Sup(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));

// Return constant 1
// func:atf_amc.Bitset.fld128.N
inline int           fld128_N(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.Bitset.fld128.qFind
inline u128&         fld128_qFind(atf_amc::Bitset& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.Bitset.fld128.NBits
inline int           fld128_Nbits(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld128.qGetBit
inline bool          fld128_qGetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.Bitset.fld128.GetBit
inline bool          fld128_GetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.Bitset.fld128.BitsEmptyQ
inline bool          fld128_BitsEmptyQ(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.Bitset.fld128.Sum1s
inline u64           fld128_Sum1s(atf_amc::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld128.qClearBit
inline void          fld128_qClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.Bitset.fld128.ClearBit
inline void          fld128_ClearBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld128.qSetBit
inline void          fld128_qSetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.Bitset.fld128.SetBit
inline void          fld128_SetBit(atf_amc::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld128.qSetBitVal
inline void          fld128_qSetBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.Bitset.fld128.qOrBitVal
inline void          fld128_qOrBitVal(atf_amc::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.Bitset.fld128.ClearBitsAll
inline void          fld128_ClearBitsAll(atf_amc::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.Bitset.fld128.ClearBits
inline void          fld128_ClearBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.Bitset.fld128.OrBits
inline void          fld128_OrBits(atf_amc::Bitset& parent, atf_amc::Bitset &rhs) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.Bitset.fld1_bitcurs.Next
void                 Bitset_fld1_bitcurs_Next(Bitset_fld1_bitcurs &curs);
// func:atf_amc.Bitset.fld1_bitcurs.Reset
inline void          Bitset_fld1_bitcurs_Reset(Bitset_fld1_bitcurs &curs, atf_amc::Bitset &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Bitset.fld1_bitcurs.ValidQ
inline bool          Bitset_fld1_bitcurs_ValidQ(Bitset_fld1_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.Bitset.fld1_bitcurs.Access
inline int&          Bitset_fld1_bitcurs_Access(Bitset_fld1_bitcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Bitset.fld1_curs.Reset
inline void          Bitset_fld1_curs_Reset(Bitset_fld1_curs &curs, atf_amc::Bitset &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Bitset.fld1_curs.ValidQ
inline bool          Bitset_fld1_curs_ValidQ(Bitset_fld1_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.Bitset.fld1_curs.Next
inline void          Bitset_fld1_curs_Next(Bitset_fld1_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.Bitset.fld1_curs.Access
inline u16&          Bitset_fld1_curs_Access(Bitset_fld1_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.Bitset.fld8_bitcurs.Next
void                 Bitset_fld8_bitcurs_Next(Bitset_fld8_bitcurs &curs);
// func:atf_amc.Bitset.fld8_bitcurs.Reset
inline void          Bitset_fld8_bitcurs_Reset(Bitset_fld8_bitcurs &curs, atf_amc::Bitset &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Bitset.fld8_bitcurs.ValidQ
inline bool          Bitset_fld8_bitcurs_ValidQ(Bitset_fld8_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.Bitset.fld8_bitcurs.Access
inline int&          Bitset_fld8_bitcurs_Access(Bitset_fld8_bitcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.Bitset.fld64_bitcurs.Next
void                 Bitset_fld64_bitcurs_Next(Bitset_fld64_bitcurs &curs);
// func:atf_amc.Bitset.fld64_bitcurs.Reset
inline void          Bitset_fld64_bitcurs_Reset(Bitset_fld64_bitcurs &curs, atf_amc::Bitset &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Bitset.fld64_bitcurs.ValidQ
inline bool          Bitset_fld64_bitcurs_ValidQ(Bitset_fld64_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.Bitset.fld64_bitcurs.Access
inline int&          Bitset_fld64_bitcurs_Access(Bitset_fld64_bitcurs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Bitset..Init
inline void          Bitset_Init(atf_amc::Bitset& parent);

// --- atf_amc.Bytebuf
// create: atf_amc.FDb.bytebuf (Cppstack)
struct Bytebuf { // atf_amc.Bytebuf
    u8              in_elems[64];      // pointer to elements of inline array
    i32             in_start;          // beginning of valid bytes (in bytes)
    i32             in_end;            // end of valid bytes (in bytes)
    bool            in_eof;            // no more data will be written to buffer
    algo::Errcode   in_err;            // system error code
    bool            in_msgvalid;       // current message is valid
    i32             in_msglen;         // current message length
    bool            in_epoll_enable;   // use epoll?
    enum { in_max = 64 };
    // func:atf_amc.Bytebuf..Ctor
    inline               Bytebuf() __attribute__((nothrow));
};

// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is any number of bytes > 0
//
// func:atf_amc.Bytebuf.in.GetMsg
algo::aryptr<char>   in_GetMsg(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_amc.Bytebuf.in.Max
inline i32           in_Max(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.Bytebuf.in.N
inline i32           in_N(atf_amc::Bytebuf& bytebuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.Bytebuf.in.RemoveAll
void                 in_RemoveAll(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_amc.Bytebuf.in.SkipBytes
void                 in_SkipBytes(atf_amc::Bytebuf& bytebuf, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.Bytebuf.in.SkipMsg
void                 in_SkipMsg(atf_amc::Bytebuf& bytebuf) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.Bytebuf.in.WriteAll
bool                 in_WriteAll(atf_amc::Bytebuf& bytebuf, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.Bytebuf..Init
void                 Bytebuf_Init(atf_amc::Bytebuf& bytebuf);
// print string representation of ROW to string STR
// cfmt:atf_amc.Bytebuf.String  printfmt:Raw
// func:atf_amc.Bytebuf..Print
void                 Bytebuf_Print(atf_amc::Bytebuf& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.BytebufDyn
// create: atf_amc.FDb.bytebuf_dyn (Cppstack)
struct BytebufDyn { // atf_amc.BytebufDyn
    u8*             in_elems;          //   NULL  pointer to elements of indirect array
    u32             in_max;            //   0  current length of allocated array
    i32             in_start;          // beginning of valid bytes (in bytes)
    i32             in_end;            // end of valid bytes (in bytes)
    bool            in_eof;            // no more data will be written to buffer
    algo::Errcode   in_err;            // system error code
    bool            in_msgvalid;       // current message is valid
    i32             in_msglen;         // current message length
    bool            in_epoll_enable;   // use epoll?
    // func:atf_amc.BytebufDyn..Ctor
    inline               BytebufDyn() __attribute__((nothrow));
    // func:atf_amc.BytebufDyn..Dtor
    inline               ~BytebufDyn() __attribute__((nothrow));
};

// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is any number of bytes > 0
//
// func:atf_amc.BytebufDyn.in.GetMsg
algo::aryptr<char>   in_GetMsg(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((nothrow));
// Set buffer size.
// Unconditionally reallocate buffer to have size NEW_MAX
// If the buffer has data in it, NEW_MAX is adjusted so that the data is not lost
// (best to call this before filling the buffer)
// func:atf_amc.BytebufDyn.in.Realloc
void                 in_Realloc(atf_amc::BytebufDyn& bytebuf_dyn, int new_max) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_amc.BytebufDyn.in.Max
inline i32           in_Max(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.BytebufDyn.in.N
inline i32           in_N(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((__warn_unused_result__, nothrow, pure));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.BytebufDyn.in.RemoveAll
void                 in_RemoveAll(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_amc.BytebufDyn.in.SkipBytes
void                 in_SkipBytes(atf_amc::BytebufDyn& bytebuf_dyn, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.BytebufDyn.in.SkipMsg
void                 in_SkipMsg(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.BytebufDyn.in.WriteAll
bool                 in_WriteAll(atf_amc::BytebufDyn& bytebuf_dyn, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.BytebufDyn..Init
void                 BytebufDyn_Init(atf_amc::BytebufDyn& bytebuf_dyn);
// func:atf_amc.BytebufDyn..Uninit
void                 BytebufDyn_Uninit(atf_amc::BytebufDyn& bytebuf_dyn) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.BytebufDyn.String  printfmt:Raw
// func:atf_amc.BytebufDyn..Print
void                 BytebufDyn_Print(atf_amc::BytebufDyn& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Cstr
// create: atf_amc.FPerfSortString.orig (Tary)
// create: atf_amc.FPerfSortString.sorted1 (Tary)
struct Cstr { // atf_amc.Cstr
    algo::cstring   val;   //
    // func:atf_amc.Cstr.val.Cast
    inline               operator algo::strptr() const __attribute__((nothrow));
    // func:atf_amc.Cstr..EqOp
    inline bool          operator ==(const atf_amc::Cstr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Cstr..NeOp
    inline bool          operator !=(const atf_amc::Cstr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Cstr..LtOp
    inline bool          operator <(const atf_amc::Cstr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Cstr..GtOp
    inline bool          operator >(const atf_amc::Cstr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Cstr..LeOp
    inline bool          operator <=(const atf_amc::Cstr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Cstr..GeOp
    inline bool          operator >=(const atf_amc::Cstr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Cstr..Ctor
    inline               Cstr() __attribute__((nothrow));
    // func:atf_amc.Cstr..FieldwiseCtor
    explicit inline               Cstr(const algo::strptr& in_val) __attribute__((nothrow));
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
// func:atf_amc.Cstr.val.Lt
inline bool          val_Lt(atf_amc::Cstr& parent, atf_amc::Cstr &rhs) __attribute__((nothrow));
// Compare two fields.
// func:atf_amc.Cstr.val.Cmp
inline i32           val_Cmp(atf_amc::Cstr& parent, atf_amc::Cstr &rhs) __attribute__((nothrow));

// func:atf_amc.Cstr..Hash
inline u32           Cstr_Hash(u32 prev, const atf_amc::Cstr& rhs) __attribute__((nothrow));
// func:atf_amc.Cstr..Lt
inline bool          Cstr_Lt(atf_amc::Cstr& lhs, atf_amc::Cstr& rhs) __attribute__((nothrow));
// func:atf_amc.Cstr..Cmp
inline i32           Cstr_Cmp(atf_amc::Cstr& lhs, atf_amc::Cstr& rhs) __attribute__((nothrow));
// func:atf_amc.Cstr..Eq
inline bool          Cstr_Eq(atf_amc::Cstr& lhs, atf_amc::Cstr& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.Cstr..Update
inline bool          Cstr_Update(atf_amc::Cstr &lhs, atf_amc::Cstr& rhs) __attribute__((nothrow));
// Create JSON representation of atf_amc::Cstr under PARENT node
// cfmt:atf_amc.Cstr.Json  printfmt:Auto
// func:atf_amc.Cstr..FmtJson
lib_json::FNode *    Cstr_FmtJson(atf_amc::Cstr& row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_amc.Cstring
// access: atf_amc.FCstring.msghdr (Base)
struct Cstring { // atf_amc.Cstring
    algo::cstring   str;   //
    // func:atf_amc.Cstring..Ctor
    inline               Cstring() __attribute__((nothrow));
};


// --- atf_amc.Ctype1Attr
struct Ctype1Attr { // atf_amc.Ctype1Attr
    u32   attr1;   //   0
    // func:atf_amc.Ctype1Attr.attr1.Cast
    inline               operator u32() const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..EqOp
    inline bool          operator ==(const atf_amc::Ctype1Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..NeOp
    inline bool          operator !=(const atf_amc::Ctype1Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..LtOp
    inline bool          operator <(const atf_amc::Ctype1Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..GtOp
    inline bool          operator >(const atf_amc::Ctype1Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..LeOp
    inline bool          operator <=(const atf_amc::Ctype1Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..GeOp
    inline bool          operator >=(const atf_amc::Ctype1Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..Ctor
    inline               Ctype1Attr() __attribute__((nothrow));
    // func:atf_amc.Ctype1Attr..FieldwiseCtor
    explicit inline               Ctype1Attr(u32 in_attr1) __attribute__((nothrow));
};

// func:atf_amc.Ctype1Attr..Hash
inline u32           Ctype1Attr_Hash(u32 prev, const atf_amc::Ctype1Attr& rhs) __attribute__((nothrow));
// Read fields of atf_amc::Ctype1Attr from an ascii string.
// The format of the string is the format of the atf_amc::Ctype1Attr's only field
// func:atf_amc.Ctype1Attr..ReadStrptrMaybe
bool                 Ctype1Attr_ReadStrptrMaybe(atf_amc::Ctype1Attr &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.Ctype1Attr..Lt
inline bool          Ctype1Attr_Lt(atf_amc::Ctype1Attr& lhs, atf_amc::Ctype1Attr& rhs) __attribute__((nothrow));
// func:atf_amc.Ctype1Attr..Cmp
inline i32           Ctype1Attr_Cmp(atf_amc::Ctype1Attr& lhs, atf_amc::Ctype1Attr& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Ctype1Attr..Init
inline void          Ctype1Attr_Init(atf_amc::Ctype1Attr& parent);
// func:atf_amc.Ctype1Attr..Eq
inline bool          Ctype1Attr_Eq(atf_amc::Ctype1Attr& lhs, atf_amc::Ctype1Attr& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.Ctype1Attr..Update
inline bool          Ctype1Attr_Update(atf_amc::Ctype1Attr &lhs, atf_amc::Ctype1Attr& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.Ctype1Attr.String  printfmt:Raw
// func:atf_amc.Ctype1Attr..Print
void                 Ctype1Attr_Print(atf_amc::Ctype1Attr& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Ctype2Attr
struct Ctype2Attr { // atf_amc.Ctype2Attr
    u32   attr1;   //   0
    u32   attr2;   //   0
    // func:atf_amc.Ctype2Attr..EqOp
    inline bool          operator ==(const atf_amc::Ctype2Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..NeOp
    inline bool          operator !=(const atf_amc::Ctype2Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..LtOp
    inline bool          operator <(const atf_amc::Ctype2Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..GtOp
    inline bool          operator >(const atf_amc::Ctype2Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..LeOp
    inline bool          operator <=(const atf_amc::Ctype2Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..GeOp
    inline bool          operator >=(const atf_amc::Ctype2Attr &rhs) const __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..Ctor
    inline               Ctype2Attr() __attribute__((nothrow));
    // func:atf_amc.Ctype2Attr..FieldwiseCtor
    explicit inline               Ctype2Attr(u32 in_attr1, u32 in_attr2) __attribute__((nothrow));
};

// func:atf_amc.Ctype2Attr..Hash
inline u32           Ctype2Attr_Hash(u32 prev, const atf_amc::Ctype2Attr& rhs) __attribute__((nothrow));
// func:atf_amc.Ctype2Attr..ReadFieldMaybe
bool                 Ctype2Attr_ReadFieldMaybe(atf_amc::Ctype2Attr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Ctype2Attr from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.Ctype2Attr..ReadStrptrMaybe
bool                 Ctype2Attr_ReadStrptrMaybe(atf_amc::Ctype2Attr &parent, algo::strptr in_str) __attribute__((nothrow));
// Read fields of atf_amc::Ctype2Attr from attributes of ascii tuple TUPLE
// func:atf_amc.Ctype2Attr..ReadTupleMaybe
bool                 Ctype2Attr_ReadTupleMaybe(atf_amc::Ctype2Attr &parent, algo::Tuple &tuple) __attribute__((nothrow));
// func:atf_amc.Ctype2Attr..Lt
inline bool          Ctype2Attr_Lt(atf_amc::Ctype2Attr& lhs, atf_amc::Ctype2Attr& rhs) __attribute__((nothrow));
// func:atf_amc.Ctype2Attr..Cmp
inline i32           Ctype2Attr_Cmp(atf_amc::Ctype2Attr& lhs, atf_amc::Ctype2Attr& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Ctype2Attr..Init
inline void          Ctype2Attr_Init(atf_amc::Ctype2Attr& parent);
// func:atf_amc.Ctype2Attr..Eq
inline bool          Ctype2Attr_Eq(atf_amc::Ctype2Attr& lhs, atf_amc::Ctype2Attr& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.Ctype2Attr..Update
inline bool          Ctype2Attr_Update(atf_amc::Ctype2Attr &lhs, atf_amc::Ctype2Attr& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.Ctype2Attr.String  printfmt:Tuple
// func:atf_amc.Ctype2Attr..Print
void                 Ctype2Attr_Print(atf_amc::Ctype2Attr& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Ctype2AttrAnon
struct Ctype2AttrAnon { // atf_amc.Ctype2AttrAnon
    u32   attr1;   //   0
    u32   attr2;   //   0
    // func:atf_amc.Ctype2AttrAnon..Ctor
    inline               Ctype2AttrAnon() __attribute__((nothrow));
    // func:atf_amc.Ctype2AttrAnon..FieldwiseCtor
    explicit inline               Ctype2AttrAnon(u32 in_attr1, u32 in_attr2) __attribute__((nothrow));
};

// func:atf_amc.Ctype2AttrAnon..ReadFieldMaybe
bool                 Ctype2AttrAnon_ReadFieldMaybe(atf_amc::Ctype2AttrAnon& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Ctype2AttrAnon from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.Ctype2AttrAnon..ReadStrptrMaybe
bool                 Ctype2AttrAnon_ReadStrptrMaybe(atf_amc::Ctype2AttrAnon &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Ctype2AttrAnon..Init
inline void          Ctype2AttrAnon_Init(atf_amc::Ctype2AttrAnon& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.Ctype2AttrAnon.String  printfmt:Tuple
// func:atf_amc.Ctype2AttrAnon..Print
void                 Ctype2AttrAnon_Print(atf_amc::Ctype2AttrAnon& row, algo::cstring& str) __attribute__((nothrow));
// func:atf_amc.Ctype2AttrAnon..GetAnon
algo::strptr         Ctype2AttrAnon_GetAnon(atf_amc::Ctype2AttrAnon &parent, i32 idx) __attribute__((nothrow));

// --- atf_amc.DelType1
struct DelType1 { // atf_amc.DelType1: Delptr test 1
    u32*   u32val;   // Private pointer to value
    // func:atf_amc.DelType1..Ctor
    inline               DelType1() __attribute__((nothrow));
    // func:atf_amc.DelType1..Dtor
    inline               ~DelType1() __attribute__((nothrow));
};

// Get or Create
// Access value, creating it if necessary. Process dies if not successful.
// func:atf_amc.DelType1.u32val.Access
u32&                 u32val_Access(atf_amc::DelType1& parent) __attribute__((nothrow));
// Delete value.
// func:atf_amc.DelType1.u32val.Delete
void                 u32val_Delete(atf_amc::DelType1& parent) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.DelType1..Init
inline void          DelType1_Init(atf_amc::DelType1& parent);
// func:atf_amc.DelType1..Uninit
void                 DelType1_Uninit(atf_amc::DelType1& parent) __attribute__((nothrow));

// --- atf_amc.DispCase
#pragma pack(push,1)
struct DispCase { // atf_amc.DispCase: Enum for dispatch atf_amc.Disp
    u32   value;   //   0
    // func:atf_amc.DispCase.value.Cast
    inline               operator atf_amc_DispCaseEnum() const __attribute__((nothrow));
    // func:atf_amc.DispCase..Ctor
    inline               DispCase() __attribute__((nothrow));
    // func:atf_amc.DispCase..FieldwiseCtor
    explicit inline               DispCase(u32 in_value) __attribute__((nothrow));
    // func:atf_amc.DispCase..EnumCtor
    inline               DispCase(atf_amc_DispCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.DispCase.value.GetEnum
inline atf_amc_DispCaseEnum value_GetEnum(const atf_amc::DispCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.DispCase.value.SetEnum
inline void          value_SetEnum(atf_amc::DispCase& parent, atf_amc_DispCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.DispCase.value.ToCstr
const char*          value_ToCstr(const atf_amc::DispCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.DispCase.value.Print
void                 value_Print(const atf_amc::DispCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.DispCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::DispCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.DispCase.value.SetStrptr
void                 value_SetStrptr(atf_amc::DispCase& parent, algo::strptr rhs, atf_amc_DispCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.DispCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::DispCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::DispCase from an ascii string.
// The format of the string is the format of the atf_amc::DispCase's only field
// func:atf_amc.DispCase..ReadStrptrMaybe
bool                 DispCase_ReadStrptrMaybe(atf_amc::DispCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.DispCase..Init
inline void          DispCase_Init(atf_amc::DispCase& parent);

// --- atf_amc.DispFilter
struct DispFilter { // atf_amc.DispFilter
    u64                pmask_elems[1];   //   0  fixed array
    algo::Smallstr20   strval;           //
    algo_lib::Regx     strval_regx;      //
    algo::Smallstr20   strval2;          //
    algo_lib::Regx     strval2_regx;     //
    algo::UnTime       start_dateval;    //
    algo::UnTime       end_dateval;      //
    algo::UnTime       dateval;          //
    u32                start_intval;     //   0
    u32                end_intval;       //   0
    u32                intval;           //   0
    // func:atf_amc.DispFilter..Ctor
    inline               DispFilter() __attribute__((nothrow));
};

// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.DispFilter.pmask.NBits
inline int           pmask_Nbits(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.DispFilter.pmask.qGetBit
inline bool          pmask_qGetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.DispFilter.pmask.GetBit
inline bool          pmask_GetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.DispFilter.pmask.BitsEmptyQ
inline bool          pmask_BitsEmptyQ(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.DispFilter.pmask.Sum1s
inline u64           pmask_Sum1s(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.DispFilter.pmask.qClearBit
inline void          pmask_qClearBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.DispFilter.pmask.ClearBit
inline void          pmask_ClearBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.DispFilter.pmask.qSetBit
inline void          pmask_qSetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.DispFilter.pmask.SetBit
inline void          pmask_SetBit(atf_amc::DispFilter& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.DispFilter.pmask.qSetBitVal
inline void          pmask_qSetBitVal(atf_amc::DispFilter& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.DispFilter.pmask.qOrBitVal
inline void          pmask_qOrBitVal(atf_amc::DispFilter& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.DispFilter.pmask.ClearBitsAll
inline void          pmask_ClearBitsAll(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.DispFilter.pmask.ClearBits
inline void          pmask_ClearBits(atf_amc::DispFilter& parent, atf_amc::DispFilter &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.DispFilter.pmask.OrBits
inline void          pmask_OrBits(atf_amc::DispFilter& parent, atf_amc::DispFilter &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.DispFilter.pmask.Sup
inline i32           pmask_Sup(atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
// func:atf_amc.DispFilter.pmask.Fill
inline void          pmask_Fill(atf_amc::DispFilter& parent, const u64 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.DispFilter.pmask.Find
inline u64*          pmask_Find(atf_amc::DispFilter& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array pmask as aryptr.
// func:atf_amc.DispFilter.pmask.Getary
inline algo::aryptr<u64> pmask_Getary(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return max number of items in the array
// func:atf_amc.DispFilter.pmask.Max
inline i32           pmask_Max(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.DispFilter.pmask.N
inline i32           pmask_N(const atf_amc::DispFilter& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
// func:atf_amc.DispFilter.pmask.Setary
inline void          pmask_Setary(atf_amc::DispFilter& parent, const algo::aryptr<u64> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.DispFilter.pmask.qFind
inline u64&          pmask_qFind(atf_amc::DispFilter& parent, u64 t) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
// func:atf_amc.DispFilter.pmask.ReadStrptrMaybe
bool                 pmask_ReadStrptrMaybe(atf_amc::DispFilter& parent, algo::strptr in_str) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.strval.PresentQ
inline bool          strval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.strval.SetPresent
inline void          strval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.strval.Present_GetBit
inline int           strval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.strval.Set
inline void          strval_Set(atf_amc::DispFilter& parent, const algo::strptr& rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.strval_regx.PresentQ
inline bool          strval_regx_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.strval_regx.SetPresent
inline void          strval_regx_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.strval_regx.Present_GetBit
inline int           strval_regx_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.strval2.PresentQ
inline bool          strval2_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.strval2.SetPresent
inline void          strval2_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.strval2.Present_GetBit
inline int           strval2_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.strval2.Set
inline void          strval2_Set(atf_amc::DispFilter& parent, const algo::strptr& rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.strval2_regx.PresentQ
inline bool          strval2_regx_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.strval2_regx.SetPresent
inline void          strval2_regx_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.strval2_regx.Present_GetBit
inline int           strval2_regx_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.start_dateval.PresentQ
inline bool          start_dateval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.start_dateval.SetPresent
inline void          start_dateval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.start_dateval.Present_GetBit
inline int           start_dateval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.start_dateval.Set
inline void          start_dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.end_dateval.PresentQ
inline bool          end_dateval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.end_dateval.SetPresent
inline void          end_dateval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.end_dateval.Present_GetBit
inline int           end_dateval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.end_dateval.Set
inline void          end_dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.dateval.PresentQ
inline bool          dateval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.dateval.SetPresent
inline void          dateval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.dateval.Present_GetBit
inline int           dateval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.dateval.Set
inline void          dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.start_intval.PresentQ
inline bool          start_intval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.start_intval.SetPresent
inline void          start_intval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.start_intval.Present_GetBit
inline int           start_intval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.start_intval.Set
inline void          start_intval_Set(atf_amc::DispFilter& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.end_intval.PresentQ
inline bool          end_intval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.end_intval.SetPresent
inline void          end_intval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.end_intval.Present_GetBit
inline int           end_intval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.end_intval.Set
inline void          end_intval_Set(atf_amc::DispFilter& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.DispFilter.intval.PresentQ
inline bool          intval_PresentQ(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.DispFilter.intval.SetPresent
inline void          intval_SetPresent(atf_amc::DispFilter& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.DispFilter.intval.Present_GetBit
inline int           intval_Present_GetBit(atf_amc::DispFilter& parent) __attribute__((nothrow));
// func:atf_amc.DispFilter.intval.Set
inline void          intval_Set(atf_amc::DispFilter& parent, u32 rhs) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.DispFilter.pmask_bitcurs.Next
void                 DispFilter_pmask_bitcurs_Next(DispFilter_pmask_bitcurs &curs);
// func:atf_amc.DispFilter.pmask_bitcurs.Reset
inline void          DispFilter_pmask_bitcurs_Reset(DispFilter_pmask_bitcurs &curs, atf_amc::DispFilter &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.DispFilter.pmask_bitcurs.ValidQ
inline bool          DispFilter_pmask_bitcurs_ValidQ(DispFilter_pmask_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.DispFilter.pmask_bitcurs.Access
inline int&          DispFilter_pmask_bitcurs_Access(DispFilter_pmask_bitcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.DispFilter.pmask_curs.Reset
inline void          DispFilter_pmask_curs_Reset(DispFilter_pmask_curs &curs, atf_amc::DispFilter &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.DispFilter.pmask_curs.ValidQ
inline bool          DispFilter_pmask_curs_ValidQ(DispFilter_pmask_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.DispFilter.pmask_curs.Next
inline void          DispFilter_pmask_curs_Next(DispFilter_pmask_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.DispFilter.pmask_curs.Access
inline u64&          DispFilter_pmask_curs_Access(DispFilter_pmask_curs &curs) __attribute__((nothrow));
// func:atf_amc.DispFilter..ReadFieldMaybe
bool                 DispFilter_ReadFieldMaybe(atf_amc::DispFilter& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::DispFilter from attributes of ascii tuple TUPLE
// func:atf_amc.DispFilter..ReadTupleMaybe
bool                 DispFilter_ReadTupleMaybe(atf_amc::DispFilter &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.DispFilter..Init
void                 DispFilter_Init(atf_amc::DispFilter& parent);
// func:atf_amc.DispFilter..MatchDispType1
bool                 DispFilter_MatchDispType1(atf_amc::DispFilter &parent, atf_amc::DispType1 &msg);
// func:atf_amc.DispFilter..MatchDispType2
bool                 DispFilter_MatchDispType2(atf_amc::DispFilter &parent, atf_amc::DispType2 &msg);
// func:atf_amc.DispFilter..MatchDispType3
bool                 DispFilter_MatchDispType3(atf_amc::DispFilter &parent, atf_amc::DispType3 &msg);

// --- atf_amc.DispType1
struct DispType1 { // atf_amc.DispType1: Dispfilter test 1
    algo::Smallstr20   strval;    //
    algo::Smallstr20   strval2;   //
    algo::UnTime       dateval;   //
    // func:atf_amc.DispType1..Ctor
    inline               DispType1() __attribute__((nothrow));
};

// func:atf_amc.DispType1..ReadFieldMaybe
bool                 DispType1_ReadFieldMaybe(atf_amc::DispType1& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::DispType1 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.DispType1..ReadStrptrMaybe
bool                 DispType1_ReadStrptrMaybe(atf_amc::DispType1 &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.DispType1.String  printfmt:Tuple
// func:atf_amc.DispType1..Print
void                 DispType1_Print(atf_amc::DispType1& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.DispType2
struct DispType2 { // atf_amc.DispType2: Dispfilter test 2
    u32   intval;   //   0
    // func:atf_amc.DispType2..Ctor
    inline               DispType2() __attribute__((nothrow));
};

// Read fields of atf_amc::DispType2 from an ascii string.
// The format of the string is the format of the atf_amc::DispType2's only field
// func:atf_amc.DispType2..ReadStrptrMaybe
bool                 DispType2_ReadStrptrMaybe(atf_amc::DispType2 &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.DispType2..Init
inline void          DispType2_Init(atf_amc::DispType2& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.DispType2.String  printfmt:Raw
// func:atf_amc.DispType2..Print
void                 DispType2_Print(atf_amc::DispType2& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.DispType3
struct DispType3 { // atf_amc.DispType3: Dispfilter test 3
    u32                intval;   //   0  Repeats type in DispType2
    algo::Smallstr20   strval;   // Repeats type in DispType1
    // func:atf_amc.DispType3..Ctor
    inline               DispType3() __attribute__((nothrow));
};

// func:atf_amc.DispType3..ReadFieldMaybe
bool                 DispType3_ReadFieldMaybe(atf_amc::DispType3& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::DispType3 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.DispType3..ReadStrptrMaybe
bool                 DispType3_ReadStrptrMaybe(atf_amc::DispType3 &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.DispType3..Init
inline void          DispType3_Init(atf_amc::DispType3& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.DispType3.String  printfmt:Tuple
// func:atf_amc.DispType3..Print
void                 DispType3_Print(atf_amc::DispType3& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FAmctest
// create: atf_amc.FDb.amctest (Lary)
// global access: amctest (Lary, by rowid)
struct FAmctest { // atf_amc.FAmctest: Test function
    algo::Smallstr50             amctest;    //
    algo::Comment                comment;    //
    bool                         select;     //   false  Select test for running?
    bool                         success;    //   false  Did it succeed?
    atf_amc::amctest_step_hook   step;       //   NULL  Pointer to a function
    lib_exec::FSyscmd*           c_syscmd;   // optional pointer
private:
    // func:atf_amc.FAmctest..Ctor
    inline               FAmctest() __attribute__((nothrow));
    friend atf_amc::FAmctest&   amctest_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FAmctest*   amctest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 amctest_RemoveAll() __attribute__((nothrow));
    friend void                 amctest_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FAmctest.msghdr.CopyOut
void                 amctest_CopyOut(atf_amc::FAmctest &row, atfdb::Amctest &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FAmctest.msghdr.CopyIn
void                 amctest_CopyIn(atf_amc::FAmctest &row, atfdb::Amctest &in) __attribute__((nothrow));

// Invoke function by pointer
// func:atf_amc.FAmctest.step.Call
inline void          step_Call(atf_amc::FAmctest& amctest) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FAmctest..Init
inline void          FAmctest_Init(atf_amc::FAmctest& amctest);
// print string representation of ROW to string STR
// cfmt:atf_amc.FAmctest.String  printfmt:Tuple
// func:atf_amc.FAmctest..Print
void                 FAmctest_Print(atf_amc::FAmctest& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FAvl
// create: atf_amc.FDb.avl (Lary)
// global access: avl (Lary, by rowid)
// global access: tr_avl (Atree, sort field n)
struct FAvl { // atf_amc.FAvl
    i32              n;              //   0
    atf_amc::FAvl*   tr_avl_up;      // pointer to parent
    atf_amc::FAvl*   tr_avl_left;    // Left child
    atf_amc::FAvl*   tr_avl_right;   // Right child
    i32              tr_avl_depth;   // Depth
    // func:atf_amc.FAvl..AssignOp
    inline atf_amc::FAvl& operator =(const atf_amc::FAvl &rhs) = delete;
    // func:atf_amc.FAvl..CopyCtor
    inline               FAvl(const atf_amc::FAvl &rhs) = delete;
private:
    // func:atf_amc.FAvl..Ctor
    inline               FAvl() __attribute__((nothrow));
    // func:atf_amc.FAvl..Dtor
    inline               ~FAvl() __attribute__((nothrow));
    friend atf_amc::FAvl&       avl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FAvl*       avl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 avl_RemoveAll() __attribute__((nothrow));
    friend void                 avl_RemoveLast() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:atf_amc.FAvl..Init
inline void          FAvl_Init(atf_amc::FAvl& avl);
// func:atf_amc.FAvl..Uninit
void                 FAvl_Uninit(atf_amc::FAvl& avl) __attribute__((nothrow));

// --- atf_amc.FCascdel
// create: atf_amc.FDb.cascdel (Tpool)
// access: atf_amc.FCascdel.p_parent (Upptr)
// access: atf_amc.FCascdel.child_ptr (Ptr)
// access: atf_amc.FCascdel.c_child_ptrary (Ptrary)
// access: atf_amc.FCascdel.ind_child_thash (Thash)
// access: atf_amc.FCascdel.bh_child_bheap (Bheap)
// access: atf_amc.FCascdel.zd_childlist (Llist)
// access: atf_amc.FCascdel.tr_child_atree (Atree)
struct FCascdel { // atf_amc.FCascdel: Test type for cascade delete
    atf_amc::FCascdel*    p_parent;                        // reference to parent row
    u32                   key;                             //   0
    u32                   type;                            //   0
    atf_amc::FCascdel*    child_ptr;                       // optional pointer
    atf_amc::FCascdel**   c_child_ptrary_elems;            // array of pointers
    u32                   c_child_ptrary_n;                // array of pointers
    u32                   c_child_ptrary_max;              // capacity of allocated array
    atf_amc::FCascdel**   ind_child_thash_buckets_elems;   // pointer to bucket array
    i32                   ind_child_thash_buckets_n;       // number of elements in bucket array
    i32                   ind_child_thash_n;               // number of elements in the hash table
    atf_amc::FCascdel*    ind_child_thash_next;            // hash next
    atf_amc::FCascdel**   bh_child_bheap_elems;            // binary heap by key
    i32                   bh_child_bheap_n;                // number of elements in the heap
    i32                   bh_child_bheap_max;              // max elements in bh_child_bheap_elems
    i32                   bh_child_bheap_idx;              // index in heap; -1 means not-in-heap
    atf_amc::FCascdel*    zd_childlist_head;               // zero-terminated doubly linked list
    i32                   zd_childlist_n;                  // zero-terminated doubly linked list
    atf_amc::FCascdel*    zd_childlist_tail;               // pointer to last element
    atf_amc::FCascdel*    zd_childlist_next;               // zslist link; -1 means not-in-list
    atf_amc::FCascdel*    zd_childlist_prev;               // previous element
    atf_amc::FCascdel*    tr_child_atree_root;             // Root of the tree
    i32                   tr_child_atree_n;                // number of elements in the tree
    atf_amc::FCascdel*    tr_child_atree_up;               // pointer to parent
    atf_amc::FCascdel*    tr_child_atree_left;             // Left child
    atf_amc::FCascdel*    tr_child_atree_right;            // Right child
    i32                   tr_child_atree_depth;            // Depth
    bool                  cascdel_c_child_ptrary_in_ary;   //   false  membership flag
    atf_amc::FCascdel*    cascdel_next;                    // Pointer to next free element int tpool
    // x-reference on atf_amc.FCascdel.child_ptr prevents copy
    // reftype Ptrary of atf_amc.FCascdel.c_child_ptrary prohibits copy
    // reftype Thash of atf_amc.FCascdel.ind_child_thash prohibits copy
    // reftype Bheap of atf_amc.FCascdel.bh_child_bheap prohibits copy
    // reftype Llist of atf_amc.FCascdel.zd_childlist prohibits copy
    // reftype Atree of atf_amc.FCascdel.tr_child_atree prohibits copy
    // func:atf_amc.FCascdel..AssignOp
    atf_amc::FCascdel&   operator =(const atf_amc::FCascdel &rhs) = delete;
    // x-reference on atf_amc.FCascdel.child_ptr prevents copy
    // reftype Ptrary of atf_amc.FCascdel.c_child_ptrary prohibits copy
    // reftype Thash of atf_amc.FCascdel.ind_child_thash prohibits copy
    // reftype Bheap of atf_amc.FCascdel.bh_child_bheap prohibits copy
    // reftype Llist of atf_amc.FCascdel.zd_childlist prohibits copy
    // reftype Atree of atf_amc.FCascdel.tr_child_atree prohibits copy
    // func:atf_amc.FCascdel..CopyCtor
    FCascdel(const atf_amc::FCascdel &rhs) = delete;
private:
    // func:atf_amc.FCascdel..Ctor
    inline               FCascdel() __attribute__((nothrow));
    // func:atf_amc.FCascdel..Dtor
    inline               ~FCascdel() __attribute__((nothrow));
    friend atf_amc::FCascdel&   cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FCascdel*   cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cascdel_Delete(atf_amc::FCascdel &row) __attribute__((nothrow));
};

// Declaration for user-defined cleanup function
// User-defined cleanup function invoked for field key of atf_amc::FCascdel
// func:atf_amc.FCascdel.key.Cleanup
// this function is 'extrn' and implemented by user
void                 key_Cleanup(atf_amc::FCascdel& cascdel) __attribute__((nothrow));

// Get value of field as enum type
// func:atf_amc.FCascdel.type.GetEnum
inline atf_amc_FCascdel_type_Enum type_GetEnum(const atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.FCascdel.type.SetEnum
inline void          type_SetEnum(atf_amc::FCascdel& cascdel, atf_amc_FCascdel_type_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.FCascdel.type.ToCstr
const char*          type_ToCstr(const atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
// func:atf_amc.FCascdel.type.Print
void                 type_Print(const atf_amc::FCascdel& cascdel, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.FCascdel.type.SetStrptrMaybe
bool                 type_SetStrptrMaybe(atf_amc::FCascdel& cascdel, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.FCascdel.type.SetStrptr
void                 type_SetStrptr(atf_amc::FCascdel& cascdel, algo::strptr rhs, atf_amc_FCascdel_type_Enum dflt) __attribute__((nothrow));

// Delete referred-to items.
// Deleted pointed-to item.
// func:atf_amc.FCascdel.child_ptr.Cascdel
void                 child_ptr_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Insert row into pointer index. Return final membership status.
// func:atf_amc.FCascdel.child_ptr.InsertMaybe
inline bool          child_ptr_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FCascdel.child_ptr.Remove
inline void          child_ptr_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));

// Delete all elements pointed to by the index.
// func:atf_amc.FCascdel.c_child_ptrary.Cascdel
void                 c_child_ptrary_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FCascdel.c_child_ptrary.EmptyQ
inline bool          c_child_ptrary_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FCascdel.c_child_ptrary.Find
inline atf_amc::FCascdel* c_child_ptrary_Find(atf_amc::FCascdel& cascdel, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:atf_amc.FCascdel.c_child_ptrary.Getary
inline algo::aryptr<atf_amc::FCascdel*> c_child_ptrary_Getary(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:atf_amc.FCascdel.c_child_ptrary.Insert
void                 c_child_ptrary_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:atf_amc.FCascdel.c_child_ptrary.InsertMaybe
bool                 c_child_ptrary_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:atf_amc.FCascdel.c_child_ptrary.N
inline i32           c_child_ptrary_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:atf_amc.FCascdel.c_child_ptrary.Remove
void                 c_child_ptrary_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FCascdel.c_child_ptrary.RemoveAll
inline void          c_child_ptrary_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:atf_amc.FCascdel.c_child_ptrary.Reserve
void                 c_child_ptrary_Reserve(atf_amc::FCascdel& cascdel, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:atf_amc.FCascdel.c_child_ptrary.qFind
inline atf_amc::FCascdel& c_child_ptrary_qFind(atf_amc::FCascdel& cascdel, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:atf_amc.FCascdel.c_child_ptrary.InAryQ
inline bool          cascdel_c_child_ptrary_InAryQ(atf_amc::FCascdel& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:atf_amc.FCascdel.c_child_ptrary.qLast
inline atf_amc::FCascdel& c_child_ptrary_qLast(atf_amc::FCascdel& cascdel) __attribute__((nothrow));

// Delete all rows reachable through the hash index
// func:atf_amc.FCascdel.ind_child_thash.Cascdel
void                 ind_child_thash_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if hash is empty
// func:atf_amc.FCascdel.ind_child_thash.EmptyQ
inline bool          ind_child_thash_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_amc.FCascdel.ind_child_thash.Find
atf_amc::FCascdel*   ind_child_thash_Find(atf_amc::FCascdel& cascdel, u32 key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:atf_amc.FCascdel.ind_child_thash.N
inline i32           ind_child_thash_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_amc.FCascdel.ind_child_thash.InsertMaybe
bool                 ind_child_thash_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_amc.FCascdel.ind_child_thash.Remove
void                 ind_child_thash_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_amc.FCascdel.ind_child_thash.Reserve
void                 ind_child_thash_Reserve(atf_amc::FCascdel& cascdel, int n) __attribute__((nothrow));

// Delete referred-to items.
// Delete all elements referenced by the heap.
// func:atf_amc.FCascdel.bh_child_bheap.Cascdel
void                 bh_child_bheap_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Remove all elements from heap and free memory used by the array.
// func:atf_amc.FCascdel.bh_child_bheap.Dealloc
void                 bh_child_bheap_Dealloc(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FCascdel.bh_child_bheap.EmptyQ
inline bool          bh_child_bheap_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FCascdel.bh_child_bheap.First
inline atf_amc::FCascdel* bh_child_bheap_First(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:atf_amc.FCascdel.bh_child_bheap.InBheapQ
inline bool          bh_child_bheap_InBheapQ(atf_amc::FCascdel& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:atf_amc.FCascdel.bh_child_bheap.Insert
void                 bh_child_bheap_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Return number of items in the heap
// func:atf_amc.FCascdel.bh_child_bheap.N
inline i32           bh_child_bheap_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:atf_amc.FCascdel.bh_child_bheap.Reheap
i32                  bh_child_bheap_Reheap(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:atf_amc.FCascdel.bh_child_bheap.ReheapFirst
i32                  bh_child_bheap_ReheapFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FCascdel.bh_child_bheap.Remove
void                 bh_child_bheap_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:atf_amc.FCascdel.bh_child_bheap.RemoveAll
void                 bh_child_bheap_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:atf_amc.FCascdel.bh_child_bheap.RemoveFirst
atf_amc::FCascdel*   bh_child_bheap_RemoveFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Reserve space in index for N more elements
// func:atf_amc.FCascdel.bh_child_bheap.Reserve
void                 bh_child_bheap_Reserve(atf_amc::FCascdel& cascdel, int n) __attribute__((nothrow));
// Set row key to new value.
// Update heap membership based on insert condition [row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap]
// func:atf_amc.FCascdel.bh_child_bheap.Set
void                 key_Set(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &row, u32 new_key) __attribute__((nothrow));
// Set row key to new value. If row not in heap, the key is set to new value
// Otherwise, the key is changed only if the new key is better than the old.
// Update heap membership based on insert condition [row.p_parent != &row && row.type==atf_amc_FCascdel_type_bheap]
// func:atf_amc.FCascdel.bh_child_bheap.SetIfBetter
void                 key_SetIfBetter(atf_amc::FCascdel& cascdel, atf_amc::FCascdel &row, u32 new_key) __attribute__((nothrow));

// Delete all elements in the linked list.
// func:atf_amc.FCascdel.zd_childlist.Cascdel
void                 zd_childlist_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FCascdel.zd_childlist.EmptyQ
inline bool          zd_childlist_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FCascdel.zd_childlist.First
inline atf_amc::FCascdel* zd_childlist_First(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FCascdel.zd_childlist.InLlistQ
inline bool          zd_childlist_InLlistQ(atf_amc::FCascdel& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FCascdel.zd_childlist.Insert
void                 zd_childlist_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FCascdel.zd_childlist.Last
inline atf_amc::FCascdel* zd_childlist_Last(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FCascdel.zd_childlist.N
inline i32           zd_childlist_N(const atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FCascdel.zd_childlist.Next
inline atf_amc::FCascdel* zd_childlist_Next(atf_amc::FCascdel &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FCascdel.zd_childlist.Prev
inline atf_amc::FCascdel* zd_childlist_Prev(atf_amc::FCascdel &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FCascdel.zd_childlist.Remove
void                 zd_childlist_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FCascdel.zd_childlist.RemoveAll
void                 zd_childlist_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FCascdel.zd_childlist.RemoveFirst
atf_amc::FCascdel*   zd_childlist_RemoveFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FCascdel.zd_childlist.qLast
inline atf_amc::FCascdel& zd_childlist_qLast(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));

// Delete all elements in the tree.
// func:atf_amc.FCascdel.tr_child_atree.Cascdel
void                 tr_child_atree_Cascdel(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FCascdel.tr_child_atree.EmptyQ
inline bool          tr_child_atree_EmptyQ(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FCascdel.tr_child_atree.FirstImpl
atf_amc::FCascdel*   tr_child_atree_FirstImpl(atf_amc::FCascdel* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the first(smallest) element in the tree
// func:atf_amc.FCascdel.tr_child_atree.First
atf_amc::FCascdel*   tr_child_atree_First(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
// Return true if row is in the tree, false otherwise
// func:atf_amc.FCascdel.tr_child_atree.InTreeQ
inline bool          tr_child_atree_InTreeQ(atf_amc::FCascdel& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
// func:atf_amc.FCascdel.tr_child_atree.InsertImpl
void                 tr_child_atree_InsertImpl(atf_amc::FCascdel& cascdel, atf_amc::FCascdel* parent, atf_amc::FCascdel& row) __attribute__((nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
// func:atf_amc.FCascdel.tr_child_atree.Insert
void                 tr_child_atree_Insert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FCascdel.tr_child_atree.Remove
void                 tr_child_atree_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FCascdel.tr_child_atree.RemoveAll
inline void          tr_child_atree_RemoveAll(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FCascdel.tr_child_atree.RemoveFirst
void                 tr_child_atree_RemoveFirst(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// func:atf_amc.FCascdel.tr_child_atree.Balance
i32                  tr_child_atree_Balance(atf_amc::FCascdel& row) __attribute__((nothrow));
// Recalculate depth and keep rebalancing if needed
// func:atf_amc.FCascdel.tr_child_atree.Propagate
atf_amc::FCascdel*   tr_child_atree_Propagate(atf_amc::FCascdel& pnode) __attribute__((nothrow));
// Rebalances the node if needed.
// func:atf_amc.FCascdel.tr_child_atree.Rebalance
void                 tr_child_atree_Rebalance(atf_amc::FCascdel& node) __attribute__((nothrow));
// func:atf_amc.FCascdel.tr_child_atree.Next
atf_amc::FCascdel*   tr_child_atree_Next(atf_amc::FCascdel& node) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FCascdel.tr_child_atree.Prev
atf_amc::FCascdel*   tr_child_atree_Prev(atf_amc::FCascdel& node) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FCascdel.tr_child_atree.LastImpl
atf_amc::FCascdel*   tr_child_atree_LastImpl(atf_amc::FCascdel* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the last(largest) element in tree
// func:atf_amc.FCascdel.tr_child_atree.Last
atf_amc::FCascdel*   tr_child_atree_Last(atf_amc::FCascdel& cascdel) __attribute__((__warn_unused_result__, nothrow));
// Empty the index. (rows may be deleted if cascdel)
// func:atf_amc.FCascdel.tr_child_atree.RemoveAllImpl
void                 tr_child_atree_RemoveAllImpl(atf_amc::FCascdel& cascdel, atf_amc::FCascdel* root, bool del) __attribute__((nothrow));
// Reinsert a row with modified key(Reheap semantics)
// func:atf_amc.FCascdel.tr_child_atree.Reinsert
void                 tr_child_atree_Reinsert(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& node) __attribute__((nothrow));
// Find the first element that is greater or equal to a sortfld value
// func:atf_amc.FCascdel.tr_child_atree.FirstGe
atf_amc::FCascdel*   tr_child_atree_FirstGe(atf_amc::FCascdel& cascdel, const u32& val) __attribute__((nothrow));
// Find the last element that is smaller or equal to a sortfld value
// func:atf_amc.FCascdel.tr_child_atree.LastLt
atf_amc::FCascdel*   tr_child_atree_LastLt(atf_amc::FCascdel& cascdel, const u32& val) __attribute__((nothrow));

// func:atf_amc.FCascdel.c_child_ptrary_curs.Reset
inline void          cascdel_c_child_ptrary_curs_Reset(cascdel_c_child_ptrary_curs &curs, atf_amc::FCascdel &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FCascdel.c_child_ptrary_curs.ValidQ
inline bool          cascdel_c_child_ptrary_curs_ValidQ(cascdel_c_child_ptrary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FCascdel.c_child_ptrary_curs.Next
inline void          cascdel_c_child_ptrary_curs_Next(cascdel_c_child_ptrary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FCascdel.c_child_ptrary_curs.Access
inline atf_amc::FCascdel& cascdel_c_child_ptrary_curs_Access(cascdel_c_child_ptrary_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.FCascdel..Init
void                 FCascdel_Init(atf_amc::FCascdel& cascdel);
// func:atf_amc.FCascdel.bh_child_bheap_curs.Reserve
void                 cascdel_bh_child_bheap_curs_Reserve(cascdel_bh_child_bheap_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:atf_amc.FCascdel.bh_child_bheap_curs.Reset
void                 cascdel_bh_child_bheap_curs_Reset(cascdel_bh_child_bheap_curs &curs, atf_amc::FCascdel &parent);
// Advance cursor.
// func:atf_amc.FCascdel.bh_child_bheap_curs.Next
void                 cascdel_bh_child_bheap_curs_Next(cascdel_bh_child_bheap_curs &curs);
// Access current element. If not more elements, return NULL
// func:atf_amc.FCascdel.bh_child_bheap_curs.Access
inline atf_amc::FCascdel& cascdel_bh_child_bheap_curs_Access(cascdel_bh_child_bheap_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:atf_amc.FCascdel.bh_child_bheap_curs.ValidQ
inline bool          cascdel_bh_child_bheap_curs_ValidQ(cascdel_bh_child_bheap_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FCascdel.zd_childlist_curs.Reset
inline void          cascdel_zd_childlist_curs_Reset(cascdel_zd_childlist_curs &curs, atf_amc::FCascdel &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FCascdel.zd_childlist_curs.ValidQ
inline bool          cascdel_zd_childlist_curs_ValidQ(cascdel_zd_childlist_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FCascdel.zd_childlist_curs.Next
inline void          cascdel_zd_childlist_curs_Next(cascdel_zd_childlist_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FCascdel.zd_childlist_curs.Access
inline atf_amc::FCascdel& cascdel_zd_childlist_curs_Access(cascdel_zd_childlist_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FCascdel.tr_child_atree_curs.Reset
inline void          cascdel_tr_child_atree_curs_Reset(cascdel_tr_child_atree_curs &curs, atf_amc::FCascdel& parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FCascdel.tr_child_atree_curs.ValidQ
inline bool          cascdel_tr_child_atree_curs_ValidQ(cascdel_tr_child_atree_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FCascdel.tr_child_atree_curs.Next
inline void          cascdel_tr_child_atree_curs_Next(cascdel_tr_child_atree_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FCascdel.tr_child_atree_curs.Access
inline atf_amc::FCascdel& cascdel_tr_child_atree_curs_Access(cascdel_tr_child_atree_curs &curs) __attribute__((nothrow));
// func:atf_amc.FCascdel..Uninit
void                 FCascdel_Uninit(atf_amc::FCascdel& cascdel) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FCascdel.String  printfmt:Tuple
// func:atf_amc.FCascdel..Print
void                 FCascdel_Print(atf_amc::FCascdel& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FCstring
// create: atf_amc.FDb.cstring (Lary)
// global access: cstring (Lary, by rowid)
// global access: ind_cstring (Thash, hash field str)
struct FCstring { // atf_amc.FCstring
    algo::cstring        str;                //
    atf_amc::FCstring*   ind_cstring_next;   // hash next
    // func:atf_amc.FCstring..AssignOp
    inline atf_amc::FCstring& operator =(const atf_amc::FCstring &rhs) = delete;
    // func:atf_amc.FCstring..CopyCtor
    inline               FCstring(const atf_amc::FCstring &rhs) = delete;
private:
    // func:atf_amc.FCstring..Ctor
    inline               FCstring() __attribute__((nothrow));
    // func:atf_amc.FCstring..Dtor
    inline               ~FCstring() __attribute__((nothrow));
    friend atf_amc::FCstring&   cstring_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FCstring*   cstring_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstring_RemoveAll() __attribute__((nothrow));
    friend void                 cstring_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FCstring.msghdr.CopyOut
void                 cstring_CopyOut(atf_amc::FCstring &row, atf_amc::Cstring &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FCstring.msghdr.CopyIn
void                 cstring_CopyIn(atf_amc::FCstring &row, atf_amc::Cstring &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FCstring..Init
inline void          FCstring_Init(atf_amc::FCstring& cstring);
// func:atf_amc.FCstring..Uninit
void                 FCstring_Uninit(atf_amc::FCstring& cstring) __attribute__((nothrow));

// --- atf_amc.FListtype
// create: atf_amc.FDb.listtype (Inlary)
// access: atf_amc.FListtype.step (Hook)
struct FListtype { // atf_amc.FListtype
    algo::Smallstr5               listtype;   //
    bool                          circular;   //   false  Circular list
    bool                          haveprev;   //   false  Previous link
    bool                          instail;    //   false  Queue
    algo::Comment                 comment;    //
    atf_amc::listtype_step_hook   step;       //   NULL  Pointer to a function
    bool                          seen;       //   false
    // func:atf_amc.FListtype..Ctor
    inline               FListtype() __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FListtype.base.CopyOut
void                 listtype_CopyOut(atf_amc::FListtype &row, dmmeta::Listtype &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FListtype.base.CopyIn
void                 listtype_CopyIn(atf_amc::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Invoke function by pointer
// func:atf_amc.FListtype.step.Call
inline void          step_Call(atf_amc::FListtype& listtype, atf_amc::FListtype& arg) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FListtype..Init
inline void          FListtype_Init(atf_amc::FListtype& listtype);

// --- atf_amc.trace
#pragma pack(push,1)
struct trace { // atf_amc.trace
    u64   step_bh_typec;             //   0
    u64   step_bh_typec_cycles;      //   0
    u64   step_zsl_h_typec;          //   0
    u64   step_zsl_h_typec_cycles;   //   0
    u64   step_zs_t_typec;           //   0
    u64   step_zs_t_typec_cycles;    //   0
    u64   step_csl_h_typec;          //   0
    u64   step_csl_h_typec_cycles;   //   0
    u64   step_cs_t_typec;           //   0
    u64   step_cs_t_typec_cycles;    //   0
    u64   step_cd_in_msg;            //   0
    u64   step_cd_in_msg_cycles;     //   0
    // func:atf_amc.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)

// Set all fields to initial values.
// func:atf_amc.trace..Init
void                 trace_Init(atf_amc::trace& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.trace.String  printfmt:Tuple
// func:atf_amc.trace..Print
void                 trace_Print(atf_amc::trace& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FDb
// create: atf_amc.FDb._db (Global)
struct FDb { // atf_amc.FDb: In-memory database for atf_amc
    command::atf_amc         cmdline;                                          //
    atf_amc::FTypeC**        bh_typec_elems;                                   // binary heap by typec
    i32                      bh_typec_n;                                       // number of elements in the heap
    i32                      bh_typec_max;                                     // max elements in bh_typec_elems
    atf_amc::FTypeC*         zdl_h_typec_head;                                 // zero-terminated doubly linked list
    i32                      zdl_h_typec_n;                                    // zero-terminated doubly linked list
    atf_amc::FTypeC*         zdl_h_typec_tail;                                 // pointer to last element
    atf_amc::FTypeC*         zd_t_typec_head;                                  // zero-terminated doubly linked list
    i32                      zd_t_typec_n;                                     // zero-terminated doubly linked list
    atf_amc::FTypeC*         zd_t_typec_tail;                                  // pointer to last element
    atf_amc::FTypeD*         zd_typed_head;                                    // zero-terminated doubly linked list
    i32                      zd_typed_n;                                       // zero-terminated doubly linked list
    atf_amc::FTypeD*         zd_typed_tail;                                    // pointer to last element
    atf_amc::FTypeD*         zs_t_typed_head;                                  // zero-terminated singly linked list
    i32                      zs_t_typed_n;                                     // zero-terminated singly linked list
    atf_amc::FTypeD*         zs_t_typed_tail;                                  // pointer to last element
    atf_amc::FTypeD*         cd_typed_head;                                    // zero-terminated doubly linked list
    i32                      cd_typed_n;                                       // zero-terminated doubly linked list
    atf_amc::FTypeC*         zsl_h_typec_head;                                 // zero-terminated singly linked list
    i32                      zsl_h_typec_n;                                    // zero-terminated singly linked list
    atf_amc::FTypeC*         zsl_h_typec_tail;                                 // pointer to last element
    atf_amc::FTypeC*         zs_t_typec_head;                                  // zero-terminated singly linked list
    i32                      zs_t_typec_n;                                     // zero-terminated singly linked list
    atf_amc::FTypeC*         zs_t_typec_tail;                                  // pointer to last element

    atf_amc::FTypeC*         zs_mt_typec_head;                                 // ZSListMT - zero-terminated singly linked list -- read side
    atf_amc::FTypeC*         zs_mt_typec_mt;                                   // elements inserted here from another thread -- write side
    atf_amc::FTypeC*         zdl_hnt_typec_head;                               // zero-terminated doubly linked list
    i32                      zdl_hnt_typec_n;                                  // zero-terminated doubly linked list
    atf_amc::FTypeC*         cdl_h_typec_head;                                 // zero-terminated doubly linked list
    i32                      cdl_h_typec_n;                                    // zero-terminated doubly linked list
    atf_amc::FTypeC*         cd_t_typec_head;                                  // zero-terminated doubly linked list
    i32                      cd_t_typec_n;                                     // zero-terminated doubly linked list
    atf_amc::FTypeC*         csl_h_typec_head;                                 // zero-terminated singly linked list
    i32                      csl_h_typec_n;                                    // zero-terminated singly linked list
    atf_amc::FTypeC*         csl_h_typec_tail;                                 // pointer to last element
    atf_amc::FTypeC*         cs_t_typec_head;                                  // zero-terminated singly linked list
    i32                      cs_t_typec_n;                                     // zero-terminated singly linked list
    atf_amc::FTypeC*         cs_t_typec_tail;                                  // pointer to last element
    atf_amc::FTypeA*         typea_lary[32];                                   // level array
    i32                      typea_n;                                          // number of elements in array
    atf_amc::FTypeS*         types_lary[32];                                   // level array
    i32                      types_n;                                          // number of elements in array
    atf_amc::FTypeS**        ind_types_buckets_elems;                          // pointer to bucket array
    i32                      ind_types_buckets_n;                              // number of elements in bucket array
    i32                      ind_types_n;                                      // number of elements in the hash table
    atf_amc::FTypeA**        ind_typea_buckets_elems;                          // pointer to bucket array
    i32                      ind_typea_buckets_n;                              // number of elements in bucket array
    i32                      ind_typea_n;                                      // number of elements in the hash table
    i32                      cs_h_count;                                       //   0  FirstChanged trigger fire count
    i32                      cs_t_count;                                       //   0  FirstChanged trigger fire count
    i32                      zs_h_count;                                       //   0  FirstChanged trigger fire count
    i32                      zs_t_count;                                       //   0  FirstChanged trigger fire count
    i32                      zs_mt_count;                                      //   0  FirstChanged trigger fire count
    i32                      bh_count;                                         //   0  FirstChanged trigger fire count
    atf_amc::FTypeT*         typet_lary[32];                                   // level array
    i32                      typet_n;                                          // number of elements in array
    atf_amc::FCstring*       cstring_lary[32];                                 // level array
    i32                      cstring_n;                                        // number of elements in array
    atf_amc::FCstring**      ind_cstring_buckets_elems;                        // pointer to bucket array
    i32                      ind_cstring_buckets_n;                            // number of elements in bucket array
    i32                      ind_cstring_n;                                    // number of elements in the hash table
    atf_amc::Msgbuf*         cd_in_msg_head;                                   // zero-terminated doubly linked list
    u64                      typeb_blocksize;                                  // # bytes per block
    atf_amc::FTypeB*         typeb_free;                                       //
    u64                      pooledbe64_blocksize;                             // # bytes per block
    atf_amc::PooledBE64*     pooledbe64_free;                                  //
    i64                      varlen_extern_n;                                  // Number of elements
    varlen_extern_Lpblock*   varlen_extern_free[36];                           // Lpool levels
    atf_amc::FAmctest*       amctest_lary[32];                                 // level array
    i32                      amctest_n;                                        // number of elements in array
    u64                      cascdel_blocksize;                                // # bytes per block
    atf_amc::FCascdel*       cascdel_free;                                     //
    algo_lib::Bitset         cascdel_check;                                    // Bitset of FCascdel records in existence
    u32                      cascdel_next_key;                                 //   0  Next sequence number for FCascdel record
    i64                      optalloc_n;                                       // Number of elements
    optalloc_Lpblock*        optalloc_free[36];                                // Lpool levels
    i64                      varlenalloc_n;                                    // Number of elements
    varlenalloc_Lpblock*     varlenalloc_free[36];                             // Lpool levels
    i64                      optg_n;                                           // Number of elements
    optg_Lpblock*            optg_free[36];                                    // Lpool levels
    atf_amc::FTypeK**        c_typek_elems;                                    // array of pointers
    u32                      c_typek_n;                                        // array of pointers
    u32                      c_typek_max;                                      // capacity of allocated array
    atf_amc::FAvl*           avl_lary[32];                                     // level array
    i32                      avl_n;                                            // number of elements in array
    atf_amc::FAvl*           tr_avl_root;                                      // Root of the tree
    i32                      tr_avl_n;                                         // number of elements in the tree
    u128                     listtype_data[sizeu128(atf_amc::FListtype,10)];   // place for data
    i32                      listtype_n;                                       // number of elems current in existence
    enum { listtype_max = 10 };
    bool                     dofork;                                           //   false
    u64                      typed_blocksize;                                  // # bytes per block
    atf_amc::FTypeD*         typed_free;                                       //
    atf_amc::FThashElem**    ind_thash_elem_buckets_elems;                     // pointer to bucket array
    i32                      ind_thash_elem_buckets_n;                         // number of elements in bucket array
    i32                      ind_thash_elem_n;                                 // number of elements in the hash table
    atf_amc::FThashElem*     thash_elem_lary[32];                              // level array
    i32                      thash_elem_n;                                     // number of elements in array
    atf_amc::trace           trace;                                            //
};

// Remove all elements from heap and free memory used by the array.
// func:atf_amc.FDb.bh_typec.Dealloc
void                 bh_typec_Dealloc() __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FDb.bh_typec.EmptyQ
inline bool          bh_typec_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.bh_typec.First
inline atf_amc::FTypeC* bh_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:atf_amc.FDb.bh_typec.InBheapQ
inline bool          bh_typec_InBheapQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:atf_amc.FDb.bh_typec.Insert
void                 bh_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// Return number of items in the heap
// func:atf_amc.FDb.bh_typec.N
inline i32           bh_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// If first item of the is changed, update fstep:atf_amc.FDb.bh_typec
// func:atf_amc.FDb.bh_typec.Reheap
i32                  bh_typec_Reheap(atf_amc::FTypeC& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// Update fstep:atf_amc.FDb.bh_typec
// func:atf_amc.FDb.bh_typec.ReheapFirst
i32                  bh_typec_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.bh_typec.Remove
void                 bh_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:atf_amc.FDb.bh_typec.RemoveAll
void                 bh_typec_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:atf_amc.FDb.bh_typec.RemoveFirst
atf_amc::FTypeC*     bh_typec_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
// func:atf_amc.FDb.bh_typec.Reserve
void                 bh_typec_Reserve(int n) __attribute__((nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
// func:atf_amc.FDb.bh_typec.FirstChanged
// this function is 'extrn' and implemented by user
void                 bh_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:atf_amc.FDb.bh_typec.UpdateCycles
void                 bh_typec_UpdateCycles() __attribute__((nothrow));
// func:atf_amc.FDb.bh_typec.Step
// this function is 'extrn' and implemented by user
void                 bh_typec_Step() __attribute__((nothrow));
// func:atf_amc.FDb.bh_typec.Call
inline void          bh_typec_Call() __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zdl_h_typec.EmptyQ
inline bool          zdl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zdl_h_typec.First
inline atf_amc::FTypeC* zdl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zdl_h_typec.InLlistQ
inline bool          zdl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zdl_h_typec.Insert
void                 zdl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.zdl_h_typec.Last
inline atf_amc::FTypeC* zdl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.zdl_h_typec.N
inline i32           zdl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zdl_h_typec.Next
inline atf_amc::FTypeC* zdl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.zdl_h_typec.Prev
inline atf_amc::FTypeC* zdl_h_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.zdl_h_typec.Remove
void                 zdl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zdl_h_typec.RemoveAll
void                 zdl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.zdl_h_typec.RemoveFirst
atf_amc::FTypeC*     zdl_h_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.zdl_h_typec.qLast
inline atf_amc::FTypeC& zdl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zd_t_typec.EmptyQ
inline bool          zd_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zd_t_typec.First
inline atf_amc::FTypeC* zd_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zd_t_typec.InLlistQ
inline bool          zd_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zd_t_typec.Insert
void                 zd_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.zd_t_typec.Last
inline atf_amc::FTypeC* zd_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.zd_t_typec.N
inline i32           zd_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zd_t_typec.Next
inline atf_amc::FTypeC* zd_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.zd_t_typec.Prev
inline atf_amc::FTypeC* zd_t_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.zd_t_typec.Remove
void                 zd_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zd_t_typec.RemoveAll
void                 zd_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.zd_t_typec.RemoveFirst
atf_amc::FTypeC*     zd_t_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.zd_t_typec.qLast
inline atf_amc::FTypeC& zd_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zd_typed.EmptyQ
inline bool          zd_typed_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zd_typed.First
inline atf_amc::FTypeD* zd_typed_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zd_typed.InLlistQ
inline bool          zd_typed_InLlistQ(atf_amc::FTypeD& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zd_typed.Insert
void                 zd_typed_Insert(atf_amc::FTypeD& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.zd_typed.Last
inline atf_amc::FTypeD* zd_typed_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.zd_typed.N
inline i32           zd_typed_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zd_typed.Next
inline atf_amc::FTypeD* zd_typed_Next(atf_amc::FTypeD &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.zd_typed.Prev
inline atf_amc::FTypeD* zd_typed_Prev(atf_amc::FTypeD &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.zd_typed.Remove
void                 zd_typed_Remove(atf_amc::FTypeD& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zd_typed.RemoveAll
void                 zd_typed_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.zd_typed.RemoveFirst
atf_amc::FTypeD*     zd_typed_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.zd_typed.qLast
inline atf_amc::FTypeD& zd_typed_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zs_t_typed.EmptyQ
inline bool          zs_t_typed_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zs_t_typed.First
inline atf_amc::FTypeD* zs_t_typed_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zs_t_typed.InLlistQ
inline bool          zs_t_typed_InLlistQ(atf_amc::FTypeD& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zs_t_typed.Insert
void                 zs_t_typed_Insert(atf_amc::FTypeD& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.zs_t_typed.Last
inline atf_amc::FTypeD* zs_t_typed_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.zs_t_typed.N
inline i32           zs_t_typed_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zs_t_typed.Next
inline atf_amc::FTypeD* zs_t_typed_Next(atf_amc::FTypeD &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:atf_amc.FDb.zs_t_typed.Remove
void                 zs_t_typed_Remove(atf_amc::FTypeD& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zs_t_typed.RemoveAll
void                 zs_t_typed_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.zs_t_typed.RemoveFirst
atf_amc::FTypeD*     zs_t_typed_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.zs_t_typed.qLast
inline atf_amc::FTypeD& zs_t_typed_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.cd_typed.EmptyQ
inline bool          cd_typed_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.cd_typed.First
inline atf_amc::FTypeD* cd_typed_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.cd_typed.InLlistQ
inline bool          cd_typed_InLlistQ(atf_amc::FTypeD& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.cd_typed.Insert
void                 cd_typed_Insert(atf_amc::FTypeD& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.cd_typed.Last
inline atf_amc::FTypeD* cd_typed_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.cd_typed.N
inline i32           cd_typed_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.cd_typed.Next
inline atf_amc::FTypeD* cd_typed_Next(atf_amc::FTypeD &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.cd_typed.Prev
inline atf_amc::FTypeD* cd_typed_Prev(atf_amc::FTypeD &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.cd_typed.Remove
void                 cd_typed_Remove(atf_amc::FTypeD& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.cd_typed.RemoveAll
void                 cd_typed_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.cd_typed.RemoveFirst
atf_amc::FTypeD*     cd_typed_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_amc.FDb.cd_typed.RotateFirst
atf_amc::FTypeD*     cd_typed_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.cd_typed.qLast
inline atf_amc::FTypeD& cd_typed_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zsl_h_typec.EmptyQ
inline bool          zsl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zsl_h_typec.First
inline atf_amc::FTypeC* zsl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zsl_h_typec.InLlistQ
inline bool          zsl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zsl_h_typec.Insert
void                 zsl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.zsl_h_typec.Last
inline atf_amc::FTypeC* zsl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.zsl_h_typec.N
inline i32           zsl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zsl_h_typec.Next
inline atf_amc::FTypeC* zsl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:atf_amc.FDb.zsl_h_typec.Remove
void                 zsl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zsl_h_typec.RemoveAll
void                 zsl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_amc.FDb.zsl_h_typec.RemoveFirst
atf_amc::FTypeC*     zsl_h_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.zsl_h_typec.qLast
inline atf_amc::FTypeC& zsl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
// func:atf_amc.FDb.zsl_h_typec.FirstChanged
// this function is 'extrn' and implemented by user
void                 zsl_h_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:atf_amc.FDb.zsl_h_typec.UpdateCycles
void                 zsl_h_typec_UpdateCycles() __attribute__((nothrow));
// func:atf_amc.FDb.zsl_h_typec.Step
// this function is 'extrn' and implemented by user
void                 zsl_h_typec_Step() __attribute__((nothrow));
// func:atf_amc.FDb.zsl_h_typec.Call
inline void          zsl_h_typec_Call() __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zs_t_typec.EmptyQ
inline bool          zs_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zs_t_typec.First
inline atf_amc::FTypeC* zs_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zs_t_typec.InLlistQ
inline bool          zs_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zs_t_typec.Insert
void                 zs_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.zs_t_typec.Last
inline atf_amc::FTypeC* zs_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.zs_t_typec.N
inline i32           zs_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zs_t_typec.Next
inline atf_amc::FTypeC* zs_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:atf_amc.FDb.zs_t_typec.Remove
void                 zs_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zs_t_typec.RemoveAll
void                 zs_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_amc.FDb.zs_t_typec.RemoveFirst
atf_amc::FTypeC*     zs_t_typec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.zs_t_typec.qLast
inline atf_amc::FTypeC& zs_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
// func:atf_amc.FDb.zs_t_typec.FirstChanged
// this function is 'extrn' and implemented by user
void                 zs_t_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:atf_amc.FDb.zs_t_typec.UpdateCycles
void                 zs_t_typec_UpdateCycles() __attribute__((nothrow));
// func:atf_amc.FDb.zs_t_typec.Step
// this function is 'extrn' and implemented by user
void                 zs_t_typec_Step() __attribute__((nothrow));
// func:atf_amc.FDb.zs_t_typec.Call
inline void          zs_t_typec_Call() __attribute__((nothrow));

// If index is empty, return NULL
// Otherwise return first key in index.
// NOTE: this function must be called from the reading thread.
// NOTE: if called from the writing thread, it might result in loss of data.
// func:atf_amc.FDb.zs_mt_typec.DestructiveFirst
atf_amc::FTypeC*     zs_mt_typec_DestructiveFirst() __attribute__((nothrow));
// Return true if row is in index, false otherwise. Row must be non-NULL.
// func:atf_amc.FDb.zs_mt_typec.InLlistQ
inline bool          zs_mt_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, the behavior is undefined.
// func:atf_amc.FDb.zs_mt_typec.Insert
void                 zs_mt_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If element is not in index, do nothing.
// Otherwise, throw exception: ZSListMT elements cannot
// be removed from the list except via RemoveFIrst.
// func:atf_amc.FDb.zs_mt_typec.Remove
void                 zs_mt_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
// func:atf_amc.FDb.zs_mt_typec.RemoveFirst
atf_amc::FTypeC*     zs_mt_typec_RemoveFirst() __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FDb.zdl_hnt_typec.EmptyQ
inline bool          zdl_hnt_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.zdl_hnt_typec.First
inline atf_amc::FTypeC* zdl_hnt_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.zdl_hnt_typec.InLlistQ
inline bool          zdl_hnt_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.zdl_hnt_typec.Insert
void                 zdl_hnt_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// Return number of items in the linked list
// func:atf_amc.FDb.zdl_hnt_typec.N
inline i32           zdl_hnt_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.zdl_hnt_typec.Next
inline atf_amc::FTypeC* zdl_hnt_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.zdl_hnt_typec.Prev
inline atf_amc::FTypeC* zdl_hnt_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.zdl_hnt_typec.Remove
void                 zdl_hnt_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.zdl_hnt_typec.RemoveAll
void                 zdl_hnt_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.zdl_hnt_typec.RemoveFirst
atf_amc::FTypeC*     zdl_hnt_typec_RemoveFirst() __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FDb.cdl_h_typec.EmptyQ
inline bool          cdl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.cdl_h_typec.First
inline atf_amc::FTypeC* cdl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.cdl_h_typec.InLlistQ
inline bool          cdl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.cdl_h_typec.Insert
void                 cdl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.cdl_h_typec.Last
inline atf_amc::FTypeC* cdl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.cdl_h_typec.N
inline i32           cdl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.cdl_h_typec.Next
inline atf_amc::FTypeC* cdl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.cdl_h_typec.Prev
inline atf_amc::FTypeC* cdl_h_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.cdl_h_typec.Remove
void                 cdl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.cdl_h_typec.RemoveAll
void                 cdl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.cdl_h_typec.RemoveFirst
atf_amc::FTypeC*     cdl_h_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_amc.FDb.cdl_h_typec.RotateFirst
atf_amc::FTypeC*     cdl_h_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.cdl_h_typec.qLast
inline atf_amc::FTypeC& cdl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.cd_t_typec.EmptyQ
inline bool          cd_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.cd_t_typec.First
inline atf_amc::FTypeC* cd_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.cd_t_typec.InLlistQ
inline bool          cd_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.cd_t_typec.Insert
void                 cd_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.cd_t_typec.Last
inline atf_amc::FTypeC* cd_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.cd_t_typec.N
inline i32           cd_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.cd_t_typec.Next
inline atf_amc::FTypeC* cd_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.cd_t_typec.Prev
inline atf_amc::FTypeC* cd_t_typec_Prev(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.cd_t_typec.Remove
void                 cd_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.cd_t_typec.RemoveAll
void                 cd_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.cd_t_typec.RemoveFirst
atf_amc::FTypeC*     cd_t_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_amc.FDb.cd_t_typec.RotateFirst
atf_amc::FTypeC*     cd_t_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.cd_t_typec.qLast
inline atf_amc::FTypeC& cd_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_amc.FDb.csl_h_typec.EmptyQ
inline bool          csl_h_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.csl_h_typec.First
inline atf_amc::FTypeC* csl_h_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.csl_h_typec.InLlistQ
inline bool          csl_h_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.csl_h_typec.Insert
void                 csl_h_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.csl_h_typec.Last
inline atf_amc::FTypeC* csl_h_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.csl_h_typec.N
inline i32           csl_h_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.csl_h_typec.Next
inline atf_amc::FTypeC* csl_h_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:atf_amc.FDb.csl_h_typec.Remove
void                 csl_h_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.csl_h_typec.RemoveAll
void                 csl_h_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_amc.FDb.csl_h_typec.RemoveFirst
atf_amc::FTypeC*     csl_h_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_amc.FDb.csl_h_typec.RotateFirst
atf_amc::FTypeC*     csl_h_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.csl_h_typec.qLast
inline atf_amc::FTypeC& csl_h_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
// func:atf_amc.FDb.csl_h_typec.FirstChanged
// this function is 'extrn' and implemented by user
void                 csl_h_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:atf_amc.FDb.csl_h_typec.UpdateCycles
void                 csl_h_typec_UpdateCycles() __attribute__((nothrow));
// func:atf_amc.FDb.csl_h_typec.Step
// this function is 'extrn' and implemented by user
void                 csl_h_typec_Step() __attribute__((nothrow));
// func:atf_amc.FDb.csl_h_typec.Call
inline void          csl_h_typec_Call() __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FDb.cs_t_typec.EmptyQ
inline bool          cs_t_typec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.cs_t_typec.First
inline atf_amc::FTypeC* cs_t_typec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.cs_t_typec.InLlistQ
inline bool          cs_t_typec_InLlistQ(atf_amc::FTypeC& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.cs_t_typec.Insert
void                 cs_t_typec_Insert(atf_amc::FTypeC& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.cs_t_typec.Last
inline atf_amc::FTypeC* cs_t_typec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FDb.cs_t_typec.N
inline i32           cs_t_typec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.cs_t_typec.Next
inline atf_amc::FTypeC* cs_t_typec_Next(atf_amc::FTypeC &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:atf_amc.FDb.cs_t_typec.Remove
void                 cs_t_typec_Remove(atf_amc::FTypeC& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.cs_t_typec.RemoveAll
void                 cs_t_typec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_amc.FDb.cs_t_typec.RemoveFirst
atf_amc::FTypeC*     cs_t_typec_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_amc.FDb.cs_t_typec.RotateFirst
atf_amc::FTypeC*     cs_t_typec_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.cs_t_typec.qLast
inline atf_amc::FTypeC& cs_t_typec_qLast() __attribute__((__warn_unused_result__, nothrow));
// First element of index changed.
// Forward-declaration for user-provided function.
// func:atf_amc.FDb.cs_t_typec.FirstChanged
// this function is 'extrn' and implemented by user
void                 cs_t_typec_FirstChanged() __attribute__((nothrow));
// Update cycles count from previous clock capture
// func:atf_amc.FDb.cs_t_typec.UpdateCycles
void                 cs_t_typec_UpdateCycles() __attribute__((nothrow));
// func:atf_amc.FDb.cs_t_typec.Step
// this function is 'extrn' and implemented by user
void                 cs_t_typec_Step() __attribute__((nothrow));
// func:atf_amc.FDb.cs_t_typec.Call
inline void          cs_t_typec_Call() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.typea.Alloc
atf_amc::FTypeA&     typea_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.typea.AllocMaybe
atf_amc::FTypeA*     typea_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.typea.InsertMaybe
atf_amc::FTypeA*     typea_InsertMaybe(const atf_amc::TypeA &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.typea.AllocMem
void*                typea_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.typea.EmptyQ
inline bool          typea_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.typea.Find
inline atf_amc::FTypeA* typea_Find(i32 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.typea.Last
inline atf_amc::FTypeA* typea_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.typea.N
inline i32           typea_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.typea.RemoveAll
void                 typea_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.typea.RemoveLast
void                 typea_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.typea.qFind
inline atf_amc::FTypeA& typea_qFind(i32 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.typea.XrefMaybe
bool                 typea_XrefMaybe(atf_amc::FTypeA &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.types.Alloc
atf_amc::FTypeS&     types_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.types.AllocMaybe
atf_amc::FTypeS*     types_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.types.InsertMaybe
atf_amc::FTypeS*     types_InsertMaybe(const atf_amc::TypeS &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.types.AllocMem
void*                types_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.types.EmptyQ
inline bool          types_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.types.Find
inline atf_amc::FTypeS* types_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.types.Last
inline atf_amc::FTypeS* types_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.types.N
inline i32           types_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.types.RemoveAll
void                 types_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.types.RemoveLast
void                 types_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.types.qFind
inline atf_amc::FTypeS& types_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.types.XrefMaybe
bool                 types_XrefMaybe(atf_amc::FTypeS &row);

// Return true if hash is empty
// func:atf_amc.FDb.ind_types.EmptyQ
inline bool          ind_types_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_amc.FDb.ind_types.Find
atf_amc::FTypeS*     ind_types_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:atf_amc.FDb.ind_types.GetOrCreate
atf_amc::FTypeS&     ind_types_GetOrCreate(i32 key) __attribute__((nothrow));
// Return number of items in the hash
// func:atf_amc.FDb.ind_types.N
inline i32           ind_types_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_amc.FDb.ind_types.InsertMaybe
bool                 ind_types_InsertMaybe(atf_amc::FTypeS& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_amc.FDb.ind_types.Remove
void                 ind_types_Remove(atf_amc::FTypeS& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_amc.FDb.ind_types.Reserve
void                 ind_types_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:atf_amc.FDb.ind_typea.EmptyQ
inline bool          ind_typea_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_amc.FDb.ind_typea.Find
atf_amc::FTypeA*     ind_typea_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:atf_amc.FDb.ind_typea.GetOrCreate
atf_amc::FTypeA&     ind_typea_GetOrCreate(i32 key) __attribute__((nothrow));
// Return number of items in the hash
// func:atf_amc.FDb.ind_typea.N
inline i32           ind_typea_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_amc.FDb.ind_typea.InsertMaybe
bool                 ind_typea_InsertMaybe(atf_amc::FTypeA& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_amc.FDb.ind_typea.Remove
void                 ind_typea_Remove(atf_amc::FTypeA& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_amc.FDb.ind_typea.Reserve
void                 ind_typea_Reserve(int n) __attribute__((nothrow));

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     atf_amc.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:atf_amc.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
// func:atf_amc.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:atf_amc.FDb._db.Step
void                 Step();
// Main function
// func:atf_amc.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:atf_amc.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:atf_amc.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:atf_amc.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:atf_amc.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load specified ssimfile.
// func:atf_amc.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:atf_amc.FDb._db.Steps
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.typet.Alloc
atf_amc::FTypeT&     typet_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.typet.AllocMaybe
atf_amc::FTypeT*     typet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.typet.InsertMaybe
atf_amc::FTypeT*     typet_InsertMaybe(const atf_amc::TypeT &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.typet.AllocMem
void*                typet_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.typet.EmptyQ
inline bool          typet_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.typet.Find
inline atf_amc::FTypeT* typet_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.typet.Last
inline atf_amc::FTypeT* typet_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.typet.N
inline i32           typet_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.typet.RemoveAll
void                 typet_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.typet.RemoveLast
void                 typet_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.typet.qFind
inline atf_amc::FTypeT& typet_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.typet.XrefMaybe
bool                 typet_XrefMaybe(atf_amc::FTypeT &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.cstring.Alloc
atf_amc::FCstring&   cstring_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.cstring.AllocMaybe
atf_amc::FCstring*   cstring_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.cstring.InsertMaybe
atf_amc::FCstring*   cstring_InsertMaybe(const atf_amc::Cstring &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.cstring.AllocMem
void*                cstring_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.cstring.EmptyQ
inline bool          cstring_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.cstring.Find
inline atf_amc::FCstring* cstring_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.cstring.Last
inline atf_amc::FCstring* cstring_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.cstring.N
inline i32           cstring_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.cstring.RemoveAll
void                 cstring_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.cstring.RemoveLast
void                 cstring_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.cstring.qFind
inline atf_amc::FCstring& cstring_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.cstring.XrefMaybe
bool                 cstring_XrefMaybe(atf_amc::FCstring &row);

// Return true if hash is empty
// func:atf_amc.FDb.ind_cstring.EmptyQ
inline bool          ind_cstring_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_amc.FDb.ind_cstring.Find
atf_amc::FCstring*   ind_cstring_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:atf_amc.FDb.ind_cstring.GetOrCreate
atf_amc::FCstring&   ind_cstring_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:atf_amc.FDb.ind_cstring.N
inline i32           ind_cstring_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_amc.FDb.ind_cstring.InsertMaybe
bool                 ind_cstring_InsertMaybe(atf_amc::FCstring& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_amc.FDb.ind_cstring.Remove
void                 ind_cstring_Remove(atf_amc::FCstring& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_amc.FDb.ind_cstring.Reserve
void                 ind_cstring_Reserve(int n) __attribute__((nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.msgbuf.XrefMaybe
bool                 msgbuf_XrefMaybe(atf_amc::Msgbuf &row);

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.bytebuf.XrefMaybe
bool                 bytebuf_XrefMaybe(atf_amc::Bytebuf &row);

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.linebuf.XrefMaybe
bool                 linebuf_XrefMaybe(atf_amc::Linebuf &row);

// Return true if index is empty
// func:atf_amc.FDb.cd_in_msg.EmptyQ
inline bool          cd_in_msg_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FDb.cd_in_msg.First
inline atf_amc::Msgbuf* cd_in_msg_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FDb.cd_in_msg.InLlistQ
inline bool          cd_in_msg_InLlistQ(atf_amc::Msgbuf& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FDb.cd_in_msg.Insert
void                 cd_in_msg_Insert(atf_amc::Msgbuf& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FDb.cd_in_msg.Last
inline atf_amc::Msgbuf* cd_in_msg_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FDb.cd_in_msg.Next
inline atf_amc::Msgbuf* cd_in_msg_Next(atf_amc::Msgbuf &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FDb.cd_in_msg.Prev
inline atf_amc::Msgbuf* cd_in_msg_Prev(atf_amc::Msgbuf &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.cd_in_msg.Remove
void                 cd_in_msg_Remove(atf_amc::Msgbuf& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.cd_in_msg.RemoveAll
void                 cd_in_msg_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_amc.FDb.cd_in_msg.RemoveFirst
atf_amc::Msgbuf*     cd_in_msg_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_amc.FDb.cd_in_msg.RotateFirst
atf_amc::Msgbuf*     cd_in_msg_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FDb.cd_in_msg.qLast
inline atf_amc::Msgbuf& cd_in_msg_qLast() __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FDb.cd_in_msg.Step
// this function is 'extrn' and implemented by user
void                 cd_in_msg_Step() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.typeb.Alloc
atf_amc::FTypeB&     typeb_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.typeb.AllocMaybe
atf_amc::FTypeB*     typeb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.typeb.InsertMaybe
atf_amc::FTypeB*     typeb_InsertMaybe(const atf_amc::TypeB &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.typeb.Delete
void                 typeb_Delete(atf_amc::FTypeB &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:atf_amc.FDb.typeb.AllocMem
void*                typeb_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:atf_amc.FDb.typeb.FreeMem
void                 typeb_FreeMem(atf_amc::FTypeB &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:atf_amc.FDb.typeb.Reserve
u64                  typeb_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:atf_amc.FDb.typeb.ReserveMem
u64                  typeb_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.typeb.XrefMaybe
bool                 typeb_XrefMaybe(atf_amc::FTypeB &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.pooledbe64.Alloc
atf_amc::PooledBE64& pooledbe64_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.pooledbe64.AllocMaybe
atf_amc::PooledBE64* pooledbe64_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.pooledbe64.Delete
void                 pooledbe64_Delete(atf_amc::PooledBE64 &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:atf_amc.FDb.pooledbe64.AllocMem
void*                pooledbe64_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:atf_amc.FDb.pooledbe64.FreeMem
void                 pooledbe64_FreeMem(atf_amc::PooledBE64 &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:atf_amc.FDb.pooledbe64.Reserve
u64                  pooledbe64_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:atf_amc.FDb.pooledbe64.ReserveMem
u64                  pooledbe64_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.pooledbe64.XrefMaybe
bool                 pooledbe64_XrefMaybe(atf_amc::PooledBE64 &row);

// Free block of memory previously returned by Lpool.
// func:atf_amc.FDb.varlen_extern.FreeMem
void                 varlen_extern_FreeMem(void* mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
// func:atf_amc.FDb.varlen_extern.AllocMem
void*                varlen_extern_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
// func:atf_amc.FDb.varlen_extern.ReserveBuffers
bool                 varlen_extern_ReserveBuffers(u64 nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
// func:atf_amc.FDb.varlen_extern.ReallocMem
void*                varlen_extern_ReallocMem(void* oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// Allocate memory for a new row with N_VARFLD var-len elements
// If out of memory, process is killed.
// func:atf_amc.FDb.varlen_extern.Alloc
atf_amc::VarlenExtern& varlen_extern_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.varlen_extern.AllocMaybe
inline atf_amc::VarlenExtern* varlen_extern_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FDb.varlen_extern.AllocExtra
atf_amc::VarlenExtern& varlen_extern_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.varlen_extern.AllocExtraMaybe
atf_amc::VarlenExtern* varlen_extern_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, return NULL.
// Allocate memory for a new row; Copy var-len portion from varlen.
// This is a convenience function that uses varlen_extern_Alloc
// func:atf_amc.FDb.varlen_extern.AllocVarlenMaybe
inline atf_amc::VarlenExtern* varlen_extern_AllocVarlenMaybe(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, terminate process.
// func:atf_amc.FDb.varlen_extern.AllocVarlen
inline atf_amc::VarlenExtern& varlen_extern_AllocVarlen(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.varlen_extern.Delete
void                 varlen_extern_Delete(atf_amc::VarlenExtern &row) __attribute__((nothrow));
// Return number of items in the pool
// func:atf_amc.FDb.varlen_extern.N
inline i64           varlen_extern_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.varlen_extern.XrefMaybe
bool                 varlen_extern_XrefMaybe(atf_amc::VarlenExtern &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.amctest.Alloc
atf_amc::FAmctest&   amctest_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.amctest.AllocMaybe
atf_amc::FAmctest*   amctest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.amctest.InsertMaybe
atf_amc::FAmctest*   amctest_InsertMaybe(const atfdb::Amctest &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.amctest.AllocMem
void*                amctest_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.amctest.EmptyQ
inline bool          amctest_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.amctest.Find
inline atf_amc::FAmctest* amctest_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.amctest.Last
inline atf_amc::FAmctest* amctest_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.amctest.N
inline i32           amctest_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.amctest.RemoveAll
void                 amctest_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.amctest.RemoveLast
void                 amctest_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.amctest.qFind
inline atf_amc::FAmctest& amctest_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.amctest.XrefMaybe
bool                 amctest_XrefMaybe(atf_amc::FAmctest &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.cascdel.Alloc
atf_amc::FCascdel&   cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.cascdel.AllocMaybe
atf_amc::FCascdel*   cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.cascdel.Delete
void                 cascdel_Delete(atf_amc::FCascdel &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:atf_amc.FDb.cascdel.AllocMem
void*                cascdel_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:atf_amc.FDb.cascdel.FreeMem
void                 cascdel_FreeMem(atf_amc::FCascdel &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:atf_amc.FDb.cascdel.Reserve
u64                  cascdel_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:atf_amc.FDb.cascdel.ReserveMem
u64                  cascdel_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.cascdel.XrefMaybe
bool                 cascdel_XrefMaybe(atf_amc::FCascdel &row);

// Free block of memory previously returned by Lpool.
// func:atf_amc.FDb.optalloc.FreeMem
void                 optalloc_FreeMem(void* mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
// func:atf_amc.FDb.optalloc.AllocMem
void*                optalloc_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
// func:atf_amc.FDb.optalloc.ReserveBuffers
bool                 optalloc_ReserveBuffers(u64 nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
// func:atf_amc.FDb.optalloc.ReallocMem
void*                optalloc_ReallocMem(void* oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// func:atf_amc.FDb.optalloc.AllocExtra
atf_amc::OptAlloc&   optalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.optalloc.AllocExtraMaybe
atf_amc::OptAlloc*   optalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.optalloc.Delete
void                 optalloc_Delete(atf_amc::OptAlloc &row) __attribute__((nothrow));
// Return number of items in the pool
// func:atf_amc.FDb.optalloc.N
inline i64           optalloc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.optalloc.XrefMaybe
bool                 optalloc_XrefMaybe(atf_amc::OptAlloc &row);

// Free block of memory previously returned by Lpool.
// func:atf_amc.FDb.varlenalloc.FreeMem
void                 varlenalloc_FreeMem(void* mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
// func:atf_amc.FDb.varlenalloc.AllocMem
void*                varlenalloc_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
// func:atf_amc.FDb.varlenalloc.ReserveBuffers
bool                 varlenalloc_ReserveBuffers(u64 nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
// func:atf_amc.FDb.varlenalloc.ReallocMem
void*                varlenalloc_ReallocMem(void* oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// Allocate memory for a new row with N_VARFLD var-len elements
// If out of memory, process is killed.
// func:atf_amc.FDb.varlenalloc.Alloc
atf_amc::VarlenAlloc& varlenalloc_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.varlenalloc.AllocMaybe
inline atf_amc::VarlenAlloc* varlenalloc_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FDb.varlenalloc.AllocExtra
atf_amc::VarlenAlloc& varlenalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.varlenalloc.AllocExtraMaybe
atf_amc::VarlenAlloc* varlenalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, return NULL.
// Allocate memory for a new row; Copy var-len portion from elem.
// This is a convenience function that uses varlenalloc_Alloc
// func:atf_amc.FDb.varlenalloc.AllocVarlenMaybe
inline atf_amc::VarlenAlloc* varlenalloc_AllocVarlenMaybe(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__, nothrow));
// Allocate element & copy memory from input parameter. If out of memory, terminate process.
// func:atf_amc.FDb.varlenalloc.AllocVarlen
inline atf_amc::VarlenAlloc& varlenalloc_AllocVarlen(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.varlenalloc.Delete
void                 varlenalloc_Delete(atf_amc::VarlenAlloc &row) __attribute__((nothrow));
// Return number of items in the pool
// func:atf_amc.FDb.varlenalloc.N
inline i64           varlenalloc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.varlenalloc.XrefMaybe
bool                 varlenalloc_XrefMaybe(atf_amc::VarlenAlloc &row);

// Free block of memory previously returned by Lpool.
// func:atf_amc.FDb.optg.FreeMem
void                 optg_FreeMem(void* mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
// func:atf_amc.FDb.optg.AllocMem
void*                optg_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::malloc)
// func:atf_amc.FDb.optg.ReserveBuffers
bool                 optg_ReserveBuffers(u64 nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
// func:atf_amc.FDb.optg.ReallocMem
void*                optg_ReallocMem(void* oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// func:atf_amc.FDb.optg.AllocExtra
atf_amc::FOptG&      optg_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.optg.AllocExtraMaybe
atf_amc::FOptG*      optg_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.optg.InsertMaybe
atf_amc::FOptG*      optg_InsertMaybe(const atf_amc::OptG &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.optg.Delete
void                 optg_Delete(atf_amc::FOptG &row) __attribute__((nothrow));
// Return number of items in the pool
// func:atf_amc.FDb.optg.N
inline i64           optg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.optg.XrefMaybe
bool                 optg_XrefMaybe(atf_amc::FOptG &row);

// Return true if index is empty
// func:atf_amc.FDb.c_typek.EmptyQ
inline bool          c_typek_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.c_typek.Find
inline atf_amc::FTypeK* c_typek_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:atf_amc.FDb.c_typek.Getary
inline algo::aryptr<atf_amc::FTypeK*> c_typek_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:atf_amc.FDb.c_typek.Insert
void                 c_typek_Insert(atf_amc::FTypeK& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:atf_amc.FDb.c_typek.InsertMaybe
bool                 c_typek_InsertMaybe(atf_amc::FTypeK& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:atf_amc.FDb.c_typek.N
inline i32           c_typek_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:atf_amc.FDb.c_typek.Remove
void                 c_typek_Remove(atf_amc::FTypeK& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.c_typek.RemoveAll
inline void          c_typek_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:atf_amc.FDb.c_typek.Reserve
void                 c_typek_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:atf_amc.FDb.c_typek.qFind
inline atf_amc::FTypeK& c_typek_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:atf_amc.FDb.c_typek.InAryQ
inline bool          c_typek_InAryQ(atf_amc::FTypeK& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:atf_amc.FDb.c_typek.qLast
inline atf_amc::FTypeK& c_typek_qLast() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.avl.Alloc
atf_amc::FAvl&       avl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.avl.AllocMaybe
atf_amc::FAvl*       avl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.avl.AllocMem
void*                avl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.avl.EmptyQ
inline bool          avl_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.avl.Find
inline atf_amc::FAvl* avl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.avl.Last
inline atf_amc::FAvl* avl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.avl.N
inline i32           avl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.avl.RemoveAll
void                 avl_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.avl.RemoveLast
void                 avl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.avl.qFind
inline atf_amc::FAvl& avl_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.avl.XrefMaybe
bool                 avl_XrefMaybe(atf_amc::FAvl &row);

// Return true if index is empty
// func:atf_amc.FDb.tr_avl.EmptyQ
inline bool          tr_avl_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FDb.tr_avl.FirstImpl
atf_amc::FAvl*       tr_avl_FirstImpl(atf_amc::FAvl* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the first(smallest) element in the tree
// func:atf_amc.FDb.tr_avl.First
atf_amc::FAvl*       tr_avl_First() __attribute__((__warn_unused_result__, nothrow));
// Return true if row is in the tree, false otherwise
// func:atf_amc.FDb.tr_avl.InTreeQ
inline bool          tr_avl_InTreeQ(atf_amc::FAvl& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
// func:atf_amc.FDb.tr_avl.InsertImpl
void                 tr_avl_InsertImpl(atf_amc::FAvl* parent, atf_amc::FAvl& row) __attribute__((nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
// func:atf_amc.FDb.tr_avl.Insert
void                 tr_avl_Insert(atf_amc::FAvl& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FDb.tr_avl.Remove
void                 tr_avl_Remove(atf_amc::FAvl& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FDb.tr_avl.RemoveAll
inline void          tr_avl_RemoveAll() __attribute__((nothrow));
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FDb.tr_avl.RemoveFirst
void                 tr_avl_RemoveFirst() __attribute__((nothrow));
// func:atf_amc.FDb.tr_avl.Balance
i32                  tr_avl_Balance(atf_amc::FAvl& row) __attribute__((nothrow));
// Recalculate depth and keep rebalancing if needed
// func:atf_amc.FDb.tr_avl.Propagate
atf_amc::FAvl*       tr_avl_Propagate(atf_amc::FAvl& pnode) __attribute__((nothrow));
// Rebalances the node if needed.
// func:atf_amc.FDb.tr_avl.Rebalance
void                 tr_avl_Rebalance(atf_amc::FAvl& node) __attribute__((nothrow));
// func:atf_amc.FDb.tr_avl.Next
atf_amc::FAvl*       tr_avl_Next(atf_amc::FAvl& node) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FDb.tr_avl.Prev
atf_amc::FAvl*       tr_avl_Prev(atf_amc::FAvl& node) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.FDb.tr_avl.LastImpl
atf_amc::FAvl*       tr_avl_LastImpl(atf_amc::FAvl* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the last(largest) element in tree
// func:atf_amc.FDb.tr_avl.Last
atf_amc::FAvl*       tr_avl_Last() __attribute__((__warn_unused_result__, nothrow));
// Empty the index. (rows may be deleted if cascdel)
// func:atf_amc.FDb.tr_avl.RemoveAllImpl
void                 tr_avl_RemoveAllImpl(atf_amc::FAvl* root, bool del) __attribute__((nothrow));
// Reinsert a row with modified key(Reheap semantics)
// func:atf_amc.FDb.tr_avl.Reinsert
void                 tr_avl_Reinsert(atf_amc::FAvl& node) __attribute__((nothrow));
// Find the first element that is greater or equal to a sortfld value
// func:atf_amc.FDb.tr_avl.FirstGe
atf_amc::FAvl*       tr_avl_FirstGe(const i32& val) __attribute__((nothrow));
// Find the last element that is smaller or equal to a sortfld value
// func:atf_amc.FDb.tr_avl.LastLt
atf_amc::FAvl*       tr_avl_LastLt(const i32& val) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.listtype.Alloc
atf_amc::FListtype&  listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.listtype.AllocMaybe
atf_amc::FListtype*  listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.listtype.InsertMaybe
atf_amc::FListtype*  listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.listtype.AllocMem
inline void*         listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.listtype.EmptyQ
inline bool          listtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.listtype.Find
inline atf_amc::FListtype* listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.FDb.listtype.Getary
inline algo::aryptr<atf_amc::FListtype> listtype_Getary() __attribute__((nothrow));
// Return constant 10 -- max. number of items in the pool
// func:atf_amc.FDb.listtype.Max
inline i32           listtype_Max() __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.FDb.listtype.N
inline i32           listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:atf_amc.FDb.listtype.RemoveAll
void                 listtype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.listtype.RemoveLast
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.FDb.listtype.qFind
inline atf_amc::FListtype& listtype_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:atf_amc.FDb.listtype.rowid_Get
inline u64           listtype_rowid_Get(atf_amc::FListtype &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.listtype.XrefMaybe
bool                 listtype_XrefMaybe(atf_amc::FListtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.typed.Alloc
atf_amc::FTypeD&     typed_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.typed.AllocMaybe
atf_amc::FTypeD*     typed_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FDb.typed.InsertMaybe
atf_amc::FTypeD*     typed_InsertMaybe(const atf_amc::TypeC &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_amc.FDb.typed.Delete
void                 typed_Delete(atf_amc::FTypeD &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:atf_amc.FDb.typed.AllocMem
void*                typed_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:atf_amc.FDb.typed.FreeMem
void                 typed_FreeMem(atf_amc::FTypeD &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:atf_amc.FDb.typed.Reserve
u64                  typed_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:atf_amc.FDb.typed.ReserveMem
u64                  typed_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.typed.XrefMaybe
bool                 typed_XrefMaybe(atf_amc::FTypeD &row);

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.bytebuf_dyn.XrefMaybe
bool                 bytebuf_dyn_XrefMaybe(atf_amc::BytebufDyn &row);

// Return true if hash is empty
// func:atf_amc.FDb.ind_thash_elem.EmptyQ
inline bool          ind_thash_elem_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_amc.FDb.ind_thash_elem.Find
atf_amc::FThashElem* ind_thash_elem_Find(u64 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:atf_amc.FDb.ind_thash_elem.GetOrCreate
atf_amc::FThashElem& ind_thash_elem_GetOrCreate(u64 key) __attribute__((nothrow));
// Return number of items in the hash
// func:atf_amc.FDb.ind_thash_elem.N
inline i32           ind_thash_elem_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_amc.FDb.ind_thash_elem.InsertMaybe
bool                 ind_thash_elem_InsertMaybe(atf_amc::FThashElem& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_amc.FDb.ind_thash_elem.Remove
void                 ind_thash_elem_Remove(atf_amc::FThashElem& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_amc.FDb.ind_thash_elem.Reserve
void                 ind_thash_elem_Reserve(int n) __attribute__((nothrow));
// func:atf_amc.FDb.ind_thash_elem.FindRemove
atf_amc::FThashElem* ind_thash_elem_FindRemove(u64 key) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FDb.thash_elem.Alloc
atf_amc::FThashElem& thash_elem_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FDb.thash_elem.AllocMaybe
atf_amc::FThashElem* thash_elem_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FDb.thash_elem.AllocMem
void*                thash_elem_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FDb.thash_elem.EmptyQ
inline bool          thash_elem_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FDb.thash_elem.Find
inline atf_amc::FThashElem* thash_elem_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FDb.thash_elem.Last
inline atf_amc::FThashElem* thash_elem_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.FDb.thash_elem.N
inline i32           thash_elem_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.FDb.thash_elem.RemoveAll
void                 thash_elem_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FDb.thash_elem.RemoveLast
void                 thash_elem_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FDb.thash_elem.qFind
inline atf_amc::FThashElem& thash_elem_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FDb.thash_elem.XrefMaybe
bool                 thash_elem_XrefMaybe(atf_amc::FThashElem &row);

// func:atf_amc.FDb.bh_typec_curs.Reserve
void                 _db_bh_typec_curs_Reserve(_db_bh_typec_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:atf_amc.FDb.bh_typec_curs.Reset
void                 _db_bh_typec_curs_Reset(_db_bh_typec_curs &curs, atf_amc::FDb &parent);
// Advance cursor.
// func:atf_amc.FDb.bh_typec_curs.Next
void                 _db_bh_typec_curs_Next(_db_bh_typec_curs &curs);
// Access current element. If not more elements, return NULL
// func:atf_amc.FDb.bh_typec_curs.Access
inline atf_amc::FTypeC& _db_bh_typec_curs_Access(_db_bh_typec_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:atf_amc.FDb.bh_typec_curs.ValidQ
inline bool          _db_bh_typec_curs_ValidQ(_db_bh_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zdl_h_typec_curs.Reset
inline void          _db_zdl_h_typec_curs_Reset(_db_zdl_h_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zdl_h_typec_curs.ValidQ
inline bool          _db_zdl_h_typec_curs_ValidQ(_db_zdl_h_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zdl_h_typec_curs.Next
inline void          _db_zdl_h_typec_curs_Next(_db_zdl_h_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zdl_h_typec_curs.Access
inline atf_amc::FTypeC& _db_zdl_h_typec_curs_Access(_db_zdl_h_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zd_t_typec_curs.Reset
inline void          _db_zd_t_typec_curs_Reset(_db_zd_t_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zd_t_typec_curs.ValidQ
inline bool          _db_zd_t_typec_curs_ValidQ(_db_zd_t_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zd_t_typec_curs.Next
inline void          _db_zd_t_typec_curs_Next(_db_zd_t_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zd_t_typec_curs.Access
inline atf_amc::FTypeC& _db_zd_t_typec_curs_Access(_db_zd_t_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zd_typed_curs.Reset
inline void          _db_zd_typed_curs_Reset(_db_zd_typed_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zd_typed_curs.ValidQ
inline bool          _db_zd_typed_curs_ValidQ(_db_zd_typed_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zd_typed_curs.Next
inline void          _db_zd_typed_curs_Next(_db_zd_typed_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zd_typed_curs.Access
inline atf_amc::FTypeD& _db_zd_typed_curs_Access(_db_zd_typed_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zd_typed_delcurs.Reset
inline void          _db_zd_typed_delcurs_Reset(_db_zd_typed_delcurs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zd_typed_delcurs.ValidQ
inline bool          _db_zd_typed_delcurs_ValidQ(_db_zd_typed_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zd_typed_delcurs.Next
inline void          _db_zd_typed_delcurs_Next(_db_zd_typed_delcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zd_typed_delcurs.Access
inline atf_amc::FTypeD& _db_zd_typed_delcurs_Access(_db_zd_typed_delcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zs_t_typed_curs.Reset
inline void          _db_zs_t_typed_curs_Reset(_db_zs_t_typed_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zs_t_typed_curs.ValidQ
inline bool          _db_zs_t_typed_curs_ValidQ(_db_zs_t_typed_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zs_t_typed_curs.Next
inline void          _db_zs_t_typed_curs_Next(_db_zs_t_typed_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zs_t_typed_curs.Access
inline atf_amc::FTypeD& _db_zs_t_typed_curs_Access(_db_zs_t_typed_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zs_t_typed_delcurs.Reset
inline void          _db_zs_t_typed_delcurs_Reset(_db_zs_t_typed_delcurs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zs_t_typed_delcurs.ValidQ
inline bool          _db_zs_t_typed_delcurs_ValidQ(_db_zs_t_typed_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zs_t_typed_delcurs.Next
inline void          _db_zs_t_typed_delcurs_Next(_db_zs_t_typed_delcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zs_t_typed_delcurs.Access
inline atf_amc::FTypeD& _db_zs_t_typed_delcurs_Access(_db_zs_t_typed_delcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_typed_curs.Reset
inline void          _db_cd_typed_curs_Reset(_db_cd_typed_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_typed_curs.ValidQ
inline bool          _db_cd_typed_curs_ValidQ(_db_cd_typed_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cd_typed_curs.Next
inline void          _db_cd_typed_curs_Next(_db_cd_typed_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cd_typed_curs.Access
inline atf_amc::FTypeD& _db_cd_typed_curs_Access(_db_cd_typed_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_typed_delcurs.Reset
inline void          _db_cd_typed_delcurs_Reset(_db_cd_typed_delcurs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_typed_delcurs.ValidQ
inline bool          _db_cd_typed_delcurs_ValidQ(_db_cd_typed_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cd_typed_delcurs.Next
inline void          _db_cd_typed_delcurs_Next(_db_cd_typed_delcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cd_typed_delcurs.Access
inline atf_amc::FTypeD& _db_cd_typed_delcurs_Access(_db_cd_typed_delcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zsl_h_typec_curs.Reset
inline void          _db_zsl_h_typec_curs_Reset(_db_zsl_h_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zsl_h_typec_curs.ValidQ
inline bool          _db_zsl_h_typec_curs_ValidQ(_db_zsl_h_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zsl_h_typec_curs.Next
inline void          _db_zsl_h_typec_curs_Next(_db_zsl_h_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zsl_h_typec_curs.Access
inline atf_amc::FTypeC& _db_zsl_h_typec_curs_Access(_db_zsl_h_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zs_t_typec_curs.Reset
inline void          _db_zs_t_typec_curs_Reset(_db_zs_t_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zs_t_typec_curs.ValidQ
inline bool          _db_zs_t_typec_curs_ValidQ(_db_zs_t_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zs_t_typec_curs.Next
inline void          _db_zs_t_typec_curs_Next(_db_zs_t_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zs_t_typec_curs.Access
inline atf_amc::FTypeC& _db_zs_t_typec_curs_Access(_db_zs_t_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zdl_hnt_typec_curs.Reset
inline void          _db_zdl_hnt_typec_curs_Reset(_db_zdl_hnt_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.zdl_hnt_typec_curs.ValidQ
inline bool          _db_zdl_hnt_typec_curs_ValidQ(_db_zdl_hnt_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.zdl_hnt_typec_curs.Next
inline void          _db_zdl_hnt_typec_curs_Next(_db_zdl_hnt_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.zdl_hnt_typec_curs.Access
inline atf_amc::FTypeC& _db_zdl_hnt_typec_curs_Access(_db_zdl_hnt_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cdl_h_typec_curs.Reset
inline void          _db_cdl_h_typec_curs_Reset(_db_cdl_h_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cdl_h_typec_curs.ValidQ
inline bool          _db_cdl_h_typec_curs_ValidQ(_db_cdl_h_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cdl_h_typec_curs.Next
inline void          _db_cdl_h_typec_curs_Next(_db_cdl_h_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cdl_h_typec_curs.Access
inline atf_amc::FTypeC& _db_cdl_h_typec_curs_Access(_db_cdl_h_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_t_typec_curs.Reset
inline void          _db_cd_t_typec_curs_Reset(_db_cd_t_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_t_typec_curs.ValidQ
inline bool          _db_cd_t_typec_curs_ValidQ(_db_cd_t_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cd_t_typec_curs.Next
inline void          _db_cd_t_typec_curs_Next(_db_cd_t_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cd_t_typec_curs.Access
inline atf_amc::FTypeC& _db_cd_t_typec_curs_Access(_db_cd_t_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.csl_h_typec_curs.Reset
inline void          _db_csl_h_typec_curs_Reset(_db_csl_h_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.csl_h_typec_curs.ValidQ
inline bool          _db_csl_h_typec_curs_ValidQ(_db_csl_h_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.csl_h_typec_curs.Next
inline void          _db_csl_h_typec_curs_Next(_db_csl_h_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.csl_h_typec_curs.Access
inline atf_amc::FTypeC& _db_csl_h_typec_curs_Access(_db_csl_h_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cs_t_typec_curs.Reset
inline void          _db_cs_t_typec_curs_Reset(_db_cs_t_typec_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cs_t_typec_curs.ValidQ
inline bool          _db_cs_t_typec_curs_ValidQ(_db_cs_t_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cs_t_typec_curs.Next
inline void          _db_cs_t_typec_curs_Next(_db_cs_t_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cs_t_typec_curs.Access
inline atf_amc::FTypeC& _db_cs_t_typec_curs_Access(_db_cs_t_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.typea_curs.Reset
inline void          _db_typea_curs_Reset(_db_typea_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.typea_curs.ValidQ
inline bool          _db_typea_curs_ValidQ(_db_typea_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.typea_curs.Next
inline void          _db_typea_curs_Next(_db_typea_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.typea_curs.Access
inline atf_amc::FTypeA& _db_typea_curs_Access(_db_typea_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.types_curs.Reset
inline void          _db_types_curs_Reset(_db_types_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.types_curs.ValidQ
inline bool          _db_types_curs_ValidQ(_db_types_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.types_curs.Next
inline void          _db_types_curs_Next(_db_types_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.types_curs.Access
inline atf_amc::FTypeS& _db_types_curs_Access(_db_types_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.typet_curs.Reset
inline void          _db_typet_curs_Reset(_db_typet_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.typet_curs.ValidQ
inline bool          _db_typet_curs_ValidQ(_db_typet_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.typet_curs.Next
inline void          _db_typet_curs_Next(_db_typet_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.typet_curs.Access
inline atf_amc::FTypeT& _db_typet_curs_Access(_db_typet_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cstring_curs.Reset
inline void          _db_cstring_curs_Reset(_db_cstring_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cstring_curs.ValidQ
inline bool          _db_cstring_curs_ValidQ(_db_cstring_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cstring_curs.Next
inline void          _db_cstring_curs_Next(_db_cstring_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cstring_curs.Access
inline atf_amc::FCstring& _db_cstring_curs_Access(_db_cstring_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_in_msg_curs.Reset
inline void          _db_cd_in_msg_curs_Reset(_db_cd_in_msg_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.cd_in_msg_curs.ValidQ
inline bool          _db_cd_in_msg_curs_ValidQ(_db_cd_in_msg_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.cd_in_msg_curs.Next
inline void          _db_cd_in_msg_curs_Next(_db_cd_in_msg_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.cd_in_msg_curs.Access
inline atf_amc::Msgbuf& _db_cd_in_msg_curs_Access(_db_cd_in_msg_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.amctest_curs.Reset
inline void          _db_amctest_curs_Reset(_db_amctest_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.amctest_curs.ValidQ
inline bool          _db_amctest_curs_ValidQ(_db_amctest_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.amctest_curs.Next
inline void          _db_amctest_curs_Next(_db_amctest_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.amctest_curs.Access
inline atf_amc::FAmctest& _db_amctest_curs_Access(_db_amctest_curs &curs) __attribute__((nothrow));
// func:atf_amc.FDb.c_typek_curs.Reset
inline void          _db_c_typek_curs_Reset(_db_c_typek_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.c_typek_curs.ValidQ
inline bool          _db_c_typek_curs_ValidQ(_db_c_typek_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.c_typek_curs.Next
inline void          _db_c_typek_curs_Next(_db_c_typek_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.c_typek_curs.Access
inline atf_amc::FTypeK& _db_c_typek_curs_Access(_db_c_typek_curs &curs) __attribute__((nothrow));
// func:atf_amc.FDb.c_typek_oncecurs.Reset
inline void          _db_c_typek_oncecurs_Reset(_db_c_typek_oncecurs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.c_typek_oncecurs.ValidQ
inline bool          _db_c_typek_oncecurs_ValidQ(_db_c_typek_oncecurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.c_typek_oncecurs.Next
inline void          _db_c_typek_oncecurs_Next(_db_c_typek_oncecurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.c_typek_oncecurs.Access
inline atf_amc::FTypeK& _db_c_typek_oncecurs_Access(_db_c_typek_oncecurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.avl_curs.Reset
inline void          _db_avl_curs_Reset(_db_avl_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.avl_curs.ValidQ
inline bool          _db_avl_curs_ValidQ(_db_avl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.avl_curs.Next
inline void          _db_avl_curs_Next(_db_avl_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.avl_curs.Access
inline atf_amc::FAvl& _db_avl_curs_Access(_db_avl_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.tr_avl_curs.Reset
inline void          _db_tr_avl_curs_Reset(_db_tr_avl_curs &curs, atf_amc::FDb& ) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.tr_avl_curs.ValidQ
inline bool          _db_tr_avl_curs_ValidQ(_db_tr_avl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.tr_avl_curs.Next
inline void          _db_tr_avl_curs_Next(_db_tr_avl_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.tr_avl_curs.Access
inline atf_amc::FAvl& _db_tr_avl_curs_Access(_db_tr_avl_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.listtype_curs.Reset
inline void          _db_listtype_curs_Reset(_db_listtype_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.listtype_curs.ValidQ
inline bool          _db_listtype_curs_ValidQ(_db_listtype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.listtype_curs.Next
inline void          _db_listtype_curs_Next(_db_listtype_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.listtype_curs.Access
inline atf_amc::FListtype& _db_listtype_curs_Access(_db_listtype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.thash_elem_curs.Reset
inline void          _db_thash_elem_curs_Reset(_db_thash_elem_curs &curs, atf_amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FDb.thash_elem_curs.ValidQ
inline bool          _db_thash_elem_curs_ValidQ(_db_thash_elem_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FDb.thash_elem_curs.Next
inline void          _db_thash_elem_curs_Next(_db_thash_elem_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FDb.thash_elem_curs.Access
inline atf_amc::FThashElem& _db_thash_elem_curs_Access(_db_thash_elem_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.FDb..Init
void                 FDb_Init();
// func:atf_amc.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));

// --- atf_amc.TypeG
// create: atf_amc.OptAlloc.typeg (Opt)
// create: atf_amc.OptG.typeg (Opt)
// create: atf_amc.FOptG.typeg (Opt)
#pragma pack(push,1)
struct TypeG { // atf_amc.TypeG
    i32   typeg;   //   0
    // func:atf_amc.TypeG..EqOp
    inline bool          operator ==(const atf_amc::TypeG &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeG..NeOp
    inline bool          operator !=(const atf_amc::TypeG &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeG..LtOp
    inline bool          operator <(const atf_amc::TypeG &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeG..GtOp
    inline bool          operator >(const atf_amc::TypeG &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeG..LeOp
    inline bool          operator <=(const atf_amc::TypeG &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeG..GeOp
    inline bool          operator >=(const atf_amc::TypeG &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeG..Ctor
    inline               TypeG() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.TypeG..Hash
inline u32           TypeG_Hash(u32 prev, const atf_amc::TypeG& rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeG from an ascii string.
// The format of the string is the format of the atf_amc::TypeG's only field
// func:atf_amc.TypeG..ReadStrptrMaybe
bool                 TypeG_ReadStrptrMaybe(atf_amc::TypeG &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.TypeG..Lt
inline bool          TypeG_Lt(atf_amc::TypeG& lhs, atf_amc::TypeG& rhs) __attribute__((nothrow));
// func:atf_amc.TypeG..Cmp
inline i32           TypeG_Cmp(atf_amc::TypeG& lhs, atf_amc::TypeG& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeG..Init
inline void          TypeG_Init(atf_amc::TypeG& typeg);
// func:atf_amc.TypeG..Eq
inline bool          TypeG_Eq(atf_amc::TypeG& lhs, atf_amc::TypeG& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.TypeG..Update
inline bool          TypeG_Update(atf_amc::TypeG &lhs, atf_amc::TypeG& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeG.String  printfmt:Raw
// func:atf_amc.TypeG..Print
void                 TypeG_Print(atf_amc::TypeG& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FOptG
// create: atf_amc.FDb.optg (Lpool)
struct FOptG { // atf_amc.FOptG: Something derived from OptG
    u32                    length;    //   0
    // atf_amc::TypeG      typeg[];                optional field
private:
    // func:atf_amc.FOptG..Ctor
    inline               FOptG() __attribute__((nothrow));
    friend atf_amc::FOptG&      optg_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FOptG*      optg_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend void                 optg_Delete(atf_amc::FOptG &row) __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FOptG.optg.CopyOut
void                 optg_CopyOut(atf_amc::FOptG &row, atf_amc::OptG &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FOptG.optg.CopyIn
void                 optg_CopyIn(atf_amc::FOptG &row, atf_amc::OptG &in) __attribute__((nothrow));

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
// func:atf_amc.FOptG.typeg.Get
inline atf_amc::TypeG* typeg_Get(atf_amc::FOptG& optg) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:atf_amc.FOptG.typeg.Getary
algo::aryptr<u8>     typeg_Getary(atf_amc::FOptG& optg) __attribute__((nothrow));

// Message length (uses length field)
// func:atf_amc.FOptG..GetMsgLength
inline i32           GetMsgLength(const atf_amc::FOptG& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.FOptG..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::FOptG& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.FOptG..Init
inline void          FOptG_Init(atf_amc::FOptG& optg);

// --- atf_amc.FPerfSortString
struct FPerfSortString { // atf_amc.FPerfSortString: Function to test string sorting
    atf_amc::Cstr*   orig_elems;      // pointer to elements
    u32              orig_n;          // number of elements in array
    u32              orig_max;        // max. capacity of array before realloc
    atf_amc::Cstr*   sorted1_elems;   // pointer to elements
    u32              sorted1_n;       // number of elements in array
    u32              sorted1_max;     // max. capacity of array before realloc
    // func:atf_amc.FPerfSortString..AssignOp
    atf_amc::FPerfSortString& operator =(const atf_amc::FPerfSortString &rhs) __attribute__((nothrow));
    // func:atf_amc.FPerfSortString..Ctor
    inline               FPerfSortString() __attribute__((nothrow));
    // func:atf_amc.FPerfSortString..Dtor
    inline               ~FPerfSortString() __attribute__((nothrow));
    // func:atf_amc.FPerfSortString..CopyCtor
    FPerfSortString(const atf_amc::FPerfSortString &rhs) __attribute__((nothrow));
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:atf_amc.FPerfSortString.orig.Addary
algo::aryptr<atf_amc::Cstr> orig_Addary(atf_amc::FPerfSortString& parent, algo::aryptr<atf_amc::Cstr> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:atf_amc.FPerfSortString.orig.Alloc
atf_amc::Cstr&       orig_Alloc(atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:atf_amc.FPerfSortString.orig.AllocAt
atf_amc::Cstr&       orig_AllocAt(atf_amc::FPerfSortString& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.FPerfSortString.orig.AllocN
algo::aryptr<atf_amc::Cstr> orig_AllocN(atf_amc::FPerfSortString& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FPerfSortString.orig.EmptyQ
inline bool          orig_EmptyQ(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FPerfSortString.orig.Find
inline atf_amc::Cstr* orig_Find(atf_amc::FPerfSortString& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.FPerfSortString.orig.Getary
inline algo::aryptr<atf_amc::Cstr> orig_Getary(const atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FPerfSortString.orig.Last
inline atf_amc::Cstr* orig_Last(atf_amc::FPerfSortString& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:atf_amc.FPerfSortString.orig.Max
inline i32           orig_Max(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.FPerfSortString.orig.N
inline i32           orig_N(const atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:atf_amc.FPerfSortString.orig.Remove
void                 orig_Remove(atf_amc::FPerfSortString& parent, u32 i) __attribute__((nothrow));
// func:atf_amc.FPerfSortString.orig.RemoveAll
void                 orig_RemoveAll(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FPerfSortString.orig.RemoveLast
void                 orig_RemoveLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:atf_amc.FPerfSortString.orig.Reserve
inline void          orig_Reserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:atf_amc.FPerfSortString.orig.AbsReserve
void                 orig_AbsReserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:atf_amc.FPerfSortString.orig.Setary
void                 orig_Setary(atf_amc::FPerfSortString& parent, atf_amc::FPerfSortString &rhs) __attribute__((nothrow));
// Copy specified array into orig, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:atf_amc.FPerfSortString.orig.Setary2
void                 orig_Setary(atf_amc::FPerfSortString& parent, const algo::aryptr<atf_amc::Cstr> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FPerfSortString.orig.qFind
inline atf_amc::Cstr& orig_qFind(atf_amc::FPerfSortString& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:atf_amc.FPerfSortString.orig.qLast
inline atf_amc::Cstr& orig_qLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return row id of specified element
// func:atf_amc.FPerfSortString.orig.rowid_Get
inline u64           orig_rowid_Get(atf_amc::FPerfSortString& parent, atf_amc::Cstr &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.FPerfSortString.orig.AllocNVal
algo::aryptr<atf_amc::Cstr> orig_AllocNVal(atf_amc::FPerfSortString& parent, int n_elems, const atf_amc::Cstr& val) __attribute__((nothrow));

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:atf_amc.FPerfSortString.sorted1.Addary
algo::aryptr<atf_amc::Cstr> sorted1_Addary(atf_amc::FPerfSortString& parent, algo::aryptr<atf_amc::Cstr> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:atf_amc.FPerfSortString.sorted1.Alloc
atf_amc::Cstr&       sorted1_Alloc(atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:atf_amc.FPerfSortString.sorted1.AllocAt
atf_amc::Cstr&       sorted1_AllocAt(atf_amc::FPerfSortString& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.FPerfSortString.sorted1.AllocN
algo::aryptr<atf_amc::Cstr> sorted1_AllocN(atf_amc::FPerfSortString& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FPerfSortString.sorted1.EmptyQ
inline bool          sorted1_EmptyQ(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FPerfSortString.sorted1.Find
inline atf_amc::Cstr* sorted1_Find(atf_amc::FPerfSortString& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.FPerfSortString.sorted1.Getary
inline algo::aryptr<atf_amc::Cstr> sorted1_Getary(const atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FPerfSortString.sorted1.Last
inline atf_amc::Cstr* sorted1_Last(atf_amc::FPerfSortString& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:atf_amc.FPerfSortString.sorted1.Max
inline i32           sorted1_Max(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.FPerfSortString.sorted1.N
inline i32           sorted1_N(const atf_amc::FPerfSortString& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:atf_amc.FPerfSortString.sorted1.Remove
void                 sorted1_Remove(atf_amc::FPerfSortString& parent, u32 i) __attribute__((nothrow));
// func:atf_amc.FPerfSortString.sorted1.RemoveAll
void                 sorted1_RemoveAll(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FPerfSortString.sorted1.RemoveLast
void                 sorted1_RemoveLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:atf_amc.FPerfSortString.sorted1.Reserve
inline void          sorted1_Reserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:atf_amc.FPerfSortString.sorted1.AbsReserve
void                 sorted1_AbsReserve(atf_amc::FPerfSortString& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:atf_amc.FPerfSortString.sorted1.Setary
void                 sorted1_Setary(atf_amc::FPerfSortString& parent, atf_amc::FPerfSortString &rhs) __attribute__((nothrow));
// Copy specified array into sorted1, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:atf_amc.FPerfSortString.sorted1.Setary2
void                 sorted1_Setary(atf_amc::FPerfSortString& parent, const algo::aryptr<atf_amc::Cstr> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FPerfSortString.sorted1.qFind
inline atf_amc::Cstr& sorted1_qFind(atf_amc::FPerfSortString& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:atf_amc.FPerfSortString.sorted1.qLast
inline atf_amc::Cstr& sorted1_qLast(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Return row id of specified element
// func:atf_amc.FPerfSortString.sorted1.rowid_Get
inline u64           sorted1_rowid_Get(atf_amc::FPerfSortString& parent, atf_amc::Cstr &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.FPerfSortString.sorted1.AllocNVal
algo::aryptr<atf_amc::Cstr> sorted1_AllocNVal(atf_amc::FPerfSortString& parent, int n_elems, const atf_amc::Cstr& val) __attribute__((nothrow));
// Verify whether array is sorted
// func:atf_amc.FPerfSortString.sorted1.SortedQ
bool                 sorted1_SortedQ(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Insertion sort
// func:atf_amc.FPerfSortString.sorted1.InsertionSort
void                 sorted1_InsertionSort(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Heap sort
// func:atf_amc.FPerfSortString.sorted1.HeapSort
void                 sorted1_HeapSort(atf_amc::FPerfSortString& parent) __attribute__((nothrow));
// Quick sort
// func:atf_amc.FPerfSortString.sorted1.QuickSort
void                 sorted1_QuickSort(atf_amc::FPerfSortString& parent) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.FPerfSortString.orig_curs.Next
inline void          FPerfSortString_orig_curs_Next(FPerfSortString_orig_curs &curs) __attribute__((nothrow));
// func:atf_amc.FPerfSortString.orig_curs.Reset
inline void          FPerfSortString_orig_curs_Reset(FPerfSortString_orig_curs &curs, atf_amc::FPerfSortString &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FPerfSortString.orig_curs.ValidQ
inline bool          FPerfSortString_orig_curs_ValidQ(FPerfSortString_orig_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FPerfSortString.orig_curs.Access
inline atf_amc::Cstr& FPerfSortString_orig_curs_Access(FPerfSortString_orig_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FPerfSortString.sorted1_curs.Next
inline void          FPerfSortString_sorted1_curs_Next(FPerfSortString_sorted1_curs &curs) __attribute__((nothrow));
// func:atf_amc.FPerfSortString.sorted1_curs.Reset
inline void          FPerfSortString_sorted1_curs_Reset(FPerfSortString_sorted1_curs &curs, atf_amc::FPerfSortString &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FPerfSortString.sorted1_curs.ValidQ
inline bool          FPerfSortString_sorted1_curs_ValidQ(FPerfSortString_sorted1_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FPerfSortString.sorted1_curs.Access
inline atf_amc::Cstr& FPerfSortString_sorted1_curs_Access(FPerfSortString_sorted1_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.FPerfSortString..Init
inline void          FPerfSortString_Init(atf_amc::FPerfSortString& parent);
// func:atf_amc.FPerfSortString..Uninit
void                 FPerfSortString_Uninit(atf_amc::FPerfSortString& parent) __attribute__((nothrow));

// --- atf_amc.FThashElem
// create: atf_amc.FDb.thash_elem (Lary)
// global access: ind_thash_elem (Thash, hash field key)
// global access: thash_elem (Lary, by rowid)
struct FThashElem { // atf_amc.FThashElem
    atf_amc::FThashElem*   ind_thash_elem_next;   // hash next
    u64                    key;                   //   0
    // func:atf_amc.FThashElem..AssignOp
    inline atf_amc::FThashElem& operator =(const atf_amc::FThashElem &rhs) = delete;
    // func:atf_amc.FThashElem..CopyCtor
    inline               FThashElem(const atf_amc::FThashElem &rhs) = delete;
private:
    // func:atf_amc.FThashElem..Ctor
    inline               FThashElem() __attribute__((nothrow));
    // func:atf_amc.FThashElem..Dtor
    inline               ~FThashElem() __attribute__((nothrow));
    friend atf_amc::FThashElem& thash_elem_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FThashElem* thash_elem_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 thash_elem_RemoveAll() __attribute__((nothrow));
    friend void                 thash_elem_RemoveLast() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:atf_amc.FThashElem..Init
inline void          FThashElem_Init(atf_amc::FThashElem& thash_elem);
// func:atf_amc.FThashElem..Uninit
void                 FThashElem_Uninit(atf_amc::FThashElem& thash_elem) __attribute__((nothrow));

// --- atf_amc.FTypeC
// create: atf_amc.FTypeA.typec (Inlary)
// global access: bh_typec (Bheap, sort field typec)
// global access: zdl_h_typec (Llist)
// global access: zd_t_typec (Llist)
// global access: zsl_h_typec (Llist)
// global access: zs_t_typec (Llist)
// global access: zs_mt_typec (ZSListMT)
// global access: zdl_hnt_typec (Llist)
// global access: cdl_h_typec (Llist)
// global access: cd_t_typec (Llist)
// global access: csl_h_typec (Llist)
// global access: cs_t_typec (Llist)
struct FTypeC { // atf_amc.FTypeC
    i32                bh_typec_idx;         // index in heap; -1 means not-in-heap
    atf_amc::FTypeC*   zdl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zdl_h_typec_prev;     // previous element
    atf_amc::FTypeC*   zd_t_typec_next;      // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zd_t_typec_prev;      // previous element
    atf_amc::FTypeC*   zsl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zs_t_typec_next;      // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zs_mt_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zdl_hnt_typec_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   zdl_hnt_typec_prev;   // previous element
    atf_amc::FTypeC*   cdl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   cdl_h_typec_prev;     // previous element
    atf_amc::FTypeC*   cd_t_typec_next;      // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   cd_t_typec_prev;      // previous element
    atf_amc::FTypeC*   csl_h_typec_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeC*   cs_t_typec_next;      // zslist link; -1 means not-in-list
    i32                typec;                //   0
    // func:atf_amc.FTypeC..AssignOp
    inline atf_amc::FTypeC& operator =(const atf_amc::FTypeC &rhs) = delete;
    // func:atf_amc.FTypeC..Ctor
    inline               FTypeC() __attribute__((nothrow));
    // func:atf_amc.FTypeC..Dtor
    inline               ~FTypeC() __attribute__((nothrow));
    // func:atf_amc.FTypeC..CopyCtor
    inline               FTypeC(const atf_amc::FTypeC &rhs) = delete;
};

// Copy fields out of row
// func:atf_amc.FTypeC.msghdr.CopyOut
void                 typec_CopyOut(atf_amc::FTypeC &row, atf_amc::TypeC &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FTypeC.msghdr.CopyIn
void                 typec_CopyIn(atf_amc::FTypeC &row, atf_amc::TypeC &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FTypeC..Init
inline void          FTypeC_Init(atf_amc::FTypeC& typec);
// func:atf_amc.FTypeC..Uninit
void                 FTypeC_Uninit(atf_amc::FTypeC& typec) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeC.String  printfmt:Raw
// func:atf_amc.FTypeC..Print
void                 FTypeC_Print(atf_amc::FTypeC& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FTypeA
// create: atf_amc.FDb.typea (Lary)
// global access: typea (Lary, by rowid)
// global access: ind_typea (Thash, hash field typea)
struct FTypeA { // atf_amc.FTypeA
    atf_amc::FTypeA*    ind_typea_next;                             // hash next
    i32                 typea;                                      //   0
    u128                typec_data[sizeu128(atf_amc::FTypeC,10)];   // place for data
    i32                 typec_n;                                    // number of elems current in existence
    enum { typec_max = 10 };
    atf_amc::FTypeB*    zdl_typeb_head;                             // zero-terminated doubly linked list
    i32                 zdl_typeb_n;                                // zero-terminated doubly linked list
    atf_amc::FTypeB*    zdl_typeb_tail;                             // pointer to last element
    i32                 rowid;                                      //   0
    atf_amc::FTypeB**   bh_typeb_elems;                             // binary heap by j
    i32                 bh_typeb_n;                                 // number of elements in the heap
    i32                 bh_typeb_max;                               // max elements in bh_typeb_elems
    // reftype Llist of atf_amc.FTypeA.zdl_typeb prohibits copy
    // reftype Bheap of atf_amc.FTypeA.bh_typeb prohibits copy
    // func:atf_amc.FTypeA..AssignOp
    inline atf_amc::FTypeA& operator =(const atf_amc::FTypeA &rhs) = delete;
    // reftype Llist of atf_amc.FTypeA.zdl_typeb prohibits copy
    // reftype Bheap of atf_amc.FTypeA.bh_typeb prohibits copy
    // func:atf_amc.FTypeA..CopyCtor
    inline               FTypeA(const atf_amc::FTypeA &rhs) = delete;
private:
    // func:atf_amc.FTypeA..Ctor
    inline               FTypeA() __attribute__((nothrow));
    // func:atf_amc.FTypeA..Dtor
    inline               ~FTypeA() __attribute__((nothrow));
    friend atf_amc::FTypeA&     typea_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeA*     typea_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typea_RemoveAll() __attribute__((nothrow));
    friend void                 typea_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FTypeA.msghdr.CopyOut
void                 typea_CopyOut(atf_amc::FTypeA &row, atf_amc::TypeA &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FTypeA.msghdr.CopyIn
void                 typea_CopyIn(atf_amc::FTypeA &row, atf_amc::TypeA &in) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.FTypeA.typec.Alloc
atf_amc::FTypeC&     typec_Alloc(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.FTypeA.typec.AllocMaybe
atf_amc::FTypeC*     typec_AllocMaybe(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_amc.FTypeA.typec.InsertMaybe
atf_amc::FTypeC*     typec_InsertMaybe(atf_amc::FTypeA& typea, const atf_amc::TypeC &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.FTypeA.typec.AllocMem
inline void*         typec_AllocMem(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FTypeA.typec.EmptyQ
inline bool          typec_EmptyQ(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FTypeA.typec.Find
inline atf_amc::FTypeC* typec_Find(atf_amc::FTypeA& typea, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.FTypeA.typec.Getary
inline algo::aryptr<atf_amc::FTypeC> typec_Getary(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return constant 10 -- max. number of items in the pool
// func:atf_amc.FTypeA.typec.Max
inline i32           typec_Max(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.FTypeA.typec.N
inline i32           typec_N(const atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:atf_amc.FTypeA.typec.RemoveAll
void                 typec_RemoveAll(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FTypeA.typec.RemoveLast
void                 typec_RemoveLast(atf_amc::FTypeA& typea) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.FTypeA.typec.qFind
inline atf_amc::FTypeC& typec_qFind(atf_amc::FTypeA& typea, u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:atf_amc.FTypeA.typec.rowid_Get
inline u64           typec_rowid_Get(atf_amc::FTypeA& typea, atf_amc::FTypeC &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FTypeA.typec.XrefMaybe
bool                 typec_XrefMaybe(atf_amc::FTypeC &row);

// Delete all elements in the linked list.
// func:atf_amc.FTypeA.zdl_typeb.Cascdel
void                 zdl_typeb_Cascdel(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FTypeA.zdl_typeb.EmptyQ
inline bool          zdl_typeb_EmptyQ(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FTypeA.zdl_typeb.First
inline atf_amc::FTypeB* zdl_typeb_First(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FTypeA.zdl_typeb.InLlistQ
inline bool          zdl_typeb_InLlistQ(atf_amc::FTypeB& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FTypeA.zdl_typeb.Insert
void                 zdl_typeb_Insert(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FTypeA.zdl_typeb.Last
inline atf_amc::FTypeB* zdl_typeb_Last(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FTypeA.zdl_typeb.N
inline i32           zdl_typeb_N(const atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FTypeA.zdl_typeb.Next
inline atf_amc::FTypeB* zdl_typeb_Next(atf_amc::FTypeB &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FTypeA.zdl_typeb.Prev
inline atf_amc::FTypeB* zdl_typeb_Prev(atf_amc::FTypeB &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FTypeA.zdl_typeb.Remove
void                 zdl_typeb_Remove(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FTypeA.zdl_typeb.RemoveAll
void                 zdl_typeb_RemoveAll(atf_amc::FTypeA& typea) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FTypeA.zdl_typeb.RemoveFirst
atf_amc::FTypeB*     zdl_typeb_RemoveFirst(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FTypeA.zdl_typeb.qLast
inline atf_amc::FTypeB& zdl_typeb_qLast(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow));

// Delete referred-to items.
// Delete all elements referenced by the heap.
// func:atf_amc.FTypeA.bh_typeb.Cascdel
void                 bh_typeb_Cascdel(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Remove all elements from heap and free memory used by the array.
// func:atf_amc.FTypeA.bh_typeb.Dealloc
void                 bh_typeb_Dealloc(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Return true if index is empty
// func:atf_amc.FTypeA.bh_typeb.EmptyQ
inline bool          bh_typeb_EmptyQ(atf_amc::FTypeA& typea) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FTypeA.bh_typeb.First
inline atf_amc::FTypeB* bh_typeb_First(atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:atf_amc.FTypeA.bh_typeb.InBheapQ
inline bool          bh_typeb_InBheapQ(atf_amc::FTypeB& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:atf_amc.FTypeA.bh_typeb.Insert
void                 bh_typeb_Insert(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Return number of items in the heap
// func:atf_amc.FTypeA.bh_typeb.N
inline i32           bh_typeb_N(const atf_amc::FTypeA& typea) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:atf_amc.FTypeA.bh_typeb.Reheap
i32                  bh_typeb_Reheap(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:atf_amc.FTypeA.bh_typeb.ReheapFirst
i32                  bh_typeb_ReheapFirst(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FTypeA.bh_typeb.Remove
void                 bh_typeb_Remove(atf_amc::FTypeA& typea, atf_amc::FTypeB& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:atf_amc.FTypeA.bh_typeb.RemoveAll
void                 bh_typeb_RemoveAll(atf_amc::FTypeA& typea) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:atf_amc.FTypeA.bh_typeb.RemoveFirst
atf_amc::FTypeB*     bh_typeb_RemoveFirst(atf_amc::FTypeA& typea) __attribute__((nothrow));
// Reserve space in index for N more elements
// func:atf_amc.FTypeA.bh_typeb.Reserve
void                 bh_typeb_Reserve(atf_amc::FTypeA& typea, int n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FTypeA..Init
void                 FTypeA_Init(atf_amc::FTypeA& typea);
// cursor points to valid item
// func:atf_amc.FTypeA.typec_curs.Reset
inline void          typea_typec_curs_Reset(typea_typec_curs &curs, atf_amc::FTypeA &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FTypeA.typec_curs.ValidQ
inline bool          typea_typec_curs_ValidQ(typea_typec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FTypeA.typec_curs.Next
inline void          typea_typec_curs_Next(typea_typec_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FTypeA.typec_curs.Access
inline atf_amc::FTypeC& typea_typec_curs_Access(typea_typec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FTypeA.zdl_typeb_curs.Reset
inline void          typea_zdl_typeb_curs_Reset(typea_zdl_typeb_curs &curs, atf_amc::FTypeA &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FTypeA.zdl_typeb_curs.ValidQ
inline bool          typea_zdl_typeb_curs_ValidQ(typea_zdl_typeb_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FTypeA.zdl_typeb_curs.Next
inline void          typea_zdl_typeb_curs_Next(typea_zdl_typeb_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FTypeA.zdl_typeb_curs.Access
inline atf_amc::FTypeB& typea_zdl_typeb_curs_Access(typea_zdl_typeb_curs &curs) __attribute__((nothrow));
// func:atf_amc.FTypeA.bh_typeb_curs.Reserve
void                 typea_bh_typeb_curs_Reserve(typea_bh_typeb_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:atf_amc.FTypeA.bh_typeb_curs.Reset
void                 typea_bh_typeb_curs_Reset(typea_bh_typeb_curs &curs, atf_amc::FTypeA &parent);
// Advance cursor.
// func:atf_amc.FTypeA.bh_typeb_curs.Next
void                 typea_bh_typeb_curs_Next(typea_bh_typeb_curs &curs);
// Access current element. If not more elements, return NULL
// func:atf_amc.FTypeA.bh_typeb_curs.Access
inline atf_amc::FTypeB& typea_bh_typeb_curs_Access(typea_bh_typeb_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:atf_amc.FTypeA.bh_typeb_curs.ValidQ
inline bool          typea_bh_typeb_curs_ValidQ(typea_bh_typeb_curs &curs) __attribute__((nothrow));
// func:atf_amc.FTypeA..Uninit
void                 FTypeA_Uninit(atf_amc::FTypeA& typea) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeA.String  printfmt:Tuple
// func:atf_amc.FTypeA..Print
void                 FTypeA_Print(atf_amc::FTypeA& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FTypeB
// create: atf_amc.FDb.typeb (Tpool)
// access: atf_amc.FTypeA.zdl_typeb (Llist)
// access: atf_amc.FTypeA.bh_typeb (Bheap)
struct FTypeB { // atf_amc.FTypeB
    atf_amc::FTypeB*   typeb_next;       // Pointer to next free element int tpool
    atf_amc::FTypeB*   zdl_typeb_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeB*   zdl_typeb_prev;   // previous element
    i32                bh_typeb_idx;     // index in heap; -1 means not-in-heap
    i32                typea;            //   0
    i32                j;                //   0
    // func:atf_amc.FTypeB..AssignOp
    inline atf_amc::FTypeB& operator =(const atf_amc::FTypeB &rhs) = delete;
    // func:atf_amc.FTypeB..CopyCtor
    inline               FTypeB(const atf_amc::FTypeB &rhs) = delete;
private:
    // func:atf_amc.FTypeB..Ctor
    inline               FTypeB() __attribute__((nothrow));
    // func:atf_amc.FTypeB..Dtor
    inline               ~FTypeB() __attribute__((nothrow));
    friend atf_amc::FTypeB&     typeb_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeB*     typeb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typeb_Delete(atf_amc::FTypeB &row) __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FTypeB.msghdr.CopyOut
void                 typeb_CopyOut(atf_amc::FTypeB &row, atf_amc::TypeB &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FTypeB.msghdr.CopyIn
void                 typeb_CopyIn(atf_amc::FTypeB &row, atf_amc::TypeB &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FTypeB..Init
inline void          FTypeB_Init(atf_amc::FTypeB& typeb);
// func:atf_amc.FTypeB..Uninit
void                 FTypeB_Uninit(atf_amc::FTypeB& typeb) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeB.String  printfmt:Tuple
// func:atf_amc.FTypeB..Print
void                 FTypeB_Print(atf_amc::FTypeB& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FTypeD
// create: atf_amc.FDb.typed (Tpool)
// global access: zd_typed (Llist)
// global access: zs_t_typed (Llist)
// global access: cd_typed (Llist)
struct FTypeD { // atf_amc.FTypeD
    atf_amc::FTypeD*   zd_typed_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeD*   zd_typed_prev;     // previous element
    atf_amc::FTypeD*   zs_t_typed_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeD*   cd_typed_next;     // zslist link; -1 means not-in-list
    atf_amc::FTypeD*   cd_typed_prev;     // previous element
    atf_amc::FTypeD*   typed_next;        // Pointer to next free element int tpool
    i32                typec;             //   0
    // func:atf_amc.FTypeD..AssignOp
    inline atf_amc::FTypeD& operator =(const atf_amc::FTypeD &rhs) = delete;
    // func:atf_amc.FTypeD..CopyCtor
    inline               FTypeD(const atf_amc::FTypeD &rhs) = delete;
private:
    // func:atf_amc.FTypeD..Ctor
    inline               FTypeD() __attribute__((nothrow));
    // func:atf_amc.FTypeD..Dtor
    inline               ~FTypeD() __attribute__((nothrow));
    friend atf_amc::FTypeD&     typed_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeD*     typed_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typed_Delete(atf_amc::FTypeD &row) __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FTypeD.msghdr.CopyOut
void                 typed_CopyOut(atf_amc::FTypeD &row, atf_amc::TypeC &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FTypeD.msghdr.CopyIn
void                 typed_CopyIn(atf_amc::FTypeD &row, atf_amc::TypeC &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FTypeD..Init
inline void          FTypeD_Init(atf_amc::FTypeD& typed);
// func:atf_amc.FTypeD..Uninit
void                 FTypeD_Uninit(atf_amc::FTypeD& typed) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeD.String  printfmt:Raw
// func:atf_amc.FTypeD..Print
void                 FTypeD_Print(atf_amc::FTypeD& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FTypeK
// global access: c_typek (Ptrary)
struct FTypeK { // atf_amc.FTypeK
    u32    value;                //   0
    bool   _db_c_typek_in_ary;   //   false  membership flag
    // func:atf_amc.FTypeK..Ctor
    inline               FTypeK() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:atf_amc.FTypeK..Init
inline void          FTypeK_Init(atf_amc::FTypeK& parent);

// --- atf_amc.FTypeS
// create: atf_amc.FDb.types (Lary)
// global access: types (Lary, by rowid)
// global access: ind_types (Thash, hash field types)
struct FTypeS { // atf_amc.FTypeS
    atf_amc::FTypeS*   ind_types_next;   // hash next
    i32                types;            //   0
    algo::Comment      comment;          //
    atf_amc::FTypeT*   zdl_typet_head;   // zero-terminated doubly linked list
    i32                zdl_typet_n;      // zero-terminated doubly linked list
    atf_amc::FTypeT*   zdl_typet_tail;   // pointer to last element
    // reftype Llist of atf_amc.FTypeS.zdl_typet prohibits copy
    // func:atf_amc.FTypeS..AssignOp
    inline atf_amc::FTypeS& operator =(const atf_amc::FTypeS &rhs) = delete;
    // reftype Llist of atf_amc.FTypeS.zdl_typet prohibits copy
    // func:atf_amc.FTypeS..CopyCtor
    inline               FTypeS(const atf_amc::FTypeS &rhs) = delete;
private:
    // func:atf_amc.FTypeS..Ctor
    inline               FTypeS() __attribute__((nothrow));
    // func:atf_amc.FTypeS..Dtor
    inline               ~FTypeS() __attribute__((nothrow));
    friend atf_amc::FTypeS&     types_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeS*     types_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 types_RemoveAll() __attribute__((nothrow));
    friend void                 types_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FTypeS.msghdr.CopyOut
void                 types_CopyOut(atf_amc::FTypeS &row, atf_amc::TypeS &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FTypeS.msghdr.CopyIn
void                 types_CopyIn(atf_amc::FTypeS &row, atf_amc::TypeS &in) __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FTypeS.zdl_typet.EmptyQ
inline bool          zdl_typet_EmptyQ(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_amc.FTypeS.zdl_typet.First
inline atf_amc::FTypeT* zdl_typet_First(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_amc.FTypeS.zdl_typet.InLlistQ
inline bool          zdl_typet_InLlistQ(atf_amc::FTypeT& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_amc.FTypeS.zdl_typet.Insert
void                 zdl_typet_Insert(atf_amc::FTypeS& types, atf_amc::FTypeT& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_amc.FTypeS.zdl_typet.Last
inline atf_amc::FTypeT* zdl_typet_Last(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_amc.FTypeS.zdl_typet.N
inline i32           zdl_typet_N(const atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_amc.FTypeS.zdl_typet.Next
inline atf_amc::FTypeT* zdl_typet_Next(atf_amc::FTypeT &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_amc.FTypeS.zdl_typet.Prev
inline atf_amc::FTypeT* zdl_typet_Prev(atf_amc::FTypeT &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_amc.FTypeS.zdl_typet.Remove
void                 zdl_typet_Remove(atf_amc::FTypeS& types, atf_amc::FTypeT& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FTypeS.zdl_typet.RemoveAll
void                 zdl_typet_RemoveAll(atf_amc::FTypeS& types) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_amc.FTypeS.zdl_typet.RemoveFirst
atf_amc::FTypeT*     zdl_typet_RemoveFirst(atf_amc::FTypeS& types) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_amc.FTypeS.zdl_typet.qLast
inline atf_amc::FTypeT& zdl_typet_qLast(atf_amc::FTypeS& types) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:atf_amc.FTypeS..Init
inline void          FTypeS_Init(atf_amc::FTypeS& types);
// cursor points to valid item
// func:atf_amc.FTypeS.zdl_typet_curs.Reset
inline void          types_zdl_typet_curs_Reset(types_zdl_typet_curs &curs, atf_amc::FTypeS &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FTypeS.zdl_typet_curs.ValidQ
inline bool          types_zdl_typet_curs_ValidQ(types_zdl_typet_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FTypeS.zdl_typet_curs.Next
inline void          types_zdl_typet_curs_Next(types_zdl_typet_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FTypeS.zdl_typet_curs.Access
inline atf_amc::FTypeT& types_zdl_typet_curs_Access(types_zdl_typet_curs &curs) __attribute__((nothrow));
// func:atf_amc.FTypeS..Uninit
void                 FTypeS_Uninit(atf_amc::FTypeS& types) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeS.String  printfmt:Tuple
// func:atf_amc.FTypeS..Print
void                 FTypeS_Print(atf_amc::FTypeS& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FTypeT
// create: atf_amc.FDb.typet (Lary)
// global access: typet (Lary, by rowid)
// access: atf_amc.FTypeS.zdl_typet (Llist)
struct FTypeT { // atf_amc.FTypeT
    atf_amc::FTypeT*   zdl_typet_next;   // zslist link; -1 means not-in-list
    atf_amc::FTypeT*   zdl_typet_prev;   // previous element
    i32                types;            //   0
    i32                j;                //   0
    // func:atf_amc.FTypeT..AssignOp
    inline atf_amc::FTypeT& operator =(const atf_amc::FTypeT &rhs) = delete;
    // func:atf_amc.FTypeT..CopyCtor
    inline               FTypeT(const atf_amc::FTypeT &rhs) = delete;
private:
    // func:atf_amc.FTypeT..Ctor
    inline               FTypeT() __attribute__((nothrow));
    // func:atf_amc.FTypeT..Dtor
    inline               ~FTypeT() __attribute__((nothrow));
    friend atf_amc::FTypeT&     typet_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::FTypeT*     typet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typet_RemoveAll() __attribute__((nothrow));
    friend void                 typet_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_amc.FTypeT.msghdr.CopyOut
void                 typet_CopyOut(atf_amc::FTypeT &row, atf_amc::TypeT &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_amc.FTypeT.msghdr.CopyIn
void                 typet_CopyIn(atf_amc::FTypeT &row, atf_amc::TypeT &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.FTypeT..Init
inline void          FTypeT_Init(atf_amc::FTypeT& typet);
// func:atf_amc.FTypeT..Uninit
void                 FTypeT_Uninit(atf_amc::FTypeT& typet) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.FTypeT.String  printfmt:Tuple
// func:atf_amc.FTypeT..Print
void                 FTypeT_Print(atf_amc::FTypeT& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeA
// create: atf_amc.FUnitSort.tary (Tary)
// create: atf_amc.FUnitSort.fixary (Inlary)
// access: atf_amc.FTypeA.msghdr (Base)
// access: atf_amc.FUnitSort.c_ptrary (Ptrary)
struct TypeA { // atf_amc.TypeA
    i32   typea;   //   0
    // func:atf_amc.TypeA..EqOp
    inline bool          operator ==(const atf_amc::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeA..NeOp
    inline bool          operator !=(const atf_amc::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeA..LtOp
    inline bool          operator <(const atf_amc::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeA..GtOp
    inline bool          operator >(const atf_amc::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeA..LeOp
    inline bool          operator <=(const atf_amc::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeA..GeOp
    inline bool          operator >=(const atf_amc::TypeA &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeA..Ctor
    inline               TypeA() __attribute__((nothrow));
};

// func:atf_amc.TypeA..Hash
inline u32           TypeA_Hash(u32 prev, const atf_amc::TypeA& rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeA from an ascii string.
// The format of the string is the format of the atf_amc::TypeA's only field
// func:atf_amc.TypeA..ReadStrptrMaybe
bool                 TypeA_ReadStrptrMaybe(atf_amc::TypeA &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.TypeA..Lt
inline bool          TypeA_Lt(atf_amc::TypeA& lhs, atf_amc::TypeA& rhs) __attribute__((nothrow));
// func:atf_amc.TypeA..Cmp
inline i32           TypeA_Cmp(atf_amc::TypeA& lhs, atf_amc::TypeA& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeA..Init
inline void          TypeA_Init(atf_amc::TypeA& fixary);
// func:atf_amc.TypeA..Eq
inline bool          TypeA_Eq(atf_amc::TypeA& lhs, atf_amc::TypeA& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.TypeA..Update
inline bool          TypeA_Update(atf_amc::TypeA &lhs, atf_amc::TypeA& rhs) __attribute__((nothrow));
// Create JSON representation of atf_amc::TypeA under PARENT node
// cfmt:atf_amc.TypeA.Json  printfmt:Auto
// func:atf_amc.TypeA..FmtJson
lib_json::FNode *    TypeA_FmtJson(atf_amc::TypeA& row, lib_json::FNode *parent) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeA.String  printfmt:Raw
// func:atf_amc.TypeA..Print
void                 TypeA_Print(atf_amc::TypeA& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.FUnitSort
struct FUnitSort { // atf_amc.FUnitSort
    atf_amc::TypeA*    tary_elems;          // pointer to elements
    u32                tary_n;              // number of elements in array
    u32                tary_max;            // max. capacity of array before realloc
    atf_amc::TypeA**   c_ptrary_elems;      // array of pointers
    u32                c_ptrary_n;          // array of pointers
    u32                c_ptrary_max;        // capacity of allocated array
    atf_amc::TypeA     fixary_elems[100];   // fixed array
    // reftype Ptrary of atf_amc.FUnitSort.c_ptrary prohibits copy
    // func:atf_amc.FUnitSort..AssignOp
    atf_amc::FUnitSort&  operator =(const atf_amc::FUnitSort &rhs) = delete;
    // func:atf_amc.FUnitSort..Ctor
    inline               FUnitSort() __attribute__((nothrow));
    // func:atf_amc.FUnitSort..Dtor
    inline               ~FUnitSort() __attribute__((nothrow));
    // reftype Ptrary of atf_amc.FUnitSort.c_ptrary prohibits copy
    // func:atf_amc.FUnitSort..CopyCtor
    FUnitSort(const atf_amc::FUnitSort &rhs) = delete;
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:atf_amc.FUnitSort.tary.Addary
algo::aryptr<atf_amc::TypeA> tary_Addary(atf_amc::FUnitSort& parent, algo::aryptr<atf_amc::TypeA> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:atf_amc.FUnitSort.tary.Alloc
atf_amc::TypeA&      tary_Alloc(atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:atf_amc.FUnitSort.tary.AllocAt
atf_amc::TypeA&      tary_AllocAt(atf_amc::FUnitSort& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.FUnitSort.tary.AllocN
algo::aryptr<atf_amc::TypeA> tary_AllocN(atf_amc::FUnitSort& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.FUnitSort.tary.EmptyQ
inline bool          tary_EmptyQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FUnitSort.tary.Find
inline atf_amc::TypeA* tary_Find(atf_amc::FUnitSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.FUnitSort.tary.Getary
inline algo::aryptr<atf_amc::TypeA> tary_Getary(const atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.FUnitSort.tary.Last
inline atf_amc::TypeA* tary_Last(atf_amc::FUnitSort& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:atf_amc.FUnitSort.tary.Max
inline i32           tary_Max(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.FUnitSort.tary.N
inline i32           tary_N(const atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:atf_amc.FUnitSort.tary.Remove
void                 tary_Remove(atf_amc::FUnitSort& parent, u32 i) __attribute__((nothrow));
// func:atf_amc.FUnitSort.tary.RemoveAll
void                 tary_RemoveAll(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.FUnitSort.tary.RemoveLast
void                 tary_RemoveLast(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:atf_amc.FUnitSort.tary.Reserve
inline void          tary_Reserve(atf_amc::FUnitSort& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:atf_amc.FUnitSort.tary.AbsReserve
void                 tary_AbsReserve(atf_amc::FUnitSort& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:atf_amc.FUnitSort.tary.Setary
void                 tary_Setary(atf_amc::FUnitSort& parent, atf_amc::FUnitSort &rhs) __attribute__((nothrow));
// Copy specified array into tary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:atf_amc.FUnitSort.tary.Setary2
void                 tary_Setary(atf_amc::FUnitSort& parent, const algo::aryptr<atf_amc::TypeA> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.FUnitSort.tary.qFind
inline atf_amc::TypeA& tary_qFind(atf_amc::FUnitSort& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:atf_amc.FUnitSort.tary.qLast
inline atf_amc::TypeA& tary_qLast(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return row id of specified element
// func:atf_amc.FUnitSort.tary.rowid_Get
inline u64           tary_rowid_Get(atf_amc::FUnitSort& parent, atf_amc::TypeA &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.FUnitSort.tary.AllocNVal
algo::aryptr<atf_amc::TypeA> tary_AllocNVal(atf_amc::FUnitSort& parent, int n_elems, const atf_amc::TypeA& val) __attribute__((nothrow));
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
// func:atf_amc.FUnitSort.tary.ReadStrptrMaybe
bool                 tary_ReadStrptrMaybe(atf_amc::FUnitSort& parent, algo::strptr in_str) __attribute__((nothrow));
// Verify whether array is sorted
// func:atf_amc.FUnitSort.tary.SortedQ
bool                 tary_SortedQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insertion sort
// func:atf_amc.FUnitSort.tary.InsertionSort
void                 tary_InsertionSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Heap sort
// func:atf_amc.FUnitSort.tary.HeapSort
void                 tary_HeapSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Quick sort
// func:atf_amc.FUnitSort.tary.QuickSort
void                 tary_QuickSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));

// Return true if index is empty
// func:atf_amc.FUnitSort.c_ptrary.EmptyQ
inline bool          c_ptrary_EmptyQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FUnitSort.c_ptrary.Find
inline atf_amc::TypeA* c_ptrary_Find(atf_amc::FUnitSort& parent, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:atf_amc.FUnitSort.c_ptrary.Getary
inline algo::aryptr<atf_amc::TypeA*> c_ptrary_Getary(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:atf_amc.FUnitSort.c_ptrary.Insert
void                 c_ptrary_Insert(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:atf_amc.FUnitSort.c_ptrary.ScanInsertMaybe
bool                 c_ptrary_ScanInsertMaybe(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:atf_amc.FUnitSort.c_ptrary.N
inline i32           c_ptrary_N(const atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:atf_amc.FUnitSort.c_ptrary.Remove
void                 c_ptrary_Remove(atf_amc::FUnitSort& parent, atf_amc::TypeA& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_amc.FUnitSort.c_ptrary.RemoveAll
inline void          c_ptrary_RemoveAll(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:atf_amc.FUnitSort.c_ptrary.Reserve
void                 c_ptrary_Reserve(atf_amc::FUnitSort& parent, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:atf_amc.FUnitSort.c_ptrary.qFind
inline atf_amc::TypeA& c_ptrary_qFind(atf_amc::FUnitSort& parent, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:atf_amc.FUnitSort.c_ptrary.qLast
inline atf_amc::TypeA& c_ptrary_qLast(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Verify whether array is sorted
// func:atf_amc.FUnitSort.c_ptrary.SortedQ
bool                 c_ptrary_SortedQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insertion sort
// func:atf_amc.FUnitSort.c_ptrary.InsertionSort
void                 c_ptrary_InsertionSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Heap sort
// func:atf_amc.FUnitSort.c_ptrary.HeapSort
void                 c_ptrary_HeapSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Quick sort
// func:atf_amc.FUnitSort.c_ptrary.QuickSort
void                 c_ptrary_QuickSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));

// Set all elements of fixed array to value RHS
// func:atf_amc.FUnitSort.fixary.Fill
inline void          fixary_Fill(atf_amc::FUnitSort& parent, const atf_amc::TypeA &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.FUnitSort.fixary.Find
inline atf_amc::TypeA* fixary_Find(atf_amc::FUnitSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array fixary as aryptr.
// func:atf_amc.FUnitSort.fixary.Getary
inline algo::aryptr<atf_amc::TypeA> fixary_Getary(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return max number of items in the array
// func:atf_amc.FUnitSort.fixary.Max
inline i32           fixary_Max(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.FUnitSort.fixary.N
inline i32           fixary_N(const atf_amc::FUnitSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
// func:atf_amc.FUnitSort.fixary.Setary
inline void          fixary_Setary(atf_amc::FUnitSort& parent, const algo::aryptr<atf_amc::TypeA> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.FUnitSort.fixary.qFind
inline atf_amc::TypeA& fixary_qFind(atf_amc::FUnitSort& parent, u64 t) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
// func:atf_amc.FUnitSort.fixary.ReadStrptrMaybe
bool                 fixary_ReadStrptrMaybe(atf_amc::FUnitSort& parent, algo::strptr in_str) __attribute__((nothrow));
// Verify whether array is sorted
// func:atf_amc.FUnitSort.fixary.SortedQ
bool                 fixary_SortedQ(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insertion sort
// func:atf_amc.FUnitSort.fixary.InsertionSort
void                 fixary_InsertionSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Heap sort
// func:atf_amc.FUnitSort.fixary.HeapSort
void                 fixary_HeapSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Quick sort
// func:atf_amc.FUnitSort.fixary.QuickSort
void                 fixary_QuickSort(atf_amc::FUnitSort& parent) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.FUnitSort.fixary.XrefMaybe
bool                 fixary_XrefMaybe(atf_amc::TypeA &row);

// proceed to next item
// func:atf_amc.FUnitSort.tary_curs.Next
inline void          FUnitSort_tary_curs_Next(FUnitSort_tary_curs &curs) __attribute__((nothrow));
// func:atf_amc.FUnitSort.tary_curs.Reset
inline void          FUnitSort_tary_curs_Reset(FUnitSort_tary_curs &curs, atf_amc::FUnitSort &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FUnitSort.tary_curs.ValidQ
inline bool          FUnitSort_tary_curs_ValidQ(FUnitSort_tary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FUnitSort.tary_curs.Access
inline atf_amc::TypeA& FUnitSort_tary_curs_Access(FUnitSort_tary_curs &curs) __attribute__((nothrow));
// func:atf_amc.FUnitSort.c_ptrary_curs.Reset
inline void          FUnitSort_c_ptrary_curs_Reset(FUnitSort_c_ptrary_curs &curs, atf_amc::FUnitSort &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FUnitSort.c_ptrary_curs.ValidQ
inline bool          FUnitSort_c_ptrary_curs_ValidQ(FUnitSort_c_ptrary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FUnitSort.c_ptrary_curs.Next
inline void          FUnitSort_c_ptrary_curs_Next(FUnitSort_c_ptrary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FUnitSort.c_ptrary_curs.Access
inline atf_amc::TypeA& FUnitSort_c_ptrary_curs_Access(FUnitSort_c_ptrary_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FUnitSort.fixary_curs.Reset
inline void          FUnitSort_fixary_curs_Reset(FUnitSort_fixary_curs &curs, atf_amc::FUnitSort &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.FUnitSort.fixary_curs.ValidQ
inline bool          FUnitSort_fixary_curs_ValidQ(FUnitSort_fixary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.FUnitSort.fixary_curs.Next
inline void          FUnitSort_fixary_curs_Next(FUnitSort_fixary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.FUnitSort.fixary_curs.Access
inline atf_amc::TypeA& FUnitSort_fixary_curs_Access(FUnitSort_fixary_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.FUnitSort..Init
inline void          FUnitSort_Init(atf_amc::FUnitSort& parent);
// func:atf_amc.FUnitSort..Uninit
void                 FUnitSort_Uninit(atf_amc::FUnitSort& parent) __attribute__((nothrow));

// --- atf_amc.FieldId
#pragma pack(push,1)
struct FieldId { // atf_amc.FieldId: Field read helper
    i32   value;   //   -1
    // func:atf_amc.FieldId.value.Cast
    inline               operator atf_amc_FieldIdEnum() const __attribute__((nothrow));
    // func:atf_amc.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:atf_amc.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:atf_amc.FieldId..EnumCtor
    inline               FieldId(atf_amc_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.FieldId.value.GetEnum
inline atf_amc_FieldIdEnum value_GetEnum(const atf_amc::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.FieldId.value.SetEnum
inline void          value_SetEnum(atf_amc::FieldId& parent, atf_amc_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.FieldId.value.ToCstr
const char*          value_ToCstr(const atf_amc::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.FieldId.value.Print
void                 value_Print(const atf_amc::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.FieldId.value.SetStrptr
void                 value_SetStrptr(atf_amc::FieldId& parent, algo::strptr rhs, atf_amc_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::FieldId from an ascii string.
// The format of the string is the format of the atf_amc::FieldId's only field
// func:atf_amc.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(atf_amc::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.FieldId..Init
inline void          FieldId_Init(atf_amc::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.FieldId.String  printfmt:Raw
// func:atf_amc.FieldId..Print
void                 FieldId_Print(atf_amc::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Hooktype
// access: atf_amc.Hooktype.callback (Hook)
struct Hooktype { // atf_amc.Hooktype
    atf_amc::parent_callback_hook   callback;       //   NULL  Pointer to a function
    u64                             callback_ctx;   //   0  Callback context
    i32                             value;          //   0
    // func:atf_amc.Hooktype..Ctor
    inline               Hooktype() __attribute__((nothrow));
};

// Invoke function by pointer
// func:atf_amc.Hooktype.callback.Call
inline void          callback_Call(atf_amc::Hooktype& parent, atf_amc::Hooktype& arg) __attribute__((nothrow));
// Assign 0-argument hook with no context pointer
// func:atf_amc.Hooktype.callback.Set0
inline void          callback_Set0(atf_amc::Hooktype& parent, void (*fcn)() ) __attribute__((nothrow));
// Assign 1-argument hook with context pointer
// func:atf_amc.Hooktype.callback.Set1
template<class T> inline void callback_Set1(atf_amc::Hooktype& parent, T& ctx, void (*fcn)(T&) ) __attribute__((nothrow));
// Assign 2-argument hook with context pointer
// func:atf_amc.Hooktype.callback.Set2
template<class T> inline void callback_Set2(atf_amc::Hooktype& parent, T& ctx, void (*fcn)(T&, atf_amc::Hooktype& arg) ) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.Hooktype..Init
inline void          Hooktype_Init(atf_amc::Hooktype& parent);

// --- atf_amc.InlaryPrint
struct InlaryPrint { // atf_amc.InlaryPrint
    u32    fixary_elems[3];                 //   0  fixed array
    u128   inlary_data[sizeu128(u32,10)];   // place for data
    i32    inlary_n;                        // number of elems current in existence
    enum { inlary_max = 10 };
    // func:atf_amc.InlaryPrint..AssignOp
    inline atf_amc::InlaryPrint& operator =(const atf_amc::InlaryPrint &rhs) __attribute__((nothrow));
    // func:atf_amc.InlaryPrint..Ctor
    inline               InlaryPrint() __attribute__((nothrow));
    // func:atf_amc.InlaryPrint..Dtor
    inline               ~InlaryPrint() __attribute__((nothrow));
    // func:atf_amc.InlaryPrint..CopyCtor
    inline               InlaryPrint(const atf_amc::InlaryPrint &rhs) __attribute__((nothrow));
};

// Set all elements of fixed array to value RHS
// func:atf_amc.InlaryPrint.fixary.Fill
inline void          fixary_Fill(atf_amc::InlaryPrint& parent, const u32 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.InlaryPrint.fixary.Find
inline u32*          fixary_Find(atf_amc::InlaryPrint& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array fixary as aryptr.
// func:atf_amc.InlaryPrint.fixary.Getary
inline algo::aryptr<u32> fixary_Getary(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return max number of items in the array
// func:atf_amc.InlaryPrint.fixary.Max
inline i32           fixary_Max(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.InlaryPrint.fixary.N
inline i32           fixary_N(const atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
// func:atf_amc.InlaryPrint.fixary.Setary
inline void          fixary_Setary(atf_amc::InlaryPrint& parent, const algo::aryptr<u32> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.InlaryPrint.fixary.qFind
inline u32&          fixary_qFind(atf_amc::InlaryPrint& parent, u64 t) __attribute__((nothrow));
// Convert fixary to a string.
// The separator character is ' '.
// func:atf_amc.InlaryPrint.fixary.Print
void                 fixary_Print(atf_amc::InlaryPrint& parent, algo::cstring &rhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
// func:atf_amc.InlaryPrint.fixary.ReadStrptrMaybe
bool                 fixary_ReadStrptrMaybe(atf_amc::InlaryPrint& parent, algo::strptr in_str) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.InlaryPrint.inlary.Alloc
u32&                 inlary_Alloc(atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.InlaryPrint.inlary.AllocMaybe
u32*                 inlary_AllocMaybe(atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.InlaryPrint.inlary.AllocMem
inline void*         inlary_AllocMem(atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.InlaryPrint.inlary.EmptyQ
inline bool          inlary_EmptyQ(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.InlaryPrint.inlary.Find
inline u32*          inlary_Find(atf_amc::InlaryPrint& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.InlaryPrint.inlary.Getary
inline algo::aryptr<u32> inlary_Getary(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return constant 10 -- max. number of items in the pool
// func:atf_amc.InlaryPrint.inlary.Max
inline i32           inlary_Max(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.InlaryPrint.inlary.N
inline i32           inlary_N(const atf_amc::InlaryPrint& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:atf_amc.InlaryPrint.inlary.RemoveAll
void                 inlary_RemoveAll(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.InlaryPrint.inlary.RemoveLast
void                 inlary_RemoveLast(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
// func:atf_amc.InlaryPrint.inlary.Setary
inline void          inlary_Setary(atf_amc::InlaryPrint& parent, const algo::aryptr<u32> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.InlaryPrint.inlary.qFind
inline u32&          inlary_qFind(atf_amc::InlaryPrint& parent, u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:atf_amc.InlaryPrint.inlary.rowid_Get
inline u64           inlary_rowid_Get(atf_amc::InlaryPrint& parent, u32 &row) __attribute__((nothrow));
// Convert inlary to a string.
// The separator character is ' '.
// func:atf_amc.InlaryPrint.inlary.Print
void                 inlary_Print(atf_amc::InlaryPrint& parent, algo::cstring &rhs) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
// func:atf_amc.InlaryPrint.inlary.ReadStrptrMaybe
bool                 inlary_ReadStrptrMaybe(atf_amc::InlaryPrint& parent, algo::strptr in_str) __attribute__((nothrow));

// cursor points to valid item
// func:atf_amc.InlaryPrint.fixary_curs.Reset
inline void          InlaryPrint_fixary_curs_Reset(InlaryPrint_fixary_curs &curs, atf_amc::InlaryPrint &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.InlaryPrint.fixary_curs.ValidQ
inline bool          InlaryPrint_fixary_curs_ValidQ(InlaryPrint_fixary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.InlaryPrint.fixary_curs.Next
inline void          InlaryPrint_fixary_curs_Next(InlaryPrint_fixary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.InlaryPrint.fixary_curs.Access
inline u32&          InlaryPrint_fixary_curs_Access(InlaryPrint_fixary_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.InlaryPrint.inlary_curs.Reset
inline void          InlaryPrint_inlary_curs_Reset(InlaryPrint_inlary_curs &curs, atf_amc::InlaryPrint &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.InlaryPrint.inlary_curs.ValidQ
inline bool          InlaryPrint_inlary_curs_ValidQ(InlaryPrint_inlary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.InlaryPrint.inlary_curs.Next
inline void          InlaryPrint_inlary_curs_Next(InlaryPrint_inlary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.InlaryPrint.inlary_curs.Access
inline u32&          InlaryPrint_inlary_curs_Access(InlaryPrint_inlary_curs &curs) __attribute__((nothrow));
// func:atf_amc.InlaryPrint..ReadFieldMaybe
bool                 InlaryPrint_ReadFieldMaybe(atf_amc::InlaryPrint& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::InlaryPrint from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.InlaryPrint..ReadStrptrMaybe
bool                 InlaryPrint_ReadStrptrMaybe(atf_amc::InlaryPrint &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.InlaryPrint..Init
void                 InlaryPrint_Init(atf_amc::InlaryPrint& parent);
// func:atf_amc.InlaryPrint..Uninit
void                 InlaryPrint_Uninit(atf_amc::InlaryPrint& parent) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.InlaryPrint.String  printfmt:Tuple
// func:atf_amc.InlaryPrint..Print
void                 InlaryPrint_Print(atf_amc::InlaryPrint& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Lary32
struct Lary32 { // atf_amc.Lary32
    u32*   lary_lary[32];   // level array
    i32    lary_n;          // number of elements in array
    // func:atf_amc.Lary32..Ctor
    inline               Lary32() __attribute__((nothrow));
    // func:atf_amc.Lary32..Dtor
    inline               ~Lary32() __attribute__((nothrow));
};

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_amc.Lary32.lary.Alloc
u32&                 lary_Alloc(atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_amc.Lary32.lary.AllocMaybe
u32*                 lary_AllocMaybe(atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:atf_amc.Lary32.lary.AllocMem
void*                lary_AllocMem(atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.Lary32.lary.EmptyQ
inline bool          lary_EmptyQ(atf_amc::Lary32& parent) __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.Lary32.lary.Find
inline u32*          lary_Find(atf_amc::Lary32& parent, u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.Lary32.lary.Last
inline u32*          lary_Last(atf_amc::Lary32& parent) __attribute__((nothrow, pure));
// Return number of items in the pool
// func:atf_amc.Lary32.lary.N
inline i32           lary_N(const atf_amc::Lary32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:atf_amc.Lary32.lary.RemoveAll
void                 lary_RemoveAll(atf_amc::Lary32& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.Lary32.lary.RemoveLast
void                 lary_RemoveLast(atf_amc::Lary32& parent) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.Lary32.lary.qFind
inline u32&          lary_qFind(atf_amc::Lary32& parent, u64 t) __attribute__((nothrow, pure));

// cursor points to valid item
// func:atf_amc.Lary32.lary_curs.Reset
inline void          Lary32_lary_curs_Reset(Lary32_lary_curs &curs, atf_amc::Lary32 &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Lary32.lary_curs.ValidQ
inline bool          Lary32_lary_curs_ValidQ(Lary32_lary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.Lary32.lary_curs.Next
inline void          Lary32_lary_curs_Next(Lary32_lary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.Lary32.lary_curs.Access
inline u32&          Lary32_lary_curs_Access(Lary32_lary_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Lary32..Init
void                 Lary32_Init(atf_amc::Lary32& parent);
// func:atf_amc.Lary32..Uninit
void                 Lary32_Uninit(atf_amc::Lary32& parent) __attribute__((nothrow));

// --- atf_amc.Linebuf
// create: atf_amc.FDb.linebuf (Cppstack)
struct Linebuf { // atf_amc.Linebuf
    u8              in_elems[64];      // pointer to elements of inline array
    i32             in_start;          // beginning of valid bytes (in bytes)
    i32             in_end;            // end of valid bytes (in bytes)
    bool            in_eof;            // no more data will be written to buffer
    algo::Errcode   in_err;            // system error code
    bool            in_msgvalid;       // current message is valid
    i32             in_msglen;         // current message length
    bool            in_epoll_enable;   // use epoll?
    enum { in_max = 64 };
    // func:atf_amc.Linebuf..Ctor
    inline               Linebuf() __attribute__((nothrow));
};

// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
//
// func:atf_amc.Linebuf.in.GetMsg
algo::aryptr<char>   in_GetMsg(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_amc.Linebuf.in.Max
inline i32           in_Max(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.Linebuf.in.N
inline i32           in_N(atf_amc::Linebuf& linebuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.Linebuf.in.RemoveAll
void                 in_RemoveAll(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_amc.Linebuf.in.SkipBytes
void                 in_SkipBytes(atf_amc::Linebuf& linebuf, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.Linebuf.in.SkipMsg
void                 in_SkipMsg(atf_amc::Linebuf& linebuf) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.Linebuf.in.WriteAll
bool                 in_WriteAll(atf_amc::Linebuf& linebuf, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.Linebuf..Init
void                 Linebuf_Init(atf_amc::Linebuf& linebuf);
// print string representation of ROW to string STR
// cfmt:atf_amc.Linebuf.String  printfmt:Raw
// func:atf_amc.Linebuf..Print
void                 Linebuf_Print(atf_amc::Linebuf& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgHdrLT
// create: atf_amc.MsgLTO.o (Opt)
// create: atf_amc.MsgLTV.v (Varlen)
// create: atf_amc.Msgbuf.out_extra (Fbuf)
// create: atf_amc.Msgbuf.in_extra (Fbuf)
// access: atf_amc.MsgLTA.base (Base)
// access: atf_amc.MsgLTB.base (Base)
// access: atf_amc.MsgLTO.base (Base)
// access: atf_amc.MsgLTV.base (Base)
// access: atf_amc.MsgHdrLT_curs.msg (Ptr)
#pragma pack(push,1)
struct MsgHdrLT { // atf_amc.MsgHdrLT: length-type header
    u8     len;    //   0
    char   type;   //   0
    // func:atf_amc.MsgHdrLT..Ctor
    inline               MsgHdrLT() __attribute__((nothrow));
    // func:atf_amc.MsgHdrLT..FieldwiseCtor
    explicit inline               MsgHdrLT(u8 in_len, char in_type) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.MsgHdrLT.type.GetEnum
inline atf_amc_MsgHdrLT_type_Enum type_GetEnum(const atf_amc::MsgHdrLT& o) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.MsgHdrLT.type.SetEnum
inline void          type_SetEnum(atf_amc::MsgHdrLT& o, atf_amc_MsgHdrLT_type_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.MsgHdrLT.type.ToCstr
const char*          type_ToCstr(const atf_amc::MsgHdrLT& o) __attribute__((nothrow));
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
// func:atf_amc.MsgHdrLT.type.Print
void                 type_Print(const atf_amc::MsgHdrLT& o, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.MsgHdrLT.type.SetStrptrMaybe
bool                 type_SetStrptrMaybe(atf_amc::MsgHdrLT& o, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.MsgHdrLT.type.SetStrptr
void                 type_SetStrptr(atf_amc::MsgHdrLT& o, algo::strptr rhs, atf_amc_MsgHdrLT_type_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.MsgHdrLT.type.ReadStrptrMaybe
bool                 type_ReadStrptrMaybe(atf_amc::MsgHdrLT& o, algo::strptr rhs) __attribute__((nothrow));

// func:atf_amc.MsgHdrLT..ReadFieldMaybe
bool                 MsgHdrLT_ReadFieldMaybe(atf_amc::MsgHdrLT& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::MsgHdrLT from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.MsgHdrLT..ReadStrptrMaybe
bool                 MsgHdrLT_ReadStrptrMaybe(atf_amc::MsgHdrLT &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.MsgHdrLT..GetMsgLength
inline i32           GetMsgLength(const atf_amc::MsgHdrLT& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.MsgHdrLT..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::MsgHdrLT& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgHdrLT..Init
inline void          MsgHdrLT_Init(atf_amc::MsgHdrLT& o);
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgHdrLT.String  printfmt:Tuple
// func:atf_amc.MsgHdrLT..Print
void                 MsgHdrLT_Print(atf_amc::MsgHdrLT& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgHdrLTMsgsCase
#pragma pack(push,1)
struct MsgHdrLTMsgsCase { // atf_amc.MsgHdrLTMsgsCase: Enum for dispatch atf_amc.MsgHdrLTMsgs
    u32   value;   //   0
    // func:atf_amc.MsgHdrLTMsgsCase.value.Cast
    inline               operator atf_amc_MsgHdrLTMsgsCaseEnum() const __attribute__((nothrow));
    // func:atf_amc.MsgHdrLTMsgsCase..Ctor
    inline               MsgHdrLTMsgsCase() __attribute__((nothrow));
    // func:atf_amc.MsgHdrLTMsgsCase..FieldwiseCtor
    explicit inline               MsgHdrLTMsgsCase(u32 in_value) __attribute__((nothrow));
    // func:atf_amc.MsgHdrLTMsgsCase..EnumCtor
    inline               MsgHdrLTMsgsCase(atf_amc_MsgHdrLTMsgsCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.MsgHdrLTMsgsCase.value.GetEnum
inline atf_amc_MsgHdrLTMsgsCaseEnum value_GetEnum(const atf_amc::MsgHdrLTMsgsCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.MsgHdrLTMsgsCase.value.SetEnum
inline void          value_SetEnum(atf_amc::MsgHdrLTMsgsCase& parent, atf_amc_MsgHdrLTMsgsCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.MsgHdrLTMsgsCase.value.ToCstr
const char*          value_ToCstr(const atf_amc::MsgHdrLTMsgsCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.MsgHdrLTMsgsCase.value.Print
void                 value_Print(const atf_amc::MsgHdrLTMsgsCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.MsgHdrLTMsgsCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::MsgHdrLTMsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.MsgHdrLTMsgsCase.value.SetStrptr
void                 value_SetStrptr(atf_amc::MsgHdrLTMsgsCase& parent, algo::strptr rhs, atf_amc_MsgHdrLTMsgsCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.MsgHdrLTMsgsCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::MsgHdrLTMsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::MsgHdrLTMsgsCase from an ascii string.
// The format of the string is the format of the atf_amc::MsgHdrLTMsgsCase's only field
// func:atf_amc.MsgHdrLTMsgsCase..ReadStrptrMaybe
bool                 MsgHdrLTMsgsCase_ReadStrptrMaybe(atf_amc::MsgHdrLTMsgsCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgHdrLTMsgsCase..Init
inline void          MsgHdrLTMsgsCase_Init(atf_amc::MsgHdrLTMsgsCase& parent);

// --- atf_amc.MsgHdrLT_curs
#pragma pack(push,1)
struct MsgHdrLT_curs { // atf_amc.MsgHdrLT_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::MsgHdrLT *ChildType;
    atf_amc::MsgHdrLT*   msg;      // Pointer to current message. optional pointer
    u8*                  bytes;    // Beginning of region. optional pointer
    i32                  limit;    //   0  # Of bytes in the region
    i32                  msglen;   //   0  Length of current message (if any)
    // func:atf_amc.MsgHdrLT_curs..Ctor
    inline               MsgHdrLT_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.MsgHdrLT_curs..ValidQ
inline bool          MsgHdrLT_curs_ValidQ(atf_amc::MsgHdrLT_curs& curs) __attribute__((nothrow));
// func:atf_amc.MsgHdrLT_curs..Reset
inline void          MsgHdrLT_curs_Reset(atf_amc::MsgHdrLT_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.MsgHdrLT_curs..Access
inline atf_amc::MsgHdrLT*& MsgHdrLT_curs_Access(atf_amc::MsgHdrLT_curs& curs) __attribute__((nothrow));
// func:atf_amc.MsgHdrLT_curs..Next
inline void          MsgHdrLT_curs_Next(atf_amc::MsgHdrLT_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgHdrLT_curs..Init
inline void          MsgHdrLT_curs_Init(atf_amc::MsgHdrLT_curs& parent);

// --- atf_amc.MsgType
#pragma pack(push,1)
struct MsgType { // atf_amc.MsgType
    u16   value;   //   0
    // func:atf_amc.MsgType.value.Cast
    inline               operator atf_amc_MsgTypeEnum() const __attribute__((nothrow));
    // func:atf_amc.MsgType..EqOp
    inline bool          operator ==(const atf_amc::MsgType &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgType..NeOp
    inline bool          operator !=(const atf_amc::MsgType &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgType..LtOp
    inline bool          operator <(const atf_amc::MsgType &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgType..GtOp
    inline bool          operator >(const atf_amc::MsgType &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgType..LeOp
    inline bool          operator <=(const atf_amc::MsgType &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgType..GeOp
    inline bool          operator >=(const atf_amc::MsgType &rhs) const __attribute__((nothrow));
    // define enum comparison operator to avoid ambiguity
    // func:atf_amc.MsgType..EqEnum
    inline bool          operator ==(atf_amc_MsgTypeEnum rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgType..Ctor
    inline               MsgType() __attribute__((nothrow));
    // func:atf_amc.MsgType..FieldwiseCtor
    explicit inline               MsgType(u16 in_value) __attribute__((nothrow));
    // func:atf_amc.MsgType..EnumCtor
    inline               MsgType(atf_amc_MsgTypeEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.MsgType.value.GetEnum
inline atf_amc_MsgTypeEnum value_GetEnum(const atf_amc::MsgType& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.MsgType.value.SetEnum
inline void          value_SetEnum(atf_amc::MsgType& parent, atf_amc_MsgTypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.MsgType.value.ToCstr
const char*          value_ToCstr(const atf_amc::MsgType& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.MsgType.value.Print
void                 value_Print(const atf_amc::MsgType& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.MsgType.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::MsgType& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.MsgType.value.SetStrptr
void                 value_SetStrptr(atf_amc::MsgType& parent, algo::strptr rhs, atf_amc_MsgTypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.MsgType.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::MsgType& parent, algo::strptr rhs) __attribute__((nothrow));

// func:atf_amc.MsgType..Hash
inline u32           MsgType_Hash(u32 prev, atf_amc::MsgType rhs) __attribute__((nothrow));
// Read fields of atf_amc::MsgType from an ascii string.
// The format of the string is the format of the atf_amc::MsgType's only field
// func:atf_amc.MsgType..ReadStrptrMaybe
bool                 MsgType_ReadStrptrMaybe(atf_amc::MsgType &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.MsgType..Lt
inline bool          MsgType_Lt(atf_amc::MsgType lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// func:atf_amc.MsgType..Cmp
inline i32           MsgType_Cmp(atf_amc::MsgType lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgType..Init
inline void          MsgType_Init(atf_amc::MsgType& parent);
// func:atf_amc.MsgType..Eq
inline bool          MsgType_Eq(atf_amc::MsgType lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.MsgType..Update
inline bool          MsgType_Update(atf_amc::MsgType &lhs, atf_amc::MsgType rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgType.String  printfmt:Raw
// func:atf_amc.MsgType..Print
void                 MsgType_Print(atf_amc::MsgType row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgLength
#pragma pack(push,1)
struct MsgLength { // atf_amc.MsgLength
    u16   value;   //   0
    // func:atf_amc.MsgLength.value.Cast
    inline               operator u16() const __attribute__((nothrow));
    // func:atf_amc.MsgLength..Ctor
    inline               MsgLength() __attribute__((nothrow));
    // func:atf_amc.MsgLength..FieldwiseCtor
    explicit inline               MsgLength(u16 in_value) __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.MsgLength..Hash
inline u32           MsgLength_Hash(u32 prev, atf_amc::MsgLength rhs) __attribute__((nothrow));
// Read fields of atf_amc::MsgLength from an ascii string.
// The format of the string is the format of the atf_amc::MsgLength's only field
// func:atf_amc.MsgLength..ReadStrptrMaybe
bool                 MsgLength_ReadStrptrMaybe(atf_amc::MsgLength &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.MsgLength..Lt
inline bool          MsgLength_Lt(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// func:atf_amc.MsgLength..Cmp
inline i32           MsgLength_Cmp(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgLength..Init
inline void          MsgLength_Init(atf_amc::MsgLength& parent);
// func:atf_amc.MsgLength..Eq
inline bool          MsgLength_Eq(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.MsgLength..Update
inline bool          MsgLength_Update(atf_amc::MsgLength &lhs, atf_amc::MsgLength rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLength.String  printfmt:Raw
// func:atf_amc.MsgLength..Print
void                 MsgLength_Print(atf_amc::MsgLength row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgHeader
// create: atf_amc.Msgbuf.in_buf (Fbuf)
// create: atf_amc.Seqmsg.payload (Opt)
// access: atf_amc.Seqmsg.msghdr (Base)
// access: atf_amc.Text.msghdr (Base)
// access: atf_amc.VarlenMsg.base (Base)
// access: atf_amc.MsgHeader_curs.msg (Ptr)
#pragma pack(push,1)
struct MsgHeader { // atf_amc.MsgHeader
    atf_amc::MsgType     type;     // Message type
    atf_amc::MsgLength   length;   // Total message length, including this header
    // func:atf_amc.MsgHeader..EqOp
    inline bool          operator ==(const atf_amc::MsgHeader &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgHeader..NeOp
    inline bool          operator !=(const atf_amc::MsgHeader &rhs) const __attribute__((nothrow));
    // func:atf_amc.MsgHeader..Ctor
    inline               MsgHeader() __attribute__((nothrow));
    // func:atf_amc.MsgHeader..FieldwiseCtor
    explicit inline               MsgHeader(atf_amc::MsgType in_type, atf_amc::MsgLength in_length) __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.MsgHeader..Hash
inline u32           MsgHeader_Hash(u32 prev, const atf_amc::MsgHeader& rhs) __attribute__((nothrow));
// func:atf_amc.MsgHeader..ReadFieldMaybe
bool                 MsgHeader_ReadFieldMaybe(atf_amc::MsgHeader& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.MsgHeader..ReadStrptrMaybe
bool                 MsgHeader_ReadStrptrMaybe(atf_amc::MsgHeader &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.MsgHeader..GetMsgLength
inline i32           GetMsgLength(const atf_amc::MsgHeader& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.MsgHeader..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::MsgHeader& row) __attribute__((nothrow));
// func:atf_amc.MsgHeader..Cmp
inline i32           MsgHeader_Cmp(atf_amc::MsgHeader& lhs, atf_amc::MsgHeader& rhs) __attribute__((nothrow));
// func:atf_amc.MsgHeader..Eq
inline bool          MsgHeader_Eq(atf_amc::MsgHeader& lhs, atf_amc::MsgHeader& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgHeader.String  printfmt:Tuple
// func:atf_amc.MsgHeader..Print
void                 MsgHeader_Print(atf_amc::MsgHeader& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgHeader_curs
#pragma pack(push,1)
struct MsgHeader_curs { // atf_amc.MsgHeader_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::MsgHeader *ChildType;
    atf_amc::MsgHeader*   msg;      // Pointer to current message. optional pointer
    u8*                   bytes;    // Beginning of region. optional pointer
    i32                   limit;    //   0  # Of bytes in the region
    i32                   msglen;   //   0  Length of current message (if any)
    // func:atf_amc.MsgHeader_curs..Ctor
    inline               MsgHeader_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.MsgHeader_curs..ValidQ
inline bool          MsgHeader_curs_ValidQ(atf_amc::MsgHeader_curs& curs) __attribute__((nothrow));
// func:atf_amc.MsgHeader_curs..Reset
inline void          MsgHeader_curs_Reset(atf_amc::MsgHeader_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.MsgHeader_curs..Access
inline atf_amc::MsgHeader*& MsgHeader_curs_Access(atf_amc::MsgHeader_curs& curs) __attribute__((nothrow));
// func:atf_amc.MsgHeader_curs..Next
inline void          MsgHeader_curs_Next(atf_amc::MsgHeader_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgHeader_curs..Init
inline void          MsgHeader_curs_Init(atf_amc::MsgHeader_curs& parent);

// --- atf_amc.MsgLTA
#pragma pack(push,1)
struct MsgLTA { // atf_amc.MsgLTA
    u8                 len;    //   ssizeof(parent) + (-2)
    char               type;   //   'A'
    algo::RspaceStr4   a;      //
    // func:atf_amc.MsgLTA..Ctor
    inline               MsgLTA() __attribute__((nothrow));
    // func:atf_amc.MsgLTA..FieldwiseCtor
    explicit inline               MsgLTA(const algo::strptr& in_a) __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.MsgLTA.base.CopyOut
void                 parent_CopyOut(atf_amc::MsgLTA &row, atf_amc::MsgHdrLT &out) __attribute__((nothrow));
// Check if atf_amc::MsgHdrLT is an instance of MsgLTA by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTA.
// If not successful, quietly return NULL.
// func:atf_amc.MsgLTA.base.Castdown
inline atf_amc::MsgLTA* MsgLTA_Castdown(atf_amc::MsgHdrLT &hdr);
// func:atf_amc.MsgLTA.base.Castbase
inline atf_amc::MsgHdrLT& Castbase(atf_amc::MsgLTA& parent);

// func:atf_amc.MsgLTA..ReadFieldMaybe
bool                 MsgLTA_ReadFieldMaybe(atf_amc::MsgLTA& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::MsgLTA from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.MsgLTA..ReadStrptrMaybe
bool                 MsgLTA_ReadStrptrMaybe(atf_amc::MsgLTA &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.MsgLTA..GetMsgLength
inline i32           GetMsgLength(const atf_amc::MsgLTA& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.MsgLTA..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::MsgLTA& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgLTA..Init
inline void          MsgLTA_Init(atf_amc::MsgLTA& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTA.String  printfmt:Tuple
// func:atf_amc.MsgLTA..Print
void                 MsgLTA_Print(atf_amc::MsgLTA& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgLTB
#pragma pack(push,1)
struct MsgLTB { // atf_amc.MsgLTB
    u8                 len;    //   ssizeof(parent) + (-2)
    char               type;   //   'B'
    algo::RspaceStr6   b;      //
    // func:atf_amc.MsgLTB..Ctor
    inline               MsgLTB() __attribute__((nothrow));
    // func:atf_amc.MsgLTB..FieldwiseCtor
    explicit inline               MsgLTB(const algo::strptr& in_b) __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.MsgLTB.base.CopyOut
void                 parent_CopyOut(atf_amc::MsgLTB &row, atf_amc::MsgHdrLT &out) __attribute__((nothrow));
// Check if atf_amc::MsgHdrLT is an instance of MsgLTB by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTB.
// If not successful, quietly return NULL.
// func:atf_amc.MsgLTB.base.Castdown
inline atf_amc::MsgLTB* MsgLTB_Castdown(atf_amc::MsgHdrLT &hdr);
// func:atf_amc.MsgLTB.base.Castbase
inline atf_amc::MsgHdrLT& Castbase(atf_amc::MsgLTB& parent);

// func:atf_amc.MsgLTB..ReadFieldMaybe
bool                 MsgLTB_ReadFieldMaybe(atf_amc::MsgLTB& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::MsgLTB from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.MsgLTB..ReadStrptrMaybe
bool                 MsgLTB_ReadStrptrMaybe(atf_amc::MsgLTB &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.MsgLTB..GetMsgLength
inline i32           GetMsgLength(const atf_amc::MsgLTB& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.MsgLTB..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::MsgLTB& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgLTB..Init
inline void          MsgLTB_Init(atf_amc::MsgLTB& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTB.String  printfmt:Tuple
// func:atf_amc.MsgLTB..Print
void                 MsgLTB_Print(atf_amc::MsgLTB& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgLTO
#pragma pack(push,1)
struct MsgLTO { // atf_amc.MsgLTO
    u8                        len;    //   ssizeof(parent) + (-2)
    char                      type;   //   'O'
    // atf_amc::MsgHdrLT      o[];                                      optional field
    // func:atf_amc.MsgLTO..Ctor
    inline               MsgLTO() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.MsgLTO.base.CopyOut
void                 parent_CopyOut(atf_amc::MsgLTO &row, atf_amc::MsgHdrLT &out) __attribute__((nothrow));
// Check if atf_amc::MsgHdrLT is an instance of MsgLTO by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTO.
// If not successful, quietly return NULL.
// func:atf_amc.MsgLTO.base.Castdown
inline atf_amc::MsgLTO* MsgLTO_Castdown(atf_amc::MsgHdrLT &hdr);
// func:atf_amc.MsgLTO.base.Castbase
inline atf_amc::MsgHdrLT& Castbase(atf_amc::MsgLTO& parent);

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized o, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If o's length field value is too short, return NULL.
// If o's length field value extends past parent's allowed length, return NULL.
// func:atf_amc.MsgLTO.o.Get
inline atf_amc::MsgHdrLT* o_Get(atf_amc::MsgLTO& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:atf_amc.MsgLTO.o.Getary
algo::aryptr<u8>     o_Getary(atf_amc::MsgLTO& parent) __attribute__((nothrow));
// func:atf_amc.MsgLTO.o.Print
void                 o_Print(atf_amc::MsgLTO& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.MsgLTO.o.ReadStrptrMaybe
bool                 o_ReadStrptrMaybe(atf_amc::MsgLTO &parent, algo::strptr in_str) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.MsgLTO.o.XrefMaybe
bool                 o_XrefMaybe(atf_amc::MsgHdrLT &row);

// func:atf_amc.MsgLTO..ReadFieldMaybe
bool                 MsgLTO_ReadFieldMaybe(atf_amc::MsgLTO& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::MsgLTO from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.MsgLTO..ReadStrptrMaybe
bool                 MsgLTO_ReadStrptrMaybe(atf_amc::MsgLTO &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.MsgLTO..GetMsgLength
inline i32           GetMsgLength(const atf_amc::MsgLTO& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.MsgLTO..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::MsgLTO& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgLTO..Init
inline void          MsgLTO_Init(atf_amc::MsgLTO& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTO.String  printfmt:Tuple
// func:atf_amc.MsgLTO..Print
void                 MsgLTO_Print(atf_amc::MsgLTO& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgLTV
#pragma pack(push,1)
struct MsgLTV { // atf_amc.MsgLTV
    u8     len;    //   ssizeof(parent) + (-2)
    char   type;   //   'V'
    // var-length field atf_amc.MsgLTV.v starts here. access it with v_Addr
    // func:atf_amc.MsgLTV..Ctor
    inline               MsgLTV() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.MsgLTV.base.CopyOut
void                 parent_CopyOut(atf_amc::MsgLTV &row, atf_amc::MsgHdrLT &out) __attribute__((nothrow));
// Check if atf_amc::MsgHdrLT is an instance of MsgLTV by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTV.
// If not successful, quietly return NULL.
// func:atf_amc.MsgLTV.base.Castdown
inline atf_amc::MsgLTV* MsgLTV_Castdown(atf_amc::MsgHdrLT &hdr);
// func:atf_amc.MsgLTV.base.Castbase
inline atf_amc::MsgHdrLT& Castbase(atf_amc::MsgLTV& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.MsgLTV.v.Getary
algo::aryptr<u8>     v_Getary(atf_amc::MsgLTV& parent) __attribute__((nothrow));
// func:atf_amc.MsgLTV.v.Addr
u8*                  v_Addr(atf_amc::MsgLTV& parent);
// Return number of elements in varlen field
// func:atf_amc.MsgLTV.v.N
inline u32           v_N(const atf_amc::MsgLTV& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:atf_amc.MsgLTV.v.ReadStrptrMaybe
bool                 v_ReadStrptrMaybe(atf_amc::MsgLTV& parent, algo::strptr in_str) __attribute__((nothrow));

// func:atf_amc.MsgLTV.v_curs.Reset
inline void          MsgLTV_v_curs_Reset(MsgLTV_v_curs &curs, atf_amc::MsgLTV &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.MsgLTV.v_curs.ValidQ
inline bool          MsgLTV_v_curs_ValidQ(MsgLTV_v_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.MsgLTV.v_curs.Next
inline void          MsgLTV_v_curs_Next(MsgLTV_v_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.MsgLTV.v_curs.Access
inline atf_amc::MsgHdrLT& MsgLTV_v_curs_Access(MsgLTV_v_curs &curs) __attribute__((nothrow));
// func:atf_amc.MsgLTV..ReadFieldMaybe
bool                 MsgLTV_ReadFieldMaybe(atf_amc::MsgLTV& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::MsgLTV from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.MsgLTV..ReadStrptrMaybe
bool                 MsgLTV_ReadStrptrMaybe(atf_amc::MsgLTV &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.MsgLTV..GetMsgLength
inline i32           GetMsgLength(const atf_amc::MsgLTV& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.MsgLTV..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::MsgLTV& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgLTV..Init
inline void          MsgLTV_Init(atf_amc::MsgLTV& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.MsgLTV.String  printfmt:Tuple
// func:atf_amc.MsgLTV..Print
void                 MsgLTV_Print(atf_amc::MsgLTV& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Msgbuf
// create: atf_amc.FDb.msgbuf (Cppstack)
// global access: cd_in_msg (Llist)
struct Msgbuf { // atf_amc.Msgbuf
    atf_amc::Msgbuf*    cd_in_msg_next;           // zslist link; -1 means not-in-list
    atf_amc::Msgbuf*    cd_in_msg_prev;           // previous element
    u8                  in_buf_elems[64];         // pointer to elements of inline array
    i32                 in_buf_start;             // beginning of valid bytes (in bytes)
    i32                 in_buf_end;               // end of valid bytes (in bytes)
    bool                in_buf_eof;               // no more data will be written to buffer
    algo::Errcode       in_buf_err;               // system error code
    bool                in_buf_msgvalid;          // current message is valid
    i32                 in_buf_msglen;            // current message length
    algo_lib::FIohook   in_buf_iohook;            // edge-triggered hook for refilling buffer
    bool                in_buf_epoll_enable;      // use epoll?
    enum { in_buf_max = 64 };
    u8                  in_custom_elems[64];      // pointer to elements of inline array
    i32                 in_custom_start;          // beginning of valid bytes (in bytes)
    i32                 in_custom_end;            // end of valid bytes (in bytes)
    bool                in_custom_eof;            // no more data will be written to buffer
    algo::Errcode       in_custom_err;            // system error code
    bool                in_custom_msgvalid;       // current message is valid
    i32                 in_custom_msglen;         // current message length
    algo_lib::FIohook   in_custom_iohook;         // edge-triggered hook for refilling buffer
    bool                in_custom_epoll_enable;   // use epoll?
    enum { in_custom_max = 64 };
    u8                  out_extra_elems[64];      // pointer to elements of inline array
    i32                 out_extra_start;          // beginning of valid bytes (in bytes)
    i32                 out_extra_end;            // end of valid bytes (in bytes)
    bool                out_extra_eof;            // no more data will be written to buffer
    algo::Errcode       out_extra_err;            // system error code
    bool                out_extra_msgvalid;       // current message is valid
    i32                 out_extra_msglen;         // current message length
    bool                out_extra_epoll_enable;   // use epoll?
    enum { out_extra_max = 64 };
    u8                  in_extra_elems[64];       // pointer to elements of inline array
    i32                 in_extra_start;           // beginning of valid bytes (in bytes)
    i32                 in_extra_end;             // end of valid bytes (in bytes)
    bool                in_extra_eof;             // no more data will be written to buffer
    algo::Errcode       in_extra_err;             // system error code
    bool                in_extra_msgvalid;        // current message is valid
    i32                 in_extra_msglen;          // current message length
    bool                in_extra_epoll_enable;    // use epoll?
    enum { in_extra_max = 64 };
    // field atf_amc.Msgbuf.in_buf prevents copy
    // field atf_amc.Msgbuf.in_custom prevents copy
    // field atf_amc.Msgbuf.out_extra prevents copy
    // field atf_amc.Msgbuf.in_extra prevents copy
    // func:atf_amc.Msgbuf..AssignOp
    inline atf_amc::Msgbuf& operator =(const atf_amc::Msgbuf &rhs) = delete;
    // func:atf_amc.Msgbuf..Ctor
    inline               Msgbuf() __attribute__((nothrow));
    // func:atf_amc.Msgbuf..Dtor
    inline               ~Msgbuf() __attribute__((nothrow));
    // field atf_amc.Msgbuf.in_buf prevents copy
    // field atf_amc.Msgbuf.in_custom prevents copy
    // field atf_amc.Msgbuf.out_extra prevents copy
    // field atf_amc.Msgbuf.in_extra prevents copy
    // func:atf_amc.Msgbuf..CopyCtor
    inline               Msgbuf(const atf_amc::Msgbuf &rhs) = delete;
};

// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by atf_amc::Msgbuf.in_buf via FIohook field.
// Whenever the file descriptor becomes readable, insert msgbuf into cd_in_msg.
// func:atf_amc.Msgbuf.in_buf.BeginRead
void                 in_buf_BeginRead(atf_amc::Msgbuf& msgbuf, algo::Fildes fd) __attribute__((nothrow));
// Set EOF flag
// func:atf_amc.Msgbuf.in_buf.EndRead
void                 in_buf_EndRead(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is length-delimited based on field length field
//
// func:atf_amc.Msgbuf.in_buf.GetMsg
atf_amc::MsgHeader*  in_buf_GetMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_amc.Msgbuf.in_buf.Max
inline i32           in_buf_Max(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.Msgbuf.in_buf.N
inline i32           in_buf_N(atf_amc::Msgbuf& msgbuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
// func:atf_amc.Msgbuf.in_buf.Refill
bool                 in_buf_Refill(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.Msgbuf.in_buf.RemoveAll
void                 in_buf_RemoveAll(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.Msgbuf.in_buf.SkipMsg
void                 in_buf_SkipMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.Msgbuf.in_buf.WriteAll
bool                 in_buf_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.Msgbuf.in_buf.XrefMaybe
bool                 in_buf_XrefMaybe(atf_amc::MsgHeader &row);

// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by atf_amc::Msgbuf.in_custom via FIohook field.
// Whenever the file descriptor becomes readable, insert msgbuf into cd_in_msg.
// func:atf_amc.Msgbuf.in_custom.BeginRead
void                 in_custom_BeginRead(atf_amc::Msgbuf& msgbuf, algo::Fildes fd) __attribute__((nothrow));
// Set EOF flag
// func:atf_amc.Msgbuf.in_custom.EndRead
void                 in_custom_EndRead(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message boundary is determined by a custom ScanMsg function implemented by user
//
// func:atf_amc.Msgbuf.in_custom.GetMsg
algo::aryptr<char>   in_custom_GetMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_amc.Msgbuf.in_custom.Max
inline i32           in_custom_Max(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.Msgbuf.in_custom.N
inline i32           in_custom_N(atf_amc::Msgbuf& msgbuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
// func:atf_amc.Msgbuf.in_custom.Refill
bool                 in_custom_Refill(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.Msgbuf.in_custom.RemoveAll
void                 in_custom_RemoveAll(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Internal function to scan for a message
//
// func:atf_amc.Msgbuf.in_custom.ScanMsg
// this function is 'extrn' and implemented by user
void                 in_custom_ScanMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_amc.Msgbuf.in_custom.SkipBytes
void                 in_custom_SkipBytes(atf_amc::Msgbuf& msgbuf, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.Msgbuf.in_custom.SkipMsg
void                 in_custom_SkipMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.Msgbuf.in_custom.WriteAll
bool                 in_custom_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) __attribute__((nothrow));

// Return max. number of bytes in the buffer.
// func:atf_amc.Msgbuf.out_extra.Max
inline i32           out_extra_Max(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.Msgbuf.out_extra.N
inline i32           out_extra_N(atf_amc::Msgbuf& msgbuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.Msgbuf.out_extra.RemoveAll
void                 out_extra_RemoveAll(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_amc.Msgbuf.out_extra.SkipBytes
void                 out_extra_SkipBytes(atf_amc::Msgbuf& msgbuf, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.Msgbuf.out_extra.SkipMsg
void                 out_extra_SkipMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.Msgbuf.out_extra.WriteAll
bool                 out_extra_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) __attribute__((nothrow));
// Write message to buffer. If the entire message is written, return true, otherwise false.
// func:atf_amc.Msgbuf.out_extra.WriteMsg
bool                 out_extra_WriteMsg(atf_amc::Msgbuf& msgbuf, atf_amc::MsgHdrLT &msg) __attribute__((nothrow));

// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is length-delimited based on field len field
//
// func:atf_amc.Msgbuf.in_extra.GetMsg
atf_amc::MsgHdrLT*   in_extra_GetMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_amc.Msgbuf.in_extra.Max
inline i32           in_extra_Max(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_amc.Msgbuf.in_extra.N
inline i32           in_extra_N(atf_amc::Msgbuf& msgbuf) __attribute__((__warn_unused_result__, nothrow, pure));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_amc.Msgbuf.in_extra.RemoveAll
void                 in_extra_RemoveAll(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_amc.Msgbuf.in_extra.SkipMsg
void                 in_extra_SkipMsg(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// Attempt to write buffer contents to fd
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_amc.Msgbuf.in_extra.WriteAll
bool                 in_extra_WriteAll(atf_amc::Msgbuf& msgbuf, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.Msgbuf..Init
void                 Msgbuf_Init(atf_amc::Msgbuf& msgbuf);
// func:atf_amc.Msgbuf..Uninit
void                 Msgbuf_Uninit(atf_amc::Msgbuf& msgbuf) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.Msgbuf.String  printfmt:Raw
// func:atf_amc.Msgbuf..Print
void                 Msgbuf_Print(atf_amc::Msgbuf& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.MsgsCase
#pragma pack(push,1)
struct MsgsCase { // atf_amc.MsgsCase: Enum for dispatch atf_amc.Msgs
    u32   value;   //   0
    // func:atf_amc.MsgsCase.value.Cast
    inline               operator atf_amc_MsgsCaseEnum() const __attribute__((nothrow));
    // func:atf_amc.MsgsCase..Ctor
    inline               MsgsCase() __attribute__((nothrow));
    // func:atf_amc.MsgsCase..FieldwiseCtor
    explicit inline               MsgsCase(u32 in_value) __attribute__((nothrow));
    // func:atf_amc.MsgsCase..EnumCtor
    inline               MsgsCase(atf_amc_MsgsCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.MsgsCase.value.GetEnum
inline atf_amc_MsgsCaseEnum value_GetEnum(const atf_amc::MsgsCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.MsgsCase.value.SetEnum
inline void          value_SetEnum(atf_amc::MsgsCase& parent, atf_amc_MsgsCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.MsgsCase.value.ToCstr
const char*          value_ToCstr(const atf_amc::MsgsCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.MsgsCase.value.Print
void                 value_Print(const atf_amc::MsgsCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.MsgsCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::MsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.MsgsCase.value.SetStrptr
void                 value_SetStrptr(atf_amc::MsgsCase& parent, algo::strptr rhs, atf_amc_MsgsCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.MsgsCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::MsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::MsgsCase from an ascii string.
// The format of the string is the format of the atf_amc::MsgsCase's only field
// func:atf_amc.MsgsCase..ReadStrptrMaybe
bool                 MsgsCase_ReadStrptrMaybe(atf_amc::MsgsCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.MsgsCase..Init
inline void          MsgsCase_Init(atf_amc::MsgsCase& parent);

// --- atf_amc.NetBitfld1
struct NetBitfld1 { // atf_amc.NetBitfld1
    u16   value_be;   //   0
    // func:atf_amc.NetBitfld1..Ctor
    inline               NetBitfld1() __attribute__((nothrow));
};

// func:atf_amc.NetBitfld1.value.Get
inline u16           value_Get(const atf_amc::NetBitfld1& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.NetBitfld1.value.Set
inline void          value_Set(atf_amc::NetBitfld1& parent, u16 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.NetBitfld1.bits0_4.Get
inline u8            bits0_4_Get(const atf_amc::NetBitfld1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.NetBitfld1.bits0_4.Set
inline void          bits0_4_Set(atf_amc::NetBitfld1& parent, u8 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 8.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.NetBitfld1.bits8_12.Get
inline u8            bits8_12_Get(const atf_amc::NetBitfld1& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 8.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.NetBitfld1.bits8_12.Set
inline void          bits8_12_Set(atf_amc::NetBitfld1& parent, u8 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.NetBitfld1..Init
inline void          NetBitfld1_Init(atf_amc::NetBitfld1& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.NetBitfld1.String  printfmt:Raw
// func:atf_amc.NetBitfld1..Print
void                 NetBitfld1_Print(atf_amc::NetBitfld1& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.OptAlloc
// create: atf_amc.FDb.optalloc (Lpool)
// access: atf_amc.OptAlloc_curs.msg (Ptr)
#pragma pack(push,1)
struct OptAlloc { // atf_amc.OptAlloc: An optional instance of atf_unit.A
    u32                    length;    //   0
    // atf_amc::TypeG      typeg[];                optional field
private:
    // func:atf_amc.OptAlloc..Ctor
    inline               OptAlloc() __attribute__((nothrow));
    friend atf_amc::OptAlloc&   optalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::OptAlloc*   optalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend void                 optalloc_Delete(atf_amc::OptAlloc &row) __attribute__((nothrow));
};
#pragma pack(pop)

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
// func:atf_amc.OptAlloc.typeg.Get
inline atf_amc::TypeG* typeg_Get(atf_amc::OptAlloc& optalloc) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:atf_amc.OptAlloc.typeg.Getary
algo::aryptr<u8>     typeg_Getary(atf_amc::OptAlloc& optalloc) __attribute__((nothrow));
// func:atf_amc.OptAlloc.typeg.Print
void                 typeg_Print(atf_amc::OptAlloc& optalloc, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.OptAlloc.typeg.ReadStrptrMaybe
bool                 typeg_ReadStrptrMaybe(atf_amc::OptAlloc &parent, algo::strptr in_str) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.OptAlloc.typeg.XrefMaybe
bool                 typeg_XrefMaybe(atf_amc::TypeG &row);

// func:atf_amc.OptAlloc..ReadFieldMaybe
bool                 OptAlloc_ReadFieldMaybe(atf_amc::OptAlloc& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::OptAlloc from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.OptAlloc..ReadStrptrMaybe
bool                 OptAlloc_ReadStrptrMaybe(atf_amc::OptAlloc &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.OptAlloc..GetMsgLength
inline i32           GetMsgLength(const atf_amc::OptAlloc& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.OptAlloc..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::OptAlloc& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.OptAlloc..Init
inline void          OptAlloc_Init(atf_amc::OptAlloc& optalloc);
// print string representation of ROW to string STR
// cfmt:atf_amc.OptAlloc.String  printfmt:Tuple
// func:atf_amc.OptAlloc..Print
void                 OptAlloc_Print(atf_amc::OptAlloc& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.OptAlloc_curs
#pragma pack(push,1)
struct OptAlloc_curs { // atf_amc.OptAlloc_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::OptAlloc *ChildType;
    atf_amc::OptAlloc*   msg;      // Pointer to current message. optional pointer
    u8*                  bytes;    // Beginning of region. optional pointer
    i32                  limit;    //   0  # Of bytes in the region
    i32                  msglen;   //   0  Length of current message (if any)
    // func:atf_amc.OptAlloc_curs..Ctor
    inline               OptAlloc_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.OptAlloc_curs..ValidQ
inline bool          OptAlloc_curs_ValidQ(atf_amc::OptAlloc_curs& curs) __attribute__((nothrow));
// func:atf_amc.OptAlloc_curs..Reset
inline void          OptAlloc_curs_Reset(atf_amc::OptAlloc_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.OptAlloc_curs..Access
inline atf_amc::OptAlloc*& OptAlloc_curs_Access(atf_amc::OptAlloc_curs& curs) __attribute__((nothrow));
// func:atf_amc.OptAlloc_curs..Next
inline void          OptAlloc_curs_Next(atf_amc::OptAlloc_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.OptAlloc_curs..Init
inline void          OptAlloc_curs_Init(atf_amc::OptAlloc_curs& parent);

// --- atf_amc.OptG
// create: atf_amc.OptOptG.optg (Opt)
// access: atf_amc.FOptG.optg (Base)
// access: atf_amc.OptG_curs.msg (Ptr)
#pragma pack(push,1)
struct OptG { // atf_amc.OptG: An optional instance of atf_unit.A
    u32                    length;    //   0
    // atf_amc::TypeG      typeg[];                optional field
    // func:atf_amc.OptG..Ctor
    inline               OptG() __attribute__((nothrow));
};
#pragma pack(pop)

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
// func:atf_amc.OptG.typeg.Get
inline atf_amc::TypeG* typeg_Get(atf_amc::OptG& optg) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:atf_amc.OptG.typeg.Getary
algo::aryptr<u8>     typeg_Getary(atf_amc::OptG& optg) __attribute__((nothrow));
// func:atf_amc.OptG.typeg.Print
void                 typeg_Print(atf_amc::OptG& optg, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.OptG.typeg.ReadStrptrMaybe
bool                 typeg_ReadStrptrMaybe(atf_amc::OptG &parent, algo::strptr in_str) __attribute__((nothrow));

// func:atf_amc.OptG..ReadFieldMaybe
bool                 OptG_ReadFieldMaybe(atf_amc::OptG& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::OptG from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.OptG..ReadStrptrMaybe
bool                 OptG_ReadStrptrMaybe(atf_amc::OptG &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.OptG..GetMsgLength
inline i32           GetMsgLength(const atf_amc::OptG& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.OptG..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::OptG& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.OptG..Init
inline void          OptG_Init(atf_amc::OptG& optg);
// print string representation of ROW to string STR
// cfmt:atf_amc.OptG.String  printfmt:Tuple
// func:atf_amc.OptG..Print
void                 OptG_Print(atf_amc::OptG& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.OptG_curs
#pragma pack(push,1)
struct OptG_curs { // atf_amc.OptG_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::OptG *ChildType;
    atf_amc::OptG*   msg;      // Pointer to current message. optional pointer
    u8*              bytes;    // Beginning of region. optional pointer
    i32              limit;    //   0  # Of bytes in the region
    i32              msglen;   //   0  Length of current message (if any)
    // func:atf_amc.OptG_curs..Ctor
    inline               OptG_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.OptG_curs..ValidQ
inline bool          OptG_curs_ValidQ(atf_amc::OptG_curs& curs) __attribute__((nothrow));
// func:atf_amc.OptG_curs..Reset
inline void          OptG_curs_Reset(atf_amc::OptG_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.OptG_curs..Access
inline atf_amc::OptG*& OptG_curs_Access(atf_amc::OptG_curs& curs) __attribute__((nothrow));
// func:atf_amc.OptG_curs..Next
inline void          OptG_curs_Next(atf_amc::OptG_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.OptG_curs..Init
inline void          OptG_curs_Init(atf_amc::OptG_curs& parent);

// --- atf_amc.OptOptG
// access: atf_amc.OptOptG_curs.msg (Ptr)
#pragma pack(push,1)
struct OptOptG { // atf_amc.OptOptG: An optional instance of atf_unit.Optg (recursive)
    u32                   length;   //   0
    // atf_amc::OptG      optg[];                optional field
    // func:atf_amc.OptOptG..Ctor
    inline               OptOptG() __attribute__((nothrow));
};
#pragma pack(pop)

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized optg, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If optg's length field value is too short, return NULL.
// If optg's length field value extends past parent's allowed length, return NULL.
// func:atf_amc.OptOptG.optg.Get
inline atf_amc::OptG* optg_Get(atf_amc::OptOptG& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:atf_amc.OptOptG.optg.Getary
algo::aryptr<u8>     optg_Getary(atf_amc::OptOptG& parent) __attribute__((nothrow));
// func:atf_amc.OptOptG.optg.Print
void                 optg_Print(atf_amc::OptOptG& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.OptOptG.optg.ReadStrptrMaybe
bool                 optg_ReadStrptrMaybe(atf_amc::OptOptG &parent, algo::strptr in_str) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.OptOptG.optg.XrefMaybe
bool                 optg_XrefMaybe(atf_amc::OptG &row);

// func:atf_amc.OptOptG..ReadFieldMaybe
bool                 OptOptG_ReadFieldMaybe(atf_amc::OptOptG& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::OptOptG from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.OptOptG..ReadStrptrMaybe
bool                 OptOptG_ReadStrptrMaybe(atf_amc::OptOptG &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.OptOptG..GetMsgLength
inline i32           GetMsgLength(const atf_amc::OptOptG& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.OptOptG..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::OptOptG& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.OptOptG..Init
inline void          OptOptG_Init(atf_amc::OptOptG& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.OptOptG.String  printfmt:Tuple
// func:atf_amc.OptOptG..Print
void                 OptOptG_Print(atf_amc::OptOptG& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.OptOptG_curs
#pragma pack(push,1)
struct OptOptG_curs { // atf_amc.OptOptG_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::OptOptG *ChildType;
    atf_amc::OptOptG*   msg;      // Pointer to current message. optional pointer
    u8*                 bytes;    // Beginning of region. optional pointer
    i32                 limit;    //   0  # Of bytes in the region
    i32                 msglen;   //   0  Length of current message (if any)
    // func:atf_amc.OptOptG_curs..Ctor
    inline               OptOptG_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.OptOptG_curs..ValidQ
inline bool          OptOptG_curs_ValidQ(atf_amc::OptOptG_curs& curs) __attribute__((nothrow));
// func:atf_amc.OptOptG_curs..Reset
inline void          OptOptG_curs_Reset(atf_amc::OptOptG_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.OptOptG_curs..Access
inline atf_amc::OptOptG*& OptOptG_curs_Access(atf_amc::OptOptG_curs& curs) __attribute__((nothrow));
// func:atf_amc.OptOptG_curs..Next
inline void          OptOptG_curs_Next(atf_amc::OptOptG_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.OptOptG_curs..Init
inline void          OptOptG_curs_Init(atf_amc::OptOptG_curs& parent);

// --- atf_amc.PmaskMultiple
#pragma pack(push,1)
struct PmaskMultiple { // atf_amc.PmaskMultiple: Ctype with 3 pmasks. One has an explicit set of fields
    u32   present;    //   0
    u32   assigned;   //   0
    u32   nullable;   //   0
    u32   value1;     //   0
    u32   value2;     //   0
    u32   value3;     //   0
    u32   value4;     //   0
    u32   value5;     //   0
    u32   value6;     //   0
    u32   value7;     //   0
    // func:atf_amc.PmaskMultiple..Ctor
    inline               PmaskMultiple() __attribute__((nothrow));
};
#pragma pack(pop)

// Return constant 1
// func:atf_amc.PmaskMultiple.present.N
inline int           present_N(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.PmaskMultiple.present.qFind
inline u32&          present_qFind(atf_amc::PmaskMultiple& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.PmaskMultiple.present.NBits
inline int           present_Nbits(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.present.qGetBit
inline bool          present_qGetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.PmaskMultiple.present.GetBit
inline bool          present_GetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.PmaskMultiple.present.BitsEmptyQ
inline bool          present_BitsEmptyQ(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PmaskMultiple.present.Sum1s
inline u64           present_Sum1s(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.present.qClearBit
inline void          present_qClearBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.PmaskMultiple.present.ClearBit
inline void          present_ClearBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.present.qSetBit
inline void          present_qSetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.PmaskMultiple.present.SetBit
inline void          present_SetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.present.qSetBitVal
inline void          present_qSetBitVal(atf_amc::PmaskMultiple& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.present.qOrBitVal
inline void          present_qOrBitVal(atf_amc::PmaskMultiple& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.PmaskMultiple.present.ClearBitsAll
inline void          present_ClearBitsAll(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.PmaskMultiple.present.ClearBits
inline void          present_ClearBits(atf_amc::PmaskMultiple& parent, atf_amc::PmaskMultiple &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.PmaskMultiple.present.OrBits
inline void          present_OrBits(atf_amc::PmaskMultiple& parent, atf_amc::PmaskMultiple &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.PmaskMultiple.present.Sup
inline i32           present_Sup(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));

// Return constant 1
// func:atf_amc.PmaskMultiple.assigned.N
inline int           assigned_N(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.PmaskMultiple.assigned.qFind
inline u32&          assigned_qFind(atf_amc::PmaskMultiple& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.PmaskMultiple.assigned.NBits
inline int           assigned_Nbits(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.assigned.qGetBit
inline bool          assigned_qGetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.PmaskMultiple.assigned.GetBit
inline bool          assigned_GetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.PmaskMultiple.assigned.BitsEmptyQ
inline bool          assigned_BitsEmptyQ(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PmaskMultiple.assigned.Sum1s
inline u64           assigned_Sum1s(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.assigned.qClearBit
inline void          assigned_qClearBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.PmaskMultiple.assigned.ClearBit
inline void          assigned_ClearBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.assigned.qSetBit
inline void          assigned_qSetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.PmaskMultiple.assigned.SetBit
inline void          assigned_SetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.assigned.qSetBitVal
inline void          assigned_qSetBitVal(atf_amc::PmaskMultiple& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.assigned.qOrBitVal
inline void          assigned_qOrBitVal(atf_amc::PmaskMultiple& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.PmaskMultiple.assigned.ClearBitsAll
inline void          assigned_ClearBitsAll(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.PmaskMultiple.assigned.ClearBits
inline void          assigned_ClearBits(atf_amc::PmaskMultiple& parent, atf_amc::PmaskMultiple &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.PmaskMultiple.assigned.OrBits
inline void          assigned_OrBits(atf_amc::PmaskMultiple& parent, atf_amc::PmaskMultiple &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.PmaskMultiple.assigned.Sup
inline i32           assigned_Sup(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));

// Return constant 1
// func:atf_amc.PmaskMultiple.nullable.N
inline int           nullable_N(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.PmaskMultiple.nullable.qFind
inline u32&          nullable_qFind(atf_amc::PmaskMultiple& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.PmaskMultiple.nullable.NBits
inline int           nullable_Nbits(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.nullable.qGetBit
inline bool          nullable_qGetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.PmaskMultiple.nullable.GetBit
inline bool          nullable_GetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.PmaskMultiple.nullable.BitsEmptyQ
inline bool          nullable_BitsEmptyQ(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PmaskMultiple.nullable.Sum1s
inline u64           nullable_Sum1s(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.nullable.qClearBit
inline void          nullable_qClearBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.PmaskMultiple.nullable.ClearBit
inline void          nullable_ClearBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.nullable.qSetBit
inline void          nullable_qSetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.PmaskMultiple.nullable.SetBit
inline void          nullable_SetBit(atf_amc::PmaskMultiple& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.nullable.qSetBitVal
inline void          nullable_qSetBitVal(atf_amc::PmaskMultiple& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskMultiple.nullable.qOrBitVal
inline void          nullable_qOrBitVal(atf_amc::PmaskMultiple& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.PmaskMultiple.nullable.ClearBitsAll
inline void          nullable_ClearBitsAll(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.PmaskMultiple.nullable.ClearBits
inline void          nullable_ClearBits(atf_amc::PmaskMultiple& parent, atf_amc::PmaskMultiple &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.PmaskMultiple.nullable.OrBits
inline void          nullable_OrBits(atf_amc::PmaskMultiple& parent, atf_amc::PmaskMultiple &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.PmaskMultiple.nullable.Sup
inline i32           nullable_Sup(atf_amc::PmaskMultiple& parent) __attribute__((__warn_unused_result__, nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value1.NullableQ
inline bool          value1_NullableQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value1.AssignedQ
inline bool          value1_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value1.PresentQ
inline bool          value1_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value1.SetNullable
inline void          value1_SetNullable(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value1.SetAssigned
inline void          value1_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value1.SetPresent
inline void          value1_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value1.Nullable_GetBit
inline int           value1_Nullable_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value1.Assigned_GetBit
inline int           value1_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value1.Present_GetBit
inline int           value1_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value1.Set
inline void          value1_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value2.AssignedQ
inline bool          value2_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value2.PresentQ
inline bool          value2_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value2.SetAssigned
inline void          value2_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value2.SetPresent
inline void          value2_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value2.Assigned_GetBit
inline int           value2_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value2.Present_GetBit
inline int           value2_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value2.Set
inline void          value2_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value3.NullableQ
inline bool          value3_NullableQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value3.AssignedQ
inline bool          value3_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value3.PresentQ
inline bool          value3_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value3.SetNullable
inline void          value3_SetNullable(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value3.SetAssigned
inline void          value3_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value3.SetPresent
inline void          value3_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value3.Nullable_GetBit
inline int           value3_Nullable_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value3.Assigned_GetBit
inline int           value3_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value3.Present_GetBit
inline int           value3_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value3.Set
inline void          value3_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value4.AssignedQ
inline bool          value4_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value4.PresentQ
inline bool          value4_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value4.SetAssigned
inline void          value4_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value4.SetPresent
inline void          value4_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value4.Assigned_GetBit
inline int           value4_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value4.Present_GetBit
inline int           value4_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value4.Set
inline void          value4_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value5.NullableQ
inline bool          value5_NullableQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value5.AssignedQ
inline bool          value5_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value5.PresentQ
inline bool          value5_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value5.SetNullable
inline void          value5_SetNullable(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value5.SetAssigned
inline void          value5_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value5.SetPresent
inline void          value5_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value5.Nullable_GetBit
inline int           value5_Nullable_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value5.Assigned_GetBit
inline int           value5_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value5.Present_GetBit
inline int           value5_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value5.Set
inline void          value5_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value6.AssignedQ
inline bool          value6_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value6.PresentQ
inline bool          value6_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value6.SetAssigned
inline void          value6_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value6.SetPresent
inline void          value6_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value6.Assigned_GetBit
inline int           value6_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value6.Present_GetBit
inline int           value6_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value6.Set
inline void          value6_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value7.AssignedQ
inline bool          value7_AssignedQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskMultiple.value7.PresentQ
inline bool          value7_PresentQ(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value7.SetAssigned
inline void          value7_SetAssigned(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskMultiple.value7.SetPresent
inline void          value7_SetPresent(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value7.Assigned_GetBit
inline int           value7_Assigned_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskMultiple.value7.Present_GetBit
inline int           value7_Present_GetBit(atf_amc::PmaskMultiple& parent) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple.value7.Set
inline void          value7_Set(atf_amc::PmaskMultiple& parent, u32 rhs) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.PmaskMultiple.present_bitcurs.Next
void                 PmaskMultiple_present_bitcurs_Next(PmaskMultiple_present_bitcurs &curs);
// func:atf_amc.PmaskMultiple.present_bitcurs.Reset
inline void          PmaskMultiple_present_bitcurs_Reset(PmaskMultiple_present_bitcurs &curs, atf_amc::PmaskMultiple &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskMultiple.present_bitcurs.ValidQ
inline bool          PmaskMultiple_present_bitcurs_ValidQ(PmaskMultiple_present_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.PmaskMultiple.present_bitcurs.Access
inline int&          PmaskMultiple_present_bitcurs_Access(PmaskMultiple_present_bitcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.PmaskMultiple.assigned_bitcurs.Next
void                 PmaskMultiple_assigned_bitcurs_Next(PmaskMultiple_assigned_bitcurs &curs);
// func:atf_amc.PmaskMultiple.assigned_bitcurs.Reset
inline void          PmaskMultiple_assigned_bitcurs_Reset(PmaskMultiple_assigned_bitcurs &curs, atf_amc::PmaskMultiple &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskMultiple.assigned_bitcurs.ValidQ
inline bool          PmaskMultiple_assigned_bitcurs_ValidQ(PmaskMultiple_assigned_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.PmaskMultiple.assigned_bitcurs.Access
inline int&          PmaskMultiple_assigned_bitcurs_Access(PmaskMultiple_assigned_bitcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.PmaskMultiple.nullable_bitcurs.Next
void                 PmaskMultiple_nullable_bitcurs_Next(PmaskMultiple_nullable_bitcurs &curs);
// func:atf_amc.PmaskMultiple.nullable_bitcurs.Reset
inline void          PmaskMultiple_nullable_bitcurs_Reset(PmaskMultiple_nullable_bitcurs &curs, atf_amc::PmaskMultiple &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskMultiple.nullable_bitcurs.ValidQ
inline bool          PmaskMultiple_nullable_bitcurs_ValidQ(PmaskMultiple_nullable_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.PmaskMultiple.nullable_bitcurs.Access
inline int&          PmaskMultiple_nullable_bitcurs_Access(PmaskMultiple_nullable_bitcurs &curs) __attribute__((nothrow));
// func:atf_amc.PmaskMultiple..ReadFieldMaybe
bool                 PmaskMultiple_ReadFieldMaybe(atf_amc::PmaskMultiple& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PmaskMultiple from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.PmaskMultiple..ReadStrptrMaybe
bool                 PmaskMultiple_ReadStrptrMaybe(atf_amc::PmaskMultiple &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.PmaskMultiple..Init
void                 PmaskMultiple_Init(atf_amc::PmaskMultiple& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.PmaskMultiple.String  printfmt:Tuple
// func:atf_amc.PmaskMultiple..Print
void                 PmaskMultiple_Print(atf_amc::PmaskMultiple& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.PmaskU128
#pragma pack(push,1)
struct PmaskU128 { // atf_amc.PmaskU128: A field controlled by a bitmask.
    u128   pmask;     //   0
    u32    value;     //   0
    u32    value2;    //   0
    u32    value3;    //   0
    u32    value21;   //   0
    u32    value22;   //   0
    u32    value23;   //   0
    u32    value24;   //   0
    u32    value25;   //   0
    u32    value26;   //   0
    u32    value20;   //   0
    u32    value28;   //   0
    u32    value29;   //   0
    u32    value30;   //   0
    u32    value31;   //   0
    u32    value32;   //   0
    u32    value27;   //   0
    u32    value19;   //   0
    u32    value18;   //   0
    u32    value4;    //   0
    u32    value5;    //   0
    u32    value6;    //   0
    u32    value7;    //   0
    u32    value8;    //   0
    u32    value9;    //   0
    u32    value69;   //   0
    u32    value11;   //   0
    u32    value12;   //   0
    u32    value13;   //   0
    u32    value14;   //   0
    u32    value15;   //   0
    u32    value16;   //   0
    u32    value33;   //   0
    u32    value10;   //   0
    u32    value17;   //   0
    u32    value35;   //   0
    u32    value55;   //   0
    u32    value56;   //   0
    u32    value57;   //   0
    u32    value58;   //   0
    u32    value59;   //   0
    u32    value60;   //   0
    u32    value54;   //   0
    u32    value62;   //   0
    u32    value63;   //   0
    u32    value64;   //   0
    u32    value65;   //   0
    u32    value66;   //   0
    u32    value67;   //   0
    u32    value68;   //   0
    u32    value61;   //   0
    u32    value34;   //   0
    u32    value52;   //   0
    u32    value36;   //   0
    u32    value37;   //   0
    u32    value38;   //   0
    u32    value39;   //   0
    u32    value40;   //   0
    u32    value41;   //   0
    u32    value42;   //   0
    u32    value53;   //   0
    u32    value44;   //   0
    u32    value45;   //   0
    u32    value46;   //   0
    u32    value47;   //   0
    u32    value48;   //   0
    u32    value49;   //   0
    u32    value50;   //   0
    u32    value51;   //   0
    u32    value43;   //   0
    u32    value70;   //   0
    u32    value71;   //   0
    // func:atf_amc.PmaskU128..Ctor
    inline               PmaskU128() __attribute__((nothrow));
};
#pragma pack(pop)

// Return constant 1
// func:atf_amc.PmaskU128.pmask.N
inline int           pmask_N(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.PmaskU128.pmask.qFind
inline u128&         pmask_qFind(atf_amc::PmaskU128& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.PmaskU128.pmask.NBits
inline int           pmask_Nbits(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU128.pmask.qGetBit
inline bool          pmask_qGetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.PmaskU128.pmask.GetBit
inline bool          pmask_GetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.PmaskU128.pmask.BitsEmptyQ
inline bool          pmask_BitsEmptyQ(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PmaskU128.pmask.Sum1s
inline u64           pmask_Sum1s(atf_amc::PmaskU128& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU128.pmask.qClearBit
inline void          pmask_qClearBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.PmaskU128.pmask.ClearBit
inline void          pmask_ClearBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU128.pmask.qSetBit
inline void          pmask_qSetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.PmaskU128.pmask.SetBit
inline void          pmask_SetBit(atf_amc::PmaskU128& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU128.pmask.qSetBitVal
inline void          pmask_qSetBitVal(atf_amc::PmaskU128& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU128.pmask.qOrBitVal
inline void          pmask_qOrBitVal(atf_amc::PmaskU128& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.PmaskU128.pmask.ClearBitsAll
inline void          pmask_ClearBitsAll(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.PmaskU128.pmask.ClearBits
inline void          pmask_ClearBits(atf_amc::PmaskU128& parent, atf_amc::PmaskU128 &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.PmaskU128.pmask.OrBits
inline void          pmask_OrBits(atf_amc::PmaskU128& parent, atf_amc::PmaskU128 &rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value.PresentQ
inline bool          value_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value.SetPresent
inline void          value_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value.Present_GetBit
inline int           value_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value.Set
inline void          value_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value2.PresentQ
inline bool          value2_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value2.SetPresent
inline void          value2_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value2.Present_GetBit
inline int           value2_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value2.Set
inline void          value2_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value3.PresentQ
inline bool          value3_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value3.SetPresent
inline void          value3_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value3.Present_GetBit
inline int           value3_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value3.Set
inline void          value3_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value21.PresentQ
inline bool          value21_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value21.SetPresent
inline void          value21_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value21.Present_GetBit
inline int           value21_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value21.Set
inline void          value21_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value22.PresentQ
inline bool          value22_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value22.SetPresent
inline void          value22_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value22.Present_GetBit
inline int           value22_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value22.Set
inline void          value22_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value23.PresentQ
inline bool          value23_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value23.SetPresent
inline void          value23_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value23.Present_GetBit
inline int           value23_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value23.Set
inline void          value23_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value24.PresentQ
inline bool          value24_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value24.SetPresent
inline void          value24_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value24.Present_GetBit
inline int           value24_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value24.Set
inline void          value24_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value25.PresentQ
inline bool          value25_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value25.SetPresent
inline void          value25_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value25.Present_GetBit
inline int           value25_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value25.Set
inline void          value25_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value26.PresentQ
inline bool          value26_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value26.SetPresent
inline void          value26_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value26.Present_GetBit
inline int           value26_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value26.Set
inline void          value26_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value20.PresentQ
inline bool          value20_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value20.SetPresent
inline void          value20_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value20.Present_GetBit
inline int           value20_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value20.Set
inline void          value20_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value28.PresentQ
inline bool          value28_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value28.SetPresent
inline void          value28_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value28.Present_GetBit
inline int           value28_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value28.Set
inline void          value28_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value29.PresentQ
inline bool          value29_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value29.SetPresent
inline void          value29_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value29.Present_GetBit
inline int           value29_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value29.Set
inline void          value29_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value30.PresentQ
inline bool          value30_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value30.SetPresent
inline void          value30_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value30.Present_GetBit
inline int           value30_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value30.Set
inline void          value30_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value31.PresentQ
inline bool          value31_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value31.SetPresent
inline void          value31_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value31.Present_GetBit
inline int           value31_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value31.Set
inline void          value31_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value32.PresentQ
inline bool          value32_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value32.SetPresent
inline void          value32_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value32.Present_GetBit
inline int           value32_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value32.Set
inline void          value32_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value27.PresentQ
inline bool          value27_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value27.SetPresent
inline void          value27_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value27.Present_GetBit
inline int           value27_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value27.Set
inline void          value27_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value19.PresentQ
inline bool          value19_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value19.SetPresent
inline void          value19_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value19.Present_GetBit
inline int           value19_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value19.Set
inline void          value19_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value18.PresentQ
inline bool          value18_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value18.SetPresent
inline void          value18_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value18.Present_GetBit
inline int           value18_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value18.Set
inline void          value18_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value4.PresentQ
inline bool          value4_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value4.SetPresent
inline void          value4_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value4.Present_GetBit
inline int           value4_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value4.Set
inline void          value4_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value5.PresentQ
inline bool          value5_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value5.SetPresent
inline void          value5_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value5.Present_GetBit
inline int           value5_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value5.Set
inline void          value5_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value6.PresentQ
inline bool          value6_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value6.SetPresent
inline void          value6_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value6.Present_GetBit
inline int           value6_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value6.Set
inline void          value6_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value7.PresentQ
inline bool          value7_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value7.SetPresent
inline void          value7_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value7.Present_GetBit
inline int           value7_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value7.Set
inline void          value7_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value8.PresentQ
inline bool          value8_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value8.SetPresent
inline void          value8_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value8.Present_GetBit
inline int           value8_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value8.Set
inline void          value8_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value9.PresentQ
inline bool          value9_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value9.SetPresent
inline void          value9_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value9.Present_GetBit
inline int           value9_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value9.Set
inline void          value9_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value69.PresentQ
inline bool          value69_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value69.SetPresent
inline void          value69_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value69.Present_GetBit
inline int           value69_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value69.Set
inline void          value69_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value11.PresentQ
inline bool          value11_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value11.SetPresent
inline void          value11_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value11.Present_GetBit
inline int           value11_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value11.Set
inline void          value11_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value12.PresentQ
inline bool          value12_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value12.SetPresent
inline void          value12_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value12.Present_GetBit
inline int           value12_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value12.Set
inline void          value12_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value13.PresentQ
inline bool          value13_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value13.SetPresent
inline void          value13_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value13.Present_GetBit
inline int           value13_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value13.Set
inline void          value13_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value14.PresentQ
inline bool          value14_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value14.SetPresent
inline void          value14_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value14.Present_GetBit
inline int           value14_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value14.Set
inline void          value14_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value15.PresentQ
inline bool          value15_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value15.SetPresent
inline void          value15_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value15.Present_GetBit
inline int           value15_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value15.Set
inline void          value15_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value16.PresentQ
inline bool          value16_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value16.SetPresent
inline void          value16_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value16.Present_GetBit
inline int           value16_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value16.Set
inline void          value16_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value33.PresentQ
inline bool          value33_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value33.SetPresent
inline void          value33_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value33.Present_GetBit
inline int           value33_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value33.Set
inline void          value33_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value10.PresentQ
inline bool          value10_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value10.SetPresent
inline void          value10_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value10.Present_GetBit
inline int           value10_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value10.Set
inline void          value10_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value17.PresentQ
inline bool          value17_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value17.SetPresent
inline void          value17_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value17.Present_GetBit
inline int           value17_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value17.Set
inline void          value17_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value35.PresentQ
inline bool          value35_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value35.SetPresent
inline void          value35_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value35.Present_GetBit
inline int           value35_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value35.Set
inline void          value35_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value55.PresentQ
inline bool          value55_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value55.SetPresent
inline void          value55_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value55.Present_GetBit
inline int           value55_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value55.Set
inline void          value55_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value56.PresentQ
inline bool          value56_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value56.SetPresent
inline void          value56_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value56.Present_GetBit
inline int           value56_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value56.Set
inline void          value56_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value57.PresentQ
inline bool          value57_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value57.SetPresent
inline void          value57_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value57.Present_GetBit
inline int           value57_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value57.Set
inline void          value57_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value58.PresentQ
inline bool          value58_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value58.SetPresent
inline void          value58_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value58.Present_GetBit
inline int           value58_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value58.Set
inline void          value58_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value59.PresentQ
inline bool          value59_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value59.SetPresent
inline void          value59_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value59.Present_GetBit
inline int           value59_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value59.Set
inline void          value59_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value60.PresentQ
inline bool          value60_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value60.SetPresent
inline void          value60_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value60.Present_GetBit
inline int           value60_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value60.Set
inline void          value60_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value54.PresentQ
inline bool          value54_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value54.SetPresent
inline void          value54_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value54.Present_GetBit
inline int           value54_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value54.Set
inline void          value54_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value62.PresentQ
inline bool          value62_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value62.SetPresent
inline void          value62_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value62.Present_GetBit
inline int           value62_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value62.Set
inline void          value62_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value63.PresentQ
inline bool          value63_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value63.SetPresent
inline void          value63_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value63.Present_GetBit
inline int           value63_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value63.Set
inline void          value63_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value64.PresentQ
inline bool          value64_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value64.SetPresent
inline void          value64_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value64.Present_GetBit
inline int           value64_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value64.Set
inline void          value64_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value65.PresentQ
inline bool          value65_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value65.SetPresent
inline void          value65_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value65.Present_GetBit
inline int           value65_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value65.Set
inline void          value65_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value66.PresentQ
inline bool          value66_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value66.SetPresent
inline void          value66_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value66.Present_GetBit
inline int           value66_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value66.Set
inline void          value66_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value67.PresentQ
inline bool          value67_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value67.SetPresent
inline void          value67_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value67.Present_GetBit
inline int           value67_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value67.Set
inline void          value67_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value68.PresentQ
inline bool          value68_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value68.SetPresent
inline void          value68_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value68.Present_GetBit
inline int           value68_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value68.Set
inline void          value68_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value61.PresentQ
inline bool          value61_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value61.SetPresent
inline void          value61_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value61.Present_GetBit
inline int           value61_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value61.Set
inline void          value61_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value34.PresentQ
inline bool          value34_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value34.SetPresent
inline void          value34_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value34.Present_GetBit
inline int           value34_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value34.Set
inline void          value34_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value52.PresentQ
inline bool          value52_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value52.SetPresent
inline void          value52_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value52.Present_GetBit
inline int           value52_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value52.Set
inline void          value52_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value36.PresentQ
inline bool          value36_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value36.SetPresent
inline void          value36_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value36.Present_GetBit
inline int           value36_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value36.Set
inline void          value36_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value37.PresentQ
inline bool          value37_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value37.SetPresent
inline void          value37_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value37.Present_GetBit
inline int           value37_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value37.Set
inline void          value37_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value38.PresentQ
inline bool          value38_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value38.SetPresent
inline void          value38_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value38.Present_GetBit
inline int           value38_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value38.Set
inline void          value38_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value39.PresentQ
inline bool          value39_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value39.SetPresent
inline void          value39_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value39.Present_GetBit
inline int           value39_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value39.Set
inline void          value39_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value40.PresentQ
inline bool          value40_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value40.SetPresent
inline void          value40_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value40.Present_GetBit
inline int           value40_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value40.Set
inline void          value40_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value41.PresentQ
inline bool          value41_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value41.SetPresent
inline void          value41_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value41.Present_GetBit
inline int           value41_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value41.Set
inline void          value41_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value42.PresentQ
inline bool          value42_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value42.SetPresent
inline void          value42_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value42.Present_GetBit
inline int           value42_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value42.Set
inline void          value42_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value53.PresentQ
inline bool          value53_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value53.SetPresent
inline void          value53_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value53.Present_GetBit
inline int           value53_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value53.Set
inline void          value53_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value44.PresentQ
inline bool          value44_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value44.SetPresent
inline void          value44_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value44.Present_GetBit
inline int           value44_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value44.Set
inline void          value44_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value45.PresentQ
inline bool          value45_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value45.SetPresent
inline void          value45_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value45.Present_GetBit
inline int           value45_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value45.Set
inline void          value45_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value46.PresentQ
inline bool          value46_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value46.SetPresent
inline void          value46_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value46.Present_GetBit
inline int           value46_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value46.Set
inline void          value46_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value47.PresentQ
inline bool          value47_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value47.SetPresent
inline void          value47_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value47.Present_GetBit
inline int           value47_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value47.Set
inline void          value47_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value48.PresentQ
inline bool          value48_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value48.SetPresent
inline void          value48_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value48.Present_GetBit
inline int           value48_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value48.Set
inline void          value48_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value49.PresentQ
inline bool          value49_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value49.SetPresent
inline void          value49_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value49.Present_GetBit
inline int           value49_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value49.Set
inline void          value49_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value50.PresentQ
inline bool          value50_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value50.SetPresent
inline void          value50_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value50.Present_GetBit
inline int           value50_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value50.Set
inline void          value50_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value51.PresentQ
inline bool          value51_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value51.SetPresent
inline void          value51_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value51.Present_GetBit
inline int           value51_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value51.Set
inline void          value51_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value43.PresentQ
inline bool          value43_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value43.SetPresent
inline void          value43_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value43.Present_GetBit
inline int           value43_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value43.Set
inline void          value43_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value70.PresentQ
inline bool          value70_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value70.SetPresent
inline void          value70_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value70.Present_GetBit
inline int           value70_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value70.Set
inline void          value70_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU128.value71.PresentQ
inline bool          value71_PresentQ(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU128.value71.SetPresent
inline void          value71_SetPresent(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU128.value71.Present_GetBit
inline int           value71_Present_GetBit(atf_amc::PmaskU128& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU128.value71.Set
inline void          value71_Set(atf_amc::PmaskU128& parent, u32 rhs) __attribute__((nothrow));

// func:atf_amc.PmaskU128..ReadFieldMaybe
bool                 PmaskU128_ReadFieldMaybe(atf_amc::PmaskU128& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PmaskU128 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.PmaskU128..ReadStrptrMaybe
bool                 PmaskU128_ReadStrptrMaybe(atf_amc::PmaskU128 &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.PmaskU128..Init
void                 PmaskU128_Init(atf_amc::PmaskU128& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.PmaskU128.String  printfmt:Tuple
// func:atf_amc.PmaskU128..Print
void                 PmaskU128_Print(atf_amc::PmaskU128& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.PmaskU32
#pragma pack(push,1)
struct PmaskU32 { // atf_amc.PmaskU32: A field controlled by a bitmask.
    u32   pmask;    //   0
    u32   value;    //   0
    u32   value2;   //   0
    u32   value3;   //   0
    u32   value4;   //   0
    u32   value5;   //   0
    // func:atf_amc.PmaskU32..Ctor
    inline               PmaskU32() __attribute__((nothrow));
};
#pragma pack(pop)

// Return constant 1
// func:atf_amc.PmaskU32.pmask.N
inline int           pmask_N(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
// func:atf_amc.PmaskU32.pmask.qFind
inline u32&          pmask_qFind(atf_amc::PmaskU32& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.PmaskU32.pmask.NBits
inline int           pmask_Nbits(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU32.pmask.qGetBit
inline bool          pmask_qGetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.PmaskU32.pmask.GetBit
inline bool          pmask_GetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.PmaskU32.pmask.BitsEmptyQ
inline bool          pmask_BitsEmptyQ(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PmaskU32.pmask.Sum1s
inline u64           pmask_Sum1s(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU32.pmask.qClearBit
inline void          pmask_qClearBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.PmaskU32.pmask.ClearBit
inline void          pmask_ClearBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU32.pmask.qSetBit
inline void          pmask_qSetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.PmaskU32.pmask.SetBit
inline void          pmask_SetBit(atf_amc::PmaskU32& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU32.pmask.qSetBitVal
inline void          pmask_qSetBitVal(atf_amc::PmaskU32& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU32.pmask.qOrBitVal
inline void          pmask_qOrBitVal(atf_amc::PmaskU32& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.PmaskU32.pmask.ClearBitsAll
inline void          pmask_ClearBitsAll(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.PmaskU32.pmask.ClearBits
inline void          pmask_ClearBits(atf_amc::PmaskU32& parent, atf_amc::PmaskU32 &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.PmaskU32.pmask.OrBits
inline void          pmask_OrBits(atf_amc::PmaskU32& parent, atf_amc::PmaskU32 &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.PmaskU32.pmask.Sup
inline i32           pmask_Sup(atf_amc::PmaskU32& parent) __attribute__((__warn_unused_result__, nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU32.value.PresentQ
inline bool          value_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU32.value.SetPresent
inline void          value_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU32.value.Present_GetBit
inline int           value_Present_GetBit(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU32.value.Set
inline void          value_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU32.value2.PresentQ
inline bool          value2_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU32.value2.SetPresent
inline void          value2_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU32.value2.Present_GetBit
inline int           value2_Present_GetBit(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU32.value2.Set
inline void          value2_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU32.value3.PresentQ
inline bool          value3_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU32.value3.SetPresent
inline void          value3_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU32.value3.Present_GetBit
inline int           value3_Present_GetBit(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU32.value3.Set
inline void          value3_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU32.value4.PresentQ
inline bool          value4_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU32.value4.SetPresent
inline void          value4_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU32.value4.Present_GetBit
inline int           value4_Present_GetBit(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU32.value4.Set
inline void          value4_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU32.value5.PresentQ
inline bool          value5_PresentQ(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU32.value5.SetPresent
inline void          value5_SetPresent(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU32.value5.Present_GetBit
inline int           value5_Present_GetBit(atf_amc::PmaskU32& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU32.value5.Set
inline void          value5_Set(atf_amc::PmaskU32& parent, u32 rhs) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.PmaskU32.pmask_bitcurs.Next
void                 PmaskU32_pmask_bitcurs_Next(PmaskU32_pmask_bitcurs &curs);
// func:atf_amc.PmaskU32.pmask_bitcurs.Reset
inline void          PmaskU32_pmask_bitcurs_Reset(PmaskU32_pmask_bitcurs &curs, atf_amc::PmaskU32 &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskU32.pmask_bitcurs.ValidQ
inline bool          PmaskU32_pmask_bitcurs_ValidQ(PmaskU32_pmask_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.PmaskU32.pmask_bitcurs.Access
inline int&          PmaskU32_pmask_bitcurs_Access(PmaskU32_pmask_bitcurs &curs) __attribute__((nothrow));
// func:atf_amc.PmaskU32..ReadFieldMaybe
bool                 PmaskU32_ReadFieldMaybe(atf_amc::PmaskU32& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PmaskU32 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.PmaskU32..ReadStrptrMaybe
bool                 PmaskU32_ReadStrptrMaybe(atf_amc::PmaskU32 &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.PmaskU32..Init
inline void          PmaskU32_Init(atf_amc::PmaskU32& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.PmaskU32.String  printfmt:Tuple
// func:atf_amc.PmaskU32..Print
void                 PmaskU32_Print(atf_amc::PmaskU32& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.PmaskU555
#pragma pack(push,1)
struct PmaskU555 { // atf_amc.PmaskU555: Check pmask with 555 bits
    u32   value;             //   0
    u64   pmask_elems[10];   //   0  fixed array
    // func:atf_amc.PmaskU555..Ctor
    inline               PmaskU555() __attribute__((nothrow));
};
#pragma pack(pop)

// Return true if the field is marked in the presence mask
// func:atf_amc.PmaskU555.value.PresentQ
inline bool          value_PresentQ(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Set presence bit for this field in the pmask
// func:atf_amc.PmaskU555.value.SetPresent
inline void          value_SetPresent(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Return field's bit number in the pmask
// func:atf_amc.PmaskU555.value.Present_GetBit
inline int           value_Present_GetBit(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// func:atf_amc.PmaskU555.value.Set
inline void          value_Set(atf_amc::PmaskU555& parent, u32 rhs) __attribute__((nothrow));

// Get max # of bits in the bitset
// Return max. number of bits supported by array
// func:atf_amc.PmaskU555.pmask.NBits
inline int           pmask_Nbits(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU555.pmask.qGetBit
inline bool          pmask_qGetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
// func:atf_amc.PmaskU555.pmask.GetBit
inline bool          pmask_GetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
// func:atf_amc.PmaskU555.pmask.BitsEmptyQ
inline bool          pmask_BitsEmptyQ(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PmaskU555.pmask.Sum1s
inline u64           pmask_Sum1s(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU555.pmask.qClearBit
inline void          pmask_qClearBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
// func:atf_amc.PmaskU555.pmask.ClearBit
inline void          pmask_ClearBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU555.pmask.qSetBit
inline void          pmask_qSetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
// func:atf_amc.PmaskU555.pmask.SetBit
inline void          pmask_SetBit(atf_amc::PmaskU555& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU555.pmask.qSetBitVal
inline void          pmask_qSetBitVal(atf_amc::PmaskU555& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
// func:atf_amc.PmaskU555.pmask.qOrBitVal
inline void          pmask_qOrBitVal(atf_amc::PmaskU555& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
// func:atf_amc.PmaskU555.pmask.ClearBitsAll
inline void          pmask_ClearBitsAll(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
// func:atf_amc.PmaskU555.pmask.ClearBits
inline void          pmask_ClearBits(atf_amc::PmaskU555& parent, atf_amc::PmaskU555 &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
// func:atf_amc.PmaskU555.pmask.OrBits
inline void          pmask_OrBits(atf_amc::PmaskU555& parent, atf_amc::PmaskU555 &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
// func:atf_amc.PmaskU555.pmask.Sup
inline i32           pmask_Sup(atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
// func:atf_amc.PmaskU555.pmask.Fill
inline void          pmask_Fill(atf_amc::PmaskU555& parent, const u64 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.PmaskU555.pmask.Find
inline u64*          pmask_Find(atf_amc::PmaskU555& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array pmask as aryptr.
// func:atf_amc.PmaskU555.pmask.Getary
inline algo::aryptr<u64> pmask_Getary(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Return max number of items in the array
// func:atf_amc.PmaskU555.pmask.Max
inline i32           pmask_Max(atf_amc::PmaskU555& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.PmaskU555.pmask.N
inline i32           pmask_N(const atf_amc::PmaskU555& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
// func:atf_amc.PmaskU555.pmask.Setary
inline void          pmask_Setary(atf_amc::PmaskU555& parent, const algo::aryptr<u64> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:atf_amc.PmaskU555.pmask.qFind
inline u64&          pmask_qFind(atf_amc::PmaskU555& parent, u64 t) __attribute__((nothrow));
// Read array from string
// Convert string to field. Return success value
// func:atf_amc.PmaskU555.pmask.ReadStrptrMaybe
bool                 pmask_ReadStrptrMaybe(atf_amc::PmaskU555& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.PmaskU555.pmask_bitcurs.Next
void                 PmaskU555_pmask_bitcurs_Next(PmaskU555_pmask_bitcurs &curs);
// func:atf_amc.PmaskU555.pmask_bitcurs.Reset
inline void          PmaskU555_pmask_bitcurs_Reset(PmaskU555_pmask_bitcurs &curs, atf_amc::PmaskU555 &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskU555.pmask_bitcurs.ValidQ
inline bool          PmaskU555_pmask_bitcurs_ValidQ(PmaskU555_pmask_bitcurs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.PmaskU555.pmask_bitcurs.Access
inline int&          PmaskU555_pmask_bitcurs_Access(PmaskU555_pmask_bitcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskU555.pmask_curs.Reset
inline void          PmaskU555_pmask_curs_Reset(PmaskU555_pmask_curs &curs, atf_amc::PmaskU555 &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.PmaskU555.pmask_curs.ValidQ
inline bool          PmaskU555_pmask_curs_ValidQ(PmaskU555_pmask_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.PmaskU555.pmask_curs.Next
inline void          PmaskU555_pmask_curs_Next(PmaskU555_pmask_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.PmaskU555.pmask_curs.Access
inline u64&          PmaskU555_pmask_curs_Access(PmaskU555_pmask_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.PmaskU555..Init
inline void          PmaskU555_Init(atf_amc::PmaskU555& parent);

// --- atf_amc.PooledBE64
// create: atf_amc.FDb.pooledbe64 (Tpool)
struct PooledBE64 { // atf_amc.PooledBE64
    atf_amc::PooledBE64*   pooledbe64_next;   // Pointer to next free element int tpool
    u64                    value_be;          //   0
    // func:atf_amc.PooledBE64..EnumCtor
    inline               PooledBE64(atf_amc_PooledBE64_value_Enum arg) __attribute__((nothrow));
private:
    // func:atf_amc.PooledBE64..Ctor
    inline               PooledBE64() __attribute__((nothrow));
    friend atf_amc::PooledBE64& pooledbe64_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::PooledBE64* pooledbe64_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pooledbe64_Delete(atf_amc::PooledBE64 &row) __attribute__((nothrow));
};

// func:atf_amc.PooledBE64.value.Get
inline u64           value_Get(const atf_amc::PooledBE64& pooledbe64) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.PooledBE64.value.Set
inline void          value_Set(atf_amc::PooledBE64& pooledbe64, u64 rhs) __attribute__((nothrow));
// Get value of field as enum type
// func:atf_amc.PooledBE64.value.GetEnum
inline atf_amc_PooledBE64_value_Enum value_GetEnum(const atf_amc::PooledBE64& pooledbe64) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.PooledBE64.value.SetEnum
inline void          value_SetEnum(atf_amc::PooledBE64& pooledbe64, atf_amc_PooledBE64_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.PooledBE64.value.ToCstr
const char*          value_ToCstr(const atf_amc::PooledBE64& pooledbe64) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.PooledBE64.value.Print
void                 value_Print(const atf_amc::PooledBE64& pooledbe64, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.PooledBE64.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.PooledBE64.value.SetStrptr
void                 value_SetStrptr(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs, atf_amc_PooledBE64_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.PooledBE64.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::PooledBE64& pooledbe64, algo::strptr rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.PooledBE64..Init
inline void          PooledBE64_Init(atf_amc::PooledBE64& pooledbe64);
// func:atf_amc.PooledBE64..ReadFieldMaybe
bool                 PooledBE64_ReadFieldMaybe(atf_amc::PooledBE64& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::PooledBE64 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.PooledBE64..ReadStrptrMaybe
bool                 PooledBE64_ReadStrptrMaybe(atf_amc::PooledBE64 &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.PooledBE64.String  printfmt:Tuple
// func:atf_amc.PooledBE64..Print
void                 PooledBE64_Print(atf_amc::PooledBE64& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.RnullStr6_U32
struct RnullStr6_U32 { // atf_amc.RnullStr6_U32: number stored as ascii digits, right pad with NUL
    enum { ch_max = 6 };
    u8 ch[6];
    // Copy from strptr (operator=)
    // func:atf_amc.RnullStr6_U32.ch.AssignStrptr
    inline void          operator =(const algo::strptr &str) __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32.ch.CtorStrptr
    inline               RnullStr6_U32(const algo::strptr &rhs) __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..EqOp
    inline bool          operator ==(const atf_amc::RnullStr6_U32 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..NeOp
    inline bool          operator !=(const atf_amc::RnullStr6_U32 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..LtOp
    inline bool          operator <(const atf_amc::RnullStr6_U32 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..GtOp
    inline bool          operator >(const atf_amc::RnullStr6_U32 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..LeOp
    inline bool          operator <=(const atf_amc::RnullStr6_U32 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..GeOp
    inline bool          operator >=(const atf_amc::RnullStr6_U32 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..EqOpAryptr
    inline bool          operator ==(const algo::aryptr<char> &rhs) const __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..AssignOp
    inline atf_amc::RnullStr6_U32& operator =(const atf_amc::RnullStr6_U32 &rhs) __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..Ctor
    inline               RnullStr6_U32() __attribute__((nothrow));
    // func:atf_amc.RnullStr6_U32..CopyCtor
    inline               RnullStr6_U32(const atf_amc::RnullStr6_U32 &rhs) __attribute__((nothrow));
};

// Access string as array of chars
// func:atf_amc.RnullStr6_U32.ch.Getary
inline algo::aryptr<char> ch_Getary(const atf_amc::RnullStr6_U32& parent) __attribute__((nothrow));
// func:atf_amc.RnullStr6_U32.ch.HashStrptr
inline u32           RnullStr6_U32_Hash(u32 prev, const algo::strptr &str);
// func:atf_amc.RnullStr6_U32.ch.Init
inline void          ch_Init(atf_amc::RnullStr6_U32 &parent) __attribute__((nothrow));
// always return constant 6
// func:atf_amc.RnullStr6_U32.ch.Max
inline int           ch_Max(atf_amc::RnullStr6_U32& parent) __attribute__((nothrow));
// func:atf_amc.RnullStr6_U32.ch.N
inline int           ch_N(const atf_amc::RnullStr6_U32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// func:atf_amc.RnullStr6_U32.ch.Print
void                 ch_Print(atf_amc::RnullStr6_U32& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.RnullStr6_U32.ch.ReadStrptrMaybe
bool                 ch_ReadStrptrMaybe(atf_amc::RnullStr6_U32& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
// func:atf_amc.RnullStr6_U32.ch.SetStrptr
void                 ch_SetStrptr(atf_amc::RnullStr6_U32& parent, const algo::strptr& rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
// func:atf_amc.RnullStr6_U32.ch.Getnum
u32                  ch_Getnum(atf_amc::RnullStr6_U32& parent, bool &and_ok) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
// func:atf_amc.RnullStr6_U32.ch.GetnumDflt
u32                  ch_GetnumDflt(atf_amc::RnullStr6_U32& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
// func:atf_amc.RnullStr6_U32.ch.Geti64
i64                  ch_Geti64(atf_amc::RnullStr6_U32& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
// func:atf_amc.RnullStr6_U32.ch.SetnumMaybe
bool                 ch_SetnumMaybe(atf_amc::RnullStr6_U32& parent, i64 rhs) __attribute__((nothrow));

// func:atf_amc.RnullStr6_U32..Hash
u32                  RnullStr6_U32_Hash(u32 prev, const atf_amc::RnullStr6_U32& rhs) __attribute__((nothrow));
// Read fields of atf_amc::RnullStr6_U32 from an ascii string.
// The format of the string is the format of the atf_amc::RnullStr6_U32's only field
// func:atf_amc.RnullStr6_U32..ReadStrptrMaybe
bool                 RnullStr6_U32_ReadStrptrMaybe(atf_amc::RnullStr6_U32 &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.RnullStr6_U32..Lt
inline bool          RnullStr6_U32_Lt(atf_amc::RnullStr6_U32& lhs, atf_amc::RnullStr6_U32& rhs) __attribute__((nothrow));
// func:atf_amc.RnullStr6_U32..Cmp
inline i32           RnullStr6_U32_Cmp(atf_amc::RnullStr6_U32& lhs, atf_amc::RnullStr6_U32& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.RnullStr6_U32..Init
inline void          RnullStr6_U32_Init(atf_amc::RnullStr6_U32& parent);
// func:atf_amc.RnullStr6_U32..Eq
inline bool          RnullStr6_U32_Eq(atf_amc::RnullStr6_U32& lhs, atf_amc::RnullStr6_U32& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.RnullStr6_U32..Update
inline bool          RnullStr6_U32_Update(atf_amc::RnullStr6_U32 &lhs, atf_amc::RnullStr6_U32& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.RnullStr6_U32.String  printfmt:Raw
// func:atf_amc.RnullStr6_U32..Print
void                 RnullStr6_U32_Print(atf_amc::RnullStr6_U32& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.RpasU32Str6
struct RpasU32Str6 { // atf_amc.RpasU32Str6: number stored as ascii digits, right pad with NUL
    enum { ch_max = 6 };
    u8 ch[6+1];
    u8 n_ch;

    // Copy from strptr (operator=)
    // func:atf_amc.RpasU32Str6.ch.AssignStrptr
    inline void          operator =(const algo::strptr &str) __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6.ch.CtorStrptr
    inline               RpasU32Str6(const algo::strptr &rhs) __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..EqOp
    inline bool          operator ==(const atf_amc::RpasU32Str6 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..NeOp
    inline bool          operator !=(const atf_amc::RpasU32Str6 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..LtOp
    inline bool          operator <(const atf_amc::RpasU32Str6 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..GtOp
    inline bool          operator >(const atf_amc::RpasU32Str6 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..LeOp
    inline bool          operator <=(const atf_amc::RpasU32Str6 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..GeOp
    inline bool          operator >=(const atf_amc::RpasU32Str6 &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..EqOpAryptr
    inline bool          operator ==(const algo::aryptr<char> &rhs) const __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..AssignOp
    inline atf_amc::RpasU32Str6& operator =(const atf_amc::RpasU32Str6 &rhs) __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..Ctor
    inline               RpasU32Str6() __attribute__((nothrow));
    // func:atf_amc.RpasU32Str6..CopyCtor
    inline               RpasU32Str6(const atf_amc::RpasU32Str6 &rhs) __attribute__((nothrow));
};

// Append character to string.
// If there is no space for an extra character, do nothing.
// func:atf_amc.RpasU32Str6.ch.Add
inline void          ch_Add(atf_amc::RpasU32Str6& parent, char c) __attribute__((nothrow));
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
// func:atf_amc.RpasU32Str6.ch.AddStrptr
inline void          ch_AddStrptr(atf_amc::RpasU32Str6& parent, algo::strptr str) __attribute__((nothrow));
// Access string as array of chars
// func:atf_amc.RpasU32Str6.ch.Getary
inline algo::aryptr<char> ch_Getary(const atf_amc::RpasU32Str6& parent) __attribute__((nothrow));
// func:atf_amc.RpasU32Str6.ch.HashStrptr
inline u32           RpasU32Str6_Hash(u32 prev, const algo::strptr &str);
// func:atf_amc.RpasU32Str6.ch.Init
inline void          ch_Init(atf_amc::RpasU32Str6 &parent) __attribute__((nothrow));
// always return constant 6
// func:atf_amc.RpasU32Str6.ch.Max
inline int           ch_Max(atf_amc::RpasU32Str6& parent) __attribute__((nothrow));
// func:atf_amc.RpasU32Str6.ch.N
inline int           ch_N(const atf_amc::RpasU32Str6& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// func:atf_amc.RpasU32Str6.ch.Print
void                 ch_Print(atf_amc::RpasU32Str6& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.RpasU32Str6.ch.ReadStrptrMaybe
bool                 ch_ReadStrptrMaybe(atf_amc::RpasU32Str6& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
// func:atf_amc.RpasU32Str6.ch.SetStrptr
void                 ch_SetStrptr(atf_amc::RpasU32Str6& parent, const algo::strptr& rhs) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, the result
// is undefined, and and_ok is set to false.
// Empty string is evaluated to zero.
// func:atf_amc.RpasU32Str6.ch.Getnum
u32                  ch_Getnum(atf_amc::RpasU32Str6& parent, bool &and_ok) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, return default value.
// Empty string is evaluated to zero.
// func:atf_amc.RpasU32Str6.ch.GetnumDflt
u32                  ch_GetnumDflt(atf_amc::RpasU32Str6& parent, u32 dflt) __attribute__((nothrow));
// Convert field to numeric value. If the value is too large
// for the target type, or the string is invalid, throw an exception.
// Empty string is evaluated to zero.
// func:atf_amc.RpasU32Str6.ch.Geti64
i64                  ch_Geti64(atf_amc::RpasU32Str6& parent, bool &out_ok) __attribute__((nothrow));
// Set string to number specified in RHS performing base-10 conversion.
// If the number is too large for the string, return false.
// func:atf_amc.RpasU32Str6.ch.SetnumMaybe
bool                 ch_SetnumMaybe(atf_amc::RpasU32Str6& parent, i64 rhs) __attribute__((nothrow));

// func:atf_amc.RpasU32Str6..Hash
u32                  RpasU32Str6_Hash(u32 prev, const atf_amc::RpasU32Str6& rhs) __attribute__((nothrow));
// Read fields of atf_amc::RpasU32Str6 from an ascii string.
// The format of the string is the format of the atf_amc::RpasU32Str6's only field
// func:atf_amc.RpasU32Str6..ReadStrptrMaybe
bool                 RpasU32Str6_ReadStrptrMaybe(atf_amc::RpasU32Str6 &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.RpasU32Str6..Lt
inline bool          RpasU32Str6_Lt(atf_amc::RpasU32Str6& lhs, atf_amc::RpasU32Str6& rhs) __attribute__((nothrow));
// func:atf_amc.RpasU32Str6..Cmp
inline i32           RpasU32Str6_Cmp(atf_amc::RpasU32Str6& lhs, atf_amc::RpasU32Str6& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.RpasU32Str6..Init
inline void          RpasU32Str6_Init(atf_amc::RpasU32Str6& parent);
// func:atf_amc.RpasU32Str6..Eq
inline bool          RpasU32Str6_Eq(atf_amc::RpasU32Str6& lhs, atf_amc::RpasU32Str6& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.RpasU32Str6..Update
inline bool          RpasU32Str6_Update(atf_amc::RpasU32Str6 &lhs, atf_amc::RpasU32Str6& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.RpasU32Str6.String  printfmt:Raw
// func:atf_amc.RpasU32Str6..Print
void                 RpasU32Str6_Print(atf_amc::RpasU32Str6& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Sep1
struct Sep1 { // atf_amc.Sep1: Check printing/reading of types with separators
    u32   val1;   //   0
    u32   val2;   //   0
    u32   val3;   //   0
    // func:atf_amc.Sep1..EqOp
    inline bool          operator ==(const atf_amc::Sep1 &rhs) const __attribute__((nothrow));
    // func:atf_amc.Sep1..NeOp
    inline bool          operator !=(const atf_amc::Sep1 &rhs) const __attribute__((nothrow));
    // func:atf_amc.Sep1..LtOp
    inline bool          operator <(const atf_amc::Sep1 &rhs) const __attribute__((nothrow));
    // func:atf_amc.Sep1..GtOp
    inline bool          operator >(const atf_amc::Sep1 &rhs) const __attribute__((nothrow));
    // func:atf_amc.Sep1..LeOp
    inline bool          operator <=(const atf_amc::Sep1 &rhs) const __attribute__((nothrow));
    // func:atf_amc.Sep1..GeOp
    inline bool          operator >=(const atf_amc::Sep1 &rhs) const __attribute__((nothrow));
    // func:atf_amc.Sep1..Ctor
    inline               Sep1() __attribute__((nothrow));
    // func:atf_amc.Sep1..FieldwiseCtor
    explicit inline               Sep1(u32 in_val1, u32 in_val2, u32 in_val3) __attribute__((nothrow));
};

// func:atf_amc.Sep1..Hash
inline u32           Sep1_Hash(u32 prev, const atf_amc::Sep1& rhs) __attribute__((nothrow));
// func:atf_amc.Sep1..ReadFieldMaybe
bool                 Sep1_ReadFieldMaybe(atf_amc::Sep1& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Sep1 from an ascii string.
// The format of the string is a string with separated values
// func:atf_amc.Sep1..ReadStrptrMaybe
bool                 Sep1_ReadStrptrMaybe(atf_amc::Sep1 &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.Sep1..Lt
inline bool          Sep1_Lt(atf_amc::Sep1& lhs, atf_amc::Sep1& rhs) __attribute__((nothrow));
// func:atf_amc.Sep1..Cmp
inline i32           Sep1_Cmp(atf_amc::Sep1& lhs, atf_amc::Sep1& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Sep1..Init
inline void          Sep1_Init(atf_amc::Sep1& parent);
// func:atf_amc.Sep1..Eq
inline bool          Sep1_Eq(atf_amc::Sep1& lhs, atf_amc::Sep1& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.Sep1..Update
inline bool          Sep1_Update(atf_amc::Sep1 &lhs, atf_amc::Sep1& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.Sep1.String  printfmt:Sep
// func:atf_amc.Sep1..Print
void                 Sep1_Print(atf_amc::Sep1& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Seqmsg
#pragma pack(push,1)
struct Seqmsg { // atf_amc.Seqmsg: Sequenced message for stream
    atf_amc::MsgType           type;        //   0x0905  Message type
    atf_amc::MsgLength         length;      //   ssizeof(parent) + (0)  Total message length, including this header
    // atf_amc::MsgHeader      payload[];                                                                               optional field
    // func:atf_amc.Seqmsg..Ctor
    inline               Seqmsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.Seqmsg.msghdr.CopyOut
void                 parent_CopyOut(atf_amc::Seqmsg &row, atf_amc::MsgHeader &out) __attribute__((nothrow));
// Check if atf_amc::MsgHeader is an instance of Seqmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Seqmsg.
// If not successful, quietly return NULL.
// func:atf_amc.Seqmsg.msghdr.Castdown
inline atf_amc::Seqmsg* Seqmsg_Castdown(atf_amc::MsgHeader &hdr);
// func:atf_amc.Seqmsg.msghdr.Castbase
inline atf_amc::MsgHeader& Castbase(atf_amc::Seqmsg& parent);

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
// func:atf_amc.Seqmsg.payload.Get
inline atf_amc::MsgHeader* payload_Get(atf_amc::Seqmsg& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:atf_amc.Seqmsg.payload.Getary
algo::aryptr<u8>     payload_Getary(atf_amc::Seqmsg& parent) __attribute__((nothrow));
// func:atf_amc.Seqmsg.payload.Print
void                 payload_Print(atf_amc::Seqmsg& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.Seqmsg.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(atf_amc::Seqmsg &parent, algo::strptr in_str) __attribute__((nothrow));

// func:atf_amc.Seqmsg..ReadFieldMaybe
bool                 Seqmsg_ReadFieldMaybe(atf_amc::Seqmsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::Seqmsg from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.Seqmsg..ReadStrptrMaybe
bool                 Seqmsg_ReadStrptrMaybe(atf_amc::Seqmsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.Seqmsg..GetMsgLength
inline i32           GetMsgLength(const atf_amc::Seqmsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.Seqmsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::Seqmsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Seqmsg..Init
inline void          Seqmsg_Init(atf_amc::Seqmsg& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.Seqmsg.String  printfmt:Tuple
// func:atf_amc.Seqmsg..Print
void                 Seqmsg_Print(atf_amc::Seqmsg& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.SortedStr
struct SortedStr { // atf_amc.SortedStr
    algo::cstring   novs;   //
    algo::cstring   vs;     //
    // func:atf_amc.SortedStr..EqOp
    inline bool          operator ==(const atf_amc::SortedStr &rhs) const __attribute__((nothrow));
    // func:atf_amc.SortedStr..NeOp
    inline bool          operator !=(const atf_amc::SortedStr &rhs) const __attribute__((nothrow));
    // func:atf_amc.SortedStr..LtOp
    inline bool          operator <(const atf_amc::SortedStr &rhs) const __attribute__((nothrow));
    // func:atf_amc.SortedStr..GtOp
    inline bool          operator >(const atf_amc::SortedStr &rhs) const __attribute__((nothrow));
    // func:atf_amc.SortedStr..LeOp
    inline bool          operator <=(const atf_amc::SortedStr &rhs) const __attribute__((nothrow));
    // func:atf_amc.SortedStr..GeOp
    inline bool          operator >=(const atf_amc::SortedStr &rhs) const __attribute__((nothrow));
    // func:atf_amc.SortedStr..Ctor
    inline               SortedStr() __attribute__((nothrow));
    // func:atf_amc.SortedStr..FieldwiseCtor
    explicit inline               SortedStr(const algo::strptr& in_novs, const algo::strptr& in_vs) __attribute__((nothrow));
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
// func:atf_amc.SortedStr.novs.Lt
inline bool          novs_Lt(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));
// Compare two fields.
// func:atf_amc.SortedStr.novs.Cmp
inline i32           novs_Cmp(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
// func:atf_amc.SortedStr.vs.Lt
inline bool          vs_Lt(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));
// Compare two fields.
// Comparison uses version sort (detect embedded integers).
// Comparison is case-insensitive.
// func:atf_amc.SortedStr.vs.Cmp
i32                  vs_Cmp(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) __attribute__((nothrow));

// func:atf_amc.SortedStr..Lt
inline bool          SortedStr_Lt(atf_amc::SortedStr& lhs, atf_amc::SortedStr& rhs) __attribute__((nothrow));
// func:atf_amc.SortedStr..Cmp
inline i32           SortedStr_Cmp(atf_amc::SortedStr& lhs, atf_amc::SortedStr& rhs) __attribute__((nothrow));
// func:atf_amc.SortedStr..Eq
inline bool          SortedStr_Eq(atf_amc::SortedStr& lhs, atf_amc::SortedStr& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.SortedStr..Update
inline bool          SortedStr_Update(atf_amc::SortedStr &lhs, atf_amc::SortedStr& rhs) __attribute__((nothrow));

// --- atf_amc.SsimfilesCase
#pragma pack(push,1)
struct SsimfilesCase { // atf_amc.SsimfilesCase: Enum for dispatch atf_amc.Ssimfiles
    u32   value;   //   0
    // func:atf_amc.SsimfilesCase.value.Cast
    inline               operator atf_amc_SsimfilesCaseEnum() const __attribute__((nothrow));
    // func:atf_amc.SsimfilesCase..Ctor
    inline               SsimfilesCase() __attribute__((nothrow));
    // func:atf_amc.SsimfilesCase..FieldwiseCtor
    explicit inline               SsimfilesCase(u32 in_value) __attribute__((nothrow));
    // func:atf_amc.SsimfilesCase..EnumCtor
    inline               SsimfilesCase(atf_amc_SsimfilesCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_amc.SsimfilesCase.value.GetEnum
inline atf_amc_SsimfilesCaseEnum value_GetEnum(const atf_amc::SsimfilesCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.SsimfilesCase.value.SetEnum
inline void          value_SetEnum(atf_amc::SsimfilesCase& parent, atf_amc_SsimfilesCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.SsimfilesCase.value.ToCstr
const char*          value_ToCstr(const atf_amc::SsimfilesCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.SsimfilesCase.value.Print
void                 value_Print(const atf_amc::SsimfilesCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.SsimfilesCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::SsimfilesCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.SsimfilesCase.value.SetStrptr
void                 value_SetStrptr(atf_amc::SsimfilesCase& parent, algo::strptr rhs, atf_amc_SsimfilesCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.SsimfilesCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::SsimfilesCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::SsimfilesCase from an ascii string.
// The format of the string is the format of the atf_amc::SsimfilesCase's only field
// func:atf_amc.SsimfilesCase..ReadStrptrMaybe
bool                 SsimfilesCase_ReadStrptrMaybe(atf_amc::SsimfilesCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.SsimfilesCase..Init
inline void          SsimfilesCase_Init(atf_amc::SsimfilesCase& parent);

// --- atf_amc.TableId
struct TableId { // atf_amc.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    // func:atf_amc.TableId.value.Cast
    inline               operator atf_amc_TableIdEnum() const __attribute__((nothrow));
    // func:atf_amc.TableId..Ctor
    inline               TableId() __attribute__((nothrow));
    // func:atf_amc.TableId..FieldwiseCtor
    explicit inline               TableId(i32 in_value) __attribute__((nothrow));
    // func:atf_amc.TableId..EnumCtor
    inline               TableId(atf_amc_TableIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:atf_amc.TableId.value.GetEnum
inline atf_amc_TableIdEnum value_GetEnum(const atf_amc::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.TableId.value.SetEnum
inline void          value_SetEnum(atf_amc::TableId& parent, atf_amc_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.TableId.value.ToCstr
const char*          value_ToCstr(const atf_amc::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.TableId.value.Print
void                 value_Print(const atf_amc::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.TableId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.TableId.value.SetStrptr
void                 value_SetStrptr(atf_amc::TableId& parent, algo::strptr rhs, atf_amc_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.TableId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_amc::TableId from an ascii string.
// The format of the string is the format of the atf_amc::TableId's only field
// func:atf_amc.TableId..ReadStrptrMaybe
bool                 TableId_ReadStrptrMaybe(atf_amc::TableId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TableId..Init
inline void          TableId_Init(atf_amc::TableId& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.TableId.String  printfmt:Raw
// func:atf_amc.TableId..Print
void                 TableId_Print(atf_amc::TableId& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TaryU32
struct TaryU32 { // atf_amc.TaryU32
    u32*   tary_u32_elems;   // pointer to elements
    u32    tary_u32_n;       // number of elements in array
    u32    tary_u32_max;     // max. capacity of array before realloc
    // Copy from aryptr (operator=)
    // func:atf_amc.TaryU32.tary_u32.AssignAryptr
    inline void          operator =(const algo::aryptr<u32> &rhs) __attribute__((nothrow));
    // func:atf_amc.TaryU32.tary_u32.CtorAryptr
    explicit inline               TaryU32(const algo::aryptr<u32> &rhs) __attribute__((nothrow));
    // func:atf_amc.TaryU32..AssignOp
    atf_amc::TaryU32&    operator =(const atf_amc::TaryU32 &rhs) __attribute__((nothrow));
    // func:atf_amc.TaryU32..Ctor
    inline               TaryU32() __attribute__((nothrow));
    // func:atf_amc.TaryU32..Dtor
    inline               ~TaryU32() __attribute__((nothrow));
    // func:atf_amc.TaryU32..CopyCtor
    TaryU32(const atf_amc::TaryU32 &rhs) __attribute__((nothrow));
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:atf_amc.TaryU32.tary_u32.Addary
algo::aryptr<u32>    tary_u32_Addary(atf_amc::TaryU32& parent, algo::aryptr<u32> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:atf_amc.TaryU32.tary_u32.Alloc
u32&                 tary_u32_Alloc(atf_amc::TaryU32& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:atf_amc.TaryU32.tary_u32.AllocAt
u32&                 tary_u32_AllocAt(atf_amc::TaryU32& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.TaryU32.tary_u32.AllocN
algo::aryptr<u32>    tary_u32_AllocN(atf_amc::TaryU32& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.TaryU32.tary_u32.EmptyQ
inline bool          tary_u32_EmptyQ(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.TaryU32.tary_u32.Find
inline u32*          tary_u32_Find(atf_amc::TaryU32& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.TaryU32.tary_u32.Getary
inline algo::aryptr<u32> tary_u32_Getary(const atf_amc::TaryU32& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.TaryU32.tary_u32.Last
inline u32*          tary_u32_Last(atf_amc::TaryU32& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:atf_amc.TaryU32.tary_u32.Max
inline i32           tary_u32_Max(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.TaryU32.tary_u32.N
inline i32           tary_u32_N(const atf_amc::TaryU32& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:atf_amc.TaryU32.tary_u32.Remove
void                 tary_u32_Remove(atf_amc::TaryU32& parent, u32 i) __attribute__((nothrow));
// func:atf_amc.TaryU32.tary_u32.RemoveAll
inline void          tary_u32_RemoveAll(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.TaryU32.tary_u32.RemoveLast
void                 tary_u32_RemoveLast(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:atf_amc.TaryU32.tary_u32.Reserve
inline void          tary_u32_Reserve(atf_amc::TaryU32& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:atf_amc.TaryU32.tary_u32.AbsReserve
void                 tary_u32_AbsReserve(atf_amc::TaryU32& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:atf_amc.TaryU32.tary_u32.Setary
void                 tary_u32_Setary(atf_amc::TaryU32& parent, atf_amc::TaryU32 &rhs) __attribute__((nothrow));
// Copy specified array into tary_u32, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:atf_amc.TaryU32.tary_u32.Setary2
void                 tary_u32_Setary(atf_amc::TaryU32& parent, const algo::aryptr<u32> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.TaryU32.tary_u32.qFind
inline u32&          tary_u32_qFind(atf_amc::TaryU32& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:atf_amc.TaryU32.tary_u32.qLast
inline u32&          tary_u32_qLast(atf_amc::TaryU32& parent) __attribute__((nothrow));
// Return row id of specified element
// func:atf_amc.TaryU32.tary_u32.rowid_Get
inline u64           tary_u32_rowid_Get(atf_amc::TaryU32& parent, u32 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.TaryU32.tary_u32.AllocNVal
algo::aryptr<u32>    tary_u32_AllocNVal(atf_amc::TaryU32& parent, int n_elems, const u32& val) __attribute__((nothrow));
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
// func:atf_amc.TaryU32.tary_u32.ReadStrptrMaybe
bool                 tary_u32_ReadStrptrMaybe(atf_amc::TaryU32& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.TaryU32.tary_u32_curs.Next
inline void          TaryU32_tary_u32_curs_Next(TaryU32_tary_u32_curs &curs) __attribute__((nothrow));
// func:atf_amc.TaryU32.tary_u32_curs.Reset
inline void          TaryU32_tary_u32_curs_Reset(TaryU32_tary_u32_curs &curs, atf_amc::TaryU32 &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.TaryU32.tary_u32_curs.ValidQ
inline bool          TaryU32_tary_u32_curs_ValidQ(TaryU32_tary_u32_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.TaryU32.tary_u32_curs.Access
inline u32&          TaryU32_tary_u32_curs_Access(TaryU32_tary_u32_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TaryU32..Init
inline void          TaryU32_Init(atf_amc::TaryU32& parent);
// func:atf_amc.TaryU32..Uninit
void                 TaryU32_Uninit(atf_amc::TaryU32& parent) __attribute__((nothrow));

// --- atf_amc.TaryU8
struct TaryU8 { // atf_amc.TaryU8
    u8*   ary_elems;   // pointer to elements
    u32   ary_n;       // number of elements in array
    u32   ary_max;     // max. capacity of array before realloc
    // Copy from aryptr (operator=)
    // func:atf_amc.TaryU8.ary.AssignAryptr
    inline void          operator =(const algo::aryptr<u8> &rhs) __attribute__((nothrow));
    // func:atf_amc.TaryU8.ary.CtorAryptr
    explicit inline               TaryU8(const algo::aryptr<u8> &rhs) __attribute__((nothrow));
    // func:atf_amc.TaryU8..AssignOp
    atf_amc::TaryU8&     operator =(const atf_amc::TaryU8 &rhs) __attribute__((nothrow));
    // func:atf_amc.TaryU8..Ctor
    inline               TaryU8() __attribute__((nothrow));
    // func:atf_amc.TaryU8..Dtor
    inline               ~TaryU8() __attribute__((nothrow));
    // func:atf_amc.TaryU8..CopyCtor
    TaryU8(const atf_amc::TaryU8 &rhs) __attribute__((nothrow));
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:atf_amc.TaryU8.ary.Addary
algo::aryptr<u8>     ary_Addary(atf_amc::TaryU8& parent, algo::aryptr<u8> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:atf_amc.TaryU8.ary.Alloc
u8&                  ary_Alloc(atf_amc::TaryU8& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:atf_amc.TaryU8.ary.AllocAt
u8&                  ary_AllocAt(atf_amc::TaryU8& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.TaryU8.ary.AllocN
algo::aryptr<u8>     ary_AllocN(atf_amc::TaryU8& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:atf_amc.TaryU8.ary.EmptyQ
inline bool          ary_EmptyQ(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:atf_amc.TaryU8.ary.Find
inline u8*           ary_Find(atf_amc::TaryU8& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:atf_amc.TaryU8.ary.Getary
inline algo::aryptr<u8> ary_Getary(const atf_amc::TaryU8& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:atf_amc.TaryU8.ary.Last
inline u8*           ary_Last(atf_amc::TaryU8& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:atf_amc.TaryU8.ary.Max
inline i32           ary_Max(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Return number of items in the array
// func:atf_amc.TaryU8.ary.N
inline i32           ary_N(const atf_amc::TaryU8& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:atf_amc.TaryU8.ary.Remove
void                 ary_Remove(atf_amc::TaryU8& parent, u32 i) __attribute__((nothrow));
// func:atf_amc.TaryU8.ary.RemoveAll
inline void          ary_RemoveAll(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:atf_amc.TaryU8.ary.RemoveLast
void                 ary_RemoveLast(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:atf_amc.TaryU8.ary.Reserve
inline void          ary_Reserve(atf_amc::TaryU8& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:atf_amc.TaryU8.ary.AbsReserve
void                 ary_AbsReserve(atf_amc::TaryU8& parent, int n) __attribute__((nothrow));
// Convert ary to a string.
// Array is printed as a regular string.
// func:atf_amc.TaryU8.ary.Print
void                 ary_Print(atf_amc::TaryU8& parent, algo::cstring &rhs) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:atf_amc.TaryU8.ary.Setary
void                 ary_Setary(atf_amc::TaryU8& parent, atf_amc::TaryU8 &rhs) __attribute__((nothrow));
// Copy specified array into ary, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:atf_amc.TaryU8.ary.Setary2
void                 ary_Setary(atf_amc::TaryU8& parent, const algo::aryptr<u8> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:atf_amc.TaryU8.ary.qFind
inline u8&           ary_qFind(atf_amc::TaryU8& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:atf_amc.TaryU8.ary.qLast
inline u8&           ary_qLast(atf_amc::TaryU8& parent) __attribute__((nothrow));
// Return row id of specified element
// func:atf_amc.TaryU8.ary.rowid_Get
inline u64           ary_rowid_Get(atf_amc::TaryU8& parent, u8 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:atf_amc.TaryU8.ary.AllocNVal
algo::aryptr<u8>     ary_AllocNVal(atf_amc::TaryU8& parent, int n_elems, const u8& val) __attribute__((nothrow));
// The array is replaced with the input string. Function always succeeds.
// func:atf_amc.TaryU8.ary.ReadStrptrMaybe
bool                 ary_ReadStrptrMaybe(atf_amc::TaryU8& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
// func:atf_amc.TaryU8.ary_curs.Next
inline void          TaryU8_ary_curs_Next(TaryU8_ary_curs &curs) __attribute__((nothrow));
// func:atf_amc.TaryU8.ary_curs.Reset
inline void          TaryU8_ary_curs_Reset(TaryU8_ary_curs &curs, atf_amc::TaryU8 &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.TaryU8.ary_curs.ValidQ
inline bool          TaryU8_ary_curs_ValidQ(TaryU8_ary_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.TaryU8.ary_curs.Access
inline u8&           TaryU8_ary_curs_Access(TaryU8_ary_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TaryU8..Init
inline void          TaryU8_Init(atf_amc::TaryU8& parent);
// func:atf_amc.TaryU8..Uninit
void                 TaryU8_Uninit(atf_amc::TaryU8& parent) __attribute__((nothrow));

// --- atf_amc.TestRegx1
struct TestRegx1 { // atf_amc.TestRegx1: Test automatic reading of Regx
    algo_lib::Regx   val;   // Sql Regx of dev::Target
    // func:atf_amc.TestRegx1..Ctor
    inline               TestRegx1() __attribute__((nothrow));
};

// Print back to string
// func:atf_amc.TestRegx1.val.Print
void                 val_Print(atf_amc::TestRegx1& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
// func:atf_amc.TestRegx1.val.ReadStrptrMaybe
bool                 val_ReadStrptrMaybe(atf_amc::TestRegx1& parent, algo::strptr in) __attribute__((nothrow));

// func:atf_amc.TestRegx1..ReadFieldMaybe
bool                 TestRegx1_ReadFieldMaybe(atf_amc::TestRegx1& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TestRegx1 from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.TestRegx1..ReadStrptrMaybe
bool                 TestRegx1_ReadStrptrMaybe(atf_amc::TestRegx1 &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TestRegx1.String  printfmt:Tuple
// func:atf_amc.TestRegx1..Print
void                 TestRegx1_Print(atf_amc::TestRegx1& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TestType
struct TestType { // atf_amc.TestType
    // func:atf_amc.TestType..Ctor
    inline               TestType() __attribute__((nothrow));
};

// Read fields of atf_amc::TestType from an ascii string.
// func:atf_amc.TestType..ReadStrptrMaybe
bool                 TestType_ReadStrptrMaybe(atf_amc::TestType &parent, algo::strptr in_str) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TestType.String  printfmt:Raw
// func:atf_amc.TestType..Print
void                 TestType_Print(atf_amc::TestType& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Text
#pragma pack(push,1)
struct Text { // atf_amc.Text
    atf_amc::MsgType     type;     //   0x0412  Message type
    atf_amc::MsgLength   length;   //   ssizeof(parent) + (0)  Total message length, including this header
    // var-length field atf_amc.Text.text starts here. access it with text_Addr
    // func:atf_amc.Text..Ctor
    inline               Text() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.Text.msghdr.CopyOut
void                 parent_CopyOut(atf_amc::Text &row, atf_amc::MsgHeader &out) __attribute__((nothrow));
// Check if atf_amc::MsgHeader is an instance of Text by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Text.
// If not successful, quietly return NULL.
// func:atf_amc.Text.msghdr.Castdown
inline atf_amc::Text* Text_Castdown(atf_amc::MsgHeader &hdr);
// func:atf_amc.Text.msghdr.Castbase
inline atf_amc::MsgHeader& Castbase(atf_amc::Text& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.Text.text.Getary
algo::aryptr<char>   text_Getary(atf_amc::Text& parent) __attribute__((nothrow));
// func:atf_amc.Text.text.Addr
char*                text_Addr(atf_amc::Text& parent);
// Return number of elements in varlen field
// func:atf_amc.Text.text.N
inline u32           text_N(const atf_amc::Text& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:atf_amc.Text.text.ReadStrptrMaybe
bool                 text_ReadStrptrMaybe(atf_amc::Text& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert text to a string.
// Array is printed as a regular string.
// func:atf_amc.Text.text.Print
void                 text_Print(atf_amc::Text& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:atf_amc.Text.text_curs.Reset
inline void          Text_text_curs_Reset(Text_text_curs &curs, atf_amc::Text &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.Text.text_curs.ValidQ
inline bool          Text_text_curs_ValidQ(Text_text_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.Text.text_curs.Next
inline void          Text_text_curs_Next(Text_text_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.Text.text_curs.Access
inline char&         Text_text_curs_Access(Text_text_curs &curs) __attribute__((nothrow));
// func:atf_amc.Text..ReadFieldMaybe
bool                 Text_ReadFieldMaybe(atf_amc::Text& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::Text from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.Text..ReadStrptrMaybe
bool                 Text_ReadStrptrMaybe(atf_amc::Text &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.Text..GetMsgLength
inline i32           GetMsgLength(const atf_amc::Text& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.Text..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::Text& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Text..Init
inline void          Text_Init(atf_amc::Text& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.Text.String  printfmt:Tuple
// func:atf_amc.Text..Print
void                 Text_Print(atf_amc::Text& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeB
// access: atf_amc.FTypeB.msghdr (Base)
struct TypeB { // atf_amc.TypeB
    i32   typea;   //   0
    i32   j;       //   0
    // func:atf_amc.TypeB..EqOp
    inline bool          operator ==(const atf_amc::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeB..NeOp
    inline bool          operator !=(const atf_amc::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeB..LtOp
    inline bool          operator <(const atf_amc::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeB..GtOp
    inline bool          operator >(const atf_amc::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeB..LeOp
    inline bool          operator <=(const atf_amc::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeB..GeOp
    inline bool          operator >=(const atf_amc::TypeB &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeB..Ctor
    inline               TypeB() __attribute__((nothrow));
};

// func:atf_amc.TypeB..Hash
inline u32           TypeB_Hash(u32 prev, const atf_amc::TypeB& rhs) __attribute__((nothrow));
// func:atf_amc.TypeB..ReadFieldMaybe
bool                 TypeB_ReadFieldMaybe(atf_amc::TypeB& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeB from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.TypeB..ReadStrptrMaybe
bool                 TypeB_ReadStrptrMaybe(atf_amc::TypeB &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.TypeB..Lt
inline bool          TypeB_Lt(atf_amc::TypeB& lhs, atf_amc::TypeB& rhs) __attribute__((nothrow));
// func:atf_amc.TypeB..Cmp
inline i32           TypeB_Cmp(atf_amc::TypeB& lhs, atf_amc::TypeB& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeB..Init
inline void          TypeB_Init(atf_amc::TypeB& parent);
// func:atf_amc.TypeB..Eq
inline bool          TypeB_Eq(atf_amc::TypeB& lhs, atf_amc::TypeB& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.TypeB..Update
inline bool          TypeB_Update(atf_amc::TypeB &lhs, atf_amc::TypeB& rhs) __attribute__((nothrow));
// Create JSON representation of atf_amc::TypeB under PARENT node
// cfmt:atf_amc.TypeB.Json  printfmt:Auto
// func:atf_amc.TypeB..FmtJson
lib_json::FNode *    TypeB_FmtJson(atf_amc::TypeB& row, lib_json::FNode *parent) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeB.String  printfmt:Tuple
// func:atf_amc.TypeB..Print
void                 TypeB_Print(atf_amc::TypeB& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeBE16
struct TypeBE16 { // atf_amc.TypeBE16
    u16   value_be;   //   0
    // func:atf_amc.TypeBE16..Ctor
    inline               TypeBE16() __attribute__((nothrow));
};

// func:atf_amc.TypeBE16.value.Get
inline u16           value_Get(const atf_amc::TypeBE16& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.TypeBE16.value.Set
inline void          value_Set(atf_amc::TypeBE16& parent, u16 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.TypeBE16..Init
inline void          TypeBE16_Init(atf_amc::TypeBE16& parent);

// --- atf_amc.TypeBE32
struct TypeBE32 { // atf_amc.TypeBE32
    u32   value_be;   //   0
    // func:atf_amc.TypeBE32..Ctor
    inline               TypeBE32() __attribute__((nothrow));
};

// func:atf_amc.TypeBE32.value.Get
inline u32           value_Get(const atf_amc::TypeBE32& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.TypeBE32.value.Set
inline void          value_Set(atf_amc::TypeBE32& parent, u32 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.TypeBE32..Init
inline void          TypeBE32_Init(atf_amc::TypeBE32& parent);

// --- atf_amc.TypeBE32en
struct TypeBE32en { // atf_amc.TypeBE32en
    u32   value_be;   //   0
    // func:atf_amc.TypeBE32en.value.Cast
    inline               operator atf_amc_TypeBE32en_value_Enum() const __attribute__((nothrow));
    // func:atf_amc.TypeBE32en..Ctor
    inline               TypeBE32en() __attribute__((nothrow));
    // func:atf_amc.TypeBE32en..FieldwiseCtor
    explicit inline               TypeBE32en(u32 in_value) __attribute__((nothrow));
    // func:atf_amc.TypeBE32en..EnumCtor
    inline               TypeBE32en(atf_amc_TypeBE32en_value_Enum arg) __attribute__((nothrow));
};

// func:atf_amc.TypeBE32en.value.Get
inline u32           value_Get(const atf_amc::TypeBE32en& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.TypeBE32en.value.Set
inline void          value_Set(atf_amc::TypeBE32en& parent, u32 rhs) __attribute__((nothrow));
// Get value of field as enum type
// func:atf_amc.TypeBE32en.value.GetEnum
inline atf_amc_TypeBE32en_value_Enum value_GetEnum(const atf_amc::TypeBE32en& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.TypeBE32en.value.SetEnum
inline void          value_SetEnum(atf_amc::TypeBE32en& parent, atf_amc_TypeBE32en_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.TypeBE32en.value.ToCstr
const char*          value_ToCstr(const atf_amc::TypeBE32en& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.TypeBE32en.value.Print
void                 value_Print(const atf_amc::TypeBE32en& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.TypeBE32en.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::TypeBE32en& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.TypeBE32en.value.SetStrptr
void                 value_SetStrptr(atf_amc::TypeBE32en& parent, algo::strptr rhs, atf_amc_TypeBE32en_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.TypeBE32en.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::TypeBE32en& parent, algo::strptr rhs) __attribute__((nothrow));

// func:atf_amc.TypeBE32en..Hash
inline u32           TypeBE32en_Hash(u32 prev, const atf_amc::TypeBE32en& rhs) __attribute__((nothrow));
// func:atf_amc.TypeBE32en..ReadFieldMaybe
bool                 TypeBE32en_ReadFieldMaybe(atf_amc::TypeBE32en& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeBE32en from an ascii string.
// The format of the string is the format of the atf_amc::TypeBE32en's only field
// func:atf_amc.TypeBE32en..ReadStrptrMaybe
bool                 TypeBE32en_ReadStrptrMaybe(atf_amc::TypeBE32en &parent, algo::strptr in_str) __attribute__((nothrow));
// Read fields of atf_amc::TypeBE32en from attributes of ascii tuple TUPLE
// func:atf_amc.TypeBE32en..ReadTupleMaybe
bool                 TypeBE32en_ReadTupleMaybe(atf_amc::TypeBE32en &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeBE32en..Init
inline void          TypeBE32en_Init(atf_amc::TypeBE32en& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeBE32en.String  printfmt:Raw
// func:atf_amc.TypeBE32en..Print
void                 TypeBE32en_Print(atf_amc::TypeBE32en& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeBE64
struct TypeBE64 { // atf_amc.TypeBE64
    u64   value_be;   //   0
    // func:atf_amc.TypeBE64.value.Cast
    inline               operator u64() const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..EqOp
    inline bool          operator ==(const atf_amc::TypeBE64 &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..NeOp
    inline bool          operator !=(const atf_amc::TypeBE64 &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..LtOp
    inline bool          operator <(const atf_amc::TypeBE64 &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..GtOp
    inline bool          operator >(const atf_amc::TypeBE64 &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..LeOp
    inline bool          operator <=(const atf_amc::TypeBE64 &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..GeOp
    inline bool          operator >=(const atf_amc::TypeBE64 &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeBE64..Ctor
    inline               TypeBE64() __attribute__((nothrow));
    // func:atf_amc.TypeBE64..FieldwiseCtor
    explicit inline               TypeBE64(u64 in_value) __attribute__((nothrow));
};

// func:atf_amc.TypeBE64.value.Get
inline u64           value_Get(const atf_amc::TypeBE64& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.TypeBE64.value.Set
inline void          value_Set(atf_amc::TypeBE64& parent, u64 rhs) __attribute__((nothrow));

// func:atf_amc.TypeBE64..Hash
inline u32           TypeBE64_Hash(u32 prev, const atf_amc::TypeBE64& rhs) __attribute__((nothrow));
// func:atf_amc.TypeBE64..ReadFieldMaybe
bool                 TypeBE64_ReadFieldMaybe(atf_amc::TypeBE64& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeBE64 from an ascii string.
// The format of the string is the format of the atf_amc::TypeBE64's only field
// func:atf_amc.TypeBE64..ReadStrptrMaybe
bool                 TypeBE64_ReadStrptrMaybe(atf_amc::TypeBE64 &parent, algo::strptr in_str) __attribute__((nothrow));
// Read fields of atf_amc::TypeBE64 from attributes of ascii tuple TUPLE
// func:atf_amc.TypeBE64..ReadTupleMaybe
bool                 TypeBE64_ReadTupleMaybe(atf_amc::TypeBE64 &parent, algo::Tuple &tuple) __attribute__((nothrow));
// func:atf_amc.TypeBE64..Lt
inline bool          TypeBE64_Lt(atf_amc::TypeBE64& lhs, atf_amc::TypeBE64& rhs) __attribute__((nothrow));
// func:atf_amc.TypeBE64..Cmp
inline i32           TypeBE64_Cmp(atf_amc::TypeBE64& lhs, atf_amc::TypeBE64& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeBE64..Init
inline void          TypeBE64_Init(atf_amc::TypeBE64& parent);
// func:atf_amc.TypeBE64..Eq
inline bool          TypeBE64_Eq(atf_amc::TypeBE64& lhs, atf_amc::TypeBE64& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.TypeBE64..Update
inline bool          TypeBE64_Update(atf_amc::TypeBE64 &lhs, atf_amc::TypeBE64& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeBE64.String  printfmt:Raw
// func:atf_amc.TypeBE64..Print
void                 TypeBE64_Print(atf_amc::TypeBE64& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeBE64dflt
struct TypeBE64dflt { // atf_amc.TypeBE64dflt
    u64   value_be;   //   0xfedcba9876543210
    // func:atf_amc.TypeBE64dflt.value.Cast
    inline               operator u64() const __attribute__((nothrow));
    // func:atf_amc.TypeBE64dflt..Ctor
    inline               TypeBE64dflt() __attribute__((nothrow));
    // func:atf_amc.TypeBE64dflt..FieldwiseCtor
    explicit inline               TypeBE64dflt(u64 in_value) __attribute__((nothrow));
};

// func:atf_amc.TypeBE64dflt.value.Get
inline u64           value_Get(const atf_amc::TypeBE64dflt& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.TypeBE64dflt.value.Set
inline void          value_Set(atf_amc::TypeBE64dflt& parent, u64 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.TypeBE64dflt..Init
inline void          TypeBE64dflt_Init(atf_amc::TypeBE64dflt& parent);

// --- atf_amc.TypeBE64sf
struct TypeBE64sf { // atf_amc.TypeBE64sf
    u64   value_be;   //   0
    // func:atf_amc.TypeBE64sf..Ctor
    inline               TypeBE64sf() __attribute__((nothrow));
};

// func:atf_amc.TypeBE64sf.value.Get
inline u64           value_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.TypeBE64sf.value.Set
inline void          value_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 63.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bit63.Get
inline u64           bit63_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 63.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bit63.Set
inline void          bit63_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    2 bits starting at bit 61.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits62_61.Get
inline u64           bits62_61_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    2 bits starting at bit 61.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits62_61.Set
inline void          bits62_61_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    3 bits starting at bit 58.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits60_58.Get
inline u64           bits60_58_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    3 bits starting at bit 58.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits60_58.Set
inline void          bits60_58_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    5 bits starting at bit 53.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits57_53.Get
inline u64           bits57_53_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    5 bits starting at bit 53.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits57_53.Set
inline void          bits57_53_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    8 bits starting at bit 45.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits52_45.Get
inline u64           bits52_45_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    8 bits starting at bit 45.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits52_45.Set
inline void          bits52_45_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    13 bits starting at bit 32.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits44_32.Get
inline u64           bits44_32_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    13 bits starting at bit 32.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits44_32.Set
inline void          bits44_32_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    21 bits starting at bit 11.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits31_11.Get
inline u64           bits31_11_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    21 bits starting at bit 11.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits31_11.Set
inline void          bits31_11_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    11 bits starting at bit 0.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits10_0.Get
inline u64           bits10_0_Get(const atf_amc::TypeBE64sf& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    11 bits starting at bit 0.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
// func:atf_amc.TypeBE64sf.bits10_0.Set
inline void          bits10_0_Set(atf_amc::TypeBE64sf& parent, u64 rhs) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_amc.TypeBE64sf..Init
inline void          TypeBE64sf_Init(atf_amc::TypeBE64sf& parent);

// --- atf_amc.TypeC
// access: atf_amc.FTypeC.msghdr (Base)
// access: atf_amc.FTypeD.msghdr (Base)
struct TypeC { // atf_amc.TypeC
    i32   typec;   //   0
    // func:atf_amc.TypeC..EqOp
    inline bool          operator ==(const atf_amc::TypeC &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeC..NeOp
    inline bool          operator !=(const atf_amc::TypeC &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeC..LtOp
    inline bool          operator <(const atf_amc::TypeC &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeC..GtOp
    inline bool          operator >(const atf_amc::TypeC &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeC..LeOp
    inline bool          operator <=(const atf_amc::TypeC &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeC..GeOp
    inline bool          operator >=(const atf_amc::TypeC &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeC..Ctor
    inline               TypeC() __attribute__((nothrow));
};

// func:atf_amc.TypeC..Hash
inline u32           TypeC_Hash(u32 prev, const atf_amc::TypeC& rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeC from an ascii string.
// The format of the string is the format of the atf_amc::TypeC's only field
// func:atf_amc.TypeC..ReadStrptrMaybe
bool                 TypeC_ReadStrptrMaybe(atf_amc::TypeC &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.TypeC..Lt
inline bool          TypeC_Lt(atf_amc::TypeC& lhs, atf_amc::TypeC& rhs) __attribute__((nothrow));
// func:atf_amc.TypeC..Cmp
inline i32           TypeC_Cmp(atf_amc::TypeC& lhs, atf_amc::TypeC& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeC..Init
inline void          TypeC_Init(atf_amc::TypeC& parent);
// func:atf_amc.TypeC..Eq
inline bool          TypeC_Eq(atf_amc::TypeC& lhs, atf_amc::TypeC& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.TypeC..Update
inline bool          TypeC_Update(atf_amc::TypeC &lhs, atf_amc::TypeC& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeC.String  printfmt:Raw
// func:atf_amc.TypeC..Print
void                 TypeC_Print(atf_amc::TypeC& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeH
// create: atf_amc.VarlenH.typeh (Varlen)
struct TypeH { // atf_amc.TypeH
    i32   typeh;   //   0
    // func:atf_amc.TypeH..EqOp
    inline bool          operator ==(const atf_amc::TypeH &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeH..NeOp
    inline bool          operator !=(const atf_amc::TypeH &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeH..LtOp
    inline bool          operator <(const atf_amc::TypeH &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeH..GtOp
    inline bool          operator >(const atf_amc::TypeH &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeH..LeOp
    inline bool          operator <=(const atf_amc::TypeH &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeH..GeOp
    inline bool          operator >=(const atf_amc::TypeH &rhs) const __attribute__((nothrow));
    // func:atf_amc.TypeH..Ctor
    inline               TypeH() __attribute__((nothrow));
};

// func:atf_amc.TypeH..Hash
inline u32           TypeH_Hash(u32 prev, const atf_amc::TypeH& rhs) __attribute__((nothrow));
// Read fields of atf_amc::TypeH from an ascii string.
// The format of the string is the format of the atf_amc::TypeH's only field
// func:atf_amc.TypeH..ReadStrptrMaybe
bool                 TypeH_ReadStrptrMaybe(atf_amc::TypeH &parent, algo::strptr in_str) __attribute__((nothrow));
// func:atf_amc.TypeH..Lt
inline bool          TypeH_Lt(atf_amc::TypeH& lhs, atf_amc::TypeH& rhs) __attribute__((nothrow));
// func:atf_amc.TypeH..Cmp
inline i32           TypeH_Cmp(atf_amc::TypeH& lhs, atf_amc::TypeH& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeH..Init
inline void          TypeH_Init(atf_amc::TypeH& typeh);
// func:atf_amc.TypeH..Eq
inline bool          TypeH_Eq(atf_amc::TypeH& lhs, atf_amc::TypeH& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:atf_amc.TypeH..Update
inline bool          TypeH_Update(atf_amc::TypeH &lhs, atf_amc::TypeH& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeH.String  printfmt:Raw
// func:atf_amc.TypeH..Print
void                 TypeH_Print(atf_amc::TypeH& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeS
// access: atf_amc.FTypeS.msghdr (Base)
struct TypeS { // atf_amc.TypeS
    i32             types;     //   0
    algo::Comment   comment;   //
    // func:atf_amc.TypeS..Ctor
    inline               TypeS() __attribute__((nothrow));
};

// func:atf_amc.TypeS..ReadFieldMaybe
bool                 TypeS_ReadFieldMaybe(atf_amc::TypeS& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeS from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.TypeS..ReadStrptrMaybe
bool                 TypeS_ReadStrptrMaybe(atf_amc::TypeS &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeS..Init
inline void          TypeS_Init(atf_amc::TypeS& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeS.String  printfmt:Tuple
// func:atf_amc.TypeS..Print
void                 TypeS_Print(atf_amc::TypeS& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeT
// access: atf_amc.FTypeT.msghdr (Base)
struct TypeT { // atf_amc.TypeT: Refers to TypeS
    i32   types;   //   0
    i32   j;       //   0
    // func:atf_amc.TypeT..Ctor
    inline               TypeT() __attribute__((nothrow));
};

// func:atf_amc.TypeT..Hash
inline u32           TypeT_Hash(u32 prev, const atf_amc::TypeT& rhs) __attribute__((nothrow));
// func:atf_amc.TypeT..ReadFieldMaybe
bool                 TypeT_ReadFieldMaybe(atf_amc::TypeT& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeT from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.TypeT..ReadStrptrMaybe
bool                 TypeT_ReadStrptrMaybe(atf_amc::TypeT &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeT..Init
inline void          TypeT_Init(atf_amc::TypeT& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeT.String  printfmt:Tuple
// func:atf_amc.TypeT..Print
void                 TypeT_Print(atf_amc::TypeT& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.TypeTVal
struct TypeTVal { // atf_amc.TypeTVal: Refers to TypeS as Val
    atf_amc::TypeS   types;   //
    i32              j;       //   0
    // func:atf_amc.TypeTVal..Ctor
    inline               TypeTVal() __attribute__((nothrow));
};

// func:atf_amc.TypeTVal..ReadFieldMaybe
bool                 TypeTVal_ReadFieldMaybe(atf_amc::TypeTVal& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::TypeTVal from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.TypeTVal..ReadStrptrMaybe
bool                 TypeTVal_ReadStrptrMaybe(atf_amc::TypeTVal &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.TypeTVal..Init
inline void          TypeTVal_Init(atf_amc::TypeTVal& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.TypeTVal.String  printfmt:Tuple
// func:atf_amc.TypeTVal..Print
void                 TypeTVal_Print(atf_amc::TypeTVal& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.Typefconst
struct Typefconst { // atf_amc.Typefconst
    u32   value;   //   0
    // func:atf_amc.Typefconst.value.Cast
    inline               operator atf_amc_Typefconst_value_Enum() const __attribute__((nothrow));
    // func:atf_amc.Typefconst..Ctor
    inline               Typefconst() __attribute__((nothrow));
    // func:atf_amc.Typefconst..FieldwiseCtor
    explicit inline               Typefconst(u32 in_value) __attribute__((nothrow));
    // func:atf_amc.Typefconst..EnumCtor
    inline               Typefconst(atf_amc_Typefconst_value_Enum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:atf_amc.Typefconst.value.GetEnum
inline atf_amc_Typefconst_value_Enum value_GetEnum(const atf_amc::Typefconst& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_amc.Typefconst.value.SetEnum
inline void          value_SetEnum(atf_amc::Typefconst& parent, atf_amc_Typefconst_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_amc.Typefconst.value.ToCstr
const char*          value_ToCstr(const atf_amc::Typefconst& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_amc.Typefconst.value.Print
void                 value_Print(const atf_amc::Typefconst& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_amc.Typefconst.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_amc::Typefconst& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_amc.Typefconst.value.SetStrptr
void                 value_SetStrptr(atf_amc::Typefconst& parent, algo::strptr rhs, atf_amc_Typefconst_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_amc.Typefconst.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_amc::Typefconst& parent, algo::strptr rhs) __attribute__((nothrow));

// func:atf_amc.Typefconst..ReadFieldMaybe
bool                 Typefconst_ReadFieldMaybe(atf_amc::Typefconst& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_amc::Typefconst from an ascii string.
// The format of the string is the format of the atf_amc::Typefconst's only field
// func:atf_amc.Typefconst..ReadStrptrMaybe
bool                 Typefconst_ReadStrptrMaybe(atf_amc::Typefconst &parent, algo::strptr in_str) __attribute__((nothrow));
// Read fields of atf_amc::Typefconst from attributes of ascii tuple TUPLE
// func:atf_amc.Typefconst..ReadTupleMaybe
bool                 Typefconst_ReadTupleMaybe(atf_amc::Typefconst &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.Typefconst..Init
inline void          Typefconst_Init(atf_amc::Typefconst& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.Typefconst.String  printfmt:Raw
// func:atf_amc.Typefconst..Print
void                 Typefconst_Print(atf_amc::Typefconst& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.VarlenAlloc
// create: atf_amc.FDb.varlenalloc (Lpool)
// access: atf_amc.VarlenAlloc_curs.msg (Ptr)
#pragma pack(push,1)
struct VarlenAlloc { // atf_amc.VarlenAlloc: An optional instance of atf_unit.A
    u32   length;   //   0
    // var-length field atf_amc.VarlenAlloc.elem starts here. access it with elem_Addr
private:
    // func:atf_amc.VarlenAlloc..Ctor
    inline               VarlenAlloc() __attribute__((nothrow));
    friend atf_amc::VarlenAlloc& varlenalloc_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend inline atf_amc::VarlenAlloc* varlenalloc_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc& varlenalloc_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenAlloc* varlenalloc_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend inline atf_amc::VarlenAlloc* varlenalloc_AllocVarlenMaybe(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__, nothrow));
    friend inline atf_amc::VarlenAlloc& varlenalloc_AllocVarlen(algo::aryptr<i32> elem) __attribute__((__warn_unused_result__));
    friend void                 varlenalloc_Delete(atf_amc::VarlenAlloc &row) __attribute__((nothrow));
};
#pragma pack(pop)

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.VarlenAlloc.elem.Getary
algo::aryptr<i32>    elem_Getary(atf_amc::VarlenAlloc& varlenalloc) __attribute__((nothrow));
// func:atf_amc.VarlenAlloc.elem.Addr
i32*                 elem_Addr(atf_amc::VarlenAlloc& varlenalloc);
// Return number of elements in varlen field
// func:atf_amc.VarlenAlloc.elem.N
inline u32           elem_N(const atf_amc::VarlenAlloc& varlenalloc) __attribute__((__warn_unused_result__, nothrow, pure));

// func:atf_amc.VarlenAlloc.elem_curs.Reset
inline void          varlenalloc_elem_curs_Reset(varlenalloc_elem_curs &curs, atf_amc::VarlenAlloc &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.VarlenAlloc.elem_curs.ValidQ
inline bool          varlenalloc_elem_curs_ValidQ(varlenalloc_elem_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.VarlenAlloc.elem_curs.Next
inline void          varlenalloc_elem_curs_Next(varlenalloc_elem_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.VarlenAlloc.elem_curs.Access
inline i32&          varlenalloc_elem_curs_Access(varlenalloc_elem_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.VarlenAlloc..GetMsgLength
inline i32           GetMsgLength(const atf_amc::VarlenAlloc& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.VarlenAlloc..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::VarlenAlloc& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenAlloc..Init
inline void          VarlenAlloc_Init(atf_amc::VarlenAlloc& varlenalloc);

// --- atf_amc.VarlenAlloc_curs
#pragma pack(push,1)
struct VarlenAlloc_curs { // atf_amc.VarlenAlloc_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::VarlenAlloc *ChildType;
    atf_amc::VarlenAlloc*   msg;      // Pointer to current message. optional pointer
    u8*                     bytes;    // Beginning of region. optional pointer
    i32                     limit;    //   0  # Of bytes in the region
    i32                     msglen;   //   0  Length of current message (if any)
    // func:atf_amc.VarlenAlloc_curs..Ctor
    inline               VarlenAlloc_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.VarlenAlloc_curs..ValidQ
inline bool          VarlenAlloc_curs_ValidQ(atf_amc::VarlenAlloc_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenAlloc_curs..Reset
inline void          VarlenAlloc_curs_Reset(atf_amc::VarlenAlloc_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.VarlenAlloc_curs..Access
inline atf_amc::VarlenAlloc*& VarlenAlloc_curs_Access(atf_amc::VarlenAlloc_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenAlloc_curs..Next
inline void          VarlenAlloc_curs_Next(atf_amc::VarlenAlloc_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenAlloc_curs..Init
inline void          VarlenAlloc_curs_Init(atf_amc::VarlenAlloc_curs& parent);

// --- atf_amc.VarlenExtern
// create: atf_amc.FDb.varlen_extern (Lpool)
// access: atf_amc.VarlenExtern_curs.msg (Ptr)
#pragma pack(push,1)
struct VarlenExtern { // atf_amc.VarlenExtern: A varlen array at the end of a struct, but lenfld is external
    u32   n_elems;   //   0
    // var-length field atf_amc.VarlenExtern.varlen starts here. access it with varlen_Addr
private:
    // func:atf_amc.VarlenExtern..Ctor
    inline               VarlenExtern() __attribute__((nothrow));
    friend atf_amc::VarlenExtern& varlen_extern_Alloc(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend inline atf_amc::VarlenExtern* varlen_extern_AllocMaybe(i32 n_varfld) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern& varlen_extern_AllocExtra(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend atf_amc::VarlenExtern* varlen_extern_AllocExtraMaybe(void *extra, i32 nbyte_extra) __attribute__((__warn_unused_result__, nothrow));
    friend inline atf_amc::VarlenExtern* varlen_extern_AllocVarlenMaybe(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__, nothrow));
    friend inline atf_amc::VarlenExtern& varlen_extern_AllocVarlen(algo::aryptr<u32> varlen) __attribute__((__warn_unused_result__));
    friend void                 varlen_extern_Delete(atf_amc::VarlenExtern &row) __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.VarlenExtern.length.Get
// this function is 'extrn' and implemented by user
u32                  length_Get(atf_amc::VarlenExtern& varlen_extern) __attribute__((__warn_unused_result__, nothrow));
// func:atf_amc.VarlenExtern.length.Set
// this function is 'extrn' and implemented by user
void                 length_Set(atf_amc::VarlenExtern& varlen_extern, u32 rhs) __attribute__((nothrow));

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.VarlenExtern.varlen.Getary
algo::aryptr<u32>    varlen_Getary(atf_amc::VarlenExtern& varlen_extern) __attribute__((nothrow));
// func:atf_amc.VarlenExtern.varlen.Addr
u32*                 varlen_Addr(atf_amc::VarlenExtern& varlen_extern);
// Return number of elements in varlen field
// func:atf_amc.VarlenExtern.varlen.N
inline u32           varlen_N(const atf_amc::VarlenExtern& varlen_extern) __attribute__((__warn_unused_result__, nothrow, pure));

// func:atf_amc.VarlenExtern.varlen_curs.Reset
inline void          varlen_extern_varlen_curs_Reset(varlen_extern_varlen_curs &curs, atf_amc::VarlenExtern &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.VarlenExtern.varlen_curs.ValidQ
inline bool          varlen_extern_varlen_curs_ValidQ(varlen_extern_varlen_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.VarlenExtern.varlen_curs.Next
inline void          varlen_extern_varlen_curs_Next(varlen_extern_varlen_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.VarlenExtern.varlen_curs.Access
inline u32&          varlen_extern_varlen_curs_Access(varlen_extern_varlen_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.VarlenExtern..GetMsgLength
inline i32           GetMsgLength(const atf_amc::VarlenExtern& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.VarlenExtern..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::VarlenExtern& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenExtern..Init
inline void          VarlenExtern_Init(atf_amc::VarlenExtern& varlen_extern);

// --- atf_amc.VarlenExtern_curs
#pragma pack(push,1)
struct VarlenExtern_curs { // atf_amc.VarlenExtern_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::VarlenExtern *ChildType;
    atf_amc::VarlenExtern*   msg;      // Pointer to current message. optional pointer
    u8*                      bytes;    // Beginning of region. optional pointer
    i32                      limit;    //   0  # Of bytes in the region
    i32                      msglen;   //   0  Length of current message (if any)
    // func:atf_amc.VarlenExtern_curs..Ctor
    inline               VarlenExtern_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.VarlenExtern_curs..ValidQ
inline bool          VarlenExtern_curs_ValidQ(atf_amc::VarlenExtern_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenExtern_curs..Reset
inline void          VarlenExtern_curs_Reset(atf_amc::VarlenExtern_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.VarlenExtern_curs..Access
inline atf_amc::VarlenExtern*& VarlenExtern_curs_Access(atf_amc::VarlenExtern_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenExtern_curs..Next
inline void          VarlenExtern_curs_Next(atf_amc::VarlenExtern_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenExtern_curs..Init
inline void          VarlenExtern_curs_Init(atf_amc::VarlenExtern_curs& parent);

// --- atf_amc.VarlenH
// access: atf_amc.VarlenH_curs.msg (Ptr)
struct VarlenH { // atf_amc.VarlenH
    u32   length;   //   0
    // var-length field atf_amc.VarlenH.typeh starts here. access it with typeh_Addr
    // func:atf_amc.VarlenH..Ctor
    inline               VarlenH() __attribute__((nothrow));
};

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.VarlenH.typeh.Getary
algo::aryptr<atf_amc::TypeH> typeh_Getary(atf_amc::VarlenH& parent) __attribute__((nothrow));
// func:atf_amc.VarlenH.typeh.Addr
atf_amc::TypeH*      typeh_Addr(atf_amc::VarlenH& parent);
// Return number of elements in varlen field
// func:atf_amc.VarlenH.typeh.N
inline u32           typeh_N(const atf_amc::VarlenH& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Verify whether array is sorted
// func:atf_amc.VarlenH.typeh.SortedQ
bool                 typeh_SortedQ(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Insertion sort
// func:atf_amc.VarlenH.typeh.InsertionSort
void                 typeh_InsertionSort(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Heap sort
// func:atf_amc.VarlenH.typeh.HeapSort
void                 typeh_HeapSort(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Quick sort
// func:atf_amc.VarlenH.typeh.QuickSort
void                 typeh_QuickSort(atf_amc::VarlenH& parent) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.VarlenH.typeh.XrefMaybe
bool                 typeh_XrefMaybe(atf_amc::TypeH &row);

// func:atf_amc.VarlenH.typeh_curs.Reset
inline void          VarlenH_typeh_curs_Reset(VarlenH_typeh_curs &curs, atf_amc::VarlenH &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.VarlenH.typeh_curs.ValidQ
inline bool          VarlenH_typeh_curs_ValidQ(VarlenH_typeh_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.VarlenH.typeh_curs.Next
inline void          VarlenH_typeh_curs_Next(VarlenH_typeh_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.VarlenH.typeh_curs.Access
inline atf_amc::TypeH& VarlenH_typeh_curs_Access(VarlenH_typeh_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.VarlenH..GetMsgLength
inline i32           GetMsgLength(const atf_amc::VarlenH& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.VarlenH..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::VarlenH& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenH..Init
inline void          VarlenH_Init(atf_amc::VarlenH& parent);

// --- atf_amc.VarlenH_curs
#pragma pack(push,1)
struct VarlenH_curs { // atf_amc.VarlenH_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::VarlenH *ChildType;
    atf_amc::VarlenH*   msg;      // Pointer to current message. optional pointer
    u8*                 bytes;    // Beginning of region. optional pointer
    i32                 limit;    //   0  # Of bytes in the region
    i32                 msglen;   //   0  Length of current message (if any)
    // func:atf_amc.VarlenH_curs..Ctor
    inline               VarlenH_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.VarlenH_curs..ValidQ
inline bool          VarlenH_curs_ValidQ(atf_amc::VarlenH_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenH_curs..Reset
inline void          VarlenH_curs_Reset(atf_amc::VarlenH_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.VarlenH_curs..Access
inline atf_amc::VarlenH*& VarlenH_curs_Access(atf_amc::VarlenH_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenH_curs..Next
inline void          VarlenH_curs_Next(atf_amc::VarlenH_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenH_curs..Init
inline void          VarlenH_curs_Init(atf_amc::VarlenH_curs& parent);

// --- atf_amc.VarlenK
// create: atf_amc.VarlenMsg.k (Varlen)
// access: atf_amc.VarlenK_curs.msg (Ptr)
#pragma pack(push,1)
struct VarlenK { // atf_amc.VarlenK: An optional instance of atf_unit.A
    u32   length;   //   0
    // var-length field atf_amc.VarlenK.i starts here. access it with i_Addr
    // func:atf_amc.VarlenK..Ctor
    inline               VarlenK() __attribute__((nothrow));
};
#pragma pack(pop)

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.VarlenK.i.Getary
algo::aryptr<u32>    i_Getary(atf_amc::VarlenK& k) __attribute__((nothrow));
// func:atf_amc.VarlenK.i.Addr
u32*                 i_Addr(atf_amc::VarlenK& k);
// Return number of elements in varlen field
// func:atf_amc.VarlenK.i.N
inline u32           i_N(const atf_amc::VarlenK& k) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:atf_amc.VarlenK.i.ReadStrptrMaybe
bool                 i_ReadStrptrMaybe(atf_amc::VarlenK& k, algo::strptr in_str) __attribute__((nothrow));

// func:atf_amc.VarlenK.i_curs.Reset
inline void          k_i_curs_Reset(k_i_curs &curs, atf_amc::VarlenK &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.VarlenK.i_curs.ValidQ
inline bool          k_i_curs_ValidQ(k_i_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.VarlenK.i_curs.Next
inline void          k_i_curs_Next(k_i_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.VarlenK.i_curs.Access
inline u32&          k_i_curs_Access(k_i_curs &curs) __attribute__((nothrow));
// func:atf_amc.VarlenK..ReadFieldMaybe
bool                 VarlenK_ReadFieldMaybe(atf_amc::VarlenK& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::VarlenK from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.VarlenK..ReadStrptrMaybe
bool                 VarlenK_ReadStrptrMaybe(atf_amc::VarlenK &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.VarlenK..GetMsgLength
inline i32           GetMsgLength(const atf_amc::VarlenK& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.VarlenK..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::VarlenK& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenK..Init
inline void          VarlenK_Init(atf_amc::VarlenK& k);
// print string representation of ROW to string STR
// cfmt:atf_amc.VarlenK.String  printfmt:Tuple
// func:atf_amc.VarlenK..Print
void                 VarlenK_Print(atf_amc::VarlenK& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_amc.VarlenK_curs
#pragma pack(push,1)
struct VarlenK_curs { // atf_amc.VarlenK_curs: Cursor for scanning messages in a memptr
    typedef atf_amc::VarlenK *ChildType;
    atf_amc::VarlenK*   msg;      // Pointer to current message. optional pointer
    u8*                 bytes;    // Beginning of region. optional pointer
    i32                 limit;    //   0  # Of bytes in the region
    i32                 msglen;   //   0  Length of current message (if any)
    // func:atf_amc.VarlenK_curs..Ctor
    inline               VarlenK_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:atf_amc.VarlenK_curs..ValidQ
inline bool          VarlenK_curs_ValidQ(atf_amc::VarlenK_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenK_curs..Reset
inline void          VarlenK_curs_Reset(atf_amc::VarlenK_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:atf_amc.VarlenK_curs..Access
inline atf_amc::VarlenK*& VarlenK_curs_Access(atf_amc::VarlenK_curs& curs) __attribute__((nothrow));
// func:atf_amc.VarlenK_curs..Next
inline void          VarlenK_curs_Next(atf_amc::VarlenK_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenK_curs..Init
inline void          VarlenK_curs_Init(atf_amc::VarlenK_curs& parent);

// --- atf_amc.VarlenMsg
#pragma pack(push,1)
struct VarlenMsg { // atf_amc.VarlenMsg
    atf_amc::MsgType     type;     //   0x1000  Message type
    atf_amc::MsgLength   length;   //   ssizeof(parent) + (0)  Total message length, including this header
    // var-length field atf_amc.VarlenMsg.k starts here. access it with k_Addr
    // func:atf_amc.VarlenMsg..Ctor
    inline               VarlenMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:atf_amc.VarlenMsg.base.CopyOut
void                 parent_CopyOut(atf_amc::VarlenMsg &row, atf_amc::MsgHeader &out) __attribute__((nothrow));
// Check if atf_amc::MsgHeader is an instance of VarlenMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of VarlenMsg.
// If not successful, quietly return NULL.
// func:atf_amc.VarlenMsg.base.Castdown
inline atf_amc::VarlenMsg* VarlenMsg_Castdown(atf_amc::MsgHeader &hdr);
// func:atf_amc.VarlenMsg.base.Castbase
inline atf_amc::MsgHeader& Castbase(atf_amc::VarlenMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:atf_amc.VarlenMsg.k.Getary
algo::aryptr<u8>     k_Getary(atf_amc::VarlenMsg& parent) __attribute__((nothrow));
// func:atf_amc.VarlenMsg.k.Addr
u8*                  k_Addr(atf_amc::VarlenMsg& parent);
// Return number of elements in varlen field
// func:atf_amc.VarlenMsg.k.N
inline u32           k_N(const atf_amc::VarlenMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:atf_amc.VarlenMsg.k.ReadStrptrMaybe
bool                 k_ReadStrptrMaybe(atf_amc::VarlenMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_amc.VarlenMsg.k.XrefMaybe
bool                 k_XrefMaybe(atf_amc::VarlenK &row);

// func:atf_amc.VarlenMsg.k_curs.Reset
inline void          VarlenMsg_k_curs_Reset(VarlenMsg_k_curs &curs, atf_amc::VarlenMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_amc.VarlenMsg.k_curs.ValidQ
inline bool          VarlenMsg_k_curs_ValidQ(VarlenMsg_k_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_amc.VarlenMsg.k_curs.Next
inline void          VarlenMsg_k_curs_Next(VarlenMsg_k_curs &curs) __attribute__((nothrow));
// item access
// func:atf_amc.VarlenMsg.k_curs.Access
inline atf_amc::VarlenK& VarlenMsg_k_curs_Access(VarlenMsg_k_curs &curs) __attribute__((nothrow));
// func:atf_amc.VarlenMsg..ReadFieldMaybe
bool                 VarlenMsg_ReadFieldMaybe(atf_amc::VarlenMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of atf_amc::VarlenMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:atf_amc.VarlenMsg..ReadStrptrMaybe
bool                 VarlenMsg_ReadStrptrMaybe(atf_amc::VarlenMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:atf_amc.VarlenMsg..GetMsgLength
inline i32           GetMsgLength(const atf_amc::VarlenMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:atf_amc.VarlenMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const atf_amc::VarlenMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_amc.VarlenMsg..Init
inline void          VarlenMsg_Init(atf_amc::VarlenMsg& parent);
// print string representation of ROW to string STR
// cfmt:atf_amc.VarlenMsg.String  printfmt:Tuple
// func:atf_amc.VarlenMsg..Print
void                 VarlenMsg_Print(atf_amc::VarlenMsg& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace atf_amc { // gen:ns_curstext

struct Bitset_fld1_bitcurs {// cursor
    typedef int& ChildType;
    u16* elems;
    int n_elems;
    int bit;
    Bitset_fld1_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct Bitset_fld1_curs {// cursor
    typedef u16 ChildType;
    int index;
    atf_amc::Bitset *parent;
    Bitset_fld1_curs() { parent=NULL; index=0; }
};


struct Bitset_fld8_bitcurs {// cursor
    typedef int& ChildType;
    u8* elems;
    int n_elems;
    int bit;
    Bitset_fld8_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct Bitset_fld64_bitcurs {// cursor
    typedef int& ChildType;
    u64* elems;
    int n_elems;
    int bit;
    Bitset_fld64_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct DispFilter_pmask_bitcurs {// cursor
    typedef int& ChildType;
    u64* elems;
    int n_elems;
    int bit;
    DispFilter_pmask_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct DispFilter_pmask_curs {// cursor
    typedef u64 ChildType;
    int index;
    atf_amc::DispFilter *parent;
    DispFilter_pmask_curs() { parent=NULL; index=0; }
};


struct cascdel_c_child_ptrary_curs {// fcurs:atf_amc.FCascdel.c_child_ptrary/curs
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel** elems;
    u32 n_elems;
    u32 index;
    cascdel_c_child_ptrary_curs() { elems=NULL; n_elems=0; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct cascdel_bh_child_bheap_curs {
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel      *parent;        // parent
    atf_amc::FCascdel*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    cascdel_bh_child_bheap_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~cascdel_bh_child_bheap_curs();
};


struct cascdel_zd_childlist_curs {// fcurs:atf_amc.FCascdel.zd_childlist/curs
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel* row;
    cascdel_zd_childlist_curs() {
        row = NULL;
    }
};


struct cascdel_tr_child_atree_curs {// cursor
    typedef atf_amc::FCascdel ChildType;
    atf_amc::FCascdel* row;
    cascdel_tr_child_atree_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_typec_curs {
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FDb      *parent;        // parent
    atf_amc::FTypeC*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_typec_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_typec_curs();
};


struct _db_zdl_h_typec_curs {// fcurs:atf_amc.FDb.zdl_h_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zdl_h_typec_curs() {
        row = NULL;
    }
};


struct _db_zd_t_typec_curs {// fcurs:atf_amc.FDb.zd_t_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zd_t_typec_curs() {
        row = NULL;
    }
};


struct _db_zd_typed_curs {// fcurs:atf_amc.FDb.zd_typed/curs
    typedef atf_amc::FTypeD ChildType;
    atf_amc::FTypeD* row;
    _db_zd_typed_curs() {
        row = NULL;
    }
};


struct _db_zd_typed_delcurs {// fcurs:atf_amc.FDb.zd_typed/delcurs
    typedef atf_amc::FTypeD ChildType;
    atf_amc::FTypeD* row;
    atf_amc::FTypeD *next;
    _db_zd_typed_delcurs() {
        row = NULL;
        next = NULL;
    }
};


struct _db_zs_t_typed_curs {// fcurs:atf_amc.FDb.zs_t_typed/curs
    typedef atf_amc::FTypeD ChildType;
    atf_amc::FTypeD* row;
    _db_zs_t_typed_curs() {
        row = NULL;
    }
};


struct _db_zs_t_typed_delcurs {// fcurs:atf_amc.FDb.zs_t_typed/delcurs
    typedef atf_amc::FTypeD ChildType;
    atf_amc::FTypeD* row;
    atf_amc::FTypeD *next;
    _db_zs_t_typed_delcurs() {
        row = NULL;
        next = NULL;
    }
};


struct _db_cd_typed_curs {// fcurs:atf_amc.FDb.cd_typed/curs
    typedef atf_amc::FTypeD ChildType;
    atf_amc::FTypeD* row;
    atf_amc::FTypeD** head; // address of head element
    _db_cd_typed_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_typed_delcurs {// fcurs:atf_amc.FDb.cd_typed/delcurs
    typedef atf_amc::FTypeD ChildType;
    atf_amc::FTypeD* row;
    atf_amc::FTypeD** head; // address of head element
    atf_amc::FTypeD *next;
    _db_cd_typed_delcurs() {
        row = NULL;
        head = NULL;
        next = NULL;
    }
};


struct _db_zsl_h_typec_curs {// fcurs:atf_amc.FDb.zsl_h_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zsl_h_typec_curs() {
        row = NULL;
    }
};


struct _db_zs_t_typec_curs {// fcurs:atf_amc.FDb.zs_t_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zs_t_typec_curs() {
        row = NULL;
    }
};


struct _db_zdl_hnt_typec_curs {// fcurs:atf_amc.FDb.zdl_hnt_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    _db_zdl_hnt_typec_curs() {
        row = NULL;
    }
};


struct _db_cdl_h_typec_curs {// fcurs:atf_amc.FDb.cdl_h_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC** head; // address of head element
    _db_cdl_h_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_t_typec_curs {// fcurs:atf_amc.FDb.cd_t_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC** head; // address of head element
    _db_cd_t_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_csl_h_typec_curs {// fcurs:atf_amc.FDb.csl_h_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC** head; // address of head element
    _db_csl_h_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cs_t_typec_curs {// fcurs:atf_amc.FDb.cs_t_typec/curs
    typedef atf_amc::FTypeC ChildType;
    atf_amc::FTypeC* row;
    atf_amc::FTypeC** head; // address of head element
    _db_cs_t_typec_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_typea_curs {// cursor
    typedef atf_amc::FTypeA ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_typea_curs(){ parent=NULL; index=0; }
};


struct _db_types_curs {// cursor
    typedef atf_amc::FTypeS ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_types_curs(){ parent=NULL; index=0; }
};


struct _db_typet_curs {// cursor
    typedef atf_amc::FTypeT ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_typet_curs(){ parent=NULL; index=0; }
};


struct _db_cstring_curs {// cursor
    typedef atf_amc::FCstring ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_cstring_curs(){ parent=NULL; index=0; }
};


struct _db_cd_in_msg_curs {// fcurs:atf_amc.FDb.cd_in_msg/curs
    typedef atf_amc::Msgbuf ChildType;
    atf_amc::Msgbuf* row;
    atf_amc::Msgbuf** head; // address of head element
    _db_cd_in_msg_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_amctest_curs {// cursor
    typedef atf_amc::FAmctest ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_amctest_curs(){ parent=NULL; index=0; }
};


struct _db_c_typek_curs {// fcurs:atf_amc.FDb.c_typek/curs
    typedef atf_amc::FTypeK ChildType;
    atf_amc::FTypeK** elems;
    u32 n_elems;
    u32 index;
    _db_c_typek_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_c_typek_oncecurs {// fcurs:atf_amc.FDb.c_typek/oncecurs
    typedef atf_amc::FTypeK ChildType;
    atf_amc::FTypeK** elems;
    u32 n_elems;
    u32 index;
    _db_c_typek_oncecurs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_avl_curs {// cursor
    typedef atf_amc::FAvl ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_avl_curs(){ parent=NULL; index=0; }
};


struct _db_tr_avl_curs {// cursor
    typedef atf_amc::FAvl ChildType;
    atf_amc::FAvl* row;
    _db_tr_avl_curs() {
        row = NULL;
    }
};


struct _db_listtype_curs {// cursor
    typedef atf_amc::FListtype ChildType;
    int index;
    atf_amc::FDb *parent;
    _db_listtype_curs() { parent=NULL; index=0; }
};


struct _db_thash_elem_curs {// cursor
    typedef atf_amc::FThashElem ChildType;
    atf_amc::FDb *parent;
    i64 index;
    _db_thash_elem_curs(){ parent=NULL; index=0; }
};


struct FPerfSortString_orig_curs {// cursor
    typedef atf_amc::Cstr ChildType;
    atf_amc::Cstr* elems;
    int n_elems;
    int index;
    FPerfSortString_orig_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FPerfSortString_sorted1_curs {// cursor
    typedef atf_amc::Cstr ChildType;
    atf_amc::Cstr* elems;
    int n_elems;
    int index;
    FPerfSortString_sorted1_curs() { elems=NULL; n_elems=0; index=0; }
};


struct typea_typec_curs {// cursor
    typedef atf_amc::FTypeC ChildType;
    int index;
    atf_amc::FTypeA *parent;
    typea_typec_curs() { parent=NULL; index=0; }
};


struct typea_zdl_typeb_curs {// fcurs:atf_amc.FTypeA.zdl_typeb/curs
    typedef atf_amc::FTypeB ChildType;
    atf_amc::FTypeB* row;
    typea_zdl_typeb_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct typea_bh_typeb_curs {
    typedef atf_amc::FTypeB ChildType;
    atf_amc::FTypeA      *parent;        // parent
    atf_amc::FTypeB*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    typea_bh_typeb_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~typea_bh_typeb_curs();
};


struct types_zdl_typet_curs {// fcurs:atf_amc.FTypeS.zdl_typet/curs
    typedef atf_amc::FTypeT ChildType;
    atf_amc::FTypeT* row;
    types_zdl_typet_curs() {
        row = NULL;
    }
};


struct FUnitSort_tary_curs {// cursor
    typedef atf_amc::TypeA ChildType;
    atf_amc::TypeA* elems;
    int n_elems;
    int index;
    FUnitSort_tary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FUnitSort_c_ptrary_curs {// fcurs:atf_amc.FUnitSort.c_ptrary/curs
    typedef atf_amc::TypeA ChildType;
    atf_amc::TypeA** elems;
    u32 n_elems;
    u32 index;
    FUnitSort_c_ptrary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FUnitSort_fixary_curs {// cursor
    typedef atf_amc::TypeA ChildType;
    int index;
    atf_amc::FUnitSort *parent;
    FUnitSort_fixary_curs() { parent=NULL; index=0; }
};


struct InlaryPrint_fixary_curs {// cursor
    typedef u32 ChildType;
    int index;
    atf_amc::InlaryPrint *parent;
    InlaryPrint_fixary_curs() { parent=NULL; index=0; }
};


struct InlaryPrint_inlary_curs {// cursor
    typedef u32 ChildType;
    int index;
    atf_amc::InlaryPrint *parent;
    InlaryPrint_inlary_curs() { parent=NULL; index=0; }
};


struct Lary32_lary_curs {// cursor
    typedef u32 ChildType;
    atf_amc::Lary32 *parent;
    i64 index;
    Lary32_lary_curs(){ parent=NULL; index=0; }
};


struct MsgLTV_v_curs {// cursor
    typedef atf_amc::MsgHdrLT ChildType;
    u8 *ptr;
    int length;
    int index;
    MsgLTV_v_curs() { ptr=NULL; length=0; index=0; }
};


struct PmaskMultiple_present_bitcurs {// cursor
    typedef int& ChildType;
    u32* elems;
    int n_elems;
    int bit;
    PmaskMultiple_present_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct PmaskMultiple_assigned_bitcurs {// cursor
    typedef int& ChildType;
    u32* elems;
    int n_elems;
    int bit;
    PmaskMultiple_assigned_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct PmaskMultiple_nullable_bitcurs {// cursor
    typedef int& ChildType;
    u32* elems;
    int n_elems;
    int bit;
    PmaskMultiple_nullable_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct PmaskU32_pmask_bitcurs {// cursor
    typedef int& ChildType;
    u32* elems;
    int n_elems;
    int bit;
    PmaskU32_pmask_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct PmaskU555_pmask_bitcurs {// cursor
    typedef int& ChildType;
    u64* elems;
    int n_elems;
    int bit;
    PmaskU555_pmask_bitcurs() : elems(0), n_elems(0), bit(0) {}
};


struct PmaskU555_pmask_curs {// cursor
    typedef u64 ChildType;
    int index;
    atf_amc::PmaskU555 *parent;
    PmaskU555_pmask_curs() { parent=NULL; index=0; }
};


struct TaryU32_tary_u32_curs {// cursor
    typedef u32 ChildType;
    u32* elems;
    int n_elems;
    int index;
    TaryU32_tary_u32_curs() { elems=NULL; n_elems=0; index=0; }
};


struct TaryU8_ary_curs {// cursor
    typedef u8 ChildType;
    u8* elems;
    int n_elems;
    int index;
    TaryU8_ary_curs() { elems=NULL; n_elems=0; index=0; }
};


struct Text_text_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    Text_text_curs() { ptr=NULL; length=0; index=0; }
};


struct varlenalloc_elem_curs {// cursor
    typedef i32 ChildType;
    u8 *ptr;
    int length;
    int index;
    varlenalloc_elem_curs() { ptr=NULL; length=0; index=0; }
};


struct varlen_extern_varlen_curs {// cursor
    typedef u32 ChildType;
    u8 *ptr;
    int length;
    int index;
    varlen_extern_varlen_curs() { ptr=NULL; length=0; index=0; }
};


struct VarlenH_typeh_curs {// cursor
    typedef atf_amc::TypeH ChildType;
    u8 *ptr;
    int length;
    int index;
    VarlenH_typeh_curs() { ptr=NULL; length=0; index=0; }
};


struct k_i_curs {// cursor
    typedef u32 ChildType;
    u8 *ptr;
    int length;
    int index;
    k_i_curs() { ptr=NULL; length=0; index=0; }
};


struct VarlenMsg_k_curs {// cursor
    typedef atf_amc::VarlenK ChildType;
    u8 *ptr;
    int length;
    int index;
    VarlenMsg_k_curs() { ptr=NULL; length=0; index=0; }
};

} // gen:ns_curstext
namespace atf_amc { // gen:ns_func
// Test string conversion
// func:atf_amc...ForAllStrings
void                 ForAllStrings(void (*fcn)(algo::StringDesc&) );
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_AmcSort
// this function is 'extrn' and implemented by user
void                 amctest_AmcSort();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BhFirstChanged1
// this function is 'extrn' and implemented by user
void                 amctest_BhFirstChanged1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BhFirstChanged2
// this function is 'extrn' and implemented by user
void                 amctest_BhFirstChanged2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BhFirstChanged3
// this function is 'extrn' and implemented by user
void                 amctest_BhFirstChanged3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BheapCursor
// this function is 'extrn' and implemented by user
void                 amctest_BheapCursor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BheapInsert100
// this function is 'extrn' and implemented by user
void                 amctest_BheapInsert100();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BigEndian
// this function is 'extrn' and implemented by user
void                 amctest_BigEndian();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BigendFconst
// this function is 'extrn' and implemented by user
void                 amctest_BigendFconst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitfldBitset
// this function is 'extrn' and implemented by user
void                 amctest_BitfldBitset();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitfldNet
// this function is 'extrn' and implemented by user
void                 amctest_BitfldNet();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitfldTuple
// this function is 'extrn' and implemented by user
void                 amctest_BitfldTuple();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitsetBitcurs
// this function is 'extrn' and implemented by user
void                 amctest_BitsetBitcurs();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitsetInlary16
// this function is 'extrn' and implemented by user
void                 amctest_BitsetInlary16();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitsetTary64
// this function is 'extrn' and implemented by user
void                 amctest_BitsetTary64();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitsetVal128
// this function is 'extrn' and implemented by user
void                 amctest_BitsetVal128();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitsetVal64
// this function is 'extrn' and implemented by user
void                 amctest_BitsetVal64();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_BitsetVal8
// this function is 'extrn' and implemented by user
void                 amctest_BitsetVal8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelAtree
// this function is 'extrn' and implemented by user
void                 amctest_CascdelAtree();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelBheap
// this function is 'extrn' and implemented by user
void                 amctest_CascdelBheap();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelBheapChain
// this function is 'extrn' and implemented by user
void                 amctest_CascdelBheapChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelPtr
// this function is 'extrn' and implemented by user
void                 amctest_CascdelPtr();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelPtrary
// this function is 'extrn' and implemented by user
void                 amctest_CascdelPtrary();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelPtraryChain
// this function is 'extrn' and implemented by user
void                 amctest_CascdelPtraryChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelThash
// this function is 'extrn' and implemented by user
void                 amctest_CascdelThash();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelThashChain
// this function is 'extrn' and implemented by user
void                 amctest_CascdelThashChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelZdlist
// this function is 'extrn' and implemented by user
void                 amctest_CascdelZdlist();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelZdlistChain
// this function is 'extrn' and implemented by user
void                 amctest_CascdelZdlistChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelZslist
// this function is 'extrn' and implemented by user
void                 amctest_CascdelZslist();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CascdelZslistChain
// this function is 'extrn' and implemented by user
void                 amctest_CascdelZslistChain();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CastDown
// this function is 'extrn' and implemented by user
void                 amctest_CastDown();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CastDownFail
// this function is 'extrn' and implemented by user
void                 amctest_CastDownFail();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CastDownTooShort
// this function is 'extrn' and implemented by user
void                 amctest_CastDownTooShort();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CastUp
// this function is 'extrn' and implemented by user
void                 amctest_CastUp();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistDfltCtor
// this function is 'extrn' and implemented by user
void                 amctest_CdlistDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistFlush100
// this function is 'extrn' and implemented by user
void                 amctest_CdlistFlush100();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistFlushEmpty
// this function is 'extrn' and implemented by user
void                 amctest_CdlistFlushEmpty();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsert1
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsert2
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsert3
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsertHead1
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsertHead2
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsertHead3
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistInsertMaybe
// this function is 'extrn' and implemented by user
void                 amctest_CdlistInsertMaybe();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistItemDfltCtor
// this function is 'extrn' and implemented by user
void                 amctest_CdlistItemDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistRemove
// this function is 'extrn' and implemented by user
void                 amctest_CdlistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistRemoveFirst
// this function is 'extrn' and implemented by user
void                 amctest_CdlistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CdlistRotateFirst
// this function is 'extrn' and implemented by user
void                 amctest_CdlistRotateFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CleanupOrder
// this function is 'extrn' and implemented by user
void                 amctest_CleanupOrder();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CopyOut1
// this function is 'extrn' and implemented by user
void                 amctest_CopyOut1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CopyOut2
// this function is 'extrn' and implemented by user
void                 amctest_CopyOut2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CopyOut3
// this function is 'extrn' and implemented by user
void                 amctest_CopyOut3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistFirstChangedFlush
// this function is 'extrn' and implemented by user
void                 amctest_CslistFirstChangedFlush();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistFirstChangedInsert
// this function is 'extrn' and implemented by user
void                 amctest_CslistFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistFirstChangedRemove
// this function is 'extrn' and implemented by user
void                 amctest_CslistFirstChangedRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistFirstChangedRemoveFirst
// this function is 'extrn' and implemented by user
void                 amctest_CslistFirstChangedRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistHeadFirstChangedInsert
// this function is 'extrn' and implemented by user
void                 amctest_CslistHeadFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistInsert1
// this function is 'extrn' and implemented by user
void                 amctest_CslistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistInsert2
// this function is 'extrn' and implemented by user
void                 amctest_CslistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistInsert3
// this function is 'extrn' and implemented by user
void                 amctest_CslistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistInsertHead1
// this function is 'extrn' and implemented by user
void                 amctest_CslistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistInsertHead2
// this function is 'extrn' and implemented by user
void                 amctest_CslistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistInsertHead3
// this function is 'extrn' and implemented by user
void                 amctest_CslistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistRemove
// this function is 'extrn' and implemented by user
void                 amctest_CslistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistRemoveFirst
// this function is 'extrn' and implemented by user
void                 amctest_CslistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_CslistRotateFirst
// this function is 'extrn' and implemented by user
void                 amctest_CslistRotateFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Delptr
// this function is 'extrn' and implemented by user
void                 amctest_Delptr();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_DispRead1
// this function is 'extrn' and implemented by user
void                 amctest_DispRead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_DispRead2
// this function is 'extrn' and implemented by user
void                 amctest_DispRead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_DispRead3
// this function is 'extrn' and implemented by user
void                 amctest_DispRead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_DispRead4
// this function is 'extrn' and implemented by user
void                 amctest_DispRead4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_DispReadSsimfile
// this function is 'extrn' and implemented by user
void                 amctest_DispReadSsimfile();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ExecSh
// this function is 'extrn' and implemented by user
void                 amctest_ExecSh();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ExecVerbose
// this function is 'extrn' and implemented by user
void                 amctest_ExecVerbose();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Exec_Status
// this function is 'extrn' and implemented by user
void                 amctest_Exec_Status();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Fcmp
// this function is 'extrn' and implemented by user
void                 amctest_Fcmp();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Fconst
// this function is 'extrn' and implemented by user
void                 amctest_Fconst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Gsymbol
// this function is 'extrn' and implemented by user
void                 amctest_Gsymbol();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Hook1
// this function is 'extrn' and implemented by user
void                 amctest_Hook1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Hook2
// this function is 'extrn' and implemented by user
void                 amctest_Hook2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ImdXref
// this function is 'extrn' and implemented by user
void                 amctest_ImdXref();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Inlary_ReadPrint
// this function is 'extrn' and implemented by user
void                 amctest_Inlary_ReadPrint();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_LaryFind
// this function is 'extrn' and implemented by user
void                 amctest_LaryFind();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_LineIter
// this function is 'extrn' and implemented by user
void                 amctest_LineIter();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Lpool
// this function is 'extrn' and implemented by user
void                 amctest_Lpool();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_LpoolLockMem
// this function is 'extrn' and implemented by user
void                 amctest_LpoolLockMem();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Minmax
// this function is 'extrn' and implemented by user
void                 amctest_Minmax();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_MsgCurs
// this function is 'extrn' and implemented by user
void                 amctest_MsgCurs();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_MsgCurs2
// this function is 'extrn' and implemented by user
void                 amctest_MsgCurs2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_MsgCurs3
// this function is 'extrn' and implemented by user
void                 amctest_MsgCurs3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_MsgCurs4
// this function is 'extrn' and implemented by user
void                 amctest_MsgCurs4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_MsgLength
// this function is 'extrn' and implemented by user
void                 amctest_MsgLength();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Numstr
// this function is 'extrn' and implemented by user
void                 amctest_Numstr();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_NumstrCorruption
// this function is 'extrn' and implemented by user
void                 amctest_NumstrCorruption();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptAlloc
// this function is 'extrn' and implemented by user
void                 amctest_OptAlloc();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptG
// this function is 'extrn' and implemented by user
void                 amctest_OptG();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptG2
// this function is 'extrn' and implemented by user
void                 amctest_OptG2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptG8
// this function is 'extrn' and implemented by user
void                 amctest_OptG8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptG9
// this function is 'extrn' and implemented by user
void                 amctest_OptG9();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG10
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG10();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG3
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG4
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG5
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG6
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG6();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG7
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG7();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG8
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_OptOptG9
// this function is 'extrn' and implemented by user
void                 amctest_OptOptG9();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PerfSortString
// this function is 'extrn' and implemented by user
void                 amctest_PerfSortString();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PerfThashRemove
// this function is 'extrn' and implemented by user
void                 amctest_PerfThashRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PmaskMultiple
// this function is 'extrn' and implemented by user
void                 amctest_PmaskMultiple();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PrintBase36
// this function is 'extrn' and implemented by user
void                 amctest_PrintBase36();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PrintRawGconst
// this function is 'extrn' and implemented by user
void                 amctest_PrintRawGconst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PtraryCursor
// this function is 'extrn' and implemented by user
void                 amctest_PtraryCursor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_PtraryInsert
// this function is 'extrn' and implemented by user
void                 amctest_PtraryInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadProc
// this function is 'extrn' and implemented by user
void                 amctest_ReadProc();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadTuple1
// this function is 'extrn' and implemented by user
void                 amctest_ReadTuple1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadTuple2
// this function is 'extrn' and implemented by user
void                 amctest_ReadTuple2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadTuple2a
// this function is 'extrn' and implemented by user
void                 amctest_ReadTuple2a();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadTuple3
// this function is 'extrn' and implemented by user
void                 amctest_ReadTuple3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadTuple4
// this function is 'extrn' and implemented by user
void                 amctest_ReadTuple4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ReadTuple5
// this function is 'extrn' and implemented by user
void                 amctest_ReadTuple5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Scratch
// this function is 'extrn' and implemented by user
void                 amctest_Scratch();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_SetGetnumBase10
// this function is 'extrn' and implemented by user
void                 amctest_SetGetnumBase10();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_SubstrDfltval
// this function is 'extrn' and implemented by user
void                 amctest_SubstrDfltval();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TaryInit
// this function is 'extrn' and implemented by user
void                 amctest_TaryInit();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TaryInit2
// this function is 'extrn' and implemented by user
void                 amctest_TaryInit2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TaryInit3
// this function is 'extrn' and implemented by user
void                 amctest_TaryInit3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TaryInit4
// this function is 'extrn' and implemented by user
void                 amctest_TaryInit4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TaryReserve
// this function is 'extrn' and implemented by user
void                 amctest_TaryReserve();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestBitfld
// this function is 'extrn' and implemented by user
void                 amctest_TestBitfld();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestBitfld2
// this function is 'extrn' and implemented by user
void                 amctest_TestBitfld2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestCstring1
// this function is 'extrn' and implemented by user
void                 amctest_TestCstring1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestCstring2
// this function is 'extrn' and implemented by user
void                 amctest_TestCstring2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestDispFilter
// this function is 'extrn' and implemented by user
void                 amctest_TestDispFilter();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestDispFilter2
// this function is 'extrn' and implemented by user
void                 amctest_TestDispFilter2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestDispFilter3
// this function is 'extrn' and implemented by user
void                 amctest_TestDispFilter3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestDispFilter4
// this function is 'extrn' and implemented by user
void                 amctest_TestDispFilter4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestInsertX2
// this function is 'extrn' and implemented by user
void                 amctest_TestInsertX2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestInsertX3
// this function is 'extrn' and implemented by user
void                 amctest_TestInsertX3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask1
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask2
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask3
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask4
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask5
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask6
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask6();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask7
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask7();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestPmask8
// this function is 'extrn' and implemented by user
void                 amctest_TestPmask8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestRegx1
// this function is 'extrn' and implemented by user
void                 amctest_TestRegx1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestSep1
// this function is 'extrn' and implemented by user
void                 amctest_TestSep1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestSep2
// this function is 'extrn' and implemented by user
void                 amctest_TestSep2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_TestString
// this function is 'extrn' and implemented by user
void                 amctest_TestString();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ThashEmpty
// this function is 'extrn' and implemented by user
void                 amctest_ThashEmpty();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ThashFindRemove
// this function is 'extrn' and implemented by user
void                 amctest_ThashFindRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ThashGetOrCreate
// this function is 'extrn' and implemented by user
void                 amctest_ThashGetOrCreate();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ThashInsertMaybe
// this function is 'extrn' and implemented by user
void                 amctest_ThashInsertMaybe();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ThashRemove
// this function is 'extrn' and implemented by user
void                 amctest_ThashRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ThashXref
// this function is 'extrn' and implemented by user
void                 amctest_ThashXref();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Typetag
// this function is 'extrn' and implemented by user
void                 amctest_Typetag();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_VarlenAlloc
// this function is 'extrn' and implemented by user
void                 amctest_VarlenAlloc();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_VarlenExternLength
// this function is 'extrn' and implemented by user
void                 amctest_VarlenExternLength();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_VarlenMsgs
// this function is 'extrn' and implemented by user
void                 amctest_VarlenMsgs();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_VarlenMsgsPnew
// this function is 'extrn' and implemented by user
void                 amctest_VarlenMsgsPnew();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistDelCurs
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistDelCurs();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistDfltCtor
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistFlush100
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistFlush100();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistFlushEmpty
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistFlushEmpty();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsert1
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsert2
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsert3
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertHead1
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertHead2
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertHead3
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertHeadNoTail1
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertHeadNoTail1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertHeadNoTail2
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertHeadNoTail2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertHeadNoTail3
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertHeadNoTail3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistInsertMaybe
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistInsertMaybe();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistItemDfltCtor
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistItemDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistRemove
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZdlistRemoveFirst
// this function is 'extrn' and implemented by user
void                 amctest_ZdlistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistFirstChangedFlush
// this function is 'extrn' and implemented by user
void                 amctest_ZslistFirstChangedFlush();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistFirstChangedInsert
// this function is 'extrn' and implemented by user
void                 amctest_ZslistFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistFirstChangedRemove
// this function is 'extrn' and implemented by user
void                 amctest_ZslistFirstChangedRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistFirstChangedRemoveFirst
// this function is 'extrn' and implemented by user
void                 amctest_ZslistFirstChangedRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistHeadFirstChangedInsert
// this function is 'extrn' and implemented by user
void                 amctest_ZslistHeadFirstChangedInsert();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistInsert1
// this function is 'extrn' and implemented by user
void                 amctest_ZslistInsert1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistInsert2
// this function is 'extrn' and implemented by user
void                 amctest_ZslistInsert2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistInsert3
// this function is 'extrn' and implemented by user
void                 amctest_ZslistInsert3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistInsertHead1
// this function is 'extrn' and implemented by user
void                 amctest_ZslistInsertHead1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistInsertHead2
// this function is 'extrn' and implemented by user
void                 amctest_ZslistInsertHead2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistInsertHead3
// this function is 'extrn' and implemented by user
void                 amctest_ZslistInsertHead3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistRemove
// this function is 'extrn' and implemented by user
void                 amctest_ZslistRemove();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistRemoveFirst
// this function is 'extrn' and implemented by user
void                 amctest_ZslistRemoveFirst();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Zslistmt1
// this function is 'extrn' and implemented by user
void                 amctest_Zslistmt1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Zslistmt2
// this function is 'extrn' and implemented by user
void                 amctest_Zslistmt2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_Zslistmt3
// this function is 'extrn' and implemented by user
void                 amctest_Zslistmt3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistmtDfltCtor
// this function is 'extrn' and implemented by user
void                 amctest_ZslistmtDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_ZslistmtItemDfltCtor
// this function is 'extrn' and implemented by user
void                 amctest_ZslistmtItemDfltCtor();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_atree_RangeSearch
// this function is 'extrn' and implemented by user
void                 amctest_atree_RangeSearch();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_atree_test1
// this function is 'extrn' and implemented by user
void                 amctest_atree_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_atree_test2
// this function is 'extrn' and implemented by user
void                 amctest_atree_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_bytebuf_dyn_test1
// this function is 'extrn' and implemented by user
void                 amctest_bytebuf_dyn_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_bytebuf_test1
// this function is 'extrn' and implemented by user
void                 amctest_bytebuf_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_bytebuf_test2
// this function is 'extrn' and implemented by user
void                 amctest_bytebuf_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_fstep_Inline
// this function is 'extrn' and implemented by user
void                 amctest_fstep_Inline();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_fstep_InlineOnce
// this function is 'extrn' and implemented by user
void                 amctest_fstep_InlineOnce();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_fstep_InlineRecur
// this function is 'extrn' and implemented by user
void                 amctest_fstep_InlineRecur();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_fstep_TimeHookRecur
// this function is 'extrn' and implemented by user
void                 amctest_fstep_TimeHookRecur();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_linebuf_test1
// this function is 'extrn' and implemented by user
void                 amctest_linebuf_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_linebuf_test2
// this function is 'extrn' and implemented by user
void                 amctest_linebuf_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_linebuf_test3
// this function is 'extrn' and implemented by user
void                 amctest_linebuf_test3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_linebuf_test4
// this function is 'extrn' and implemented by user
void                 amctest_linebuf_test4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_linebuf_test5
// this function is 'extrn' and implemented by user
void                 amctest_linebuf_test5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_custom
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_custom();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_extra_test
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_extra_test();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test0
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test0();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test1
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test10
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test10();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test1_1
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test1_1();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test1_2
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test1_2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test2
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test2();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test3
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test3();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test4
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test4();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test5
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test5();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test6
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test6();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test7
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test7();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test8
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test8();
// User-implemented function from gstatic:atf_amc.FDb.amctest
// func:atf_amc...amctest_msgbuf_test9
// this function is 'extrn' and implemented by user
void                 amctest_msgbuf_test9();
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_cd
// this function is 'extrn' and implemented by user
void                 listtype_cd(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_cdl
// this function is 'extrn' and implemented by user
void                 listtype_cdl(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_cs
// this function is 'extrn' and implemented by user
void                 listtype_cs(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_csl
// this function is 'extrn' and implemented by user
void                 listtype_csl(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_zd
// this function is 'extrn' and implemented by user
void                 listtype_zd(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_zdl
// this function is 'extrn' and implemented by user
void                 listtype_zdl(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_zs
// this function is 'extrn' and implemented by user
void                 listtype_zs(atf_amc::FListtype&);
// User-implemented function from gstatic:atf_amc.FDb.listtype
// func:atf_amc...listtype_zsl
// this function is 'extrn' and implemented by user
void                 listtype_zsl(atf_amc::FListtype&);
// func:atf_amc...StaticCheck
void                 StaticCheck();
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
// func:atf_amc.MsgHdrLTMsgs..Print
bool                 MsgHdrLTMsgs_Print(algo::cstring &str, atf_amc::MsgHdrLT &msg, u32 msg_len);
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
// func:atf_amc.MsgHeaderMsgs..Print
bool                 MsgHeaderMsgs_Print(algo::cstring &str, atf_amc::MsgHeader &msg, u32 msg_len);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.Msgs..ReadStrptr
atf_amc::MsgsCase    Msgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.Msgs..ReadStrptrMaybe
bool                 Msgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.Ssimfiles..ReadStrptr
atf_amc::SsimfilesCase Ssimfiles_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.Ssimfiles..ReadStrptrMaybe
bool                 Ssimfiles_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.MsgHdrLTMsgs..ReadStrptr
atf_amc::MsgHdrLTMsgsCase MsgHdrLTMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.MsgHdrLTMsgs..ReadStrptrMaybe
bool                 MsgHdrLTMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.MsgHeaderMsgs..ReadStrptr
atf_amc::MsgType     MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:atf_amc.MsgHeaderMsgs..ReadStrptrMaybe
bool                 MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Construct a new atf_amc::MsgLTO in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_amc...MsgLTO_FmtByteAry
atf_amc::MsgLTO *    MsgLTO_FmtByteAry(algo::ByteAry &buf, atf_amc::MsgHdrLT* o);
// Construct a new atf_amc::MsgLTV in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_amc...MsgLTV_FmtByteAry
atf_amc::MsgLTV *    MsgLTV_FmtByteAry(algo::ByteAry &buf, algo::memptr v);
// Construct a new atf_amc::OptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_amc...OptG_FmtByteAry
atf_amc::OptG *      OptG_FmtByteAry(algo::ByteAry &buf, atf_amc::TypeG* typeg, int opt_len);
// Construct a new atf_amc::OptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:atf_amc...OptG_FmtMemptr
atf_amc::OptG *      OptG_FmtMemptr(algo::memptr &buf, atf_amc::TypeG* typeg, int opt_len);
// Construct a new atf_amc::OptOptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_amc...OptOptG_FmtByteAry
atf_amc::OptOptG *   OptOptG_FmtByteAry(algo::ByteAry &buf, atf_amc::OptG* optg);
// Construct a new atf_amc::OptOptG in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:atf_amc...OptOptG_FmtMemptr
atf_amc::OptOptG *   OptOptG_FmtMemptr(algo::memptr &buf, atf_amc::OptG* optg);
// Construct a new atf_amc::Text in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_amc...Text_FmtByteAry
atf_amc::Text *      Text_FmtByteAry(algo::ByteAry &buf, algo::aryptr<char > text);
// Construct a new atf_amc::VarlenK in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_amc...VarlenK_FmtByteAry
atf_amc::VarlenK *   VarlenK_FmtByteAry(algo::ByteAry &buf, algo::aryptr<u32 > i);
// Construct a new atf_amc::VarlenK in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:atf_amc...VarlenK_FmtMemptr
atf_amc::VarlenK *   VarlenK_FmtMemptr(algo::memptr &buf, algo::aryptr<u32 > i);
} // gen:ns_func
// func:atf_amc...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:atf_amc...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::BitfldType1 &row);// cfmt:atf_amc.BitfldType1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::BitfldType2 &row);// cfmt:atf_amc.BitfldType2.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Ctype1Attr &row);// cfmt:atf_amc.Ctype1Attr.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Ctype2Attr &row);// cfmt:atf_amc.Ctype2Attr.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Ctype2AttrAnon &row);// cfmt:atf_amc.Ctype2AttrAnon.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::trace &row);// cfmt:atf_amc.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TypeG &row);// cfmt:atf_amc.TypeG.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::FieldId &row);// cfmt:atf_amc.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgHdrLT &row);// cfmt:atf_amc.MsgHdrLT.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgType &row);// cfmt:atf_amc.MsgType.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgLength &row);// cfmt:atf_amc.MsgLength.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgHeader &row);// cfmt:atf_amc.MsgHeader.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgLTA &row);// cfmt:atf_amc.MsgLTA.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgLTB &row);// cfmt:atf_amc.MsgLTB.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgLTO &row);// cfmt:atf_amc.MsgLTO.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::MsgLTV &row);// cfmt:atf_amc.MsgLTV.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::OptAlloc &row);// cfmt:atf_amc.OptAlloc.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::OptG &row);// cfmt:atf_amc.OptG.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::OptOptG &row);// cfmt:atf_amc.OptOptG.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::PmaskMultiple &row);// cfmt:atf_amc.PmaskMultiple.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::PooledBE64 &row);// cfmt:atf_amc.PooledBE64.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Sep1 &row);// cfmt:atf_amc.Sep1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Seqmsg &row);// cfmt:atf_amc.Seqmsg.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TableId &row);// cfmt:atf_amc.TableId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TestRegx1 &row);// cfmt:atf_amc.TestRegx1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TypeBE32en &row);// cfmt:atf_amc.TypeBE32en.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::TypeBE64 &row);// cfmt:atf_amc.TypeBE64.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::Typefconst &row);// cfmt:atf_amc.Typefconst.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_amc::VarlenMsg &row);// cfmt:atf_amc.VarlenMsg.String
}
