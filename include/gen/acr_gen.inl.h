//
// include/gen/acr_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/amcdb_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

inline bool acr::CtypeTopoKey::operator ==(const acr::CtypeTopoKey &rhs) const {
    return acr::CtypeTopoKey_Eq(const_cast<acr::CtypeTopoKey&>(*this),const_cast<acr::CtypeTopoKey&>(rhs));
}

inline bool acr::CtypeTopoKey::operator <(const acr::CtypeTopoKey &rhs) const {
    return acr::CtypeTopoKey_Lt(const_cast<acr::CtypeTopoKey&>(*this),const_cast<acr::CtypeTopoKey&>(rhs));
}
inline acr::CtypeTopoKey::CtypeTopoKey() {
    acr::CtypeTopoKey_Init(*this);
}


// --- acr.CtypeTopoKey..Hash
inline u32 acr::CtypeTopoKey_Hash(u32 prev, const acr::CtypeTopoKey & rhs) {
    prev = i32_Hash(prev, rhs.alldep);
    prev = i32_Hash(prev, rhs.rowid);
    return prev;
}

// --- acr.CtypeTopoKey..Lt
inline bool acr::CtypeTopoKey_Lt(acr::CtypeTopoKey & lhs, acr::CtypeTopoKey & rhs) {
    return CtypeTopoKey_Cmp(lhs,rhs) < 0;
}

// --- acr.CtypeTopoKey..Cmp
inline i32 acr::CtypeTopoKey_Cmp(acr::CtypeTopoKey & lhs, acr::CtypeTopoKey & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.alldep, rhs.alldep);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.rowid, rhs.rowid);
    return retval;
}

// --- acr.CtypeTopoKey..Init
// Set all fields to initial values.
inline void acr::CtypeTopoKey_Init(acr::CtypeTopoKey& parent) {
    parent.alldep = i32(0);
    parent.rowid = i32(0);
}

// --- acr.CtypeTopoKey..Eq
inline bool acr::CtypeTopoKey_Eq(const acr::CtypeTopoKey & lhs,const acr::CtypeTopoKey & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.alldep, rhs.alldep);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.rowid, rhs.rowid);
    return retval;
}

// --- acr.CtypeTopoKey..Update
// Set value. Return true if new value is different from old value.
inline bool acr::CtypeTopoKey_Update(acr::CtypeTopoKey &lhs, acr::CtypeTopoKey & rhs) {
    bool ret = !CtypeTopoKey_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline acr::Err::Err() {
    acr::Err_Init(*this);
}


// --- acr.Err..Init
// Set all fields to initial values.
inline void acr::Err_Init(acr::Err& parent) {
    parent.ctype = NULL;
    parent.id = u32(0);
    parent.rec = NULL;
    parent.fld = NULL;
}
inline acr::FAnonfld::FAnonfld() {
}

inline acr::FBltin::FBltin() {
    acr::FBltin_Init(*this);
}

inline acr::FBltin::~FBltin() {
    acr::FBltin_Uninit(*this);
}


// --- acr.FBltin..Init
// Set all fields to initial values.
inline void acr::FBltin_Init(acr::FBltin& bltin) {
    bltin.likeu64 = bool(false);
    bltin.bigendok = bool(false);
    bltin.issigned = bool(false);
}
inline acr::FCdflt::FCdflt() {
}

inline acr::FCdflt::~FCdflt() {
    acr::FCdflt_Uninit(*this);
}

inline acr::FCheck::FCheck() {
    acr::FCheck_Init(*this);
}

inline acr::FCheck::~FCheck() {
    acr::FCheck_Uninit(*this);
}


// --- acr.FCheck.c_bad_rec.EmptyQ
// Return true if index is empty
inline bool acr::c_bad_rec_EmptyQ(acr::FCheck& check) {
    return check.c_bad_rec_n == 0;
}

// --- acr.FCheck.c_bad_rec.Find
// Look up row by row id. Return NULL if out of range
inline acr::FRec* acr::c_bad_rec_Find(acr::FCheck& check, u32 t) {
    acr::FRec *retval = NULL;
    u64 idx = t;
    u64 lim = check.c_bad_rec_n;
    if (idx < lim) {
        retval = check.c_bad_rec_elems[idx];
    }
    return retval;
}

// --- acr.FCheck.c_bad_rec.Getary
// Return array of pointers
inline algo::aryptr<acr::FRec*> acr::c_bad_rec_Getary(acr::FCheck& check) {
    return algo::aryptr<acr::FRec*>(check.c_bad_rec_elems, check.c_bad_rec_n);
}

// --- acr.FCheck.c_bad_rec.N
// Return number of items in the pointer array
inline i32 acr::c_bad_rec_N(const acr::FCheck& check) {
    return check.c_bad_rec_n;
}

// --- acr.FCheck.c_bad_rec.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_bad_rec_RemoveAll(acr::FCheck& check) {
    check.c_bad_rec_n = 0;
}

// --- acr.FCheck.ary_name.EmptyQ
// Return true if index is empty
inline bool acr::ary_name_EmptyQ(acr::FCheck& check) {
    return check.ary_name_n == 0;
}

// --- acr.FCheck.ary_name.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* acr::ary_name_Find(acr::FCheck& check, u64 t) {
    u64 idx = t;
    u64 lim = check.ary_name_n;
    if (idx >= lim) return NULL;
    return check.ary_name_elems + idx;
}

// --- acr.FCheck.ary_name.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> acr::ary_name_Getary(acr::FCheck& check) {
    return algo::aryptr<algo::cstring>(check.ary_name_elems, check.ary_name_n);
}

// --- acr.FCheck.ary_name.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* acr::ary_name_Last(acr::FCheck& check) {
    return ary_name_Find(check, u64(check.ary_name_n-1));
}

// --- acr.FCheck.ary_name.Max
// Return max. number of items in the array
inline i32 acr::ary_name_Max(acr::FCheck& check) {
    (void)check;
    return check.ary_name_max;
}

// --- acr.FCheck.ary_name.N
// Return number of items in the array
inline i32 acr::ary_name_N(const acr::FCheck& check) {
    return check.ary_name_n;
}

// --- acr.FCheck.ary_name.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void acr::ary_name_Reserve(acr::FCheck& check, int n) {
    u32 new_n = check.ary_name_n + n;
    if (UNLIKELY(new_n > check.ary_name_max)) {
        ary_name_AbsReserve(check, new_n);
    }
}

// --- acr.FCheck.ary_name.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& acr::ary_name_qFind(acr::FCheck& check, u64 t) {
    return check.ary_name_elems[t];
}

// --- acr.FCheck.ary_name.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& acr::ary_name_qLast(acr::FCheck& check) {
    return ary_name_qFind(check, u64(check.ary_name_n-1));
}

// --- acr.FCheck.ary_name.rowid_Get
// Return row id of specified element
inline u64 acr::ary_name_rowid_Get(acr::FCheck& check, algo::cstring &elem) {
    u64 id = &elem - check.ary_name_elems;
    return u64(id);
}

// --- acr.FCheck.c_bad_rec_curs.Reset
inline void acr::check_c_bad_rec_curs_Reset(check_c_bad_rec_curs &curs, acr::FCheck &parent) {
    curs.elems = parent.c_bad_rec_elems;
    curs.n_elems = parent.c_bad_rec_n;
    curs.index = 0;
}

// --- acr.FCheck.c_bad_rec_curs.ValidQ
// cursor points to valid item
inline bool acr::check_c_bad_rec_curs_ValidQ(check_c_bad_rec_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FCheck.c_bad_rec_curs.Next
// proceed to next item
inline void acr::check_c_bad_rec_curs_Next(check_c_bad_rec_curs &curs) {
    curs.index++;
}

// --- acr.FCheck.c_bad_rec_curs.Access
// item access
inline acr::FRec& acr::check_c_bad_rec_curs_Access(check_c_bad_rec_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FCheck.ary_name_curs.Next
// proceed to next item
inline void acr::check_ary_name_curs_Next(check_ary_name_curs &curs) {
    curs.index++;
}

// --- acr.FCheck.ary_name_curs.Reset
inline void acr::check_ary_name_curs_Reset(check_ary_name_curs &curs, acr::FCheck &parent) {
    curs.elems = parent.ary_name_elems;
    curs.n_elems = parent.ary_name_n;
    curs.index = 0;
}

// --- acr.FCheck.ary_name_curs.ValidQ
// cursor points to valid item
inline bool acr::check_ary_name_curs_ValidQ(check_ary_name_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FCheck.ary_name_curs.Access
// item access
inline algo::cstring& acr::check_ary_name_curs_Access(check_ary_name_curs &curs) {
    return curs.elems[curs.index];
}

// --- acr.FCheck..Init
// Set all fields to initial values.
inline void acr::FCheck_Init(acr::FCheck& check) {
    check.c_bad_rec_elems = NULL; // (acr.FCheck.c_bad_rec)
    check.c_bad_rec_n = 0; // (acr.FCheck.c_bad_rec)
    check.c_bad_rec_max = 0; // (acr.FCheck.c_bad_rec)
    check.n_record = u32(0);
    check.n_err = i32(0);
    check.ary_name_elems 	= 0; // (acr.FCheck.ary_name)
    check.ary_name_n     	= 0; // (acr.FCheck.ary_name)
    check.ary_name_max   	= 0; // (acr.FCheck.ary_name)
}
inline acr::FCppfunc::FCppfunc() {
}

inline acr::FCtype::FCtype() {
    acr::FCtype_Init(*this);
}

inline acr::FCtype::~FCtype() {
    acr::FCtype_Uninit(*this);
}


// --- acr.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool acr::c_field_EmptyQ(acr::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- acr.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline acr::FField* acr::c_field_Find(acr::FCtype& ctype, u32 t) {
    acr::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- acr.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<acr::FField*> acr::c_field_Getary(acr::FCtype& ctype) {
    return algo::aryptr<acr::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- acr.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 acr::c_field_N(const acr::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- acr.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_field_RemoveAll(acr::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_elems[i]->ctype_c_field_in_ary = false;
    }
    ctype.c_field_n = 0;
}

// --- acr.FCtype.c_cdflt.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr::c_cdflt_InsertMaybe(acr::FCtype& ctype, acr::FCdflt& row) {
    acr::FCdflt* ptr = ctype.c_cdflt;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cdflt = &row;
    }
    return retval;
}

// --- acr.FCtype.c_cdflt.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr::c_cdflt_Remove(acr::FCtype& ctype, acr::FCdflt& row) {
    acr::FCdflt *ptr = ctype.c_cdflt;
    if (LIKELY(ptr == &row)) {
        ctype.c_cdflt = NULL;
    }
}

// --- acr.FCtype.c_ssimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr::c_ssimfile_InsertMaybe(acr::FCtype& ctype, acr::FSsimfile& row) {
    acr::FSsimfile* ptr = ctype.c_ssimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ssimfile = &row;
    }
    return retval;
}

// --- acr.FCtype.c_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr::c_ssimfile_Remove(acr::FCtype& ctype, acr::FSsimfile& row) {
    acr::FSsimfile *ptr = ctype.c_ssimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_ssimfile = NULL;
    }
}

// --- acr.FCtype.zd_trec.EmptyQ
// Return true if index is empty
inline bool acr::zd_trec_EmptyQ(acr::FCtype& ctype) {
    return ctype.zd_trec_head == NULL;
}

// --- acr.FCtype.zd_trec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FRec* acr::zd_trec_First(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_trec_head;
    return row;
}

// --- acr.FCtype.zd_trec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_trec_InLlistQ(acr::FRec& row) {
    bool result = false;
    result = !(row.zd_trec_next == (acr::FRec*)-1);
    return result;
}

// --- acr.FCtype.zd_trec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FRec* acr::zd_trec_Last(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_trec_tail;
    return row;
}

// --- acr.FCtype.zd_trec.Next
// Return pointer to next element in the list
inline acr::FRec* acr::zd_trec_Next(acr::FRec &row) {
    return row.zd_trec_next;
}

// --- acr.FCtype.zd_trec.Prev
// Return pointer to previous element in the list
inline acr::FRec* acr::zd_trec_Prev(acr::FRec &row) {
    return row.zd_trec_prev;
}

// --- acr.FCtype.zd_trec.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FRec& acr::zd_trec_qLast(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_trec_tail;
    return *row;
}

// --- acr.FCtype.ind_rec.EmptyQ
// Return true if hash is empty
inline bool acr::ind_rec_EmptyQ(acr::FCtype& ctype) {
    return ctype.ind_rec_n == 0;
}

// --- acr.FCtype.ind_rec.N
// Return number of items in the hash
inline i32 acr::ind_rec_N(const acr::FCtype& ctype) {
    return ctype.ind_rec_n;
}

// --- acr.FCtype.zd_selrec.EmptyQ
// Return true if index is empty
inline bool acr::zd_selrec_EmptyQ(acr::FCtype& ctype) {
    return ctype.zd_selrec_head == NULL;
}

// --- acr.FCtype.zd_selrec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FRec* acr::zd_selrec_First(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_selrec_head;
    return row;
}

// --- acr.FCtype.zd_selrec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_selrec_InLlistQ(acr::FRec& row) {
    bool result = false;
    result = !(row.zd_selrec_next == (acr::FRec*)-1);
    return result;
}

// --- acr.FCtype.zd_selrec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FRec* acr::zd_selrec_Last(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_selrec_tail;
    return row;
}

// --- acr.FCtype.zd_selrec.Next
// Return pointer to next element in the list
inline acr::FRec* acr::zd_selrec_Next(acr::FRec &row) {
    return row.zd_selrec_next;
}

// --- acr.FCtype.zd_selrec.Prev
// Return pointer to previous element in the list
inline acr::FRec* acr::zd_selrec_Prev(acr::FRec &row) {
    return row.zd_selrec_prev;
}

// --- acr.FCtype.zd_selrec.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FRec& acr::zd_selrec_qLast(acr::FCtype& ctype) {
    acr::FRec *row = NULL;
    row = ctype.zd_selrec_tail;
    return *row;
}

// --- acr.FCtype.c_child.EmptyQ
// Return true if index is empty
inline bool acr::c_child_EmptyQ(acr::FCtype& ctype) {
    return ctype.c_child_n == 0;
}

// --- acr.FCtype.c_child.Find
// Look up row by row id. Return NULL if out of range
inline acr::FCtype* acr::c_child_Find(acr::FCtype& ctype, u32 t) {
    acr::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_child_n;
    if (idx < lim) {
        retval = ctype.c_child_elems[idx];
    }
    return retval;
}

// --- acr.FCtype.c_child.Getary
// Return array of pointers
inline algo::aryptr<acr::FCtype*> acr::c_child_Getary(acr::FCtype& ctype) {
    return algo::aryptr<acr::FCtype*>(ctype.c_child_elems, ctype.c_child_n);
}

// --- acr.FCtype.c_child.N
// Return number of items in the pointer array
inline i32 acr::c_child_N(const acr::FCtype& ctype) {
    return ctype.c_child_n;
}

// --- acr.FCtype.c_child.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_child_RemoveAll(acr::FCtype& ctype) {
    ctype.c_child_n = 0;
}

// --- acr.FCtype.c_bltin.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr::c_bltin_InsertMaybe(acr::FCtype& ctype, acr::FBltin& row) {
    acr::FBltin* ptr = ctype.c_bltin;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_bltin = &row;
    }
    return retval;
}

// --- acr.FCtype.c_bltin.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr::c_bltin_Remove(acr::FCtype& ctype, acr::FBltin& row) {
    acr::FBltin *ptr = ctype.c_bltin;
    if (LIKELY(ptr == &row)) {
        ctype.c_bltin = NULL;
    }
}

// --- acr.FCtype.zd_arg.EmptyQ
// Return true if index is empty
inline bool acr::zd_arg_EmptyQ(acr::FCtype& ctype) {
    return ctype.zd_arg_head == NULL;
}

// --- acr.FCtype.zd_arg.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FField* acr::zd_arg_First(acr::FCtype& ctype) {
    acr::FField *row = NULL;
    row = ctype.zd_arg_head;
    return row;
}

// --- acr.FCtype.zd_arg.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_arg_InLlistQ(acr::FField& row) {
    bool result = false;
    result = !(row.zd_arg_next == (acr::FField*)-1);
    return result;
}

// --- acr.FCtype.zd_arg.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FField* acr::zd_arg_Last(acr::FCtype& ctype) {
    acr::FField *row = NULL;
    row = ctype.zd_arg_tail;
    return row;
}

// --- acr.FCtype.zd_arg.N
// Return number of items in the linked list
inline i32 acr::zd_arg_N(const acr::FCtype& ctype) {
    return ctype.zd_arg_n;
}

// --- acr.FCtype.zd_arg.Next
// Return pointer to next element in the list
inline acr::FField* acr::zd_arg_Next(acr::FField &row) {
    return row.zd_arg_next;
}

// --- acr.FCtype.zd_arg.Prev
// Return pointer to previous element in the list
inline acr::FField* acr::zd_arg_Prev(acr::FField &row) {
    return row.zd_arg_prev;
}

// --- acr.FCtype.zd_arg.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FField& acr::zd_arg_qLast(acr::FCtype& ctype) {
    acr::FField *row = NULL;
    row = ctype.zd_arg_tail;
    return *row;
}

// --- acr.FCtype.topokey.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool acr::topokey_Lt(acr::FCtype& ctype, acr::FCtype &rhs) {
    return acr::CtypeTopoKey_Lt(ctype.topokey,rhs.topokey);
}

// --- acr.FCtype.topokey.Cmp
// Compare two fields.
inline i32 acr::topokey_Cmp(acr::FCtype& ctype, acr::FCtype &rhs) {
    i32 retval = 0;
    retval = acr::CtypeTopoKey_Cmp(ctype.topokey, rhs.topokey);
    return retval;
}

// --- acr.FCtype.c_field_curs.Reset
inline void acr::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- acr.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool acr::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FCtype.c_field_curs.Next
// proceed to next item
inline void acr::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- acr.FCtype.c_field_curs.Access
// item access
inline acr::FField& acr::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FCtype.zd_trec_curs.Reset
// cursor points to valid item
inline void acr::ctype_zd_trec_curs_Reset(ctype_zd_trec_curs &curs, acr::FCtype &parent) {
    curs.row = parent.zd_trec_head;
}

// --- acr.FCtype.zd_trec_curs.ValidQ
// cursor points to valid item
inline bool acr::ctype_zd_trec_curs_ValidQ(ctype_zd_trec_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FCtype.zd_trec_curs.Next
// proceed to next item
inline void acr::ctype_zd_trec_curs_Next(ctype_zd_trec_curs &curs) {
    curs.row = (*curs.row).zd_trec_next;
}

// --- acr.FCtype.zd_trec_curs.Access
// item access
inline acr::FRec& acr::ctype_zd_trec_curs_Access(ctype_zd_trec_curs &curs) {
    return *curs.row;
}

// --- acr.FCtype.ind_rec_curs.ValidQ
// cursor points to valid item
inline bool acr::ctype_ind_rec_curs_ValidQ(ctype_ind_rec_curs &curs) {
    return *curs.prow != NULL;
}

// --- acr.FCtype.ind_rec_curs.Next
// proceed to next item
inline void acr::ctype_ind_rec_curs_Next(ctype_ind_rec_curs &curs) {
    curs.prow = &(*curs.prow)->ind_rec_next;
    while (!*curs.prow) {
        curs.bucket += 1;
        if (curs.bucket >= curs.parent->ind_rec_buckets_n) break;
        curs.prow = &curs.parent->ind_rec_buckets_elems[curs.bucket];
    }
}

// --- acr.FCtype.ind_rec_curs.Access
// item access
inline acr::FRec& acr::ctype_ind_rec_curs_Access(ctype_ind_rec_curs &curs) {
    return **curs.prow;
}

// --- acr.FCtype.zd_selrec_curs.Reset
// cursor points to valid item
inline void acr::ctype_zd_selrec_curs_Reset(ctype_zd_selrec_curs &curs, acr::FCtype &parent) {
    curs.row = parent.zd_selrec_head;
}

// --- acr.FCtype.zd_selrec_curs.ValidQ
// cursor points to valid item
inline bool acr::ctype_zd_selrec_curs_ValidQ(ctype_zd_selrec_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FCtype.zd_selrec_curs.Next
// proceed to next item
inline void acr::ctype_zd_selrec_curs_Next(ctype_zd_selrec_curs &curs) {
    curs.row = (*curs.row).zd_selrec_next;
}

// --- acr.FCtype.zd_selrec_curs.Access
// item access
inline acr::FRec& acr::ctype_zd_selrec_curs_Access(ctype_zd_selrec_curs &curs) {
    return *curs.row;
}

// --- acr.FCtype.c_child_curs.Reset
inline void acr::ctype_c_child_curs_Reset(ctype_c_child_curs &curs, acr::FCtype &parent) {
    curs.elems = parent.c_child_elems;
    curs.n_elems = parent.c_child_n;
    curs.index = 0;
}

// --- acr.FCtype.c_child_curs.ValidQ
// cursor points to valid item
inline bool acr::ctype_c_child_curs_ValidQ(ctype_c_child_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FCtype.c_child_curs.Next
// proceed to next item
inline void acr::ctype_c_child_curs_Next(ctype_c_child_curs &curs) {
    curs.index++;
}

// --- acr.FCtype.c_child_curs.Access
// item access
inline acr::FCtype& acr::ctype_c_child_curs_Access(ctype_c_child_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FCtype.zd_arg_curs.Reset
// cursor points to valid item
inline void acr::ctype_zd_arg_curs_Reset(ctype_zd_arg_curs &curs, acr::FCtype &parent) {
    curs.row = parent.zd_arg_head;
}

// --- acr.FCtype.zd_arg_curs.ValidQ
// cursor points to valid item
inline bool acr::ctype_zd_arg_curs_ValidQ(ctype_zd_arg_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FCtype.zd_arg_curs.Next
// proceed to next item
inline void acr::ctype_zd_arg_curs_Next(ctype_zd_arg_curs &curs) {
    curs.row = (*curs.row).zd_arg_next;
}

// --- acr.FCtype.zd_arg_curs.Access
// item access
inline acr::FField& acr::ctype_zd_arg_curs_Access(ctype_zd_arg_curs &curs) {
    return *curs.row;
}
inline acr::trace::trace() {
}


// --- acr.FDb.zd_pline.EmptyQ
// Return true if index is empty
inline bool acr::zd_pline_EmptyQ() {
    return _db.zd_pline_head == NULL;
}

// --- acr.FDb.zd_pline.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FPline* acr::zd_pline_First() {
    acr::FPline *row = NULL;
    row = _db.zd_pline_head;
    return row;
}

// --- acr.FDb.zd_pline.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_pline_InLlistQ(acr::FPline& row) {
    bool result = false;
    result = !(row.zd_pline_next == (acr::FPline*)-1);
    return result;
}

// --- acr.FDb.zd_pline.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FPline* acr::zd_pline_Last() {
    acr::FPline *row = NULL;
    row = _db.zd_pline_tail;
    return row;
}

// --- acr.FDb.zd_pline.Next
// Return pointer to next element in the list
inline acr::FPline* acr::zd_pline_Next(acr::FPline &row) {
    return row.zd_pline_next;
}

// --- acr.FDb.zd_pline.Prev
// Return pointer to previous element in the list
inline acr::FPline* acr::zd_pline_Prev(acr::FPline &row) {
    return row.zd_pline_prev;
}

// --- acr.FDb.zd_pline.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FPline& acr::zd_pline_qLast() {
    acr::FPline *row = NULL;
    row = _db.zd_pline_tail;
    return *row;
}

// --- acr.FDb.zd_pdep.EmptyQ
// Return true if index is empty
inline bool acr::zd_pdep_EmptyQ() {
    return _db.zd_pdep_head == NULL;
}

// --- acr.FDb.zd_pdep.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FPdep* acr::zd_pdep_First() {
    acr::FPdep *row = NULL;
    row = _db.zd_pdep_head;
    return row;
}

// --- acr.FDb.zd_pdep.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_pdep_InLlistQ(acr::FPdep& row) {
    bool result = false;
    result = !(row.zd_pdep_next == (acr::FPdep*)-1);
    return result;
}

// --- acr.FDb.zd_pdep.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FPdep* acr::zd_pdep_Last() {
    acr::FPdep *row = NULL;
    row = _db.zd_pdep_tail;
    return row;
}

// --- acr.FDb.zd_pdep.Next
// Return pointer to next element in the list
inline acr::FPdep* acr::zd_pdep_Next(acr::FPdep &row) {
    return row.zd_pdep_next;
}

// --- acr.FDb.zd_pdep.Prev
// Return pointer to previous element in the list
inline acr::FPdep* acr::zd_pdep_Prev(acr::FPdep &row) {
    return row.zd_pdep_prev;
}

// --- acr.FDb.zd_pdep.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FPdep& acr::zd_pdep_qLast() {
    acr::FPdep *row = NULL;
    row = _db.zd_pdep_tail;
    return *row;
}

// --- acr.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool acr::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- acr.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline acr::FCtype* acr::ctype_Find(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FCtype *retval = NULL;
    if (LIKELY(x <= u64(_db.ctype_n))) {
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FCtype* acr::ctype_Last() {
    return ctype_Find(i32(_db.ctype_n-1));
}

// --- acr.FDb.ctype.N
// Return number of items in the pool
inline i32 acr::ctype_N() {
    return _db.ctype_n;
}

// --- acr.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FCtype& acr::ctype_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- acr.FDb.anonfld.EmptyQ
// Return true if index is empty
inline bool acr::anonfld_EmptyQ() {
    return _db.anonfld_n == 0;
}

// --- acr.FDb.anonfld.Find
// Look up row by row id. Return NULL if out of range
inline acr::FAnonfld* acr::anonfld_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FAnonfld *retval = NULL;
    if (LIKELY(x <= u64(_db.anonfld_n))) {
        retval = &_db.anonfld_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.anonfld.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FAnonfld* acr::anonfld_Last() {
    return anonfld_Find(u64(_db.anonfld_n-1));
}

// --- acr.FDb.anonfld.N
// Return number of items in the pool
inline i32 acr::anonfld_N() {
    return _db.anonfld_n;
}

// --- acr.FDb.anonfld.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FAnonfld& acr::anonfld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.anonfld_lary[bsr][index];
}

// --- acr.FDb.cdflt.EmptyQ
// Return true if index is empty
inline bool acr::cdflt_EmptyQ() {
    return _db.cdflt_n == 0;
}

// --- acr.FDb.cdflt.Find
// Look up row by row id. Return NULL if out of range
inline acr::FCdflt* acr::cdflt_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FCdflt *retval = NULL;
    if (LIKELY(x <= u64(_db.cdflt_n))) {
        retval = &_db.cdflt_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.cdflt.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FCdflt* acr::cdflt_Last() {
    return cdflt_Find(u64(_db.cdflt_n-1));
}

// --- acr.FDb.cdflt.N
// Return number of items in the pool
inline i32 acr::cdflt_N() {
    return _db.cdflt_n;
}

// --- acr.FDb.cdflt.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FCdflt& acr::cdflt_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cdflt_lary[bsr][index];
}

// --- acr.FDb.field.EmptyQ
// Return true if index is empty
inline bool acr::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- acr.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline acr::FField* acr::field_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FField *retval = NULL;
    if (LIKELY(x <= u64(_db.field_n))) {
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FField* acr::field_Last() {
    return field_Find(u64(_db.field_n-1));
}

// --- acr.FDb.field.N
// Return number of items in the pool
inline i32 acr::field_N() {
    return _db.field_n;
}

// --- acr.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FField& acr::field_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- acr.FDb.file.EmptyQ
// Return true if index is empty
inline bool acr::file_EmptyQ() {
    return _db.file_n == 0;
}

// --- acr.FDb.file.Find
// Look up row by row id. Return NULL if out of range
inline acr::FFile* acr::file_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FFile *retval = NULL;
    if (LIKELY(x <= u64(_db.file_n))) {
        retval = &_db.file_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.file.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FFile* acr::file_Last() {
    return file_Find(u64(_db.file_n-1));
}

// --- acr.FDb.file.N
// Return number of items in the pool
inline i32 acr::file_N() {
    return _db.file_n;
}

// --- acr.FDb.file.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FFile& acr::file_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.file_lary[bsr][index];
}

// --- acr.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool acr::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- acr.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 acr::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- acr.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool acr::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- acr.FDb.ind_field.N
// Return number of items in the hash
inline i32 acr::ind_field_N() {
    return _db.ind_field_n;
}

// --- acr.FDb.ind_file.EmptyQ
// Return true if hash is empty
inline bool acr::ind_file_EmptyQ() {
    return _db.ind_file_n == 0;
}

// --- acr.FDb.ind_file.N
// Return number of items in the hash
inline i32 acr::ind_file_N() {
    return _db.ind_file_n;
}

// --- acr.FDb.zd_all_selrec.EmptyQ
// Return true if index is empty
inline bool acr::zd_all_selrec_EmptyQ() {
    return _db.zd_all_selrec_head == NULL;
}

// --- acr.FDb.zd_all_selrec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FRec* acr::zd_all_selrec_First() {
    acr::FRec *row = NULL;
    row = _db.zd_all_selrec_head;
    return row;
}

// --- acr.FDb.zd_all_selrec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_all_selrec_InLlistQ(acr::FRec& row) {
    bool result = false;
    result = !(row.zd_all_selrec_next == (acr::FRec*)-1);
    return result;
}

// --- acr.FDb.zd_all_selrec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FRec* acr::zd_all_selrec_Last() {
    acr::FRec *row = NULL;
    row = _db.zd_all_selrec_tail;
    return row;
}

// --- acr.FDb.zd_all_selrec.N
// Return number of items in the linked list
inline i32 acr::zd_all_selrec_N() {
    return _db.zd_all_selrec_n;
}

// --- acr.FDb.zd_all_selrec.Next
// Return pointer to next element in the list
inline acr::FRec* acr::zd_all_selrec_Next(acr::FRec &row) {
    return row.zd_all_selrec_next;
}

// --- acr.FDb.zd_all_selrec.Prev
// Return pointer to previous element in the list
inline acr::FRec* acr::zd_all_selrec_Prev(acr::FRec &row) {
    return row.zd_all_selrec_prev;
}

// --- acr.FDb.zd_all_selrec.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FRec& acr::zd_all_selrec_qLast() {
    acr::FRec *row = NULL;
    row = _db.zd_all_selrec_tail;
    return *row;
}

// --- acr.FDb.zd_all_err.EmptyQ
// Return true if index is empty
inline bool acr::zd_all_err_EmptyQ() {
    return _db.zd_all_err_head == NULL;
}

// --- acr.FDb.zd_all_err.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FErr* acr::zd_all_err_First() {
    acr::FErr *row = NULL;
    row = _db.zd_all_err_head;
    return row;
}

// --- acr.FDb.zd_all_err.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_all_err_InLlistQ(acr::FErr& row) {
    bool result = false;
    result = !(row.zd_all_err_next == (acr::FErr*)-1);
    return result;
}

// --- acr.FDb.zd_all_err.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FErr* acr::zd_all_err_Last() {
    acr::FErr *row = NULL;
    row = _db.zd_all_err_tail;
    return row;
}

// --- acr.FDb.zd_all_err.N
// Return number of items in the linked list
inline i32 acr::zd_all_err_N() {
    return _db.zd_all_err_n;
}

// --- acr.FDb.zd_all_err.Next
// Return pointer to next element in the list
inline acr::FErr* acr::zd_all_err_Next(acr::FErr &row) {
    return row.zd_all_err_next;
}

// --- acr.FDb.zd_all_err.Prev
// Return pointer to previous element in the list
inline acr::FErr* acr::zd_all_err_Prev(acr::FErr &row) {
    return row.zd_all_err_prev;
}

// --- acr.FDb.zd_all_err.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FErr& acr::zd_all_err_qLast() {
    acr::FErr *row = NULL;
    row = _db.zd_all_err_tail;
    return *row;
}

// --- acr.FDb.zd_sel_ctype.EmptyQ
// Return true if index is empty
inline bool acr::zd_sel_ctype_EmptyQ() {
    return _db.zd_sel_ctype_head == NULL;
}

// --- acr.FDb.zd_sel_ctype.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FCtype* acr::zd_sel_ctype_First() {
    acr::FCtype *row = NULL;
    row = _db.zd_sel_ctype_head;
    return row;
}

// --- acr.FDb.zd_sel_ctype.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_sel_ctype_InLlistQ(acr::FCtype& row) {
    bool result = false;
    result = !(row.zd_sel_ctype_next == (acr::FCtype*)-1);
    return result;
}

// --- acr.FDb.zd_sel_ctype.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FCtype* acr::zd_sel_ctype_Last() {
    acr::FCtype *row = NULL;
    row = _db.zd_sel_ctype_tail;
    return row;
}

// --- acr.FDb.zd_sel_ctype.Next
// Return pointer to next element in the list
inline acr::FCtype* acr::zd_sel_ctype_Next(acr::FCtype &row) {
    return row.zd_sel_ctype_next;
}

// --- acr.FDb.zd_sel_ctype.Prev
// Return pointer to previous element in the list
inline acr::FCtype* acr::zd_sel_ctype_Prev(acr::FCtype &row) {
    return row.zd_sel_ctype_prev;
}

// --- acr.FDb.zd_sel_ctype.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FCtype& acr::zd_sel_ctype_qLast() {
    acr::FCtype *row = NULL;
    row = _db.zd_sel_ctype_tail;
    return *row;
}

// --- acr.FDb.bh_pline.EmptyQ
// Return true if index is empty
inline bool acr::bh_pline_EmptyQ() {
    return _db.bh_pline_n == 0;
}

// --- acr.FDb.bh_pline.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FPline* acr::bh_pline_First() {
    acr::FPline *row = NULL;
    if (_db.bh_pline_n > 0) {
        row = _db.bh_pline_elems[0];
    }
    return row;
}

// --- acr.FDb.bh_pline.InBheapQ
// Return true if row is in index, false otherwise
inline bool acr::bh_pline_InBheapQ(acr::FPline& row) {
    bool result = false;
    result = row.bh_pline_idx != -1;
    return result;
}

// --- acr.FDb.bh_pline.N
// Return number of items in the heap
inline i32 acr::bh_pline_N() {
    return _db.bh_pline_n;
}

// --- acr.FDb.substr.EmptyQ
// Return true if index is empty
inline bool acr::substr_EmptyQ() {
    return _db.substr_n == 0;
}

// --- acr.FDb.substr.Find
// Look up row by row id. Return NULL if out of range
inline acr::FSubstr* acr::substr_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FSubstr *retval = NULL;
    if (LIKELY(x <= u64(_db.substr_n))) {
        retval = &_db.substr_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.substr.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FSubstr* acr::substr_Last() {
    return substr_Find(u64(_db.substr_n-1));
}

// --- acr.FDb.substr.N
// Return number of items in the pool
inline i32 acr::substr_N() {
    return _db.substr_n;
}

// --- acr.FDb.substr.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FSubstr& acr::substr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.substr_lary[bsr][index];
}

// --- acr.FDb.ssimfile.EmptyQ
// Return true if index is empty
inline bool acr::ssimfile_EmptyQ() {
    return _db.ssimfile_n == 0;
}

// --- acr.FDb.ssimfile.Find
// Look up row by row id. Return NULL if out of range
inline acr::FSsimfile* acr::ssimfile_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FSsimfile *retval = NULL;
    if (LIKELY(x <= u64(_db.ssimfile_n))) {
        retval = &_db.ssimfile_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.ssimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FSsimfile* acr::ssimfile_Last() {
    return ssimfile_Find(u64(_db.ssimfile_n-1));
}

// --- acr.FDb.ssimfile.N
// Return number of items in the pool
inline i32 acr::ssimfile_N() {
    return _db.ssimfile_n;
}

// --- acr.FDb.ssimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FSsimfile& acr::ssimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimfile_lary[bsr][index];
}

// --- acr.FDb.tempkey.EmptyQ
// Return true if index is empty
inline bool acr::tempkey_EmptyQ() {
    return _db.tempkey_n == 0;
}

// --- acr.FDb.tempkey.Find
// Look up row by row id. Return NULL if out of range
inline acr::FTempkey* acr::tempkey_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FTempkey *retval = NULL;
    if (LIKELY(x <= u64(_db.tempkey_n))) {
        retval = &_db.tempkey_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.tempkey.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FTempkey* acr::tempkey_Last() {
    return tempkey_Find(u64(_db.tempkey_n-1));
}

// --- acr.FDb.tempkey.N
// Return number of items in the pool
inline i32 acr::tempkey_N() {
    return _db.tempkey_n;
}

// --- acr.FDb.tempkey.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FTempkey& acr::tempkey_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tempkey_lary[bsr][index];
}

// --- acr.FDb.ind_tempkey.EmptyQ
// Return true if hash is empty
inline bool acr::ind_tempkey_EmptyQ() {
    return _db.ind_tempkey_n == 0;
}

// --- acr.FDb.ind_tempkey.N
// Return number of items in the hash
inline i32 acr::ind_tempkey_N() {
    return _db.ind_tempkey_n;
}

// --- acr.FDb.ind_ssimfile.EmptyQ
// Return true if hash is empty
inline bool acr::ind_ssimfile_EmptyQ() {
    return _db.ind_ssimfile_n == 0;
}

// --- acr.FDb.ind_ssimfile.N
// Return number of items in the hash
inline i32 acr::ind_ssimfile_N() {
    return _db.ind_ssimfile_n;
}

// --- acr.FDb.zs_query.EmptyQ
// Return true if index is empty
inline bool acr::zs_query_EmptyQ() {
    return _db.zs_query_head == NULL;
}

// --- acr.FDb.zs_query.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FQuery* acr::zs_query_First() {
    acr::FQuery *row = NULL;
    row = _db.zs_query_head;
    return row;
}

// --- acr.FDb.zs_query.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zs_query_InLlistQ(acr::FQuery& row) {
    bool result = false;
    result = !(row.zs_query_next == (acr::FQuery*)-1);
    return result;
}

// --- acr.FDb.zs_query.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FQuery* acr::zs_query_Last() {
    acr::FQuery *row = NULL;
    row = _db.zs_query_tail;
    return row;
}

// --- acr.FDb.zs_query.Next
// Return pointer to next element in the list
inline acr::FQuery* acr::zs_query_Next(acr::FQuery &row) {
    return row.zs_query_next;
}

// --- acr.FDb.zs_query.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FQuery& acr::zs_query_qLast() {
    acr::FQuery *row = NULL;
    row = _db.zs_query_tail;
    return *row;
}

// --- acr.FDb.ssimsort.EmptyQ
// Return true if index is empty
inline bool acr::ssimsort_EmptyQ() {
    return _db.ssimsort_n == 0;
}

// --- acr.FDb.ssimsort.Find
// Look up row by row id. Return NULL if out of range
inline acr::FSsimsort* acr::ssimsort_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FSsimsort *retval = NULL;
    if (LIKELY(x <= u64(_db.ssimsort_n))) {
        retval = &_db.ssimsort_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.ssimsort.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FSsimsort* acr::ssimsort_Last() {
    return ssimsort_Find(u64(_db.ssimsort_n-1));
}

// --- acr.FDb.ssimsort.N
// Return number of items in the pool
inline i32 acr::ssimsort_N() {
    return _db.ssimsort_n;
}

// --- acr.FDb.ssimsort.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FSsimsort& acr::ssimsort_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimsort_lary[bsr][index];
}

// --- acr.FDb.ind_ssimsort.EmptyQ
// Return true if hash is empty
inline bool acr::ind_ssimsort_EmptyQ() {
    return _db.ind_ssimsort_n == 0;
}

// --- acr.FDb.ind_ssimsort.N
// Return number of items in the hash
inline i32 acr::ind_ssimsort_N() {
    return _db.ind_ssimsort_n;
}

// --- acr.FDb.smallstr.EmptyQ
// Return true if index is empty
inline bool acr::smallstr_EmptyQ() {
    return _db.smallstr_n == 0;
}

// --- acr.FDb.smallstr.Find
// Look up row by row id. Return NULL if out of range
inline acr::FSmallstr* acr::smallstr_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FSmallstr *retval = NULL;
    if (LIKELY(x <= u64(_db.smallstr_n))) {
        retval = &_db.smallstr_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.smallstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FSmallstr* acr::smallstr_Last() {
    return smallstr_Find(u64(_db.smallstr_n-1));
}

// --- acr.FDb.smallstr.N
// Return number of items in the pool
inline i32 acr::smallstr_N() {
    return _db.smallstr_n;
}

// --- acr.FDb.smallstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FSmallstr& acr::smallstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.smallstr_lary[bsr][index];
}

// --- acr.FDb.funique.EmptyQ
// Return true if index is empty
inline bool acr::funique_EmptyQ() {
    return _db.funique_n == 0;
}

// --- acr.FDb.funique.Find
// Look up row by row id. Return NULL if out of range
inline acr::FFunique* acr::funique_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FFunique *retval = NULL;
    if (LIKELY(x <= u64(_db.funique_n))) {
        retval = &_db.funique_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.funique.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FFunique* acr::funique_Last() {
    return funique_Find(u64(_db.funique_n-1));
}

// --- acr.FDb.funique.N
// Return number of items in the pool
inline i32 acr::funique_N() {
    return _db.funique_n;
}

// --- acr.FDb.funique.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FFunique& acr::funique_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.funique_lary[bsr][index];
}

// --- acr.FDb.ind_uniqueattr.EmptyQ
// Return true if hash is empty
inline bool acr::ind_uniqueattr_EmptyQ() {
    return _db.ind_uniqueattr_n == 0;
}

// --- acr.FDb.ind_uniqueattr.N
// Return number of items in the hash
inline i32 acr::ind_uniqueattr_N() {
    return _db.ind_uniqueattr_n;
}

// --- acr.FDb.bltin.EmptyQ
// Return true if index is empty
inline bool acr::bltin_EmptyQ() {
    return _db.bltin_n == 0;
}

// --- acr.FDb.bltin.Find
// Look up row by row id. Return NULL if out of range
inline acr::FBltin* acr::bltin_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FBltin *retval = NULL;
    if (LIKELY(x <= u64(_db.bltin_n))) {
        retval = &_db.bltin_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.bltin.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FBltin* acr::bltin_Last() {
    return bltin_Find(u64(_db.bltin_n-1));
}

// --- acr.FDb.bltin.N
// Return number of items in the pool
inline i32 acr::bltin_N() {
    return _db.bltin_n;
}

// --- acr.FDb.bltin.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FBltin& acr::bltin_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.bltin_lary[bsr][index];
}

// --- acr.FDb.bh_ctype_topo.EmptyQ
// Return true if index is empty
inline bool acr::bh_ctype_topo_EmptyQ() {
    return _db.bh_ctype_topo_n == 0;
}

// --- acr.FDb.bh_ctype_topo.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FCtype* acr::bh_ctype_topo_First() {
    acr::FCtype *row = NULL;
    if (_db.bh_ctype_topo_n > 0) {
        row = _db.bh_ctype_topo_elems[0];
    }
    return row;
}

// --- acr.FDb.bh_ctype_topo.InBheapQ
// Return true if row is in index, false otherwise
inline bool acr::bh_ctype_topo_InBheapQ(acr::FCtype& row) {
    bool result = false;
    result = row.bh_ctype_topo_idx != -1;
    return result;
}

// --- acr.FDb.bh_ctype_topo.N
// Return number of items in the heap
inline i32 acr::bh_ctype_topo_N() {
    return _db.bh_ctype_topo_n;
}

// --- acr.FDb.cppfunc.EmptyQ
// Return true if index is empty
inline bool acr::cppfunc_EmptyQ() {
    return _db.cppfunc_n == 0;
}

// --- acr.FDb.cppfunc.Find
// Look up row by row id. Return NULL if out of range
inline acr::FCppfunc* acr::cppfunc_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr::FCppfunc *retval = NULL;
    if (LIKELY(x <= u64(_db.cppfunc_n))) {
        retval = &_db.cppfunc_lary[bsr][index];
    }
    return retval;
}

// --- acr.FDb.cppfunc.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr::FCppfunc* acr::cppfunc_Last() {
    return cppfunc_Find(u64(_db.cppfunc_n-1));
}

// --- acr.FDb.cppfunc.N
// Return number of items in the pool
inline i32 acr::cppfunc_N() {
    return _db.cppfunc_n;
}

// --- acr.FDb.cppfunc.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr::FCppfunc& acr::cppfunc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cppfunc_lary[bsr][index];
}

// --- acr.FDb.zd_pline_curs.Reset
// cursor points to valid item
inline void acr::_db_zd_pline_curs_Reset(_db_zd_pline_curs &curs, acr::FDb &parent) {
    curs.row = parent.zd_pline_head;
}

// --- acr.FDb.zd_pline_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_zd_pline_curs_ValidQ(_db_zd_pline_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FDb.zd_pline_curs.Next
// proceed to next item
inline void acr::_db_zd_pline_curs_Next(_db_zd_pline_curs &curs) {
    curs.row = (*curs.row).zd_pline_next;
}

// --- acr.FDb.zd_pline_curs.Access
// item access
inline acr::FPline& acr::_db_zd_pline_curs_Access(_db_zd_pline_curs &curs) {
    return *curs.row;
}

// --- acr.FDb.zd_pdep_curs.Reset
// cursor points to valid item
inline void acr::_db_zd_pdep_curs_Reset(_db_zd_pdep_curs &curs, acr::FDb &parent) {
    curs.row = parent.zd_pdep_head;
}

// --- acr.FDb.zd_pdep_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_zd_pdep_curs_ValidQ(_db_zd_pdep_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FDb.zd_pdep_curs.Next
// proceed to next item
inline void acr::_db_zd_pdep_curs_Next(_db_zd_pdep_curs &curs) {
    curs.row = (*curs.row).zd_pdep_next;
}

// --- acr.FDb.zd_pdep_curs.Access
// item access
inline acr::FPdep& acr::_db_zd_pdep_curs_Access(_db_zd_pdep_curs &curs) {
    return *curs.row;
}

// --- acr.FDb.ctype_curs.Reset
// cursor points to valid item
inline void acr::_db_ctype_curs_Reset(_db_ctype_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- acr.FDb.ctype_curs.Next
// proceed to next item
inline void acr::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- acr.FDb.ctype_curs.Access
// item access
inline acr::FCtype& acr::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(i32(curs.index));
}

// --- acr.FDb.anonfld_curs.Reset
// cursor points to valid item
inline void acr::_db_anonfld_curs_Reset(_db_anonfld_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.anonfld_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_anonfld_curs_ValidQ(_db_anonfld_curs &curs) {
    return curs.index < _db.anonfld_n;
}

// --- acr.FDb.anonfld_curs.Next
// proceed to next item
inline void acr::_db_anonfld_curs_Next(_db_anonfld_curs &curs) {
    curs.index++;
}

// --- acr.FDb.anonfld_curs.Access
// item access
inline acr::FAnonfld& acr::_db_anonfld_curs_Access(_db_anonfld_curs &curs) {
    return anonfld_qFind(u64(curs.index));
}

// --- acr.FDb.cdflt_curs.Reset
// cursor points to valid item
inline void acr::_db_cdflt_curs_Reset(_db_cdflt_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.cdflt_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_cdflt_curs_ValidQ(_db_cdflt_curs &curs) {
    return curs.index < _db.cdflt_n;
}

// --- acr.FDb.cdflt_curs.Next
// proceed to next item
inline void acr::_db_cdflt_curs_Next(_db_cdflt_curs &curs) {
    curs.index++;
}

// --- acr.FDb.cdflt_curs.Access
// item access
inline acr::FCdflt& acr::_db_cdflt_curs_Access(_db_cdflt_curs &curs) {
    return cdflt_qFind(u64(curs.index));
}

// --- acr.FDb.field_curs.Reset
// cursor points to valid item
inline void acr::_db_field_curs_Reset(_db_field_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- acr.FDb.field_curs.Next
// proceed to next item
inline void acr::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- acr.FDb.field_curs.Access
// item access
inline acr::FField& acr::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u64(curs.index));
}

// --- acr.FDb.file_curs.Reset
// cursor points to valid item
inline void acr::_db_file_curs_Reset(_db_file_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.file_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_file_curs_ValidQ(_db_file_curs &curs) {
    return curs.index < _db.file_n;
}

// --- acr.FDb.file_curs.Next
// proceed to next item
inline void acr::_db_file_curs_Next(_db_file_curs &curs) {
    curs.index++;
}

// --- acr.FDb.file_curs.Access
// item access
inline acr::FFile& acr::_db_file_curs_Access(_db_file_curs &curs) {
    return file_qFind(u64(curs.index));
}

// --- acr.FDb.zd_all_selrec_curs.Reset
// cursor points to valid item
inline void acr::_db_zd_all_selrec_curs_Reset(_db_zd_all_selrec_curs &curs, acr::FDb &parent) {
    curs.row = parent.zd_all_selrec_head;
}

// --- acr.FDb.zd_all_selrec_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_zd_all_selrec_curs_ValidQ(_db_zd_all_selrec_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FDb.zd_all_selrec_curs.Next
// proceed to next item
inline void acr::_db_zd_all_selrec_curs_Next(_db_zd_all_selrec_curs &curs) {
    curs.row = (*curs.row).zd_all_selrec_next;
}

// --- acr.FDb.zd_all_selrec_curs.Access
// item access
inline acr::FRec& acr::_db_zd_all_selrec_curs_Access(_db_zd_all_selrec_curs &curs) {
    return *curs.row;
}

// --- acr.FDb.zd_all_err_curs.Reset
// cursor points to valid item
inline void acr::_db_zd_all_err_curs_Reset(_db_zd_all_err_curs &curs, acr::FDb &parent) {
    curs.row = parent.zd_all_err_head;
}

// --- acr.FDb.zd_all_err_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_zd_all_err_curs_ValidQ(_db_zd_all_err_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FDb.zd_all_err_curs.Next
// proceed to next item
inline void acr::_db_zd_all_err_curs_Next(_db_zd_all_err_curs &curs) {
    curs.row = (*curs.row).zd_all_err_next;
}

// --- acr.FDb.zd_all_err_curs.Access
// item access
inline acr::FErr& acr::_db_zd_all_err_curs_Access(_db_zd_all_err_curs &curs) {
    return *curs.row;
}

// --- acr.FDb.zd_sel_ctype_curs.Reset
// cursor points to valid item
inline void acr::_db_zd_sel_ctype_curs_Reset(_db_zd_sel_ctype_curs &curs, acr::FDb &parent) {
    curs.row = parent.zd_sel_ctype_head;
}

// --- acr.FDb.zd_sel_ctype_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_zd_sel_ctype_curs_ValidQ(_db_zd_sel_ctype_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FDb.zd_sel_ctype_curs.Next
// proceed to next item
inline void acr::_db_zd_sel_ctype_curs_Next(_db_zd_sel_ctype_curs &curs) {
    curs.row = (*curs.row).zd_sel_ctype_next;
}

// --- acr.FDb.zd_sel_ctype_curs.Access
// item access
inline acr::FCtype& acr::_db_zd_sel_ctype_curs_Access(_db_zd_sel_ctype_curs &curs) {
    return *curs.row;
}

// --- acr.FDb.bh_pline_curs.Access
// Access current element. If not more elements, return NULL
inline acr::FPline& acr::_db_bh_pline_curs_Access(_db_bh_pline_curs &curs) {
    return *curs.temp_elems[0];
}

// --- acr.FDb.bh_pline_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool acr::_db_bh_pline_curs_ValidQ(_db_bh_pline_curs &curs) {
    return curs.temp_n > 0;
}

// --- acr.FDb.substr_curs.Reset
// cursor points to valid item
inline void acr::_db_substr_curs_Reset(_db_substr_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.substr_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_substr_curs_ValidQ(_db_substr_curs &curs) {
    return curs.index < _db.substr_n;
}

// --- acr.FDb.substr_curs.Next
// proceed to next item
inline void acr::_db_substr_curs_Next(_db_substr_curs &curs) {
    curs.index++;
}

// --- acr.FDb.substr_curs.Access
// item access
inline acr::FSubstr& acr::_db_substr_curs_Access(_db_substr_curs &curs) {
    return substr_qFind(u64(curs.index));
}

// --- acr.FDb.ssimfile_curs.Reset
// cursor points to valid item
inline void acr::_db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.ssimfile_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) {
    return curs.index < _db.ssimfile_n;
}

// --- acr.FDb.ssimfile_curs.Next
// proceed to next item
inline void acr::_db_ssimfile_curs_Next(_db_ssimfile_curs &curs) {
    curs.index++;
}

// --- acr.FDb.ssimfile_curs.Access
// item access
inline acr::FSsimfile& acr::_db_ssimfile_curs_Access(_db_ssimfile_curs &curs) {
    return ssimfile_qFind(u64(curs.index));
}

// --- acr.FDb.tempkey_curs.Reset
// cursor points to valid item
inline void acr::_db_tempkey_curs_Reset(_db_tempkey_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.tempkey_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_tempkey_curs_ValidQ(_db_tempkey_curs &curs) {
    return curs.index < _db.tempkey_n;
}

// --- acr.FDb.tempkey_curs.Next
// proceed to next item
inline void acr::_db_tempkey_curs_Next(_db_tempkey_curs &curs) {
    curs.index++;
}

// --- acr.FDb.tempkey_curs.Access
// item access
inline acr::FTempkey& acr::_db_tempkey_curs_Access(_db_tempkey_curs &curs) {
    return tempkey_qFind(u64(curs.index));
}

// --- acr.FDb.zs_query_curs.Reset
// cursor points to valid item
inline void acr::_db_zs_query_curs_Reset(_db_zs_query_curs &curs, acr::FDb &parent) {
    curs.row = parent.zs_query_head;
}

// --- acr.FDb.zs_query_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_zs_query_curs_ValidQ(_db_zs_query_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FDb.zs_query_curs.Next
// proceed to next item
inline void acr::_db_zs_query_curs_Next(_db_zs_query_curs &curs) {
    curs.row = (*curs.row).zs_query_next;
}

// --- acr.FDb.zs_query_curs.Access
// item access
inline acr::FQuery& acr::_db_zs_query_curs_Access(_db_zs_query_curs &curs) {
    return *curs.row;
}

// --- acr.FDb.ssimsort_curs.Reset
// cursor points to valid item
inline void acr::_db_ssimsort_curs_Reset(_db_ssimsort_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.ssimsort_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_ssimsort_curs_ValidQ(_db_ssimsort_curs &curs) {
    return curs.index < _db.ssimsort_n;
}

// --- acr.FDb.ssimsort_curs.Next
// proceed to next item
inline void acr::_db_ssimsort_curs_Next(_db_ssimsort_curs &curs) {
    curs.index++;
}

// --- acr.FDb.ssimsort_curs.Access
// item access
inline acr::FSsimsort& acr::_db_ssimsort_curs_Access(_db_ssimsort_curs &curs) {
    return ssimsort_qFind(u64(curs.index));
}

// --- acr.FDb.smallstr_curs.Reset
// cursor points to valid item
inline void acr::_db_smallstr_curs_Reset(_db_smallstr_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.smallstr_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_smallstr_curs_ValidQ(_db_smallstr_curs &curs) {
    return curs.index < _db.smallstr_n;
}

// --- acr.FDb.smallstr_curs.Next
// proceed to next item
inline void acr::_db_smallstr_curs_Next(_db_smallstr_curs &curs) {
    curs.index++;
}

// --- acr.FDb.smallstr_curs.Access
// item access
inline acr::FSmallstr& acr::_db_smallstr_curs_Access(_db_smallstr_curs &curs) {
    return smallstr_qFind(u64(curs.index));
}

// --- acr.FDb.funique_curs.Reset
// cursor points to valid item
inline void acr::_db_funique_curs_Reset(_db_funique_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.funique_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_funique_curs_ValidQ(_db_funique_curs &curs) {
    return curs.index < _db.funique_n;
}

// --- acr.FDb.funique_curs.Next
// proceed to next item
inline void acr::_db_funique_curs_Next(_db_funique_curs &curs) {
    curs.index++;
}

// --- acr.FDb.funique_curs.Access
// item access
inline acr::FFunique& acr::_db_funique_curs_Access(_db_funique_curs &curs) {
    return funique_qFind(u64(curs.index));
}

// --- acr.FDb.bltin_curs.Reset
// cursor points to valid item
inline void acr::_db_bltin_curs_Reset(_db_bltin_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.bltin_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_bltin_curs_ValidQ(_db_bltin_curs &curs) {
    return curs.index < _db.bltin_n;
}

// --- acr.FDb.bltin_curs.Next
// proceed to next item
inline void acr::_db_bltin_curs_Next(_db_bltin_curs &curs) {
    curs.index++;
}

// --- acr.FDb.bltin_curs.Access
// item access
inline acr::FBltin& acr::_db_bltin_curs_Access(_db_bltin_curs &curs) {
    return bltin_qFind(u64(curs.index));
}

// --- acr.FDb.bh_ctype_topo_curs.Access
// Access current element. If not more elements, return NULL
inline acr::FCtype& acr::_db_bh_ctype_topo_curs_Access(_db_bh_ctype_topo_curs &curs) {
    return *curs.temp_elems[0];
}

// --- acr.FDb.bh_ctype_topo_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool acr::_db_bh_ctype_topo_curs_ValidQ(_db_bh_ctype_topo_curs &curs) {
    return curs.temp_n > 0;
}

// --- acr.FDb.cppfunc_curs.Reset
// cursor points to valid item
inline void acr::_db_cppfunc_curs_Reset(_db_cppfunc_curs &curs, acr::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr.FDb.cppfunc_curs.ValidQ
// cursor points to valid item
inline bool acr::_db_cppfunc_curs_ValidQ(_db_cppfunc_curs &curs) {
    return curs.index < _db.cppfunc_n;
}

// --- acr.FDb.cppfunc_curs.Next
// proceed to next item
inline void acr::_db_cppfunc_curs_Next(_db_cppfunc_curs &curs) {
    curs.index++;
}

// --- acr.FDb.cppfunc_curs.Access
// item access
inline acr::FCppfunc& acr::_db_cppfunc_curs_Access(_db_cppfunc_curs &curs) {
    return cppfunc_qFind(u64(curs.index));
}
inline acr::FErr::FErr() {
    acr::FErr_Init(*this);
}

inline acr::FErr::~FErr() {
    acr::FErr_Uninit(*this);
}


// --- acr.FErr..Init
// Set all fields to initial values.
inline void acr::FErr_Init(acr::FErr& err) {
    err.ctype = NULL;
    err.id = u32(0);
    err.rec = NULL;
    err.fld = NULL;
    err.err_next = (acr::FErr*)-1; // (acr.FDb.err) not-in-tpool's freelist
    err.zd_all_err_next = (acr::FErr*)-1; // (acr.FDb.zd_all_err) not-in-list
    err.zd_all_err_prev = NULL; // (acr.FDb.zd_all_err)
}
inline acr::FEvalattr::FEvalattr(bool                           in_pick_dflt
        ,bool                           in_normalize
        ,acr::FField*                   in_field
        ,algo::Attr*                    in_attr
        ,const algo::strptr&            in_value
        ,const algo::i32_Range&         in_val_range)
    : pick_dflt(in_pick_dflt)
    , normalize(in_normalize)
    , field(in_field)
    , attr(in_attr)
    , value(in_value)
    , val_range(in_val_range)
{
}
inline acr::FEvalattr::FEvalattr() {
    acr::FEvalattr_Init(*this);
}


// --- acr.FEvalattr..Init
// Set all fields to initial values.
inline void acr::FEvalattr_Init(acr::FEvalattr& parent) {
    parent.pick_dflt = bool(false);
    parent.normalize = bool(false);
    parent.field = NULL;
    parent.attr = NULL;
}
inline acr::FField::FField() {
    acr::FField_Init(*this);
}

inline acr::FField::~FField() {
    acr::FField_Uninit(*this);
}


// --- acr.FField.c_substr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr::c_substr_InsertMaybe(acr::FField& field, acr::FSubstr& row) {
    acr::FSubstr* ptr = field.c_substr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_substr = &row;
    }
    return retval;
}

// --- acr.FField.c_substr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr::c_substr_Remove(acr::FField& field, acr::FSubstr& row) {
    acr::FSubstr *ptr = field.c_substr;
    if (LIKELY(ptr == &row)) {
        field.c_substr = NULL;
    }
}
inline acr::FFile::FFile() {
    acr::FFile_Init(*this);
}

inline acr::FFile::~FFile() {
    acr::FFile_Uninit(*this);
}


// --- acr.FFile.zd_frec.EmptyQ
// Return true if index is empty
inline bool acr::zd_frec_EmptyQ(acr::FFile& file) {
    return file.zd_frec_head == NULL;
}

// --- acr.FFile.zd_frec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FRec* acr::zd_frec_First(acr::FFile& file) {
    acr::FRec *row = NULL;
    row = file.zd_frec_head;
    return row;
}

// --- acr.FFile.zd_frec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_frec_InLlistQ(acr::FRec& row) {
    bool result = false;
    result = !(row.zd_frec_next == (acr::FRec*)-1);
    return result;
}

// --- acr.FFile.zd_frec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FRec* acr::zd_frec_Last(acr::FFile& file) {
    acr::FRec *row = NULL;
    row = file.zd_frec_tail;
    return row;
}

// --- acr.FFile.zd_frec.Next
// Return pointer to next element in the list
inline acr::FRec* acr::zd_frec_Next(acr::FRec &row) {
    return row.zd_frec_next;
}

// --- acr.FFile.zd_frec.Prev
// Return pointer to previous element in the list
inline acr::FRec* acr::zd_frec_Prev(acr::FRec &row) {
    return row.zd_frec_prev;
}

// --- acr.FFile.zd_frec.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FRec& acr::zd_frec_qLast(acr::FFile& file) {
    acr::FRec *row = NULL;
    row = file.zd_frec_tail;
    return *row;
}

// --- acr.FFile..Init
// Set all fields to initial values.
inline void acr::FFile_Init(acr::FFile& file) {
    file.ephemeral = bool(false);
    file.sticky = bool(false);
    file.lineno = u32(1);
    file.zd_frec_head = NULL; // (acr.FFile.zd_frec)
    file.zd_frec_tail = NULL; // (acr.FFile.zd_frec)
    file.autoloaded = bool(false);
    file.deselect = bool(false);
    file.ind_file_next = (acr::FFile*)-1; // (acr.FDb.ind_file) not-in-hash
}

// --- acr.FFile.zd_frec_curs.Reset
// cursor points to valid item
inline void acr::file_zd_frec_curs_Reset(file_zd_frec_curs &curs, acr::FFile &parent) {
    curs.row = parent.zd_frec_head;
}

// --- acr.FFile.zd_frec_curs.ValidQ
// cursor points to valid item
inline bool acr::file_zd_frec_curs_ValidQ(file_zd_frec_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FFile.zd_frec_curs.Next
// proceed to next item
inline void acr::file_zd_frec_curs_Next(file_zd_frec_curs &curs) {
    curs.row = (*curs.row).zd_frec_next;
}

// --- acr.FFile.zd_frec_curs.Access
// item access
inline acr::FRec& acr::file_zd_frec_curs_Access(file_zd_frec_curs &curs) {
    return *curs.row;
}
inline acr::FFunique::FFunique() {
}

inline acr::FPdep::FPdep() {
    acr::FPdep_Init(*this);
}

inline acr::FPdep::~FPdep() {
    acr::FPdep_Uninit(*this);
}


// --- acr.FPdep..Init
// Set all fields to initial values.
inline void acr::FPdep_Init(acr::FPdep& pdep) {
    pdep.p_parent = NULL;
    pdep.p_child = NULL;
    pdep.weight = i32(0);
    pdep.lindex = i32(0);
    pdep.pdep_next = (acr::FPdep*)-1; // (acr.FDb.pdep) not-in-tpool's freelist
    pdep.zd_pdep_next = (acr::FPdep*)-1; // (acr.FDb.zd_pdep) not-in-list
    pdep.zd_pdep_prev = NULL; // (acr.FDb.zd_pdep)
    pdep.zd_child_next = (acr::FPdep*)-1; // (acr.FPline.zd_child) not-in-list
    pdep.zd_child_prev = NULL; // (acr.FPline.zd_child)
}

inline bool acr::PlineKey::operator ==(const acr::PlineKey &rhs) const {
    return acr::PlineKey_Eq(const_cast<acr::PlineKey&>(*this),const_cast<acr::PlineKey&>(rhs));
}

inline bool acr::PlineKey::operator <(const acr::PlineKey &rhs) const {
    return acr::PlineKey_Lt(const_cast<acr::PlineKey&>(*this),const_cast<acr::PlineKey&>(rhs));
}
inline acr::PlineKey::PlineKey() {
    acr::PlineKey_Init(*this);
}


// --- acr.PlineKey..Hash
inline u32 acr::PlineKey_Hash(u32 prev, const acr::PlineKey & rhs) {
    prev = i32_Hash(prev, rhs.alldep);
    prev = i32_Hash(prev, rhs.negdepth);
    prev = i32_Hash(prev, rhs.ctype_rank);
    prev = i32_Hash(prev, rhs.rowid);
    return prev;
}

// --- acr.PlineKey..Lt
inline bool acr::PlineKey_Lt(acr::PlineKey & lhs, acr::PlineKey & rhs) {
    return PlineKey_Cmp(lhs,rhs) < 0;
}

// --- acr.PlineKey..Init
// Set all fields to initial values.
inline void acr::PlineKey_Init(acr::PlineKey& parent) {
    parent.alldep = i32(0);
    parent.negdepth = i32(0);
    parent.ctype_rank = i32(0);
    parent.rowid = i32(0);
}

// --- acr.PlineKey..Update
// Set value. Return true if new value is different from old value.
inline bool acr::PlineKey_Update(acr::PlineKey &lhs, acr::PlineKey & rhs) {
    bool ret = !PlineKey_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline acr::FPline::FPline() {
    acr::FPline_Init(*this);
}

inline acr::FPline::~FPline() {
    acr::FPline_Uninit(*this);
}


// --- acr.FPline.key.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool acr::key_Lt(acr::FPline& pline, acr::FPline &rhs) {
    return acr::PlineKey_Lt(pline.key,rhs.key);
}

// --- acr.FPline.key.Cmp
// Compare two fields.
inline i32 acr::key_Cmp(acr::FPline& pline, acr::FPline &rhs) {
    i32 retval = 0;
    retval = acr::PlineKey_Cmp(pline.key, rhs.key);
    return retval;
}

// --- acr.FPline.zd_child.EmptyQ
// Return true if index is empty
inline bool acr::zd_child_EmptyQ(acr::FPline& pline) {
    return pline.zd_child_head == NULL;
}

// --- acr.FPline.zd_child.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline acr::FPdep* acr::zd_child_First(acr::FPline& pline) {
    acr::FPdep *row = NULL;
    row = pline.zd_child_head;
    return row;
}

// --- acr.FPline.zd_child.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool acr::zd_child_InLlistQ(acr::FPdep& row) {
    bool result = false;
    result = !(row.zd_child_next == (acr::FPdep*)-1);
    return result;
}

// --- acr.FPline.zd_child.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline acr::FPdep* acr::zd_child_Last(acr::FPline& pline) {
    acr::FPdep *row = NULL;
    row = pline.zd_child_tail;
    return row;
}

// --- acr.FPline.zd_child.Next
// Return pointer to next element in the list
inline acr::FPdep* acr::zd_child_Next(acr::FPdep &row) {
    return row.zd_child_next;
}

// --- acr.FPline.zd_child.Prev
// Return pointer to previous element in the list
inline acr::FPdep* acr::zd_child_Prev(acr::FPdep &row) {
    return row.zd_child_prev;
}

// --- acr.FPline.zd_child.qLast
// Return reference to last element in the index. No bounds checking.
inline acr::FPdep& acr::zd_child_qLast(acr::FPline& pline) {
    acr::FPdep *row = NULL;
    row = pline.zd_child_tail;
    return *row;
}

// --- acr.FPline..Init
// Set all fields to initial values.
inline void acr::FPline_Init(acr::FPline& pline) {
    pline.p_rec = NULL;
    pline.zd_child_head = NULL; // (acr.FPline.zd_child)
    pline.zd_child_tail = NULL; // (acr.FPline.zd_child)
    pline.pline_next = (acr::FPline*)-1; // (acr.FDb.pline) not-in-tpool's freelist
    pline.zd_pline_next = (acr::FPline*)-1; // (acr.FDb.zd_pline) not-in-list
    pline.zd_pline_prev = NULL; // (acr.FDb.zd_pline)
    pline.bh_pline_idx = -1; // (acr.FDb.bh_pline) not-in-heap
}

// --- acr.FPline.zd_child_curs.Reset
// cursor points to valid item
inline void acr::pline_zd_child_curs_Reset(pline_zd_child_curs &curs, acr::FPline &parent) {
    curs.row = parent.zd_child_head;
}

// --- acr.FPline.zd_child_curs.ValidQ
// cursor points to valid item
inline bool acr::pline_zd_child_curs_ValidQ(pline_zd_child_curs &curs) {
    return curs.row != NULL;
}

// --- acr.FPline.zd_child_curs.Next
// proceed to next item
inline void acr::pline_zd_child_curs_Next(pline_zd_child_curs &curs) {
    curs.row = (*curs.row).zd_child_next;
}

// --- acr.FPline.zd_child_curs.Access
// item access
inline acr::FPdep& acr::pline_zd_child_curs_Access(pline_zd_child_curs &curs) {
    return *curs.row;
}
inline acr::FPrint::FPrint() {
    acr::FPrint_Init(*this);
}

inline acr::FPrint::~FPrint() {
    acr::FPrint_Uninit(*this);
}


// --- acr.FPrint.ind_printattr.EmptyQ
// Return true if hash is empty
inline bool acr::ind_printattr_EmptyQ(acr::FPrint& print) {
    return print.ind_printattr_n == 0;
}

// --- acr.FPrint.ind_printattr.N
// Return number of items in the hash
inline i32 acr::ind_printattr_N(const acr::FPrint& print) {
    return print.ind_printattr_n;
}

// --- acr.FPrint.c_pline.EmptyQ
// Return true if index is empty
inline bool acr::c_pline_EmptyQ(acr::FPrint& print) {
    return print.c_pline_n == 0;
}

// --- acr.FPrint.c_pline.Find
// Look up row by row id. Return NULL if out of range
inline acr::FPline* acr::c_pline_Find(acr::FPrint& print, u32 t) {
    acr::FPline *retval = NULL;
    u64 idx = t;
    u64 lim = print.c_pline_n;
    if (idx < lim) {
        retval = print.c_pline_elems[idx];
    }
    return retval;
}

// --- acr.FPrint.c_pline.Getary
// Return array of pointers
inline algo::aryptr<acr::FPline*> acr::c_pline_Getary(acr::FPrint& print) {
    return algo::aryptr<acr::FPline*>(print.c_pline_elems, print.c_pline_n);
}

// --- acr.FPrint.c_pline.N
// Return number of items in the pointer array
inline i32 acr::c_pline_N(const acr::FPrint& print) {
    return print.c_pline_n;
}

// --- acr.FPrint.c_pline.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_pline_RemoveAll(acr::FPrint& print) {
    print.c_pline_n = 0;
}

// --- acr.FPrint.c_pline_curs.Reset
inline void acr::print_c_pline_curs_Reset(print_c_pline_curs &curs, acr::FPrint &parent) {
    curs.elems = parent.c_pline_elems;
    curs.n_elems = parent.c_pline_n;
    curs.index = 0;
}

// --- acr.FPrint.c_pline_curs.ValidQ
// cursor points to valid item
inline bool acr::print_c_pline_curs_ValidQ(print_c_pline_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FPrint.c_pline_curs.Next
// proceed to next item
inline void acr::print_c_pline_curs_Next(print_c_pline_curs &curs) {
    curs.index++;
}

// --- acr.FPrint.c_pline_curs.Access
// item access
inline acr::FPline& acr::print_c_pline_curs_Access(print_c_pline_curs &curs) {
    return *curs.elems[curs.index];
}
inline acr::FPrintAttr::FPrintAttr() {
    acr::FPrintAttr_Init(*this);
}

inline acr::FPrintAttr::~FPrintAttr() {
    acr::FPrintAttr_Uninit(*this);
}


// --- acr.FPrintAttr..Init
// Set all fields to initial values.
inline void acr::FPrintAttr_Init(acr::FPrintAttr& printattr) {
    printattr.p_print = NULL;
    printattr.field = algo::strptr(0);
    printattr.width = u32(0);
    printattr.ind_printattr_next = (acr::FPrintAttr*)-1; // (acr.FPrint.ind_printattr) not-in-hash
}
inline acr::Queryop::Queryop(u8                             in_value)
    : value(in_value)
{
}
inline acr::Queryop::Queryop(acr_Queryop_value_Enum arg) { this->value = u8(arg); }
inline acr::Queryop::Queryop() {
    acr::Queryop_Init(*this);
}


// --- acr.Queryop.value.GetEnum
// Get value of field as enum type
inline acr_Queryop_value_Enum acr::value_GetEnum(const acr::Queryop& parent) {
    return acr_Queryop_value_Enum(parent.value);
}

// --- acr.Queryop.value.SetEnum
// Set value of field from enum type.
inline void acr::value_SetEnum(acr::Queryop& parent, acr_Queryop_value_Enum rhs) {
    parent.value = u8(rhs);
}

// --- acr.Queryop.value.Cast
inline acr::Queryop::operator acr_Queryop_value_Enum () const {
    return acr_Queryop_value_Enum((*this).value);
}

// --- acr.Queryop..Init
// Set all fields to initial values.
inline void acr::Queryop_Init(acr::Queryop& parent) {
    parent.value = u8(0);
}
inline acr::FQuery::FQuery() {
    acr::FQuery_Init(*this);
}

inline acr::FQuery::~FQuery() {
    acr::FQuery_Uninit(*this);
}


inline bool acr::RecSortkey::operator ==(const acr::RecSortkey &rhs) const {
    return acr::RecSortkey_Eq(const_cast<acr::RecSortkey&>(*this),const_cast<acr::RecSortkey&>(rhs));
}

inline bool acr::RecSortkey::operator <(const acr::RecSortkey &rhs) const {
    return acr::RecSortkey_Lt(const_cast<acr::RecSortkey&>(*this),const_cast<acr::RecSortkey&>(rhs));
}
inline acr::RecSortkey::RecSortkey() {
    acr::RecSortkey_Init(*this);
}


// --- acr.RecSortkey..Hash
inline u32 acr::RecSortkey_Hash(u32 prev, const acr::RecSortkey & rhs) {
    prev = double_Hash(prev, rhs.num);
    prev = cstring_Hash(prev, rhs.str);
    prev = float_Hash(prev, rhs.rowid);
    return prev;
}

// --- acr.RecSortkey..Lt
inline bool acr::RecSortkey_Lt(acr::RecSortkey & lhs, acr::RecSortkey & rhs) {
    return RecSortkey_Cmp(lhs,rhs) < 0;
}

// --- acr.RecSortkey..Cmp
inline i32 acr::RecSortkey_Cmp(acr::RecSortkey & lhs, acr::RecSortkey & rhs) {
    i32 retval = 0;
    retval = double_Cmp(lhs.num, rhs.num);
    if (retval != 0) {
        return retval;
    }
    retval = algo::cstring_Cmp(lhs.str, rhs.str);
    if (retval != 0) {
        return retval;
    }
    retval = float_Cmp(lhs.rowid, rhs.rowid);
    return retval;
}

// --- acr.RecSortkey..Init
// Set all fields to initial values.
inline void acr::RecSortkey_Init(acr::RecSortkey& parent) {
    parent.num = double(0.0);
    parent.rowid = float(0.f);
}

// --- acr.RecSortkey..Eq
inline bool acr::RecSortkey_Eq(const acr::RecSortkey & lhs,const acr::RecSortkey & rhs) {
    bool retval = true;
    retval = double_Eq(lhs.num, rhs.num);
    if (!retval) {
        return false;
    }
    retval = algo::cstring_Eq(lhs.str, rhs.str);
    if (!retval) {
        return false;
    }
    retval = float_Eq(lhs.rowid, rhs.rowid);
    return retval;
}

// --- acr.RecSortkey..Update
// Set value. Return true if new value is different from old value.
inline bool acr::RecSortkey_Update(acr::RecSortkey &lhs, acr::RecSortkey & rhs) {
    bool ret = !RecSortkey_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline acr::FRec::FRec() {
    acr::FRec_Init(*this);
}

inline acr::FRec::~FRec() {
    acr::FRec_Uninit(*this);
}


// --- acr.FRec.c_pline.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr::c_pline_InsertMaybe(acr::FRec& rec, acr::FPline& row) {
    acr::FPline* ptr = rec.c_pline;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        rec.c_pline = &row;
    }
    return retval;
}

// --- acr.FRec.c_pline.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr::c_pline_Remove(acr::FRec& rec, acr::FPline& row) {
    acr::FPline *ptr = rec.c_pline;
    if (LIKELY(ptr == &row)) {
        rec.c_pline = NULL;
    }
}
inline acr::FRun::FRun() {
    acr::FRun_Init(*this);
}

inline acr::FRun::~FRun() {
    acr::FRun_Uninit(*this);
}


// --- acr.FRun.c_ctype.EmptyQ
// Return true if index is empty
inline bool acr::c_ctype_EmptyQ(acr::FRun& run) {
    return run.c_ctype_n == 0;
}

// --- acr.FRun.c_ctype.Find
// Look up row by row id. Return NULL if out of range
inline acr::FCtype* acr::c_ctype_Find(acr::FRun& run, u32 t) {
    acr::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = run.c_ctype_n;
    if (idx < lim) {
        retval = run.c_ctype_elems[idx];
    }
    return retval;
}

// --- acr.FRun.c_ctype.Getary
// Return array of pointers
inline algo::aryptr<acr::FCtype*> acr::c_ctype_Getary(acr::FRun& run) {
    return algo::aryptr<acr::FCtype*>(run.c_ctype_elems, run.c_ctype_n);
}

// --- acr.FRun.c_ctype.N
// Return number of items in the pointer array
inline i32 acr::c_ctype_N(const acr::FRun& run) {
    return run.c_ctype_n;
}

// --- acr.FRun.c_ctype.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_ctype_RemoveAll(acr::FRun& run) {
    run.c_ctype_n = 0;
}

// --- acr.FRun.c_field.EmptyQ
// Return true if index is empty
inline bool acr::c_field_EmptyQ(acr::FRun& run) {
    return run.c_field_n == 0;
}

// --- acr.FRun.c_field.Find
// Look up row by row id. Return NULL if out of range
inline acr::FField* acr::c_field_Find(acr::FRun& run, u32 t) {
    acr::FField *retval = NULL;
    u64 idx = t;
    u64 lim = run.c_field_n;
    if (idx < lim) {
        retval = run.c_field_elems[idx];
    }
    return retval;
}

// --- acr.FRun.c_field.Getary
// Return array of pointers
inline algo::aryptr<acr::FField*> acr::c_field_Getary(acr::FRun& run) {
    return algo::aryptr<acr::FField*>(run.c_field_elems, run.c_field_n);
}

// --- acr.FRun.c_field.N
// Return number of items in the pointer array
inline i32 acr::c_field_N(const acr::FRun& run) {
    return run.c_field_n;
}

// --- acr.FRun.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_field_RemoveAll(acr::FRun& run) {
    run.c_field_n = 0;
}

// --- acr.FRun.c_rec.EmptyQ
// Return true if index is empty
inline bool acr::c_rec_EmptyQ(acr::FRun& run) {
    return run.c_rec_n == 0;
}

// --- acr.FRun.c_rec.Find
// Look up row by row id. Return NULL if out of range
inline acr::FRec* acr::c_rec_Find(acr::FRun& run, u32 t) {
    acr::FRec *retval = NULL;
    u64 idx = t;
    u64 lim = run.c_rec_n;
    if (idx < lim) {
        retval = run.c_rec_elems[idx];
    }
    return retval;
}

// --- acr.FRun.c_rec.Getary
// Return array of pointers
inline algo::aryptr<acr::FRec*> acr::c_rec_Getary(acr::FRun& run) {
    return algo::aryptr<acr::FRec*>(run.c_rec_elems, run.c_rec_n);
}

// --- acr.FRun.c_rec.N
// Return number of items in the pointer array
inline i32 acr::c_rec_N(const acr::FRun& run) {
    return run.c_rec_n;
}

// --- acr.FRun.c_rec.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_rec_RemoveAll(acr::FRun& run) {
    run.c_rec_n = 0;
}

// --- acr.FRun.c_child.EmptyQ
// Return true if index is empty
inline bool acr::c_child_EmptyQ(acr::FRun& run) {
    return run.c_child_n == 0;
}

// --- acr.FRun.c_child.Find
// Look up row by row id. Return NULL if out of range
inline acr::FCtype* acr::c_child_Find(acr::FRun& run, u32 t) {
    acr::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = run.c_child_n;
    if (idx < lim) {
        retval = run.c_child_elems[idx];
    }
    return retval;
}

// --- acr.FRun.c_child.Getary
// Return array of pointers
inline algo::aryptr<acr::FCtype*> acr::c_child_Getary(acr::FRun& run) {
    return algo::aryptr<acr::FCtype*>(run.c_child_elems, run.c_child_n);
}

// --- acr.FRun.c_child.N
// Return number of items in the pointer array
inline i32 acr::c_child_N(const acr::FRun& run) {
    return run.c_child_n;
}

// --- acr.FRun.c_child.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_child_RemoveAll(acr::FRun& run) {
    for (u32 i = 0; i < run.c_child_n; i++) {
        // mark all elements as not-in-array
        run.c_child_elems[i]->run_c_child_in_ary = false;
    }
    run.c_child_n = 0;
}

// --- acr.FRun.c_ctype_curs.Reset
inline void acr::run_c_ctype_curs_Reset(run_c_ctype_curs &curs, acr::FRun &parent) {
    curs.elems = parent.c_ctype_elems;
    curs.n_elems = parent.c_ctype_n;
    curs.index = 0;
}

// --- acr.FRun.c_ctype_curs.ValidQ
// cursor points to valid item
inline bool acr::run_c_ctype_curs_ValidQ(run_c_ctype_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FRun.c_ctype_curs.Next
// proceed to next item
inline void acr::run_c_ctype_curs_Next(run_c_ctype_curs &curs) {
    curs.index++;
}

// --- acr.FRun.c_ctype_curs.Access
// item access
inline acr::FCtype& acr::run_c_ctype_curs_Access(run_c_ctype_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FRun.c_field_curs.Reset
inline void acr::run_c_field_curs_Reset(run_c_field_curs &curs, acr::FRun &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- acr.FRun.c_field_curs.ValidQ
// cursor points to valid item
inline bool acr::run_c_field_curs_ValidQ(run_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FRun.c_field_curs.Next
// proceed to next item
inline void acr::run_c_field_curs_Next(run_c_field_curs &curs) {
    curs.index++;
}

// --- acr.FRun.c_field_curs.Access
// item access
inline acr::FField& acr::run_c_field_curs_Access(run_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FRun.c_rec_curs.Reset
inline void acr::run_c_rec_curs_Reset(run_c_rec_curs &curs, acr::FRun &parent) {
    curs.elems = parent.c_rec_elems;
    curs.n_elems = parent.c_rec_n;
    curs.index = 0;
}

// --- acr.FRun.c_rec_curs.ValidQ
// cursor points to valid item
inline bool acr::run_c_rec_curs_ValidQ(run_c_rec_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FRun.c_rec_curs.Next
// proceed to next item
inline void acr::run_c_rec_curs_Next(run_c_rec_curs &curs) {
    curs.index++;
}

// --- acr.FRun.c_rec_curs.Access
// item access
inline acr::FRec& acr::run_c_rec_curs_Access(run_c_rec_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FRun.c_child_curs.Reset
inline void acr::run_c_child_curs_Reset(run_c_child_curs &curs, acr::FRun &parent) {
    curs.elems = parent.c_child_elems;
    curs.n_elems = parent.c_child_n;
    curs.index = 0;
}

// --- acr.FRun.c_child_curs.ValidQ
// cursor points to valid item
inline bool acr::run_c_child_curs_ValidQ(run_c_child_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FRun.c_child_curs.Next
// proceed to next item
inline void acr::run_c_child_curs_Next(run_c_child_curs &curs) {
    curs.index++;
}

// --- acr.FRun.c_child_curs.Access
// item access
inline acr::FCtype& acr::run_c_child_curs_Access(run_c_child_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FRun..Init
// Set all fields to initial values.
inline void acr::FRun_Init(acr::FRun& run) {
    run.c_ctype_elems = NULL; // (acr.FRun.c_ctype)
    run.c_ctype_n = 0; // (acr.FRun.c_ctype)
    run.c_ctype_max = 0; // (acr.FRun.c_ctype)
    run.c_field_elems = NULL; // (acr.FRun.c_field)
    run.c_field_n = 0; // (acr.FRun.c_field)
    run.c_field_max = 0; // (acr.FRun.c_field)
    run.c_rec_elems = NULL; // (acr.FRun.c_rec)
    run.c_rec_n = 0; // (acr.FRun.c_rec)
    run.c_rec_max = 0; // (acr.FRun.c_rec)
    run.c_child_elems = NULL; // (acr.FRun.c_child)
    run.c_child_n = 0; // (acr.FRun.c_child)
    run.c_child_max = 0; // (acr.FRun.c_child)
}
inline acr::FSmallstr::FSmallstr() {
    acr::FSmallstr_Init(*this);
}


// --- acr.FSmallstr..Init
// Set all fields to initial values.
inline void acr::FSmallstr_Init(acr::FSmallstr& smallstr) {
    smallstr.length = i32(0);
    smallstr.strict = bool(false);
}
inline acr::FSsimfile::FSsimfile() {
    acr::FSsimfile_Init(*this);
}

inline acr::FSsimfile::~FSsimfile() {
    acr::FSsimfile_Uninit(*this);
}


// --- acr.FSsimfile.c_ssimsort.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr::c_ssimsort_InsertMaybe(acr::FSsimfile& ssimfile, acr::FSsimsort& row) {
    acr::FSsimsort* ptr = ssimfile.c_ssimsort;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ssimfile.c_ssimsort = &row;
    }
    return retval;
}

// --- acr.FSsimfile.c_ssimsort.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr::c_ssimsort_Remove(acr::FSsimfile& ssimfile, acr::FSsimsort& row) {
    acr::FSsimsort *ptr = ssimfile.c_ssimsort;
    if (LIKELY(ptr == &row)) {
        ssimfile.c_ssimsort = NULL;
    }
}

// --- acr.FSsimfile..Init
// Set all fields to initial values.
inline void acr::FSsimfile_Init(acr::FSsimfile& ssimfile) {
    ssimfile.c_file = NULL;
    ssimfile.p_ctype = NULL;
    ssimfile.c_ssimsort = NULL;
    ssimfile.ind_ssimfile_next = (acr::FSsimfile*)-1; // (acr.FDb.ind_ssimfile) not-in-hash
}
inline acr::FSsimsort::FSsimsort() {
    acr::FSsimsort_Init(*this);
}

inline acr::FSsimsort::~FSsimsort() {
    acr::FSsimsort_Uninit(*this);
}


// --- acr.FSsimsort..Init
// Set all fields to initial values.
inline void acr::FSsimsort_Init(acr::FSsimsort& ssimsort) {
    ssimsort.ind_ssimsort_next = (acr::FSsimsort*)-1; // (acr.FDb.ind_ssimsort) not-in-hash
}
inline acr::FSubstr::FSubstr() {
}

inline acr::FSubstr::~FSubstr() {
    acr::FSubstr_Uninit(*this);
}

inline acr::FTempkey::FTempkey() {
    acr::FTempkey_Init(*this);
}

inline acr::FTempkey::~FTempkey() {
    acr::FTempkey_Uninit(*this);
}


// --- acr.FTempkey..Init
// Set all fields to initial values.
inline void acr::FTempkey_Init(acr::FTempkey& tempkey) {
    tempkey.ind_tempkey_next = (acr::FTempkey*)-1; // (acr.FDb.ind_tempkey) not-in-hash
}
inline acr::FUniqueattr::FUniqueattr() {
    acr::FUniqueattr_Init(*this);
}

inline acr::FUniqueattr::~FUniqueattr() {
    acr::FUniqueattr_Uninit(*this);
}


// --- acr.FUniqueattr..Init
// Set all fields to initial values.
inline void acr::FUniqueattr_Init(acr::FUniqueattr& uniqueattr) {
    uniqueattr.uniqueattr_next = (acr::FUniqueattr*)-1; // (acr.FDb.uniqueattr) not-in-tpool's freelist
    uniqueattr.ind_uniqueattr_next = (acr::FUniqueattr*)-1; // (acr.FDb.ind_uniqueattr) not-in-hash
}
inline acr::FWrite::FWrite() {
    acr::FWrite_Init(*this);
}

inline acr::FWrite::~FWrite() {
    acr::FWrite_Uninit(*this);
}


// --- acr.FWrite.c_cmtrec.EmptyQ
// Return true if index is empty
inline bool acr::c_cmtrec_EmptyQ(acr::FWrite& write) {
    return write.c_cmtrec_n == 0;
}

// --- acr.FWrite.c_cmtrec.Find
// Look up row by row id. Return NULL if out of range
inline acr::FRec* acr::c_cmtrec_Find(acr::FWrite& write, u32 t) {
    acr::FRec *retval = NULL;
    u64 idx = t;
    u64 lim = write.c_cmtrec_n;
    if (idx < lim) {
        retval = write.c_cmtrec_elems[idx];
    }
    return retval;
}

// --- acr.FWrite.c_cmtrec.Getary
// Return array of pointers
inline algo::aryptr<acr::FRec*> acr::c_cmtrec_Getary(acr::FWrite& write) {
    return algo::aryptr<acr::FRec*>(write.c_cmtrec_elems, write.c_cmtrec_n);
}

// --- acr.FWrite.c_cmtrec.N
// Return number of items in the pointer array
inline i32 acr::c_cmtrec_N(const acr::FWrite& write) {
    return write.c_cmtrec_n;
}

// --- acr.FWrite.c_cmtrec.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr::c_cmtrec_RemoveAll(acr::FWrite& write) {
    write.c_cmtrec_n = 0;
}

// --- acr.FWrite.c_cmtrec_curs.Reset
inline void acr::write_c_cmtrec_curs_Reset(write_c_cmtrec_curs &curs, acr::FWrite &parent) {
    curs.elems = parent.c_cmtrec_elems;
    curs.n_elems = parent.c_cmtrec_n;
    curs.index = 0;
}

// --- acr.FWrite.c_cmtrec_curs.ValidQ
// cursor points to valid item
inline bool acr::write_c_cmtrec_curs_ValidQ(write_c_cmtrec_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr.FWrite.c_cmtrec_curs.Next
// proceed to next item
inline void acr::write_c_cmtrec_curs_Next(write_c_cmtrec_curs &curs) {
    curs.index++;
}

// --- acr.FWrite.c_cmtrec_curs.Access
// item access
inline acr::FRec& acr::write_c_cmtrec_curs_Access(write_c_cmtrec_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr.FWrite..Init
// Set all fields to initial values.
inline void acr::FWrite_Init(acr::FWrite& write) {
    write.c_cmtrec_elems = NULL; // (acr.FWrite.c_cmtrec)
    write.c_cmtrec_n = 0; // (acr.FWrite.c_cmtrec)
    write.c_cmtrec_max = 0; // (acr.FWrite.c_cmtrec)
}
inline acr::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline acr::FieldId::FieldId(acr_FieldIdEnum arg) { this->value = i32(arg); }
inline acr::FieldId::FieldId() {
    acr::FieldId_Init(*this);
}


// --- acr.FieldId.value.GetEnum
// Get value of field as enum type
inline acr_FieldIdEnum acr::value_GetEnum(const acr::FieldId& parent) {
    return acr_FieldIdEnum(parent.value);
}

// --- acr.FieldId.value.SetEnum
// Set value of field from enum type.
inline void acr::value_SetEnum(acr::FieldId& parent, acr_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr.FieldId.value.Cast
inline acr::FieldId::operator acr_FieldIdEnum () const {
    return acr_FieldIdEnum((*this).value);
}

// --- acr.FieldId..Init
// Set all fields to initial values.
inline void acr::FieldId_Init(acr::FieldId& parent) {
    parent.value = i32(-1);
}
inline acr::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline acr::TableId::TableId(acr_TableIdEnum arg) { this->value = i32(arg); }
inline acr::TableId::TableId() {
    acr::TableId_Init(*this);
}


// --- acr.TableId.value.GetEnum
// Get value of field as enum type
inline acr_TableIdEnum acr::value_GetEnum(const acr::TableId& parent) {
    return acr_TableIdEnum(parent.value);
}

// --- acr.TableId.value.SetEnum
// Set value of field from enum type.
inline void acr::value_SetEnum(acr::TableId& parent, acr_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr.TableId.value.Cast
inline acr::TableId::operator acr_TableIdEnum () const {
    return acr_TableIdEnum((*this).value);
}

// --- acr.TableId..Init
// Set all fields to initial values.
inline void acr::TableId_Init(acr::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr::CtypeTopoKey &row) {// cfmt:acr.CtypeTopoKey.String
    acr::CtypeTopoKey_Print(const_cast<acr::CtypeTopoKey&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr::trace &row) {// cfmt:acr.trace.String
    acr::trace_Print(const_cast<acr::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr::PlineKey &row) {// cfmt:acr.PlineKey.String
    acr::PlineKey_Print(const_cast<acr::PlineKey&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr::Queryop &row) {// cfmt:acr.Queryop.String
    acr::Queryop_Print(const_cast<acr::Queryop&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr::FieldId &row) {// cfmt:acr.FieldId.String
    acr::FieldId_Print(const_cast<acr::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr::TableId &row) {// cfmt:acr.TableId.String
    acr::TableId_Print(const_cast<acr::TableId&>(row), str);
    return str;
}
