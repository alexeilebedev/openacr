//
// include/gen/atf_norm_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/dev_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/dmmeta_gen.h"
//#pragma endinclude

// --- atf_norm_FieldIdEnum

enum atf_norm_FieldIdEnum {        // atf_norm.FieldId.value
     atf_norm_FieldId_value   = 0
};

enum { atf_norm_FieldIdEnum_N = 1 };


// --- atf_norm_TableIdEnum

enum atf_norm_TableIdEnum {                   // atf_norm.TableId.value
     atf_norm_TableId_dev_Builddir      = 0   // dev.Builddir -> atf_norm.FBuilddir
    ,atf_norm_TableId_dev_builddir      = 0   // dev.builddir -> atf_norm.FBuilddir
    ,atf_norm_TableId_dev_Cfg           = 1   // dev.Cfg -> atf_norm.FCfg
    ,atf_norm_TableId_dev_cfg           = 1   // dev.cfg -> atf_norm.FCfg
    ,atf_norm_TableId_dev_Gitfile       = 2   // dev.Gitfile -> atf_norm.FGitfile
    ,atf_norm_TableId_dev_gitfile       = 2   // dev.gitfile -> atf_norm.FGitfile
    ,atf_norm_TableId_dev_Noindent      = 3   // dev.Noindent -> atf_norm.FNoindent
    ,atf_norm_TableId_dev_noindent      = 3   // dev.noindent -> atf_norm.FNoindent
    ,atf_norm_TableId_dmmeta_Ns         = 4   // dmmeta.Ns -> atf_norm.FNs
    ,atf_norm_TableId_dmmeta_ns         = 4   // dmmeta.ns -> atf_norm.FNs
    ,atf_norm_TableId_dev_Readme        = 5   // dev.Readme -> atf_norm.FReadme
    ,atf_norm_TableId_dev_readme        = 5   // dev.readme -> atf_norm.FReadme
    ,atf_norm_TableId_dev_Scriptfile    = 6   // dev.Scriptfile -> atf_norm.FScriptfile
    ,atf_norm_TableId_dev_scriptfile    = 6   // dev.scriptfile -> atf_norm.FScriptfile
    ,atf_norm_TableId_dmmeta_Ssimfile   = 7   // dmmeta.Ssimfile -> atf_norm.FSsimfile
    ,atf_norm_TableId_dmmeta_ssimfile   = 7   // dmmeta.ssimfile -> atf_norm.FSsimfile
    ,atf_norm_TableId_dev_Targsrc       = 8   // dev.Targsrc -> atf_norm.FTargsrc
    ,atf_norm_TableId_dev_targsrc       = 8   // dev.targsrc -> atf_norm.FTargsrc
};

enum { atf_norm_TableIdEnum_N = 18 };

namespace dev { struct Builddir; }
namespace dev { struct Cfg; }
namespace dev { struct Gitfile; }
namespace dev { struct Noindent; }
namespace atfdb { struct Normcheck; }
namespace dmmeta { struct Ns; }
namespace dev { struct Readme; }
namespace dev { struct Scriptfile; }
namespace dmmeta { struct Ssimfile; }
namespace dev { struct Targsrc; }
namespace atf_norm { struct FBuilddir; }
namespace atf_norm { struct FCfg; }
namespace atf_norm { struct trace; }
namespace atf_norm { struct FDb; }
namespace atf_norm { struct FGitfile; }
namespace atf_norm { struct FNoindent; }
namespace atf_norm { struct FNormcheck; }
namespace atf_norm { struct FNs; }
namespace atf_norm { struct FReadme; }
namespace atf_norm { struct FScriptfile; }
namespace atf_norm { struct FSsimfile; }
namespace atf_norm { struct FTargsrc; }
namespace atf_norm { struct FieldId; }
namespace atf_norm { struct TableId; }
namespace atf_norm { struct _db_normcheck_curs; }
namespace atf_norm { struct _db_ssimfile_curs; }
namespace atf_norm { struct _db_ind_ssimfile_curs; }
namespace atf_norm { struct _db_scriptfile_curs; }
namespace atf_norm { struct _db_ind_scriptfile_curs; }
namespace atf_norm { struct _db_ns_curs; }
namespace atf_norm { struct _db_ind_ns_curs; }
namespace atf_norm { struct _db_readme_curs; }
namespace atf_norm { struct _db_builddir_curs; }
namespace atf_norm { struct _db_cfg_curs; }
namespace atf_norm { struct _db_ind_builddir_curs; }
namespace atf_norm { struct _db_gitfile_curs; }
namespace atf_norm { struct _db_ind_gitfile_curs; }
namespace atf_norm { struct _db_noindent_curs; }
namespace atf_norm { struct _db_targsrc_curs; }
namespace atf_norm {
}//pkey typedefs
namespace atf_norm {
extern const char *atf_norm_help;
extern const char *atf_norm_syntax;
extern FDb _db;
typedef void (*normcheck_step_hook)();
extern const char *dev_scriptfile_bin_update_gitfile; // "bin/update-gitfile"
extern const char *dev_scriptfile_bin_update_scriptfile; // "bin/update-scriptfile"

// --- atf_norm.FBuilddir
// create: atf_norm.FDb.builddir (Lary)
// global access: ind_builddir (Thash)
struct FBuilddir { // atf_norm.FBuilddir
    algo::Smallstr50       builddir;            //
    algo::Comment          comment;             //
    atf_norm::FBuilddir*   ind_builddir_next;   // hash next
private:
    friend atf_norm::FBuilddir& builddir_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FBuilddir* builddir_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 builddir_RemoveAll() __attribute__((nothrow));
    friend void                 builddir_RemoveLast() __attribute__((nothrow));
    FBuilddir();
    ~FBuilddir();
    FBuilddir(const FBuilddir&){ /*disallow copy constructor */}
    void operator =(const FBuilddir&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 builddir_CopyOut(atf_norm::FBuilddir &row, dev::Builddir &out) __attribute__((nothrow));
// Copy fields in to row
void                 builddir_CopyIn(atf_norm::FBuilddir &row, dev::Builddir &in) __attribute__((nothrow));

algo::Smallstr50     uname_Get(atf_norm::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     compiler_Get(atf_norm::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     cfg_Get(atf_norm::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     arch_Get(atf_norm::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FBuilddir_Init(atf_norm::FBuilddir& builddir);
void                 FBuilddir_Uninit(atf_norm::FBuilddir& builddir) __attribute__((nothrow));

// --- atf_norm.FCfg
// create: atf_norm.FDb.cfg (Lary)
struct FCfg { // atf_norm.FCfg
    algo::Smallstr50   cfg;       //
    algo::Smallstr5    suffix;    //
    algo::Comment      comment;   //
private:
    friend atf_norm::FCfg&      cfg_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FCfg*      cfg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfg_RemoveAll() __attribute__((nothrow));
    friend void                 cfg_RemoveLast() __attribute__((nothrow));
    FCfg();
};

// Copy fields out of row
void                 cfg_CopyOut(atf_norm::FCfg &row, dev::Cfg &out) __attribute__((nothrow));
// Copy fields in to row
void                 cfg_CopyIn(atf_norm::FCfg &row, dev::Cfg &in) __attribute__((nothrow));


// --- atf_norm.trace
#pragma pack(push,1)
struct trace { // atf_norm.trace
    trace();
};
#pragma pack(pop)

// print string representation of atf_norm::trace to string LHS, no header -- cprint:atf_norm.trace.String
void                 trace_Print(atf_norm::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_norm.FDb
// create: atf_norm.FDb._db (Global)
struct FDb { // atf_norm.FDb
    command::atf_norm         cmdline;                        //
    atf_norm::FNormcheck*     normcheck_lary[32];             // level array
    i32                       normcheck_n;                    // number of elements in array
    atf_norm::FSsimfile*      ssimfile_lary[32];              // level array
    i32                       ssimfile_n;                     // number of elements in array
    atf_norm::FSsimfile**     ind_ssimfile_buckets_elems;     // pointer to bucket array
    i32                       ind_ssimfile_buckets_n;         // number of elements in bucket array
    i32                       ind_ssimfile_n;                 // number of elements in the hash table
    atf_norm::FNormcheck*     c_normcheck;                    // optional pointer
    atf_norm::FScriptfile*    scriptfile_lary[32];            // level array
    i32                       scriptfile_n;                   // number of elements in array
    atf_norm::FScriptfile**   ind_scriptfile_buckets_elems;   // pointer to bucket array
    i32                       ind_scriptfile_buckets_n;       // number of elements in bucket array
    i32                       ind_scriptfile_n;               // number of elements in the hash table
    atf_norm::FNs*            ns_lary[32];                    // level array
    i32                       ns_n;                           // number of elements in array
    atf_norm::FNs**           ind_ns_buckets_elems;           // pointer to bucket array
    i32                       ind_ns_buckets_n;               // number of elements in bucket array
    i32                       ind_ns_n;                       // number of elements in the hash table
    atf_norm::FReadme*        readme_lary[32];                // level array
    i32                       readme_n;                       // number of elements in array
    atf_norm::FBuilddir*      builddir_lary[32];              // level array
    i32                       builddir_n;                     // number of elements in array
    atf_norm::FCfg*           cfg_lary[32];                   // level array
    i32                       cfg_n;                          // number of elements in array
    atf_norm::FBuilddir**     ind_builddir_buckets_elems;     // pointer to bucket array
    i32                       ind_builddir_buckets_n;         // number of elements in bucket array
    i32                       ind_builddir_n;                 // number of elements in the hash table
    atf_norm::FGitfile*       gitfile_lary[32];               // level array
    i32                       gitfile_n;                      // number of elements in array
    atf_norm::FGitfile**      ind_gitfile_buckets_elems;      // pointer to bucket array
    i32                       ind_gitfile_buckets_n;          // number of elements in bucket array
    i32                       ind_gitfile_n;                  // number of elements in the hash table
    atf_norm::FNoindent*      noindent_lary[32];              // level array
    i32                       noindent_n;                     // number of elements in array
    atf_norm::FTargsrc*       targsrc_lary[32];               // level array
    i32                       targsrc_n;                      // number of elements in array
    atf_norm::trace           trace;                          //
};

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FNormcheck& normcheck_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FNormcheck* normcheck_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FNormcheck* normcheck_InsertMaybe(const atfdb::Normcheck &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                normcheck_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 normcheck_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FNormcheck* normcheck_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FNormcheck* normcheck_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  normcheck_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 normcheck_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 normcheck_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FNormcheck& normcheck_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 normcheck_XrefMaybe(atf_norm::FNormcheck &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FSsimfile& ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FSsimfile* ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FSsimfile* ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FSsimfile* ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FSsimfile* ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FSsimfile& ssimfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimfile_XrefMaybe(atf_norm::FSsimfile &row);

// Return true if hash is empty
bool                 ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_norm::FSsimfile* ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_norm::FSsimfile& ind_ssimfile_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_norm::FSsimfile& ind_ssimfile_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimfile_InsertMaybe(atf_norm::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimfile_Remove(atf_norm::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FScriptfile& scriptfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FScriptfile* scriptfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FScriptfile* scriptfile_InsertMaybe(const dev::Scriptfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                scriptfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 scriptfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FScriptfile* scriptfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FScriptfile* scriptfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  scriptfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 scriptfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 scriptfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FScriptfile& scriptfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 scriptfile_XrefMaybe(atf_norm::FScriptfile &row);

// Return true if hash is empty
bool                 ind_scriptfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_norm::FScriptfile* ind_scriptfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_norm::FScriptfile& ind_scriptfile_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_scriptfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_scriptfile_InsertMaybe(atf_norm::FScriptfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_scriptfile_Remove(atf_norm::FScriptfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_scriptfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FNs&       ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FNs*       ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FNs*       ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ns_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FNs*       ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FNs*       ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 ns_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FNs&       ns_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ns_XrefMaybe(atf_norm::FNs &row);

// Return true if hash is empty
bool                 ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_norm::FNs*       ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_norm::FNs&       ind_ns_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_norm::FNs&       ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ns_InsertMaybe(atf_norm::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ns_Remove(atf_norm::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FReadme&   readme_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FReadme*   readme_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FReadme*   readme_InsertMaybe(const dev::Readme &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                readme_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 readme_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FReadme*   readme_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FReadme*   readme_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  readme_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 readme_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 readme_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FReadme&   readme_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 readme_XrefMaybe(atf_norm::FReadme &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FBuilddir& builddir_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FBuilddir* builddir_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FBuilddir* builddir_InsertMaybe(const dev::Builddir &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                builddir_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 builddir_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FBuilddir* builddir_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FBuilddir* builddir_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  builddir_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 builddir_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 builddir_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FBuilddir& builddir_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 builddir_XrefMaybe(atf_norm::FBuilddir &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FCfg&      cfg_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FCfg*      cfg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FCfg*      cfg_InsertMaybe(const dev::Cfg &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cfg_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cfg_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FCfg*      cfg_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FCfg*      cfg_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cfg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cfg_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cfg_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FCfg&      cfg_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cfg_XrefMaybe(atf_norm::FCfg &row);

// Return true if hash is empty
bool                 ind_builddir_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_norm::FBuilddir* ind_builddir_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_norm::FBuilddir& ind_builddir_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_norm::FBuilddir& ind_builddir_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_builddir_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_builddir_InsertMaybe(atf_norm::FBuilddir& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_builddir_Remove(atf_norm::FBuilddir& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_builddir_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FGitfile&  gitfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FGitfile*  gitfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FGitfile*  gitfile_InsertMaybe(const dev::Gitfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gitfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gitfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FGitfile*  gitfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FGitfile*  gitfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gitfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gitfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gitfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FGitfile&  gitfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gitfile_XrefMaybe(atf_norm::FGitfile &row);

// Return true if hash is empty
bool                 ind_gitfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_norm::FGitfile*  ind_gitfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_norm::FGitfile&  ind_gitfile_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_norm::FGitfile&  ind_gitfile_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gitfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gitfile_InsertMaybe(atf_norm::FGitfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gitfile_Remove(atf_norm::FGitfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gitfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FNoindent& noindent_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FNoindent* noindent_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FNoindent* noindent_InsertMaybe(const dev::Noindent &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                noindent_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 noindent_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FNoindent* noindent_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FNoindent* noindent_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  noindent_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 noindent_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 noindent_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FNoindent& noindent_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 noindent_XrefMaybe(atf_norm::FNoindent &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_norm::FTargsrc&  targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_norm::FTargsrc*  targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_norm::FTargsrc*  targsrc_InsertMaybe(const dev::Targsrc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                targsrc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 targsrc_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_norm::FTargsrc*  targsrc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_norm::FTargsrc*  targsrc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  targsrc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 targsrc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 targsrc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_norm::FTargsrc&  targsrc_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 targsrc_XrefMaybe(atf_norm::FTargsrc &row);

// cursor points to valid item
void                 _db_normcheck_curs_Reset(_db_normcheck_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_normcheck_curs_ValidQ(_db_normcheck_curs &curs);
// proceed to next item
void                 _db_normcheck_curs_Next(_db_normcheck_curs &curs);
// item access
atf_norm::FNormcheck& _db_normcheck_curs_Access(_db_normcheck_curs &curs);
// cursor points to valid item
void                 _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs);
// proceed to next item
void                 _db_ssimfile_curs_Next(_db_ssimfile_curs &curs);
// item access
atf_norm::FSsimfile& _db_ssimfile_curs_Access(_db_ssimfile_curs &curs);
// cursor points to valid item
void                 _db_scriptfile_curs_Reset(_db_scriptfile_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_scriptfile_curs_ValidQ(_db_scriptfile_curs &curs);
// proceed to next item
void                 _db_scriptfile_curs_Next(_db_scriptfile_curs &curs);
// item access
atf_norm::FScriptfile& _db_scriptfile_curs_Access(_db_scriptfile_curs &curs);
// cursor points to valid item
void                 _db_ns_curs_Reset(_db_ns_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_ns_curs_ValidQ(_db_ns_curs &curs);
// proceed to next item
void                 _db_ns_curs_Next(_db_ns_curs &curs);
// item access
atf_norm::FNs&       _db_ns_curs_Access(_db_ns_curs &curs);
// cursor points to valid item
void                 _db_readme_curs_Reset(_db_readme_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_readme_curs_ValidQ(_db_readme_curs &curs);
// proceed to next item
void                 _db_readme_curs_Next(_db_readme_curs &curs);
// item access
atf_norm::FReadme&   _db_readme_curs_Access(_db_readme_curs &curs);
// cursor points to valid item
void                 _db_builddir_curs_Reset(_db_builddir_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_builddir_curs_ValidQ(_db_builddir_curs &curs);
// proceed to next item
void                 _db_builddir_curs_Next(_db_builddir_curs &curs);
// item access
atf_norm::FBuilddir& _db_builddir_curs_Access(_db_builddir_curs &curs);
// cursor points to valid item
void                 _db_cfg_curs_Reset(_db_cfg_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_cfg_curs_ValidQ(_db_cfg_curs &curs);
// proceed to next item
void                 _db_cfg_curs_Next(_db_cfg_curs &curs);
// item access
atf_norm::FCfg&      _db_cfg_curs_Access(_db_cfg_curs &curs);
// cursor points to valid item
void                 _db_gitfile_curs_Reset(_db_gitfile_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_gitfile_curs_ValidQ(_db_gitfile_curs &curs);
// proceed to next item
void                 _db_gitfile_curs_Next(_db_gitfile_curs &curs);
// item access
atf_norm::FGitfile&  _db_gitfile_curs_Access(_db_gitfile_curs &curs);
// cursor points to valid item
void                 _db_noindent_curs_Reset(_db_noindent_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_noindent_curs_ValidQ(_db_noindent_curs &curs);
// proceed to next item
void                 _db_noindent_curs_Next(_db_noindent_curs &curs);
// item access
atf_norm::FNoindent& _db_noindent_curs_Access(_db_noindent_curs &curs);
// cursor points to valid item
void                 _db_targsrc_curs_Reset(_db_targsrc_curs &curs, atf_norm::FDb &parent);
// cursor points to valid item
bool                 _db_targsrc_curs_ValidQ(_db_targsrc_curs &curs);
// proceed to next item
void                 _db_targsrc_curs_Next(_db_targsrc_curs &curs);
// item access
atf_norm::FTargsrc&  _db_targsrc_curs_Access(_db_targsrc_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- atf_norm.FGitfile
// create: atf_norm.FDb.gitfile (Lary)
// global access: ind_gitfile (Thash)
struct FGitfile { // atf_norm.FGitfile
    atf_norm::FGitfile*      ind_gitfile_next;   // hash next
    algo::Smallstr200        gitfile;            //
    atf_norm::FNoindent*     c_noindent;         // optional pointer
    atf_norm::FScriptfile*   c_scriptfile;       // optional pointer
    atf_norm::FTargsrc*      c_targsrc;          // optional pointer
private:
    friend atf_norm::FGitfile&  gitfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FGitfile*  gitfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gitfile_RemoveAll() __attribute__((nothrow));
    friend void                 gitfile_RemoveLast() __attribute__((nothrow));
    FGitfile();
    ~FGitfile();
    FGitfile(const FGitfile&){ /*disallow copy constructor */}
    void operator =(const FGitfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gitfile_CopyOut(atf_norm::FGitfile &row, dev::Gitfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 gitfile_CopyIn(atf_norm::FGitfile &row, dev::Gitfile &in) __attribute__((nothrow));

algo::Smallstr50     ext_Get(atf_norm::FGitfile& gitfile) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_noindent_InsertMaybe(atf_norm::FGitfile& gitfile, atf_norm::FNoindent& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_noindent_Remove(atf_norm::FGitfile& gitfile, atf_norm::FNoindent& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_scriptfile_InsertMaybe(atf_norm::FGitfile& gitfile, atf_norm::FScriptfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_scriptfile_Remove(atf_norm::FGitfile& gitfile, atf_norm::FScriptfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_targsrc_InsertMaybe(atf_norm::FGitfile& gitfile, atf_norm::FTargsrc& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_targsrc_Remove(atf_norm::FGitfile& gitfile, atf_norm::FTargsrc& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGitfile_Init(atf_norm::FGitfile& gitfile);
void                 FGitfile_Uninit(atf_norm::FGitfile& gitfile) __attribute__((nothrow));

// --- atf_norm.FNoindent
// create: atf_norm.FDb.noindent (Lary)
// access: atf_norm.FGitfile.c_noindent (Ptr)
struct FNoindent { // atf_norm.FNoindent
    algo::Smallstr200   gitfile;   //
    algo::Comment       comment;   //
private:
    friend atf_norm::FNoindent& noindent_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FNoindent* noindent_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 noindent_RemoveAll() __attribute__((nothrow));
    friend void                 noindent_RemoveLast() __attribute__((nothrow));
    FNoindent();
    ~FNoindent();
    FNoindent(const FNoindent&){ /*disallow copy constructor */}
    void operator =(const FNoindent&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 noindent_CopyOut(atf_norm::FNoindent &row, dev::Noindent &out) __attribute__((nothrow));
// Copy fields in to row
void                 noindent_CopyIn(atf_norm::FNoindent &row, dev::Noindent &in) __attribute__((nothrow));

void                 FNoindent_Uninit(atf_norm::FNoindent& noindent) __attribute__((nothrow));

// --- atf_norm.FNormcheck
// create: atf_norm.FDb.normcheck (Lary)
// global access: c_normcheck (Ptr)
struct FNormcheck { // atf_norm.FNormcheck
    algo::Smallstr50                normcheck;   //
    algo::Comment                   comment;     //
    i32                             nerr;        //   0
    atf_norm::normcheck_step_hook   step;        //   NULL  Pointer to a function
private:
    friend atf_norm::FNormcheck& normcheck_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FNormcheck* normcheck_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 normcheck_RemoveAll() __attribute__((nothrow));
    friend void                 normcheck_RemoveLast() __attribute__((nothrow));
    FNormcheck();
    // reftype of atf_norm.FNormcheck.step prohibits copy
    FNormcheck(const FNormcheck&){ /*disallow copy constructor */}
    void operator =(const FNormcheck&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 normcheck_CopyOut(atf_norm::FNormcheck &row, atfdb::Normcheck &out) __attribute__((nothrow));
// Copy fields in to row
void                 normcheck_CopyIn(atf_norm::FNormcheck &row, atfdb::Normcheck &in) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(atf_norm::FNormcheck& normcheck) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNormcheck_Init(atf_norm::FNormcheck& normcheck);

// --- atf_norm.FNs
// create: atf_norm.FDb.ns (Lary)
// global access: ind_ns (Thash)
struct FNs { // atf_norm.FNs
    atf_norm::FNs*     ind_ns_next;   // hash next
    algo::Smallstr16   ns;            // Namespace name (primary key)
    algo::Smallstr50   nstype;        //
    algo::Comment      comment;       //
private:
    friend atf_norm::FNs&       ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FNs*       ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveAll() __attribute__((nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
    FNs();
    ~FNs();
    FNs(const FNs&){ /*disallow copy constructor */}
    void operator =(const FNs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ns_CopyOut(atf_norm::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
void                 ns_CopyIn(atf_norm::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNs_Init(atf_norm::FNs& ns);
void                 FNs_Uninit(atf_norm::FNs& ns) __attribute__((nothrow));

// --- atf_norm.FReadme
// create: atf_norm.FDb.readme (Lary)
struct FReadme { // atf_norm.FReadme
    algo::Smallstr200   gitfile;   //
    bool                inl;       //   false
    algo::Comment       comment;   //
private:
    friend atf_norm::FReadme&   readme_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FReadme*   readme_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 readme_RemoveAll() __attribute__((nothrow));
    friend void                 readme_RemoveLast() __attribute__((nothrow));
    FReadme();
};

// Copy fields out of row
void                 readme_CopyOut(atf_norm::FReadme &row, dev::Readme &out) __attribute__((nothrow));
// Copy fields in to row
void                 readme_CopyIn(atf_norm::FReadme &row, dev::Readme &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FReadme_Init(atf_norm::FReadme& readme);

// --- atf_norm.FScriptfile
// create: atf_norm.FDb.scriptfile (Lary)
// global access: ind_scriptfile (Thash)
// access: atf_norm.FGitfile.c_scriptfile (Ptr)
struct FScriptfile { // atf_norm.FScriptfile
    atf_norm::FScriptfile*   ind_scriptfile_next;   // hash next
    algo::Smallstr200        gitfile;               //
    algo::Smallstr100        args;                  //
    algo::Comment            comment;               //
private:
    friend atf_norm::FScriptfile& scriptfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FScriptfile* scriptfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 scriptfile_RemoveAll() __attribute__((nothrow));
    friend void                 scriptfile_RemoveLast() __attribute__((nothrow));
    FScriptfile();
    ~FScriptfile();
    FScriptfile(const FScriptfile&){ /*disallow copy constructor */}
    void operator =(const FScriptfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 scriptfile_CopyOut(atf_norm::FScriptfile &row, dev::Scriptfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 scriptfile_CopyIn(atf_norm::FScriptfile &row, dev::Scriptfile &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FScriptfile_Init(atf_norm::FScriptfile& scriptfile);
void                 FScriptfile_Uninit(atf_norm::FScriptfile& scriptfile) __attribute__((nothrow));

// --- atf_norm.FSsimfile
// create: atf_norm.FDb.ssimfile (Lary)
// global access: ind_ssimfile (Thash)
struct FSsimfile { // atf_norm.FSsimfile
    atf_norm::FSsimfile*   ind_ssimfile_next;   // hash next
    algo::Smallstr50       ssimfile;            //
    algo::Smallstr50       ctype;               //
private:
    friend atf_norm::FSsimfile& ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FSsimfile* ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
    FSsimfile();
    ~FSsimfile();
    FSsimfile(const FSsimfile&){ /*disallow copy constructor */}
    void operator =(const FSsimfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimfile_CopyOut(atf_norm::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimfile_CopyIn(atf_norm::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

algo::Smallstr16     ssimns_Get(atf_norm::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(atf_norm::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(atf_norm::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FSsimfile_Init(atf_norm::FSsimfile& ssimfile);
void                 FSsimfile_Uninit(atf_norm::FSsimfile& ssimfile) __attribute__((nothrow));

// --- atf_norm.FTargsrc
// create: atf_norm.FDb.targsrc (Lary)
// access: atf_norm.FGitfile.c_targsrc (Ptr)
struct FTargsrc { // atf_norm.FTargsrc
    algo::Smallstr100   targsrc;   //
    algo::Comment       comment;   //
private:
    friend atf_norm::FTargsrc&  targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_norm::FTargsrc*  targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targsrc_RemoveAll() __attribute__((nothrow));
    friend void                 targsrc_RemoveLast() __attribute__((nothrow));
    FTargsrc();
    ~FTargsrc();
    FTargsrc(const FTargsrc&){ /*disallow copy constructor */}
    void operator =(const FTargsrc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 targsrc_CopyOut(atf_norm::FTargsrc &row, dev::Targsrc &out) __attribute__((nothrow));
// Copy fields in to row
void                 targsrc_CopyIn(atf_norm::FTargsrc &row, dev::Targsrc &in) __attribute__((nothrow));

algo::Smallstr16     target_Get(atf_norm::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr200    src_Get(atf_norm::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr10     ext_Get(atf_norm::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

void                 FTargsrc_Uninit(atf_norm::FTargsrc& targsrc) __attribute__((nothrow));

// --- atf_norm.FieldId
#pragma pack(push,1)
struct FieldId { // atf_norm.FieldId: Field read helper
    i32   value;   //   -1
    inline operator atf_norm_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(atf_norm_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
atf_norm_FieldIdEnum value_GetEnum(const atf_norm::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_norm::FieldId& parent, atf_norm_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_norm::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_norm::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_norm::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_norm::FieldId& parent, algo::strptr rhs, atf_norm_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_norm::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_norm::FieldId from an ascii string.
// The format of the string is the format of the atf_norm::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(atf_norm::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(atf_norm::FieldId& parent);
// print string representation of atf_norm::FieldId to string LHS, no header -- cprint:atf_norm.FieldId.String
void                 FieldId_Print(atf_norm::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_norm.TableId
struct TableId { // atf_norm.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator atf_norm_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(atf_norm_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
atf_norm_TableIdEnum value_GetEnum(const atf_norm::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_norm::TableId& parent, atf_norm_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_norm::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_norm::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_norm::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_norm::TableId& parent, algo::strptr rhs, atf_norm_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_norm::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_norm::TableId from an ascii string.
// The format of the string is the format of the atf_norm::TableId's only field
bool                 TableId_ReadStrptrMaybe(atf_norm::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(atf_norm::TableId& parent);
// print string representation of atf_norm::TableId to string LHS, no header -- cprint:atf_norm.TableId.String
void                 TableId_Print(atf_norm::TableId & row, algo::cstring &str) __attribute__((nothrow));

struct _db_normcheck_curs {// cursor
    typedef atf_norm::FNormcheck ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_normcheck_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef atf_norm::FSsimfile ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_scriptfile_curs {// cursor
    typedef atf_norm::FScriptfile ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_scriptfile_curs(){ parent=NULL; index=0; }
};


struct _db_ns_curs {// cursor
    typedef atf_norm::FNs ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_readme_curs {// cursor
    typedef atf_norm::FReadme ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_readme_curs(){ parent=NULL; index=0; }
};


struct _db_builddir_curs {// cursor
    typedef atf_norm::FBuilddir ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_builddir_curs(){ parent=NULL; index=0; }
};


struct _db_cfg_curs {// cursor
    typedef atf_norm::FCfg ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_cfg_curs(){ parent=NULL; index=0; }
};


struct _db_gitfile_curs {// cursor
    typedef atf_norm::FGitfile ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_gitfile_curs(){ parent=NULL; index=0; }
};


struct _db_noindent_curs {// cursor
    typedef atf_norm::FNoindent ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_noindent_curs(){ parent=NULL; index=0; }
};


struct _db_targsrc_curs {// cursor
    typedef atf_norm::FTargsrc ChildType;
    atf_norm::FDb *parent;
    i64 index;
    _db_targsrc_curs(){ parent=NULL; index=0; }
};

// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_checkclean();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_gitfile();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_normalize_acr();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_src_lim();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_cppcheck();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_amc();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_bootstrap();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_shebang();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_encoding();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_inline_readme();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_readme();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_bintests();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_copyright();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_iffy_src();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_stray_gen();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_tempcode();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_lineendings();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_indent_srcfile();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_indent_script();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_normalize_amc_vis();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_ssimfile();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_normalize_acr_my();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_atf_unit();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_build_clang();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_build_gcc9();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_acr_ed_ssimfile();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_acr_ed_ssimdb();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_acr_ed_target();
// User-implemented function from gstatic:atf_norm.FDb.normcheck
void                 normcheck_atf_amc();
int                  main(int argc, char **argv);
} // end namespace atf_norm
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const atf_norm::trace &row);// cfmt:atf_norm.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_norm::FieldId &row);// cfmt:atf_norm.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_norm::TableId &row);// cfmt:atf_norm.TableId.String
}
