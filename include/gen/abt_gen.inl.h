//
// include/gen/abt_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

// --- abt.FArch..Init
// Set all fields to initial values.
inline void abt::FArch_Init(abt::FArch& arch) {
    arch.ind_arch_next = (abt::FArch*)-1; // (abt.FDb.ind_arch) not-in-hash
}

// --- abt.FArch..Ctor
inline  abt::FArch::FArch() {
    abt::FArch_Init(*this);
}

// --- abt.FArch..Dtor
inline  abt::FArch::~FArch() {
    abt::FArch_Uninit(*this);
}

// --- abt.FCfg..Init
// Set all fields to initial values.
inline void abt::FCfg_Init(abt::FCfg& cfg) {
    cfg.ind_cfg_next = (abt::FCfg*)-1; // (abt.FDb.ind_cfg) not-in-hash
}

// --- abt.FCfg..Ctor
inline  abt::FCfg::FCfg() {
    abt::FCfg_Init(*this);
}

// --- abt.FCfg..Dtor
inline  abt::FCfg::~FCfg() {
    abt::FCfg_Uninit(*this);
}

// --- abt.FCompiler..Init
// Set all fields to initial values.
inline void abt::FCompiler_Init(abt::FCompiler& compiler) {
    compiler.ind_compiler_next = (abt::FCompiler*)-1; // (abt.FDb.ind_compiler) not-in-hash
}

// --- abt.FCompiler..Ctor
inline  abt::FCompiler::FCompiler() {
    abt::FCompiler_Init(*this);
}

// --- abt.FCompiler..Dtor
inline  abt::FCompiler::~FCompiler() {
    abt::FCompiler_Uninit(*this);
}

// --- abt.trace..Ctor
inline  abt::trace::trace() {
}

// --- abt.FDb.srcfile.EmptyQ
// Return true if index is empty
inline bool abt::srcfile_EmptyQ() {
    return _db.srcfile_n == 0;
}

// --- abt.FDb.srcfile.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSrcfile* abt::srcfile_Find(u64 t) {
    abt::FSrcfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.srcfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.srcfile_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.srcfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FSrcfile* abt::srcfile_Last() {
    return srcfile_Find(u64(_db.srcfile_n-1));
}

// --- abt.FDb.srcfile.N
// Return number of items in the pool
inline i32 abt::srcfile_N() {
    return _db.srcfile_n;
}

// --- abt.FDb.srcfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FSrcfile& abt::srcfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.srcfile_lary[bsr][index];
}

// --- abt.FDb.targdep.EmptyQ
// Return true if index is empty
inline bool abt::targdep_EmptyQ() {
    return _db.targdep_n == 0;
}

// --- abt.FDb.targdep.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTargdep* abt::targdep_Find(u64 t) {
    abt::FTargdep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targdep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targdep_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.targdep.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FTargdep* abt::targdep_Last() {
    return targdep_Find(u64(_db.targdep_n-1));
}

// --- abt.FDb.targdep.N
// Return number of items in the pool
inline i32 abt::targdep_N() {
    return _db.targdep_n;
}

// --- abt.FDb.targdep.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FTargdep& abt::targdep_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targdep_lary[bsr][index];
}

// --- abt.FDb.tool_opt.EmptyQ
// Return true if index is empty
inline bool abt::tool_opt_EmptyQ() {
    return _db.tool_opt_n == 0;
}

// --- abt.FDb.tool_opt.Find
// Look up row by row id. Return NULL if out of range
inline abt::FToolOpt* abt::tool_opt_Find(u64 t) {
    abt::FToolOpt *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tool_opt_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tool_opt_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.tool_opt.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FToolOpt* abt::tool_opt_Last() {
    return tool_opt_Find(u64(_db.tool_opt_n-1));
}

// --- abt.FDb.tool_opt.N
// Return number of items in the pool
inline i32 abt::tool_opt_N() {
    return _db.tool_opt_n;
}

// --- abt.FDb.tool_opt.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FToolOpt& abt::tool_opt_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tool_opt_lary[bsr][index];
}

// --- abt.FDb.ind_target.EmptyQ
// Return true if hash is empty
inline bool abt::ind_target_EmptyQ() {
    return _db.ind_target_n == 0;
}

// --- abt.FDb.ind_target.N
// Return number of items in the hash
inline i32 abt::ind_target_N() {
    return _db.ind_target_n;
}

// --- abt.FDb.target.EmptyQ
// Return true if index is empty
inline bool abt::target_EmptyQ() {
    return _db.target_n == 0;
}

// --- abt.FDb.target.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTarget* abt::target_Find(u64 t) {
    abt::FTarget *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.target_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.target_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.target.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FTarget* abt::target_Last() {
    return target_Find(u64(_db.target_n-1));
}

// --- abt.FDb.target.N
// Return number of items in the pool
inline i32 abt::target_N() {
    return _db.target_n;
}

// --- abt.FDb.target.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FTarget& abt::target_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.target_lary[bsr][index];
}

// --- abt.FDb.ind_targsrc.EmptyQ
// Return true if hash is empty
inline bool abt::ind_targsrc_EmptyQ() {
    return _db.ind_targsrc_n == 0;
}

// --- abt.FDb.ind_targsrc.N
// Return number of items in the hash
inline i32 abt::ind_targsrc_N() {
    return _db.ind_targsrc_n;
}

// --- abt.FDb.targsrc.EmptyQ
// Return true if index is empty
inline bool abt::targsrc_EmptyQ() {
    return _db.targsrc_n == 0;
}

// --- abt.FDb.targsrc.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTargsrc* abt::targsrc_Find(u64 t) {
    abt::FTargsrc *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targsrc_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targsrc_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.targsrc.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FTargsrc* abt::targsrc_Last() {
    return targsrc_Find(u64(_db.targsrc_n-1));
}

// --- abt.FDb.targsrc.N
// Return number of items in the pool
inline i32 abt::targsrc_N() {
    return _db.targsrc_n;
}

// --- abt.FDb.targsrc.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FTargsrc& abt::targsrc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targsrc_lary[bsr][index];
}

// --- abt.FDb.syscmddep.EmptyQ
// Return true if index is empty
inline bool abt::syscmddep_EmptyQ() {
    return _db.syscmddep_n == 0;
}

// --- abt.FDb.syscmddep.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSyscmddep* abt::syscmddep_Find(u64 t) {
    abt::FSyscmddep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.syscmddep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.syscmddep_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.syscmddep.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FSyscmddep* abt::syscmddep_Last() {
    return syscmddep_Find(u64(_db.syscmddep_n-1));
}

// --- abt.FDb.syscmddep.N
// Return number of items in the pool
inline i32 abt::syscmddep_N() {
    return _db.syscmddep_n;
}

// --- abt.FDb.syscmddep.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FSyscmddep& abt::syscmddep_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.syscmddep_lary[bsr][index];
}

// --- abt.FDb.syscmd.EmptyQ
// Return true if index is empty
inline bool abt::syscmd_EmptyQ() {
    return _db.syscmd_n == 0;
}

// --- abt.FDb.syscmd.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSyscmd* abt::syscmd_Find(i32 t) {
    abt::FSyscmd *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.syscmd_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.syscmd_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.syscmd.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FSyscmd* abt::syscmd_Last() {
    return syscmd_Find(i32(_db.syscmd_n-1));
}

// --- abt.FDb.syscmd.N
// Return number of items in the pool
inline i32 abt::syscmd_N() {
    return _db.syscmd_n;
}

// --- abt.FDb.syscmd.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FSyscmd& abt::syscmd_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.syscmd_lary[bsr][index];
}

// --- abt.FDb.ind_syscmd.EmptyQ
// Return true if hash is empty
inline bool abt::ind_syscmd_EmptyQ() {
    return _db.ind_syscmd_n == 0;
}

// --- abt.FDb.ind_syscmd.N
// Return number of items in the hash
inline i32 abt::ind_syscmd_N() {
    return _db.ind_syscmd_n;
}

// --- abt.FDb.ind_running.EmptyQ
// Return true if hash is empty
inline bool abt::ind_running_EmptyQ() {
    return _db.ind_running_n == 0;
}

// --- abt.FDb.ind_running.N
// Return number of items in the hash
inline i32 abt::ind_running_N() {
    return _db.ind_running_n;
}

// --- abt.FDb.ind_srcfile.EmptyQ
// Return true if hash is empty
inline bool abt::ind_srcfile_EmptyQ() {
    return _db.ind_srcfile_n == 0;
}

// --- abt.FDb.ind_srcfile.N
// Return number of items in the hash
inline i32 abt::ind_srcfile_N() {
    return _db.ind_srcfile_n;
}

// --- abt.FDb.cfg.EmptyQ
// Return true if index is empty
inline bool abt::cfg_EmptyQ() {
    return _db.cfg_n == 0;
}

// --- abt.FDb.cfg.Find
// Look up row by row id. Return NULL if out of range
inline abt::FCfg* abt::cfg_Find(u64 t) {
    abt::FCfg *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cfg_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cfg_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.cfg.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FCfg* abt::cfg_Last() {
    return cfg_Find(u64(_db.cfg_n-1));
}

// --- abt.FDb.cfg.N
// Return number of items in the pool
inline i32 abt::cfg_N() {
    return _db.cfg_n;
}

// --- abt.FDb.cfg.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FCfg& abt::cfg_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cfg_lary[bsr][index];
}

// --- abt.FDb.ind_cfg.EmptyQ
// Return true if hash is empty
inline bool abt::ind_cfg_EmptyQ() {
    return _db.ind_cfg_n == 0;
}

// --- abt.FDb.ind_cfg.N
// Return number of items in the hash
inline i32 abt::ind_cfg_N() {
    return _db.ind_cfg_n;
}

// --- abt.FDb.uname.EmptyQ
// Return true if index is empty
inline bool abt::uname_EmptyQ() {
    return _db.uname_n == 0;
}

// --- abt.FDb.uname.Find
// Look up row by row id. Return NULL if out of range
inline abt::FUname* abt::uname_Find(u64 t) {
    abt::FUname *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.uname_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.uname_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.uname.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FUname* abt::uname_Last() {
    return uname_Find(u64(_db.uname_n-1));
}

// --- abt.FDb.uname.N
// Return number of items in the pool
inline i32 abt::uname_N() {
    return _db.uname_n;
}

// --- abt.FDb.uname.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FUname& abt::uname_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.uname_lary[bsr][index];
}

// --- abt.FDb.ind_uname.EmptyQ
// Return true if hash is empty
inline bool abt::ind_uname_EmptyQ() {
    return _db.ind_uname_n == 0;
}

// --- abt.FDb.ind_uname.N
// Return number of items in the hash
inline i32 abt::ind_uname_N() {
    return _db.ind_uname_n;
}

// --- abt.FDb.compiler.EmptyQ
// Return true if index is empty
inline bool abt::compiler_EmptyQ() {
    return _db.compiler_n == 0;
}

// --- abt.FDb.compiler.Find
// Look up row by row id. Return NULL if out of range
inline abt::FCompiler* abt::compiler_Find(u64 t) {
    abt::FCompiler *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.compiler_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.compiler_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.compiler.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FCompiler* abt::compiler_Last() {
    return compiler_Find(u64(_db.compiler_n-1));
}

// --- abt.FDb.compiler.N
// Return number of items in the pool
inline i32 abt::compiler_N() {
    return _db.compiler_n;
}

// --- abt.FDb.compiler.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FCompiler& abt::compiler_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.compiler_lary[bsr][index];
}

// --- abt.FDb.ind_compiler.EmptyQ
// Return true if hash is empty
inline bool abt::ind_compiler_EmptyQ() {
    return _db.ind_compiler_n == 0;
}

// --- abt.FDb.ind_compiler.N
// Return number of items in the hash
inline i32 abt::ind_compiler_N() {
    return _db.ind_compiler_n;
}

// --- abt.FDb.arch.EmptyQ
// Return true if index is empty
inline bool abt::arch_EmptyQ() {
    return _db.arch_n == 0;
}

// --- abt.FDb.arch.Find
// Look up row by row id. Return NULL if out of range
inline abt::FArch* abt::arch_Find(u64 t) {
    abt::FArch *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.arch_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.arch_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.arch.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FArch* abt::arch_Last() {
    return arch_Find(u64(_db.arch_n-1));
}

// --- abt.FDb.arch.N
// Return number of items in the pool
inline i32 abt::arch_N() {
    return _db.arch_n;
}

// --- abt.FDb.arch.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FArch& abt::arch_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.arch_lary[bsr][index];
}

// --- abt.FDb.ind_arch.EmptyQ
// Return true if hash is empty
inline bool abt::ind_arch_EmptyQ() {
    return _db.ind_arch_n == 0;
}

// --- abt.FDb.ind_arch.N
// Return number of items in the hash
inline i32 abt::ind_arch_N() {
    return _db.ind_arch_n;
}

// --- abt.FDb.bh_syscmd.EmptyQ
// Return true if index is empty
inline bool abt::bh_syscmd_EmptyQ() {
    return _db.bh_syscmd_n == 0;
}

// --- abt.FDb.bh_syscmd.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt::FSyscmd* abt::bh_syscmd_First() {
    abt::FSyscmd *row = NULL;
    if (_db.bh_syscmd_n > 0) {
        row = _db.bh_syscmd_elems[0];
    }
    return row;
}

// --- abt.FDb.bh_syscmd.InBheapQ
// Return true if row is in index, false otherwise
inline bool abt::bh_syscmd_InBheapQ(abt::FSyscmd& row) {
    bool result = false;
    result = row.bh_syscmd_idx != -1;
    return result;
}

// --- abt.FDb.bh_syscmd.N
// Return number of items in the heap
inline i32 abt::bh_syscmd_N() {
    return _db.bh_syscmd_n;
}

// --- abt.FDb.zs_srcfile_read.EmptyQ
// Return true if index is empty
inline bool abt::zs_srcfile_read_EmptyQ() {
    return _db.zs_srcfile_read_head == NULL;
}

// --- abt.FDb.zs_srcfile_read.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt::FSrcfile* abt::zs_srcfile_read_First() {
    abt::FSrcfile *row = NULL;
    row = _db.zs_srcfile_read_head;
    return row;
}

// --- abt.FDb.zs_srcfile_read.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt::zs_srcfile_read_InLlistQ(abt::FSrcfile& row) {
    bool result = false;
    result = !(row.zs_srcfile_read_next == (abt::FSrcfile*)-1);
    return result;
}

// --- abt.FDb.zs_srcfile_read.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt::FSrcfile* abt::zs_srcfile_read_Last() {
    abt::FSrcfile *row = NULL;
    row = _db.zs_srcfile_read_tail;
    return row;
}

// --- abt.FDb.zs_srcfile_read.Next
// Return pointer to next element in the list
inline abt::FSrcfile* abt::zs_srcfile_read_Next(abt::FSrcfile &row) {
    return row.zs_srcfile_read_next;
}

// --- abt.FDb.zs_srcfile_read.qLast
// Return reference to last element in the index. No bounds checking.
inline abt::FSrcfile& abt::zs_srcfile_read_qLast() {
    abt::FSrcfile *row = NULL;
    row = _db.zs_srcfile_read_tail;
    return *row;
}

// --- abt.FDb.zs_sel_target.EmptyQ
// Return true if index is empty
inline bool abt::zs_sel_target_EmptyQ() {
    return _db.zs_sel_target_head == NULL;
}

// --- abt.FDb.zs_sel_target.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt::FTarget* abt::zs_sel_target_First() {
    abt::FTarget *row = NULL;
    row = _db.zs_sel_target_head;
    return row;
}

// --- abt.FDb.zs_sel_target.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt::zs_sel_target_InLlistQ(abt::FTarget& row) {
    bool result = false;
    result = !(row.zs_sel_target_next == (abt::FTarget*)-1);
    return result;
}

// --- abt.FDb.zs_sel_target.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt::FTarget* abt::zs_sel_target_Last() {
    abt::FTarget *row = NULL;
    row = _db.zs_sel_target_tail;
    return row;
}

// --- abt.FDb.zs_sel_target.N
// Return number of items in the linked list
inline i32 abt::zs_sel_target_N() {
    return _db.zs_sel_target_n;
}

// --- abt.FDb.zs_sel_target.Next
// Return pointer to next element in the list
inline abt::FTarget* abt::zs_sel_target_Next(abt::FTarget &row) {
    return row.zs_sel_target_next;
}

// --- abt.FDb.zs_sel_target.qLast
// Return reference to last element in the index. No bounds checking.
inline abt::FTarget& abt::zs_sel_target_qLast() {
    abt::FTarget *row = NULL;
    row = _db.zs_sel_target_tail;
    return *row;
}

// --- abt.FDb.targsyslib.EmptyQ
// Return true if index is empty
inline bool abt::targsyslib_EmptyQ() {
    return _db.targsyslib_n == 0;
}

// --- abt.FDb.targsyslib.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTargsyslib* abt::targsyslib_Find(u64 t) {
    abt::FTargsyslib *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targsyslib_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targsyslib_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.targsyslib.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FTargsyslib* abt::targsyslib_Last() {
    return targsyslib_Find(u64(_db.targsyslib_n-1));
}

// --- abt.FDb.targsyslib.N
// Return number of items in the pool
inline i32 abt::targsyslib_N() {
    return _db.targsyslib_n;
}

// --- abt.FDb.targsyslib.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FTargsyslib& abt::targsyslib_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targsyslib_lary[bsr][index];
}

// --- abt.FDb.syslib.EmptyQ
// Return true if index is empty
inline bool abt::syslib_EmptyQ() {
    return _db.syslib_n == 0;
}

// --- abt.FDb.syslib.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSyslib* abt::syslib_Find(u64 t) {
    abt::FSyslib *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.syslib_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.syslib_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.syslib.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FSyslib* abt::syslib_Last() {
    return syslib_Find(u64(_db.syslib_n-1));
}

// --- abt.FDb.syslib.N
// Return number of items in the pool
inline i32 abt::syslib_N() {
    return _db.syslib_n;
}

// --- abt.FDb.syslib.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FSyslib& abt::syslib_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.syslib_lary[bsr][index];
}

// --- abt.FDb.ind_syslib.EmptyQ
// Return true if hash is empty
inline bool abt::ind_syslib_EmptyQ() {
    return _db.ind_syslib_n == 0;
}

// --- abt.FDb.ind_syslib.N
// Return number of items in the hash
inline i32 abt::ind_syslib_N() {
    return _db.ind_syslib_n;
}

// --- abt.FDb.include.EmptyQ
// Return true if index is empty
inline bool abt::include_EmptyQ() {
    return _db.include_n == 0;
}

// --- abt.FDb.include.Find
// Look up row by row id. Return NULL if out of range
inline abt::FInclude* abt::include_Find(u64 t) {
    abt::FInclude *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.include_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.include_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.include.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FInclude* abt::include_Last() {
    return include_Find(u64(_db.include_n-1));
}

// --- abt.FDb.include.N
// Return number of items in the pool
inline i32 abt::include_N() {
    return _db.include_n;
}

// --- abt.FDb.include.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FInclude& abt::include_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.include_lary[bsr][index];
}

// --- abt.FDb.ind_include.EmptyQ
// Return true if hash is empty
inline bool abt::ind_include_EmptyQ() {
    return _db.ind_include_n == 0;
}

// --- abt.FDb.ind_include.N
// Return number of items in the hash
inline i32 abt::ind_include_N() {
    return _db.ind_include_n;
}

// --- abt.FDb.sysincl.EmptyQ
// Return true if index is empty
inline bool abt::sysincl_EmptyQ() {
    return _db.sysincl_n == 0;
}

// --- abt.FDb.sysincl.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* abt::sysincl_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.sysincl_n;
    if (idx >= lim) return NULL;
    return _db.sysincl_elems + idx;
}

// --- abt.FDb.sysincl.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> abt::sysincl_Getary() {
    return algo::aryptr<algo::cstring>(_db.sysincl_elems, _db.sysincl_n);
}

// --- abt.FDb.sysincl.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* abt::sysincl_Last() {
    return sysincl_Find(u64(_db.sysincl_n-1));
}

// --- abt.FDb.sysincl.Max
// Return max. number of items in the array
inline i32 abt::sysincl_Max() {
    return _db.sysincl_max;
}

// --- abt.FDb.sysincl.N
// Return number of items in the array
inline i32 abt::sysincl_N() {
    return _db.sysincl_n;
}

// --- abt.FDb.sysincl.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void abt::sysincl_Reserve(int n) {
    u32 new_n = _db.sysincl_n + n;
    if (UNLIKELY(new_n > _db.sysincl_max)) {
        sysincl_AbsReserve(new_n);
    }
}

// --- abt.FDb.sysincl.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& abt::sysincl_qFind(u64 t) {
    return _db.sysincl_elems[t];
}

// --- abt.FDb.sysincl.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& abt::sysincl_qLast() {
    return sysincl_qFind(u64(_db.sysincl_n-1));
}

// --- abt.FDb.sysincl.rowid_Get
// Return row id of specified element
inline u64 abt::sysincl_rowid_Get(algo::cstring &elem) {
    u64 id = &elem - _db.sysincl_elems;
    return u64(id);
}

// --- abt.FDb.zs_origsel_target.EmptyQ
// Return true if index is empty
inline bool abt::zs_origsel_target_EmptyQ() {
    return _db.zs_origsel_target_head == NULL;
}

// --- abt.FDb.zs_origsel_target.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt::FTarget* abt::zs_origsel_target_First() {
    abt::FTarget *row = NULL;
    row = _db.zs_origsel_target_head;
    return row;
}

// --- abt.FDb.zs_origsel_target.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt::zs_origsel_target_InLlistQ(abt::FTarget& row) {
    bool result = false;
    result = !(row.zs_origsel_target_next == (abt::FTarget*)-1);
    return result;
}

// --- abt.FDb.zs_origsel_target.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt::FTarget* abt::zs_origsel_target_Last() {
    abt::FTarget *row = NULL;
    row = _db.zs_origsel_target_tail;
    return row;
}

// --- abt.FDb.zs_origsel_target.Next
// Return pointer to next element in the list
inline abt::FTarget* abt::zs_origsel_target_Next(abt::FTarget &row) {
    return row.zs_origsel_target_next;
}

// --- abt.FDb.zs_origsel_target.qLast
// Return reference to last element in the index. No bounds checking.
inline abt::FTarget& abt::zs_origsel_target_qLast() {
    abt::FTarget *row = NULL;
    row = _db.zs_origsel_target_tail;
    return *row;
}

// --- abt.FDb.ns.EmptyQ
// Return true if index is empty
inline bool abt::ns_EmptyQ() {
    return _db.ns_n == 0;
}

// --- abt.FDb.ns.Find
// Look up row by row id. Return NULL if out of range
inline abt::FNs* abt::ns_Find(u64 t) {
    abt::FNs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ns_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ns_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.ns.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FNs* abt::ns_Last() {
    return ns_Find(u64(_db.ns_n-1));
}

// --- abt.FDb.ns.N
// Return number of items in the pool
inline i32 abt::ns_N() {
    return _db.ns_n;
}

// --- abt.FDb.ns.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FNs& abt::ns_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ns_lary[bsr][index];
}

// --- abt.FDb.ind_ns.EmptyQ
// Return true if hash is empty
inline bool abt::ind_ns_EmptyQ() {
    return _db.ind_ns_n == 0;
}

// --- abt.FDb.ind_ns.N
// Return number of items in the hash
inline i32 abt::ind_ns_N() {
    return _db.ind_ns_n;
}

// --- abt.FDb.filestat.EmptyQ
// Return true if index is empty
inline bool abt::filestat_EmptyQ() {
    return _db.filestat_n == 0;
}

// --- abt.FDb.filestat.Find
// Look up row by row id. Return NULL if out of range
inline abt::FFilestat* abt::filestat_Find(u64 t) {
    abt::FFilestat *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.filestat_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.filestat_lary[bsr][index];
    }
    return retval;
}

// --- abt.FDb.filestat.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt::FFilestat* abt::filestat_Last() {
    return filestat_Find(u64(_db.filestat_n-1));
}

// --- abt.FDb.filestat.N
// Return number of items in the pool
inline i32 abt::filestat_N() {
    return _db.filestat_n;
}

// --- abt.FDb.filestat.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt::FFilestat& abt::filestat_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.filestat_lary[bsr][index];
}

// --- abt.FDb.ind_filestat.EmptyQ
// Return true if hash is empty
inline bool abt::ind_filestat_EmptyQ() {
    return _db.ind_filestat_n == 0;
}

// --- abt.FDb.ind_filestat.N
// Return number of items in the hash
inline i32 abt::ind_filestat_N() {
    return _db.ind_filestat_n;
}

// --- abt.FDb.zd_inclstack.EmptyQ
// Return true if index is empty
inline bool abt::zd_inclstack_EmptyQ() {
    return _db.zd_inclstack_head == NULL;
}

// --- abt.FDb.zd_inclstack.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt::FSrcfile* abt::zd_inclstack_First() {
    abt::FSrcfile *row = NULL;
    row = _db.zd_inclstack_head;
    return row;
}

// --- abt.FDb.zd_inclstack.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt::zd_inclstack_InLlistQ(abt::FSrcfile& row) {
    bool result = false;
    result = !(row.zd_inclstack_next == (abt::FSrcfile*)-1);
    return result;
}

// --- abt.FDb.zd_inclstack.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt::FSrcfile* abt::zd_inclstack_Last() {
    abt::FSrcfile *row = NULL;
    row = _db.zd_inclstack_tail;
    return row;
}

// --- abt.FDb.zd_inclstack.N
// Return number of items in the linked list
inline i32 abt::zd_inclstack_N() {
    return _db.zd_inclstack_n;
}

// --- abt.FDb.zd_inclstack.Next
// Return pointer to next element in the list
inline abt::FSrcfile* abt::zd_inclstack_Next(abt::FSrcfile &row) {
    return row.zd_inclstack_next;
}

// --- abt.FDb.zd_inclstack.Prev
// Return pointer to previous element in the list
inline abt::FSrcfile* abt::zd_inclstack_Prev(abt::FSrcfile &row) {
    return row.zd_inclstack_prev;
}

// --- abt.FDb.zd_inclstack.qLast
// Return reference to last element in the index. No bounds checking.
inline abt::FSrcfile& abt::zd_inclstack_qLast() {
    abt::FSrcfile *row = NULL;
    row = _db.zd_inclstack_tail;
    return *row;
}

// --- abt.FDb.srcfile_curs.Reset
// cursor points to valid item
inline void abt::_db_srcfile_curs_Reset(_db_srcfile_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.srcfile_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_srcfile_curs_ValidQ(_db_srcfile_curs &curs) {
    return curs.index < _db.srcfile_n;
}

// --- abt.FDb.srcfile_curs.Next
// proceed to next item
inline void abt::_db_srcfile_curs_Next(_db_srcfile_curs &curs) {
    curs.index++;
}

// --- abt.FDb.srcfile_curs.Access
// item access
inline abt::FSrcfile& abt::_db_srcfile_curs_Access(_db_srcfile_curs &curs) {
    return srcfile_qFind(u64(curs.index));
}

// --- abt.FDb.targdep_curs.Reset
// cursor points to valid item
inline void abt::_db_targdep_curs_Reset(_db_targdep_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.targdep_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_targdep_curs_ValidQ(_db_targdep_curs &curs) {
    return curs.index < _db.targdep_n;
}

// --- abt.FDb.targdep_curs.Next
// proceed to next item
inline void abt::_db_targdep_curs_Next(_db_targdep_curs &curs) {
    curs.index++;
}

// --- abt.FDb.targdep_curs.Access
// item access
inline abt::FTargdep& abt::_db_targdep_curs_Access(_db_targdep_curs &curs) {
    return targdep_qFind(u64(curs.index));
}

// --- abt.FDb.tool_opt_curs.Reset
// cursor points to valid item
inline void abt::_db_tool_opt_curs_Reset(_db_tool_opt_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.tool_opt_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_tool_opt_curs_ValidQ(_db_tool_opt_curs &curs) {
    return curs.index < _db.tool_opt_n;
}

// --- abt.FDb.tool_opt_curs.Next
// proceed to next item
inline void abt::_db_tool_opt_curs_Next(_db_tool_opt_curs &curs) {
    curs.index++;
}

// --- abt.FDb.tool_opt_curs.Access
// item access
inline abt::FToolOpt& abt::_db_tool_opt_curs_Access(_db_tool_opt_curs &curs) {
    return tool_opt_qFind(u64(curs.index));
}

// --- abt.FDb.target_curs.Reset
// cursor points to valid item
inline void abt::_db_target_curs_Reset(_db_target_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.target_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_target_curs_ValidQ(_db_target_curs &curs) {
    return curs.index < _db.target_n;
}

// --- abt.FDb.target_curs.Next
// proceed to next item
inline void abt::_db_target_curs_Next(_db_target_curs &curs) {
    curs.index++;
}

// --- abt.FDb.target_curs.Access
// item access
inline abt::FTarget& abt::_db_target_curs_Access(_db_target_curs &curs) {
    return target_qFind(u64(curs.index));
}

// --- abt.FDb.targsrc_curs.Reset
// cursor points to valid item
inline void abt::_db_targsrc_curs_Reset(_db_targsrc_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.targsrc_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_targsrc_curs_ValidQ(_db_targsrc_curs &curs) {
    return curs.index < _db.targsrc_n;
}

// --- abt.FDb.targsrc_curs.Next
// proceed to next item
inline void abt::_db_targsrc_curs_Next(_db_targsrc_curs &curs) {
    curs.index++;
}

// --- abt.FDb.targsrc_curs.Access
// item access
inline abt::FTargsrc& abt::_db_targsrc_curs_Access(_db_targsrc_curs &curs) {
    return targsrc_qFind(u64(curs.index));
}

// --- abt.FDb.syscmddep_curs.Reset
// cursor points to valid item
inline void abt::_db_syscmddep_curs_Reset(_db_syscmddep_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.syscmddep_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_syscmddep_curs_ValidQ(_db_syscmddep_curs &curs) {
    return curs.index < _db.syscmddep_n;
}

// --- abt.FDb.syscmddep_curs.Next
// proceed to next item
inline void abt::_db_syscmddep_curs_Next(_db_syscmddep_curs &curs) {
    curs.index++;
}

// --- abt.FDb.syscmddep_curs.Access
// item access
inline abt::FSyscmddep& abt::_db_syscmddep_curs_Access(_db_syscmddep_curs &curs) {
    return syscmddep_qFind(u64(curs.index));
}

// --- abt.FDb.syscmd_curs.Reset
// cursor points to valid item
inline void abt::_db_syscmd_curs_Reset(_db_syscmd_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.syscmd_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_syscmd_curs_ValidQ(_db_syscmd_curs &curs) {
    return curs.index < _db.syscmd_n;
}

// --- abt.FDb.syscmd_curs.Next
// proceed to next item
inline void abt::_db_syscmd_curs_Next(_db_syscmd_curs &curs) {
    curs.index++;
}

// --- abt.FDb.syscmd_curs.Access
// item access
inline abt::FSyscmd& abt::_db_syscmd_curs_Access(_db_syscmd_curs &curs) {
    return syscmd_qFind(i32(curs.index));
}

// --- abt.FDb.cfg_curs.Reset
// cursor points to valid item
inline void abt::_db_cfg_curs_Reset(_db_cfg_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.cfg_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_cfg_curs_ValidQ(_db_cfg_curs &curs) {
    return curs.index < _db.cfg_n;
}

// --- abt.FDb.cfg_curs.Next
// proceed to next item
inline void abt::_db_cfg_curs_Next(_db_cfg_curs &curs) {
    curs.index++;
}

// --- abt.FDb.cfg_curs.Access
// item access
inline abt::FCfg& abt::_db_cfg_curs_Access(_db_cfg_curs &curs) {
    return cfg_qFind(u64(curs.index));
}

// --- abt.FDb.uname_curs.Reset
// cursor points to valid item
inline void abt::_db_uname_curs_Reset(_db_uname_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.uname_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_uname_curs_ValidQ(_db_uname_curs &curs) {
    return curs.index < _db.uname_n;
}

// --- abt.FDb.uname_curs.Next
// proceed to next item
inline void abt::_db_uname_curs_Next(_db_uname_curs &curs) {
    curs.index++;
}

// --- abt.FDb.uname_curs.Access
// item access
inline abt::FUname& abt::_db_uname_curs_Access(_db_uname_curs &curs) {
    return uname_qFind(u64(curs.index));
}

// --- abt.FDb.compiler_curs.Reset
// cursor points to valid item
inline void abt::_db_compiler_curs_Reset(_db_compiler_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.compiler_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_compiler_curs_ValidQ(_db_compiler_curs &curs) {
    return curs.index < _db.compiler_n;
}

// --- abt.FDb.compiler_curs.Next
// proceed to next item
inline void abt::_db_compiler_curs_Next(_db_compiler_curs &curs) {
    curs.index++;
}

// --- abt.FDb.compiler_curs.Access
// item access
inline abt::FCompiler& abt::_db_compiler_curs_Access(_db_compiler_curs &curs) {
    return compiler_qFind(u64(curs.index));
}

// --- abt.FDb.arch_curs.Reset
// cursor points to valid item
inline void abt::_db_arch_curs_Reset(_db_arch_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.arch_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_arch_curs_ValidQ(_db_arch_curs &curs) {
    return curs.index < _db.arch_n;
}

// --- abt.FDb.arch_curs.Next
// proceed to next item
inline void abt::_db_arch_curs_Next(_db_arch_curs &curs) {
    curs.index++;
}

// --- abt.FDb.arch_curs.Access
// item access
inline abt::FArch& abt::_db_arch_curs_Access(_db_arch_curs &curs) {
    return arch_qFind(u64(curs.index));
}

// --- abt.FDb.bh_syscmd_curs.Access
// Access current element. If not more elements, return NULL
inline abt::FSyscmd& abt::_db_bh_syscmd_curs_Access(_db_bh_syscmd_curs &curs) {
    return *curs.temp_elems[0];
}

// --- abt.FDb.bh_syscmd_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool abt::_db_bh_syscmd_curs_ValidQ(_db_bh_syscmd_curs &curs) {
    return curs.temp_n > 0;
}

// --- abt.FDb.zs_srcfile_read_curs.Reset
// cursor points to valid item
inline void abt::_db_zs_srcfile_read_curs_Reset(_db_zs_srcfile_read_curs &curs, abt::FDb &parent) {
    curs.row = parent.zs_srcfile_read_head;
}

// --- abt.FDb.zs_srcfile_read_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_zs_srcfile_read_curs_ValidQ(_db_zs_srcfile_read_curs &curs) {
    return curs.row != NULL;
}

// --- abt.FDb.zs_srcfile_read_curs.Next
// proceed to next item
inline void abt::_db_zs_srcfile_read_curs_Next(_db_zs_srcfile_read_curs &curs) {
    abt::FSrcfile *next = (*curs.row).zs_srcfile_read_next;
    curs.row = next;
}

// --- abt.FDb.zs_srcfile_read_curs.Access
// item access
inline abt::FSrcfile& abt::_db_zs_srcfile_read_curs_Access(_db_zs_srcfile_read_curs &curs) {
    return *curs.row;
}

// --- abt.FDb.zs_sel_target_curs.Reset
// cursor points to valid item
inline void abt::_db_zs_sel_target_curs_Reset(_db_zs_sel_target_curs &curs, abt::FDb &parent) {
    curs.row = parent.zs_sel_target_head;
}

// --- abt.FDb.zs_sel_target_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_zs_sel_target_curs_ValidQ(_db_zs_sel_target_curs &curs) {
    return curs.row != NULL;
}

// --- abt.FDb.zs_sel_target_curs.Next
// proceed to next item
inline void abt::_db_zs_sel_target_curs_Next(_db_zs_sel_target_curs &curs) {
    abt::FTarget *next = (*curs.row).zs_sel_target_next;
    curs.row = next;
}

// --- abt.FDb.zs_sel_target_curs.Access
// item access
inline abt::FTarget& abt::_db_zs_sel_target_curs_Access(_db_zs_sel_target_curs &curs) {
    return *curs.row;
}

// --- abt.FDb.targsyslib_curs.Reset
// cursor points to valid item
inline void abt::_db_targsyslib_curs_Reset(_db_targsyslib_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.targsyslib_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_targsyslib_curs_ValidQ(_db_targsyslib_curs &curs) {
    return curs.index < _db.targsyslib_n;
}

// --- abt.FDb.targsyslib_curs.Next
// proceed to next item
inline void abt::_db_targsyslib_curs_Next(_db_targsyslib_curs &curs) {
    curs.index++;
}

// --- abt.FDb.targsyslib_curs.Access
// item access
inline abt::FTargsyslib& abt::_db_targsyslib_curs_Access(_db_targsyslib_curs &curs) {
    return targsyslib_qFind(u64(curs.index));
}

// --- abt.FDb.syslib_curs.Reset
// cursor points to valid item
inline void abt::_db_syslib_curs_Reset(_db_syslib_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.syslib_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_syslib_curs_ValidQ(_db_syslib_curs &curs) {
    return curs.index < _db.syslib_n;
}

// --- abt.FDb.syslib_curs.Next
// proceed to next item
inline void abt::_db_syslib_curs_Next(_db_syslib_curs &curs) {
    curs.index++;
}

// --- abt.FDb.syslib_curs.Access
// item access
inline abt::FSyslib& abt::_db_syslib_curs_Access(_db_syslib_curs &curs) {
    return syslib_qFind(u64(curs.index));
}

// --- abt.FDb.include_curs.Reset
// cursor points to valid item
inline void abt::_db_include_curs_Reset(_db_include_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.include_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_include_curs_ValidQ(_db_include_curs &curs) {
    return curs.index < _db.include_n;
}

// --- abt.FDb.include_curs.Next
// proceed to next item
inline void abt::_db_include_curs_Next(_db_include_curs &curs) {
    curs.index++;
}

// --- abt.FDb.include_curs.Access
// item access
inline abt::FInclude& abt::_db_include_curs_Access(_db_include_curs &curs) {
    return include_qFind(u64(curs.index));
}

// --- abt.FDb.sysincl_curs.Next
// proceed to next item
inline void abt::_db_sysincl_curs_Next(_db_sysincl_curs &curs) {
    curs.index++;
}

// --- abt.FDb.sysincl_curs.Reset
inline void abt::_db_sysincl_curs_Reset(_db_sysincl_curs &curs, abt::FDb &parent) {
    curs.elems = parent.sysincl_elems;
    curs.n_elems = parent.sysincl_n;
    curs.index = 0;
}

// --- abt.FDb.sysincl_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_sysincl_curs_ValidQ(_db_sysincl_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FDb.sysincl_curs.Access
// item access
inline algo::cstring& abt::_db_sysincl_curs_Access(_db_sysincl_curs &curs) {
    return curs.elems[curs.index];
}

// --- abt.FDb.zs_origsel_target_curs.Reset
// cursor points to valid item
inline void abt::_db_zs_origsel_target_curs_Reset(_db_zs_origsel_target_curs &curs, abt::FDb &parent) {
    curs.row = parent.zs_origsel_target_head;
}

// --- abt.FDb.zs_origsel_target_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_zs_origsel_target_curs_ValidQ(_db_zs_origsel_target_curs &curs) {
    return curs.row != NULL;
}

// --- abt.FDb.zs_origsel_target_curs.Next
// proceed to next item
inline void abt::_db_zs_origsel_target_curs_Next(_db_zs_origsel_target_curs &curs) {
    abt::FTarget *next = (*curs.row).zs_origsel_target_next;
    curs.row = next;
}

// --- abt.FDb.zs_origsel_target_curs.Access
// item access
inline abt::FTarget& abt::_db_zs_origsel_target_curs_Access(_db_zs_origsel_target_curs &curs) {
    return *curs.row;
}

// --- abt.FDb.ns_curs.Reset
// cursor points to valid item
inline void abt::_db_ns_curs_Reset(_db_ns_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.ns_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_ns_curs_ValidQ(_db_ns_curs &curs) {
    return curs.index < _db.ns_n;
}

// --- abt.FDb.ns_curs.Next
// proceed to next item
inline void abt::_db_ns_curs_Next(_db_ns_curs &curs) {
    curs.index++;
}

// --- abt.FDb.ns_curs.Access
// item access
inline abt::FNs& abt::_db_ns_curs_Access(_db_ns_curs &curs) {
    return ns_qFind(u64(curs.index));
}

// --- abt.FDb.filestat_curs.Reset
// cursor points to valid item
inline void abt::_db_filestat_curs_Reset(_db_filestat_curs &curs, abt::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt.FDb.filestat_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_filestat_curs_ValidQ(_db_filestat_curs &curs) {
    return curs.index < _db.filestat_n;
}

// --- abt.FDb.filestat_curs.Next
// proceed to next item
inline void abt::_db_filestat_curs_Next(_db_filestat_curs &curs) {
    curs.index++;
}

// --- abt.FDb.filestat_curs.Access
// item access
inline abt::FFilestat& abt::_db_filestat_curs_Access(_db_filestat_curs &curs) {
    return filestat_qFind(u64(curs.index));
}

// --- abt.FDb.zd_inclstack_curs.Reset
// cursor points to valid item
inline void abt::_db_zd_inclstack_curs_Reset(_db_zd_inclstack_curs &curs, abt::FDb &parent) {
    curs.row = parent.zd_inclstack_head;
}

// --- abt.FDb.zd_inclstack_curs.ValidQ
// cursor points to valid item
inline bool abt::_db_zd_inclstack_curs_ValidQ(_db_zd_inclstack_curs &curs) {
    return curs.row != NULL;
}

// --- abt.FDb.zd_inclstack_curs.Next
// proceed to next item
inline void abt::_db_zd_inclstack_curs_Next(_db_zd_inclstack_curs &curs) {
    abt::FSrcfile *next = (*curs.row).zd_inclstack_next;
    curs.row = next;
}

// --- abt.FDb.zd_inclstack_curs.Access
// item access
inline abt::FSrcfile& abt::_db_zd_inclstack_curs_Access(_db_zd_inclstack_curs &curs) {
    return *curs.row;
}

// --- abt.FFilestat..Init
// Set all fields to initial values.
inline void abt::FFilestat_Init(abt::FFilestat& filestat) {
    filestat.size = u64(0);
    filestat.isdir = bool(false);
    filestat.exists = bool(false);
    filestat.ind_filestat_next = (abt::FFilestat*)-1; // (abt.FDb.ind_filestat) not-in-hash
}

// --- abt.FFilestat..Ctor
inline  abt::FFilestat::FFilestat() {
    abt::FFilestat_Init(*this);
}

// --- abt.FFilestat..Dtor
inline  abt::FFilestat::~FFilestat() {
    abt::FFilestat_Uninit(*this);
}

// --- abt.FInclude..Init
// Set all fields to initial values.
inline void abt::FInclude_Init(abt::FInclude& include) {
    include.sys = bool(false);
    include.p_header = NULL;
    include.wantprint = bool(false);
    include.ind_include_next = (abt::FInclude*)-1; // (abt.FDb.ind_include) not-in-hash
    include.zd_include_next = (abt::FInclude*)-1; // (abt.FSrcfile.zd_include) not-in-list
    include.zd_include_prev = NULL; // (abt.FSrcfile.zd_include)
}

// --- abt.FInclude..Ctor
inline  abt::FInclude::FInclude() {
    abt::FInclude_Init(*this);
}

// --- abt.FInclude..Dtor
inline  abt::FInclude::~FInclude() {
    abt::FInclude_Uninit(*this);
}

// --- abt.FNs..Init
// Set all fields to initial values.
inline void abt::FNs_Init(abt::FNs& ns) {
    ns.ind_ns_next = (abt::FNs*)-1; // (abt.FDb.ind_ns) not-in-hash
}

// --- abt.FNs..Ctor
inline  abt::FNs::FNs() {
    abt::FNs_Init(*this);
}

// --- abt.FNs..Dtor
inline  abt::FNs::~FNs() {
    abt::FNs_Uninit(*this);
}

// --- abt.FSrcfile.zd_include.EmptyQ
// Return true if index is empty
inline bool abt::zd_include_EmptyQ(abt::FSrcfile& srcfile) {
    return srcfile.zd_include_head == NULL;
}

// --- abt.FSrcfile.zd_include.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt::FInclude* abt::zd_include_First(abt::FSrcfile& srcfile) {
    abt::FInclude *row = NULL;
    row = srcfile.zd_include_head;
    return row;
}

// --- abt.FSrcfile.zd_include.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt::zd_include_InLlistQ(abt::FInclude& row) {
    bool result = false;
    result = !(row.zd_include_next == (abt::FInclude*)-1);
    return result;
}

// --- abt.FSrcfile.zd_include.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt::FInclude* abt::zd_include_Last(abt::FSrcfile& srcfile) {
    abt::FInclude *row = NULL;
    row = srcfile.zd_include_tail;
    return row;
}

// --- abt.FSrcfile.zd_include.N
// Return number of items in the linked list
inline i32 abt::zd_include_N(const abt::FSrcfile& srcfile) {
    return srcfile.zd_include_n;
}

// --- abt.FSrcfile.zd_include.Next
// Return pointer to next element in the list
inline abt::FInclude* abt::zd_include_Next(abt::FInclude &row) {
    return row.zd_include_next;
}

// --- abt.FSrcfile.zd_include.Prev
// Return pointer to previous element in the list
inline abt::FInclude* abt::zd_include_Prev(abt::FInclude &row) {
    return row.zd_include_prev;
}

// --- abt.FSrcfile.zd_include.qLast
// Return reference to last element in the index. No bounds checking.
inline abt::FInclude& abt::zd_include_qLast(abt::FSrcfile& srcfile) {
    abt::FInclude *row = NULL;
    row = srcfile.zd_include_tail;
    return *row;
}

// --- abt.FSrcfile.zd_include_curs.Reset
// cursor points to valid item
inline void abt::srcfile_zd_include_curs_Reset(srcfile_zd_include_curs &curs, abt::FSrcfile &parent) {
    curs.row = parent.zd_include_head;
}

// --- abt.FSrcfile.zd_include_curs.ValidQ
// cursor points to valid item
inline bool abt::srcfile_zd_include_curs_ValidQ(srcfile_zd_include_curs &curs) {
    return curs.row != NULL;
}

// --- abt.FSrcfile.zd_include_curs.Next
// proceed to next item
inline void abt::srcfile_zd_include_curs_Next(srcfile_zd_include_curs &curs) {
    abt::FInclude *next = (*curs.row).zd_include_next;
    curs.row = next;
}

// --- abt.FSrcfile.zd_include_curs.Access
// item access
inline abt::FInclude& abt::srcfile_zd_include_curs_Access(srcfile_zd_include_curs &curs) {
    return *curs.row;
}

// --- abt.FSrcfile..Ctor
inline  abt::FSrcfile::FSrcfile() {
    abt::FSrcfile_Init(*this);
}

// --- abt.FSrcfile..Dtor
inline  abt::FSrcfile::~FSrcfile() {
    abt::FSrcfile_Uninit(*this);
}

// --- abt.FSyscmd.c_prior.EmptyQ
// Return true if index is empty
inline bool abt::c_prior_EmptyQ(abt::FSyscmd& syscmd) {
    return syscmd.c_prior_n == 0;
}

// --- abt.FSyscmd.c_prior.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSyscmddep* abt::c_prior_Find(abt::FSyscmd& syscmd, u32 t) {
    abt::FSyscmddep *retval = NULL;
    u64 idx = t;
    u64 lim = syscmd.c_prior_n;
    if (idx < lim) {
        retval = syscmd.c_prior_elems[idx];
    }
    return retval;
}

// --- abt.FSyscmd.c_prior.Getary
// Return array of pointers
inline algo::aryptr<abt::FSyscmddep*> abt::c_prior_Getary(abt::FSyscmd& syscmd) {
    return algo::aryptr<abt::FSyscmddep*>(syscmd.c_prior_elems, syscmd.c_prior_n);
}

// --- abt.FSyscmd.c_prior.N
// Return number of items in the pointer array
inline i32 abt::c_prior_N(const abt::FSyscmd& syscmd) {
    return syscmd.c_prior_n;
}

// --- abt.FSyscmd.c_prior.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_prior_RemoveAll(abt::FSyscmd& syscmd) {
    for (u32 i = 0; i < syscmd.c_prior_n; i++) {
        // mark all elements as not-in-array
        syscmd.c_prior_elems[i]->syscmd_c_prior_in_ary = false;
    }
    syscmd.c_prior_n = 0;
}

// --- abt.FSyscmd.c_prior.qFind
// Return reference without bounds checking
inline abt::FSyscmddep& abt::c_prior_qFind(abt::FSyscmd& syscmd, u32 idx) {
    return *syscmd.c_prior_elems[idx];
}

// --- abt.FSyscmd.c_prior.InAryQ
// True if row is in any ptrary instance
inline bool abt::syscmd_c_prior_InAryQ(abt::FSyscmddep& row) {
    return row.syscmd_c_prior_in_ary;
}

// --- abt.FSyscmd.c_prior.qLast
// Reference to last element without bounds checking
inline abt::FSyscmddep& abt::c_prior_qLast(abt::FSyscmd& syscmd) {
    return *syscmd.c_prior_elems[syscmd.c_prior_n-1];
}

// --- abt.FSyscmd.c_next.EmptyQ
// Return true if index is empty
inline bool abt::c_next_EmptyQ(abt::FSyscmd& syscmd) {
    return syscmd.c_next_n == 0;
}

// --- abt.FSyscmd.c_next.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSyscmddep* abt::c_next_Find(abt::FSyscmd& syscmd, u32 t) {
    abt::FSyscmddep *retval = NULL;
    u64 idx = t;
    u64 lim = syscmd.c_next_n;
    if (idx < lim) {
        retval = syscmd.c_next_elems[idx];
    }
    return retval;
}

// --- abt.FSyscmd.c_next.Getary
// Return array of pointers
inline algo::aryptr<abt::FSyscmddep*> abt::c_next_Getary(abt::FSyscmd& syscmd) {
    return algo::aryptr<abt::FSyscmddep*>(syscmd.c_next_elems, syscmd.c_next_n);
}

// --- abt.FSyscmd.c_next.N
// Return number of items in the pointer array
inline i32 abt::c_next_N(const abt::FSyscmd& syscmd) {
    return syscmd.c_next_n;
}

// --- abt.FSyscmd.c_next.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_next_RemoveAll(abt::FSyscmd& syscmd) {
    for (u32 i = 0; i < syscmd.c_next_n; i++) {
        // mark all elements as not-in-array
        syscmd.c_next_elems[i]->syscmd_c_next_in_ary = false;
    }
    syscmd.c_next_n = 0;
}

// --- abt.FSyscmd.c_next.qFind
// Return reference without bounds checking
inline abt::FSyscmddep& abt::c_next_qFind(abt::FSyscmd& syscmd, u32 idx) {
    return *syscmd.c_next_elems[idx];
}

// --- abt.FSyscmd.c_next.InAryQ
// True if row is in any ptrary instance
inline bool abt::syscmd_c_next_InAryQ(abt::FSyscmddep& row) {
    return row.syscmd_c_next_in_ary;
}

// --- abt.FSyscmd.c_next.qLast
// Reference to last element without bounds checking
inline abt::FSyscmddep& abt::c_next_qLast(abt::FSyscmd& syscmd) {
    return *syscmd.c_next_elems[syscmd.c_next_n-1];
}

// --- abt.FSyscmd.c_prior_curs.Reset
inline void abt::syscmd_c_prior_curs_Reset(syscmd_c_prior_curs &curs, abt::FSyscmd &parent) {
    curs.elems = parent.c_prior_elems;
    curs.n_elems = parent.c_prior_n;
    curs.index = 0;
}

// --- abt.FSyscmd.c_prior_curs.ValidQ
// cursor points to valid item
inline bool abt::syscmd_c_prior_curs_ValidQ(syscmd_c_prior_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FSyscmd.c_prior_curs.Next
// proceed to next item
inline void abt::syscmd_c_prior_curs_Next(syscmd_c_prior_curs &curs) {
    curs.index++;
}

// --- abt.FSyscmd.c_prior_curs.Access
// item access
inline abt::FSyscmddep& abt::syscmd_c_prior_curs_Access(syscmd_c_prior_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FSyscmd.c_next_curs.Reset
inline void abt::syscmd_c_next_curs_Reset(syscmd_c_next_curs &curs, abt::FSyscmd &parent) {
    curs.elems = parent.c_next_elems;
    curs.n_elems = parent.c_next_n;
    curs.index = 0;
}

// --- abt.FSyscmd.c_next_curs.ValidQ
// cursor points to valid item
inline bool abt::syscmd_c_next_curs_ValidQ(syscmd_c_next_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FSyscmd.c_next_curs.Next
// proceed to next item
inline void abt::syscmd_c_next_curs_Next(syscmd_c_next_curs &curs) {
    curs.index++;
}

// --- abt.FSyscmd.c_next_curs.Access
// item access
inline abt::FSyscmddep& abt::syscmd_c_next_curs_Access(syscmd_c_next_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FSyscmd..Ctor
inline  abt::FSyscmd::FSyscmd() {
    abt::FSyscmd_Init(*this);
}

// --- abt.FSyscmd..Dtor
inline  abt::FSyscmd::~FSyscmd() {
    abt::FSyscmd_Uninit(*this);
}

// --- abt.FSyscmddep..Init
// Set all fields to initial values.
inline void abt::FSyscmddep_Init(abt::FSyscmddep& syscmddep) {
    syscmddep.child = i64(0);
    syscmddep.parent = i64(0);
    syscmddep.p_child = NULL;
    syscmddep.p_parent = NULL;
    syscmddep.syscmd_c_next_in_ary = bool(false);
    syscmddep.syscmd_c_prior_in_ary = bool(false);
}

// --- abt.FSyscmddep..Ctor
inline  abt::FSyscmddep::FSyscmddep() {
    abt::FSyscmddep_Init(*this);
}

// --- abt.FSyscmddep..Dtor
inline  abt::FSyscmddep::~FSyscmddep() {
    abt::FSyscmddep_Uninit(*this);
}

// --- abt.FSyslib..Init
// Set all fields to initial values.
inline void abt::FSyslib_Init(abt::FSyslib& syslib) {
    syslib.ind_syslib_next = (abt::FSyslib*)-1; // (abt.FDb.ind_syslib) not-in-hash
}

// --- abt.FSyslib..Ctor
inline  abt::FSyslib::FSyslib() {
    abt::FSyslib_Init(*this);
}

// --- abt.FSyslib..Dtor
inline  abt::FSyslib::~FSyslib() {
    abt::FSyslib_Uninit(*this);
}

// --- abt.FTargdep..Init
// Set all fields to initial values.
inline void abt::FTargdep_Init(abt::FTargdep& targdep) {
    targdep.p_parent = NULL;
    targdep.target_c_targdep_in_ary = bool(false);
}

// --- abt.FTargdep..Ctor
inline  abt::FTargdep::FTargdep() {
    abt::FTargdep_Init(*this);
}

// --- abt.FTargdep..Dtor
inline  abt::FTargdep::~FTargdep() {
    abt::FTargdep_Uninit(*this);
}

// --- abt.FTarget.c_targsrc.EmptyQ
// Return true if index is empty
inline bool abt::c_targsrc_EmptyQ(abt::FTarget& target) {
    return target.c_targsrc_n == 0;
}

// --- abt.FTarget.c_targsrc.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTargsrc* abt::c_targsrc_Find(abt::FTarget& target, u32 t) {
    abt::FTargsrc *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_targsrc_n;
    if (idx < lim) {
        retval = target.c_targsrc_elems[idx];
    }
    return retval;
}

// --- abt.FTarget.c_targsrc.Getary
// Return array of pointers
inline algo::aryptr<abt::FTargsrc*> abt::c_targsrc_Getary(abt::FTarget& target) {
    return algo::aryptr<abt::FTargsrc*>(target.c_targsrc_elems, target.c_targsrc_n);
}

// --- abt.FTarget.c_targsrc.N
// Return number of items in the pointer array
inline i32 abt::c_targsrc_N(const abt::FTarget& target) {
    return target.c_targsrc_n;
}

// --- abt.FTarget.c_targsrc.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_targsrc_RemoveAll(abt::FTarget& target) {
    for (u32 i = 0; i < target.c_targsrc_n; i++) {
        // mark all elements as not-in-array
        target.c_targsrc_elems[i]->target_c_targsrc_in_ary = false;
    }
    target.c_targsrc_n = 0;
}

// --- abt.FTarget.c_targsrc.qFind
// Return reference without bounds checking
inline abt::FTargsrc& abt::c_targsrc_qFind(abt::FTarget& target, u32 idx) {
    return *target.c_targsrc_elems[idx];
}

// --- abt.FTarget.c_targsrc.InAryQ
// True if row is in any ptrary instance
inline bool abt::target_c_targsrc_InAryQ(abt::FTargsrc& row) {
    return row.target_c_targsrc_in_ary;
}

// --- abt.FTarget.c_targsrc.qLast
// Reference to last element without bounds checking
inline abt::FTargsrc& abt::c_targsrc_qLast(abt::FTarget& target) {
    return *target.c_targsrc_elems[target.c_targsrc_n-1];
}

// --- abt.FTarget.c_srcfile.EmptyQ
// Return true if index is empty
inline bool abt::c_srcfile_EmptyQ(abt::FTarget& target) {
    return target.c_srcfile_n == 0;
}

// --- abt.FTarget.c_srcfile.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSrcfile* abt::c_srcfile_Find(abt::FTarget& target, u32 t) {
    abt::FSrcfile *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_srcfile_n;
    if (idx < lim) {
        retval = target.c_srcfile_elems[idx];
    }
    return retval;
}

// --- abt.FTarget.c_srcfile.Getary
// Return array of pointers
inline algo::aryptr<abt::FSrcfile*> abt::c_srcfile_Getary(abt::FTarget& target) {
    return algo::aryptr<abt::FSrcfile*>(target.c_srcfile_elems, target.c_srcfile_n);
}

// --- abt.FTarget.c_srcfile.N
// Return number of items in the pointer array
inline i32 abt::c_srcfile_N(const abt::FTarget& target) {
    return target.c_srcfile_n;
}

// --- abt.FTarget.c_srcfile.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_srcfile_RemoveAll(abt::FTarget& target) {
    target.c_srcfile_n = 0;
}

// --- abt.FTarget.c_srcfile.qFind
// Return reference without bounds checking
inline abt::FSrcfile& abt::c_srcfile_qFind(abt::FTarget& target, u32 idx) {
    return *target.c_srcfile_elems[idx];
}

// --- abt.FTarget.c_srcfile.qLast
// Reference to last element without bounds checking
inline abt::FSrcfile& abt::c_srcfile_qLast(abt::FTarget& target) {
    return *target.c_srcfile_elems[target.c_srcfile_n-1];
}

// --- abt.FTarget.c_targdep.EmptyQ
// Return true if index is empty
inline bool abt::c_targdep_EmptyQ(abt::FTarget& target) {
    return target.c_targdep_n == 0;
}

// --- abt.FTarget.c_targdep.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTargdep* abt::c_targdep_Find(abt::FTarget& target, u32 t) {
    abt::FTargdep *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_targdep_n;
    if (idx < lim) {
        retval = target.c_targdep_elems[idx];
    }
    return retval;
}

// --- abt.FTarget.c_targdep.Getary
// Return array of pointers
inline algo::aryptr<abt::FTargdep*> abt::c_targdep_Getary(abt::FTarget& target) {
    return algo::aryptr<abt::FTargdep*>(target.c_targdep_elems, target.c_targdep_n);
}

// --- abt.FTarget.c_targdep.N
// Return number of items in the pointer array
inline i32 abt::c_targdep_N(const abt::FTarget& target) {
    return target.c_targdep_n;
}

// --- abt.FTarget.c_targdep.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_targdep_RemoveAll(abt::FTarget& target) {
    for (u32 i = 0; i < target.c_targdep_n; i++) {
        // mark all elements as not-in-array
        target.c_targdep_elems[i]->target_c_targdep_in_ary = false;
    }
    target.c_targdep_n = 0;
}

// --- abt.FTarget.c_targdep.qFind
// Return reference without bounds checking
inline abt::FTargdep& abt::c_targdep_qFind(abt::FTarget& target, u32 idx) {
    return *target.c_targdep_elems[idx];
}

// --- abt.FTarget.c_targdep.InAryQ
// True if row is in any ptrary instance
inline bool abt::target_c_targdep_InAryQ(abt::FTargdep& row) {
    return row.target_c_targdep_in_ary;
}

// --- abt.FTarget.c_targdep.qLast
// Reference to last element without bounds checking
inline abt::FTargdep& abt::c_targdep_qLast(abt::FTarget& target) {
    return *target.c_targdep_elems[target.c_targdep_n-1];
}

// --- abt.FTarget.c_targsyslib.EmptyQ
// Return true if index is empty
inline bool abt::c_targsyslib_EmptyQ(abt::FTarget& target) {
    return target.c_targsyslib_n == 0;
}

// --- abt.FTarget.c_targsyslib.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTargsyslib* abt::c_targsyslib_Find(abt::FTarget& target, u32 t) {
    abt::FTargsyslib *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_targsyslib_n;
    if (idx < lim) {
        retval = target.c_targsyslib_elems[idx];
    }
    return retval;
}

// --- abt.FTarget.c_targsyslib.Getary
// Return array of pointers
inline algo::aryptr<abt::FTargsyslib*> abt::c_targsyslib_Getary(abt::FTarget& target) {
    return algo::aryptr<abt::FTargsyslib*>(target.c_targsyslib_elems, target.c_targsyslib_n);
}

// --- abt.FTarget.c_targsyslib.N
// Return number of items in the pointer array
inline i32 abt::c_targsyslib_N(const abt::FTarget& target) {
    return target.c_targsyslib_n;
}

// --- abt.FTarget.c_targsyslib.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_targsyslib_RemoveAll(abt::FTarget& target) {
    for (u32 i = 0; i < target.c_targsyslib_n; i++) {
        // mark all elements as not-in-array
        target.c_targsyslib_elems[i]->target_c_targsyslib_in_ary = false;
    }
    target.c_targsyslib_n = 0;
}

// --- abt.FTarget.c_targsyslib.qFind
// Return reference without bounds checking
inline abt::FTargsyslib& abt::c_targsyslib_qFind(abt::FTarget& target, u32 idx) {
    return *target.c_targsyslib_elems[idx];
}

// --- abt.FTarget.c_targsyslib.InAryQ
// True if row is in any ptrary instance
inline bool abt::target_c_targsyslib_InAryQ(abt::FTargsyslib& row) {
    return row.target_c_targsyslib_in_ary;
}

// --- abt.FTarget.c_targsyslib.qLast
// Reference to last element without bounds checking
inline abt::FTargsyslib& abt::c_targsyslib_qLast(abt::FTarget& target) {
    return *target.c_targsyslib_elems[target.c_targsyslib_n-1];
}

// --- abt.FTarget.c_alldep.EmptyQ
// Return true if index is empty
inline bool abt::c_alldep_EmptyQ(abt::FTarget& target) {
    return target.c_alldep_n == 0;
}

// --- abt.FTarget.c_alldep.Find
// Look up row by row id. Return NULL if out of range
inline abt::FTarget* abt::c_alldep_Find(abt::FTarget& target, u32 t) {
    abt::FTarget *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_alldep_n;
    if (idx < lim) {
        retval = target.c_alldep_elems[idx];
    }
    return retval;
}

// --- abt.FTarget.c_alldep.Getary
// Return array of pointers
inline algo::aryptr<abt::FTarget*> abt::c_alldep_Getary(abt::FTarget& target) {
    return algo::aryptr<abt::FTarget*>(target.c_alldep_elems, target.c_alldep_n);
}

// --- abt.FTarget.c_alldep.N
// Return number of items in the pointer array
inline i32 abt::c_alldep_N(const abt::FTarget& target) {
    return target.c_alldep_n;
}

// --- abt.FTarget.c_alldep.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_alldep_RemoveAll(abt::FTarget& target) {
    target.c_alldep_n = 0;
}

// --- abt.FTarget.c_alldep.qFind
// Return reference without bounds checking
inline abt::FTarget& abt::c_alldep_qFind(abt::FTarget& target, u32 idx) {
    return *target.c_alldep_elems[idx];
}

// --- abt.FTarget.c_alldep.qLast
// Reference to last element without bounds checking
inline abt::FTarget& abt::c_alldep_qLast(abt::FTarget& target) {
    return *target.c_alldep_elems[target.c_alldep_n-1];
}

// --- abt.FTarget.c_alllib.EmptyQ
// Return true if index is empty
inline bool abt::c_alllib_EmptyQ(abt::FTarget& target) {
    return target.c_alllib_n == 0;
}

// --- abt.FTarget.c_alllib.Find
// Look up row by row id. Return NULL if out of range
inline abt::FSyslib* abt::c_alllib_Find(abt::FTarget& target, u32 t) {
    abt::FSyslib *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_alllib_n;
    if (idx < lim) {
        retval = target.c_alllib_elems[idx];
    }
    return retval;
}

// --- abt.FTarget.c_alllib.Getary
// Return array of pointers
inline algo::aryptr<abt::FSyslib*> abt::c_alllib_Getary(abt::FTarget& target) {
    return algo::aryptr<abt::FSyslib*>(target.c_alllib_elems, target.c_alllib_n);
}

// --- abt.FTarget.c_alllib.N
// Return number of items in the pointer array
inline i32 abt::c_alllib_N(const abt::FTarget& target) {
    return target.c_alllib_n;
}

// --- abt.FTarget.c_alllib.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt::c_alllib_RemoveAll(abt::FTarget& target) {
    target.c_alllib_n = 0;
}

// --- abt.FTarget.c_alllib.qFind
// Return reference without bounds checking
inline abt::FSyslib& abt::c_alllib_qFind(abt::FTarget& target, u32 idx) {
    return *target.c_alllib_elems[idx];
}

// --- abt.FTarget.c_alllib.qLast
// Reference to last element without bounds checking
inline abt::FSyslib& abt::c_alllib_qLast(abt::FTarget& target) {
    return *target.c_alllib_elems[target.c_alllib_n-1];
}

// --- abt.FTarget.c_targsrc_curs.Reset
inline void abt::target_c_targsrc_curs_Reset(target_c_targsrc_curs &curs, abt::FTarget &parent) {
    curs.elems = parent.c_targsrc_elems;
    curs.n_elems = parent.c_targsrc_n;
    curs.index = 0;
}

// --- abt.FTarget.c_targsrc_curs.ValidQ
// cursor points to valid item
inline bool abt::target_c_targsrc_curs_ValidQ(target_c_targsrc_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FTarget.c_targsrc_curs.Next
// proceed to next item
inline void abt::target_c_targsrc_curs_Next(target_c_targsrc_curs &curs) {
    curs.index++;
}

// --- abt.FTarget.c_targsrc_curs.Access
// item access
inline abt::FTargsrc& abt::target_c_targsrc_curs_Access(target_c_targsrc_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FTarget.c_srcfile_curs.Reset
inline void abt::target_c_srcfile_curs_Reset(target_c_srcfile_curs &curs, abt::FTarget &parent) {
    curs.elems = parent.c_srcfile_elems;
    curs.n_elems = parent.c_srcfile_n;
    curs.index = 0;
}

// --- abt.FTarget.c_srcfile_curs.ValidQ
// cursor points to valid item
inline bool abt::target_c_srcfile_curs_ValidQ(target_c_srcfile_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FTarget.c_srcfile_curs.Next
// proceed to next item
inline void abt::target_c_srcfile_curs_Next(target_c_srcfile_curs &curs) {
    curs.index++;
}

// --- abt.FTarget.c_srcfile_curs.Access
// item access
inline abt::FSrcfile& abt::target_c_srcfile_curs_Access(target_c_srcfile_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FTarget.c_targdep_curs.Reset
inline void abt::target_c_targdep_curs_Reset(target_c_targdep_curs &curs, abt::FTarget &parent) {
    curs.elems = parent.c_targdep_elems;
    curs.n_elems = parent.c_targdep_n;
    curs.index = 0;
}

// --- abt.FTarget.c_targdep_curs.ValidQ
// cursor points to valid item
inline bool abt::target_c_targdep_curs_ValidQ(target_c_targdep_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FTarget.c_targdep_curs.Next
// proceed to next item
inline void abt::target_c_targdep_curs_Next(target_c_targdep_curs &curs) {
    curs.index++;
}

// --- abt.FTarget.c_targdep_curs.Access
// item access
inline abt::FTargdep& abt::target_c_targdep_curs_Access(target_c_targdep_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FTarget.c_targsyslib_curs.Reset
inline void abt::target_c_targsyslib_curs_Reset(target_c_targsyslib_curs &curs, abt::FTarget &parent) {
    curs.elems = parent.c_targsyslib_elems;
    curs.n_elems = parent.c_targsyslib_n;
    curs.index = 0;
}

// --- abt.FTarget.c_targsyslib_curs.ValidQ
// cursor points to valid item
inline bool abt::target_c_targsyslib_curs_ValidQ(target_c_targsyslib_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FTarget.c_targsyslib_curs.Next
// proceed to next item
inline void abt::target_c_targsyslib_curs_Next(target_c_targsyslib_curs &curs) {
    curs.index++;
}

// --- abt.FTarget.c_targsyslib_curs.Access
// item access
inline abt::FTargsyslib& abt::target_c_targsyslib_curs_Access(target_c_targsyslib_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FTarget.c_alldep_curs.Reset
inline void abt::target_c_alldep_curs_Reset(target_c_alldep_curs &curs, abt::FTarget &parent) {
    curs.elems = parent.c_alldep_elems;
    curs.n_elems = parent.c_alldep_n;
    curs.index = 0;
}

// --- abt.FTarget.c_alldep_curs.ValidQ
// cursor points to valid item
inline bool abt::target_c_alldep_curs_ValidQ(target_c_alldep_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FTarget.c_alldep_curs.Next
// proceed to next item
inline void abt::target_c_alldep_curs_Next(target_c_alldep_curs &curs) {
    curs.index++;
}

// --- abt.FTarget.c_alldep_curs.Access
// item access
inline abt::FTarget& abt::target_c_alldep_curs_Access(target_c_alldep_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FTarget.c_alllib_curs.Reset
inline void abt::target_c_alllib_curs_Reset(target_c_alllib_curs &curs, abt::FTarget &parent) {
    curs.elems = parent.c_alllib_elems;
    curs.n_elems = parent.c_alllib_n;
    curs.index = 0;
}

// --- abt.FTarget.c_alllib_curs.ValidQ
// cursor points to valid item
inline bool abt::target_c_alllib_curs_ValidQ(target_c_alllib_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt.FTarget.c_alllib_curs.Next
// proceed to next item
inline void abt::target_c_alllib_curs_Next(target_c_alllib_curs &curs) {
    curs.index++;
}

// --- abt.FTarget.c_alllib_curs.Access
// item access
inline abt::FSyslib& abt::target_c_alllib_curs_Access(target_c_alllib_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt.FTarget..Ctor
inline  abt::FTarget::FTarget() {
    abt::FTarget_Init(*this);
}

// --- abt.FTarget..Dtor
inline  abt::FTarget::~FTarget() {
    abt::FTarget_Uninit(*this);
}

// --- abt.FTargsrc..Init
// Set all fields to initial values.
inline void abt::FTargsrc_Init(abt::FTargsrc& targsrc) {
    targsrc.p_target = NULL;
    targsrc.target_c_targsrc_in_ary = bool(false);
    targsrc.ind_targsrc_next = (abt::FTargsrc*)-1; // (abt.FDb.ind_targsrc) not-in-hash
}

// --- abt.FTargsrc..Ctor
inline  abt::FTargsrc::FTargsrc() {
    abt::FTargsrc_Init(*this);
}

// --- abt.FTargsrc..Dtor
inline  abt::FTargsrc::~FTargsrc() {
    abt::FTargsrc_Uninit(*this);
}

// --- abt.FTargsyslib..Init
// Set all fields to initial values.
inline void abt::FTargsyslib_Init(abt::FTargsyslib& targsyslib) {
    targsyslib.p_syslib = NULL;
    targsyslib.target_c_targsyslib_in_ary = bool(false);
}

// --- abt.FTargsyslib..Ctor
inline  abt::FTargsyslib::FTargsyslib() {
    abt::FTargsyslib_Init(*this);
}

// --- abt.FTargsyslib..Dtor
inline  abt::FTargsyslib::~FTargsyslib() {
    abt::FTargsyslib_Uninit(*this);
}

// --- abt.FToolOpt..Ctor
inline  abt::FToolOpt::FToolOpt() {
    abt::FToolOpt_Init(*this);
}

// --- abt.FUname..Init
// Set all fields to initial values.
inline void abt::FUname_Init(abt::FUname& uname) {
    uname.ind_uname_next = (abt::FUname*)-1; // (abt.FDb.ind_uname) not-in-hash
}

// --- abt.FUname..Ctor
inline  abt::FUname::FUname() {
    abt::FUname_Init(*this);
}

// --- abt.FUname..Dtor
inline  abt::FUname::~FUname() {
    abt::FUname_Uninit(*this);
}

// --- abt.FieldId.value.GetEnum
// Get value of field as enum type
inline abt_FieldIdEnum abt::value_GetEnum(const abt::FieldId& parent) {
    return abt_FieldIdEnum(parent.value);
}

// --- abt.FieldId.value.SetEnum
// Set value of field from enum type.
inline void abt::value_SetEnum(abt::FieldId& parent, abt_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- abt.FieldId.value.Cast
inline  abt::FieldId::operator abt_FieldIdEnum() const {
    return abt_FieldIdEnum((*this).value);
}

// --- abt.FieldId..Init
// Set all fields to initial values.
inline void abt::FieldId_Init(abt::FieldId& parent) {
    parent.value = i32(-1);
}

// --- abt.FieldId..Ctor
inline  abt::FieldId::FieldId() {
    abt::FieldId_Init(*this);
}

// --- abt.FieldId..FieldwiseCtor
inline  abt::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- abt.FieldId..EnumCtor
inline  abt::FieldId::FieldId(abt_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- abt.TableId.value.GetEnum
// Get value of field as enum type
inline abt_TableIdEnum abt::value_GetEnum(const abt::TableId& parent) {
    return abt_TableIdEnum(parent.value);
}

// --- abt.TableId.value.SetEnum
// Set value of field from enum type.
inline void abt::value_SetEnum(abt::TableId& parent, abt_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- abt.TableId.value.Cast
inline  abt::TableId::operator abt_TableIdEnum() const {
    return abt_TableIdEnum((*this).value);
}

// --- abt.TableId..Init
// Set all fields to initial values.
inline void abt::TableId_Init(abt::TableId& parent) {
    parent.value = i32(-1);
}

// --- abt.TableId..Ctor
inline  abt::TableId::TableId() {
    abt::TableId_Init(*this);
}

// --- abt.TableId..FieldwiseCtor
inline  abt::TableId::TableId(i32 in_value)
    : value(in_value)
 {
}

// --- abt.TableId..EnumCtor
inline  abt::TableId::TableId(abt_TableIdEnum arg) {
    this->value = i32(arg);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const abt::trace &row) {// cfmt:abt.trace.String
    abt::trace_Print(const_cast<abt::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const abt::FieldId &row) {// cfmt:abt.FieldId.String
    abt::FieldId_Print(const_cast<abt::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const abt::TableId &row) {// cfmt:abt.TableId.String
    abt::TableId_Print(const_cast<abt::TableId&>(row), str);
    return str;
}
