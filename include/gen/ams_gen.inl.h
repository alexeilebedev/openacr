//
// include/gen/ams_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/ietf_gen.inl.h"
//#pragma endinclude

// --- ams.ExpectMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ExpectMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ExpectMsg.
// If not successful, quietly return NULL.
inline ams::ExpectMsg* ams::ExpectMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (395);
    cond &= i32(hdr.length) >= ssizeof(ams::ExpectMsg);
    return cond ? reinterpret_cast<ams::ExpectMsg*>(&hdr) : NULL;
}

// --- ams.ExpectMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ExpectMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ExpectMsg.text.N
// Return number of elements in varlen field
inline u32 ams::text_N(const ams::ExpectMsg& parent) {
    u32 length = i32(((ams::ExpectMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::ExpectMsg)) - sizeof(ams::ExpectMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.ExpectMsg.text_curs.Reset
inline void ams::ExpectMsg_text_curs_Reset(ExpectMsg_text_curs &curs, ams::ExpectMsg &parent) {
    curs.ptr = (u8*)text_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::ExpectMsg);
    curs.index = 0;
}

// --- ams.ExpectMsg.text_curs.ValidQ
// cursor points to valid item
inline bool ams::ExpectMsg_text_curs_ValidQ(ExpectMsg_text_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.ExpectMsg.text_curs.Next
// proceed to next item
inline void ams::ExpectMsg_text_curs_Next(ExpectMsg_text_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.ExpectMsg.text_curs.Access
// item access
inline char& ams::ExpectMsg_text_curs_Access(ExpectMsg_text_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.ExpectMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ExpectMsg& parent) {
    return i32(const_cast<ams::ExpectMsg&>(parent).length);
}

// --- ams.ExpectMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ExpectMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ExpectMsg&>(row).length));
}

// --- ams.ExpectMsg..Init
// Set all fields to initial values.
inline void ams::ExpectMsg_Init(ams::ExpectMsg& parent) {
    parent.type = u32(395);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.ExpectMsg..Ctor
inline  ams::ExpectMsg::ExpectMsg() {
    ams::ExpectMsg_Init(*this);
}

// --- ams.FieldId.value.GetEnum
// Get value of field as enum type
inline ams_FieldIdEnum ams::value_GetEnum(const ams::FieldId& parent) {
    return ams_FieldIdEnum(parent.value);
}

// --- ams.FieldId.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::FieldId& parent, ams_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- ams.FieldId.value.Cast
inline  ams::FieldId::operator ams_FieldIdEnum() const {
    return ams_FieldIdEnum((*this).value);
}

// --- ams.FieldId..Init
// Set all fields to initial values.
inline void ams::FieldId_Init(ams::FieldId& parent) {
    parent.value = i32(-1);
}

// --- ams.FieldId..Ctor
inline  ams::FieldId::FieldId() {
    ams::FieldId_Init(*this);
}

// --- ams.FieldId..FieldwiseCtor
inline  ams::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- ams.FieldId..EnumCtor
inline  ams::FieldId::FieldId(ams_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- ams.Proctype.value.GetEnum
// Get value of field as enum type
inline ams_ProctypeEnum ams::value_GetEnum(const ams::Proctype& parent) {
    return ams_ProctypeEnum(parent.value);
}

// --- ams.Proctype.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::Proctype& parent, ams_ProctypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- ams.Proctype..Hash
inline u32 ams::Proctype_Hash(u32 prev, ams::Proctype rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- ams.Proctype..EqOp
inline bool ams::Proctype::operator ==(const ams::Proctype &rhs) const {
    return ams::Proctype_Eq(const_cast<ams::Proctype&>(*this),const_cast<ams::Proctype&>(rhs));
}

// --- ams.Proctype..NeOp
inline bool ams::Proctype::operator !=(const ams::Proctype &rhs) const {
    return !ams::Proctype_Eq(const_cast<ams::Proctype&>(*this),const_cast<ams::Proctype&>(rhs));
}

// --- ams.Proctype..Cmp
inline i32 ams::Proctype_Cmp(ams::Proctype lhs, ams::Proctype rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- ams.Proctype..Init
// Set all fields to initial values.
inline void ams::Proctype_Init(ams::Proctype& parent) {
    parent.value = u8(0);
}

// --- ams.Proctype..Eq
inline bool ams::Proctype_Eq(ams::Proctype lhs, ams::Proctype rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- ams.Proctype..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool ams::Proctype::operator ==(ams_ProctypeEnum rhs) const {
    return ams_ProctypeEnum(value) == rhs;
}

// --- ams.Proctype..Ctor
inline  ams::Proctype::Proctype() {
    ams::Proctype_Init(*this);
}

// --- ams.Proctype..FieldwiseCtor
inline  ams::Proctype::Proctype(u8 in_value)
    : value(in_value)
 {
}

// --- ams.Proctype..EnumCtor
inline  ams::Proctype::Proctype(ams_ProctypeEnum arg) {
    this->value = u8(arg);
}

// --- ams.ProcId.proctype.Get
// Retrieve bitfield from value of field value
//    8 bits starting at bit 24.
inline ams::Proctype ams::proctype_Get(const ams::ProcId& parent) {
    return ams::Proctype((parent.value >> 24) & 0xff);
}

// --- ams.ProcId.proctype.Set
// Set bitfield in value of field 'value'
//    8 bits starting at bit 24.
inline void ams::proctype_Set(ams::ProcId& parent, ams::Proctype rhs) {
    u32 t1    = u32(0xff) << 24;
    u32 t2    = (u32(rhs.value) & 0xff) << 24;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- ams.ProcId.nodeidx.Get
// Retrieve bitfield from value of field value
//    8 bits starting at bit 8.
inline u8 ams::nodeidx_Get(const ams::ProcId& parent) {
    return u8((parent.value >> 8) & 0xff);
}

// --- ams.ProcId.nodeidx.Set
// Set bitfield in value of field 'value'
//    8 bits starting at bit 8.
inline void ams::nodeidx_Set(ams::ProcId& parent, u8 rhs) {
    u32 t1    = u32(0xff) << 8;
    u32 t2    = (u32(rhs) & 0xff) << 8;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- ams.ProcId.procidx.Get
// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
inline u8 ams::procidx_Get(const ams::ProcId& parent) {
    return u8((parent.value >> 0) & 0x0f);
}

// --- ams.ProcId.procidx.Set
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
inline void ams::procidx_Set(ams::ProcId& parent, u8 rhs) {
    u32 t1    = u32(0x0f) << 0;
    u32 t2    = (u32(rhs) & 0x0f) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- ams.ProcId..Hash
inline u32 ams::ProcId_Hash(u32 prev, ams::ProcId rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- ams.ProcId..EqOp
inline bool ams::ProcId::operator ==(const ams::ProcId &rhs) const {
    return ams::ProcId_Eq(const_cast<ams::ProcId&>(*this),const_cast<ams::ProcId&>(rhs));
}

// --- ams.ProcId..NeOp
inline bool ams::ProcId::operator !=(const ams::ProcId &rhs) const {
    return !ams::ProcId_Eq(const_cast<ams::ProcId&>(*this),const_cast<ams::ProcId&>(rhs));
}

// --- ams.ProcId..Cmp
inline i32 ams::ProcId_Cmp(ams::ProcId lhs, ams::ProcId rhs) {
    i32 retval = 0;
    retval = u32_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- ams.ProcId..Init
// Set all fields to initial values.
inline void ams::ProcId_Init(ams::ProcId& parent) {
    parent.value = u32(0);
}

// --- ams.ProcId..Eq
inline bool ams::ProcId_Eq(ams::ProcId lhs, ams::ProcId rhs) {
    bool retval = true;
    retval = u32_Eq(lhs.value, rhs.value);
    return retval;
}

// --- ams.ProcId..Ctor
inline  ams::ProcId::ProcId() {
    ams::ProcId_Init(*this);
}

// --- ams.ProcId..FieldwiseCtor
inline  ams::ProcId::ProcId(u32 in_value)
    : value(in_value)
 {
}

// --- ams.InputLineMsg.base.Castdown
// Check if ams::MsgHeader is an instance of InputLineMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of InputLineMsg.
// If not successful, quietly return NULL.
inline ams::InputLineMsg* ams::InputLineMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (22);
    cond &= i32(hdr.length) >= ssizeof(ams::InputLineMsg);
    return cond ? reinterpret_cast<ams::InputLineMsg*>(&hdr) : NULL;
}

// --- ams.InputLineMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::InputLineMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.InputLineMsg.payload.N
// Return number of elements in varlen field
inline u32 ams::payload_N(const ams::InputLineMsg& parent) {
    u32 length = i32(((ams::InputLineMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::InputLineMsg)) - sizeof(ams::InputLineMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.InputLineMsg.payload_curs.Reset
inline void ams::InputLineMsg_payload_curs_Reset(InputLineMsg_payload_curs &curs, ams::InputLineMsg &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::InputLineMsg);
    curs.index = 0;
}

// --- ams.InputLineMsg.payload_curs.ValidQ
// cursor points to valid item
inline bool ams::InputLineMsg_payload_curs_ValidQ(InputLineMsg_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.InputLineMsg.payload_curs.Next
// proceed to next item
inline void ams::InputLineMsg_payload_curs_Next(InputLineMsg_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.InputLineMsg.payload_curs.Access
// item access
inline char& ams::InputLineMsg_payload_curs_Access(InputLineMsg_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.InputLineMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::InputLineMsg& parent) {
    return i32(const_cast<ams::InputLineMsg&>(parent).length);
}

// --- ams.InputLineMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::InputLineMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::InputLineMsg&>(row).length));
}

// --- ams.InputLineMsg..Init
// Set all fields to initial values.
inline void ams::InputLineMsg_Init(ams::InputLineMsg& parent) {
    parent.type = u32(22);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.InputLineMsg..Ctor
inline  ams::InputLineMsg::InputLineMsg() {
    ams::InputLineMsg_Init(*this);
}

// --- ams.InputLineMsg..FieldwiseCtor
inline  ams::InputLineMsg::InputLineMsg(ams::ProcId in_proc_id)
    : proc_id(in_proc_id)
 {
    this->type = u32(22);
    this->length = u32(ssizeof(*this) + (0));
}

// --- ams.LogMsg.base.Castdown
// Check if ams::MsgHeader is an instance of LogMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of LogMsg.
// If not successful, quietly return NULL.
inline ams::LogMsg* ams::LogMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (6);
    cond &= i32(hdr.length) >= ssizeof(ams::LogMsg);
    return cond ? reinterpret_cast<ams::LogMsg*>(&hdr) : NULL;
}

// --- ams.LogMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::LogMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.LogMsg.logcat.N
// Return number of elements in varlen field
inline u32 ams::logcat_N(const ams::LogMsg& parent) {
    return u32((parent.logcat_end) / sizeof(char));
}

// --- ams.LogMsg.text.N
// Return number of elements in varlen field
inline u32 ams::text_N(const ams::LogMsg& parent) {
    u32 length = i32(((ams::LogMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::LogMsg)) - sizeof(ams::LogMsg) - parent.logcat_end; // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.LogMsg.logcat_curs.Reset
inline void ams::LogMsg_logcat_curs_Reset(LogMsg_logcat_curs &curs, ams::LogMsg &parent) {
    curs.ptr = (u8*)logcat_Addr(parent);
    curs.length = parent.logcat_end;
    curs.index = 0;
}

// --- ams.LogMsg.logcat_curs.ValidQ
// cursor points to valid item
inline bool ams::LogMsg_logcat_curs_ValidQ(LogMsg_logcat_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.LogMsg.logcat_curs.Next
// proceed to next item
inline void ams::LogMsg_logcat_curs_Next(LogMsg_logcat_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.LogMsg.logcat_curs.Access
// item access
inline char& ams::LogMsg_logcat_curs_Access(LogMsg_logcat_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.LogMsg.text_curs.Reset
inline void ams::LogMsg_text_curs_Reset(LogMsg_text_curs &curs, ams::LogMsg &parent) {
    curs.ptr = (u8*)text_Addr(parent);
    curs.length = i32(parent.length) - parent.logcat_end - sizeof(ams::LogMsg);
    curs.index = 0;
}

// --- ams.LogMsg.text_curs.ValidQ
// cursor points to valid item
inline bool ams::LogMsg_text_curs_ValidQ(LogMsg_text_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.LogMsg.text_curs.Next
// proceed to next item
inline void ams::LogMsg_text_curs_Next(LogMsg_text_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.LogMsg.text_curs.Access
// item access
inline char& ams::LogMsg_text_curs_Access(LogMsg_text_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.LogMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::LogMsg& parent) {
    return i32(const_cast<ams::LogMsg&>(parent).length);
}

// --- ams.LogMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::LogMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::LogMsg&>(row).length));
}

// --- ams.LogMsg..Init
// Set all fields to initial values.
inline void ams::LogMsg_Init(ams::LogMsg& parent) {
    parent.type = u32(6);
    parent.length = u32(ssizeof(parent) + (0));
    parent.logcat_end = u32(0); // logcat: initialize
}

// --- ams.LogMsg..Ctor
inline  ams::LogMsg::LogMsg() {
    ams::LogMsg_Init(*this);
}

// --- ams.LogMsg..FieldwiseCtor
inline  ams::LogMsg::LogMsg(ams::ProcId in_proc_id, algo::SchedTime in_tstamp)
    : proc_id(in_proc_id)
    , tstamp(in_tstamp)
 {
    this->type = u32(6);
    this->length = u32(ssizeof(*this) + (0));
}

// --- ams.MsgBlock.header.Castdown
// Check if ams::MsgHeader is an instance of MsgBlock by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgBlock.
// If not successful, quietly return NULL.
inline ams::MsgBlock* ams::MsgBlock_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (1);
    cond &= i32(hdr.length) >= ssizeof(ams::MsgBlock);
    return cond ? reinterpret_cast<ams::MsgBlock*>(&hdr) : NULL;
}

// --- ams.MsgBlock.header.Castbase
inline ams::MsgHeader& ams::Castbase(ams::MsgBlock& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.MsgBlock.messages.N
// Return number of elements in varlen field
inline u32 ams::messages_N(const ams::MsgBlock& parent) {
    u32 length = i32(((ams::MsgBlock&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::MsgBlock)) - sizeof(ams::MsgBlock); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u8));
}

// --- ams.MsgBlock.messages_curs.Reset
inline void ams::MsgBlock_messages_curs_Reset(MsgBlock_messages_curs &curs, ams::MsgBlock &parent) {
    curs.ptr = (u8*)messages_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::MsgBlock);
    curs.index = 0;
}

// --- ams.MsgBlock.messages_curs.ValidQ
// cursor points to valid item
inline bool ams::MsgBlock_messages_curs_ValidQ(MsgBlock_messages_curs &curs) {
    bool valid = ssizeof(u8) <= curs.length;
    return valid;
}

// --- ams.MsgBlock.messages_curs.Next
// proceed to next item
inline void ams::MsgBlock_messages_curs_Next(MsgBlock_messages_curs &curs) {
    i32 len = i32(sizeof(u8));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.MsgBlock.messages_curs.Access
// item access
inline u8& ams::MsgBlock_messages_curs_Access(MsgBlock_messages_curs &curs) {
    return *(u8*)curs.ptr;
}

// --- ams.MsgBlock..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::MsgBlock& parent) {
    return i32(const_cast<ams::MsgBlock&>(parent).length);
}

// --- ams.MsgBlock..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::MsgBlock& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::MsgBlock&>(row).length));
}

// --- ams.MsgBlock..Init
// Set all fields to initial values.
inline void ams::MsgBlock_Init(ams::MsgBlock& parent) {
    parent.type = u32(1);
    parent.length = u32(ssizeof(parent) + (0));
    parent.first_seqno = u64(0);
    parent.n_messages = u32(0);
    parent.original_length = u32(0);
}

// --- ams.MsgBlock..Ctor
inline  ams::MsgBlock::MsgBlock() {
    ams::MsgBlock_Init(*this);
}

// --- ams.MsgHeader.type.GetEnum
// Get value of field as enum type
inline ams_MsgHeader_type_Enum ams::type_GetEnum(const ams::MsgHeader& payload) {
    return ams_MsgHeader_type_Enum(payload.type);
}

// --- ams.MsgHeader.type.SetEnum
// Set value of field from enum type.
inline void ams::type_SetEnum(ams::MsgHeader& payload, ams_MsgHeader_type_Enum rhs) {
    payload.type = u32(rhs);
}

// --- ams.MsgHeader..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::MsgHeader& parent) {
    return i32(const_cast<ams::MsgHeader&>(parent).length);
}

// --- ams.MsgHeader..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::MsgHeader& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::MsgHeader&>(row).length));
}

// --- ams.MsgHeader..Init
// Set all fields to initial values.
inline void ams::MsgHeader_Init(ams::MsgHeader& payload) {
    payload.type = u32(0);
    payload.length = u32(0);
}

// --- ams.MsgHeader..Ctor
inline  ams::MsgHeader::MsgHeader() {
    ams::MsgHeader_Init(*this);
}

// --- ams.MsgHeader..FieldwiseCtor
inline  ams::MsgHeader::MsgHeader(u32 in_type, u32 in_length)
    : type(in_type)
    , length(in_length)
 {
}

// --- ams.MsgHeaderMsgsCase.value.GetEnum
// Get value of field as enum type
inline ams_MsgHeaderMsgsCaseEnum ams::value_GetEnum(const ams::MsgHeaderMsgsCase& parent) {
    return ams_MsgHeaderMsgsCaseEnum(parent.value);
}

// --- ams.MsgHeaderMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::MsgHeaderMsgsCase& parent, ams_MsgHeaderMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- ams.MsgHeaderMsgsCase.value.Cast
inline  ams::MsgHeaderMsgsCase::operator ams_MsgHeaderMsgsCaseEnum() const {
    return ams_MsgHeaderMsgsCaseEnum((*this).value);
}

// --- ams.MsgHeaderMsgsCase..Init
// Set all fields to initial values.
inline void ams::MsgHeaderMsgsCase_Init(ams::MsgHeaderMsgsCase& parent) {
    parent.value = u32(0);
}

// --- ams.MsgHeaderMsgsCase..Ctor
inline  ams::MsgHeaderMsgsCase::MsgHeaderMsgsCase() {
    ams::MsgHeaderMsgsCase_Init(*this);
}

// --- ams.MsgHeaderMsgsCase..FieldwiseCtor
inline  ams::MsgHeaderMsgsCase::MsgHeaderMsgsCase(u32 in_value)
    : value(in_value)
 {
}

// --- ams.MsgHeaderMsgsCase..EnumCtor
inline  ams::MsgHeaderMsgsCase::MsgHeaderMsgsCase(ams_MsgHeaderMsgsCaseEnum arg) {
    this->value = u32(arg);
}

// --- ams.MsgHeader_curs..ValidQ
inline bool ams::MsgHeader_curs_ValidQ(ams::MsgHeader_curs& curs) {
    return curs.msg != NULL;
}

// --- ams.MsgHeader_curs..Reset
inline void ams::MsgHeader_curs_Reset(ams::MsgHeader_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    ams::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ams::MsgHeader)) {
        ams::MsgHeader *ptr = (ams::MsgHeader*)curs.bytes;
        msglen = i32((*ptr).length);
        if (msglen >= ssizeof(ams::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ams.MsgHeader_curs..Access
inline ams::MsgHeader*& ams::MsgHeader_curs_Access(ams::MsgHeader_curs& curs) {
    return curs.msg;
}

// --- ams.MsgHeader_curs..Next
inline void ams::MsgHeader_curs_Next(ams::MsgHeader_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    ams::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ams::MsgHeader)) {
        ams::MsgHeader *ptr = (ams::MsgHeader*)curs.bytes;
        msglen = i32((*ptr).length);
        if (msglen >= ssizeof(ams::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ams.MsgHeader_curs..Init
// Set all fields to initial values.
inline void ams::MsgHeader_curs_Init(ams::MsgHeader_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- ams.MsgHeader_curs..Ctor
inline  ams::MsgHeader_curs::MsgHeader_curs() {
    ams::MsgHeader_curs_Init(*this);
}

// --- ams.ProcEofMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcEofMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcEofMsg.
// If not successful, quietly return NULL.
inline ams::ProcEofMsg* ams::ProcEofMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (703);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcEofMsg);
    return cond ? reinterpret_cast<ams::ProcEofMsg*>(&hdr) : NULL;
}

// --- ams.ProcEofMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcEofMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcEofMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcEofMsg& parent) {
    return i32(const_cast<ams::ProcEofMsg&>(parent).length);
}

// --- ams.ProcEofMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcEofMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcEofMsg&>(row).length));
}

// --- ams.ProcEofMsg..Init
// Set all fields to initial values.
inline void ams::ProcEofMsg_Init(ams::ProcEofMsg& parent) {
    parent.type = u32(703);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.ProcEofMsg..Ctor
inline  ams::ProcEofMsg::ProcEofMsg() {
    ams::ProcEofMsg_Init(*this);
}

// --- ams.ProcKillMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcKillMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcKillMsg.
// If not successful, quietly return NULL.
inline ams::ProcKillMsg* ams::ProcKillMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (704);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcKillMsg);
    return cond ? reinterpret_cast<ams::ProcKillMsg*>(&hdr) : NULL;
}

// --- ams.ProcKillMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcKillMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcKillMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcKillMsg& parent) {
    return i32(const_cast<ams::ProcKillMsg&>(parent).length);
}

// --- ams.ProcKillMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcKillMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcKillMsg&>(row).length));
}

// --- ams.ProcKillMsg..Init
// Set all fields to initial values.
inline void ams::ProcKillMsg_Init(ams::ProcKillMsg& parent) {
    parent.type = u32(704);
    parent.length = u32(ssizeof(parent) + (0));
    parent.signal = i32(15);
}

// --- ams.ProcKillMsg..Ctor
inline  ams::ProcKillMsg::ProcKillMsg() {
    ams::ProcKillMsg_Init(*this);
}

// --- ams.ProcMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcMsg.
// If not successful, quietly return NULL.
inline ams::ProcMsg* ams::ProcMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (701);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcMsg);
    return cond ? reinterpret_cast<ams::ProcMsg*>(&hdr) : NULL;
}

// --- ams.ProcMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcMsg.payload.N
// Return number of elements in varlen field
inline u32 ams::payload_N(const ams::ProcMsg& parent) {
    u32 length = i32(((ams::ProcMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::ProcMsg)) - sizeof(ams::ProcMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.ProcMsg.payload_curs.Reset
inline void ams::ProcMsg_payload_curs_Reset(ProcMsg_payload_curs &curs, ams::ProcMsg &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::ProcMsg);
    curs.index = 0;
}

// --- ams.ProcMsg.payload_curs.ValidQ
// cursor points to valid item
inline bool ams::ProcMsg_payload_curs_ValidQ(ProcMsg_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.ProcMsg.payload_curs.Next
// proceed to next item
inline void ams::ProcMsg_payload_curs_Next(ProcMsg_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.ProcMsg.payload_curs.Access
// item access
inline char& ams::ProcMsg_payload_curs_Access(ProcMsg_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.ProcMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcMsg& parent) {
    return i32(const_cast<ams::ProcMsg&>(parent).length);
}

// --- ams.ProcMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcMsg&>(row).length));
}

// --- ams.ProcMsg..Init
// Set all fields to initial values.
inline void ams::ProcMsg_Init(ams::ProcMsg& parent) {
    parent.type = u32(701);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.ProcMsg..Ctor
inline  ams::ProcMsg::ProcMsg() {
    ams::ProcMsg_Init(*this);
}

// --- ams.ProcReadMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcReadMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcReadMsg.
// If not successful, quietly return NULL.
inline ams::ProcReadMsg* ams::ProcReadMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (702);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcReadMsg);
    return cond ? reinterpret_cast<ams::ProcReadMsg*>(&hdr) : NULL;
}

// --- ams.ProcReadMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcReadMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcReadMsg.until.N
// Return number of elements in varlen field
inline u32 ams::until_N(const ams::ProcReadMsg& parent) {
    u32 length = i32(((ams::ProcReadMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::ProcReadMsg)) - sizeof(ams::ProcReadMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.ProcReadMsg.until_curs.Reset
inline void ams::ProcReadMsg_until_curs_Reset(ProcReadMsg_until_curs &curs, ams::ProcReadMsg &parent) {
    curs.ptr = (u8*)until_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::ProcReadMsg);
    curs.index = 0;
}

// --- ams.ProcReadMsg.until_curs.ValidQ
// cursor points to valid item
inline bool ams::ProcReadMsg_until_curs_ValidQ(ProcReadMsg_until_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.ProcReadMsg.until_curs.Next
// proceed to next item
inline void ams::ProcReadMsg_until_curs_Next(ProcReadMsg_until_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.ProcReadMsg.until_curs.Access
// item access
inline char& ams::ProcReadMsg_until_curs_Access(ProcReadMsg_until_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.ProcReadMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcReadMsg& parent) {
    return i32(const_cast<ams::ProcReadMsg&>(parent).length);
}

// --- ams.ProcReadMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcReadMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcReadMsg&>(row).length));
}

// --- ams.ProcReadMsg..Init
// Set all fields to initial values.
inline void ams::ProcReadMsg_Init(ams::ProcReadMsg& parent) {
    parent.type = u32(702);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.ProcReadMsg..Ctor
inline  ams::ProcReadMsg::ProcReadMsg() {
    ams::ProcReadMsg_Init(*this);
}

// --- ams.ProcStartMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcStartMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcStartMsg.
// If not successful, quietly return NULL.
inline ams::ProcStartMsg* ams::ProcStartMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (700);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcStartMsg);
    return cond ? reinterpret_cast<ams::ProcStartMsg*>(&hdr) : NULL;
}

// --- ams.ProcStartMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcStartMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcStartMsg.cmd.N
// Return number of elements in varlen field
inline u32 ams::cmd_N(const ams::ProcStartMsg& parent) {
    u32 length = i32(((ams::ProcStartMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::ProcStartMsg)) - sizeof(ams::ProcStartMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.ProcStartMsg.cmd_curs.Reset
inline void ams::ProcStartMsg_cmd_curs_Reset(ProcStartMsg_cmd_curs &curs, ams::ProcStartMsg &parent) {
    curs.ptr = (u8*)cmd_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::ProcStartMsg);
    curs.index = 0;
}

// --- ams.ProcStartMsg.cmd_curs.ValidQ
// cursor points to valid item
inline bool ams::ProcStartMsg_cmd_curs_ValidQ(ProcStartMsg_cmd_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.ProcStartMsg.cmd_curs.Next
// proceed to next item
inline void ams::ProcStartMsg_cmd_curs_Next(ProcStartMsg_cmd_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.ProcStartMsg.cmd_curs.Access
// item access
inline char& ams::ProcStartMsg_cmd_curs_Access(ProcStartMsg_cmd_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.ProcStartMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcStartMsg& parent) {
    return i32(const_cast<ams::ProcStartMsg&>(parent).length);
}

// --- ams.ProcStartMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcStartMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcStartMsg&>(row).length));
}

// --- ams.ProcStartMsg..Init
// Set all fields to initial values.
inline void ams::ProcStartMsg_Init(ams::ProcStartMsg& parent) {
    parent.type = u32(700);
    parent.length = u32(ssizeof(parent) + (0));
    parent.pty = bool(false);
}

// --- ams.ProcStartMsg..Ctor
inline  ams::ProcStartMsg::ProcStartMsg() {
    ams::ProcStartMsg_Init(*this);
}

// --- ams.ProcStatusMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcStatusMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcStatusMsg.
// If not successful, quietly return NULL.
inline ams::ProcStatusMsg* ams::ProcStatusMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (705);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcStatusMsg);
    return cond ? reinterpret_cast<ams::ProcStatusMsg*>(&hdr) : NULL;
}

// --- ams.ProcStatusMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcStatusMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcStatusMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcStatusMsg& parent) {
    return i32(const_cast<ams::ProcStatusMsg&>(parent).length);
}

// --- ams.ProcStatusMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcStatusMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcStatusMsg&>(row).length));
}

// --- ams.ProcStatusMsg..Init
// Set all fields to initial values.
inline void ams::ProcStatusMsg_Init(ams::ProcStatusMsg& parent) {
    parent.type = u32(705);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.ProcStatusMsg..Ctor
inline  ams::ProcStatusMsg::ProcStatusMsg() {
    ams::ProcStatusMsg_Init(*this);
}

// --- ams.RemDirRecurseMsg.base.Castdown
// Check if ams::MsgHeader is an instance of RemDirRecurseMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of RemDirRecurseMsg.
// If not successful, quietly return NULL.
inline ams::RemDirRecurseMsg* ams::RemDirRecurseMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (633);
    cond &= i32(hdr.length) >= ssizeof(ams::RemDirRecurseMsg);
    return cond ? reinterpret_cast<ams::RemDirRecurseMsg*>(&hdr) : NULL;
}

// --- ams.RemDirRecurseMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::RemDirRecurseMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.RemDirRecurseMsg.pathname.N
// Return number of elements in varlen field
inline u32 ams::pathname_N(const ams::RemDirRecurseMsg& parent) {
    u32 length = i32(((ams::RemDirRecurseMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::RemDirRecurseMsg)) - sizeof(ams::RemDirRecurseMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.RemDirRecurseMsg.pathname_curs.Reset
inline void ams::RemDirRecurseMsg_pathname_curs_Reset(RemDirRecurseMsg_pathname_curs &curs, ams::RemDirRecurseMsg &parent) {
    curs.ptr = (u8*)pathname_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::RemDirRecurseMsg);
    curs.index = 0;
}

// --- ams.RemDirRecurseMsg.pathname_curs.ValidQ
// cursor points to valid item
inline bool ams::RemDirRecurseMsg_pathname_curs_ValidQ(RemDirRecurseMsg_pathname_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.RemDirRecurseMsg.pathname_curs.Next
// proceed to next item
inline void ams::RemDirRecurseMsg_pathname_curs_Next(RemDirRecurseMsg_pathname_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.RemDirRecurseMsg.pathname_curs.Access
// item access
inline char& ams::RemDirRecurseMsg_pathname_curs_Access(RemDirRecurseMsg_pathname_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.RemDirRecurseMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::RemDirRecurseMsg& parent) {
    return i32(const_cast<ams::RemDirRecurseMsg&>(parent).length);
}

// --- ams.RemDirRecurseMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::RemDirRecurseMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::RemDirRecurseMsg&>(row).length));
}

// --- ams.RemDirRecurseMsg..Init
// Set all fields to initial values.
inline void ams::RemDirRecurseMsg_Init(ams::RemDirRecurseMsg& parent) {
    parent.type = u32(633);
    parent.length = u32(ssizeof(parent) + (0));
    parent.remove_topmost = bool(false);
}

// --- ams.RemDirRecurseMsg..Ctor
inline  ams::RemDirRecurseMsg::RemDirRecurseMsg() {
    ams::RemDirRecurseMsg_Init(*this);
}

// --- ams.ShmFlags.write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool ams::write_Get(const ams::ShmFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- ams.ShmFlags.write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void ams::write_Set(ams::ShmFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 1;
    u8 t2    = (u8(rhs) & 0x01) << 1;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.ShmFlags.read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool ams::read_Get(const ams::ShmFlags& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- ams.ShmFlags.read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void ams::read_Set(ams::ShmFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 2;
    u8 t2    = (u8(rhs) & 0x01) << 2;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.ShmFlags.nonblock.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool ams::nonblock_Get(const ams::ShmFlags& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- ams.ShmFlags.nonblock.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void ams::nonblock_Set(ams::ShmFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 3;
    u8 t2    = (u8(rhs) & 0x01) << 3;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.ShmFlags.write_err.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
inline bool ams::write_err_Get(const ams::ShmFlags& parent) {
    return bool((parent.value >> 6) & 0x01);
}

// --- ams.ShmFlags.write_err.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
inline void ams::write_err_Set(ams::ShmFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.ShmFlags..Init
// Set all fields to initial values.
inline void ams::ShmFlags_Init(ams::ShmFlags& parent) {
    parent.value = u8(0);
}

// --- ams.ShmFlags..Ctor
inline  ams::ShmFlags::ShmFlags() {
    ams::ShmFlags_Init(*this);
}

// --- ams.ShmFlags..FieldwiseCtor
inline  ams::ShmFlags::ShmFlags(u8 in_value)
    : value(in_value)
 {
}

// --- ams.ShmFlags..EnumCtor
inline  ams::ShmFlags::ShmFlags(ams_ShmFlagsEnum arg) {
    this->value = u8(arg);
}

// --- ams.Shmtype.value.GetEnum
// Get value of field as enum type
inline ams_ShmtypeEnum ams::value_GetEnum(const ams::Shmtype& parent) {
    return ams_ShmtypeEnum(parent.value);
}

// --- ams.Shmtype.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::Shmtype& parent, ams_ShmtypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- ams.Shmtype..Hash
inline u32 ams::Shmtype_Hash(u32 prev, ams::Shmtype rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- ams.Shmtype..EqOp
inline bool ams::Shmtype::operator ==(const ams::Shmtype &rhs) const {
    return ams::Shmtype_Eq(const_cast<ams::Shmtype&>(*this),const_cast<ams::Shmtype&>(rhs));
}

// --- ams.Shmtype..NeOp
inline bool ams::Shmtype::operator !=(const ams::Shmtype &rhs) const {
    return !ams::Shmtype_Eq(const_cast<ams::Shmtype&>(*this),const_cast<ams::Shmtype&>(rhs));
}

// --- ams.Shmtype..Cmp
inline i32 ams::Shmtype_Cmp(ams::Shmtype lhs, ams::Shmtype rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- ams.Shmtype..Init
// Set all fields to initial values.
inline void ams::Shmtype_Init(ams::Shmtype& parent) {
    parent.value = u8(0);
}

// --- ams.Shmtype..Eq
inline bool ams::Shmtype_Eq(ams::Shmtype lhs, ams::Shmtype rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- ams.Shmtype..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool ams::Shmtype::operator ==(ams_ShmtypeEnum rhs) const {
    return ams_ShmtypeEnum(value) == rhs;
}

// --- ams.Shmtype..Ctor
inline  ams::Shmtype::Shmtype() {
    ams::Shmtype_Init(*this);
}

// --- ams.Shmtype..FieldwiseCtor
inline  ams::Shmtype::Shmtype(u8 in_value)
    : value(in_value)
 {
}

// --- ams.Shmtype..EnumCtor
inline  ams::Shmtype::Shmtype(ams_ShmtypeEnum arg) {
    this->value = u8(arg);
}

// --- ams.ShmId..Hash
inline u32 ams::ShmId_Hash(u32 prev, ams::ShmId rhs) {
    prev = ProcId_Hash(prev, rhs.proc_id);
    prev = Shmtype_Hash(prev, rhs.shmtype);
    prev = u8_Hash(prev, rhs.index);
    return prev;
}

// --- ams.ShmId..EqOp
inline bool ams::ShmId::operator ==(const ams::ShmId &rhs) const {
    return ams::ShmId_Eq(const_cast<ams::ShmId&>(*this),const_cast<ams::ShmId&>(rhs));
}

// --- ams.ShmId..NeOp
inline bool ams::ShmId::operator !=(const ams::ShmId &rhs) const {
    return !ams::ShmId_Eq(const_cast<ams::ShmId&>(*this),const_cast<ams::ShmId&>(rhs));
}

// --- ams.ShmId..Cmp
inline i32 ams::ShmId_Cmp(ams::ShmId lhs, ams::ShmId rhs) {
    i32 retval = 0;
    retval = ams::ProcId_Cmp(lhs.proc_id, rhs.proc_id);
    if (retval != 0) {
        return retval;
    }
    retval = ams::Shmtype_Cmp(lhs.shmtype, rhs.shmtype);
    if (retval != 0) {
        return retval;
    }
    retval = u8_Cmp(lhs.index, rhs.index);
    return retval;
}

// --- ams.ShmId..Init
// Set all fields to initial values.
inline void ams::ShmId_Init(ams::ShmId& parent) {
    parent.index = u8(0);
}

// --- ams.ShmId..Eq
inline bool ams::ShmId_Eq(ams::ShmId lhs, ams::ShmId rhs) {
    bool retval = true;
    retval = ams::ProcId_Eq(lhs.proc_id, rhs.proc_id);
    if (!retval) {
        return false;
    }
    retval = ams::Shmtype_Eq(lhs.shmtype, rhs.shmtype);
    if (!retval) {
        return false;
    }
    retval = u8_Eq(lhs.index, rhs.index);
    return retval;
}

// --- ams.ShmId..Ctor
inline  ams::ShmId::ShmId() {
    ams::ShmId_Init(*this);
}

// --- ams.ShmId..FieldwiseCtor
inline  ams::ShmId::ShmId(ams::ProcId in_proc_id, ams::Shmtype in_shmtype, u8 in_index)
    : proc_id(in_proc_id)
    , shmtype(in_shmtype)
    , index(in_index)
 {
}

// --- ams.ShmemberFlags.r.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool ams::r_Get(const ams::ShmemberFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- ams.ShmemberFlags.r.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void ams::r_Set(ams::ShmemberFlags& parent, bool rhs) {
    u16 t1    = u16(0x01) << 0;
    u16 t2    = (u16(rhs) & 0x01) << 0;
    parent.value = u16((parent.value & ~t1) | t2);
}

// --- ams.ShmemberFlags.w.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool ams::w_Get(const ams::ShmemberFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- ams.ShmemberFlags.w.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void ams::w_Set(ams::ShmemberFlags& parent, bool rhs) {
    u16 t1    = u16(0x01) << 1;
    u16 t2    = (u16(rhs) & 0x01) << 1;
    parent.value = u16((parent.value & ~t1) | t2);
}

// --- ams.ShmemberFlags..Hash
inline u32 ams::ShmemberFlags_Hash(u32 prev, ams::ShmemberFlags rhs) {
    prev = u16_Hash(prev, rhs.value);
    return prev;
}

// --- ams.ShmemberFlags..EqOp
inline bool ams::ShmemberFlags::operator ==(const ams::ShmemberFlags &rhs) const {
    return ams::ShmemberFlags_Eq(const_cast<ams::ShmemberFlags&>(*this),const_cast<ams::ShmemberFlags&>(rhs));
}

// --- ams.ShmemberFlags..NeOp
inline bool ams::ShmemberFlags::operator !=(const ams::ShmemberFlags &rhs) const {
    return !ams::ShmemberFlags_Eq(const_cast<ams::ShmemberFlags&>(*this),const_cast<ams::ShmemberFlags&>(rhs));
}

// --- ams.ShmemberFlags..Cmp
inline i32 ams::ShmemberFlags_Cmp(ams::ShmemberFlags lhs, ams::ShmemberFlags rhs) {
    i32 retval = 0;
    retval = u16_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- ams.ShmemberFlags..Init
// Set all fields to initial values.
inline void ams::ShmemberFlags_Init(ams::ShmemberFlags& parent) {
    parent.value = u16(0);
    r_Set(parent, 0); // default value
    w_Set(parent, 0); // default value
}

// --- ams.ShmemberFlags..Eq
inline bool ams::ShmemberFlags_Eq(ams::ShmemberFlags lhs, ams::ShmemberFlags rhs) {
    bool retval = true;
    retval = u16_Eq(lhs.value, rhs.value);
    return retval;
}

// --- ams.ShmemberFlags..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool ams::ShmemberFlags::operator ==(ams_ShmemberFlagsEnum rhs) const {
    return ams_ShmemberFlagsEnum(value) == rhs;
}

// --- ams.ShmemberFlags..Ctor
inline  ams::ShmemberFlags::ShmemberFlags() {
    ams::ShmemberFlags_Init(*this);
}

// --- ams.ShmemberFlags..FieldwiseCtor
inline  ams::ShmemberFlags::ShmemberFlags(u16 in_value)
    : value(in_value)
 {
}

// --- ams.ShmemberFlags..EnumCtor
inline  ams::ShmemberFlags::ShmemberFlags(ams_ShmemberFlagsEnum arg) {
    this->value = u16(arg);
}

// --- ams.ShmemberId..Hash
inline u32 ams::ShmemberId_Hash(u32 prev, ams::ShmemberId rhs) {
    prev = ShmId_Hash(prev, rhs.shm_id);
    prev = ProcId_Hash(prev, rhs.proc_id);
    prev = ShmemberFlags_Hash(prev, rhs.flags);
    return prev;
}

// --- ams.ShmemberId..EqOp
inline bool ams::ShmemberId::operator ==(const ams::ShmemberId &rhs) const {
    return ams::ShmemberId_Eq(const_cast<ams::ShmemberId&>(*this),const_cast<ams::ShmemberId&>(rhs));
}

// --- ams.ShmemberId..NeOp
inline bool ams::ShmemberId::operator !=(const ams::ShmemberId &rhs) const {
    return !ams::ShmemberId_Eq(const_cast<ams::ShmemberId&>(*this),const_cast<ams::ShmemberId&>(rhs));
}

// --- ams.ShmemberId..Cmp
inline i32 ams::ShmemberId_Cmp(ams::ShmemberId lhs, ams::ShmemberId rhs) {
    i32 retval = 0;
    retval = ams::ShmId_Cmp(lhs.shm_id, rhs.shm_id);
    if (retval != 0) {
        return retval;
    }
    retval = ams::ProcId_Cmp(lhs.proc_id, rhs.proc_id);
    if (retval != 0) {
        return retval;
    }
    retval = ams::ShmemberFlags_Cmp(lhs.flags, rhs.flags);
    return retval;
}

// --- ams.ShmemberId..Init
// Set all fields to initial values.
inline void ams::ShmemberId_Init(ams::ShmemberId& parent) {
    parent.flags = ams::ShmemberFlags(0);
}

// --- ams.ShmemberId..Eq
inline bool ams::ShmemberId_Eq(ams::ShmemberId lhs, ams::ShmemberId rhs) {
    bool retval = true;
    retval = ams::ShmId_Eq(lhs.shm_id, rhs.shm_id);
    if (!retval) {
        return false;
    }
    retval = ams::ProcId_Eq(lhs.proc_id, rhs.proc_id);
    if (!retval) {
        return false;
    }
    retval = ams::ShmemberFlags_Eq(lhs.flags, rhs.flags);
    return retval;
}

// --- ams.ShmemberId..Ctor
inline  ams::ShmemberId::ShmemberId() {
    ams::ShmemberId_Init(*this);
}

// --- ams.ShmemberId..FieldwiseCtor
inline  ams::ShmemberId::ShmemberId(ams::ShmId in_shm_id, ams::ProcId in_proc_id, ams::ShmemberFlags in_flags)
    : shm_id(in_shm_id)
    , proc_id(in_proc_id)
    , flags(in_flags)
 {
}

// --- ams.ShmHbMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ShmHbMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ShmHbMsg.
// If not successful, quietly return NULL.
inline ams::ShmHbMsg* ams::ShmHbMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (3);
    cond &= i32(hdr.length) >= ssizeof(ams::ShmHbMsg);
    return cond ? reinterpret_cast<ams::ShmHbMsg*>(&hdr) : NULL;
}

// --- ams.ShmHbMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ShmHbMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ShmHbMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ShmHbMsg& parent) {
    return i32(const_cast<ams::ShmHbMsg&>(parent).length);
}

// --- ams.ShmHbMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ShmHbMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ShmHbMsg&>(row).length));
}

// --- ams.ShmHbMsg..Init
// Set all fields to initial values.
inline void ams::ShmHbMsg_Init(ams::ShmHbMsg& parent) {
    parent.type = u32(3);
    parent.length = u32(ssizeof(parent) + (0));
    parent.off = u64(0);
    parent.wbudget = u32(0);
}

// --- ams.ShmHbMsg..Ctor
inline  ams::ShmHbMsg::ShmHbMsg() {
    ams::ShmHbMsg_Init(*this);
}

// --- ams.ShmHbMsg..FieldwiseCtor
inline  ams::ShmHbMsg::ShmHbMsg(ams::ShmemberId in_shmember, u64 in_off, u32 in_wbudget)
    : shmember(in_shmember)
    , off(in_off)
    , wbudget(in_wbudget)
 {
    this->type = u32(3);
    this->length = u32(ssizeof(*this) + (0));
}

// --- ams.Shmmsg.base.Castdown
// Check if ams::MsgHeader is an instance of Shmmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Shmmsg.
// If not successful, quietly return NULL.
inline ams::Shmmsg* ams::Shmmsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (10);
    cond &= i32(hdr.length) >= ssizeof(ams::Shmmsg);
    return cond ? reinterpret_cast<ams::Shmmsg*>(&hdr) : NULL;
}

// --- ams.Shmmsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::Shmmsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.Shmmsg.payload.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
inline ams::MsgHeader* ams::payload_Get(ams::Shmmsg& parent) {
    i32 totlen = i32(parent.length);
    u8 *end = (u8*)&parent + sizeof(ams::Shmmsg);
    ams::MsgHeader *ptr = (ams::MsgHeader*)end;
    bool exists = ssizeof(ams::Shmmsg) + sizeof_ams_MsgHeader <= totlen;
    exists = exists && i32((*ptr).length) >= sizeof_ams_MsgHeader && ssizeof(ams::Shmmsg) + i32((*ptr).length) <= totlen;
    return exists ? ptr : NULL;
}

// --- ams.Shmmsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::Shmmsg& parent) {
    return i32(const_cast<ams::Shmmsg&>(parent).length);
}

// --- ams.Shmmsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::Shmmsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::Shmmsg&>(row).length));
}

// --- ams.Shmmsg..Init
// Set all fields to initial values.
inline void ams::Shmmsg_Init(ams::Shmmsg& parent) {
    parent.type = u32(10);
    parent.length = u32(ssizeof(parent) + (0));
    parent.off = u64(0);
    parent.tstamp = u64(0);
}

// --- ams.Shmmsg..Ctor
inline  ams::Shmmsg::Shmmsg() {
    ams::Shmmsg_Init(*this);
}

// --- ams.Shmmsg..FieldwiseCtor
inline  ams::Shmmsg::Shmmsg(ams::ShmId in_shm_id, u64 in_off, u64 in_tstamp)
    : shm_id(in_shm_id)
    , off(in_off)
    , tstamp(in_tstamp)
 {
    this->type = u32(10);
    this->length = u32(ssizeof(*this) + (0));
}

// --- ams.TerminateMsg.base.Castdown
// Check if ams::MsgHeader is an instance of TerminateMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TerminateMsg.
// If not successful, quietly return NULL.
inline ams::TerminateMsg* ams::TerminateMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (352);
    cond &= i32(hdr.length) >= ssizeof(ams::TerminateMsg);
    return cond ? reinterpret_cast<ams::TerminateMsg*>(&hdr) : NULL;
}

// --- ams.TerminateMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::TerminateMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.TerminateMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::TerminateMsg& parent) {
    return i32(const_cast<ams::TerminateMsg&>(parent).length);
}

// --- ams.TerminateMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::TerminateMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::TerminateMsg&>(row).length));
}

// --- ams.TerminateMsg..Init
// Set all fields to initial values.
inline void ams::TerminateMsg_Init(ams::TerminateMsg& parent) {
    parent.type = u32(352);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ams.TerminateMsg..Ctor
inline  ams::TerminateMsg::TerminateMsg() {
    ams::TerminateMsg_Init(*this);
}

// --- ams.UdpFrame.header.Castdown
// Check if ams::MsgHeader is an instance of UdpFrame by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of UdpFrame.
// If not successful, quietly return NULL.
inline ams::UdpFrame* ams::UdpFrame_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (2);
    cond &= i32(hdr.length) >= ssizeof(ams::UdpFrame);
    return cond ? reinterpret_cast<ams::UdpFrame*>(&hdr) : NULL;
}

// --- ams.UdpFrame.header.Castbase
inline ams::MsgHeader& ams::Castbase(ams::UdpFrame& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.UdpFrame.payload.N
// Return number of elements in varlen field
inline u32 ams::payload_N(const ams::UdpFrame& parent) {
    u32 length = i32(((ams::UdpFrame&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::UdpFrame)) - sizeof(ams::UdpFrame); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u8));
}

// --- ams.UdpFrame.payload_curs.Reset
inline void ams::UdpFrame_payload_curs_Reset(UdpFrame_payload_curs &curs, ams::UdpFrame &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ams::UdpFrame);
    curs.index = 0;
}

// --- ams.UdpFrame.payload_curs.ValidQ
// cursor points to valid item
inline bool ams::UdpFrame_payload_curs_ValidQ(UdpFrame_payload_curs &curs) {
    bool valid = ssizeof(u8) <= curs.length;
    return valid;
}

// --- ams.UdpFrame.payload_curs.Next
// proceed to next item
inline void ams::UdpFrame_payload_curs_Next(UdpFrame_payload_curs &curs) {
    i32 len = i32(sizeof(u8));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.UdpFrame.payload_curs.Access
// item access
inline u8& ams::UdpFrame_payload_curs_Access(UdpFrame_payload_curs &curs) {
    return *(u8*)curs.ptr;
}

// --- ams.UdpFrame..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::UdpFrame& parent) {
    return i32(const_cast<ams::UdpFrame&>(parent).length);
}

// --- ams.UdpFrame..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::UdpFrame& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::UdpFrame&>(row).length));
}

// --- ams.UdpFrame..Init
// Set all fields to initial values.
inline void ams::UdpFrame_Init(ams::UdpFrame& parent) {
    parent.type = u32(2);
    parent.length = u32(ssizeof(parent) + (0));
    parent.src_port = u16(0);
    parent.dst_port = u16(0);
}

// --- ams.UdpFrame..Ctor
inline  ams::UdpFrame::UdpFrame() {
    ams::UdpFrame_Init(*this);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ExpectMsg &row) {// cfmt:ams.ExpectMsg.String
    ams::ExpectMsg_Print(const_cast<ams::ExpectMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::FieldId &row) {// cfmt:ams.FieldId.String
    ams::FieldId_Print(const_cast<ams::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::Proctype &row) {// cfmt:ams.Proctype.String
    ams::Proctype_Print(const_cast<ams::Proctype&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcId &row) {// cfmt:ams.ProcId.String
    ams::ProcId_Print(const_cast<ams::ProcId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::InputLineMsg &row) {// cfmt:ams.InputLineMsg.String
    ams::InputLineMsg_Print(const_cast<ams::InputLineMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::LogMsg &row) {// cfmt:ams.LogMsg.String
    ams::LogMsg_Print(const_cast<ams::LogMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::MsgBlock &row) {// cfmt:ams.MsgBlock.String
    ams::MsgBlock_Print(const_cast<ams::MsgBlock&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::MsgHeader &row) {// cfmt:ams.MsgHeader.String
    ams::MsgHeader_Print(const_cast<ams::MsgHeader&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcEofMsg &row) {// cfmt:ams.ProcEofMsg.String
    ams::ProcEofMsg_Print(const_cast<ams::ProcEofMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcKillMsg &row) {// cfmt:ams.ProcKillMsg.String
    ams::ProcKillMsg_Print(const_cast<ams::ProcKillMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcMsg &row) {// cfmt:ams.ProcMsg.String
    ams::ProcMsg_Print(const_cast<ams::ProcMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcReadMsg &row) {// cfmt:ams.ProcReadMsg.String
    ams::ProcReadMsg_Print(const_cast<ams::ProcReadMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcStartMsg &row) {// cfmt:ams.ProcStartMsg.String
    ams::ProcStartMsg_Print(const_cast<ams::ProcStartMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcStatusMsg &row) {// cfmt:ams.ProcStatusMsg.String
    ams::ProcStatusMsg_Print(const_cast<ams::ProcStatusMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ShmFlags &row) {// cfmt:ams.ShmFlags.String
    ams::ShmFlags_Print(const_cast<ams::ShmFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::Shmtype &row) {// cfmt:ams.Shmtype.String
    ams::Shmtype_Print(const_cast<ams::Shmtype&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ShmId &row) {// cfmt:ams.ShmId.String
    ams::ShmId_Print(const_cast<ams::ShmId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ShmemberFlags &row) {// cfmt:ams.ShmemberFlags.String
    ams::ShmemberFlags_Print(const_cast<ams::ShmemberFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ShmemberId &row) {// cfmt:ams.ShmemberId.String
    ams::ShmemberId_Print(const_cast<ams::ShmemberId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ShmHbMsg &row) {// cfmt:ams.ShmHbMsg.String
    ams::ShmHbMsg_Print(const_cast<ams::ShmHbMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::Shmmsg &row) {// cfmt:ams.Shmmsg.String
    ams::Shmmsg_Print(const_cast<ams::Shmmsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::UdpFrame &row) {// cfmt:ams.UdpFrame.String
    ams::UdpFrame_Print(const_cast<ams::UdpFrame&>(row), str);
    return str;
}
