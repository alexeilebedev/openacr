//
// include/gen/ams_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/ietf_gen.inl.h"
//#pragma endinclude
inline ams::AlarmSyncMsg::AlarmSyncMsg(algo::UnTime                   in_updated_after)
    : updated_after(in_updated_after)
{
    this->type = u32(18);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::AlarmSyncMsg::AlarmSyncMsg() {
    ams::AlarmSyncMsg_Init(*this);
}


// --- ams.AlarmSyncMsg.base.Castdown
// Check if ams::MsgHeader is an instance of AlarmSyncMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of AlarmSyncMsg.
// If not successful, quietly return NULL.
inline ams::AlarmSyncMsg* ams::AlarmSyncMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (18);
    cond &= i32(hdr.length) >= ssizeof(ams::AlarmSyncMsg);
    return cond ? reinterpret_cast<ams::AlarmSyncMsg*>(&hdr) : NULL;
}

// --- ams.AlarmSyncMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::AlarmSyncMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.AlarmSyncMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::AlarmSyncMsg& row) {
    return i32(const_cast<ams::AlarmSyncMsg&>(row).length);
}

// --- ams.AlarmSyncMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::AlarmSyncMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::AlarmSyncMsg&>(row).length));
}

// --- ams.AlarmSyncMsg..Init
// Set all fields to initial values.
inline void ams::AlarmSyncMsg_Init(ams::AlarmSyncMsg& parent) {
    parent.type = u32(18);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::ProcType::ProcType(u8                             in_value)
    : value(in_value)
{
}
inline ams::ProcType::ProcType(ams_ProcTypeEnum arg) { this->value = u8(arg); }

inline bool ams::ProcType::operator ==(const ams::ProcType &rhs) const {
    return ams::ProcType_Eq(const_cast<ams::ProcType&>(*this),const_cast<ams::ProcType&>(rhs));
}

inline bool ams::ProcType::operator !=(const ams::ProcType &rhs) const {
    return !ams::ProcType_Eq(const_cast<ams::ProcType&>(*this),const_cast<ams::ProcType&>(rhs));
}

inline bool ams::ProcType::operator ==(ams_ProcTypeEnum rhs) const {
    return ams::ProcType_EqEnum(const_cast<ams::ProcType&>(*this),rhs);
}
inline ams::ProcType::ProcType() {
    ams::ProcType_Init(*this);
}


// --- ams.ProcType.value.GetEnum
// Get value of field as enum type
inline ams_ProcTypeEnum ams::value_GetEnum(const ams::ProcType& parent) {
    return ams_ProcTypeEnum(parent.value);
}

// --- ams.ProcType.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::ProcType& parent, ams_ProcTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- ams.ProcType..Hash
inline u32 ams::ProcType_Hash(u32 prev, ams::ProcType rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- ams.ProcType..Cmp
inline i32 ams::ProcType_Cmp(ams::ProcType lhs, ams::ProcType rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- ams.ProcType..Init
// Set all fields to initial values.
inline void ams::ProcType_Init(ams::ProcType& parent) {
    parent.value = u8(0);
}

// --- ams.ProcType..Eq
inline bool ams::ProcType_Eq(ams::ProcType lhs, ams::ProcType rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- ams.ProcType..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool ams::ProcType_EqEnum(ams::ProcType lhs, ams_ProcTypeEnum rhs) {
    return ams_ProcTypeEnum(lhs.value) == rhs;
}
inline ams::ProcId::ProcId(ams::ProcType                  in_proc_type
        ,u8                             in_procidx)
    : proc_type(in_proc_type)
    , procidx(in_procidx)
{
}

inline bool ams::ProcId::operator ==(const ams::ProcId &rhs) const {
    return ams::ProcId_Eq(const_cast<ams::ProcId&>(*this),const_cast<ams::ProcId&>(rhs));
}

inline bool ams::ProcId::operator !=(const ams::ProcId &rhs) const {
    return !ams::ProcId_Eq(const_cast<ams::ProcId&>(*this),const_cast<ams::ProcId&>(rhs));
}
inline ams::ProcId::ProcId() {
    ams::ProcId_Init(*this);
}


// --- ams.ProcId..Hash
inline u32 ams::ProcId_Hash(u32 prev, ams::ProcId rhs) {
    prev = ProcType_Hash(prev, rhs.proc_type);
    prev = u8_Hash(prev, rhs.procidx);
    return prev;
}

// --- ams.ProcId..Cmp
inline i32 ams::ProcId_Cmp(ams::ProcId lhs, ams::ProcId rhs) {
    i32 retval = 0;
    retval = ams::ProcType_Cmp(lhs.proc_type, rhs.proc_type);
    if (retval != 0) {
        return retval;
    }
    retval = u8_Cmp(lhs.procidx, rhs.procidx);
    return retval;
}

// --- ams.ProcId..Init
// Set all fields to initial values.
inline void ams::ProcId_Init(ams::ProcId& parent) {
    parent.procidx = u8(0);
}

// --- ams.ProcId..Eq
inline bool ams::ProcId_Eq(ams::ProcId lhs, ams::ProcId rhs) {
    bool retval = true;
    retval = ams::ProcType_Eq(lhs.proc_type, rhs.proc_type);
    if (!retval) {
        return false;
    }
    retval = u8_Eq(lhs.procidx, rhs.procidx);
    return retval;
}
inline ams::StreamType::StreamType(u8                             in_value)
    : value(in_value)
{
}
inline ams::StreamType::StreamType(ams_StreamTypeEnum arg) { this->value = u8(arg); }

inline bool ams::StreamType::operator ==(const ams::StreamType &rhs) const {
    return ams::StreamType_Eq(const_cast<ams::StreamType&>(*this),const_cast<ams::StreamType&>(rhs));
}

inline bool ams::StreamType::operator !=(const ams::StreamType &rhs) const {
    return !ams::StreamType_Eq(const_cast<ams::StreamType&>(*this),const_cast<ams::StreamType&>(rhs));
}

inline bool ams::StreamType::operator ==(ams_StreamTypeEnum rhs) const {
    return ams::StreamType_EqEnum(const_cast<ams::StreamType&>(*this),rhs);
}
inline ams::StreamType::StreamType() {
    ams::StreamType_Init(*this);
}


// --- ams.StreamType.value.GetEnum
// Get value of field as enum type
inline ams_StreamTypeEnum ams::value_GetEnum(const ams::StreamType& parent) {
    return ams_StreamTypeEnum(parent.value);
}

// --- ams.StreamType.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::StreamType& parent, ams_StreamTypeEnum rhs) {
    parent.value = u8(rhs);
}

// --- ams.StreamType..Hash
inline u32 ams::StreamType_Hash(u32 prev, ams::StreamType rhs) {
    prev = u8_Hash(prev, rhs.value);
    return prev;
}

// --- ams.StreamType..Cmp
inline i32 ams::StreamType_Cmp(ams::StreamType lhs, ams::StreamType rhs) {
    i32 retval = 0;
    retval = u8_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- ams.StreamType..Init
// Set all fields to initial values.
inline void ams::StreamType_Init(ams::StreamType& parent) {
    parent.value = u8(0);
}

// --- ams.StreamType..Eq
inline bool ams::StreamType_Eq(ams::StreamType lhs, ams::StreamType rhs) {
    bool retval = true;
    retval = u8_Eq(lhs.value, rhs.value);
    return retval;
}

// --- ams.StreamType..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool ams::StreamType_EqEnum(ams::StreamType lhs, ams_StreamTypeEnum rhs) {
    return ams_StreamTypeEnum(lhs.value) == rhs;
}
inline ams::StreamId::StreamId(ams::ProcId                    in_proc_id
        ,ams::StreamType                in_stream_type
        ,u8                             in_streamidx)
    : proc_id(in_proc_id)
    , stream_type(in_stream_type)
    , streamidx(in_streamidx)
{
}

inline bool ams::StreamId::operator ==(const ams::StreamId &rhs) const {
    return ams::StreamId_Eq(const_cast<ams::StreamId&>(*this),const_cast<ams::StreamId&>(rhs));
}

inline bool ams::StreamId::operator !=(const ams::StreamId &rhs) const {
    return !ams::StreamId_Eq(const_cast<ams::StreamId&>(*this),const_cast<ams::StreamId&>(rhs));
}
inline ams::StreamId::StreamId() {
    ams::StreamId_Init(*this);
}


// --- ams.StreamId..Hash
inline u32 ams::StreamId_Hash(u32 prev, ams::StreamId rhs) {
    prev = ProcId_Hash(prev, rhs.proc_id);
    prev = StreamType_Hash(prev, rhs.stream_type);
    prev = u8_Hash(prev, rhs.streamidx);
    return prev;
}

// --- ams.StreamId..Cmp
inline i32 ams::StreamId_Cmp(ams::StreamId lhs, ams::StreamId rhs) {
    i32 retval = 0;
    retval = ams::ProcId_Cmp(lhs.proc_id, rhs.proc_id);
    if (retval != 0) {
        return retval;
    }
    retval = ams::StreamType_Cmp(lhs.stream_type, rhs.stream_type);
    if (retval != 0) {
        return retval;
    }
    retval = u8_Cmp(lhs.streamidx, rhs.streamidx);
    return retval;
}

// --- ams.StreamId..Init
// Set all fields to initial values.
inline void ams::StreamId_Init(ams::StreamId& parent) {
    parent.streamidx = u8(0);
}

// --- ams.StreamId..Eq
inline bool ams::StreamId_Eq(ams::StreamId lhs, ams::StreamId rhs) {
    bool retval = true;
    retval = ams::ProcId_Eq(lhs.proc_id, rhs.proc_id);
    if (!retval) {
        return false;
    }
    retval = ams::StreamType_Eq(lhs.stream_type, rhs.stream_type);
    if (!retval) {
        return false;
    }
    retval = u8_Eq(lhs.streamidx, rhs.streamidx);
    return retval;
}
inline ams::DfltStream::DfltStream(ams::StreamId                  in_stream_id)
    : stream_id(in_stream_id)
{
    this->type = u32(21);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::DfltStream::DfltStream() {
    ams::DfltStream_Init(*this);
}


// --- ams.DfltStream.base.Castdown
// Check if ams::MsgHeader is an instance of DfltStream by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of DfltStream.
// If not successful, quietly return NULL.
inline ams::DfltStream* ams::DfltStream_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (21);
    cond &= i32(hdr.length) >= ssizeof(ams::DfltStream);
    return cond ? reinterpret_cast<ams::DfltStream*>(&hdr) : NULL;
}

// --- ams.DfltStream.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::DfltStream& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.DfltStream..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::DfltStream& row) {
    return i32(const_cast<ams::DfltStream&>(row).length);
}

// --- ams.DfltStream..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::DfltStream& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::DfltStream&>(row).length));
}

// --- ams.DfltStream..Init
// Set all fields to initial values.
inline void ams::DfltStream_Init(ams::DfltStream& parent) {
    parent.type = u32(21);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::DumpStreamTableMsg::DumpStreamTableMsg(ams::ProcId                    in_proc_id)
    : proc_id(in_proc_id)
{
    this->type = u32(12);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::DumpStreamTableMsg::DumpStreamTableMsg() {
    ams::DumpStreamTableMsg_Init(*this);
}


// --- ams.DumpStreamTableMsg.base.Castdown
// Check if ams::MsgHeader is an instance of DumpStreamTableMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of DumpStreamTableMsg.
// If not successful, quietly return NULL.
inline ams::DumpStreamTableMsg* ams::DumpStreamTableMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (12);
    cond &= i32(hdr.length) >= ssizeof(ams::DumpStreamTableMsg);
    return cond ? reinterpret_cast<ams::DumpStreamTableMsg*>(&hdr) : NULL;
}

// --- ams.DumpStreamTableMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::DumpStreamTableMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.DumpStreamTableMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::DumpStreamTableMsg& row) {
    return i32(const_cast<ams::DumpStreamTableMsg&>(row).length);
}

// --- ams.DumpStreamTableMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::DumpStreamTableMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::DumpStreamTableMsg&>(row).length));
}

// --- ams.DumpStreamTableMsg..Init
// Set all fields to initial values.
inline void ams::DumpStreamTableMsg_Init(ams::DumpStreamTableMsg& parent) {
    parent.type = u32(12);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::ExpectMsg::ExpectMsg() {
    ams::ExpectMsg_Init(*this);
}


// --- ams.ExpectMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ExpectMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ExpectMsg.
// If not successful, quietly return NULL.
inline ams::ExpectMsg* ams::ExpectMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (395);
    cond &= i32(hdr.length) >= ssizeof(ams::ExpectMsg);
    return cond ? reinterpret_cast<ams::ExpectMsg*>(&hdr) : NULL;
}

// --- ams.ExpectMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ExpectMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ExpectMsg.text.N
// Return number of elements in varlen field
inline u32 ams::text_N(const ams::ExpectMsg& parent) {
    u32 length = i32(((ams::ExpectMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::ExpectMsg)) - sizeof(ams::ExpectMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.ExpectMsg.text_curs.Reset
inline void ams::ExpectMsg_text_curs_Reset(ExpectMsg_text_curs &curs, ams::ExpectMsg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::ExpectMsg);
    curs.length = i32(parent.length) - sizeof(ams::ExpectMsg);
    curs.index = 0;
}

// --- ams.ExpectMsg.text_curs.ValidQ
// cursor points to valid item
inline bool ams::ExpectMsg_text_curs_ValidQ(ExpectMsg_text_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.ExpectMsg.text_curs.Next
// proceed to next item
inline void ams::ExpectMsg_text_curs_Next(ExpectMsg_text_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.ExpectMsg.text_curs.Access
// item access
inline char& ams::ExpectMsg_text_curs_Access(ExpectMsg_text_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.ExpectMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ExpectMsg& row) {
    return i32(const_cast<ams::ExpectMsg&>(row).length);
}

// --- ams.ExpectMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ExpectMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ExpectMsg&>(row).length));
}

// --- ams.ExpectMsg..Init
// Set all fields to initial values.
inline void ams::ExpectMsg_Init(ams::ExpectMsg& parent) {
    parent.type = u32(395);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline ams::FieldId::FieldId(ams_FieldIdEnum arg) { this->value = i32(arg); }
inline ams::FieldId::FieldId() {
    ams::FieldId_Init(*this);
}


// --- ams.FieldId.value.GetEnum
// Get value of field as enum type
inline ams_FieldIdEnum ams::value_GetEnum(const ams::FieldId& parent) {
    return ams_FieldIdEnum(parent.value);
}

// --- ams.FieldId.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::FieldId& parent, ams_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- ams.FieldId.value.Cast
inline ams::FieldId::operator ams_FieldIdEnum () const {
    return ams_FieldIdEnum((*this).value);
}

// --- ams.FieldId..Init
// Set all fields to initial values.
inline void ams::FieldId_Init(ams::FieldId& parent) {
    parent.value = i32(-1);
}
inline ams::HeartbeatMsg::HeartbeatMsg(algo::UnTime                   in_time)
    : time(in_time)
{
    this->type = u32(16);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::HeartbeatMsg::HeartbeatMsg() {
    ams::HeartbeatMsg_Init(*this);
}


// --- ams.HeartbeatMsg.base.Castdown
// Check if ams::MsgHeader is an instance of HeartbeatMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of HeartbeatMsg.
// If not successful, quietly return NULL.
inline ams::HeartbeatMsg* ams::HeartbeatMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (16);
    cond &= i32(hdr.length) >= ssizeof(ams::HeartbeatMsg);
    return cond ? reinterpret_cast<ams::HeartbeatMsg*>(&hdr) : NULL;
}

// --- ams.HeartbeatMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::HeartbeatMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.HeartbeatMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::HeartbeatMsg& row) {
    return i32(const_cast<ams::HeartbeatMsg&>(row).length);
}

// --- ams.HeartbeatMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::HeartbeatMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::HeartbeatMsg&>(row).length));
}

// --- ams.HeartbeatMsg..Init
// Set all fields to initial values.
inline void ams::HeartbeatMsg_Init(ams::HeartbeatMsg& parent) {
    parent.type = u32(16);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::InputLineMsg::InputLineMsg() {
    ams::InputLineMsg_Init(*this);
}


// --- ams.InputLineMsg.base.Castdown
// Check if ams::MsgHeader is an instance of InputLineMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of InputLineMsg.
// If not successful, quietly return NULL.
inline ams::InputLineMsg* ams::InputLineMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (22);
    cond &= i32(hdr.length) >= ssizeof(ams::InputLineMsg);
    return cond ? reinterpret_cast<ams::InputLineMsg*>(&hdr) : NULL;
}

// --- ams.InputLineMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::InputLineMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.InputLineMsg.payload.N
// Return number of elements in varlen field
inline u32 ams::payload_N(const ams::InputLineMsg& parent) {
    u32 length = i32(((ams::InputLineMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::InputLineMsg)) - sizeof(ams::InputLineMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.InputLineMsg.payload_curs.Reset
inline void ams::InputLineMsg_payload_curs_Reset(InputLineMsg_payload_curs &curs, ams::InputLineMsg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::InputLineMsg);
    curs.length = i32(parent.length) - sizeof(ams::InputLineMsg);
    curs.index = 0;
}

// --- ams.InputLineMsg.payload_curs.ValidQ
// cursor points to valid item
inline bool ams::InputLineMsg_payload_curs_ValidQ(InputLineMsg_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.InputLineMsg.payload_curs.Next
// proceed to next item
inline void ams::InputLineMsg_payload_curs_Next(InputLineMsg_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.InputLineMsg.payload_curs.Access
// item access
inline char& ams::InputLineMsg_payload_curs_Access(InputLineMsg_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.InputLineMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::InputLineMsg& row) {
    return i32(const_cast<ams::InputLineMsg&>(row).length);
}

// --- ams.InputLineMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::InputLineMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::InputLineMsg&>(row).length));
}

// --- ams.InputLineMsg..Init
// Set all fields to initial values.
inline void ams::InputLineMsg_Init(ams::InputLineMsg& parent) {
    parent.type = u32(22);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::LogMsg::LogMsg(const algo::strptr&            in_logcat
        ,algo::SchedTime                in_tstamp)
    : logcat(in_logcat)
    , tstamp(in_tstamp)
{
    this->type = u32(6);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::LogMsg::LogMsg() {
    ams::LogMsg_Init(*this);
}


// --- ams.LogMsg.base.Castdown
// Check if ams::MsgHeader is an instance of LogMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of LogMsg.
// If not successful, quietly return NULL.
inline ams::LogMsg* ams::LogMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (6);
    cond &= i32(hdr.length) >= ssizeof(ams::LogMsg);
    return cond ? reinterpret_cast<ams::LogMsg*>(&hdr) : NULL;
}

// --- ams.LogMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::LogMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.LogMsg.text.N
// Return number of elements in varlen field
inline u32 ams::text_N(const ams::LogMsg& parent) {
    u32 length = i32(((ams::LogMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::LogMsg)) - sizeof(ams::LogMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.LogMsg.text_curs.Reset
inline void ams::LogMsg_text_curs_Reset(LogMsg_text_curs &curs, ams::LogMsg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::LogMsg);
    curs.length = i32(parent.length) - sizeof(ams::LogMsg);
    curs.index = 0;
}

// --- ams.LogMsg.text_curs.ValidQ
// cursor points to valid item
inline bool ams::LogMsg_text_curs_ValidQ(LogMsg_text_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.LogMsg.text_curs.Next
// proceed to next item
inline void ams::LogMsg_text_curs_Next(LogMsg_text_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.LogMsg.text_curs.Access
// item access
inline char& ams::LogMsg_text_curs_Access(LogMsg_text_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.LogMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::LogMsg& row) {
    return i32(const_cast<ams::LogMsg&>(row).length);
}

// --- ams.LogMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::LogMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::LogMsg&>(row).length));
}

// --- ams.LogMsg..Init
// Set all fields to initial values.
inline void ams::LogMsg_Init(ams::LogMsg& parent) {
    parent.type = u32(6);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::Member::Member(ams::ProcId                    in_proc_id
        ,ams::StreamId                  in_stream_id
        ,u8                             in_mode)
    : proc_id(in_proc_id)
    , stream_id(in_stream_id)
    , mode(in_mode)
{
}

inline bool ams::Member::operator ==(const ams::Member &rhs) const {
    return ams::Member_Eq(const_cast<ams::Member&>(*this),const_cast<ams::Member&>(rhs));
}

inline bool ams::Member::operator !=(const ams::Member &rhs) const {
    return !ams::Member_Eq(const_cast<ams::Member&>(*this),const_cast<ams::Member&>(rhs));
}
inline ams::Member::Member() {
    ams::Member_Init(*this);
}


// --- ams.Member.mode.GetEnum
// Get value of field as enum type
inline ams_Member_mode_Enum ams::mode_GetEnum(const ams::Member& parent) {
    return ams_Member_mode_Enum(parent.mode);
}

// --- ams.Member.mode.SetEnum
// Set value of field from enum type.
inline void ams::mode_SetEnum(ams::Member& parent, ams_Member_mode_Enum rhs) {
    parent.mode = u8(rhs);
}

// --- ams.Member..Hash
inline u32 ams::Member_Hash(u32 prev, ams::Member rhs) {
    prev = ProcId_Hash(prev, rhs.proc_id);
    prev = StreamId_Hash(prev, rhs.stream_id);
    prev = u8_Hash(prev, rhs.mode);
    return prev;
}

// --- ams.Member..Cmp
inline i32 ams::Member_Cmp(ams::Member lhs, ams::Member rhs) {
    i32 retval = 0;
    retval = ams::ProcId_Cmp(lhs.proc_id, rhs.proc_id);
    if (retval != 0) {
        return retval;
    }
    retval = ams::StreamId_Cmp(lhs.stream_id, rhs.stream_id);
    if (retval != 0) {
        return retval;
    }
    retval = u8_Cmp(lhs.mode, rhs.mode);
    return retval;
}

// --- ams.Member..Init
// Set all fields to initial values.
inline void ams::Member_Init(ams::Member& parent) {
    parent.mode = u8(0);
}

// --- ams.Member..Eq
inline bool ams::Member_Eq(ams::Member lhs, ams::Member rhs) {
    bool retval = true;
    retval = ams::ProcId_Eq(lhs.proc_id, rhs.proc_id);
    if (!retval) {
        return false;
    }
    retval = ams::StreamId_Eq(lhs.stream_id, rhs.stream_id);
    if (!retval) {
        return false;
    }
    retval = u8_Eq(lhs.mode, rhs.mode);
    return retval;
}
inline ams::MsgBlock::MsgBlock() {
    ams::MsgBlock_Init(*this);
}


// --- ams.MsgBlock.header.Castdown
// Check if ams::MsgHeader is an instance of MsgBlock by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgBlock.
// If not successful, quietly return NULL.
inline ams::MsgBlock* ams::MsgBlock_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (1);
    cond &= i32(hdr.length) >= ssizeof(ams::MsgBlock);
    return cond ? reinterpret_cast<ams::MsgBlock*>(&hdr) : NULL;
}

// --- ams.MsgBlock.header.Castbase
inline ams::MsgHeader& ams::Castbase(ams::MsgBlock& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.MsgBlock.messages.N
// Return number of elements in varlen field
inline u32 ams::messages_N(const ams::MsgBlock& parent) {
    u32 length = i32(((ams::MsgBlock&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::MsgBlock)) - sizeof(ams::MsgBlock); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u8));
}

// --- ams.MsgBlock.messages_curs.Reset
inline void ams::MsgBlock_messages_curs_Reset(MsgBlock_messages_curs &curs, ams::MsgBlock &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::MsgBlock);
    curs.length = i32(parent.length) - sizeof(ams::MsgBlock);
    curs.index = 0;
}

// --- ams.MsgBlock.messages_curs.ValidQ
// cursor points to valid item
inline bool ams::MsgBlock_messages_curs_ValidQ(MsgBlock_messages_curs &curs) {
    bool valid = ssizeof(u8) <= curs.length;
    return valid;
}

// --- ams.MsgBlock.messages_curs.Next
// proceed to next item
inline void ams::MsgBlock_messages_curs_Next(MsgBlock_messages_curs &curs) {
    i32 len = i32(sizeof(u8));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.MsgBlock.messages_curs.Access
// item access
inline u8& ams::MsgBlock_messages_curs_Access(MsgBlock_messages_curs &curs) {
    return *(u8*)curs.ptr;
}

// --- ams.MsgBlock..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::MsgBlock& row) {
    return i32(const_cast<ams::MsgBlock&>(row).length);
}

// --- ams.MsgBlock..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::MsgBlock& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::MsgBlock&>(row).length));
}

// --- ams.MsgBlock..Init
// Set all fields to initial values.
inline void ams::MsgBlock_Init(ams::MsgBlock& parent) {
    parent.type = u32(1);
    parent.length = u32(ssizeof(parent) + (0));
    parent.first_seqno = u64(0);
    parent.n_messages = u32(0);
    parent.original_length = u32(0);
}
inline ams::MsgHeader::MsgHeader(u32                            in_type
        ,u32                            in_length)
    : type(in_type)
    , length(in_length)
{
}
inline ams::MsgHeader::MsgHeader() {
    ams::MsgHeader_Init(*this);
}


// --- ams.MsgHeader.type.GetEnum
// Get value of field as enum type
inline ams_MsgHeader_type_Enum ams::type_GetEnum(const ams::MsgHeader& data) {
    return ams_MsgHeader_type_Enum(data.type);
}

// --- ams.MsgHeader.type.SetEnum
// Set value of field from enum type.
inline void ams::type_SetEnum(ams::MsgHeader& data, ams_MsgHeader_type_Enum rhs) {
    data.type = u32(rhs);
}

// --- ams.MsgHeader..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::MsgHeader& row) {
    return i32(const_cast<ams::MsgHeader&>(row).length);
}

// --- ams.MsgHeader..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::MsgHeader& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::MsgHeader&>(row).length));
}

// --- ams.MsgHeader..Init
// Set all fields to initial values.
inline void ams::MsgHeader_Init(ams::MsgHeader& data) {
    data.type = u32(0);
    data.length = u32(0);
}
inline ams::MsgHeaderMsgsCase::MsgHeaderMsgsCase(u32                            in_value)
    : value(in_value)
{
}
inline ams::MsgHeaderMsgsCase::MsgHeaderMsgsCase(ams_MsgHeaderMsgsCaseEnum arg) { this->value = u32(arg); }
inline ams::MsgHeaderMsgsCase::MsgHeaderMsgsCase() {
    ams::MsgHeaderMsgsCase_Init(*this);
}


// --- ams.MsgHeaderMsgsCase.value.GetEnum
// Get value of field as enum type
inline ams_MsgHeaderMsgsCaseEnum ams::value_GetEnum(const ams::MsgHeaderMsgsCase& parent) {
    return ams_MsgHeaderMsgsCaseEnum(parent.value);
}

// --- ams.MsgHeaderMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void ams::value_SetEnum(ams::MsgHeaderMsgsCase& parent, ams_MsgHeaderMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- ams.MsgHeaderMsgsCase.value.Cast
inline ams::MsgHeaderMsgsCase::operator ams_MsgHeaderMsgsCaseEnum () const {
    return ams_MsgHeaderMsgsCaseEnum((*this).value);
}

// --- ams.MsgHeaderMsgsCase..Init
// Set all fields to initial values.
inline void ams::MsgHeaderMsgsCase_Init(ams::MsgHeaderMsgsCase& parent) {
    parent.value = u32(0);
}
inline ams::MsgHeader_curs::MsgHeader_curs() {
    ams::MsgHeader_curs_Init(*this);
}


// --- ams.MsgHeader_curs..ValidQ
inline bool ams::MsgHeader_curs_ValidQ(ams::MsgHeader_curs& curs) {
    return curs.msg != NULL;
}

// --- ams.MsgHeader_curs..Reset
inline void ams::MsgHeader_curs_Reset(ams::MsgHeader_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    ams::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ams::MsgHeader)) {
        ams::MsgHeader *ptr = (ams::MsgHeader*)curs.bytes;
        msglen = (*ptr).length;
        if (msglen >= ssizeof(ams::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ams.MsgHeader_curs..Access
inline ams::MsgHeader*& ams::MsgHeader_curs_Access(ams::MsgHeader_curs& curs) {
    return curs.msg;
}

// --- ams.MsgHeader_curs..Next
inline void ams::MsgHeader_curs_Next(ams::MsgHeader_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    ams::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ams::MsgHeader)) {
        ams::MsgHeader *ptr = (ams::MsgHeader*)curs.bytes;
        msglen = (*ptr).length;
        if (msglen >= ssizeof(ams::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ams.MsgHeader_curs..Init
// Set all fields to initial values.
inline void ams::MsgHeader_curs_Init(ams::MsgHeader_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}
inline ams::StreamPos::StreamPos(u64                            in_seq
        ,u64                            in_off)
    : seq(in_seq)
    , off(in_off)
{
}
inline ams::StreamPos::StreamPos() {
    ams::StreamPos_Init(*this);
}


// --- ams.StreamPos..Init
// Set all fields to initial values.
inline void ams::StreamPos_Init(ams::StreamPos& parent) {
    parent.seq = u64(1);
    parent.off = u64(0);
}
inline ams::OpenMsg::OpenMsg(ams::Member                    in_member
        ,ams::StreamPos                 in_pos)
    : member(in_member)
    , pos(in_pos)
{
    this->type = u32(7);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::OpenMsg::OpenMsg() {
    ams::OpenMsg_Init(*this);
}


// --- ams.OpenMsg.base.Castdown
// Check if ams::MsgHeader is an instance of OpenMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of OpenMsg.
// If not successful, quietly return NULL.
inline ams::OpenMsg* ams::OpenMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (7);
    cond &= i32(hdr.length) >= ssizeof(ams::OpenMsg);
    return cond ? reinterpret_cast<ams::OpenMsg*>(&hdr) : NULL;
}

// --- ams.OpenMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::OpenMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.OpenMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::OpenMsg& row) {
    return i32(const_cast<ams::OpenMsg&>(row).length);
}

// --- ams.OpenMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::OpenMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::OpenMsg&>(row).length));
}

// --- ams.OpenMsg..Init
// Set all fields to initial values.
inline void ams::OpenMsg_Init(ams::OpenMsg& parent) {
    parent.type = u32(7);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::PrlogMsg::PrlogMsg() {
    ams::PrlogMsg_Init(*this);
}


// --- ams.PrlogMsg.base.Castdown
// Check if ams::MsgHeader is an instance of PrlogMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of PrlogMsg.
// If not successful, quietly return NULL.
inline ams::PrlogMsg* ams::PrlogMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (229);
    cond &= i32(hdr.length) >= ssizeof(ams::PrlogMsg);
    return cond ? reinterpret_cast<ams::PrlogMsg*>(&hdr) : NULL;
}

// --- ams.PrlogMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::PrlogMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.PrlogMsg.data.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized data, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If data's length field value is too short, return NULL.
// If data's length field value extends past parent's allowed length, return NULL.
inline ams::MsgHeader* ams::data_Get(ams::PrlogMsg& parent) {
    i32 totlen = i32(parent.length);
    u8 *end = (u8*)&parent + sizeof(ams::PrlogMsg);
    ams::MsgHeader *ptr = (ams::MsgHeader*)end;
    bool exists = ssizeof(ams::PrlogMsg) + sizeof_ams_MsgHeader <= totlen;
    exists = exists && i32((*ptr).length) >= sizeof_ams_MsgHeader && ssizeof(ams::PrlogMsg) + i32((*ptr).length) <= totlen;
    return exists ? ptr : NULL;
}

// --- ams.PrlogMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::PrlogMsg& row) {
    return i32(const_cast<ams::PrlogMsg&>(row).length);
}

// --- ams.PrlogMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::PrlogMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::PrlogMsg&>(row).length));
}

// --- ams.PrlogMsg..Init
// Set all fields to initial values.
inline void ams::PrlogMsg_Init(ams::PrlogMsg& parent) {
    parent.type = u32(229);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::ProcAddMsg::ProcAddMsg(ams::ProcId                    in_proc_id)
    : proc_id(in_proc_id)
{
    this->type = u32(4);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::ProcAddMsg::ProcAddMsg() {
    ams::ProcAddMsg_Init(*this);
}


// --- ams.ProcAddMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcAddMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcAddMsg.
// If not successful, quietly return NULL.
inline ams::ProcAddMsg* ams::ProcAddMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (4);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcAddMsg);
    return cond ? reinterpret_cast<ams::ProcAddMsg*>(&hdr) : NULL;
}

// --- ams.ProcAddMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcAddMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcAddMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcAddMsg& row) {
    return i32(const_cast<ams::ProcAddMsg&>(row).length);
}

// --- ams.ProcAddMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcAddMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcAddMsg&>(row).length));
}

// --- ams.ProcAddMsg..Init
// Set all fields to initial values.
inline void ams::ProcAddMsg_Init(ams::ProcAddMsg& parent) {
    parent.type = u32(4);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::ProcRemoveMsg::ProcRemoveMsg(ams::ProcId                    in_proc_id)
    : proc_id(in_proc_id)
{
    this->type = u32(5);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::ProcRemoveMsg::ProcRemoveMsg() {
    ams::ProcRemoveMsg_Init(*this);
}


// --- ams.ProcRemoveMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ProcRemoveMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcRemoveMsg.
// If not successful, quietly return NULL.
inline ams::ProcRemoveMsg* ams::ProcRemoveMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (5);
    cond &= i32(hdr.length) >= ssizeof(ams::ProcRemoveMsg);
    return cond ? reinterpret_cast<ams::ProcRemoveMsg*>(&hdr) : NULL;
}

// --- ams.ProcRemoveMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::ProcRemoveMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.ProcRemoveMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::ProcRemoveMsg& row) {
    return i32(const_cast<ams::ProcRemoveMsg&>(row).length);
}

// --- ams.ProcRemoveMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::ProcRemoveMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::ProcRemoveMsg&>(row).length));
}

// --- ams.ProcRemoveMsg..Init
// Set all fields to initial values.
inline void ams::ProcRemoveMsg_Init(ams::ProcRemoveMsg& parent) {
    parent.type = u32(5);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::Protocol::Protocol() {
}

inline ams::SeqmsgId::SeqmsgId(ams::StreamId                  in_stream_id
        ,u64                            in_seq
        ,u32                            in_off)
    : stream_id(in_stream_id)
    , seq(in_seq)
    , off(in_off)
{
}
inline ams::SeqmsgId::SeqmsgId() {
    ams::SeqmsgId_Init(*this);
}


// --- ams.SeqmsgId..Init
// Set all fields to initial values.
inline void ams::SeqmsgId_Init(ams::SeqmsgId& parent) {
    parent.seq = u64(1);
    parent.off = u32(0);
}
inline ams::Seqmsg::Seqmsg(ams::SeqmsgId                  in_seqmsg_id
        ,u64                            in_tsc)
    : seqmsg_id(in_seqmsg_id)
    , tsc(in_tsc)
{
    this->type = u32(10);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::Seqmsg::Seqmsg() {
    ams::Seqmsg_Init(*this);
}


// --- ams.Seqmsg.base.Castdown
// Check if ams::MsgHeader is an instance of Seqmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Seqmsg.
// If not successful, quietly return NULL.
inline ams::Seqmsg* ams::Seqmsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (10);
    cond &= i32(hdr.length) >= ssizeof(ams::Seqmsg);
    return cond ? reinterpret_cast<ams::Seqmsg*>(&hdr) : NULL;
}

// --- ams.Seqmsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::Seqmsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.Seqmsg.payload.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
inline ams::MsgHeader* ams::payload_Get(ams::Seqmsg& parent) {
    i32 totlen = i32(parent.length);
    u8 *end = (u8*)&parent + sizeof(ams::Seqmsg);
    ams::MsgHeader *ptr = (ams::MsgHeader*)end;
    bool exists = ssizeof(ams::Seqmsg) + sizeof_ams_MsgHeader <= totlen;
    exists = exists && i32((*ptr).length) >= sizeof_ams_MsgHeader && ssizeof(ams::Seqmsg) + i32((*ptr).length) <= totlen;
    return exists ? ptr : NULL;
}

// --- ams.Seqmsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::Seqmsg& row) {
    return i32(const_cast<ams::Seqmsg&>(row).length);
}

// --- ams.Seqmsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::Seqmsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::Seqmsg&>(row).length));
}

// --- ams.Seqmsg..Init
// Set all fields to initial values.
inline void ams::Seqmsg_Init(ams::Seqmsg& parent) {
    parent.type = u32(10);
    parent.length = u32(ssizeof(parent) + (0));
    parent.tsc = u64(0);
}
inline ams::SeqmsgTrace::SeqmsgTrace(ams::ProcId                    in_proc_id
        ,u8                             in_mode
        ,ams::SeqmsgId                  in_seqmsg_id
        ,u64                            in_tsc)
    : proc_id(in_proc_id)
    , mode(in_mode)
    , seqmsg_id(in_seqmsg_id)
    , tsc(in_tsc)
{
    this->type = u32(11);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::SeqmsgTrace::SeqmsgTrace() {
    ams::SeqmsgTrace_Init(*this);
}


// --- ams.SeqmsgTrace.base.Castdown
// Check if ams::MsgHeader is an instance of SeqmsgTrace by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of SeqmsgTrace.
// If not successful, quietly return NULL.
inline ams::SeqmsgTrace* ams::SeqmsgTrace_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (11);
    cond &= i32(hdr.length) >= ssizeof(ams::SeqmsgTrace);
    return cond ? reinterpret_cast<ams::SeqmsgTrace*>(&hdr) : NULL;
}

// --- ams.SeqmsgTrace.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::SeqmsgTrace& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.SeqmsgTrace.mode.GetEnum
// Get value of field as enum type
inline ams_SeqmsgTrace_mode_Enum ams::mode_GetEnum(const ams::SeqmsgTrace& parent) {
    return ams_SeqmsgTrace_mode_Enum(parent.mode);
}

// --- ams.SeqmsgTrace.mode.SetEnum
// Set value of field from enum type.
inline void ams::mode_SetEnum(ams::SeqmsgTrace& parent, ams_SeqmsgTrace_mode_Enum rhs) {
    parent.mode = u8(rhs);
}

// --- ams.SeqmsgTrace.payload.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
inline ams::MsgHeader* ams::payload_Get(ams::SeqmsgTrace& parent) {
    i32 totlen = i32(parent.length);
    u8 *end = (u8*)&parent + sizeof(ams::SeqmsgTrace);
    ams::MsgHeader *ptr = (ams::MsgHeader*)end;
    bool exists = ssizeof(ams::SeqmsgTrace) + sizeof_ams_MsgHeader <= totlen;
    exists = exists && i32((*ptr).length) >= sizeof_ams_MsgHeader && ssizeof(ams::SeqmsgTrace) + i32((*ptr).length) <= totlen;
    return exists ? ptr : NULL;
}

// --- ams.SeqmsgTrace..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::SeqmsgTrace& row) {
    return i32(const_cast<ams::SeqmsgTrace&>(row).length);
}

// --- ams.SeqmsgTrace..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::SeqmsgTrace& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::SeqmsgTrace&>(row).length));
}

// --- ams.SeqmsgTrace..Init
// Set all fields to initial values.
inline void ams::SeqmsgTrace_Init(ams::SeqmsgTrace& parent) {
    parent.type = u32(11);
    parent.length = u32(ssizeof(parent) + (0));
    parent.mode = u8(0);
    parent.tsc = u64(0);
}
inline ams::StreamFlags::StreamFlags(u8                             in_value)
    : value(in_value)
{
}
inline ams::StreamFlags::StreamFlags(ams_StreamFlagsEnum arg) { this->value = u8(arg); }
inline ams::StreamFlags::StreamFlags() {
    ams::StreamFlags_Init(*this);
}


// --- ams.StreamFlags.write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool ams::write_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- ams.StreamFlags.write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void ams::write_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 1;
    u8 t2    = (u8(rhs) & 0x01) << 1;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags.read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool ams::read_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- ams.StreamFlags.read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void ams::read_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 2;
    u8 t2    = (u8(rhs) & 0x01) << 2;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags.nonblock.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool ams::nonblock_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- ams.StreamFlags.nonblock.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void ams::nonblock_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 3;
    u8 t2    = (u8(rhs) & 0x01) << 3;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags.trace_read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
inline bool ams::trace_read_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 4) & 0x01);
}

// --- ams.StreamFlags.trace_read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
inline void ams::trace_read_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags.trace_write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 5.
inline bool ams::trace_write_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 5) & 0x01);
}

// --- ams.StreamFlags.trace_write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 5.
inline void ams::trace_write_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags.write_err.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
inline bool ams::write_err_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 6) & 0x01);
}

// --- ams.StreamFlags.write_err.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
inline void ams::write_err_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags.trace_text.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 7.
inline bool ams::trace_text_Get(const ams::StreamFlags& parent) {
    return bool((parent.value >> 7) & 0x01);
}

// --- ams.StreamFlags.trace_text.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 7.
inline void ams::trace_text_Set(ams::StreamFlags& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.value = u8((parent.value & ~t1) | t2);
}

// --- ams.StreamFlags..Init
// Set all fields to initial values.
inline void ams::StreamFlags_Init(ams::StreamFlags& parent) {
    parent.value = u8(0);
}
inline ams::StreamHbMsg::StreamHbMsg(ams::Member                    in_member
        ,ams::StreamPos                 in_pos
        ,u32                            in_wbudget)
    : member(in_member)
    , pos(in_pos)
    , wbudget(in_wbudget)
{
    this->type = u32(3);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::StreamHbMsg::StreamHbMsg() {
    ams::StreamHbMsg_Init(*this);
}


// --- ams.StreamHbMsg.base.Castdown
// Check if ams::MsgHeader is an instance of StreamHbMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of StreamHbMsg.
// If not successful, quietly return NULL.
inline ams::StreamHbMsg* ams::StreamHbMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (3);
    cond &= i32(hdr.length) >= ssizeof(ams::StreamHbMsg);
    return cond ? reinterpret_cast<ams::StreamHbMsg*>(&hdr) : NULL;
}

// --- ams.StreamHbMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::StreamHbMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.StreamHbMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::StreamHbMsg& row) {
    return i32(const_cast<ams::StreamHbMsg&>(row).length);
}

// --- ams.StreamHbMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::StreamHbMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::StreamHbMsg&>(row).length));
}

// --- ams.StreamHbMsg..Init
// Set all fields to initial values.
inline void ams::StreamHbMsg_Init(ams::StreamHbMsg& parent) {
    parent.type = u32(3);
    parent.length = u32(ssizeof(parent) + (0));
    parent.wbudget = u32(0);
}
inline ams::TerminateMsg::TerminateMsg() {
    ams::TerminateMsg_Init(*this);
}


// --- ams.TerminateMsg.base.Castdown
// Check if ams::MsgHeader is an instance of TerminateMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TerminateMsg.
// If not successful, quietly return NULL.
inline ams::TerminateMsg* ams::TerminateMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (352);
    cond &= i32(hdr.length) >= ssizeof(ams::TerminateMsg);
    return cond ? reinterpret_cast<ams::TerminateMsg*>(&hdr) : NULL;
}

// --- ams.TerminateMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::TerminateMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.TerminateMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::TerminateMsg& row) {
    return i32(const_cast<ams::TerminateMsg&>(row).length);
}

// --- ams.TerminateMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::TerminateMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::TerminateMsg&>(row).length));
}

// --- ams.TerminateMsg..Init
// Set all fields to initial values.
inline void ams::TerminateMsg_Init(ams::TerminateMsg& parent) {
    parent.type = u32(352);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::Trace2Msg::Trace2Msg(ams::ProcId                    in_proc
        ,u8                             in_trace
        ,algo::UnTime                   in_tstamp)
    : proc(in_proc)
    , trace(in_trace)
    , tstamp(in_tstamp)
{
    this->type = u32(108);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::Trace2Msg::Trace2Msg() {
    ams::Trace2Msg_Init(*this);
}


// --- ams.Trace2Msg.base.Castdown
// Check if ams::MsgHeader is an instance of Trace2Msg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Trace2Msg.
// If not successful, quietly return NULL.
inline ams::Trace2Msg* ams::Trace2Msg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (108);
    cond &= i32(hdr.length) >= ssizeof(ams::Trace2Msg);
    return cond ? reinterpret_cast<ams::Trace2Msg*>(&hdr) : NULL;
}

// --- ams.Trace2Msg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::Trace2Msg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.Trace2Msg.data.N
// Return number of elements in varlen field
inline u32 ams::data_N(const ams::Trace2Msg& parent) {
    u32 length = i32(((ams::Trace2Msg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::Trace2Msg)) - sizeof(ams::Trace2Msg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u64));
}

// --- ams.Trace2Msg.data_curs.Reset
inline void ams::Trace2Msg_data_curs_Reset(Trace2Msg_data_curs &curs, ams::Trace2Msg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::Trace2Msg);
    curs.length = i32(parent.length) - sizeof(ams::Trace2Msg);
    curs.index = 0;
}

// --- ams.Trace2Msg.data_curs.ValidQ
// cursor points to valid item
inline bool ams::Trace2Msg_data_curs_ValidQ(Trace2Msg_data_curs &curs) {
    bool valid = ssizeof(u64) <= curs.length;
    return valid;
}

// --- ams.Trace2Msg.data_curs.Next
// proceed to next item
inline void ams::Trace2Msg_data_curs_Next(Trace2Msg_data_curs &curs) {
    i32 len = i32(sizeof(u64));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.Trace2Msg.data_curs.Access
// item access
inline u64& ams::Trace2Msg_data_curs_Access(Trace2Msg_data_curs &curs) {
    return *(u64*)curs.ptr;
}

// --- ams.Trace2Msg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::Trace2Msg& row) {
    return i32(const_cast<ams::Trace2Msg&>(row).length);
}

// --- ams.Trace2Msg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::Trace2Msg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::Trace2Msg&>(row).length));
}

// --- ams.Trace2Msg..Init
// Set all fields to initial values.
inline void ams::Trace2Msg_Init(ams::Trace2Msg& parent) {
    parent.type = u32(108);
    parent.length = u32(ssizeof(parent) + (0));
    parent.trace = u8(0);
}
inline ams::TraceInfo2Msg::TraceInfo2Msg(ams::ProcId                    in_proc
        ,u8                             in_trace
        ,algo::UnTime                   in_tstamp
        ,u8                             in_part)
    : proc(in_proc)
    , trace(in_trace)
    , tstamp(in_tstamp)
    , part(in_part)
{
    this->type = u32(109);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::TraceInfo2Msg::TraceInfo2Msg() {
    ams::TraceInfo2Msg_Init(*this);
}


// --- ams.TraceInfo2Msg.base.Castdown
// Check if ams::MsgHeader is an instance of TraceInfo2Msg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TraceInfo2Msg.
// If not successful, quietly return NULL.
inline ams::TraceInfo2Msg* ams::TraceInfo2Msg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (109);
    cond &= i32(hdr.length) >= ssizeof(ams::TraceInfo2Msg);
    return cond ? reinterpret_cast<ams::TraceInfo2Msg*>(&hdr) : NULL;
}

// --- ams.TraceInfo2Msg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::TraceInfo2Msg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.TraceInfo2Msg.data.N
// Return number of elements in varlen field
inline u32 ams::data_N(const ams::TraceInfo2Msg& parent) {
    u32 length = i32(((ams::TraceInfo2Msg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::TraceInfo2Msg)) - sizeof(ams::TraceInfo2Msg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.TraceInfo2Msg.data_curs.Reset
inline void ams::TraceInfo2Msg_data_curs_Reset(TraceInfo2Msg_data_curs &curs, ams::TraceInfo2Msg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::TraceInfo2Msg);
    curs.length = i32(parent.length) - sizeof(ams::TraceInfo2Msg);
    curs.index = 0;
}

// --- ams.TraceInfo2Msg.data_curs.ValidQ
// cursor points to valid item
inline bool ams::TraceInfo2Msg_data_curs_ValidQ(TraceInfo2Msg_data_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.TraceInfo2Msg.data_curs.Next
// proceed to next item
inline void ams::TraceInfo2Msg_data_curs_Next(TraceInfo2Msg_data_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.TraceInfo2Msg.data_curs.Access
// item access
inline char& ams::TraceInfo2Msg_data_curs_Access(TraceInfo2Msg_data_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.TraceInfo2Msg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::TraceInfo2Msg& row) {
    return i32(const_cast<ams::TraceInfo2Msg&>(row).length);
}

// --- ams.TraceInfo2Msg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::TraceInfo2Msg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::TraceInfo2Msg&>(row).length));
}

// --- ams.TraceInfo2Msg..Init
// Set all fields to initial values.
inline void ams::TraceInfo2Msg_Init(ams::TraceInfo2Msg& parent) {
    parent.type = u32(109);
    parent.length = u32(ssizeof(parent) + (0));
    parent.trace = u8(0);
    parent.part = u8(0);
}
inline ams::TraceInfoMsg::TraceInfoMsg(ams::ProcId                    in_proc
        ,algo::UnTime                   in_tstamp
        ,u8                             in_part)
    : proc(in_proc)
    , tstamp(in_tstamp)
    , part(in_part)
{
    this->type = u32(9);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::TraceInfoMsg::TraceInfoMsg() {
    ams::TraceInfoMsg_Init(*this);
}


// --- ams.TraceInfoMsg.base.Castdown
// Check if ams::MsgHeader is an instance of TraceInfoMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TraceInfoMsg.
// If not successful, quietly return NULL.
inline ams::TraceInfoMsg* ams::TraceInfoMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (9);
    cond &= i32(hdr.length) >= ssizeof(ams::TraceInfoMsg);
    return cond ? reinterpret_cast<ams::TraceInfoMsg*>(&hdr) : NULL;
}

// --- ams.TraceInfoMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::TraceInfoMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.TraceInfoMsg.data.N
// Return number of elements in varlen field
inline u32 ams::data_N(const ams::TraceInfoMsg& parent) {
    u32 length = i32(((ams::TraceInfoMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::TraceInfoMsg)) - sizeof(ams::TraceInfoMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ams.TraceInfoMsg.data_curs.Reset
inline void ams::TraceInfoMsg_data_curs_Reset(TraceInfoMsg_data_curs &curs, ams::TraceInfoMsg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::TraceInfoMsg);
    curs.length = i32(parent.length) - sizeof(ams::TraceInfoMsg);
    curs.index = 0;
}

// --- ams.TraceInfoMsg.data_curs.ValidQ
// cursor points to valid item
inline bool ams::TraceInfoMsg_data_curs_ValidQ(TraceInfoMsg_data_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ams.TraceInfoMsg.data_curs.Next
// proceed to next item
inline void ams::TraceInfoMsg_data_curs_Next(TraceInfoMsg_data_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.TraceInfoMsg.data_curs.Access
// item access
inline char& ams::TraceInfoMsg_data_curs_Access(TraceInfoMsg_data_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ams.TraceInfoMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::TraceInfoMsg& row) {
    return i32(const_cast<ams::TraceInfoMsg&>(row).length);
}

// --- ams.TraceInfoMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::TraceInfoMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::TraceInfoMsg&>(row).length));
}

// --- ams.TraceInfoMsg..Init
// Set all fields to initial values.
inline void ams::TraceInfoMsg_Init(ams::TraceInfoMsg& parent) {
    parent.type = u32(9);
    parent.length = u32(ssizeof(parent) + (0));
    parent.part = u8(0);
}
inline ams::TraceMsg::TraceMsg(ams::ProcId                    in_proc
        ,algo::UnTime                   in_tstamp)
    : proc(in_proc)
    , tstamp(in_tstamp)
{
    this->type = u32(8);
    this->length = u32(ssizeof(*this) + (0));
}
inline ams::TraceMsg::TraceMsg() {
    ams::TraceMsg_Init(*this);
}


// --- ams.TraceMsg.base.Castdown
// Check if ams::MsgHeader is an instance of TraceMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TraceMsg.
// If not successful, quietly return NULL.
inline ams::TraceMsg* ams::TraceMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (8);
    cond &= i32(hdr.length) >= ssizeof(ams::TraceMsg);
    return cond ? reinterpret_cast<ams::TraceMsg*>(&hdr) : NULL;
}

// --- ams.TraceMsg.base.Castbase
inline ams::MsgHeader& ams::Castbase(ams::TraceMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.TraceMsg.data.N
// Return number of elements in varlen field
inline u32 ams::data_N(const ams::TraceMsg& parent) {
    u32 length = i32(((ams::TraceMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::TraceMsg)) - sizeof(ams::TraceMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u64));
}

// --- ams.TraceMsg.data_curs.Reset
inline void ams::TraceMsg_data_curs_Reset(TraceMsg_data_curs &curs, ams::TraceMsg &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::TraceMsg);
    curs.length = i32(parent.length) - sizeof(ams::TraceMsg);
    curs.index = 0;
}

// --- ams.TraceMsg.data_curs.ValidQ
// cursor points to valid item
inline bool ams::TraceMsg_data_curs_ValidQ(TraceMsg_data_curs &curs) {
    bool valid = ssizeof(u64) <= curs.length;
    return valid;
}

// --- ams.TraceMsg.data_curs.Next
// proceed to next item
inline void ams::TraceMsg_data_curs_Next(TraceMsg_data_curs &curs) {
    i32 len = i32(sizeof(u64));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.TraceMsg.data_curs.Access
// item access
inline u64& ams::TraceMsg_data_curs_Access(TraceMsg_data_curs &curs) {
    return *(u64*)curs.ptr;
}

// --- ams.TraceMsg..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::TraceMsg& row) {
    return i32(const_cast<ams::TraceMsg&>(row).length);
}

// --- ams.TraceMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::TraceMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::TraceMsg&>(row).length));
}

// --- ams.TraceMsg..Init
// Set all fields to initial values.
inline void ams::TraceMsg_Init(ams::TraceMsg& parent) {
    parent.type = u32(8);
    parent.length = u32(ssizeof(parent) + (0));
}
inline ams::UdpFrame::UdpFrame() {
    ams::UdpFrame_Init(*this);
}


// --- ams.UdpFrame.header.Castdown
// Check if ams::MsgHeader is an instance of UdpFrame by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of UdpFrame.
// If not successful, quietly return NULL.
inline ams::UdpFrame* ams::UdpFrame_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (2);
    cond &= i32(hdr.length) >= ssizeof(ams::UdpFrame);
    return cond ? reinterpret_cast<ams::UdpFrame*>(&hdr) : NULL;
}

// --- ams.UdpFrame.header.Castbase
inline ams::MsgHeader& ams::Castbase(ams::UdpFrame& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ams.UdpFrame.payload.N
// Return number of elements in varlen field
inline u32 ams::payload_N(const ams::UdpFrame& parent) {
    u32 length = i32(((ams::UdpFrame&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ams::UdpFrame)) - sizeof(ams::UdpFrame); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u8));
}

// --- ams.UdpFrame.payload_curs.Reset
inline void ams::UdpFrame_payload_curs_Reset(UdpFrame_payload_curs &curs, ams::UdpFrame &parent) {
    curs.ptr = (u8*)&parent + sizeof(ams::UdpFrame);
    curs.length = i32(parent.length) - sizeof(ams::UdpFrame);
    curs.index = 0;
}

// --- ams.UdpFrame.payload_curs.ValidQ
// cursor points to valid item
inline bool ams::UdpFrame_payload_curs_ValidQ(UdpFrame_payload_curs &curs) {
    bool valid = ssizeof(u8) <= curs.length;
    return valid;
}

// --- ams.UdpFrame.payload_curs.Next
// proceed to next item
inline void ams::UdpFrame_payload_curs_Next(UdpFrame_payload_curs &curs) {
    i32 len = i32(sizeof(u8));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ams.UdpFrame.payload_curs.Access
// item access
inline u8& ams::UdpFrame_payload_curs_Access(UdpFrame_payload_curs &curs) {
    return *(u8*)curs.ptr;
}

// --- ams.UdpFrame..GetMsgLength
// Message length (uses length field)
inline i32 ams::GetMsgLength(const ams::UdpFrame& row) {
    return i32(const_cast<ams::UdpFrame&>(row).length);
}

// --- ams.UdpFrame..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ams::GetMsgMemptr(const ams::UdpFrame& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ams::UdpFrame&>(row).length));
}

// --- ams.UdpFrame..Init
// Set all fields to initial values.
inline void ams::UdpFrame_Init(ams::UdpFrame& parent) {
    parent.type = u32(2);
    parent.length = u32(ssizeof(parent) + (0));
    parent.src_port = u16(0);
    parent.dst_port = u16(0);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::AlarmSyncMsg &row) {// cfmt:ams.AlarmSyncMsg.String
    ams::AlarmSyncMsg_Print(const_cast<ams::AlarmSyncMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcId &row) {// cfmt:ams.ProcId.String
    ams::ProcId_Print(const_cast<ams::ProcId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::StreamType &row) {// cfmt:ams.StreamType.String
    ams::StreamType_Print(const_cast<ams::StreamType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::StreamId &row) {// cfmt:ams.StreamId.String
    ams::StreamId_Print(const_cast<ams::StreamId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::DfltStream &row) {// cfmt:ams.DfltStream.String
    ams::DfltStream_Print(const_cast<ams::DfltStream&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::DumpStreamTableMsg &row) {// cfmt:ams.DumpStreamTableMsg.String
    ams::DumpStreamTableMsg_Print(const_cast<ams::DumpStreamTableMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ExpectMsg &row) {// cfmt:ams.ExpectMsg.String
    ams::ExpectMsg_Print(const_cast<ams::ExpectMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::FieldId &row) {// cfmt:ams.FieldId.String
    ams::FieldId_Print(const_cast<ams::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::HeartbeatMsg &row) {// cfmt:ams.HeartbeatMsg.String
    ams::HeartbeatMsg_Print(const_cast<ams::HeartbeatMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::InputLineMsg &row) {// cfmt:ams.InputLineMsg.String
    ams::InputLineMsg_Print(const_cast<ams::InputLineMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::Member &row) {// cfmt:ams.Member.String
    ams::Member_Print(const_cast<ams::Member&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::MsgBlock &row) {// cfmt:ams.MsgBlock.String
    ams::MsgBlock_Print(const_cast<ams::MsgBlock&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::MsgHeader &row) {// cfmt:ams.MsgHeader.String
    ams::MsgHeader_Print(const_cast<ams::MsgHeader&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::StreamPos &row) {// cfmt:ams.StreamPos.String
    ams::StreamPos_Print(const_cast<ams::StreamPos&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::OpenMsg &row) {// cfmt:ams.OpenMsg.String
    ams::OpenMsg_Print(const_cast<ams::OpenMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::PrlogMsg &row) {// cfmt:ams.PrlogMsg.String
    ams::PrlogMsg_Print(const_cast<ams::PrlogMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcAddMsg &row) {// cfmt:ams.ProcAddMsg.String
    ams::ProcAddMsg_Print(const_cast<ams::ProcAddMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::ProcRemoveMsg &row) {// cfmt:ams.ProcRemoveMsg.String
    ams::ProcRemoveMsg_Print(const_cast<ams::ProcRemoveMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::SeqmsgId &row) {// cfmt:ams.SeqmsgId.String
    ams::SeqmsgId_Print(const_cast<ams::SeqmsgId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::Seqmsg &row) {// cfmt:ams.Seqmsg.String
    ams::Seqmsg_Print(const_cast<ams::Seqmsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::SeqmsgTrace &row) {// cfmt:ams.SeqmsgTrace.String
    ams::SeqmsgTrace_Print(const_cast<ams::SeqmsgTrace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::StreamFlags &row) {// cfmt:ams.StreamFlags.String
    ams::StreamFlags_Print(const_cast<ams::StreamFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::StreamHbMsg &row) {// cfmt:ams.StreamHbMsg.String
    ams::StreamHbMsg_Print(const_cast<ams::StreamHbMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ams::UdpFrame &row) {// cfmt:ams.UdpFrame.String
    ams::UdpFrame_Print(const_cast<ams::UdpFrame&>(row), str);
    return str;
}
