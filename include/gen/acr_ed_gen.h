//
// include/gen/acr_ed_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/dmmeta_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/dev_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- acr_ed_FieldIdEnum

enum acr_ed_FieldIdEnum {        // acr_ed.FieldId.value
     acr_ed_FieldId_value   = 0
};

enum { acr_ed_FieldIdEnum_N = 1 };


// --- acr_ed_TableIdEnum

enum acr_ed_TableIdEnum {                    // acr_ed.TableId.value
     acr_ed_TableId_dmmeta_Cfmt       = 0    // dmmeta.Cfmt -> acr_ed.FCfmt
    ,acr_ed_TableId_dmmeta_cfmt       = 0    // dmmeta.cfmt -> acr_ed.FCfmt
    ,acr_ed_TableId_dmmeta_Cpptype    = 1    // dmmeta.Cpptype -> acr_ed.FCpptype
    ,acr_ed_TableId_dmmeta_cpptype    = 1    // dmmeta.cpptype -> acr_ed.FCpptype
    ,acr_ed_TableId_dmmeta_Cstr       = 2    // dmmeta.Cstr -> acr_ed.FCstr
    ,acr_ed_TableId_dmmeta_cstr       = 2    // dmmeta.cstr -> acr_ed.FCstr
    ,acr_ed_TableId_dmmeta_Ctype      = 3    // dmmeta.Ctype -> acr_ed.FCtype
    ,acr_ed_TableId_dmmeta_ctype      = 3    // dmmeta.ctype -> acr_ed.FCtype
    ,acr_ed_TableId_dmmeta_Field      = 4    // dmmeta.Field -> acr_ed.FField
    ,acr_ed_TableId_dmmeta_field      = 4    // dmmeta.field -> acr_ed.FField
    ,acr_ed_TableId_dmmeta_Fprefix    = 5    // dmmeta.Fprefix -> acr_ed.FFprefix
    ,acr_ed_TableId_dmmeta_fprefix    = 5    // dmmeta.fprefix -> acr_ed.FFprefix
    ,acr_ed_TableId_dmmeta_Listtype   = 6    // dmmeta.Listtype -> acr_ed.FListtype
    ,acr_ed_TableId_dmmeta_listtype   = 6    // dmmeta.listtype -> acr_ed.FListtype
    ,acr_ed_TableId_dmmeta_Ns         = 7    // dmmeta.Ns -> acr_ed.FNs
    ,acr_ed_TableId_dmmeta_ns         = 7    // dmmeta.ns -> acr_ed.FNs
    ,acr_ed_TableId_dmmeta_Nsdb       = 8    // dmmeta.Nsdb -> acr_ed.FNsdb
    ,acr_ed_TableId_dmmeta_nsdb       = 8    // dmmeta.nsdb -> acr_ed.FNsdb
    ,acr_ed_TableId_dmmeta_Pack       = 9    // dmmeta.Pack -> acr_ed.FPack
    ,acr_ed_TableId_dmmeta_pack       = 9    // dmmeta.pack -> acr_ed.FPack
    ,acr_ed_TableId_dev_Sandbox       = 10   // dev.Sandbox -> acr_ed.FSandbox
    ,acr_ed_TableId_dev_sandbox       = 10   // dev.sandbox -> acr_ed.FSandbox
    ,acr_ed_TableId_dmmeta_Ssimfile   = 11   // dmmeta.Ssimfile -> acr_ed.FSsimfile
    ,acr_ed_TableId_dmmeta_ssimfile   = 11   // dmmeta.ssimfile -> acr_ed.FSsimfile
    ,acr_ed_TableId_dev_Target        = 12   // dev.Target -> acr_ed.FTarget
    ,acr_ed_TableId_dev_target        = 12   // dev.target -> acr_ed.FTarget
    ,acr_ed_TableId_dev_Targsrc       = 13   // dev.Targsrc -> acr_ed.FTargsrc
    ,acr_ed_TableId_dev_targsrc       = 13   // dev.targsrc -> acr_ed.FTargsrc
    ,acr_ed_TableId_dmmeta_Typefld    = 14   // dmmeta.Typefld -> acr_ed.FTypefld
    ,acr_ed_TableId_dmmeta_typefld    = 14   // dmmeta.typefld -> acr_ed.FTypefld
};

enum { acr_ed_TableIdEnum_N = 30 };

namespace acr_ed { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace acr_ed { // gen:ns_field
extern const char *acr_ed_help;
extern const char *acr_ed_syntax;
} // gen:ns_field
// gen:ns_fwddecl2
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace acr_ed { struct FNs; }
namespace dmmeta { struct Field; }
namespace acr_ed { struct FCtype; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Pack; }
namespace dev { struct Sandbox; }
namespace dmmeta { struct Ssimfile; }
namespace dev { struct Target; }
namespace dev { struct Targsrc; }
namespace acr_ed { struct FTarget; }
namespace dmmeta { struct Typefld; }
namespace acr_ed { struct ctype_c_field_curs; }
namespace acr_ed { struct ctype_c_cfmt_curs; }
namespace acr_ed { struct _db_ns_curs; }
namespace acr_ed { struct _db_field_curs; }
namespace acr_ed { struct _db_ctype_curs; }
namespace acr_ed { struct _db_ssimfile_curs; }
namespace acr_ed { struct _db_cstr_curs; }
namespace acr_ed { struct _db_vis_curs; }
namespace acr_ed { struct _db_listtype_curs; }
namespace acr_ed { struct _db_fprefix_curs; }
namespace acr_ed { struct _db_target_curs; }
namespace acr_ed { struct _db_targsrc_curs; }
namespace acr_ed { struct _db_sandbox_curs; }
namespace acr_ed { struct _db_pack_curs; }
namespace acr_ed { struct _db_typefld_curs; }
namespace acr_ed { struct _db_cpptype_curs; }
namespace acr_ed { struct _db_cfmt_curs; }
namespace acr_ed { struct _db_nsdb_curs; }
namespace acr_ed { struct FCfmt; }
namespace acr_ed { struct FCpptype; }
namespace acr_ed { struct FCstr; }
namespace acr_ed { struct trace; }
namespace acr_ed { struct FDb; }
namespace acr_ed { struct FField; }
namespace acr_ed { struct FFprefix; }
namespace acr_ed { struct FListtype; }
namespace acr_ed { struct FNsdb; }
namespace acr_ed { struct FPack; }
namespace acr_ed { struct FSandbox; }
namespace acr_ed { struct FSsimfile; }
namespace acr_ed { struct FTargsrc; }
namespace acr_ed { struct FTypefld; }
namespace acr_ed { struct FieldId; }
namespace acr_ed { struct TableId; }
namespace acr_ed { extern struct acr_ed::FDb _db; }
namespace acr_ed { // gen:ns_print_struct

// --- acr_ed.FCfmt
// create: acr_ed.FDb.cfmt (Lary)
// access: acr_ed.FCtype.c_cfmt (Ptrary)
struct FCfmt { // acr_ed.FCfmt
    algo::Smallstr100   cfmt;       //
    algo::Smallstr50    printfmt;   //
    bool                read;       //   false
    bool                print;      //   false
    algo::Smallstr20    sep;        //
    bool                genop;      //   false
    algo::Comment       comment;    //
private:
    friend acr_ed::FCfmt&       cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCfmt*       cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfmt_RemoveAll() __attribute__((nothrow));
    friend void                 cfmt_RemoveLast() __attribute__((nothrow));
    FCfmt();
    ~FCfmt();
    FCfmt(const FCfmt&){ /*disallow copy constructor */}
    void operator =(const FCfmt&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cfmt_CopyOut(acr_ed::FCfmt &row, dmmeta::Cfmt &out) __attribute__((nothrow));
// Copy fields in to row
void                 cfmt_CopyIn(acr_ed::FCfmt &row, dmmeta::Cfmt &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(acr_ed::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     strfmt_Get(acr_ed::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FCfmt_Init(acr_ed::FCfmt& cfmt);
void                 FCfmt_Uninit(acr_ed::FCfmt& cfmt) __attribute__((nothrow));

// --- acr_ed.FCpptype
// create: acr_ed.FDb.cpptype (Lary)
// access: acr_ed.FCtype.c_cpptype (Ptr)
struct FCpptype { // acr_ed.FCpptype
    algo::Smallstr50   ctype;        //
    bool               ctor;         //   false  if true, generate non-default constructor from all fields
    bool               dtor;         //   true  generate non-default destructor
    bool               cheap_copy;   //   false  Pass by value whenever possible
private:
    friend acr_ed::FCpptype&    cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCpptype*    cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cpptype_RemoveAll() __attribute__((nothrow));
    friend void                 cpptype_RemoveLast() __attribute__((nothrow));
    FCpptype();
    ~FCpptype();
    FCpptype(const FCpptype&){ /*disallow copy constructor */}
    void operator =(const FCpptype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cpptype_CopyOut(acr_ed::FCpptype &row, dmmeta::Cpptype &out) __attribute__((nothrow));
// Copy fields in to row
void                 cpptype_CopyIn(acr_ed::FCpptype &row, dmmeta::Cpptype &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCpptype_Init(acr_ed::FCpptype& cpptype);
void                 FCpptype_Uninit(acr_ed::FCpptype& cpptype) __attribute__((nothrow));

// --- acr_ed.FCstr
// create: acr_ed.FDb.cstr (Lary)
// access: acr_ed.FCtype.c_cstr (Ptr)
struct FCstr { // acr_ed.FCstr
    algo::Smallstr50   ctype;      //
    bool               strequiv;   //   false  Use strptr instead of this type when possible
    algo::Comment      comment;    //
private:
    friend acr_ed::FCstr&       cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCstr*       cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstr_RemoveLast() __attribute__((nothrow));
    FCstr();
    ~FCstr();
    FCstr(const FCstr&){ /*disallow copy constructor */}
    void operator =(const FCstr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cstr_CopyOut(acr_ed::FCstr &row, dmmeta::Cstr &out) __attribute__((nothrow));
// Copy fields in to row
void                 cstr_CopyIn(acr_ed::FCstr &row, dmmeta::Cstr &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCstr_Init(acr_ed::FCstr& cstr);
void                 FCstr_Uninit(acr_ed::FCstr& cstr) __attribute__((nothrow));

// --- acr_ed.FCtype
// create: acr_ed.FDb.ctype (Lary)
// global access: ind_ctype (Thash)
// access: acr_ed.FField.p_ctype (Upptr)
// access: acr_ed.FField.p_arg (Upptr)
// access: acr_ed.FSsimfile.p_ctype (Upptr)
struct FCtype { // acr_ed.FCtype
    algo::Smallstr50     ctype;            // Identifier. must be ns.typename
    algo::Comment        comment;          //
    acr_ed::FField**     c_field_elems;    // array of pointers
    u32                  c_field_n;        // array of pointers
    u32                  c_field_max;      // capacity of allocated array
    acr_ed::FCstr*       c_cstr;           // optional pointer
    acr_ed::FNs*         p_ns;             // reference to parent row
    acr_ed::FSsimfile*   c_ssimfile;       // optional pointer
    acr_ed::FPack*       c_pack;           // optional pointer
    acr_ed::FTypefld*    c_typefld;        // optional pointer
    acr_ed::FCpptype*    c_cpptype;        // optional pointer
    acr_ed::FCfmt**      c_cfmt_elems;     // array of pointers
    u32                  c_cfmt_n;         // array of pointers
    u32                  c_cfmt_max;       // capacity of allocated array
    acr_ed::FCtype*      ind_ctype_next;   // hash next
private:
    friend acr_ed::FCtype&      ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCtype*      ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
    FCtype();
    ~FCtype();
    FCtype(const FCtype&){ /*disallow copy constructor */}
    void operator =(const FCtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ctype_CopyOut(acr_ed::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
void                 ctype_CopyIn(acr_ed::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_field_EmptyQ(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FField*      c_field_Find(acr_ed::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr_ed::FField*> c_field_Getary(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_field_Insert(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_field_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_field_N(const acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_field_Remove(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_field_RemoveAll(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_field_Reserve(acr_ed::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cstr_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cstr_Remove(acr_ed::FCtype& ctype, acr_ed::FCstr& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ssimfile_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ssimfile_Remove(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_pack_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FPack& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_pack_Remove(acr_ed::FCtype& ctype, acr_ed::FPack& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_typefld_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FTypefld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_typefld_Remove(acr_ed::FCtype& ctype, acr_ed::FTypefld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cpptype_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCpptype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cpptype_Remove(acr_ed::FCtype& ctype, acr_ed::FCpptype& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_cfmt_EmptyQ(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCfmt*       c_cfmt_Find(acr_ed::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr_ed::FCfmt*> c_cfmt_Getary(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_cfmt_Insert(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_cfmt_ScanInsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_cfmt_N(const acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_cfmt_Remove(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_cfmt_RemoveAll(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_cfmt_Reserve(acr_ed::FCtype& ctype, u32 n) __attribute__((nothrow));

void                 ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr_ed::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs);
// proceed to next item
void                 ctype_c_field_curs_Next(ctype_c_field_curs &curs);
// item access
acr_ed::FField&      ctype_c_field_curs_Access(ctype_c_field_curs &curs);
void                 ctype_c_cfmt_curs_Reset(ctype_c_cfmt_curs &curs, acr_ed::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_cfmt_curs_ValidQ(ctype_c_cfmt_curs &curs);
// proceed to next item
void                 ctype_c_cfmt_curs_Next(ctype_c_cfmt_curs &curs);
// item access
acr_ed::FCfmt&       ctype_c_cfmt_curs_Access(ctype_c_cfmt_curs &curs);
// Set all fields to initial values.
void                 FCtype_Init(acr_ed::FCtype& ctype);
void                 FCtype_Uninit(acr_ed::FCtype& ctype) __attribute__((nothrow));

// --- acr_ed.trace
#pragma pack(push,1)
struct trace { // acr_ed.trace
    trace();
};
#pragma pack(pop)

// print string representation of acr_ed::trace to string LHS, no header -- cprint:acr_ed.trace.String
void                 trace_Print(acr_ed::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- acr_ed.FDb
// create: acr_ed.FDb._db (Global)
struct FDb { // acr_ed.FDb
    acr_ed::FNs*          ns_lary[32];                  // level array
    i32                   ns_n;                         // number of elements in array
    acr_ed::FNs**         ind_ns_buckets_elems;         // pointer to bucket array
    i32                   ind_ns_buckets_n;             // number of elements in bucket array
    i32                   ind_ns_n;                     // number of elements in the hash table
    command::acr_ed       cmdline;                      //
    acr_ed::FField*       field_lary[32];               // level array
    i32                   field_n;                      // number of elements in array
    acr_ed::FField**      ind_field_buckets_elems;      // pointer to bucket array
    i32                   ind_field_buckets_n;          // number of elements in bucket array
    i32                   ind_field_n;                  // number of elements in the hash table
    acr_ed::FCtype*       ctype_lary[32];               // level array
    i32                   ctype_n;                      // number of elements in array
    algo::cstring         fcontents;                    // Optional file contents
    algo::cstring         script;                       // Script to execute
    algo::cstring         out_ssim;                     // Input for acr command
    acr_ed::FCtype**      ind_ctype_buckets_elems;      // pointer to bucket array
    i32                   ind_ctype_buckets_n;          // number of elements in bucket array
    i32                   ind_ctype_n;                  // number of elements in the hash table
    acr_ed::FSsimfile*    ssimfile_lary[32];            // level array
    i32                   ssimfile_n;                   // number of elements in array
    acr_ed::FSsimfile**   ind_ssimfile_buckets_elems;   // pointer to bucket array
    i32                   ind_ssimfile_buckets_n;       // number of elements in bucket array
    i32                   ind_ssimfile_n;               // number of elements in the hash table
    acr_ed::FCstr*        cstr_lary[32];                // level array
    i32                   cstr_n;                       // number of elements in array
    algo::cstring*        vis_elems;                    // pointer to elements
    u32                   vis_n;                        // number of elements in array
    u32                   vis_max;                      // max. capacity of array before realloc
    acr_ed::FListtype*    listtype_lary[32];            // level array
    i32                   listtype_n;                   // number of elements in array
    acr_ed::FListtype**   ind_listtype_buckets_elems;   // pointer to bucket array
    i32                   ind_listtype_buckets_n;       // number of elements in bucket array
    i32                   ind_listtype_n;               // number of elements in the hash table
    acr_ed::FFprefix*     fprefix_lary[32];             // level array
    i32                   fprefix_n;                    // number of elements in array
    acr_ed::FFprefix**    ind_fprefix_buckets_elems;    // pointer to bucket array
    i32                   ind_fprefix_buckets_n;        // number of elements in bucket array
    i32                   ind_fprefix_n;                // number of elements in the hash table
    acr_ed::FTarget*      target_lary[32];              // level array
    i32                   target_n;                     // number of elements in array
    acr_ed::FTarget**     ind_target_buckets_elems;     // pointer to bucket array
    i32                   ind_target_buckets_n;         // number of elements in bucket array
    i32                   ind_target_n;                 // number of elements in the hash table
    algo::Smallstr100     keyfld;                       //
    algo::Smallstr100     viafld;                       //
    bool                  need_amc;                     //   false
    acr_ed::FTargsrc*     targsrc_lary[32];             // level array
    i32                   targsrc_n;                    // number of elements in array
    algo::cstring         orig_dir;                     //
    algo::cstring         sandbox_dir;                  //
    algo::cstring         abt_path;                     //   "bin/abt"  path for executable
    command::abt          abt_cmd;                      // command line for child process
    algo::cstring         abt_fstdin;                   // redirect for stdin
    algo::cstring         abt_fstdout;                  // redirect for stdout
    algo::cstring         abt_fstderr;                  // redirect for stderr
    pid_t                 abt_pid;                      //   0  pid of running child process
    i32                   abt_timeout;                  //   0  optional timeout for child process
    i32                   abt_status;                   //   0  last exit status of child process
    acr_ed::FSandbox*     sandbox_lary[32];             // level array
    i32                   sandbox_n;                    // number of elements in array
    acr_ed::FPack*        pack_lary[32];                // level array
    i32                   pack_n;                       // number of elements in array
    acr_ed::FTypefld*     typefld_lary[32];             // level array
    i32                   typefld_n;                    // number of elements in array
    acr_ed::FCpptype*     cpptype_lary[32];             // level array
    i32                   cpptype_n;                    // number of elements in array
    acr_ed::FCfmt*        cfmt_lary[32];                // level array
    i32                   cfmt_n;                       // number of elements in array
    acr_ed::FNsdb*        nsdb_lary[32];                // level array
    i32                   nsdb_n;                       // number of elements in array
    acr_ed::FNsdb**       ind_nsdb_buckets_elems;       // pointer to bucket array
    i32                   ind_nsdb_buckets_n;           // number of elements in bucket array
    i32                   ind_nsdb_n;                   // number of elements in the hash table
    acr_ed::trace         trace;                        //
};

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FNs*         ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ns_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FNs*         ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FNs*         ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FNs&         ns_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ns_XrefMaybe(acr_ed::FNs &row);

// Return true if hash is empty
bool                 ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FNs*         ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FNs&         ind_ns_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FNs&         ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ns_InsertMaybe(acr_ed::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ns_Remove(acr_ed::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Calls Step function of dependencies
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FField&      field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FField*      field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FField*      field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 field_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FField*      field_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FField*      field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FField&      field_qFind(u32 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 field_XrefMaybe(acr_ed::FField &row);

// Return true if hash is empty
bool                 ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FField*      ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FField&      ind_field_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_field_InsertMaybe(acr_ed::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_field_Remove(acr_ed::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCtype&      ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCtype*      ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCtype*      ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ctype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCtype*      ctype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FCtype*      ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FCtype&      ctype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ctype_XrefMaybe(acr_ed::FCtype &row);

// Return true if hash is empty
bool                 ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FCtype*      ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FCtype&      ind_ctype_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ctype_InsertMaybe(acr_ed::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ctype_Remove(acr_ed::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FSsimfile*   ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FSsimfile*   ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FSsimfile*   ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FSsimfile&   ssimfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimfile_XrefMaybe(acr_ed::FSsimfile &row);

// Return true if hash is empty
bool                 ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FSsimfile*   ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FSsimfile&   ind_ssimfile_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimfile_InsertMaybe(acr_ed::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimfile_Remove(acr_ed::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCstr&       cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCstr*       cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCstr*       cstr_InsertMaybe(const dmmeta::Cstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cstr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCstr*       cstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FCstr*       cstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FCstr&       cstr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cstr_XrefMaybe(acr_ed::FCstr &row);

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       vis_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       vis_AllocAt(int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> vis_AllocN(int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 vis_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       vis_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> vis_Getary() __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       vis_Last() __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  vis_Max() __attribute__((nothrow));
// Return number of items in the array
i32                  vis_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 vis_Remove(u32 i) __attribute__((nothrow));
void                 vis_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 vis_RemoveLast() __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 vis_Reserve(int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 vis_AbsReserve(int n) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       vis_qFind(u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       vis_qLast() __attribute__((nothrow));
// Return row id of specified element
u64                  vis_rowid_Get(algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> vis_AllocNVal(int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FListtype&   listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FListtype*   listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FListtype*   listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 listtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FListtype*   listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FListtype*   listtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FListtype&   listtype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 listtype_XrefMaybe(acr_ed::FListtype &row);

// Return true if hash is empty
bool                 ind_listtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FListtype*   ind_listtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FListtype&   ind_listtype_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FListtype&   ind_listtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_listtype_InsertMaybe(acr_ed::FListtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_listtype_Remove(acr_ed::FListtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_listtype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FFprefix&    fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FFprefix*    fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FFprefix*    fprefix_InsertMaybe(const dmmeta::Fprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fprefix_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FFprefix*    fprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FFprefix*    fprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FFprefix&    fprefix_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 fprefix_XrefMaybe(acr_ed::FFprefix &row);

// Return true if hash is empty
bool                 ind_fprefix_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FFprefix*    ind_fprefix_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FFprefix&    ind_fprefix_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FFprefix&    ind_fprefix_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fprefix_InsertMaybe(acr_ed::FFprefix& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fprefix_Remove(acr_ed::FFprefix& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fprefix_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTarget&     target_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTarget*     target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTarget*     target_InsertMaybe(const dev::Target &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                target_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 target_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FTarget*     target_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FTarget*     target_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 target_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FTarget&     target_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 target_XrefMaybe(acr_ed::FTarget &row);

// Return true if hash is empty
bool                 ind_target_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FTarget*     ind_target_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FTarget&     ind_target_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FTarget&     ind_target_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_target_InsertMaybe(acr_ed::FTarget& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_target_Remove(acr_ed::FTarget& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_target_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTargsrc*    targsrc_InsertMaybe(const dev::Targsrc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                targsrc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 targsrc_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FTargsrc*    targsrc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FTargsrc*    targsrc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  targsrc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 targsrc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 targsrc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FTargsrc&    targsrc_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 targsrc_XrefMaybe(acr_ed::FTargsrc &row);

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  abt_Start() __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         abt_StartRead(algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 abt_Kill();
// Wait for subprocess to return
void                 abt_Wait() __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  abt_Exec() __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 abt_ExecX();
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int                  abt_Execv() __attribute__((nothrow));
algo::tempstr        abt_ToCmdline() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FSandbox&    sandbox_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FSandbox*    sandbox_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FSandbox*    sandbox_InsertMaybe(const dev::Sandbox &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                sandbox_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 sandbox_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FSandbox*    sandbox_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FSandbox*    sandbox_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  sandbox_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 sandbox_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 sandbox_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FSandbox&    sandbox_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 sandbox_XrefMaybe(acr_ed::FSandbox &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FPack&       pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FPack*       pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FPack*       pack_InsertMaybe(const dmmeta::Pack &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                pack_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 pack_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FPack*       pack_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FPack*       pack_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  pack_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 pack_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 pack_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FPack&       pack_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 pack_XrefMaybe(acr_ed::FPack &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTypefld&    typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTypefld*    typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTypefld*    typefld_InsertMaybe(const dmmeta::Typefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                typefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 typefld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FTypefld*    typefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FTypefld*    typefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  typefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 typefld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 typefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FTypefld&    typefld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 typefld_XrefMaybe(acr_ed::FTypefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCpptype&    cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCpptype*    cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCpptype*    cpptype_InsertMaybe(const dmmeta::Cpptype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cpptype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cpptype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCpptype*    cpptype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FCpptype*    cpptype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cpptype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cpptype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cpptype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FCpptype&    cpptype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cpptype_XrefMaybe(acr_ed::FCpptype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCfmt&       cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCfmt*       cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCfmt*       cfmt_InsertMaybe(const dmmeta::Cfmt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cfmt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cfmt_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCfmt*       cfmt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FCfmt*       cfmt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cfmt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cfmt_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cfmt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FCfmt&       cfmt_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cfmt_XrefMaybe(acr_ed::FCfmt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FNsdb&       nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FNsdb*       nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FNsdb*       nsdb_InsertMaybe(const dmmeta::Nsdb &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nsdb_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nsdb_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FNsdb*       nsdb_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FNsdb*       nsdb_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nsdb_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 nsdb_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 nsdb_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FNsdb&       nsdb_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 nsdb_XrefMaybe(acr_ed::FNsdb &row);

// Return true if hash is empty
bool                 ind_nsdb_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FNsdb*       ind_nsdb_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FNsdb&       ind_nsdb_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FNsdb&       ind_nsdb_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_nsdb_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_nsdb_InsertMaybe(acr_ed::FNsdb& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_nsdb_Remove(acr_ed::FNsdb& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_nsdb_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
void                 _db_ns_curs_Reset(_db_ns_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_ns_curs_ValidQ(_db_ns_curs &curs);
// proceed to next item
void                 _db_ns_curs_Next(_db_ns_curs &curs);
// item access
acr_ed::FNs&         _db_ns_curs_Access(_db_ns_curs &curs);
// cursor points to valid item
void                 _db_field_curs_Reset(_db_field_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_field_curs_ValidQ(_db_field_curs &curs);
// proceed to next item
void                 _db_field_curs_Next(_db_field_curs &curs);
// item access
acr_ed::FField&      _db_field_curs_Access(_db_field_curs &curs);
// cursor points to valid item
void                 _db_ctype_curs_Reset(_db_ctype_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_ctype_curs_ValidQ(_db_ctype_curs &curs);
// proceed to next item
void                 _db_ctype_curs_Next(_db_ctype_curs &curs);
// item access
acr_ed::FCtype&      _db_ctype_curs_Access(_db_ctype_curs &curs);
// cursor points to valid item
void                 _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs);
// proceed to next item
void                 _db_ssimfile_curs_Next(_db_ssimfile_curs &curs);
// item access
acr_ed::FSsimfile&   _db_ssimfile_curs_Access(_db_ssimfile_curs &curs);
// cursor points to valid item
void                 _db_cstr_curs_Reset(_db_cstr_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_cstr_curs_ValidQ(_db_cstr_curs &curs);
// proceed to next item
void                 _db_cstr_curs_Next(_db_cstr_curs &curs);
// item access
acr_ed::FCstr&       _db_cstr_curs_Access(_db_cstr_curs &curs);
// proceed to next item
void                 _db_vis_curs_Next(_db_vis_curs &curs);
void                 _db_vis_curs_Reset(_db_vis_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_vis_curs_ValidQ(_db_vis_curs &curs);
// item access
algo::cstring&       _db_vis_curs_Access(_db_vis_curs &curs);
// cursor points to valid item
void                 _db_listtype_curs_Reset(_db_listtype_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_listtype_curs_ValidQ(_db_listtype_curs &curs);
// proceed to next item
void                 _db_listtype_curs_Next(_db_listtype_curs &curs);
// item access
acr_ed::FListtype&   _db_listtype_curs_Access(_db_listtype_curs &curs);
// cursor points to valid item
void                 _db_fprefix_curs_Reset(_db_fprefix_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_fprefix_curs_ValidQ(_db_fprefix_curs &curs);
// proceed to next item
void                 _db_fprefix_curs_Next(_db_fprefix_curs &curs);
// item access
acr_ed::FFprefix&    _db_fprefix_curs_Access(_db_fprefix_curs &curs);
// cursor points to valid item
void                 _db_target_curs_Reset(_db_target_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_target_curs_ValidQ(_db_target_curs &curs);
// proceed to next item
void                 _db_target_curs_Next(_db_target_curs &curs);
// item access
acr_ed::FTarget&     _db_target_curs_Access(_db_target_curs &curs);
// cursor points to valid item
void                 _db_targsrc_curs_Reset(_db_targsrc_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_targsrc_curs_ValidQ(_db_targsrc_curs &curs);
// proceed to next item
void                 _db_targsrc_curs_Next(_db_targsrc_curs &curs);
// item access
acr_ed::FTargsrc&    _db_targsrc_curs_Access(_db_targsrc_curs &curs);
// cursor points to valid item
void                 _db_sandbox_curs_Reset(_db_sandbox_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_sandbox_curs_ValidQ(_db_sandbox_curs &curs);
// proceed to next item
void                 _db_sandbox_curs_Next(_db_sandbox_curs &curs);
// item access
acr_ed::FSandbox&    _db_sandbox_curs_Access(_db_sandbox_curs &curs);
// cursor points to valid item
void                 _db_pack_curs_Reset(_db_pack_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_pack_curs_ValidQ(_db_pack_curs &curs);
// proceed to next item
void                 _db_pack_curs_Next(_db_pack_curs &curs);
// item access
acr_ed::FPack&       _db_pack_curs_Access(_db_pack_curs &curs);
// cursor points to valid item
void                 _db_typefld_curs_Reset(_db_typefld_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_typefld_curs_ValidQ(_db_typefld_curs &curs);
// proceed to next item
void                 _db_typefld_curs_Next(_db_typefld_curs &curs);
// item access
acr_ed::FTypefld&    _db_typefld_curs_Access(_db_typefld_curs &curs);
// cursor points to valid item
void                 _db_cpptype_curs_Reset(_db_cpptype_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_cpptype_curs_ValidQ(_db_cpptype_curs &curs);
// proceed to next item
void                 _db_cpptype_curs_Next(_db_cpptype_curs &curs);
// item access
acr_ed::FCpptype&    _db_cpptype_curs_Access(_db_cpptype_curs &curs);
// cursor points to valid item
void                 _db_cfmt_curs_Reset(_db_cfmt_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_cfmt_curs_ValidQ(_db_cfmt_curs &curs);
// proceed to next item
void                 _db_cfmt_curs_Next(_db_cfmt_curs &curs);
// item access
acr_ed::FCfmt&       _db_cfmt_curs_Access(_db_cfmt_curs &curs);
// cursor points to valid item
void                 _db_nsdb_curs_Reset(_db_nsdb_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_nsdb_curs_ValidQ(_db_nsdb_curs &curs);
// proceed to next item
void                 _db_nsdb_curs_Next(_db_nsdb_curs &curs);
// item access
acr_ed::FNsdb&       _db_nsdb_curs_Access(_db_nsdb_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- acr_ed.FField
// create: acr_ed.FDb.field (Lary)
// global access: ind_field (Thash)
// access: acr_ed.FCtype.c_field (Ptrary)
struct FField { // acr_ed.FField
    acr_ed::FField*     ind_field_next;         // hash next
    algo::Smallstr100   field;                  //
    algo::Smallstr50    arg;                    // type of field
    algo::Smallstr50    reftype;                //   "Val"
    dmmeta::CppExpr     dflt;                   // default value (c++ expression)
    algo::Comment       comment;                //
    acr_ed::FCtype*     p_ctype;                // reference to parent row
    u32                 rowid;                  //   0
    acr_ed::FCtype*     p_arg;                  // reference to parent row
    acr_ed::FNs*        p_ns;                   // reference to parent row
    bool                ctype_c_field_in_ary;   //   false  membership flag
private:
    friend acr_ed::FField&      field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FField*      field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
    FField();
    ~FField();
    FField(const FField&){ /*disallow copy constructor */}
    void operator =(const FField&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 field_CopyOut(acr_ed::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
void                 field_CopyIn(acr_ed::FField &row, dmmeta::Field &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FField_Init(acr_ed::FField& field);
void                 FField_Uninit(acr_ed::FField& field) __attribute__((nothrow));

// --- acr_ed.FFprefix
// create: acr_ed.FDb.fprefix (Lary)
// global access: ind_fprefix (Thash)
struct FFprefix { // acr_ed.FFprefix
    acr_ed::FFprefix*   ind_fprefix_next;   // hash next
    algo::Smallstr5     fprefix;            //
    algo::Smallstr50    reftype;            //
    algo::Comment       comment;            //
private:
    friend acr_ed::FFprefix&    fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FFprefix*    fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fprefix_RemoveLast() __attribute__((nothrow));
    FFprefix();
    ~FFprefix();
    FFprefix(const FFprefix&){ /*disallow copy constructor */}
    void operator =(const FFprefix&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fprefix_CopyOut(acr_ed::FFprefix &row, dmmeta::Fprefix &out) __attribute__((nothrow));
// Copy fields in to row
void                 fprefix_CopyIn(acr_ed::FFprefix &row, dmmeta::Fprefix &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFprefix_Init(acr_ed::FFprefix& fprefix);
void                 FFprefix_Uninit(acr_ed::FFprefix& fprefix) __attribute__((nothrow));

// --- acr_ed.FListtype
// create: acr_ed.FDb.listtype (Lary)
// global access: ind_listtype (Thash)
struct FListtype { // acr_ed.FListtype
    acr_ed::FListtype*   ind_listtype_next;   // hash next
    algo::Smallstr5      listtype;            //
    bool                 circular;            //   false  Circular list
    bool                 haveprev;            //   false  Previous link
    bool                 instail;             //   false  Queue
    algo::Comment        comment;             //
private:
    friend acr_ed::FListtype&   listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FListtype*   listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 listtype_RemoveLast() __attribute__((nothrow));
    FListtype();
    ~FListtype();
    FListtype(const FListtype&){ /*disallow copy constructor */}
    void operator =(const FListtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 listtype_CopyOut(acr_ed::FListtype &row, dmmeta::Listtype &out) __attribute__((nothrow));
// Copy fields in to row
void                 listtype_CopyIn(acr_ed::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FListtype_Init(acr_ed::FListtype& listtype);
void                 FListtype_Uninit(acr_ed::FListtype& listtype) __attribute__((nothrow));

// --- acr_ed.FNs
// create: acr_ed.FDb.ns (Lary)
// global access: ind_ns (Thash)
// access: acr_ed.FCtype.p_ns (Upptr)
// access: acr_ed.FField.p_ns (Upptr)
struct FNs { // acr_ed.FNs
    acr_ed::FNs*       ind_ns_next;   // hash next
    algo::Smallstr16   ns;            // Namespace name (primary key)
    algo::Smallstr50   nstype;        //
    algo::Comment      comment;       //
private:
    friend acr_ed::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
    FNs();
    ~FNs();
    FNs(const FNs&){ /*disallow copy constructor */}
    void operator =(const FNs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ns_CopyOut(acr_ed::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
void                 ns_CopyIn(acr_ed::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNs_Init(acr_ed::FNs& ns);
void                 FNs_Uninit(acr_ed::FNs& ns) __attribute__((nothrow));

// --- acr_ed.FNsdb
// create: acr_ed.FDb.nsdb (Lary)
// global access: ind_nsdb (Thash)
struct FNsdb { // acr_ed.FNsdb
    acr_ed::FNsdb*     ind_nsdb_next;   // hash next
    algo::Smallstr16   ns;              //
    algo::Comment      comment;         //
private:
    friend acr_ed::FNsdb&       nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FNsdb*       nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsdb_RemoveAll() __attribute__((nothrow));
    friend void                 nsdb_RemoveLast() __attribute__((nothrow));
    FNsdb();
    ~FNsdb();
    FNsdb(const FNsdb&){ /*disallow copy constructor */}
    void operator =(const FNsdb&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 nsdb_CopyOut(acr_ed::FNsdb &row, dmmeta::Nsdb &out) __attribute__((nothrow));
// Copy fields in to row
void                 nsdb_CopyIn(acr_ed::FNsdb &row, dmmeta::Nsdb &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNsdb_Init(acr_ed::FNsdb& nsdb);
void                 FNsdb_Uninit(acr_ed::FNsdb& nsdb) __attribute__((nothrow));

// --- acr_ed.FPack
// create: acr_ed.FDb.pack (Lary)
// access: acr_ed.FCtype.c_pack (Ptr)
struct FPack { // acr_ed.FPack
    algo::Smallstr50   ctype;     // Target ctype
    algo::Comment      comment;   //
private:
    friend acr_ed::FPack&       pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FPack*       pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pack_RemoveAll() __attribute__((nothrow));
    friend void                 pack_RemoveLast() __attribute__((nothrow));
    FPack();
    ~FPack();
    FPack(const FPack&){ /*disallow copy constructor */}
    void operator =(const FPack&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 pack_CopyOut(acr_ed::FPack &row, dmmeta::Pack &out) __attribute__((nothrow));
// Copy fields in to row
void                 pack_CopyIn(acr_ed::FPack &row, dmmeta::Pack &in) __attribute__((nothrow));

void                 FPack_Uninit(acr_ed::FPack& pack) __attribute__((nothrow));

// --- acr_ed.FSandbox
// create: acr_ed.FDb.sandbox (Lary)
struct FSandbox { // acr_ed.FSandbox
    algo::Smallstr50   sandbox;   //
    algo::Comment      comment;   //
private:
    friend acr_ed::FSandbox&    sandbox_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FSandbox*    sandbox_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 sandbox_RemoveAll() __attribute__((nothrow));
    friend void                 sandbox_RemoveLast() __attribute__((nothrow));
    FSandbox();
};

// Copy fields out of row
void                 sandbox_CopyOut(acr_ed::FSandbox &row, dev::Sandbox &out) __attribute__((nothrow));
// Copy fields in to row
void                 sandbox_CopyIn(acr_ed::FSandbox &row, dev::Sandbox &in) __attribute__((nothrow));


// --- acr_ed.FSsimfile
// create: acr_ed.FDb.ssimfile (Lary)
// global access: ind_ssimfile (Thash)
// access: acr_ed.FCtype.c_ssimfile (Ptr)
struct FSsimfile { // acr_ed.FSsimfile
    acr_ed::FSsimfile*   ind_ssimfile_next;   // hash next
    algo::Smallstr50     ssimfile;            //
    algo::Smallstr50     ctype;               //
    acr_ed::FCtype*      p_ctype;             // reference to parent row
private:
    friend acr_ed::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
    FSsimfile();
    ~FSsimfile();
    FSsimfile(const FSsimfile&){ /*disallow copy constructor */}
    void operator =(const FSsimfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimfile_CopyOut(acr_ed::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimfile_CopyIn(acr_ed::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

algo::Smallstr16     ssimns_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FSsimfile_Init(acr_ed::FSsimfile& ssimfile);
void                 FSsimfile_Uninit(acr_ed::FSsimfile& ssimfile) __attribute__((nothrow));

// --- acr_ed.FTarget
// create: acr_ed.FDb.target (Lary)
// global access: ind_target (Thash)
// access: acr_ed.FTargsrc.p_target (Upptr)
struct FTarget { // acr_ed.FTarget
    acr_ed::FTarget*   ind_target_next;   // hash next
    algo::Smallstr16   target;            //
    algo::Smallstr50   license;           //
    algo::Smallstr50   compat;            //   "Linux-%.%-%"
    u32                score;             //   0  For guessing target from source file
private:
    friend acr_ed::FTarget&     target_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTarget*     target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 target_RemoveLast() __attribute__((nothrow));
    FTarget();
    ~FTarget();
    FTarget(const FTarget&){ /*disallow copy constructor */}
    void operator =(const FTarget&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 target_CopyOut(acr_ed::FTarget &row, dev::Target &out) __attribute__((nothrow));
// Copy fields in to row
void                 target_CopyIn(acr_ed::FTarget &row, dev::Target &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTarget_Init(acr_ed::FTarget& target);
void                 FTarget_Uninit(acr_ed::FTarget& target) __attribute__((nothrow));

// --- acr_ed.FTargsrc
// create: acr_ed.FDb.targsrc (Lary)
struct FTargsrc { // acr_ed.FTargsrc
    algo::Smallstr100   targsrc;    //
    algo::Comment       comment;    //
    acr_ed::FTarget*    p_target;   // reference to parent row
private:
    friend acr_ed::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targsrc_RemoveAll() __attribute__((nothrow));
    friend void                 targsrc_RemoveLast() __attribute__((nothrow));
    FTargsrc();
    // x-reference on acr_ed.FTargsrc.p_target prevents copy
    FTargsrc(const FTargsrc&){ /*disallow copy constructor */}
    void operator =(const FTargsrc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 targsrc_CopyOut(acr_ed::FTargsrc &row, dev::Targsrc &out) __attribute__((nothrow));
// Copy fields in to row
void                 targsrc_CopyIn(acr_ed::FTargsrc &row, dev::Targsrc &in) __attribute__((nothrow));

algo::Smallstr16     target_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr200    src_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr10     ext_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FTargsrc_Init(acr_ed::FTargsrc& targsrc);

// --- acr_ed.FTypefld
// create: acr_ed.FDb.typefld (Lary)
// access: acr_ed.FCtype.c_typefld (Ptr)
struct FTypefld { // acr_ed.FTypefld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
private:
    friend acr_ed::FTypefld&    typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTypefld*    typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typefld_RemoveAll() __attribute__((nothrow));
    friend void                 typefld_RemoveLast() __attribute__((nothrow));
    FTypefld();
    ~FTypefld();
    FTypefld(const FTypefld&){ /*disallow copy constructor */}
    void operator =(const FTypefld&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 typefld_CopyOut(acr_ed::FTypefld &row, dmmeta::Typefld &out) __attribute__((nothrow));
// Copy fields in to row
void                 typefld_CopyIn(acr_ed::FTypefld &row, dmmeta::Typefld &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(acr_ed::FTypefld& typefld) __attribute__((__warn_unused_result__, nothrow));

void                 FTypefld_Uninit(acr_ed::FTypefld& typefld) __attribute__((nothrow));

// --- acr_ed.FieldId
#pragma pack(push,1)
struct FieldId { // acr_ed.FieldId: Field read helper
    i32   value;   //   -1
    inline operator acr_ed_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(acr_ed_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
acr_ed_FieldIdEnum   value_GetEnum(const acr_ed::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr_ed::FieldId& parent, acr_ed_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr_ed::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr_ed::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr_ed::FieldId& parent, algo::strptr rhs, acr_ed_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr_ed::FieldId from an ascii string.
// The format of the string is the format of the acr_ed::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(acr_ed::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(acr_ed::FieldId& parent);
// print string representation of acr_ed::FieldId to string LHS, no header -- cprint:acr_ed.FieldId.String
void                 FieldId_Print(acr_ed::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- acr_ed.TableId
struct TableId { // acr_ed.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator acr_ed_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(acr_ed_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
acr_ed_TableIdEnum   value_GetEnum(const acr_ed::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr_ed::TableId& parent, acr_ed_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr_ed::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr_ed::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr_ed::TableId& parent, algo::strptr rhs, acr_ed_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr_ed::TableId from an ascii string.
// The format of the string is the format of the acr_ed::TableId's only field
bool                 TableId_ReadStrptrMaybe(acr_ed::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(acr_ed::TableId& parent);
// print string representation of acr_ed::TableId to string LHS, no header -- cprint:acr_ed.TableId.String
void                 TableId_Print(acr_ed::TableId & row, algo::cstring &str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace acr_ed { // gen:ns_curstext

struct ctype_c_field_curs {// fcurs:acr_ed.FCtype.c_field/curs
    typedef acr_ed::FField ChildType;
    acr_ed::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_cfmt_curs {// fcurs:acr_ed.FCtype.c_cfmt/curs
    typedef acr_ed::FCfmt ChildType;
    acr_ed::FCfmt** elems;
    u32 n_elems;
    u32 index;
    ctype_c_cfmt_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_ns_curs {// cursor
    typedef acr_ed::FNs ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef acr_ed::FField ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_ctype_curs {// cursor
    typedef acr_ed::FCtype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef acr_ed::FSsimfile ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_cstr_curs {// cursor
    typedef acr_ed::FCstr ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cstr_curs(){ parent=NULL; index=0; }
};


struct _db_vis_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    _db_vis_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_listtype_curs {// cursor
    typedef acr_ed::FListtype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_listtype_curs(){ parent=NULL; index=0; }
};


struct _db_fprefix_curs {// cursor
    typedef acr_ed::FFprefix ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_fprefix_curs(){ parent=NULL; index=0; }
};


struct _db_target_curs {// cursor
    typedef acr_ed::FTarget ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_target_curs(){ parent=NULL; index=0; }
};


struct _db_targsrc_curs {// cursor
    typedef acr_ed::FTargsrc ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_targsrc_curs(){ parent=NULL; index=0; }
};


struct _db_sandbox_curs {// cursor
    typedef acr_ed::FSandbox ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_sandbox_curs(){ parent=NULL; index=0; }
};


struct _db_pack_curs {// cursor
    typedef acr_ed::FPack ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_pack_curs(){ parent=NULL; index=0; }
};


struct _db_typefld_curs {// cursor
    typedef acr_ed::FTypefld ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_typefld_curs(){ parent=NULL; index=0; }
};


struct _db_cpptype_curs {// cursor
    typedef acr_ed::FCpptype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cpptype_curs(){ parent=NULL; index=0; }
};


struct _db_cfmt_curs {// cursor
    typedef acr_ed::FCfmt ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cfmt_curs(){ parent=NULL; index=0; }
};


struct _db_nsdb_curs {// cursor
    typedef acr_ed::FNsdb ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_nsdb_curs(){ parent=NULL; index=0; }
};

} // gen:ns_curstext
namespace acr_ed { // gen:ns_func
} // gen:ns_func
int                  main(int argc, char **argv);
#if defined(WIN32)
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::trace &row);// cfmt:acr_ed.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::FieldId &row);// cfmt:acr_ed.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::TableId &row);// cfmt:acr_ed.TableId.String
}
