//
// include/gen/acr_ed_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/dmmeta_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/dev_gen.h"
//#pragma endinclude

// --- acr_ed_FieldIdEnum

enum acr_ed_FieldIdEnum {        // acr_ed.FieldId.value
     acr_ed_FieldId_value   = 0
};

enum { acr_ed_FieldIdEnum_N = 1 };


// --- acr_ed_TableIdEnum

enum acr_ed_TableIdEnum {                   // acr_ed.TableId.value
     acr_ed_TableId_dmmeta_Cstr       = 0   // dmmeta.Cstr -> acr_ed.FCstr
    ,acr_ed_TableId_dmmeta_cstr       = 0   // dmmeta.cstr -> acr_ed.FCstr
    ,acr_ed_TableId_dmmeta_Ctype      = 1   // dmmeta.Ctype -> acr_ed.FCtype
    ,acr_ed_TableId_dmmeta_ctype      = 1   // dmmeta.ctype -> acr_ed.FCtype
    ,acr_ed_TableId_dmmeta_Field      = 2   // dmmeta.Field -> acr_ed.FField
    ,acr_ed_TableId_dmmeta_field      = 2   // dmmeta.field -> acr_ed.FField
    ,acr_ed_TableId_dmmeta_Fprefix    = 3   // dmmeta.Fprefix -> acr_ed.FFprefix
    ,acr_ed_TableId_dmmeta_fprefix    = 3   // dmmeta.fprefix -> acr_ed.FFprefix
    ,acr_ed_TableId_dmmeta_Listtype   = 4   // dmmeta.Listtype -> acr_ed.FListtype
    ,acr_ed_TableId_dmmeta_listtype   = 4   // dmmeta.listtype -> acr_ed.FListtype
    ,acr_ed_TableId_dmmeta_Ns         = 5   // dmmeta.Ns -> acr_ed.FNs
    ,acr_ed_TableId_dmmeta_ns         = 5   // dmmeta.ns -> acr_ed.FNs
    ,acr_ed_TableId_dmmeta_Ssimfile   = 6   // dmmeta.Ssimfile -> acr_ed.FSsimfile
    ,acr_ed_TableId_dmmeta_ssimfile   = 6   // dmmeta.ssimfile -> acr_ed.FSsimfile
    ,acr_ed_TableId_dev_Target        = 7   // dev.Target -> acr_ed.FTarget
    ,acr_ed_TableId_dev_target        = 7   // dev.target -> acr_ed.FTarget
    ,acr_ed_TableId_dev_Targsrc       = 8   // dev.Targsrc -> acr_ed.FTargsrc
    ,acr_ed_TableId_dev_targsrc       = 8   // dev.targsrc -> acr_ed.FTargsrc
};

enum { acr_ed_TableIdEnum_N = 18 };

namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace acr_ed { struct FNs; }
namespace dmmeta { struct Field; }
namespace acr_ed { struct FCtype; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Ssimfile; }
namespace dev { struct Target; }
namespace dev { struct Targsrc; }
namespace acr_ed { struct FTarget; }
namespace acr_ed { struct FCstr; }
namespace acr_ed { struct trace; }
namespace acr_ed { struct FDb; }
namespace acr_ed { struct FField; }
namespace acr_ed { struct FFprefix; }
namespace acr_ed { struct FListtype; }
namespace acr_ed { struct FSsimfile; }
namespace acr_ed { struct FTargsrc; }
namespace acr_ed { struct FieldId; }
namespace acr_ed { struct TableId; }
namespace acr_ed { struct ctype_c_field_curs; }
namespace acr_ed { struct _db_ns_curs; }
namespace acr_ed { struct _db_ind_ns_curs; }
namespace acr_ed { struct _db_field_curs; }
namespace acr_ed { struct _db_ind_field_curs; }
namespace acr_ed { struct _db_ctype_curs; }
namespace acr_ed { struct _db_ind_ctype_curs; }
namespace acr_ed { struct _db_ssimfile_curs; }
namespace acr_ed { struct _db_ind_ssimfile_curs; }
namespace acr_ed { struct _db_cstr_curs; }
namespace acr_ed { struct _db_vis_curs; }
namespace acr_ed { struct _db_listtype_curs; }
namespace acr_ed { struct _db_ind_listtype_curs; }
namespace acr_ed { struct _db_fprefix_curs; }
namespace acr_ed { struct _db_ind_fprefix_curs; }
namespace acr_ed { struct _db_target_curs; }
namespace acr_ed { struct _db_ind_target_curs; }
namespace acr_ed { struct _db_targsrc_curs; }
namespace acr_ed {
}//pkey typedefs
namespace acr_ed {
extern const char *acr_ed_help;
extern const char *acr_ed_syntax;
extern FDb _db;

// --- acr_ed.FCstr
// create: acr_ed.FDb.cstr (Lary)
// access: acr_ed.FCtype.c_cstr (Ptr)
struct FCstr { // acr_ed.FCstr
    algo::Smallstr50   ctype;      //
    bool               strequiv;   //   false  Use strptr instead of this type when possible
    algo::Comment      comment;    //
private:
    friend acr_ed::FCstr&       cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCstr*       cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstr_RemoveLast() __attribute__((nothrow));
    FCstr();
    ~FCstr();
    FCstr(const FCstr&){ /*disallow copy constructor */}
    void operator =(const FCstr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cstr_CopyOut(acr_ed::FCstr &row, dmmeta::Cstr &out) __attribute__((nothrow));
// Copy fields in to row
void                 cstr_CopyIn(acr_ed::FCstr &row, dmmeta::Cstr &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCstr_Init(acr_ed::FCstr& cstr);
void                 FCstr_Uninit(acr_ed::FCstr& cstr) __attribute__((nothrow));

// --- acr_ed.FCtype
// create: acr_ed.FDb.ctype (Lary)
// global access: ind_ctype (Thash)
// access: acr_ed.FField.p_ctype (Upptr)
// access: acr_ed.FField.p_arg (Upptr)
// access: acr_ed.FSsimfile.p_ctype (Upptr)
struct FCtype { // acr_ed.FCtype
    algo::Smallstr50   ctype;            // Identifier. must be ns.typename
    algo::Comment      comment;          //
    acr_ed::FField**   c_field_elems;    // array of pointers
    u32                c_field_n;        // array of pointers
    u32                c_field_max;      // capacity of allocated array
    acr_ed::FCstr*     c_cstr;           // optional pointer
    acr_ed::FNs*       p_ns;             // reference to parent row
    acr_ed::FCtype*    ind_ctype_next;   // hash next
private:
    friend acr_ed::FCtype&      ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCtype*      ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
    FCtype();
    ~FCtype();
    FCtype(const FCtype&){ /*disallow copy constructor */}
    void operator =(const FCtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ctype_CopyOut(acr_ed::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
void                 ctype_CopyIn(acr_ed::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_field_EmptyQ(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FField*      c_field_Find(acr_ed::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr_ed::FField*> c_field_Getary(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_field_Insert(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_field_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_field_N(const acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_field_Remove(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_field_RemoveAll(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_field_Reserve(acr_ed::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cstr_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cstr_Remove(acr_ed::FCtype& ctype, acr_ed::FCstr& row) __attribute__((nothrow));

void                 ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr_ed::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs);
// proceed to next item
void                 ctype_c_field_curs_Next(ctype_c_field_curs &curs);
// item access
acr_ed::FField&      ctype_c_field_curs_Access(ctype_c_field_curs &curs);
// Set all fields to initial values.
void                 FCtype_Init(acr_ed::FCtype& ctype);
void                 FCtype_Uninit(acr_ed::FCtype& ctype) __attribute__((nothrow));

// --- acr_ed.trace
#pragma pack(push,1)
struct trace { // acr_ed.trace
    trace();
};
#pragma pack(pop)

// print string representation of acr_ed::trace to string LHS, no header -- cprint:acr_ed.trace.String
void                 trace_Print(acr_ed::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- acr_ed.FDb
// create: acr_ed.FDb._db (Global)
struct FDb { // acr_ed.FDb
    acr_ed::FNs*          ns_lary[32];                  // level array
    i32                   ns_n;                         // number of elements in array
    acr_ed::FNs**         ind_ns_buckets_elems;         // pointer to bucket array
    i32                   ind_ns_buckets_n;             // number of elements in bucket array
    i32                   ind_ns_n;                     // number of elements in the hash table
    command::acr_ed       cmdline;                      //
    acr_ed::FField*       field_lary[32];               // level array
    i32                   field_n;                      // number of elements in array
    acr_ed::FField**      ind_field_buckets_elems;      // pointer to bucket array
    i32                   ind_field_buckets_n;          // number of elements in bucket array
    i32                   ind_field_n;                  // number of elements in the hash table
    acr_ed::FCtype*       ctype_lary[32];               // level array
    i32                   ctype_n;                      // number of elements in array
    algo::cstring         fcontents;                    // Optional file contents
    algo::cstring         script;                       // Script to execute
    algo::cstring         out_ssim;                     // Input for acr command
    acr_ed::FCtype**      ind_ctype_buckets_elems;      // pointer to bucket array
    i32                   ind_ctype_buckets_n;          // number of elements in bucket array
    i32                   ind_ctype_n;                  // number of elements in the hash table
    acr_ed::FSsimfile*    ssimfile_lary[32];            // level array
    i32                   ssimfile_n;                   // number of elements in array
    acr_ed::FSsimfile**   ind_ssimfile_buckets_elems;   // pointer to bucket array
    i32                   ind_ssimfile_buckets_n;       // number of elements in bucket array
    i32                   ind_ssimfile_n;               // number of elements in the hash table
    acr_ed::FCstr*        cstr_lary[32];                // level array
    i32                   cstr_n;                       // number of elements in array
    algo::cstring*        vis_elems;                    // pointer to elements
    u32                   vis_n;                        // number of elements in array
    u32                   vis_max;                      // max. capacity of array before realloc
    acr_ed::FListtype*    listtype_lary[32];            // level array
    i32                   listtype_n;                   // number of elements in array
    acr_ed::FListtype**   ind_listtype_buckets_elems;   // pointer to bucket array
    i32                   ind_listtype_buckets_n;       // number of elements in bucket array
    i32                   ind_listtype_n;               // number of elements in the hash table
    acr_ed::FFprefix*     fprefix_lary[32];             // level array
    i32                   fprefix_n;                    // number of elements in array
    acr_ed::FFprefix**    ind_fprefix_buckets_elems;    // pointer to bucket array
    i32                   ind_fprefix_buckets_n;        // number of elements in bucket array
    i32                   ind_fprefix_n;                // number of elements in the hash table
    acr_ed::FTarget*      target_lary[32];              // level array
    i32                   target_n;                     // number of elements in array
    acr_ed::FTarget**     ind_target_buckets_elems;     // pointer to bucket array
    i32                   ind_target_buckets_n;         // number of elements in bucket array
    i32                   ind_target_n;                 // number of elements in the hash table
    algo::Smallstr100     keyfld;                       //
    algo::Smallstr100     viafld;                       //
    bool                  need_amc;                     //   false
    acr_ed::FTargsrc*     targsrc_lary[32];             // level array
    i32                   targsrc_n;                    // number of elements in array
    algo::cstring         orig_dir;                     //
    algo::cstring         sandbox_dir;                  //
    algo::cstring         abt_path;                     //   "bin/abt"  path for executable
    command::abt          abt_cmd;                      // command line for child process
    algo::cstring         abt_stdin;                    // redirect for stdin
    algo::cstring         abt_stdout;                   // redirect for stdout
    algo::cstring         abt_stderr;                   // redirect for stderr
    pid_t                 abt_pid;                      //   0  pid of running child process
    i32                   abt_timeout;                  //   0  optional timeout for child process
    i32                   abt_status;                   //   0  last exit status of child process
    acr_ed::trace         trace;                        //
};

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FNs*         ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ns_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FNs*         ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FNs*         ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FNs&         ns_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ns_XrefMaybe(acr_ed::FNs &row);

// Return true if hash is empty
bool                 ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FNs*         ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FNs&         ind_ns_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FNs&         ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ns_InsertMaybe(acr_ed::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ns_Remove(acr_ed::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FField&      field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FField*      field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FField*      field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 field_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FField*      field_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FField*      field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FField&      field_qFind(u32 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 field_XrefMaybe(acr_ed::FField &row);

// Return true if hash is empty
bool                 ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FField*      ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FField&      ind_field_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_field_InsertMaybe(acr_ed::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_field_Remove(acr_ed::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCtype&      ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCtype*      ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCtype*      ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ctype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCtype*      ctype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FCtype*      ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FCtype&      ctype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ctype_XrefMaybe(acr_ed::FCtype &row);

// Return true if hash is empty
bool                 ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FCtype*      ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FCtype&      ind_ctype_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ctype_InsertMaybe(acr_ed::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ctype_Remove(acr_ed::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FSsimfile*   ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FSsimfile*   ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FSsimfile*   ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FSsimfile&   ssimfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ssimfile_XrefMaybe(acr_ed::FSsimfile &row);

// Return true if hash is empty
bool                 ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FSsimfile*   ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FSsimfile&   ind_ssimfile_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimfile_InsertMaybe(acr_ed::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimfile_Remove(acr_ed::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FCstr&       cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FCstr*       cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FCstr*       cstr_InsertMaybe(const dmmeta::Cstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cstr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FCstr*       cstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FCstr*       cstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FCstr&       cstr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cstr_XrefMaybe(acr_ed::FCstr &row);

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       vis_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       vis_AllocAt(int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> vis_AllocN(int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 vis_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       vis_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> vis_Getary() __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       vis_Last() __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  vis_Max() __attribute__((nothrow));
// Return number of items in the array
i32                  vis_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 vis_Remove(u32 i) __attribute__((nothrow));
void                 vis_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 vis_RemoveLast() __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 vis_Reserve(int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 vis_AbsReserve(int n) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       vis_qFind(u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       vis_qLast() __attribute__((nothrow));
// Return row id of specified element
u64                  vis_rowid_Get(algo::cstring &elem) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FListtype&   listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FListtype*   listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FListtype*   listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 listtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FListtype*   listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FListtype*   listtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FListtype&   listtype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 listtype_XrefMaybe(acr_ed::FListtype &row);

// Return true if hash is empty
bool                 ind_listtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FListtype*   ind_listtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FListtype&   ind_listtype_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FListtype&   ind_listtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_listtype_InsertMaybe(acr_ed::FListtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_listtype_Remove(acr_ed::FListtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_listtype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FFprefix&    fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FFprefix*    fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FFprefix*    fprefix_InsertMaybe(const dmmeta::Fprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fprefix_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FFprefix*    fprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FFprefix*    fprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FFprefix&    fprefix_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fprefix_XrefMaybe(acr_ed::FFprefix &row);

// Return true if hash is empty
bool                 ind_fprefix_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FFprefix*    ind_fprefix_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FFprefix&    ind_fprefix_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FFprefix&    ind_fprefix_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fprefix_InsertMaybe(acr_ed::FFprefix& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fprefix_Remove(acr_ed::FFprefix& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fprefix_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTarget&     target_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTarget*     target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTarget*     target_InsertMaybe(const dev::Target &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                target_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 target_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FTarget*     target_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FTarget*     target_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 target_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FTarget&     target_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 target_XrefMaybe(acr_ed::FTarget &row);

// Return true if hash is empty
bool                 ind_target_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr_ed::FTarget*     ind_target_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
acr_ed::FTarget&     ind_target_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
acr_ed::FTarget&     ind_target_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_target_InsertMaybe(acr_ed::FTarget& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_target_Remove(acr_ed::FTarget& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_target_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr_ed::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr_ed::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr_ed::FTargsrc*    targsrc_InsertMaybe(const dev::Targsrc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                targsrc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 targsrc_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr_ed::FTargsrc*    targsrc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr_ed::FTargsrc*    targsrc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  targsrc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 targsrc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 targsrc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr_ed::FTargsrc&    targsrc_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 targsrc_XrefMaybe(acr_ed::FTargsrc &row);

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  abt_Start() __attribute__((nothrow));
// Kill subprocess and wait
void                 abt_Kill();
// Wait for subprocess to return
void                 abt_Wait() __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  abt_Exec() __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 abt_ExecX();
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int                  abt_Execv() __attribute__((nothrow));
algo::tempstr        abt_ToCmdline() __attribute__((nothrow));

// cursor points to valid item
void                 _db_ns_curs_Reset(_db_ns_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_ns_curs_ValidQ(_db_ns_curs &curs);
// proceed to next item
void                 _db_ns_curs_Next(_db_ns_curs &curs);
// item access
acr_ed::FNs&         _db_ns_curs_Access(_db_ns_curs &curs);
// cursor points to valid item
void                 _db_field_curs_Reset(_db_field_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_field_curs_ValidQ(_db_field_curs &curs);
// proceed to next item
void                 _db_field_curs_Next(_db_field_curs &curs);
// item access
acr_ed::FField&      _db_field_curs_Access(_db_field_curs &curs);
// cursor points to valid item
void                 _db_ctype_curs_Reset(_db_ctype_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_ctype_curs_ValidQ(_db_ctype_curs &curs);
// proceed to next item
void                 _db_ctype_curs_Next(_db_ctype_curs &curs);
// item access
acr_ed::FCtype&      _db_ctype_curs_Access(_db_ctype_curs &curs);
// cursor points to valid item
void                 _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs);
// proceed to next item
void                 _db_ssimfile_curs_Next(_db_ssimfile_curs &curs);
// item access
acr_ed::FSsimfile&   _db_ssimfile_curs_Access(_db_ssimfile_curs &curs);
// cursor points to valid item
void                 _db_cstr_curs_Reset(_db_cstr_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_cstr_curs_ValidQ(_db_cstr_curs &curs);
// proceed to next item
void                 _db_cstr_curs_Next(_db_cstr_curs &curs);
// item access
acr_ed::FCstr&       _db_cstr_curs_Access(_db_cstr_curs &curs);
// proceed to next item
void                 _db_vis_curs_Next(_db_vis_curs &curs);
void                 _db_vis_curs_Reset(_db_vis_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_vis_curs_ValidQ(_db_vis_curs &curs);
// item access
algo::cstring&       _db_vis_curs_Access(_db_vis_curs &curs);
// cursor points to valid item
void                 _db_listtype_curs_Reset(_db_listtype_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_listtype_curs_ValidQ(_db_listtype_curs &curs);
// proceed to next item
void                 _db_listtype_curs_Next(_db_listtype_curs &curs);
// item access
acr_ed::FListtype&   _db_listtype_curs_Access(_db_listtype_curs &curs);
// cursor points to valid item
void                 _db_fprefix_curs_Reset(_db_fprefix_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_fprefix_curs_ValidQ(_db_fprefix_curs &curs);
// proceed to next item
void                 _db_fprefix_curs_Next(_db_fprefix_curs &curs);
// item access
acr_ed::FFprefix&    _db_fprefix_curs_Access(_db_fprefix_curs &curs);
// cursor points to valid item
void                 _db_target_curs_Reset(_db_target_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_target_curs_ValidQ(_db_target_curs &curs);
// proceed to next item
void                 _db_target_curs_Next(_db_target_curs &curs);
// item access
acr_ed::FTarget&     _db_target_curs_Access(_db_target_curs &curs);
// cursor points to valid item
void                 _db_targsrc_curs_Reset(_db_targsrc_curs &curs, acr_ed::FDb &parent);
// cursor points to valid item
bool                 _db_targsrc_curs_ValidQ(_db_targsrc_curs &curs);
// proceed to next item
void                 _db_targsrc_curs_Next(_db_targsrc_curs &curs);
// item access
acr_ed::FTargsrc&    _db_targsrc_curs_Access(_db_targsrc_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- acr_ed.FField
// create: acr_ed.FDb.field (Lary)
// global access: ind_field (Thash)
// access: acr_ed.FCtype.c_field (Ptrary)
struct FField { // acr_ed.FField
    acr_ed::FField*     ind_field_next;         // hash next
    algo::Smallstr100   field;                  //
    algo::Smallstr50    arg;                    // type of field
    algo::Smallstr50    reftype;                //   "Val"
    dmmeta::CppExpr     dflt;                   // default value (c++ expression)
    algo::Comment       comment;                //
    acr_ed::FCtype*     p_ctype;                // reference to parent row
    u32                 rowid;                  //   0
    acr_ed::FCtype*     p_arg;                  // reference to parent row
    acr_ed::FNs*        p_ns;                   // reference to parent row
    bool                ctype_c_field_in_ary;   //   false  membership flag
private:
    friend acr_ed::FField&      field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FField*      field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
    FField();
    ~FField();
    FField(const FField&){ /*disallow copy constructor */}
    void operator =(const FField&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 field_CopyOut(acr_ed::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
void                 field_CopyIn(acr_ed::FField &row, dmmeta::Field &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FField_Init(acr_ed::FField& field);
void                 FField_Uninit(acr_ed::FField& field) __attribute__((nothrow));

// --- acr_ed.FFprefix
// create: acr_ed.FDb.fprefix (Lary)
// global access: ind_fprefix (Thash)
struct FFprefix { // acr_ed.FFprefix
    acr_ed::FFprefix*   ind_fprefix_next;   // hash next
    algo::Smallstr5     fprefix;            //
    algo::Smallstr50    reftype;            //
    algo::Comment       comment;            //
private:
    friend acr_ed::FFprefix&    fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FFprefix*    fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fprefix_RemoveLast() __attribute__((nothrow));
    FFprefix();
    ~FFprefix();
    FFprefix(const FFprefix&){ /*disallow copy constructor */}
    void operator =(const FFprefix&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fprefix_CopyOut(acr_ed::FFprefix &row, dmmeta::Fprefix &out) __attribute__((nothrow));
// Copy fields in to row
void                 fprefix_CopyIn(acr_ed::FFprefix &row, dmmeta::Fprefix &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFprefix_Init(acr_ed::FFprefix& fprefix);
void                 FFprefix_Uninit(acr_ed::FFprefix& fprefix) __attribute__((nothrow));

// --- acr_ed.FListtype
// create: acr_ed.FDb.listtype (Lary)
// global access: ind_listtype (Thash)
struct FListtype { // acr_ed.FListtype
    acr_ed::FListtype*   ind_listtype_next;   // hash next
    algo::Smallstr5      listtype;            //
    bool                 circular;            //   false  Circular list
    bool                 haveprev;            //   false  Previous link
    bool                 instail;             //   false  Queue
    algo::Comment        comment;             //
private:
    friend acr_ed::FListtype&   listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FListtype*   listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 listtype_RemoveLast() __attribute__((nothrow));
    FListtype();
    ~FListtype();
    FListtype(const FListtype&){ /*disallow copy constructor */}
    void operator =(const FListtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 listtype_CopyOut(acr_ed::FListtype &row, dmmeta::Listtype &out) __attribute__((nothrow));
// Copy fields in to row
void                 listtype_CopyIn(acr_ed::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FListtype_Init(acr_ed::FListtype& listtype);
void                 FListtype_Uninit(acr_ed::FListtype& listtype) __attribute__((nothrow));

// --- acr_ed.FNs
// create: acr_ed.FDb.ns (Lary)
// global access: ind_ns (Thash)
// access: acr_ed.FCtype.p_ns (Upptr)
// access: acr_ed.FField.p_ns (Upptr)
struct FNs { // acr_ed.FNs
    acr_ed::FNs*       ind_ns_next;   // hash next
    algo::Smallstr16   ns;            // Namespace name (primary key)
    algo::Smallstr50   nstype;        //
    algo::Comment      comment;       //
private:
    friend acr_ed::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
    FNs();
    ~FNs();
    FNs(const FNs&){ /*disallow copy constructor */}
    void operator =(const FNs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ns_CopyOut(acr_ed::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
void                 ns_CopyIn(acr_ed::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNs_Init(acr_ed::FNs& ns);
void                 FNs_Uninit(acr_ed::FNs& ns) __attribute__((nothrow));

// --- acr_ed.FSsimfile
// create: acr_ed.FDb.ssimfile (Lary)
// global access: ind_ssimfile (Thash)
struct FSsimfile { // acr_ed.FSsimfile
    acr_ed::FSsimfile*   ind_ssimfile_next;   // hash next
    algo::Smallstr50     ssimfile;            //
    algo::Smallstr50     ctype;               //
    acr_ed::FCtype*      p_ctype;             // reference to parent row
private:
    friend acr_ed::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
    FSsimfile();
    ~FSsimfile();
    FSsimfile(const FSsimfile&){ /*disallow copy constructor */}
    void operator =(const FSsimfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimfile_CopyOut(acr_ed::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimfile_CopyIn(acr_ed::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

algo::Smallstr16     ssimns_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FSsimfile_Init(acr_ed::FSsimfile& ssimfile);
void                 FSsimfile_Uninit(acr_ed::FSsimfile& ssimfile) __attribute__((nothrow));

// --- acr_ed.FTarget
// create: acr_ed.FDb.target (Lary)
// global access: ind_target (Thash)
// access: acr_ed.FTargsrc.p_target (Upptr)
struct FTarget { // acr_ed.FTarget
    acr_ed::FTarget*   ind_target_next;   // hash next
    algo::Smallstr16   target;            //
    u32                score;             //   0  For guessing target from source file
private:
    friend acr_ed::FTarget&     target_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTarget*     target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 target_RemoveLast() __attribute__((nothrow));
    FTarget();
    ~FTarget();
    FTarget(const FTarget&){ /*disallow copy constructor */}
    void operator =(const FTarget&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 target_CopyOut(acr_ed::FTarget &row, dev::Target &out) __attribute__((nothrow));
// Copy fields in to row
void                 target_CopyIn(acr_ed::FTarget &row, dev::Target &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTarget_Init(acr_ed::FTarget& target);
void                 FTarget_Uninit(acr_ed::FTarget& target) __attribute__((nothrow));

// --- acr_ed.FTargsrc
// create: acr_ed.FDb.targsrc (Lary)
struct FTargsrc { // acr_ed.FTargsrc
    algo::Smallstr100   targsrc;    //
    algo::Comment       comment;    //
    acr_ed::FTarget*    p_target;   // reference to parent row
private:
    friend acr_ed::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targsrc_RemoveAll() __attribute__((nothrow));
    friend void                 targsrc_RemoveLast() __attribute__((nothrow));
    FTargsrc();
    // x-reference on acr_ed.FTargsrc.p_target prevents copy
    FTargsrc(const FTargsrc&){ /*disallow copy constructor */}
    void operator =(const FTargsrc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 targsrc_CopyOut(acr_ed::FTargsrc &row, dev::Targsrc &out) __attribute__((nothrow));
// Copy fields in to row
void                 targsrc_CopyIn(acr_ed::FTargsrc &row, dev::Targsrc &in) __attribute__((nothrow));

algo::Smallstr16     target_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr200    src_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr10     ext_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FTargsrc_Init(acr_ed::FTargsrc& targsrc);

// --- acr_ed.FieldId
#pragma pack(push,1)
struct FieldId { // acr_ed.FieldId: Field read helper
    i32   value;   //   -1
    inline operator acr_ed_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(acr_ed_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
acr_ed_FieldIdEnum   value_GetEnum(const acr_ed::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr_ed::FieldId& parent, acr_ed_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr_ed::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr_ed::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr_ed::FieldId& parent, algo::strptr rhs, acr_ed_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr_ed::FieldId from an ascii string.
// The format of the string is the format of the acr_ed::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(acr_ed::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(acr_ed::FieldId& parent);
// print string representation of acr_ed::FieldId to string LHS, no header -- cprint:acr_ed.FieldId.String
void                 FieldId_Print(acr_ed::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- acr_ed.TableId
struct TableId { // acr_ed.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator acr_ed_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(acr_ed_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
acr_ed_TableIdEnum   value_GetEnum(const acr_ed::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr_ed::TableId& parent, acr_ed_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr_ed::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr_ed::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr_ed::TableId& parent, algo::strptr rhs, acr_ed_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr_ed::TableId from an ascii string.
// The format of the string is the format of the acr_ed::TableId's only field
bool                 TableId_ReadStrptrMaybe(acr_ed::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(acr_ed::TableId& parent);
// print string representation of acr_ed::TableId to string LHS, no header -- cprint:acr_ed.TableId.String
void                 TableId_Print(acr_ed::TableId & row, algo::cstring &str) __attribute__((nothrow));

struct ctype_c_field_curs {// cursor
    typedef acr_ed::FField ChildType;
    acr_ed::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_ns_curs {// cursor
    typedef acr_ed::FNs ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef acr_ed::FField ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_ctype_curs {// cursor
    typedef acr_ed::FCtype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef acr_ed::FSsimfile ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_cstr_curs {// cursor
    typedef acr_ed::FCstr ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cstr_curs(){ parent=NULL; index=0; }
};


struct _db_vis_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    _db_vis_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_listtype_curs {// cursor
    typedef acr_ed::FListtype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_listtype_curs(){ parent=NULL; index=0; }
};


struct _db_fprefix_curs {// cursor
    typedef acr_ed::FFprefix ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_fprefix_curs(){ parent=NULL; index=0; }
};


struct _db_target_curs {// cursor
    typedef acr_ed::FTarget ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_target_curs(){ parent=NULL; index=0; }
};


struct _db_targsrc_curs {// cursor
    typedef acr_ed::FTargsrc ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_targsrc_curs(){ parent=NULL; index=0; }
};

int                  main(int argc, char **argv);
} // end namespace acr_ed
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::trace &row);// cfmt:acr_ed.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::FieldId &row);// cfmt:acr_ed.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::TableId &row);// cfmt:acr_ed.TableId.String
}
