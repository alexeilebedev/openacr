//
// include/gen/acr_ed_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/dmmeta_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/dev_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- acr_ed_FieldIdEnum

enum acr_ed_FieldIdEnum {        // acr_ed.FieldId.value
     acr_ed_FieldId_value   = 0
};

enum { acr_ed_FieldIdEnum_N = 1 };


// --- acr_ed_TableIdEnum

enum acr_ed_TableIdEnum {                    // acr_ed.TableId.value
     acr_ed_TableId_dmmeta_Cfmt       = 0    // dmmeta.Cfmt -> acr_ed.FCfmt
    ,acr_ed_TableId_dmmeta_cfmt       = 0    // dmmeta.cfmt -> acr_ed.FCfmt
    ,acr_ed_TableId_dmmeta_Cpptype    = 1    // dmmeta.Cpptype -> acr_ed.FCpptype
    ,acr_ed_TableId_dmmeta_cpptype    = 1    // dmmeta.cpptype -> acr_ed.FCpptype
    ,acr_ed_TableId_dmmeta_Cstr       = 2    // dmmeta.Cstr -> acr_ed.FCstr
    ,acr_ed_TableId_dmmeta_cstr       = 2    // dmmeta.cstr -> acr_ed.FCstr
    ,acr_ed_TableId_dmmeta_Ctype      = 3    // dmmeta.Ctype -> acr_ed.FCtype
    ,acr_ed_TableId_dmmeta_ctype      = 3    // dmmeta.ctype -> acr_ed.FCtype
    ,acr_ed_TableId_dmmeta_Field      = 4    // dmmeta.Field -> acr_ed.FField
    ,acr_ed_TableId_dmmeta_field      = 4    // dmmeta.field -> acr_ed.FField
    ,acr_ed_TableId_dmmeta_Fprefix    = 5    // dmmeta.Fprefix -> acr_ed.FFprefix
    ,acr_ed_TableId_dmmeta_fprefix    = 5    // dmmeta.fprefix -> acr_ed.FFprefix
    ,acr_ed_TableId_dev_Gitfile       = 6    // dev.Gitfile -> acr_ed.FGitfile
    ,acr_ed_TableId_dev_gitfile       = 6    // dev.gitfile -> acr_ed.FGitfile
    ,acr_ed_TableId_dmmeta_Listtype   = 7    // dmmeta.Listtype -> acr_ed.FListtype
    ,acr_ed_TableId_dmmeta_listtype   = 7    // dmmeta.listtype -> acr_ed.FListtype
    ,acr_ed_TableId_dmmeta_Ns         = 8    // dmmeta.Ns -> acr_ed.FNs
    ,acr_ed_TableId_dmmeta_ns         = 8    // dmmeta.ns -> acr_ed.FNs
    ,acr_ed_TableId_dmmeta_Nsdb       = 9    // dmmeta.Nsdb -> acr_ed.FNsdb
    ,acr_ed_TableId_dmmeta_nsdb       = 9    // dmmeta.nsdb -> acr_ed.FNsdb
    ,acr_ed_TableId_dmmeta_Pack       = 10   // dmmeta.Pack -> acr_ed.FPack
    ,acr_ed_TableId_dmmeta_pack       = 10   // dmmeta.pack -> acr_ed.FPack
    ,acr_ed_TableId_dev_Sbpath        = 11   // dev.Sbpath -> acr_ed.FSbpath
    ,acr_ed_TableId_dev_sbpath        = 11   // dev.sbpath -> acr_ed.FSbpath
    ,acr_ed_TableId_dmmeta_Ssimfile   = 12   // dmmeta.Ssimfile -> acr_ed.FSsimfile
    ,acr_ed_TableId_dmmeta_ssimfile   = 12   // dmmeta.ssimfile -> acr_ed.FSsimfile
    ,acr_ed_TableId_dev_Target        = 13   // dev.Target -> acr_ed.FTarget
    ,acr_ed_TableId_dev_target        = 13   // dev.target -> acr_ed.FTarget
    ,acr_ed_TableId_dev_Targsrc       = 14   // dev.Targsrc -> acr_ed.FTargsrc
    ,acr_ed_TableId_dev_targsrc       = 14   // dev.targsrc -> acr_ed.FTargsrc
    ,acr_ed_TableId_dmmeta_Typefld    = 15   // dmmeta.Typefld -> acr_ed.FTypefld
    ,acr_ed_TableId_dmmeta_typefld    = 15   // dmmeta.typefld -> acr_ed.FTypefld
};

enum { acr_ed_TableIdEnum_N = 32 };

namespace acr_ed { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace acr_ed { // gen:ns_tclass_field
extern const char *acr_ed_help;
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace acr_ed { struct FNs; }
namespace dev { struct Edaction; }
namespace dmmeta { struct Field; }
namespace acr_ed { struct FCtype; }
namespace dmmeta { struct Fprefix; }
namespace dev { struct Gitfile; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Pack; }
namespace dev { struct Sbpath; }
namespace dmmeta { struct Ssimfile; }
namespace dev { struct Target; }
namespace dev { struct Targsrc; }
namespace acr_ed { struct FTarget; }
namespace dmmeta { struct Typefld; }
namespace acr_ed { struct ctype_c_field_curs; }
namespace acr_ed { struct ctype_c_cfmt_curs; }
namespace acr_ed { struct _db_ns_curs; }
namespace acr_ed { struct _db_field_curs; }
namespace acr_ed { struct _db_ctype_curs; }
namespace acr_ed { struct _db_ssimfile_curs; }
namespace acr_ed { struct _db_cstr_curs; }
namespace acr_ed { struct _db_vis_curs; }
namespace acr_ed { struct _db_listtype_curs; }
namespace acr_ed { struct _db_fprefix_curs; }
namespace acr_ed { struct _db_target_curs; }
namespace acr_ed { struct _db_targsrc_curs; }
namespace acr_ed { struct _db_sbpath_curs; }
namespace acr_ed { struct _db_pack_curs; }
namespace acr_ed { struct _db_typefld_curs; }
namespace acr_ed { struct _db_cpptype_curs; }
namespace acr_ed { struct _db_cfmt_curs; }
namespace acr_ed { struct _db_nsdb_curs; }
namespace acr_ed { struct _db_edaction_curs; }
namespace acr_ed { struct _db_gitfile_curs; }
namespace acr_ed { struct target_zd_targsrc_curs; }
namespace acr_ed { struct FCfmt; }
namespace acr_ed { struct FCpptype; }
namespace acr_ed { struct FCstr; }
namespace acr_ed { struct FEdaction; }
namespace acr_ed { struct trace; }
namespace acr_ed { struct FDb; }
namespace acr_ed { struct FField; }
namespace acr_ed { struct FFprefix; }
namespace acr_ed { struct FGitfile; }
namespace acr_ed { struct FListtype; }
namespace acr_ed { struct FNsdb; }
namespace acr_ed { struct FPack; }
namespace acr_ed { struct FSbpath; }
namespace acr_ed { struct FSsimfile; }
namespace acr_ed { struct FTargsrc; }
namespace acr_ed { struct FTypefld; }
namespace acr_ed { struct FieldId; }
namespace acr_ed { struct TableId; }
namespace acr_ed { extern struct acr_ed::FDb _db; }
namespace acr_ed { // hook_fcn_typedef
    typedef void (*edaction_step_hook)(); // hook:acr_ed.FEdaction.step
} // hook_decl
namespace acr_ed { // gen:ns_gsymbol
    extern const char* atfdb_cijob_comp; // "comp"
    extern const char* atfdb_cijob_cov; // "cov"
    extern const char* atfdb_cijob_memcheck; // "memcheck"
    extern const char* atfdb_cijob_normalize; // "normalize"
} // gen:ns_gsymbol
namespace acr_ed { // gen:ns_gsymbol
    extern const algo::strptr dev_package_amc; // "amc"
    extern const algo::strptr dev_package_apm; // "apm"
    extern const algo::strptr dev_package_openacr; // "openacr"
} // gen:ns_gsymbol
namespace acr_ed { // gen:ns_print_struct

// --- acr_ed.FCfmt
// create: acr_ed.FDb.cfmt (Lary)
// global access: cfmt (Lary, by rowid)
// access: acr_ed.FCtype.c_cfmt (Ptrary)
struct FCfmt { // acr_ed.FCfmt
    algo::Smallstr100   cfmt;       //
    algo::Smallstr50    printfmt;   //
    bool                read;       //   false
    bool                print;      //   false
    algo::Smallstr20    sep;        //
    bool                genop;      //   false
    algo::Comment       comment;    //
    // func:acr_ed.FCfmt..AssignOp
    acr_ed::FCfmt&       operator =(const acr_ed::FCfmt &rhs) = delete;
    // func:acr_ed.FCfmt..CopyCtor
    FCfmt(const acr_ed::FCfmt &rhs) = delete;
private:
    // func:acr_ed.FCfmt..Ctor
    inline               FCfmt() __attribute__((nothrow));
    // func:acr_ed.FCfmt..Dtor
    inline               ~FCfmt() __attribute__((nothrow));
    friend acr_ed::FCfmt&       cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCfmt*       cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfmt_RemoveAll() __attribute__((nothrow));
    friend void                 cfmt_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FCfmt.base.CopyOut
void                 cfmt_CopyOut(acr_ed::FCfmt &row, dmmeta::Cfmt &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FCfmt.base.CopyIn
void                 cfmt_CopyIn(acr_ed::FCfmt &row, dmmeta::Cfmt &in) __attribute__((nothrow));

// func:acr_ed.FCfmt.ctype.Get
algo::Smallstr100    ctype_Get(acr_ed::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FCfmt.strfmt.Get
algo::Smallstr50     strfmt_Get(acr_ed::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr_ed.FCfmt..Init
inline void          FCfmt_Init(acr_ed::FCfmt& cfmt);
// func:acr_ed.FCfmt..Uninit
void                 FCfmt_Uninit(acr_ed::FCfmt& cfmt) __attribute__((nothrow));

// --- acr_ed.FCpptype
// create: acr_ed.FDb.cpptype (Lary)
// global access: cpptype (Lary, by rowid)
// access: acr_ed.FCtype.c_cpptype (Ptr)
struct FCpptype { // acr_ed.FCpptype
    algo::Smallstr100   ctype;        //
    bool                ctor;         //   false  if true, generate non-default constructor from all fields
    bool                dtor;         //   true  generate non-default destructor
    bool                cheap_copy;   //   false  Pass by value whenever possible
    // func:acr_ed.FCpptype..AssignOp
    inline acr_ed::FCpptype& operator =(const acr_ed::FCpptype &rhs) = delete;
    // func:acr_ed.FCpptype..CopyCtor
    inline               FCpptype(const acr_ed::FCpptype &rhs) = delete;
private:
    // func:acr_ed.FCpptype..Ctor
    inline               FCpptype() __attribute__((nothrow));
    // func:acr_ed.FCpptype..Dtor
    inline               ~FCpptype() __attribute__((nothrow));
    friend acr_ed::FCpptype&    cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCpptype*    cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cpptype_RemoveAll() __attribute__((nothrow));
    friend void                 cpptype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FCpptype.base.CopyOut
void                 cpptype_CopyOut(acr_ed::FCpptype &row, dmmeta::Cpptype &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FCpptype.base.CopyIn
void                 cpptype_CopyIn(acr_ed::FCpptype &row, dmmeta::Cpptype &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FCpptype..Init
inline void          FCpptype_Init(acr_ed::FCpptype& cpptype);
// func:acr_ed.FCpptype..Uninit
void                 FCpptype_Uninit(acr_ed::FCpptype& cpptype) __attribute__((nothrow));

// --- acr_ed.FCstr
// create: acr_ed.FDb.cstr (Lary)
// global access: cstr (Lary, by rowid)
// access: acr_ed.FCtype.c_cstr (Ptr)
struct FCstr { // acr_ed.FCstr
    algo::Smallstr100   ctype;      //
    bool                strequiv;   //   false  Use strptr instead of this type when possible
    algo::Comment       comment;    //
    // func:acr_ed.FCstr..AssignOp
    inline acr_ed::FCstr& operator =(const acr_ed::FCstr &rhs) = delete;
    // func:acr_ed.FCstr..CopyCtor
    inline               FCstr(const acr_ed::FCstr &rhs) = delete;
private:
    // func:acr_ed.FCstr..Ctor
    inline               FCstr() __attribute__((nothrow));
    // func:acr_ed.FCstr..Dtor
    inline               ~FCstr() __attribute__((nothrow));
    friend acr_ed::FCstr&       cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCstr*       cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FCstr.msghdr.CopyOut
void                 cstr_CopyOut(acr_ed::FCstr &row, dmmeta::Cstr &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FCstr.msghdr.CopyIn
void                 cstr_CopyIn(acr_ed::FCstr &row, dmmeta::Cstr &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FCstr..Init
inline void          FCstr_Init(acr_ed::FCstr& cstr);
// func:acr_ed.FCstr..Uninit
void                 FCstr_Uninit(acr_ed::FCstr& cstr) __attribute__((nothrow));

// --- acr_ed.FCtype
// create: acr_ed.FDb.ctype (Lary)
// global access: ctype (Lary, by rowid)
// global access: ind_ctype (Thash, hash field ctype)
// access: acr_ed.FField.p_ctype (Upptr)
// access: acr_ed.FField.p_arg (Upptr)
// access: acr_ed.FSsimfile.p_ctype (Upptr)
struct FCtype { // acr_ed.FCtype
    algo::Smallstr100    ctype;            // Identifier. must be ns.typename
    algo::Comment        comment;          //
    acr_ed::FField**     c_field_elems;    // array of pointers
    u32                  c_field_n;        // array of pointers
    u32                  c_field_max;      // capacity of allocated array
    acr_ed::FCstr*       c_cstr;           // optional pointer
    acr_ed::FNs*         p_ns;             // reference to parent row
    acr_ed::FSsimfile*   c_ssimfile;       // optional pointer
    acr_ed::FPack*       c_pack;           // optional pointer
    acr_ed::FTypefld*    c_typefld;        // optional pointer
    acr_ed::FCpptype*    c_cpptype;        // optional pointer
    acr_ed::FCfmt**      c_cfmt_elems;     // array of pointers
    u32                  c_cfmt_n;         // array of pointers
    u32                  c_cfmt_max;       // capacity of allocated array
    acr_ed::FCtype*      ind_ctype_next;   // hash next
    // reftype Ptrary of acr_ed.FCtype.c_field prohibits copy
    // x-reference on acr_ed.FCtype.c_cstr prevents copy
    // x-reference on acr_ed.FCtype.p_ns prevents copy
    // x-reference on acr_ed.FCtype.c_ssimfile prevents copy
    // x-reference on acr_ed.FCtype.c_pack prevents copy
    // x-reference on acr_ed.FCtype.c_typefld prevents copy
    // x-reference on acr_ed.FCtype.c_cpptype prevents copy
    // reftype Ptrary of acr_ed.FCtype.c_cfmt prohibits copy
    // func:acr_ed.FCtype..AssignOp
    acr_ed::FCtype&      operator =(const acr_ed::FCtype &rhs) = delete;
    // reftype Ptrary of acr_ed.FCtype.c_field prohibits copy
    // x-reference on acr_ed.FCtype.c_cstr prevents copy
    // x-reference on acr_ed.FCtype.p_ns prevents copy
    // x-reference on acr_ed.FCtype.c_ssimfile prevents copy
    // x-reference on acr_ed.FCtype.c_pack prevents copy
    // x-reference on acr_ed.FCtype.c_typefld prevents copy
    // x-reference on acr_ed.FCtype.c_cpptype prevents copy
    // reftype Ptrary of acr_ed.FCtype.c_cfmt prohibits copy
    // func:acr_ed.FCtype..CopyCtor
    FCtype(const acr_ed::FCtype &rhs) = delete;
private:
    // func:acr_ed.FCtype..Ctor
    inline               FCtype() __attribute__((nothrow));
    // func:acr_ed.FCtype..Dtor
    inline               ~FCtype() __attribute__((nothrow));
    friend acr_ed::FCtype&      ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FCtype*      ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FCtype.msghdr.CopyOut
void                 ctype_CopyOut(acr_ed::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FCtype.msghdr.CopyIn
void                 ctype_CopyIn(acr_ed::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

// func:acr_ed.FCtype.ns.Get
algo::Smallstr16     ns_Get(acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FCtype.name.Get
algo::Smallstr100    name_Get(acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:acr_ed.FCtype.c_field.EmptyQ
inline bool          c_field_EmptyQ(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FCtype.c_field.Find
inline acr_ed::FField* c_field_Find(acr_ed::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr_ed.FCtype.c_field.Getary
inline algo::aryptr<acr_ed::FField*> c_field_Getary(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr_ed.FCtype.c_field.Insert
void                 c_field_Insert(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:acr_ed.FCtype.c_field.InsertMaybe
bool                 c_field_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr_ed.FCtype.c_field.N
inline i32           c_field_N(const acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr_ed.FCtype.c_field.Remove
void                 c_field_Remove(acr_ed::FCtype& ctype, acr_ed::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr_ed.FCtype.c_field.RemoveAll
inline void          c_field_RemoveAll(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr_ed.FCtype.c_field.Reserve
void                 c_field_Reserve(acr_ed::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr_ed.FCtype.c_field.qFind
inline acr_ed::FField& c_field_qFind(acr_ed::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:acr_ed.FCtype.c_field.InAryQ
inline bool          ctype_c_field_InAryQ(acr_ed::FField& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr_ed.FCtype.c_field.qLast
inline acr_ed::FField& c_field_qLast(acr_ed::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr_ed.FCtype.c_cstr.InsertMaybe
inline bool          c_cstr_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr_ed.FCtype.c_cstr.Remove
inline void          c_cstr_Remove(acr_ed::FCtype& ctype, acr_ed::FCstr& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr_ed.FCtype.c_ssimfile.InsertMaybe
inline bool          c_ssimfile_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr_ed.FCtype.c_ssimfile.Remove
inline void          c_ssimfile_Remove(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr_ed.FCtype.c_pack.InsertMaybe
inline bool          c_pack_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FPack& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr_ed.FCtype.c_pack.Remove
inline void          c_pack_Remove(acr_ed::FCtype& ctype, acr_ed::FPack& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr_ed.FCtype.c_typefld.InsertMaybe
inline bool          c_typefld_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FTypefld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr_ed.FCtype.c_typefld.Remove
inline void          c_typefld_Remove(acr_ed::FCtype& ctype, acr_ed::FTypefld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr_ed.FCtype.c_cpptype.InsertMaybe
inline bool          c_cpptype_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCpptype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr_ed.FCtype.c_cpptype.Remove
inline void          c_cpptype_Remove(acr_ed::FCtype& ctype, acr_ed::FCpptype& row) __attribute__((nothrow));

// Return true if index is empty
// func:acr_ed.FCtype.c_cfmt.EmptyQ
inline bool          c_cfmt_EmptyQ(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FCtype.c_cfmt.Find
inline acr_ed::FCfmt* c_cfmt_Find(acr_ed::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr_ed.FCtype.c_cfmt.Getary
inline algo::aryptr<acr_ed::FCfmt*> c_cfmt_Getary(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr_ed.FCtype.c_cfmt.Insert
void                 c_cfmt_Insert(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr_ed.FCtype.c_cfmt.ScanInsertMaybe
bool                 c_cfmt_ScanInsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr_ed.FCtype.c_cfmt.N
inline i32           c_cfmt_N(const acr_ed::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr_ed.FCtype.c_cfmt.Remove
void                 c_cfmt_Remove(acr_ed::FCtype& ctype, acr_ed::FCfmt& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr_ed.FCtype.c_cfmt.RemoveAll
inline void          c_cfmt_RemoveAll(acr_ed::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr_ed.FCtype.c_cfmt.Reserve
void                 c_cfmt_Reserve(acr_ed::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr_ed.FCtype.c_cfmt.qFind
inline acr_ed::FCfmt& c_cfmt_qFind(acr_ed::FCtype& ctype, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr_ed.FCtype.c_cfmt.qLast
inline acr_ed::FCfmt& c_cfmt_qLast(acr_ed::FCtype& ctype) __attribute__((nothrow));

// func:acr_ed.FCtype.c_field_curs.Reset
inline void          ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr_ed::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FCtype.c_field_curs.ValidQ
inline bool          ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FCtype.c_field_curs.Next
inline void          ctype_c_field_curs_Next(ctype_c_field_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FCtype.c_field_curs.Access
inline acr_ed::FField& ctype_c_field_curs_Access(ctype_c_field_curs &curs) __attribute__((nothrow));
// func:acr_ed.FCtype.c_cfmt_curs.Reset
inline void          ctype_c_cfmt_curs_Reset(ctype_c_cfmt_curs &curs, acr_ed::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FCtype.c_cfmt_curs.ValidQ
inline bool          ctype_c_cfmt_curs_ValidQ(ctype_c_cfmt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FCtype.c_cfmt_curs.Next
inline void          ctype_c_cfmt_curs_Next(ctype_c_cfmt_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FCtype.c_cfmt_curs.Access
inline acr_ed::FCfmt& ctype_c_cfmt_curs_Access(ctype_c_cfmt_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr_ed.FCtype..Init
void                 FCtype_Init(acr_ed::FCtype& ctype);
// func:acr_ed.FCtype..Uninit
void                 FCtype_Uninit(acr_ed::FCtype& ctype) __attribute__((nothrow));

// --- acr_ed.FEdaction
// create: acr_ed.FDb.edaction (Inlary)
// global access: ind_edaction (Thash, hash field edaction)
struct FEdaction { // acr_ed.FEdaction
    algo::Smallstr50             edaction;            //
    bool                         needamc;             //   false
    algo::Comment                comment;             //
    acr_ed::edaction_step_hook   step;                //   NULL  Pointer to a function
    bool                         select;              //   false
    acr_ed::FEdaction*           ind_edaction_next;   // hash next
    // reftype Hook of acr_ed.FEdaction.step prohibits copy
    // func:acr_ed.FEdaction..AssignOp
    inline acr_ed::FEdaction& operator =(const acr_ed::FEdaction &rhs) = delete;
    // func:acr_ed.FEdaction..Ctor
    inline               FEdaction() __attribute__((nothrow));
    // func:acr_ed.FEdaction..Dtor
    inline               ~FEdaction() __attribute__((nothrow));
    // reftype Hook of acr_ed.FEdaction.step prohibits copy
    // func:acr_ed.FEdaction..CopyCtor
    inline               FEdaction(const acr_ed::FEdaction &rhs) = delete;
};

// Copy fields out of row
// func:acr_ed.FEdaction.base.CopyOut
void                 edaction_CopyOut(acr_ed::FEdaction &row, dev::Edaction &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FEdaction.base.CopyIn
void                 edaction_CopyIn(acr_ed::FEdaction &row, dev::Edaction &in) __attribute__((nothrow));

// func:acr_ed.FEdaction.edacttype.Get
algo::Smallstr50     edacttype_Get(acr_ed::FEdaction& edaction) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FEdaction.name.Get
algo::Smallstr50     name_Get(acr_ed::FEdaction& edaction) __attribute__((__warn_unused_result__, nothrow));

// Invoke function by pointer
// func:acr_ed.FEdaction.step.Call
inline void          step_Call(acr_ed::FEdaction& edaction) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FEdaction..Init
inline void          FEdaction_Init(acr_ed::FEdaction& edaction);
// func:acr_ed.FEdaction..Uninit
void                 FEdaction_Uninit(acr_ed::FEdaction& edaction) __attribute__((nothrow));

// --- acr_ed.trace
#pragma pack(push,1)
struct trace { // acr_ed.trace
    // func:acr_ed.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)

// print string representation of ROW to string STR
// cfmt:acr_ed.trace.String  printfmt:Tuple
// func:acr_ed.trace..Print
void                 trace_Print(acr_ed::trace& row, algo::cstring& str) __attribute__((nothrow));

// --- acr_ed.FDb
// create: acr_ed.FDb._db (Global)
struct FDb { // acr_ed.FDb: In-memory database for acr_ed
    acr_ed::FNs*          ns_lary[32];                                     // level array
    i32                   ns_n;                                            // number of elements in array
    acr_ed::FNs**         ind_ns_buckets_elems;                            // pointer to bucket array
    i32                   ind_ns_buckets_n;                                // number of elements in bucket array
    i32                   ind_ns_n;                                        // number of elements in the hash table
    command::acr_ed       cmdline;                                         //
    acr_ed::FField*       field_lary[32];                                  // level array
    i32                   field_n;                                         // number of elements in array
    acr_ed::FField**      ind_field_buckets_elems;                         // pointer to bucket array
    i32                   ind_field_buckets_n;                             // number of elements in bucket array
    i32                   ind_field_n;                                     // number of elements in the hash table
    acr_ed::FCtype*       ctype_lary[32];                                  // level array
    i32                   ctype_n;                                         // number of elements in array
    algo::cstring         fcontents;                                       // Optional file contents
    algo::cstring         script;                                          // Script to execute
    algo::cstring         out_ssim;                                        // Input for acr command
    acr_ed::FCtype**      ind_ctype_buckets_elems;                         // pointer to bucket array
    i32                   ind_ctype_buckets_n;                             // number of elements in bucket array
    i32                   ind_ctype_n;                                     // number of elements in the hash table
    acr_ed::FSsimfile*    ssimfile_lary[32];                               // level array
    i32                   ssimfile_n;                                      // number of elements in array
    acr_ed::FSsimfile**   ind_ssimfile_buckets_elems;                      // pointer to bucket array
    i32                   ind_ssimfile_buckets_n;                          // number of elements in bucket array
    i32                   ind_ssimfile_n;                                  // number of elements in the hash table
    acr_ed::FCstr*        cstr_lary[32];                                   // level array
    i32                   cstr_n;                                          // number of elements in array
    algo::cstring*        vis_elems;                                       // pointer to elements
    u32                   vis_n;                                           // number of elements in array
    u32                   vis_max;                                         // max. capacity of array before realloc
    acr_ed::FListtype*    listtype_lary[32];                               // level array
    i32                   listtype_n;                                      // number of elements in array
    acr_ed::FListtype**   ind_listtype_buckets_elems;                      // pointer to bucket array
    i32                   ind_listtype_buckets_n;                          // number of elements in bucket array
    i32                   ind_listtype_n;                                  // number of elements in the hash table
    acr_ed::FFprefix*     fprefix_lary[32];                                // level array
    i32                   fprefix_n;                                       // number of elements in array
    acr_ed::FFprefix**    ind_fprefix_buckets_elems;                       // pointer to bucket array
    i32                   ind_fprefix_buckets_n;                           // number of elements in bucket array
    i32                   ind_fprefix_n;                                   // number of elements in the hash table
    acr_ed::FTarget*      target_lary[32];                                 // level array
    i32                   target_n;                                        // number of elements in array
    acr_ed::FTarget**     ind_target_buckets_elems;                        // pointer to bucket array
    i32                   ind_target_buckets_n;                            // number of elements in bucket array
    i32                   ind_target_n;                                    // number of elements in the hash table
    algo::Smallstr100     keyfld;                                          //
    algo::Smallstr100     viafld;                                          //
    bool                  need_amc;                                        //   false
    acr_ed::FTargsrc*     targsrc_lary[32];                                // level array
    i32                   targsrc_n;                                       // number of elements in array
    algo::cstring         abt_path;                                        //   "bin/abt"  path for executable
    command::abt          abt_cmd;                                         // command line for child process
    algo::cstring         abt_fstdin;                                      // redirect for stdin
    algo::cstring         abt_fstdout;                                     // redirect for stdout
    algo::cstring         abt_fstderr;                                     // redirect for stderr
    pid_t                 abt_pid;                                         //   0  pid of running child process
    i32                   abt_timeout;                                     //   0  optional timeout for child process
    i32                   abt_status;                                      //   0  last exit status of child process
    acr_ed::FSbpath*      sbpath_lary[32];                                 // level array
    i32                   sbpath_n;                                        // number of elements in array
    acr_ed::FPack*        pack_lary[32];                                   // level array
    i32                   pack_n;                                          // number of elements in array
    acr_ed::FTypefld*     typefld_lary[32];                                // level array
    i32                   typefld_n;                                       // number of elements in array
    acr_ed::FCpptype*     cpptype_lary[32];                                // level array
    i32                   cpptype_n;                                       // number of elements in array
    acr_ed::FCfmt*        cfmt_lary[32];                                   // level array
    i32                   cfmt_n;                                          // number of elements in array
    acr_ed::FNsdb*        nsdb_lary[32];                                   // level array
    i32                   nsdb_n;                                          // number of elements in array
    acr_ed::FNsdb**       ind_nsdb_buckets_elems;                          // pointer to bucket array
    i32                   ind_nsdb_buckets_n;                              // number of elements in bucket array
    i32                   ind_nsdb_n;                                      // number of elements in the hash table
    bool                  could_be_ptr;                                    //   false  Used to automatically guess Ptr or Ptrary reftype on new fields
    u128                  edaction_data[sizeu128(acr_ed::FEdaction,18)];   // place for data
    i32                   edaction_n;                                      // number of elems current in existence
    enum { edaction_max = 18 };
    acr_ed::FEdaction**   ind_edaction_buckets_elems;                      // pointer to bucket array
    i32                   ind_edaction_buckets_n;                          // number of elements in bucket array
    i32                   ind_edaction_n;                                  // number of elements in the hash table
    acr_ed::FGitfile*     gitfile_lary[32];                                // level array
    i32                   gitfile_n;                                       // number of elements in array
    acr_ed::trace         trace;                                           //
};

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.ns.Alloc
acr_ed::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.ns.AllocMaybe
acr_ed::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.ns.InsertMaybe
acr_ed::FNs*         ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.ns.AllocMem
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.ns.EmptyQ
inline bool          ns_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.ns.Find
inline acr_ed::FNs*  ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.ns.Last
inline acr_ed::FNs*  ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.ns.N
inline i32           ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.ns.RemoveLast
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.ns.qFind
inline acr_ed::FNs&  ns_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.ns.XrefMaybe
bool                 ns_XrefMaybe(acr_ed::FNs &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_ns.EmptyQ
inline bool          ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_ns.Find
acr_ed::FNs*         ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_ns.FindX
acr_ed::FNs&         ind_ns_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr_ed.FDb.ind_ns.GetOrCreate
acr_ed::FNs&         ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr_ed.FDb.ind_ns.N
inline i32           ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_ns.InsertMaybe
bool                 ind_ns_InsertMaybe(acr_ed::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_ns.Remove
void                 ind_ns_Remove(acr_ed::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_ns.Reserve
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     acr_ed.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:acr_ed.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
// func:acr_ed.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:acr_ed.FDb._db.Step
void                 Step();
// Main function
// func:acr_ed.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:acr_ed.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:acr_ed.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:acr_ed.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:acr_ed.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load specified ssimfile.
// func:acr_ed.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:acr_ed.FDb._db.Steps
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.field.Alloc
acr_ed::FField&      field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.field.AllocMaybe
acr_ed::FField*      field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.field.InsertMaybe
acr_ed::FField*      field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.field.AllocMem
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.field.EmptyQ
inline bool          field_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.field.Find
inline acr_ed::FField* field_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.field.Last
inline acr_ed::FField* field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.field.N
inline i32           field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.field.RemoveLast
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.field.qFind
inline acr_ed::FField& field_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.field.XrefMaybe
bool                 field_XrefMaybe(acr_ed::FField &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_field.EmptyQ
inline bool          ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_field.Find
acr_ed::FField*      ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_field.FindX
acr_ed::FField&      ind_field_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:acr_ed.FDb.ind_field.N
inline i32           ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_field.InsertMaybe
bool                 ind_field_InsertMaybe(acr_ed::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_field.Remove
void                 ind_field_Remove(acr_ed::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_field.Reserve
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.ctype.Alloc
acr_ed::FCtype&      ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.ctype.AllocMaybe
acr_ed::FCtype*      ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.ctype.InsertMaybe
acr_ed::FCtype*      ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.ctype.AllocMem
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.ctype.EmptyQ
inline bool          ctype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.ctype.Find
inline acr_ed::FCtype* ctype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.ctype.Last
inline acr_ed::FCtype* ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.ctype.N
inline i32           ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.ctype.RemoveLast
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.ctype.qFind
inline acr_ed::FCtype& ctype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.ctype.XrefMaybe
bool                 ctype_XrefMaybe(acr_ed::FCtype &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_ctype.EmptyQ
inline bool          ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_ctype.Find
acr_ed::FCtype*      ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_ctype.FindX
acr_ed::FCtype&      ind_ctype_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:acr_ed.FDb.ind_ctype.N
inline i32           ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_ctype.InsertMaybe
bool                 ind_ctype_InsertMaybe(acr_ed::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_ctype.Remove
void                 ind_ctype_Remove(acr_ed::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_ctype.Reserve
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.ssimfile.Alloc
acr_ed::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.ssimfile.AllocMaybe
acr_ed::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.ssimfile.InsertMaybe
acr_ed::FSsimfile*   ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.ssimfile.AllocMem
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.ssimfile.EmptyQ
inline bool          ssimfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.ssimfile.Find
inline acr_ed::FSsimfile* ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.ssimfile.Last
inline acr_ed::FSsimfile* ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.ssimfile.N
inline i32           ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.ssimfile.RemoveLast
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.ssimfile.qFind
inline acr_ed::FSsimfile& ssimfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.ssimfile.XrefMaybe
bool                 ssimfile_XrefMaybe(acr_ed::FSsimfile &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_ssimfile.EmptyQ
inline bool          ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_ssimfile.Find
acr_ed::FSsimfile*   ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_ssimfile.FindX
acr_ed::FSsimfile&   ind_ssimfile_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:acr_ed.FDb.ind_ssimfile.N
inline i32           ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_ssimfile.InsertMaybe
bool                 ind_ssimfile_InsertMaybe(acr_ed::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_ssimfile.Remove
void                 ind_ssimfile_Remove(acr_ed::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_ssimfile.Reserve
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.cstr.Alloc
acr_ed::FCstr&       cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.cstr.AllocMaybe
acr_ed::FCstr*       cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.cstr.InsertMaybe
acr_ed::FCstr*       cstr_InsertMaybe(const dmmeta::Cstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.cstr.AllocMem
void*                cstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.cstr.EmptyQ
inline bool          cstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.cstr.Find
inline acr_ed::FCstr* cstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.cstr.Last
inline acr_ed::FCstr* cstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.cstr.N
inline i32           cstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.cstr.RemoveLast
void                 cstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.cstr.qFind
inline acr_ed::FCstr& cstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.cstr.XrefMaybe
bool                 cstr_XrefMaybe(acr_ed::FCstr &row);

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:acr_ed.FDb.vis.Addary
algo::aryptr<algo::cstring> vis_Addary(algo::aryptr<algo::cstring> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:acr_ed.FDb.vis.Alloc
algo::cstring&       vis_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:acr_ed.FDb.vis.AllocAt
algo::cstring&       vis_AllocAt(int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:acr_ed.FDb.vis.AllocN
algo::aryptr<algo::cstring> vis_AllocN(int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.vis.EmptyQ
inline bool          vis_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.vis.Find
inline algo::cstring* vis_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:acr_ed.FDb.vis.Getary
inline algo::aryptr<algo::cstring> vis_Getary() __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.vis.Last
inline algo::cstring* vis_Last() __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:acr_ed.FDb.vis.Max
inline i32           vis_Max() __attribute__((nothrow));
// Return number of items in the array
// func:acr_ed.FDb.vis.N
inline i32           vis_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:acr_ed.FDb.vis.Remove
void                 vis_Remove(u32 i) __attribute__((nothrow));
// func:acr_ed.FDb.vis.RemoveAll
void                 vis_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.vis.RemoveLast
void                 vis_RemoveLast() __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:acr_ed.FDb.vis.Reserve
inline void          vis_Reserve(int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:acr_ed.FDb.vis.AbsReserve
void                 vis_AbsReserve(int n) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.vis.qFind
inline algo::cstring& vis_qFind(u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:acr_ed.FDb.vis.qLast
inline algo::cstring& vis_qLast() __attribute__((nothrow));
// Return row id of specified element
// func:acr_ed.FDb.vis.rowid_Get
inline u64           vis_rowid_Get(algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:acr_ed.FDb.vis.AllocNVal
algo::aryptr<algo::cstring> vis_AllocNVal(int n_elems, const algo::cstring& val) __attribute__((nothrow));
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
// func:acr_ed.FDb.vis.ReadStrptrMaybe
bool                 vis_ReadStrptrMaybe(algo::strptr in_str) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.listtype.Alloc
acr_ed::FListtype&   listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.listtype.AllocMaybe
acr_ed::FListtype*   listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.listtype.InsertMaybe
acr_ed::FListtype*   listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.listtype.AllocMem
void*                listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.listtype.EmptyQ
inline bool          listtype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.listtype.Find
inline acr_ed::FListtype* listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.listtype.Last
inline acr_ed::FListtype* listtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.listtype.N
inline i32           listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.listtype.RemoveLast
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.listtype.qFind
inline acr_ed::FListtype& listtype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.listtype.XrefMaybe
bool                 listtype_XrefMaybe(acr_ed::FListtype &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_listtype.EmptyQ
inline bool          ind_listtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_listtype.Find
acr_ed::FListtype*   ind_listtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_listtype.FindX
acr_ed::FListtype&   ind_listtype_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr_ed.FDb.ind_listtype.GetOrCreate
acr_ed::FListtype&   ind_listtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr_ed.FDb.ind_listtype.N
inline i32           ind_listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_listtype.InsertMaybe
bool                 ind_listtype_InsertMaybe(acr_ed::FListtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_listtype.Remove
void                 ind_listtype_Remove(acr_ed::FListtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_listtype.Reserve
void                 ind_listtype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.fprefix.Alloc
acr_ed::FFprefix&    fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.fprefix.AllocMaybe
acr_ed::FFprefix*    fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.fprefix.InsertMaybe
acr_ed::FFprefix*    fprefix_InsertMaybe(const dmmeta::Fprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.fprefix.AllocMem
void*                fprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.fprefix.EmptyQ
inline bool          fprefix_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.fprefix.Find
inline acr_ed::FFprefix* fprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.fprefix.Last
inline acr_ed::FFprefix* fprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.fprefix.N
inline i32           fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.fprefix.RemoveLast
void                 fprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.fprefix.qFind
inline acr_ed::FFprefix& fprefix_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.fprefix.XrefMaybe
bool                 fprefix_XrefMaybe(acr_ed::FFprefix &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_fprefix.EmptyQ
inline bool          ind_fprefix_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_fprefix.Find
acr_ed::FFprefix*    ind_fprefix_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_fprefix.FindX
acr_ed::FFprefix&    ind_fprefix_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr_ed.FDb.ind_fprefix.GetOrCreate
acr_ed::FFprefix&    ind_fprefix_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr_ed.FDb.ind_fprefix.N
inline i32           ind_fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_fprefix.InsertMaybe
bool                 ind_fprefix_InsertMaybe(acr_ed::FFprefix& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_fprefix.Remove
void                 ind_fprefix_Remove(acr_ed::FFprefix& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_fprefix.Reserve
void                 ind_fprefix_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.target.Alloc
acr_ed::FTarget&     target_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.target.AllocMaybe
acr_ed::FTarget*     target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.target.InsertMaybe
acr_ed::FTarget*     target_InsertMaybe(const dev::Target &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.target.AllocMem
void*                target_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.target.EmptyQ
inline bool          target_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.target.Find
inline acr_ed::FTarget* target_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.target.Last
inline acr_ed::FTarget* target_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.target.N
inline i32           target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.target.RemoveLast
void                 target_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.target.qFind
inline acr_ed::FTarget& target_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.target.XrefMaybe
bool                 target_XrefMaybe(acr_ed::FTarget &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_target.EmptyQ
inline bool          ind_target_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_target.Find
acr_ed::FTarget*     ind_target_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_target.FindX
acr_ed::FTarget&     ind_target_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:acr_ed.FDb.ind_target.N
inline i32           ind_target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_target.InsertMaybe
bool                 ind_target_InsertMaybe(acr_ed::FTarget& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_target.Remove
void                 ind_target_Remove(acr_ed::FTarget& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_target.Reserve
void                 ind_target_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.targsrc.Alloc
acr_ed::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.targsrc.AllocMaybe
acr_ed::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.targsrc.InsertMaybe
acr_ed::FTargsrc*    targsrc_InsertMaybe(const dev::Targsrc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.targsrc.AllocMem
void*                targsrc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.targsrc.EmptyQ
inline bool          targsrc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.targsrc.Find
inline acr_ed::FTargsrc* targsrc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.targsrc.Last
inline acr_ed::FTargsrc* targsrc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.targsrc.N
inline i32           targsrc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.targsrc.RemoveAll
void                 targsrc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.targsrc.RemoveLast
void                 targsrc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.targsrc.qFind
inline acr_ed::FTargsrc& targsrc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.targsrc.XrefMaybe
bool                 targsrc_XrefMaybe(acr_ed::FTargsrc &row);

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
// func:acr_ed.FDb.abt.Start
int                  abt_Start() __attribute__((nothrow));
// Start subprocess & Read output
// func:acr_ed.FDb.abt.StartRead
algo::Fildes         abt_StartRead(algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
// func:acr_ed.FDb.abt.Kill
void                 abt_Kill();
// Wait for subprocess to return
// func:acr_ed.FDb.abt.Wait
void                 abt_Wait() __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
// func:acr_ed.FDb.abt.Exec
int                  abt_Exec() __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
// func:acr_ed.FDb.abt.ExecX
void                 abt_ExecX();
// Call execv()
// Call execv with specified parameters
// func:acr_ed.FDb.abt.Execv
int                  abt_Execv() __attribute__((nothrow));
// func:acr_ed.FDb.abt.ToCmdline
algo::tempstr        abt_ToCmdline() __attribute__((nothrow));
// Form array from the command line
// func:acr_ed.FDb.abt.ToArgv
void                 abt_ToArgv(algo::StringAry& args) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.sbpath.Alloc
acr_ed::FSbpath&     sbpath_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.sbpath.AllocMaybe
acr_ed::FSbpath*     sbpath_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.sbpath.InsertMaybe
acr_ed::FSbpath*     sbpath_InsertMaybe(const dev::Sbpath &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.sbpath.AllocMem
void*                sbpath_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.sbpath.EmptyQ
inline bool          sbpath_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.sbpath.Find
inline acr_ed::FSbpath* sbpath_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.sbpath.Last
inline acr_ed::FSbpath* sbpath_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.sbpath.N
inline i32           sbpath_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.sbpath.RemoveAll
void                 sbpath_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.sbpath.RemoveLast
void                 sbpath_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.sbpath.qFind
inline acr_ed::FSbpath& sbpath_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.sbpath.XrefMaybe
bool                 sbpath_XrefMaybe(acr_ed::FSbpath &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.pack.Alloc
acr_ed::FPack&       pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.pack.AllocMaybe
acr_ed::FPack*       pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.pack.InsertMaybe
acr_ed::FPack*       pack_InsertMaybe(const dmmeta::Pack &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.pack.AllocMem
void*                pack_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.pack.EmptyQ
inline bool          pack_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.pack.Find
inline acr_ed::FPack* pack_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.pack.Last
inline acr_ed::FPack* pack_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.pack.N
inline i32           pack_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.pack.RemoveAll
void                 pack_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.pack.RemoveLast
void                 pack_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.pack.qFind
inline acr_ed::FPack& pack_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.pack.XrefMaybe
bool                 pack_XrefMaybe(acr_ed::FPack &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.typefld.Alloc
acr_ed::FTypefld&    typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.typefld.AllocMaybe
acr_ed::FTypefld*    typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.typefld.InsertMaybe
acr_ed::FTypefld*    typefld_InsertMaybe(const dmmeta::Typefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.typefld.AllocMem
void*                typefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.typefld.EmptyQ
inline bool          typefld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.typefld.Find
inline acr_ed::FTypefld* typefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.typefld.Last
inline acr_ed::FTypefld* typefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.typefld.N
inline i32           typefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.typefld.RemoveAll
void                 typefld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.typefld.RemoveLast
void                 typefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.typefld.qFind
inline acr_ed::FTypefld& typefld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.typefld.XrefMaybe
bool                 typefld_XrefMaybe(acr_ed::FTypefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.cpptype.Alloc
acr_ed::FCpptype&    cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.cpptype.AllocMaybe
acr_ed::FCpptype*    cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.cpptype.InsertMaybe
acr_ed::FCpptype*    cpptype_InsertMaybe(const dmmeta::Cpptype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.cpptype.AllocMem
void*                cpptype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.cpptype.EmptyQ
inline bool          cpptype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.cpptype.Find
inline acr_ed::FCpptype* cpptype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.cpptype.Last
inline acr_ed::FCpptype* cpptype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.cpptype.N
inline i32           cpptype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.cpptype.RemoveAll
void                 cpptype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.cpptype.RemoveLast
void                 cpptype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.cpptype.qFind
inline acr_ed::FCpptype& cpptype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.cpptype.XrefMaybe
bool                 cpptype_XrefMaybe(acr_ed::FCpptype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.cfmt.Alloc
acr_ed::FCfmt&       cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.cfmt.AllocMaybe
acr_ed::FCfmt*       cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.cfmt.InsertMaybe
acr_ed::FCfmt*       cfmt_InsertMaybe(const dmmeta::Cfmt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.cfmt.AllocMem
void*                cfmt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.cfmt.EmptyQ
inline bool          cfmt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.cfmt.Find
inline acr_ed::FCfmt* cfmt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.cfmt.Last
inline acr_ed::FCfmt* cfmt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.cfmt.N
inline i32           cfmt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.cfmt.RemoveAll
void                 cfmt_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.cfmt.RemoveLast
void                 cfmt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.cfmt.qFind
inline acr_ed::FCfmt& cfmt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.cfmt.XrefMaybe
bool                 cfmt_XrefMaybe(acr_ed::FCfmt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.nsdb.Alloc
acr_ed::FNsdb&       nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.nsdb.AllocMaybe
acr_ed::FNsdb*       nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.nsdb.InsertMaybe
acr_ed::FNsdb*       nsdb_InsertMaybe(const dmmeta::Nsdb &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.nsdb.AllocMem
void*                nsdb_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.nsdb.EmptyQ
inline bool          nsdb_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.nsdb.Find
inline acr_ed::FNsdb* nsdb_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.nsdb.Last
inline acr_ed::FNsdb* nsdb_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.nsdb.N
inline i32           nsdb_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.nsdb.RemoveAll
void                 nsdb_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.nsdb.RemoveLast
void                 nsdb_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.nsdb.qFind
inline acr_ed::FNsdb& nsdb_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.nsdb.XrefMaybe
bool                 nsdb_XrefMaybe(acr_ed::FNsdb &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_nsdb.EmptyQ
inline bool          ind_nsdb_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_nsdb.Find
acr_ed::FNsdb*       ind_nsdb_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_nsdb.FindX
acr_ed::FNsdb&       ind_nsdb_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr_ed.FDb.ind_nsdb.GetOrCreate
acr_ed::FNsdb&       ind_nsdb_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr_ed.FDb.ind_nsdb.N
inline i32           ind_nsdb_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_nsdb.InsertMaybe
bool                 ind_nsdb_InsertMaybe(acr_ed::FNsdb& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_nsdb.Remove
void                 ind_nsdb_Remove(acr_ed::FNsdb& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_nsdb.Reserve
void                 ind_nsdb_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.edaction.Alloc
acr_ed::FEdaction&   edaction_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.edaction.AllocMaybe
acr_ed::FEdaction*   edaction_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.edaction.InsertMaybe
acr_ed::FEdaction*   edaction_InsertMaybe(const dev::Edaction &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.edaction.AllocMem
inline void*         edaction_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.edaction.EmptyQ
inline bool          edaction_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.edaction.Find
inline acr_ed::FEdaction* edaction_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:acr_ed.FDb.edaction.Getary
inline algo::aryptr<acr_ed::FEdaction> edaction_Getary() __attribute__((nothrow));
// Return constant 18 -- max. number of items in the pool
// func:acr_ed.FDb.edaction.Max
inline i32           edaction_Max() __attribute__((nothrow));
// Return number of items in the array
// func:acr_ed.FDb.edaction.N
inline i32           edaction_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:acr_ed.FDb.edaction.RemoveAll
void                 edaction_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.edaction.RemoveLast
void                 edaction_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:acr_ed.FDb.edaction.qFind
inline acr_ed::FEdaction& edaction_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:acr_ed.FDb.edaction.rowid_Get
inline u64           edaction_rowid_Get(acr_ed::FEdaction &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.edaction.XrefMaybe
bool                 edaction_XrefMaybe(acr_ed::FEdaction &row);

// Return true if hash is empty
// func:acr_ed.FDb.ind_edaction.EmptyQ
inline bool          ind_edaction_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr_ed.FDb.ind_edaction.Find
acr_ed::FEdaction*   ind_edaction_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:acr_ed.FDb.ind_edaction.FindX
acr_ed::FEdaction&   ind_edaction_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr_ed.FDb.ind_edaction.GetOrCreate
acr_ed::FEdaction&   ind_edaction_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr_ed.FDb.ind_edaction.N
inline i32           ind_edaction_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr_ed.FDb.ind_edaction.InsertMaybe
bool                 ind_edaction_InsertMaybe(acr_ed::FEdaction& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr_ed.FDb.ind_edaction.Remove
void                 ind_edaction_Remove(acr_ed::FEdaction& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr_ed.FDb.ind_edaction.Reserve
void                 ind_edaction_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr_ed.FDb.gitfile.Alloc
acr_ed::FGitfile&    gitfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr_ed.FDb.gitfile.AllocMaybe
acr_ed::FGitfile*    gitfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr_ed.FDb.gitfile.InsertMaybe
acr_ed::FGitfile*    gitfile_InsertMaybe(const dev::Gitfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr_ed.FDb.gitfile.AllocMem
void*                gitfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr_ed.FDb.gitfile.EmptyQ
inline bool          gitfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr_ed.FDb.gitfile.Find
inline acr_ed::FGitfile* gitfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr_ed.FDb.gitfile.Last
inline acr_ed::FGitfile* gitfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr_ed.FDb.gitfile.N
inline i32           gitfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr_ed.FDb.gitfile.RemoveAll
void                 gitfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr_ed.FDb.gitfile.RemoveLast
void                 gitfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr_ed.FDb.gitfile.qFind
inline acr_ed::FGitfile& gitfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr_ed.FDb.gitfile.XrefMaybe
bool                 gitfile_XrefMaybe(acr_ed::FGitfile &row);

// cursor points to valid item
// func:acr_ed.FDb.ns_curs.Reset
inline void          _db_ns_curs_Reset(_db_ns_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.ns_curs.ValidQ
inline bool          _db_ns_curs_ValidQ(_db_ns_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.ns_curs.Next
inline void          _db_ns_curs_Next(_db_ns_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.ns_curs.Access
inline acr_ed::FNs&  _db_ns_curs_Access(_db_ns_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.field_curs.Reset
inline void          _db_field_curs_Reset(_db_field_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.field_curs.ValidQ
inline bool          _db_field_curs_ValidQ(_db_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.field_curs.Next
inline void          _db_field_curs_Next(_db_field_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.field_curs.Access
inline acr_ed::FField& _db_field_curs_Access(_db_field_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.ctype_curs.Reset
inline void          _db_ctype_curs_Reset(_db_ctype_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.ctype_curs.ValidQ
inline bool          _db_ctype_curs_ValidQ(_db_ctype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.ctype_curs.Next
inline void          _db_ctype_curs_Next(_db_ctype_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.ctype_curs.Access
inline acr_ed::FCtype& _db_ctype_curs_Access(_db_ctype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.ssimfile_curs.Reset
inline void          _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.ssimfile_curs.ValidQ
inline bool          _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.ssimfile_curs.Next
inline void          _db_ssimfile_curs_Next(_db_ssimfile_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.ssimfile_curs.Access
inline acr_ed::FSsimfile& _db_ssimfile_curs_Access(_db_ssimfile_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.cstr_curs.Reset
inline void          _db_cstr_curs_Reset(_db_cstr_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.cstr_curs.ValidQ
inline bool          _db_cstr_curs_ValidQ(_db_cstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.cstr_curs.Next
inline void          _db_cstr_curs_Next(_db_cstr_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.cstr_curs.Access
inline acr_ed::FCstr& _db_cstr_curs_Access(_db_cstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.vis_curs.Next
inline void          _db_vis_curs_Next(_db_vis_curs &curs) __attribute__((nothrow));
// func:acr_ed.FDb.vis_curs.Reset
inline void          _db_vis_curs_Reset(_db_vis_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.vis_curs.ValidQ
inline bool          _db_vis_curs_ValidQ(_db_vis_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.vis_curs.Access
inline algo::cstring& _db_vis_curs_Access(_db_vis_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.listtype_curs.Reset
inline void          _db_listtype_curs_Reset(_db_listtype_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.listtype_curs.ValidQ
inline bool          _db_listtype_curs_ValidQ(_db_listtype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.listtype_curs.Next
inline void          _db_listtype_curs_Next(_db_listtype_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.listtype_curs.Access
inline acr_ed::FListtype& _db_listtype_curs_Access(_db_listtype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.fprefix_curs.Reset
inline void          _db_fprefix_curs_Reset(_db_fprefix_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.fprefix_curs.ValidQ
inline bool          _db_fprefix_curs_ValidQ(_db_fprefix_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.fprefix_curs.Next
inline void          _db_fprefix_curs_Next(_db_fprefix_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.fprefix_curs.Access
inline acr_ed::FFprefix& _db_fprefix_curs_Access(_db_fprefix_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.target_curs.Reset
inline void          _db_target_curs_Reset(_db_target_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.target_curs.ValidQ
inline bool          _db_target_curs_ValidQ(_db_target_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.target_curs.Next
inline void          _db_target_curs_Next(_db_target_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.target_curs.Access
inline acr_ed::FTarget& _db_target_curs_Access(_db_target_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.targsrc_curs.Reset
inline void          _db_targsrc_curs_Reset(_db_targsrc_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.targsrc_curs.ValidQ
inline bool          _db_targsrc_curs_ValidQ(_db_targsrc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.targsrc_curs.Next
inline void          _db_targsrc_curs_Next(_db_targsrc_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.targsrc_curs.Access
inline acr_ed::FTargsrc& _db_targsrc_curs_Access(_db_targsrc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.sbpath_curs.Reset
inline void          _db_sbpath_curs_Reset(_db_sbpath_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.sbpath_curs.ValidQ
inline bool          _db_sbpath_curs_ValidQ(_db_sbpath_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.sbpath_curs.Next
inline void          _db_sbpath_curs_Next(_db_sbpath_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.sbpath_curs.Access
inline acr_ed::FSbpath& _db_sbpath_curs_Access(_db_sbpath_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.pack_curs.Reset
inline void          _db_pack_curs_Reset(_db_pack_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.pack_curs.ValidQ
inline bool          _db_pack_curs_ValidQ(_db_pack_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.pack_curs.Next
inline void          _db_pack_curs_Next(_db_pack_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.pack_curs.Access
inline acr_ed::FPack& _db_pack_curs_Access(_db_pack_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.typefld_curs.Reset
inline void          _db_typefld_curs_Reset(_db_typefld_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.typefld_curs.ValidQ
inline bool          _db_typefld_curs_ValidQ(_db_typefld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.typefld_curs.Next
inline void          _db_typefld_curs_Next(_db_typefld_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.typefld_curs.Access
inline acr_ed::FTypefld& _db_typefld_curs_Access(_db_typefld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.cpptype_curs.Reset
inline void          _db_cpptype_curs_Reset(_db_cpptype_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.cpptype_curs.ValidQ
inline bool          _db_cpptype_curs_ValidQ(_db_cpptype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.cpptype_curs.Next
inline void          _db_cpptype_curs_Next(_db_cpptype_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.cpptype_curs.Access
inline acr_ed::FCpptype& _db_cpptype_curs_Access(_db_cpptype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.cfmt_curs.Reset
inline void          _db_cfmt_curs_Reset(_db_cfmt_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.cfmt_curs.ValidQ
inline bool          _db_cfmt_curs_ValidQ(_db_cfmt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.cfmt_curs.Next
inline void          _db_cfmt_curs_Next(_db_cfmt_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.cfmt_curs.Access
inline acr_ed::FCfmt& _db_cfmt_curs_Access(_db_cfmt_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.nsdb_curs.Reset
inline void          _db_nsdb_curs_Reset(_db_nsdb_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.nsdb_curs.ValidQ
inline bool          _db_nsdb_curs_ValidQ(_db_nsdb_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.nsdb_curs.Next
inline void          _db_nsdb_curs_Next(_db_nsdb_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.nsdb_curs.Access
inline acr_ed::FNsdb& _db_nsdb_curs_Access(_db_nsdb_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.edaction_curs.Reset
inline void          _db_edaction_curs_Reset(_db_edaction_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.edaction_curs.ValidQ
inline bool          _db_edaction_curs_ValidQ(_db_edaction_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.edaction_curs.Next
inline void          _db_edaction_curs_Next(_db_edaction_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.edaction_curs.Access
inline acr_ed::FEdaction& _db_edaction_curs_Access(_db_edaction_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.gitfile_curs.Reset
inline void          _db_gitfile_curs_Reset(_db_gitfile_curs &curs, acr_ed::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FDb.gitfile_curs.ValidQ
inline bool          _db_gitfile_curs_ValidQ(_db_gitfile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FDb.gitfile_curs.Next
inline void          _db_gitfile_curs_Next(_db_gitfile_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FDb.gitfile_curs.Access
inline acr_ed::FGitfile& _db_gitfile_curs_Access(_db_gitfile_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr_ed.FDb..Init
void                 FDb_Init();
// func:acr_ed.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));

// --- acr_ed.FField
// create: acr_ed.FDb.field (Lary)
// global access: field (Lary, by rowid)
// global access: ind_field (Thash, hash field field)
// access: acr_ed.FCtype.c_field (Ptrary)
struct FField { // acr_ed.FField
    acr_ed::FField*     ind_field_next;         // hash next
    algo::Smallstr100   field;                  // Primary key, as ctype.name
    algo::Smallstr100   arg;                    // Type of field
    algo::Smallstr50    reftype;                //   "Val"  Type constructor
    algo::CppExpr       dflt;                   // Default value (c++ expression)
    algo::Comment       comment;                //
    acr_ed::FCtype*     p_ctype;                // reference to parent row
    acr_ed::FCtype*     p_arg;                  // reference to parent row
    acr_ed::FNs*        p_ns;                   // reference to parent row
    bool                ctype_c_field_in_ary;   //   false  membership flag
    // x-reference on acr_ed.FField.p_ctype prevents copy
    // x-reference on acr_ed.FField.p_arg prevents copy
    // x-reference on acr_ed.FField.p_ns prevents copy
    // func:acr_ed.FField..AssignOp
    acr_ed::FField&      operator =(const acr_ed::FField &rhs) = delete;
    // x-reference on acr_ed.FField.p_ctype prevents copy
    // x-reference on acr_ed.FField.p_arg prevents copy
    // x-reference on acr_ed.FField.p_ns prevents copy
    // func:acr_ed.FField..CopyCtor
    FField(const acr_ed::FField &rhs) = delete;
private:
    // func:acr_ed.FField..Ctor
    inline               FField() __attribute__((nothrow));
    // func:acr_ed.FField..Dtor
    inline               ~FField() __attribute__((nothrow));
    friend acr_ed::FField&      field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FField*      field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FField.msghdr.CopyOut
void                 field_CopyOut(acr_ed::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FField.msghdr.CopyIn
void                 field_CopyIn(acr_ed::FField &row, dmmeta::Field &in) __attribute__((nothrow));

// func:acr_ed.FField.ctype.Get
algo::Smallstr100    ctype_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FField.ns.Get
algo::Smallstr16     ns_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FField.name.Get
algo::Smallstr50     name_Get(acr_ed::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr_ed.FField..Init
void                 FField_Init(acr_ed::FField& field);
// func:acr_ed.FField..Uninit
void                 FField_Uninit(acr_ed::FField& field) __attribute__((nothrow));

// --- acr_ed.FFprefix
// create: acr_ed.FDb.fprefix (Lary)
// global access: fprefix (Lary, by rowid)
// global access: ind_fprefix (Thash, hash field fprefix)
struct FFprefix { // acr_ed.FFprefix
    acr_ed::FFprefix*   ind_fprefix_next;   // hash next
    algo::Smallstr5     fprefix;            //
    algo::Smallstr50    reftype;            //
    algo::Comment       comment;            //
    // func:acr_ed.FFprefix..AssignOp
    inline acr_ed::FFprefix& operator =(const acr_ed::FFprefix &rhs) = delete;
    // func:acr_ed.FFprefix..CopyCtor
    inline               FFprefix(const acr_ed::FFprefix &rhs) = delete;
private:
    // func:acr_ed.FFprefix..Ctor
    inline               FFprefix() __attribute__((nothrow));
    // func:acr_ed.FFprefix..Dtor
    inline               ~FFprefix() __attribute__((nothrow));
    friend acr_ed::FFprefix&    fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FFprefix*    fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fprefix_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FFprefix.base.CopyOut
void                 fprefix_CopyOut(acr_ed::FFprefix &row, dmmeta::Fprefix &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FFprefix.base.CopyIn
void                 fprefix_CopyIn(acr_ed::FFprefix &row, dmmeta::Fprefix &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FFprefix..Init
inline void          FFprefix_Init(acr_ed::FFprefix& fprefix);
// func:acr_ed.FFprefix..Uninit
void                 FFprefix_Uninit(acr_ed::FFprefix& fprefix) __attribute__((nothrow));

// --- acr_ed.FGitfile
// create: acr_ed.FDb.gitfile (Lary)
// global access: gitfile (Lary, by rowid)
struct FGitfile { // acr_ed.FGitfile
    algo::Smallstr200   gitfile;   //
private:
    // func:acr_ed.FGitfile..Ctor
    inline               FGitfile() __attribute__((nothrow));
    friend acr_ed::FGitfile&    gitfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FGitfile*    gitfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gitfile_RemoveAll() __attribute__((nothrow));
    friend void                 gitfile_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FGitfile.base.CopyOut
void                 gitfile_CopyOut(acr_ed::FGitfile &row, dev::Gitfile &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FGitfile.base.CopyIn
void                 gitfile_CopyIn(acr_ed::FGitfile &row, dev::Gitfile &in) __attribute__((nothrow));

// func:acr_ed.FGitfile.ext.Get
algo::Smallstr50     ext_Get(acr_ed::FGitfile& gitfile) __attribute__((__warn_unused_result__, nothrow));


// --- acr_ed.FListtype
// create: acr_ed.FDb.listtype (Lary)
// global access: listtype (Lary, by rowid)
// global access: ind_listtype (Thash, hash field listtype)
struct FListtype { // acr_ed.FListtype
    acr_ed::FListtype*   ind_listtype_next;   // hash next
    algo::Smallstr5      listtype;            //
    bool                 circular;            //   false  Circular list
    bool                 haveprev;            //   false  Previous link
    bool                 instail;             //   false  Queue
    algo::Comment        comment;             //
    // func:acr_ed.FListtype..AssignOp
    inline acr_ed::FListtype& operator =(const acr_ed::FListtype &rhs) = delete;
    // func:acr_ed.FListtype..CopyCtor
    inline               FListtype(const acr_ed::FListtype &rhs) = delete;
private:
    // func:acr_ed.FListtype..Ctor
    inline               FListtype() __attribute__((nothrow));
    // func:acr_ed.FListtype..Dtor
    inline               ~FListtype() __attribute__((nothrow));
    friend acr_ed::FListtype&   listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FListtype*   listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 listtype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FListtype.msghdr.CopyOut
void                 listtype_CopyOut(acr_ed::FListtype &row, dmmeta::Listtype &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FListtype.msghdr.CopyIn
void                 listtype_CopyIn(acr_ed::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FListtype..Init
inline void          FListtype_Init(acr_ed::FListtype& listtype);
// func:acr_ed.FListtype..Uninit
void                 FListtype_Uninit(acr_ed::FListtype& listtype) __attribute__((nothrow));

// --- acr_ed.FNs
// create: acr_ed.FDb.ns (Lary)
// global access: ns (Lary, by rowid)
// global access: ind_ns (Thash, hash field ns)
// access: acr_ed.FCtype.p_ns (Upptr)
// access: acr_ed.FField.p_ns (Upptr)
// access: acr_ed.FSsimfile.p_ns (Upptr)
// access: acr_ed.FTarget.p_ns (Upptr)
struct FNs { // acr_ed.FNs
    acr_ed::FNs*       ind_ns_next;   // hash next
    algo::Smallstr16   ns;            // Namespace name (primary key)
    algo::Smallstr50   nstype;        // Namespace type
    algo::Smallstr50   license;       // Associated license
    algo::Comment      comment;       //
    // func:acr_ed.FNs..AssignOp
    inline acr_ed::FNs&  operator =(const acr_ed::FNs &rhs) = delete;
    // func:acr_ed.FNs..CopyCtor
    inline               FNs(const acr_ed::FNs &rhs) = delete;
private:
    // func:acr_ed.FNs..Ctor
    inline               FNs() __attribute__((nothrow));
    // func:acr_ed.FNs..Dtor
    inline               ~FNs() __attribute__((nothrow));
    friend acr_ed::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FNs.msghdr.CopyOut
void                 ns_CopyOut(acr_ed::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FNs.msghdr.CopyIn
void                 ns_CopyIn(acr_ed::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FNs..Init
inline void          FNs_Init(acr_ed::FNs& ns);
// func:acr_ed.FNs..Uninit
void                 FNs_Uninit(acr_ed::FNs& ns) __attribute__((nothrow));

// --- acr_ed.FNsdb
// create: acr_ed.FDb.nsdb (Lary)
// global access: nsdb (Lary, by rowid)
// global access: ind_nsdb (Thash, hash field ns)
struct FNsdb { // acr_ed.FNsdb
    acr_ed::FNsdb*     ind_nsdb_next;   // hash next
    algo::Smallstr16   ns;              //
    algo::Comment      comment;         //
    // func:acr_ed.FNsdb..AssignOp
    inline acr_ed::FNsdb& operator =(const acr_ed::FNsdb &rhs) = delete;
    // func:acr_ed.FNsdb..CopyCtor
    inline               FNsdb(const acr_ed::FNsdb &rhs) = delete;
private:
    // func:acr_ed.FNsdb..Ctor
    inline               FNsdb() __attribute__((nothrow));
    // func:acr_ed.FNsdb..Dtor
    inline               ~FNsdb() __attribute__((nothrow));
    friend acr_ed::FNsdb&       nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FNsdb*       nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsdb_RemoveAll() __attribute__((nothrow));
    friend void                 nsdb_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FNsdb.base.CopyOut
void                 nsdb_CopyOut(acr_ed::FNsdb &row, dmmeta::Nsdb &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FNsdb.base.CopyIn
void                 nsdb_CopyIn(acr_ed::FNsdb &row, dmmeta::Nsdb &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr_ed.FNsdb..Init
inline void          FNsdb_Init(acr_ed::FNsdb& nsdb);
// func:acr_ed.FNsdb..Uninit
void                 FNsdb_Uninit(acr_ed::FNsdb& nsdb) __attribute__((nothrow));

// --- acr_ed.FPack
// create: acr_ed.FDb.pack (Lary)
// global access: pack (Lary, by rowid)
// access: acr_ed.FCtype.c_pack (Ptr)
struct FPack { // acr_ed.FPack
    algo::Smallstr100   ctype;     // Target ctype
    algo::Comment       comment;   //
    // func:acr_ed.FPack..AssignOp
    inline acr_ed::FPack& operator =(const acr_ed::FPack &rhs) = delete;
    // func:acr_ed.FPack..CopyCtor
    inline               FPack(const acr_ed::FPack &rhs) = delete;
private:
    // func:acr_ed.FPack..Ctor
    inline               FPack() __attribute__((nothrow));
    // func:acr_ed.FPack..Dtor
    inline               ~FPack() __attribute__((nothrow));
    friend acr_ed::FPack&       pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FPack*       pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pack_RemoveAll() __attribute__((nothrow));
    friend void                 pack_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FPack.base.CopyOut
void                 pack_CopyOut(acr_ed::FPack &row, dmmeta::Pack &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FPack.base.CopyIn
void                 pack_CopyIn(acr_ed::FPack &row, dmmeta::Pack &in) __attribute__((nothrow));

// func:acr_ed.FPack..Uninit
void                 FPack_Uninit(acr_ed::FPack& pack) __attribute__((nothrow));

// --- acr_ed.FSbpath
// create: acr_ed.FDb.sbpath (Lary)
// global access: sbpath (Lary, by rowid)
struct FSbpath { // acr_ed.FSbpath
    algo::Smallstr50   sbpath;    //
    algo::Comment      comment;   //
private:
    // func:acr_ed.FSbpath..Ctor
    inline               FSbpath() __attribute__((nothrow));
    friend acr_ed::FSbpath&     sbpath_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FSbpath*     sbpath_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 sbpath_RemoveAll() __attribute__((nothrow));
    friend void                 sbpath_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FSbpath.base.CopyOut
void                 sbpath_CopyOut(acr_ed::FSbpath &row, dev::Sbpath &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FSbpath.base.CopyIn
void                 sbpath_CopyIn(acr_ed::FSbpath &row, dev::Sbpath &in) __attribute__((nothrow));


// --- acr_ed.FSsimfile
// create: acr_ed.FDb.ssimfile (Lary)
// global access: ssimfile (Lary, by rowid)
// global access: ind_ssimfile (Thash, hash field ssimfile)
// access: acr_ed.FCtype.c_ssimfile (Ptr)
struct FSsimfile { // acr_ed.FSsimfile
    acr_ed::FSsimfile*   ind_ssimfile_next;   // hash next
    algo::Smallstr50     ssimfile;            //
    algo::Smallstr100    ctype;               //
    acr_ed::FCtype*      p_ctype;             // reference to parent row
    acr_ed::FNs*         p_ns;                // reference to parent row
    // x-reference on acr_ed.FSsimfile.p_ctype prevents copy
    // x-reference on acr_ed.FSsimfile.p_ns prevents copy
    // func:acr_ed.FSsimfile..AssignOp
    inline acr_ed::FSsimfile& operator =(const acr_ed::FSsimfile &rhs) = delete;
    // x-reference on acr_ed.FSsimfile.p_ctype prevents copy
    // x-reference on acr_ed.FSsimfile.p_ns prevents copy
    // func:acr_ed.FSsimfile..CopyCtor
    inline               FSsimfile(const acr_ed::FSsimfile &rhs) = delete;
private:
    // func:acr_ed.FSsimfile..Ctor
    inline               FSsimfile() __attribute__((nothrow));
    // func:acr_ed.FSsimfile..Dtor
    inline               ~FSsimfile() __attribute__((nothrow));
    friend acr_ed::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FSsimfile.msghdr.CopyOut
void                 ssimfile_CopyOut(acr_ed::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FSsimfile.msghdr.CopyIn
void                 ssimfile_CopyIn(acr_ed::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

// func:acr_ed.FSsimfile.ssimns.Get
algo::Smallstr16     ssimns_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FSsimfile.ns.Get
algo::Smallstr16     ns_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FSsimfile.name.Get
algo::Smallstr50     name_Get(acr_ed::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr_ed.FSsimfile..Init
inline void          FSsimfile_Init(acr_ed::FSsimfile& ssimfile);
// func:acr_ed.FSsimfile..Uninit
void                 FSsimfile_Uninit(acr_ed::FSsimfile& ssimfile) __attribute__((nothrow));

// --- acr_ed.FTarget
// create: acr_ed.FDb.target (Lary)
// global access: target (Lary, by rowid)
// global access: ind_target (Thash, hash field target)
// access: acr_ed.FTargsrc.p_target (Upptr)
struct FTarget { // acr_ed.FTarget
    acr_ed::FTarget*    ind_target_next;   // hash next
    algo::Smallstr16    target;            // Primary key - name of target
    u32                 score;             //   0  For guessing target from source file
    acr_ed::FTargsrc*   zd_targsrc_head;   // zero-terminated doubly linked list
    i32                 zd_targsrc_n;      // zero-terminated doubly linked list
    acr_ed::FTargsrc*   zd_targsrc_tail;   // pointer to last element
    acr_ed::FNs*        p_ns;              // reference to parent row
    // reftype Llist of acr_ed.FTarget.zd_targsrc prohibits copy
    // x-reference on acr_ed.FTarget.p_ns prevents copy
    // func:acr_ed.FTarget..AssignOp
    inline acr_ed::FTarget& operator =(const acr_ed::FTarget &rhs) = delete;
    // reftype Llist of acr_ed.FTarget.zd_targsrc prohibits copy
    // x-reference on acr_ed.FTarget.p_ns prevents copy
    // func:acr_ed.FTarget..CopyCtor
    inline               FTarget(const acr_ed::FTarget &rhs) = delete;
private:
    // func:acr_ed.FTarget..Ctor
    inline               FTarget() __attribute__((nothrow));
    // func:acr_ed.FTarget..Dtor
    inline               ~FTarget() __attribute__((nothrow));
    friend acr_ed::FTarget&     target_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTarget*     target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 target_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FTarget.base.CopyOut
void                 target_CopyOut(acr_ed::FTarget &row, dev::Target &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FTarget.base.CopyIn
void                 target_CopyIn(acr_ed::FTarget &row, dev::Target &in) __attribute__((nothrow));

// Return true if index is empty
// func:acr_ed.FTarget.zd_targsrc.EmptyQ
inline bool          zd_targsrc_EmptyQ(acr_ed::FTarget& target) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr_ed.FTarget.zd_targsrc.First
inline acr_ed::FTargsrc* zd_targsrc_First(acr_ed::FTarget& target) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr_ed.FTarget.zd_targsrc.InLlistQ
inline bool          zd_targsrc_InLlistQ(acr_ed::FTargsrc& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr_ed.FTarget.zd_targsrc.Insert
void                 zd_targsrc_Insert(acr_ed::FTarget& target, acr_ed::FTargsrc& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr_ed.FTarget.zd_targsrc.Last
inline acr_ed::FTargsrc* zd_targsrc_Last(acr_ed::FTarget& target) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:acr_ed.FTarget.zd_targsrc.N
inline i32           zd_targsrc_N(const acr_ed::FTarget& target) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr_ed.FTarget.zd_targsrc.Next
inline acr_ed::FTargsrc* zd_targsrc_Next(acr_ed::FTargsrc &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr_ed.FTarget.zd_targsrc.Prev
inline acr_ed::FTargsrc* zd_targsrc_Prev(acr_ed::FTargsrc &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr_ed.FTarget.zd_targsrc.Remove
void                 zd_targsrc_Remove(acr_ed::FTarget& target, acr_ed::FTargsrc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr_ed.FTarget.zd_targsrc.RemoveAll
void                 zd_targsrc_RemoveAll(acr_ed::FTarget& target) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr_ed.FTarget.zd_targsrc.RemoveFirst
acr_ed::FTargsrc*    zd_targsrc_RemoveFirst(acr_ed::FTarget& target) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr_ed.FTarget.zd_targsrc.qLast
inline acr_ed::FTargsrc& zd_targsrc_qLast(acr_ed::FTarget& target) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr_ed.FTarget..Init
inline void          FTarget_Init(acr_ed::FTarget& target);
// cursor points to valid item
// func:acr_ed.FTarget.zd_targsrc_curs.Reset
inline void          target_zd_targsrc_curs_Reset(target_zd_targsrc_curs &curs, acr_ed::FTarget &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr_ed.FTarget.zd_targsrc_curs.ValidQ
inline bool          target_zd_targsrc_curs_ValidQ(target_zd_targsrc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr_ed.FTarget.zd_targsrc_curs.Next
inline void          target_zd_targsrc_curs_Next(target_zd_targsrc_curs &curs) __attribute__((nothrow));
// item access
// func:acr_ed.FTarget.zd_targsrc_curs.Access
inline acr_ed::FTargsrc& target_zd_targsrc_curs_Access(target_zd_targsrc_curs &curs) __attribute__((nothrow));
// func:acr_ed.FTarget..Uninit
void                 FTarget_Uninit(acr_ed::FTarget& target) __attribute__((nothrow));

// --- acr_ed.FTargsrc
// create: acr_ed.FDb.targsrc (Lary)
// global access: targsrc (Lary, by rowid)
// access: acr_ed.FTarget.zd_targsrc (Llist)
struct FTargsrc { // acr_ed.FTargsrc
    acr_ed::FTargsrc*   zd_targsrc_next;   // zslist link; -1 means not-in-list
    acr_ed::FTargsrc*   zd_targsrc_prev;   // previous element
    algo::Smallstr100   targsrc;           //
    algo::Comment       comment;           //
    acr_ed::FTarget*    p_target;          // reference to parent row
    // x-reference on acr_ed.FTargsrc.p_target prevents copy
    // func:acr_ed.FTargsrc..AssignOp
    inline acr_ed::FTargsrc& operator =(const acr_ed::FTargsrc &rhs) = delete;
    // x-reference on acr_ed.FTargsrc.p_target prevents copy
    // func:acr_ed.FTargsrc..CopyCtor
    inline               FTargsrc(const acr_ed::FTargsrc &rhs) = delete;
private:
    // func:acr_ed.FTargsrc..Ctor
    inline               FTargsrc() __attribute__((nothrow));
    // func:acr_ed.FTargsrc..Dtor
    inline               ~FTargsrc() __attribute__((nothrow));
    friend acr_ed::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targsrc_RemoveAll() __attribute__((nothrow));
    friend void                 targsrc_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FTargsrc.base.CopyOut
void                 targsrc_CopyOut(acr_ed::FTargsrc &row, dev::Targsrc &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FTargsrc.base.CopyIn
void                 targsrc_CopyIn(acr_ed::FTargsrc &row, dev::Targsrc &in) __attribute__((nothrow));

// func:acr_ed.FTargsrc.target.Get
algo::Smallstr16     target_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FTargsrc.src.Get
algo::Smallstr200    src_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FTargsrc.ext.Get
algo::Smallstr10     ext_Get(acr_ed::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr_ed.FTargsrc..Init
inline void          FTargsrc_Init(acr_ed::FTargsrc& targsrc);
// func:acr_ed.FTargsrc..Uninit
void                 FTargsrc_Uninit(acr_ed::FTargsrc& targsrc) __attribute__((nothrow));

// --- acr_ed.FTypefld
// create: acr_ed.FDb.typefld (Lary)
// global access: typefld (Lary, by rowid)
// access: acr_ed.FCtype.c_typefld (Ptr)
struct FTypefld { // acr_ed.FTypefld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:acr_ed.FTypefld..AssignOp
    inline acr_ed::FTypefld& operator =(const acr_ed::FTypefld &rhs) = delete;
    // func:acr_ed.FTypefld..CopyCtor
    inline               FTypefld(const acr_ed::FTypefld &rhs) = delete;
private:
    // func:acr_ed.FTypefld..Ctor
    inline               FTypefld() __attribute__((nothrow));
    // func:acr_ed.FTypefld..Dtor
    inline               ~FTypefld() __attribute__((nothrow));
    friend acr_ed::FTypefld&    typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr_ed::FTypefld*    typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typefld_RemoveAll() __attribute__((nothrow));
    friend void                 typefld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr_ed.FTypefld.base.CopyOut
void                 typefld_CopyOut(acr_ed::FTypefld &row, dmmeta::Typefld &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr_ed.FTypefld.base.CopyIn
void                 typefld_CopyIn(acr_ed::FTypefld &row, dmmeta::Typefld &in) __attribute__((nothrow));

// func:acr_ed.FTypefld.ctype.Get
algo::Smallstr100    ctype_Get(acr_ed::FTypefld& typefld) __attribute__((__warn_unused_result__, nothrow));

// func:acr_ed.FTypefld..Uninit
void                 FTypefld_Uninit(acr_ed::FTypefld& typefld) __attribute__((nothrow));

// --- acr_ed.FieldId
#pragma pack(push,1)
struct FieldId { // acr_ed.FieldId: Field read helper
    i32   value;   //   -1
    // func:acr_ed.FieldId.value.Cast
    inline               operator acr_ed_FieldIdEnum() const __attribute__((nothrow));
    // func:acr_ed.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:acr_ed.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:acr_ed.FieldId..EnumCtor
    inline               FieldId(acr_ed_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:acr_ed.FieldId.value.GetEnum
inline acr_ed_FieldIdEnum value_GetEnum(const acr_ed::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:acr_ed.FieldId.value.SetEnum
inline void          value_SetEnum(acr_ed::FieldId& parent, acr_ed_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:acr_ed.FieldId.value.ToCstr
const char*          value_ToCstr(const acr_ed::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:acr_ed.FieldId.value.Print
void                 value_Print(const acr_ed::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:acr_ed.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:acr_ed.FieldId.value.SetStrptr
void                 value_SetStrptr(acr_ed::FieldId& parent, algo::strptr rhs, acr_ed_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:acr_ed.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(acr_ed::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr_ed::FieldId from an ascii string.
// The format of the string is the format of the acr_ed::FieldId's only field
// func:acr_ed.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(acr_ed::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr_ed.FieldId..Init
inline void          FieldId_Init(acr_ed::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:acr_ed.FieldId.String  printfmt:Raw
// func:acr_ed.FieldId..Print
void                 FieldId_Print(acr_ed::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- acr_ed.TableId
struct TableId { // acr_ed.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    // func:acr_ed.TableId.value.Cast
    inline               operator acr_ed_TableIdEnum() const __attribute__((nothrow));
    // func:acr_ed.TableId..Ctor
    inline               TableId() __attribute__((nothrow));
    // func:acr_ed.TableId..FieldwiseCtor
    explicit inline               TableId(i32 in_value) __attribute__((nothrow));
    // func:acr_ed.TableId..EnumCtor
    inline               TableId(acr_ed_TableIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:acr_ed.TableId.value.GetEnum
inline acr_ed_TableIdEnum value_GetEnum(const acr_ed::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:acr_ed.TableId.value.SetEnum
inline void          value_SetEnum(acr_ed::TableId& parent, acr_ed_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:acr_ed.TableId.value.ToCstr
const char*          value_ToCstr(const acr_ed::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:acr_ed.TableId.value.Print
void                 value_Print(const acr_ed::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:acr_ed.TableId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:acr_ed.TableId.value.SetStrptr
void                 value_SetStrptr(acr_ed::TableId& parent, algo::strptr rhs, acr_ed_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:acr_ed.TableId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(acr_ed::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr_ed::TableId from an ascii string.
// The format of the string is the format of the acr_ed::TableId's only field
// func:acr_ed.TableId..ReadStrptrMaybe
bool                 TableId_ReadStrptrMaybe(acr_ed::TableId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr_ed.TableId..Init
inline void          TableId_Init(acr_ed::TableId& parent);
// print string representation of ROW to string STR
// cfmt:acr_ed.TableId.String  printfmt:Raw
// func:acr_ed.TableId..Print
void                 TableId_Print(acr_ed::TableId& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace acr_ed { // gen:ns_curstext

struct ctype_c_field_curs {// fcurs:acr_ed.FCtype.c_field/curs
    typedef acr_ed::FField ChildType;
    acr_ed::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_cfmt_curs {// fcurs:acr_ed.FCtype.c_cfmt/curs
    typedef acr_ed::FCfmt ChildType;
    acr_ed::FCfmt** elems;
    u32 n_elems;
    u32 index;
    ctype_c_cfmt_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_ns_curs {// cursor
    typedef acr_ed::FNs ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef acr_ed::FField ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_ctype_curs {// cursor
    typedef acr_ed::FCtype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef acr_ed::FSsimfile ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_cstr_curs {// cursor
    typedef acr_ed::FCstr ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cstr_curs(){ parent=NULL; index=0; }
};


struct _db_vis_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    _db_vis_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_listtype_curs {// cursor
    typedef acr_ed::FListtype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_listtype_curs(){ parent=NULL; index=0; }
};


struct _db_fprefix_curs {// cursor
    typedef acr_ed::FFprefix ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_fprefix_curs(){ parent=NULL; index=0; }
};


struct _db_target_curs {// cursor
    typedef acr_ed::FTarget ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_target_curs(){ parent=NULL; index=0; }
};


struct _db_targsrc_curs {// cursor
    typedef acr_ed::FTargsrc ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_targsrc_curs(){ parent=NULL; index=0; }
};


struct _db_sbpath_curs {// cursor
    typedef acr_ed::FSbpath ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_sbpath_curs(){ parent=NULL; index=0; }
};


struct _db_pack_curs {// cursor
    typedef acr_ed::FPack ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_pack_curs(){ parent=NULL; index=0; }
};


struct _db_typefld_curs {// cursor
    typedef acr_ed::FTypefld ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_typefld_curs(){ parent=NULL; index=0; }
};


struct _db_cpptype_curs {// cursor
    typedef acr_ed::FCpptype ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cpptype_curs(){ parent=NULL; index=0; }
};


struct _db_cfmt_curs {// cursor
    typedef acr_ed::FCfmt ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_cfmt_curs(){ parent=NULL; index=0; }
};


struct _db_nsdb_curs {// cursor
    typedef acr_ed::FNsdb ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_nsdb_curs(){ parent=NULL; index=0; }
};


struct _db_edaction_curs {// cursor
    typedef acr_ed::FEdaction ChildType;
    int index;
    acr_ed::FDb *parent;
    _db_edaction_curs() { parent=NULL; index=0; }
};


struct _db_gitfile_curs {// cursor
    typedef acr_ed::FGitfile ChildType;
    acr_ed::FDb *parent;
    i64 index;
    _db_gitfile_curs(){ parent=NULL; index=0; }
};


struct target_zd_targsrc_curs {// fcurs:acr_ed.FTarget.zd_targsrc/curs
    typedef acr_ed::FTargsrc ChildType;
    acr_ed::FTargsrc* row;
    target_zd_targsrc_curs() {
        row = NULL;
    }
};

} // gen:ns_curstext
namespace acr_ed { // gen:ns_func
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Citest
// this function is 'extrn' and implemented by user
void                 edaction_Create_Citest();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Ctype
// this function is 'extrn' and implemented by user
void                 edaction_Create_Ctype();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Field
// this function is 'extrn' and implemented by user
void                 edaction_Create_Field();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Finput
// this function is 'extrn' and implemented by user
void                 edaction_Create_Finput();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Srcfile
// this function is 'extrn' and implemented by user
void                 edaction_Create_Srcfile();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Ssimfile
// this function is 'extrn' and implemented by user
void                 edaction_Create_Ssimfile();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Target
// this function is 'extrn' and implemented by user
void                 edaction_Create_Target();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Create_Unittest
// this function is 'extrn' and implemented by user
void                 edaction_Create_Unittest();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Delete_Ctype
// this function is 'extrn' and implemented by user
void                 edaction_Delete_Ctype();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Delete_Field
// this function is 'extrn' and implemented by user
void                 edaction_Delete_Field();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Delete_Srcfile
// this function is 'extrn' and implemented by user
void                 edaction_Delete_Srcfile();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Delete_Ssimfile
// this function is 'extrn' and implemented by user
void                 edaction_Delete_Ssimfile();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Delete_Target
// this function is 'extrn' and implemented by user
void                 edaction_Delete_Target();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Rename_Ctype
// this function is 'extrn' and implemented by user
void                 edaction_Rename_Ctype();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Rename_Field
// this function is 'extrn' and implemented by user
void                 edaction_Rename_Field();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Rename_Srcfile
// this function is 'extrn' and implemented by user
void                 edaction_Rename_Srcfile();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Rename_Ssimfile
// this function is 'extrn' and implemented by user
void                 edaction_Rename_Ssimfile();
// User-implemented function from gstatic:acr_ed.FDb.edaction
// func:acr_ed...edaction_Rename_Target
// this function is 'extrn' and implemented by user
void                 edaction_Rename_Target();
// func:acr_ed...StaticCheck
void                 StaticCheck();
} // gen:ns_func
// func:acr_ed...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:acr_ed...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::trace &row);// cfmt:acr_ed.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::FieldId &row);// cfmt:acr_ed.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const acr_ed::TableId &row);// cfmt:acr_ed.TableId.String
}
