//
// include/gen/http_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude

// --- http.ExtensionHeader..Ctor
inline  http::ExtensionHeader::ExtensionHeader() {
}

// --- http.FieldId.value.GetEnum
// Get value of field as enum type
inline http_FieldIdEnum http::value_GetEnum(const http::FieldId& parent) {
    return http_FieldIdEnum(parent.value);
}

// --- http.FieldId.value.SetEnum
// Set value of field from enum type.
inline void http::value_SetEnum(http::FieldId& parent, http_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- http.FieldId.value.Cast
inline  http::FieldId::operator http_FieldIdEnum() const {
    return http_FieldIdEnum((*this).value);
}

// --- http.FieldId..Init
// Set all fields to initial values.
inline void http::FieldId_Init(http::FieldId& parent) {
    parent.value = i32(-1);
}

// --- http.FieldId..Ctor
inline  http::FieldId::FieldId() {
    http::FieldId_Init(*this);
}

// --- http.FieldId..FieldwiseCtor
inline  http::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- http.FieldId..EnumCtor
inline  http::FieldId::FieldId(http_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- http.HeaderType.value.GetEnum
// Get value of field as enum type
inline http_HeaderTypeEnum http::value_GetEnum(const http::HeaderType& parent) {
    return http_HeaderTypeEnum(parent.value);
}

// --- http.HeaderType.value.SetEnum
// Set value of field from enum type.
inline void http::value_SetEnum(http::HeaderType& parent, http_HeaderTypeEnum rhs) {
    parent.value = u16(rhs);
}

// --- http.HeaderType..Init
// Set all fields to initial values.
inline void http::HeaderType_Init(http::HeaderType& parent) {
    parent.value = u16(0);
}

// --- http.HeaderType..Ctor
inline  http::HeaderType::HeaderType() {
    http::HeaderType_Init(*this);
}

// --- http.HeaderType..EnumCtor
inline  http::HeaderType::HeaderType(http_HeaderTypeEnum arg) {
    this->value = u16(arg);
}

// --- http.Method.value.GetEnum
// Get value of field as enum type
inline http_MethodEnum http::value_GetEnum(const http::Method& parent) {
    return http_MethodEnum(parent.value);
}

// --- http.Method.value.SetEnum
// Set value of field from enum type.
inline void http::value_SetEnum(http::Method& parent, http_MethodEnum rhs) {
    parent.value = u8(rhs);
}

// --- http.Method..Init
// Set all fields to initial values.
inline void http::Method_Init(http::Method& parent) {
    parent.value = u8(0);
}

// --- http.Method..Ctor
inline  http::Method::Method() {
    http::Method_Init(*this);
}

// --- http.Method..EnumCtor
inline  http::Method::Method(http_MethodEnum arg) {
    this->value = u8(arg);
}

// --- http.Request.extension_header.EmptyQ
// Return true if index is empty
inline bool http::extension_header_EmptyQ(http::Request& parent) {
    return parent.extension_header_n == 0;
}

// --- http.Request.extension_header.Find
// Look up row by row id. Return NULL if out of range
inline http::ExtensionHeader* http::extension_header_Find(http::Request& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.extension_header_n;
    if (idx >= lim) return NULL;
    return parent.extension_header_elems + idx;
}

// --- http.Request.extension_header.Getary
// Return array pointer by value
inline algo::aryptr<http::ExtensionHeader> http::extension_header_Getary(const http::Request& parent) {
    return algo::aryptr<http::ExtensionHeader>(parent.extension_header_elems, parent.extension_header_n);
}

// --- http.Request.extension_header.Last
// Return pointer to last element of array, or NULL if array is empty
inline http::ExtensionHeader* http::extension_header_Last(http::Request& parent) {
    return extension_header_Find(parent, u64(parent.extension_header_n-1));
}

// --- http.Request.extension_header.Max
// Return max. number of items in the array
inline i32 http::extension_header_Max(http::Request& parent) {
    (void)parent;
    return parent.extension_header_max;
}

// --- http.Request.extension_header.N
// Return number of items in the array
inline i32 http::extension_header_N(const http::Request& parent) {
    return parent.extension_header_n;
}

// --- http.Request.extension_header.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void http::extension_header_Reserve(http::Request& parent, int n) {
    u32 new_n = parent.extension_header_n + n;
    if (UNLIKELY(new_n > parent.extension_header_max)) {
        extension_header_AbsReserve(parent, new_n);
    }
}

// --- http.Request.extension_header.qFind
// 'quick' Access row by row id. No bounds checking.
inline http::ExtensionHeader& http::extension_header_qFind(http::Request& parent, u64 t) {
    return parent.extension_header_elems[t];
}

// --- http.Request.extension_header.qLast
// Return reference to last element of array. No bounds checking
inline http::ExtensionHeader& http::extension_header_qLast(http::Request& parent) {
    return extension_header_qFind(parent, u64(parent.extension_header_n-1));
}

// --- http.Request.extension_header.rowid_Get
// Return row id of specified element
inline u64 http::extension_header_rowid_Get(http::Request& parent, http::ExtensionHeader &elem) {
    u64 id = &elem - parent.extension_header_elems;
    return u64(id);
}

// --- http.Request.extension_header_curs.Next
// proceed to next item
inline void http::Request_extension_header_curs_Next(Request_extension_header_curs &curs) {
    curs.index++;
}

// --- http.Request.extension_header_curs.Reset
inline void http::Request_extension_header_curs_Reset(Request_extension_header_curs &curs, http::Request &parent) {
    curs.elems = parent.extension_header_elems;
    curs.n_elems = parent.extension_header_n;
    curs.index = 0;
}

// --- http.Request.extension_header_curs.ValidQ
// cursor points to valid item
inline bool http::Request_extension_header_curs_ValidQ(Request_extension_header_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- http.Request.extension_header_curs.Access
// item access
inline http::ExtensionHeader& http::Request_extension_header_curs_Access(Request_extension_header_curs &curs) {
    return curs.elems[curs.index];
}

// --- http.Request..Ctor
inline  http::Request::Request() {
    http::Request_Init(*this);
}

// --- http.Request..Dtor
inline  http::Request::~Request() {
    http::Request_Uninit(*this);
}

// --- http.Response.extension_header.EmptyQ
// Return true if index is empty
inline bool http::extension_header_EmptyQ(http::Response& parent) {
    return parent.extension_header_n == 0;
}

// --- http.Response.extension_header.Find
// Look up row by row id. Return NULL if out of range
inline http::ExtensionHeader* http::extension_header_Find(http::Response& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.extension_header_n;
    if (idx >= lim) return NULL;
    return parent.extension_header_elems + idx;
}

// --- http.Response.extension_header.Getary
// Return array pointer by value
inline algo::aryptr<http::ExtensionHeader> http::extension_header_Getary(const http::Response& parent) {
    return algo::aryptr<http::ExtensionHeader>(parent.extension_header_elems, parent.extension_header_n);
}

// --- http.Response.extension_header.Last
// Return pointer to last element of array, or NULL if array is empty
inline http::ExtensionHeader* http::extension_header_Last(http::Response& parent) {
    return extension_header_Find(parent, u64(parent.extension_header_n-1));
}

// --- http.Response.extension_header.Max
// Return max. number of items in the array
inline i32 http::extension_header_Max(http::Response& parent) {
    (void)parent;
    return parent.extension_header_max;
}

// --- http.Response.extension_header.N
// Return number of items in the array
inline i32 http::extension_header_N(const http::Response& parent) {
    return parent.extension_header_n;
}

// --- http.Response.extension_header.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void http::extension_header_Reserve(http::Response& parent, int n) {
    u32 new_n = parent.extension_header_n + n;
    if (UNLIKELY(new_n > parent.extension_header_max)) {
        extension_header_AbsReserve(parent, new_n);
    }
}

// --- http.Response.extension_header.qFind
// 'quick' Access row by row id. No bounds checking.
inline http::ExtensionHeader& http::extension_header_qFind(http::Response& parent, u64 t) {
    return parent.extension_header_elems[t];
}

// --- http.Response.extension_header.qLast
// Return reference to last element of array. No bounds checking
inline http::ExtensionHeader& http::extension_header_qLast(http::Response& parent) {
    return extension_header_qFind(parent, u64(parent.extension_header_n-1));
}

// --- http.Response.extension_header.rowid_Get
// Return row id of specified element
inline u64 http::extension_header_rowid_Get(http::Response& parent, http::ExtensionHeader &elem) {
    u64 id = &elem - parent.extension_header_elems;
    return u64(id);
}

// --- http.Response.extension_header_curs.Next
// proceed to next item
inline void http::Response_extension_header_curs_Next(Response_extension_header_curs &curs) {
    curs.index++;
}

// --- http.Response.extension_header_curs.Reset
inline void http::Response_extension_header_curs_Reset(Response_extension_header_curs &curs, http::Response &parent) {
    curs.elems = parent.extension_header_elems;
    curs.n_elems = parent.extension_header_n;
    curs.index = 0;
}

// --- http.Response.extension_header_curs.ValidQ
// cursor points to valid item
inline bool http::Response_extension_header_curs_ValidQ(Response_extension_header_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- http.Response.extension_header_curs.Access
// item access
inline http::ExtensionHeader& http::Response_extension_header_curs_Access(Response_extension_header_curs &curs) {
    return curs.elems[curs.index];
}

// --- http.Response..Ctor
inline  http::Response::Response() {
    http::Response_Init(*this);
}

// --- http.Response..Dtor
inline  http::Response::~Response() {
    http::Response_Uninit(*this);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const http::ExtensionHeader &row) {// cfmt:http.ExtensionHeader.String
    http::ExtensionHeader_Print(const_cast<http::ExtensionHeader&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const http::FieldId &row) {// cfmt:http.FieldId.String
    http::FieldId_Print(const_cast<http::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const http::HeaderType &row) {// cfmt:http.HeaderType.String
    http::HeaderType_Print(const_cast<http::HeaderType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const http::Method &row) {// cfmt:http.Method.String
    http::Method_Print(const_cast<http::Method&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const http::Request &row) {// cfmt:http.Request.String
    http::Request_Print(const_cast<http::Request&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const http::Response &row) {// cfmt:http.Response.String
    http::Response_Print(const_cast<http::Response&>(row), str);
    return str;
}
