//
// include/gen/lib_http_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/httpdb_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
static lib_http::FStatus &lib_http_status__100_Continue                          = ((lib_http::FStatus*)lib_http::_db.status_data)[0];
static lib_http::FStatus &lib_http_status__101_Switching_Protocols               = ((lib_http::FStatus*)lib_http::_db.status_data)[1];
static lib_http::FStatus &lib_http_status__200_OK                                = ((lib_http::FStatus*)lib_http::_db.status_data)[2];
static lib_http::FStatus &lib_http_status__201_Created                           = ((lib_http::FStatus*)lib_http::_db.status_data)[3];
static lib_http::FStatus &lib_http_status__202_Accepted                          = ((lib_http::FStatus*)lib_http::_db.status_data)[4];
static lib_http::FStatus &lib_http_status__203_Non_Authoritative_Information     = ((lib_http::FStatus*)lib_http::_db.status_data)[5];
static lib_http::FStatus &lib_http_status__204_No_Content                        = ((lib_http::FStatus*)lib_http::_db.status_data)[6];
static lib_http::FStatus &lib_http_status__205_Reset_Content                     = ((lib_http::FStatus*)lib_http::_db.status_data)[7];
static lib_http::FStatus &lib_http_status__206_Partial_Content                   = ((lib_http::FStatus*)lib_http::_db.status_data)[8];
static lib_http::FStatus &lib_http_status__300_Multiple_Choices                  = ((lib_http::FStatus*)lib_http::_db.status_data)[9];
static lib_http::FStatus &lib_http_status__301_Moved_Permanently                 = ((lib_http::FStatus*)lib_http::_db.status_data)[10];
static lib_http::FStatus &lib_http_status__302_Found                             = ((lib_http::FStatus*)lib_http::_db.status_data)[11];
static lib_http::FStatus &lib_http_status__303_See_Other                         = ((lib_http::FStatus*)lib_http::_db.status_data)[12];
static lib_http::FStatus &lib_http_status__304_Not_Modified                      = ((lib_http::FStatus*)lib_http::_db.status_data)[13];
static lib_http::FStatus &lib_http_status__305_Use_Proxy                         = ((lib_http::FStatus*)lib_http::_db.status_data)[14];
static lib_http::FStatus &lib_http_status__307_Temporary_Redirect                = ((lib_http::FStatus*)lib_http::_db.status_data)[15];
static lib_http::FStatus &lib_http_status__400_Bad_Request                       = ((lib_http::FStatus*)lib_http::_db.status_data)[16];
static lib_http::FStatus &lib_http_status__401_Unauthorized                      = ((lib_http::FStatus*)lib_http::_db.status_data)[17];
static lib_http::FStatus &lib_http_status__402_Payment_Required                  = ((lib_http::FStatus*)lib_http::_db.status_data)[18];
static lib_http::FStatus &lib_http_status__403_Forbidden                         = ((lib_http::FStatus*)lib_http::_db.status_data)[19];
static lib_http::FStatus &lib_http_status__404_Not_Found                         = ((lib_http::FStatus*)lib_http::_db.status_data)[20];
static lib_http::FStatus &lib_http_status__405_Method_Not_Allowed                = ((lib_http::FStatus*)lib_http::_db.status_data)[21];
static lib_http::FStatus &lib_http_status__406_Not_Acceptable                    = ((lib_http::FStatus*)lib_http::_db.status_data)[22];
static lib_http::FStatus &lib_http_status__407_Proxy_Authentication_Required     = ((lib_http::FStatus*)lib_http::_db.status_data)[23];
static lib_http::FStatus &lib_http_status__408_Request_Time_out                  = ((lib_http::FStatus*)lib_http::_db.status_data)[24];
static lib_http::FStatus &lib_http_status__409_Conflict                          = ((lib_http::FStatus*)lib_http::_db.status_data)[25];
static lib_http::FStatus &lib_http_status__410_Gone                              = ((lib_http::FStatus*)lib_http::_db.status_data)[26];
static lib_http::FStatus &lib_http_status__411_Length_Required                   = ((lib_http::FStatus*)lib_http::_db.status_data)[27];
static lib_http::FStatus &lib_http_status__412_Precondition_Failed               = ((lib_http::FStatus*)lib_http::_db.status_data)[28];
static lib_http::FStatus &lib_http_status__413_Request_Entity_Too_Large          = ((lib_http::FStatus*)lib_http::_db.status_data)[29];
static lib_http::FStatus &lib_http_status__414_Request_URI_Too_Large             = ((lib_http::FStatus*)lib_http::_db.status_data)[30];
static lib_http::FStatus &lib_http_status__415_Unsupported_Media_Type            = ((lib_http::FStatus*)lib_http::_db.status_data)[31];
static lib_http::FStatus &lib_http_status__416_Requested_range_not_satisfiable   = ((lib_http::FStatus*)lib_http::_db.status_data)[32];
static lib_http::FStatus &lib_http_status__417_Expectation_Failed                = ((lib_http::FStatus*)lib_http::_db.status_data)[33];
static lib_http::FStatus &lib_http_status__500_Internal_Server_Error             = ((lib_http::FStatus*)lib_http::_db.status_data)[34];
static lib_http::FStatus &lib_http_status__501_Not_Implemented                   = ((lib_http::FStatus*)lib_http::_db.status_data)[35];
static lib_http::FStatus &lib_http_status__502_Bad_Gateway                       = ((lib_http::FStatus*)lib_http::_db.status_data)[36];
static lib_http::FStatus &lib_http_status__503_Service_Unavailable               = ((lib_http::FStatus*)lib_http::_db.status_data)[37];
static lib_http::FStatus &lib_http_status__504_Gateway_Time_out                  = ((lib_http::FStatus*)lib_http::_db.status_data)[38];
static lib_http::FStatus &lib_http_status__505_HTTP_Version_not_supported        = ((lib_http::FStatus*)lib_http::_db.status_data)[39];

// --- lib_http.FStatus..Ctor
inline  lib_http::FStatus::FStatus() {
}

// --- lib_http.trace..Ctor
inline  lib_http::trace::trace() {
}

// --- lib_http.FDb.status.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* lib_http::status_AllocMem() {
    void *row = reinterpret_cast<lib_http::FStatus*>(_db.status_data) + _db.status_n;
    if (_db.status_n == 40) row = NULL;
    if (row) _db.status_n++;
    return row;
}

// --- lib_http.FDb.status.EmptyQ
// Return true if index is empty
inline bool lib_http::status_EmptyQ() {
    return _db.status_n == 0;
}

// --- lib_http.FDb.status.Find
// Look up row by row id. Return NULL if out of range
inline lib_http::FStatus* lib_http::status_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.status_n;
    return idx < lim ? reinterpret_cast<lib_http::FStatus*>(_db.status_data) + idx : NULL; // unsigned comparison with limit
}

// --- lib_http.FDb.status.Getary
// Return array pointer by value
inline algo::aryptr<lib_http::FStatus> lib_http::status_Getary() {
    return algo::aryptr<lib_http::FStatus>(reinterpret_cast<lib_http::FStatus*>(_db.status_data), _db.status_n);
}

// --- lib_http.FDb.status.Max
// Return constant 40 -- max. number of items in the pool
inline i32 lib_http::status_Max() {
    return 40;
}

// --- lib_http.FDb.status.N
// Return number of items in the array
inline i32 lib_http::status_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return _db.status_n;
}

// --- lib_http.FDb.status.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void lib_http::status_Setary(const algo::aryptr<lib_http::FStatus> &rhs) {
    int n = i32_Min(40, rhs.n_elems);
    memcpy(reinterpret_cast<lib_http::FStatus*>(_db.status_data), rhs.elems, sizeof(lib_http::FStatus)*n);
}

// --- lib_http.FDb.status.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline lib_http::FStatus& lib_http::status_qFind(u64 t) {
    return reinterpret_cast<lib_http::FStatus*>(_db.status_data)[u64(t)];
}

// --- lib_http.FDb.status.rowid_Get
// Compute row id of element given element's address
inline u64 lib_http::status_rowid_Get(lib_http::FStatus &row) {
    u64 ret = u64(&row - reinterpret_cast<lib_http::FStatus*>(_db.status_data));
    return u64(ret);
}

// --- lib_http.FDb.status_curs.Reset
// cursor points to valid item
inline void lib_http::_db_status_curs_Reset(_db_status_curs &curs, lib_http::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- lib_http.FDb.status_curs.ValidQ
// cursor points to valid item
inline bool lib_http::_db_status_curs_ValidQ(_db_status_curs &curs) {
    return u64(curs.index) < u64(curs.parent->status_n);
}

// --- lib_http.FDb.status_curs.Next
// proceed to next item
inline void lib_http::_db_status_curs_Next(_db_status_curs &curs) {
    curs.index++;
}

// --- lib_http.FDb.status_curs.Access
// item access
inline lib_http::FStatus& lib_http::_db_status_curs_Access(_db_status_curs &curs) {
    return status_qFind(u64(curs.index));
}

// --- lib_http.FieldId.value.GetEnum
// Get value of field as enum type
inline lib_http_FieldIdEnum lib_http::value_GetEnum(const lib_http::FieldId& parent) {
    return lib_http_FieldIdEnum(parent.value);
}

// --- lib_http.FieldId.value.SetEnum
// Set value of field from enum type.
inline void lib_http::value_SetEnum(lib_http::FieldId& parent, lib_http_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- lib_http.FieldId.value.Cast
inline  lib_http::FieldId::operator lib_http_FieldIdEnum() const {
    return lib_http_FieldIdEnum((*this).value);
}

// --- lib_http.FieldId..Init
// Set all fields to initial values.
inline void lib_http::FieldId_Init(lib_http::FieldId& parent) {
    parent.value = i32(-1);
}

// --- lib_http.FieldId..Ctor
inline  lib_http::FieldId::FieldId() {
    lib_http::FieldId_Init(*this);
}

// --- lib_http.FieldId..FieldwiseCtor
inline  lib_http::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- lib_http.FieldId..EnumCtor
inline  lib_http::FieldId::FieldId(lib_http_FieldIdEnum arg) {
    this->value = i32(arg);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const lib_http::trace &row) {// cfmt:lib_http.trace.String
    lib_http::trace_Print(const_cast<lib_http::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const lib_http::FieldId &row) {// cfmt:lib_http.FieldId.String
    lib_http::FieldId_Print(const_cast<lib_http::FieldId&>(row), str);
    return str;
}
