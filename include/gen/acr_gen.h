//
// include/gen/acr_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/amcdb_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/report_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- acr_Queryop_value_Enum

enum acr_Queryop_value_Enum {                      // acr.Queryop.value
     acr_Queryop_value_none                  = 0
    ,acr_Queryop_value_select                = 1   // Select record
    ,acr_Queryop_value_set_attr              = 2   // Set attribute value
    ,acr_Queryop_value_rename_attr           = 3   // Set attribute name
    ,acr_Queryop_value_del_attr              = 4   // Delete attribute
    ,acr_Queryop_value_finish_rename_field   = 5   // Reindex renamed field
    ,acr_Queryop_value_rename_typetag        = 6   // Rewrite type tag in renamed ssimfile
};

enum { acr_Queryop_value_Enum_N = 7 };


// --- acr_FieldIdEnum

enum acr_FieldIdEnum {        // acr.FieldId.value
     acr_FieldId_value   = 0
};

enum { acr_FieldIdEnum_N = 1 };


// --- acr_ReadModeEnum

enum acr_ReadModeEnum {               // acr.ReadMode.read_mode
     acr_ReadMode_acr_insert    = 0   // Insert new record only
    ,acr_ReadMode_acr_replace   = 1   // Replace record with input
    ,acr_ReadMode_acr_update    = 2   // Merge existing attributes only
    ,acr_ReadMode_acr_merge     = 3   // Create new record & merge attributes
    ,acr_ReadMode_acr_delete    = 4   // Delete record
    ,acr_ReadMode_acr_select    = 5   // Select found record
};

enum { acr_ReadModeEnum_N = 6 };


// --- acr_TableIdEnum

enum acr_TableIdEnum {                    // acr.TableId.value
     acr_TableId_dmmeta_Anonfld    = 0    // dmmeta.Anonfld -> acr.FAnonfld
    ,acr_TableId_dmmeta_anonfld    = 0    // dmmeta.anonfld -> acr.FAnonfld
    ,acr_TableId_amcdb_Bltin       = 1    // amcdb.Bltin -> acr.FBltin
    ,acr_TableId_amcdb_bltin       = 1    // amcdb.bltin -> acr.FBltin
    ,acr_TableId_dmmeta_Cdflt      = 2    // dmmeta.Cdflt -> acr.FCdflt
    ,acr_TableId_dmmeta_cdflt      = 2    // dmmeta.cdflt -> acr.FCdflt
    ,acr_TableId_dmmeta_Cppfunc    = 3    // dmmeta.Cppfunc -> acr.FCppfunc
    ,acr_TableId_dmmeta_cppfunc    = 3    // dmmeta.cppfunc -> acr.FCppfunc
    ,acr_TableId_dmmeta_Ctype      = 4    // dmmeta.Ctype -> acr.FCtype
    ,acr_TableId_dmmeta_ctype      = 4    // dmmeta.ctype -> acr.FCtype
    ,acr_TableId_dmmeta_Field      = 5    // dmmeta.Field -> acr.FField
    ,acr_TableId_dmmeta_field      = 5    // dmmeta.field -> acr.FField
    ,acr_TableId_dmmeta_Funique    = 6    // dmmeta.Funique -> acr.FFunique
    ,acr_TableId_dmmeta_funique    = 6    // dmmeta.funique -> acr.FFunique
    ,acr_TableId_dmmeta_Smallstr   = 7    // dmmeta.Smallstr -> acr.FSmallstr
    ,acr_TableId_dmmeta_smallstr   = 7    // dmmeta.smallstr -> acr.FSmallstr
    ,acr_TableId_dmmeta_Ssimfile   = 8    // dmmeta.Ssimfile -> acr.FSsimfile
    ,acr_TableId_dmmeta_ssimfile   = 8    // dmmeta.ssimfile -> acr.FSsimfile
    ,acr_TableId_dmmeta_Ssimreq    = 9    // dmmeta.Ssimreq -> acr.FSsimreq
    ,acr_TableId_dmmeta_ssimreq    = 9    // dmmeta.ssimreq -> acr.FSsimreq
    ,acr_TableId_dmmeta_Ssimsort   = 10   // dmmeta.Ssimsort -> acr.FSsimsort
    ,acr_TableId_dmmeta_ssimsort   = 10   // dmmeta.ssimsort -> acr.FSsimsort
    ,acr_TableId_dmmeta_Substr     = 11   // dmmeta.Substr -> acr.FSubstr
    ,acr_TableId_dmmeta_substr     = 11   // dmmeta.substr -> acr.FSubstr
};

enum { acr_TableIdEnum_N = 24 };

namespace acr { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace acr { // gen:ns_tclass_field
extern const char *acr_help;
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace dmmeta { struct Anonfld; }
namespace amcdb { struct Bltin; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Ctype; }
namespace acr { struct Err; }
namespace dmmeta { struct Field; }
namespace acr { struct FCtype; }
namespace dmmeta { struct Funique; }
namespace acr { struct FPline; }
namespace acr { struct FRec; }
namespace acr { struct FPrint; }
namespace acr { struct FFile; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimreq; }
namespace acr { struct FSsimfile; }
namespace acr { struct FField; }
namespace dmmeta { struct Ssimsort; }
namespace dmmeta { struct Substr; }
namespace acr { struct check_c_bad_rec_curs; }
namespace acr { struct check_ary_name_curs; }
namespace acr { struct ctype_c_field_curs; }
namespace acr { struct ctype_zd_ctype_rec_curs; }
namespace acr { struct ctype_ind_ctype_rec_curs; }
namespace acr { struct ctype_zd_ctype_selrec_curs; }
namespace acr { struct ctype_c_child_curs; }
namespace acr { struct ctype_zd_arg_curs; }
namespace acr { struct ctype_c_ssimreq_curs; }
namespace acr { struct _db_zd_pline_curs; }
namespace acr { struct _db_zd_pdep_curs; }
namespace acr { struct _db_ctype_curs; }
namespace acr { struct _db_anonfld_curs; }
namespace acr { struct _db_cdflt_curs; }
namespace acr { struct _db_field_curs; }
namespace acr { struct _db_file_curs; }
namespace acr { struct _db_zd_all_selrec_curs; }
namespace acr { struct _db_zd_all_selrec_delcurs; }
namespace acr { struct _db_zd_all_err_curs; }
namespace acr { struct _db_zd_sel_ctype_curs; }
namespace acr { struct _db_bh_pline_curs; }
namespace acr { struct _db_substr_curs; }
namespace acr { struct _db_ssimfile_curs; }
namespace acr { struct _db_tempkey_curs; }
namespace acr { struct _db_zs_query_curs; }
namespace acr { struct _db_ssimsort_curs; }
namespace acr { struct _db_smallstr_curs; }
namespace acr { struct _db_funique_curs; }
namespace acr { struct _db_bltin_curs; }
namespace acr { struct _db_bh_ctype_topo_curs; }
namespace acr { struct _db_cppfunc_curs; }
namespace acr { struct _db_ssimreq_curs; }
namespace acr { struct _db_c_ssimreq_rec_curs; }
namespace acr { struct _db_c_ctype_front_curs; }
namespace acr { struct _db_sortkey_curs; }
namespace acr { struct file_zd_frec_curs; }
namespace acr { struct pline_zd_child_curs; }
namespace acr { struct print_c_pline_curs; }
namespace acr { struct query_where_curs; }
namespace acr { struct query_c_ctype_curs; }
namespace acr { struct query_c_field_curs; }
namespace acr { struct query_c_rec_curs; }
namespace acr { struct write_c_cmtrec_curs; }
namespace acr { struct AttrRegx; }
namespace acr { struct CtypeTopoKey; }
namespace acr { struct FAnonfld; }
namespace acr { struct FBltin; }
namespace acr { struct FCdflt; }
namespace acr { struct FCheck; }
namespace acr { struct FCppfunc; }
namespace acr { struct trace; }
namespace acr { struct FDb; }
namespace acr { struct FErr; }
namespace acr { struct FEvalattr; }
namespace acr { struct FFunique; }
namespace acr { struct FPdep; }
namespace acr { struct RecSortkey; }
namespace acr { struct PlineKey; }
namespace acr { struct FPrintAttr; }
namespace acr { struct Queryop; }
namespace acr { struct FQuery; }
namespace acr { struct FSmallstr; }
namespace acr { struct FSortkey; }
namespace acr { struct FSsimreq; }
namespace acr { struct FSsimsort; }
namespace acr { struct FSubstr; }
namespace acr { struct FTempkey; }
namespace acr { struct FUniqueattr; }
namespace acr { struct FWrite; }
namespace acr { struct FieldId; }
namespace acr { struct ReadMode; }
namespace acr { struct TableId; }
namespace acr { extern struct acr::FDb _db; }
namespace acr { // gen:ns_print_struct

// --- acr.AttrRegx
// create: acr.FQuery.where (Tary)
struct AttrRegx { // acr.AttrRegx: Filters that must match input key/value pairs
    algo_lib::Regx   name;    // Acr Regx
    algo_lib::Regx   value;   // Acr Regx
    // func:acr.AttrRegx..Ctor
    inline               AttrRegx() __attribute__((nothrow));
};

// Print back to string
// func:acr.AttrRegx.name.Print
void                 name_Print(acr::AttrRegx& parent, algo::cstring &out) __attribute__((nothrow));

// Print back to string
// func:acr.AttrRegx.value.Print
void                 value_Print(acr::AttrRegx& parent, algo::cstring &out) __attribute__((nothrow));

// print string representation of ROW to string STR
// cfmt:acr.AttrRegx.String  printfmt:Sep
// func:acr.AttrRegx..Print
void                 AttrRegx_Print(acr::AttrRegx& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.CtypeTopoKey
struct CtypeTopoKey { // acr.CtypeTopoKey: Key for sorting print-line records
    i32   alldep;   //   0  # Unresolved references
    i32   rowid;    //   0  Rowid of original record
    // func:acr.CtypeTopoKey..EqOp
    inline bool          operator ==(const acr::CtypeTopoKey &rhs) const __attribute__((nothrow));
    // func:acr.CtypeTopoKey..NeOp
    inline bool          operator !=(const acr::CtypeTopoKey &rhs) const __attribute__((nothrow));
    // func:acr.CtypeTopoKey..LtOp
    inline bool          operator <(const acr::CtypeTopoKey &rhs) const __attribute__((nothrow));
    // func:acr.CtypeTopoKey..GtOp
    inline bool          operator >(const acr::CtypeTopoKey &rhs) const __attribute__((nothrow));
    // func:acr.CtypeTopoKey..LeOp
    inline bool          operator <=(const acr::CtypeTopoKey &rhs) const __attribute__((nothrow));
    // func:acr.CtypeTopoKey..GeOp
    inline bool          operator >=(const acr::CtypeTopoKey &rhs) const __attribute__((nothrow));
    // func:acr.CtypeTopoKey..Ctor
    inline               CtypeTopoKey() __attribute__((nothrow));
};

// func:acr.CtypeTopoKey..Hash
inline u32           CtypeTopoKey_Hash(u32 prev, const acr::CtypeTopoKey& rhs) __attribute__((nothrow));
// func:acr.CtypeTopoKey..Lt
inline bool          CtypeTopoKey_Lt(acr::CtypeTopoKey& lhs, acr::CtypeTopoKey& rhs) __attribute__((nothrow));
// func:acr.CtypeTopoKey..Cmp
inline i32           CtypeTopoKey_Cmp(acr::CtypeTopoKey& lhs, acr::CtypeTopoKey& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.CtypeTopoKey..Init
inline void          CtypeTopoKey_Init(acr::CtypeTopoKey& parent);
// func:acr.CtypeTopoKey..Eq
inline bool          CtypeTopoKey_Eq(acr::CtypeTopoKey& lhs, acr::CtypeTopoKey& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:acr.CtypeTopoKey..Update
inline bool          CtypeTopoKey_Update(acr::CtypeTopoKey &lhs, acr::CtypeTopoKey& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:acr.CtypeTopoKey.String  printfmt:Tuple
// func:acr.CtypeTopoKey..Print
void                 CtypeTopoKey_Print(acr::CtypeTopoKey& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.Err
// access: acr.FErr.base (Base)
struct Err { // acr.Err
    acr::FCtype*    ctype;   // Parent ctype. optional pointer
    u32             id;      //   0  ID
    algo::cstring   text;    // Error text
    acr::FRec*      rec;     // Parent record. optional pointer
    acr::FField*    fld;     // Parent field. optional pointer
    // func:acr.Err..Ctor
    inline               Err() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.Err..Init
inline void          Err_Init(acr::Err& parent);
// print string representation of ROW to string STR
// cfmt:acr.Err.String  printfmt:Tuple
// func:acr.Err..Print
void                 Err_Print(acr::Err& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.FAnonfld
// create: acr.FDb.anonfld (Lary)
// global access: anonfld (Lary, by rowid)
struct FAnonfld { // acr.FAnonfld
    algo::Smallstr100   field;   //
private:
    // func:acr.FAnonfld..Ctor
    inline               FAnonfld() __attribute__((nothrow));
    friend acr::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 anonfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FAnonfld.base.CopyOut
void                 anonfld_CopyOut(acr::FAnonfld &row, dmmeta::Anonfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FAnonfld.base.CopyIn
void                 anonfld_CopyIn(acr::FAnonfld &row, dmmeta::Anonfld &in) __attribute__((nothrow));


// --- acr.FBltin
// create: acr.FDb.bltin (Lary)
// global access: bltin (Lary, by rowid)
// access: acr.FCtype.c_bltin (Ptr)
struct FBltin { // acr.FBltin
    algo::Smallstr100   ctype;      //
    bool                likeu64;    //   false
    bool                bigendok;   //   false
    bool                issigned;   //   false
    // func:acr.FBltin..AssignOp
    inline acr::FBltin&  operator =(const acr::FBltin &rhs) = delete;
    // func:acr.FBltin..CopyCtor
    inline               FBltin(const acr::FBltin &rhs) = delete;
private:
    // func:acr.FBltin..Ctor
    inline               FBltin() __attribute__((nothrow));
    // func:acr.FBltin..Dtor
    inline               ~FBltin() __attribute__((nothrow));
    friend acr::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 bltin_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FBltin.base.CopyOut
void                 bltin_CopyOut(acr::FBltin &row, amcdb::Bltin &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FBltin.base.CopyIn
void                 bltin_CopyIn(acr::FBltin &row, amcdb::Bltin &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FBltin..Init
inline void          FBltin_Init(acr::FBltin& bltin);
// func:acr.FBltin..Uninit
void                 FBltin_Uninit(acr::FBltin& bltin) __attribute__((nothrow));

// --- acr.FCdflt
// create: acr.FDb.cdflt (Lary)
// global access: cdflt (Lary, by rowid)
// access: acr.FCtype.c_cdflt (Ptr)
struct FCdflt { // acr.FCdflt
    algo::Smallstr100   ctype;      //
    algo::CppExpr       dflt;       //
    algo::CppExpr       cppdflt;    //
    algo::Smallstr50    ssimdflt;   //
    algo::Smallstr50    jsdflt;     //
    // func:acr.FCdflt..AssignOp
    inline acr::FCdflt&  operator =(const acr::FCdflt &rhs) = delete;
    // func:acr.FCdflt..CopyCtor
    inline               FCdflt(const acr::FCdflt &rhs) = delete;
private:
    // func:acr.FCdflt..Ctor
    inline               FCdflt() __attribute__((nothrow));
    // func:acr.FCdflt..Dtor
    inline               ~FCdflt() __attribute__((nothrow));
    friend acr::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cdflt_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FCdflt.base.CopyOut
void                 cdflt_CopyOut(acr::FCdflt &row, dmmeta::Cdflt &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FCdflt.base.CopyIn
void                 cdflt_CopyIn(acr::FCdflt &row, dmmeta::Cdflt &in) __attribute__((nothrow));

// func:acr.FCdflt..Uninit
void                 FCdflt_Uninit(acr::FCdflt& cdflt) __attribute__((nothrow));

// --- acr.FCheck
// create: acr.FDb.check (Cppstack)
struct FCheck { // acr.FCheck: Function to check for consistency
    acr::FRec**      c_bad_rec_elems;   // array of pointers
    u32              c_bad_rec_n;       // array of pointers
    u32              c_bad_rec_max;     // capacity of allocated array
    u32              n_record;          //   0
    i32              n_err;             //   0
    algo::cstring*   ary_name_elems;    // pointer to elements
    u32              ary_name_n;        // number of elements in array
    u32              ary_name_max;      // max. capacity of array before realloc
    // reftype Ptrary of acr.FCheck.c_bad_rec prohibits copy
    // func:acr.FCheck..AssignOp
    acr::FCheck&         operator =(const acr::FCheck &rhs) = delete;
    // func:acr.FCheck..Ctor
    inline               FCheck() __attribute__((nothrow));
    // func:acr.FCheck..Dtor
    inline               ~FCheck() __attribute__((nothrow));
    // reftype Ptrary of acr.FCheck.c_bad_rec prohibits copy
    // func:acr.FCheck..CopyCtor
    FCheck(const acr::FCheck &rhs) = delete;
};

// Return true if index is empty
// func:acr.FCheck.c_bad_rec.EmptyQ
inline bool          c_bad_rec_EmptyQ(acr::FCheck& check) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FCheck.c_bad_rec.Find
inline acr::FRec*    c_bad_rec_Find(acr::FCheck& check, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FCheck.c_bad_rec.Getary
inline algo::aryptr<acr::FRec*> c_bad_rec_Getary(acr::FCheck& check) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FCheck.c_bad_rec.Insert
void                 c_bad_rec_Insert(acr::FCheck& check, acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FCheck.c_bad_rec.ScanInsertMaybe
bool                 c_bad_rec_ScanInsertMaybe(acr::FCheck& check, acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FCheck.c_bad_rec.N
inline i32           c_bad_rec_N(const acr::FCheck& check) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FCheck.c_bad_rec.Remove
void                 c_bad_rec_Remove(acr::FCheck& check, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCheck.c_bad_rec.RemoveAll
inline void          c_bad_rec_RemoveAll(acr::FCheck& check) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FCheck.c_bad_rec.Reserve
void                 c_bad_rec_Reserve(acr::FCheck& check, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FCheck.c_bad_rec.qFind
inline acr::FRec&    c_bad_rec_qFind(acr::FCheck& check, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FCheck.c_bad_rec.qLast
inline acr::FRec&    c_bad_rec_qLast(acr::FCheck& check) __attribute__((nothrow));

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:acr.FCheck.ary_name.Addary
algo::aryptr<algo::cstring> ary_name_Addary(acr::FCheck& check, algo::aryptr<algo::cstring> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:acr.FCheck.ary_name.Alloc
algo::cstring&       ary_name_Alloc(acr::FCheck& check) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:acr.FCheck.ary_name.AllocAt
algo::cstring&       ary_name_AllocAt(acr::FCheck& check, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:acr.FCheck.ary_name.AllocN
algo::aryptr<algo::cstring> ary_name_AllocN(acr::FCheck& check, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FCheck.ary_name.EmptyQ
inline bool          ary_name_EmptyQ(acr::FCheck& check) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FCheck.ary_name.Find
inline algo::cstring* ary_name_Find(acr::FCheck& check, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:acr.FCheck.ary_name.Getary
inline algo::aryptr<algo::cstring> ary_name_Getary(const acr::FCheck& check) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FCheck.ary_name.Last
inline algo::cstring* ary_name_Last(acr::FCheck& check) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:acr.FCheck.ary_name.Max
inline i32           ary_name_Max(acr::FCheck& check) __attribute__((nothrow));
// Return number of items in the array
// func:acr.FCheck.ary_name.N
inline i32           ary_name_N(const acr::FCheck& check) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:acr.FCheck.ary_name.Remove
void                 ary_name_Remove(acr::FCheck& check, u32 i) __attribute__((nothrow));
// func:acr.FCheck.ary_name.RemoveAll
void                 ary_name_RemoveAll(acr::FCheck& check) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FCheck.ary_name.RemoveLast
void                 ary_name_RemoveLast(acr::FCheck& check) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:acr.FCheck.ary_name.Reserve
inline void          ary_name_Reserve(acr::FCheck& check, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:acr.FCheck.ary_name.AbsReserve
void                 ary_name_AbsReserve(acr::FCheck& check, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:acr.FCheck.ary_name.Setary
void                 ary_name_Setary(acr::FCheck& check, acr::FCheck &rhs) __attribute__((nothrow));
// Copy specified array into ary_name, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:acr.FCheck.ary_name.Setary2
void                 ary_name_Setary(acr::FCheck& check, const algo::aryptr<algo::cstring> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FCheck.ary_name.qFind
inline algo::cstring& ary_name_qFind(acr::FCheck& check, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:acr.FCheck.ary_name.qLast
inline algo::cstring& ary_name_qLast(acr::FCheck& check) __attribute__((nothrow));
// Return row id of specified element
// func:acr.FCheck.ary_name.rowid_Get
inline u64           ary_name_rowid_Get(acr::FCheck& check, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:acr.FCheck.ary_name.AllocNVal
algo::aryptr<algo::cstring> ary_name_AllocNVal(acr::FCheck& check, int n_elems, const algo::cstring& val) __attribute__((nothrow));
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
// func:acr.FCheck.ary_name.ReadStrptrMaybe
bool                 ary_name_ReadStrptrMaybe(acr::FCheck& check, algo::strptr in_str) __attribute__((nothrow));

// func:acr.FCheck.c_bad_rec_curs.Reset
inline void          check_c_bad_rec_curs_Reset(check_c_bad_rec_curs &curs, acr::FCheck &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCheck.c_bad_rec_curs.ValidQ
inline bool          check_c_bad_rec_curs_ValidQ(check_c_bad_rec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCheck.c_bad_rec_curs.Next
inline void          check_c_bad_rec_curs_Next(check_c_bad_rec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCheck.c_bad_rec_curs.Access
inline acr::FRec&    check_c_bad_rec_curs_Access(check_c_bad_rec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCheck.ary_name_curs.Next
inline void          check_ary_name_curs_Next(check_ary_name_curs &curs) __attribute__((nothrow));
// func:acr.FCheck.ary_name_curs.Reset
inline void          check_ary_name_curs_Reset(check_ary_name_curs &curs, acr::FCheck &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCheck.ary_name_curs.ValidQ
inline bool          check_ary_name_curs_ValidQ(check_ary_name_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCheck.ary_name_curs.Access
inline algo::cstring& check_ary_name_curs_Access(check_ary_name_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.FCheck..Init
inline void          FCheck_Init(acr::FCheck& check);
// func:acr.FCheck..Uninit
void                 FCheck_Uninit(acr::FCheck& check) __attribute__((nothrow));

// --- acr.FCppfunc
// create: acr.FDb.cppfunc (Lary)
// global access: cppfunc (Lary, by rowid)
struct FCppfunc { // acr.FCppfunc
    algo::Smallstr100   field;   //
    algo::CppExpr       expr;    //
    bool                print;   //   false
    bool                set;     //   false
private:
    // func:acr.FCppfunc..Ctor
    inline               FCppfunc() __attribute__((nothrow));
    friend acr::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cppfunc_RemoveAll() __attribute__((nothrow));
    friend void                 cppfunc_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FCppfunc.base.CopyOut
void                 cppfunc_CopyOut(acr::FCppfunc &row, dmmeta::Cppfunc &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FCppfunc.base.CopyIn
void                 cppfunc_CopyIn(acr::FCppfunc &row, dmmeta::Cppfunc &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FCppfunc..Init
inline void          FCppfunc_Init(acr::FCppfunc& cppfunc);

// --- acr.FCtype
// create: acr.FDb.ctype (Lary)
// global access: ctype (Lary, by rowid)
// global access: ind_ctype (Thash, hash field ctype)
// global access: zd_sel_ctype (Llist)
// global access: bh_ctype_topo (Bheap, sort field topokey)
// global access: c_field_ctype (Ptr)
// global access: c_ssimfile_ctype (Ptr)
// global access: c_ctype_front (Ptrary)
// access: acr.Err.ctype (Ptr)
// access: acr.FCtype.c_child (Ptrary)
// access: acr.FField.p_ctype (Upptr)
// access: acr.FField.p_arg (Upptr)
// access: acr.FQuery.c_ctype (Ptrary)
// access: acr.FRec.p_ctype (Upptr)
// access: acr.FSsimfile.p_ctype (Upptr)
// access: acr.FSsimreq.p_ctype (Upptr)
// access: acr.FErr.ctype (Ptr)
struct FCtype { // acr.FCtype
    algo::Smallstr100   ctype;                         // Identifier. must be ns.typename
    algo::Comment       comment;                       //
    acr::FField**       c_field_elems;                 // array of pointers
    u32                 c_field_n;                     // array of pointers
    u32                 c_field_max;                   // capacity of allocated array
    acr::FCdflt*        c_cdflt;                       // optional pointer
    acr::FSsimfile*     c_ssimfile;                    // optional pointer
    acr::FRec*          zd_ctype_rec_head;             // zero-terminated doubly linked list
    acr::FRec*          zd_ctype_rec_tail;             // pointer to last element
    acr::FRec**         ind_ctype_rec_buckets_elems;   // pointer to bucket array
    i32                 ind_ctype_rec_buckets_n;       // number of elements in bucket array
    i32                 ind_ctype_rec_n;               // number of elements in the hash table
    acr::FRec*          zd_ctype_selrec_head;          // zero-terminated doubly linked list
    acr::FRec*          zd_ctype_selrec_tail;          // pointer to last element
    i32                 n_insert;                      //   0  Number of tuples inserted
    i32                 rank;                          //   false  Topological sort rank
    acr::FCtype**       c_child_elems;                 // array of pointers
    u32                 c_child_n;                     // array of pointers
    u32                 c_child_max;                   // capacity of allocated array
    bool                show_rowid;                    //   false  True if records of this type require printing rowid (not fully ordered)
    u64                 next_rowid;                    //   0  Rowid of next created record for this type
    bool                numeric;                       //   false
    acr::FBltin*        c_bltin;                       // optional pointer
    acr::FField*        zd_arg_head;                   // zero-terminated doubly linked list
    i32                 zd_arg_n;                      // zero-terminated doubly linked list
    acr::FField*        zd_arg_tail;                   // pointer to last element
    i32                 rowid;                         //   0  Row id of ctype from its original ctype.ssim table
    acr::CtypeTopoKey   topokey;                       //
    bool                cmt_printed;                   //   false
    bool                mark_sel;                      //   false  Ctype tree scheduled to be selected (with -meta)
    acr::FSsimreq**     c_ssimreq_elems;               // array of pointers
    u32                 c_ssimreq_n;                   // array of pointers
    u32                 c_ssimreq_max;                 // capacity of allocated array
    bool                _db_c_ctype_front_in_ary;      //   false  membership flag
    acr::FCtype*        ind_ctype_next;                // hash next
    acr::FCtype*        zd_sel_ctype_next;             // zslist link; -1 means not-in-list
    acr::FCtype*        zd_sel_ctype_prev;             // previous element
    i32                 bh_ctype_topo_idx;             // index in heap; -1 means not-in-heap
    // reftype Ptrary of acr.FCtype.c_field prohibits copy
    // x-reference on acr.FCtype.c_cdflt prevents copy
    // x-reference on acr.FCtype.c_ssimfile prevents copy
    // reftype Llist of acr.FCtype.zd_ctype_rec prohibits copy
    // reftype Thash of acr.FCtype.ind_ctype_rec prohibits copy
    // reftype Llist of acr.FCtype.zd_ctype_selrec prohibits copy
    // reftype Ptrary of acr.FCtype.c_child prohibits copy
    // x-reference on acr.FCtype.c_bltin prevents copy
    // reftype Llist of acr.FCtype.zd_arg prohibits copy
    // reftype Ptrary of acr.FCtype.c_ssimreq prohibits copy
    // func:acr.FCtype..AssignOp
    acr::FCtype&         operator =(const acr::FCtype &rhs) = delete;
    // reftype Ptrary of acr.FCtype.c_field prohibits copy
    // x-reference on acr.FCtype.c_cdflt prevents copy
    // x-reference on acr.FCtype.c_ssimfile prevents copy
    // reftype Llist of acr.FCtype.zd_ctype_rec prohibits copy
    // reftype Thash of acr.FCtype.ind_ctype_rec prohibits copy
    // reftype Llist of acr.FCtype.zd_ctype_selrec prohibits copy
    // reftype Ptrary of acr.FCtype.c_child prohibits copy
    // x-reference on acr.FCtype.c_bltin prevents copy
    // reftype Llist of acr.FCtype.zd_arg prohibits copy
    // reftype Ptrary of acr.FCtype.c_ssimreq prohibits copy
    // func:acr.FCtype..CopyCtor
    FCtype(const acr::FCtype &rhs) = delete;
private:
    // func:acr.FCtype..Ctor
    inline               FCtype() __attribute__((nothrow));
    // func:acr.FCtype..Dtor
    inline               ~FCtype() __attribute__((nothrow));
    friend acr::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FCtype.base.CopyOut
void                 ctype_CopyOut(acr::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FCtype.base.CopyIn
void                 ctype_CopyIn(acr::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

// func:acr.FCtype.ns.Get
algo::Smallstr16     ns_Get(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FCtype.name.Get
algo::Smallstr100    name_Get(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:acr.FCtype.c_field.EmptyQ
inline bool          c_field_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FCtype.c_field.Find
inline acr::FField*  c_field_Find(acr::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FCtype.c_field.Getary
inline algo::aryptr<acr::FField*> c_field_Getary(acr::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FCtype.c_field.Insert
void                 c_field_Insert(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:acr.FCtype.c_field.InsertMaybe
bool                 c_field_InsertMaybe(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FCtype.c_field.N
inline i32           c_field_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FCtype.c_field.Remove
void                 c_field_Remove(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCtype.c_field.RemoveAll
inline void          c_field_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FCtype.c_field.Reserve
void                 c_field_Reserve(acr::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FCtype.c_field.qFind
inline acr::FField&  c_field_qFind(acr::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:acr.FCtype.c_field.InAryQ
inline bool          ctype_c_field_InAryQ(acr::FField& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FCtype.c_field.qLast
inline acr::FField&  c_field_qLast(acr::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr.FCtype.c_cdflt.InsertMaybe
inline bool          c_cdflt_InsertMaybe(acr::FCtype& ctype, acr::FCdflt& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FCtype.c_cdflt.Remove
inline void          c_cdflt_Remove(acr::FCtype& ctype, acr::FCdflt& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr.FCtype.c_ssimfile.InsertMaybe
inline bool          c_ssimfile_InsertMaybe(acr::FCtype& ctype, acr::FSsimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FCtype.c_ssimfile.Remove
inline void          c_ssimfile_Remove(acr::FCtype& ctype, acr::FSsimfile& row) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FCtype.zd_ctype_rec.EmptyQ
inline bool          zd_ctype_rec_EmptyQ(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FCtype.zd_ctype_rec.First
inline acr::FRec*    zd_ctype_rec_First(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FCtype.zd_ctype_rec.InLlistQ
inline bool          zd_ctype_rec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FCtype.zd_ctype_rec.Insert
void                 zd_ctype_rec_Insert(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FCtype.zd_ctype_rec.Last
inline acr::FRec*    zd_ctype_rec_Last(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FCtype.zd_ctype_rec.Next
inline acr::FRec*    zd_ctype_rec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FCtype.zd_ctype_rec.Prev
inline acr::FRec*    zd_ctype_rec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FCtype.zd_ctype_rec.Remove
void                 zd_ctype_rec_Remove(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCtype.zd_ctype_rec.RemoveAll
void                 zd_ctype_rec_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FCtype.zd_ctype_rec.RemoveFirst
acr::FRec*           zd_ctype_rec_RemoveFirst(acr::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FCtype.zd_ctype_rec.qLast
inline acr::FRec&    zd_ctype_rec_qLast(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if hash is empty
// func:acr.FCtype.ind_ctype_rec.EmptyQ
inline bool          ind_ctype_rec_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FCtype.ind_ctype_rec.Find
acr::FRec*           ind_ctype_rec_Find(acr::FCtype& ctype, const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:acr.FCtype.ind_ctype_rec.N
inline i32           ind_ctype_rec_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FCtype.ind_ctype_rec.InsertMaybe
bool                 ind_ctype_rec_InsertMaybe(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FCtype.ind_ctype_rec.Remove
void                 ind_ctype_rec_Remove(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FCtype.ind_ctype_rec.Reserve
void                 ind_ctype_rec_Reserve(acr::FCtype& ctype, int n) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FCtype.zd_ctype_selrec.EmptyQ
inline bool          zd_ctype_selrec_EmptyQ(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FCtype.zd_ctype_selrec.First
inline acr::FRec*    zd_ctype_selrec_First(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FCtype.zd_ctype_selrec.InLlistQ
inline bool          zd_ctype_selrec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FCtype.zd_ctype_selrec.Insert
void                 zd_ctype_selrec_Insert(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FCtype.zd_ctype_selrec.Last
inline acr::FRec*    zd_ctype_selrec_Last(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FCtype.zd_ctype_selrec.Next
inline acr::FRec*    zd_ctype_selrec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FCtype.zd_ctype_selrec.Prev
inline acr::FRec*    zd_ctype_selrec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FCtype.zd_ctype_selrec.Remove
void                 zd_ctype_selrec_Remove(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCtype.zd_ctype_selrec.RemoveAll
void                 zd_ctype_selrec_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FCtype.zd_ctype_selrec.RemoveFirst
acr::FRec*           zd_ctype_selrec_RemoveFirst(acr::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FCtype.zd_ctype_selrec.qLast
inline acr::FRec&    zd_ctype_selrec_qLast(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:acr.FCtype.c_child.EmptyQ
inline bool          c_child_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FCtype.c_child.Find
inline acr::FCtype*  c_child_Find(acr::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FCtype.c_child.Getary
inline algo::aryptr<acr::FCtype*> c_child_Getary(acr::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FCtype.c_child.Insert
void                 c_child_Insert(acr::FCtype& ctype, acr::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FCtype.c_child.ScanInsertMaybe
bool                 c_child_ScanInsertMaybe(acr::FCtype& ctype, acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FCtype.c_child.N
inline i32           c_child_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FCtype.c_child.Remove
void                 c_child_Remove(acr::FCtype& ctype, acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCtype.c_child.RemoveAll
inline void          c_child_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FCtype.c_child.Reserve
void                 c_child_Reserve(acr::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FCtype.c_child.qFind
inline acr::FCtype&  c_child_qFind(acr::FCtype& ctype, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FCtype.c_child.qLast
inline acr::FCtype&  c_child_qLast(acr::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr.FCtype.c_bltin.InsertMaybe
inline bool          c_bltin_InsertMaybe(acr::FCtype& ctype, acr::FBltin& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FCtype.c_bltin.Remove
inline void          c_bltin_Remove(acr::FCtype& ctype, acr::FBltin& row) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FCtype.zd_arg.EmptyQ
inline bool          zd_arg_EmptyQ(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FCtype.zd_arg.First
inline acr::FField*  zd_arg_First(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FCtype.zd_arg.InLlistQ
inline bool          zd_arg_InLlistQ(acr::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FCtype.zd_arg.Insert
void                 zd_arg_Insert(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FCtype.zd_arg.Last
inline acr::FField*  zd_arg_Last(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:acr.FCtype.zd_arg.N
inline i32           zd_arg_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FCtype.zd_arg.Next
inline acr::FField*  zd_arg_Next(acr::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FCtype.zd_arg.Prev
inline acr::FField*  zd_arg_Prev(acr::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FCtype.zd_arg.Remove
void                 zd_arg_Remove(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCtype.zd_arg.RemoveAll
void                 zd_arg_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FCtype.zd_arg.RemoveFirst
acr::FField*         zd_arg_RemoveFirst(acr::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FCtype.zd_arg.qLast
inline acr::FField&  zd_arg_qLast(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
// func:acr.FCtype.topokey.Lt
inline bool          topokey_Lt(acr::FCtype& ctype, acr::FCtype &rhs) __attribute__((nothrow));
// Compare two fields.
// func:acr.FCtype.topokey.Cmp
inline i32           topokey_Cmp(acr::FCtype& ctype, acr::FCtype &rhs) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FCtype.c_ssimreq.EmptyQ
inline bool          c_ssimreq_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FCtype.c_ssimreq.Find
inline acr::FSsimreq* c_ssimreq_Find(acr::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FCtype.c_ssimreq.Getary
inline algo::aryptr<acr::FSsimreq*> c_ssimreq_Getary(acr::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FCtype.c_ssimreq.Insert
void                 c_ssimreq_Insert(acr::FCtype& ctype, acr::FSsimreq& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:acr.FCtype.c_ssimreq.InsertMaybe
bool                 c_ssimreq_InsertMaybe(acr::FCtype& ctype, acr::FSsimreq& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FCtype.c_ssimreq.N
inline i32           c_ssimreq_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FCtype.c_ssimreq.Remove
void                 c_ssimreq_Remove(acr::FCtype& ctype, acr::FSsimreq& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FCtype.c_ssimreq.RemoveAll
inline void          c_ssimreq_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FCtype.c_ssimreq.Reserve
void                 c_ssimreq_Reserve(acr::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FCtype.c_ssimreq.qFind
inline acr::FSsimreq& c_ssimreq_qFind(acr::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:acr.FCtype.c_ssimreq.InAryQ
inline bool          ctype_c_ssimreq_InAryQ(acr::FSsimreq& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FCtype.c_ssimreq.qLast
inline acr::FSsimreq& c_ssimreq_qLast(acr::FCtype& ctype) __attribute__((nothrow));

// func:acr.FCtype.c_field_curs.Reset
inline void          ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.c_field_curs.ValidQ
inline bool          ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.c_field_curs.Next
inline void          ctype_c_field_curs_Next(ctype_c_field_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.c_field_curs.Access
inline acr::FField&  ctype_c_field_curs_Access(ctype_c_field_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.zd_ctype_rec_curs.Reset
inline void          ctype_zd_ctype_rec_curs_Reset(ctype_zd_ctype_rec_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.zd_ctype_rec_curs.ValidQ
inline bool          ctype_zd_ctype_rec_curs_ValidQ(ctype_zd_ctype_rec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.zd_ctype_rec_curs.Next
inline void          ctype_zd_ctype_rec_curs_Next(ctype_zd_ctype_rec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.zd_ctype_rec_curs.Access
inline acr::FRec&    ctype_zd_ctype_rec_curs_Access(ctype_zd_ctype_rec_curs &curs) __attribute__((nothrow));
// func:acr.FCtype.ind_ctype_rec_curs.Reset
void                 ctype_ind_ctype_rec_curs_Reset(ctype_ind_ctype_rec_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.ind_ctype_rec_curs.ValidQ
inline bool          ctype_ind_ctype_rec_curs_ValidQ(ctype_ind_ctype_rec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.ind_ctype_rec_curs.Next
inline void          ctype_ind_ctype_rec_curs_Next(ctype_ind_ctype_rec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.ind_ctype_rec_curs.Access
inline acr::FRec&    ctype_ind_ctype_rec_curs_Access(ctype_ind_ctype_rec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.zd_ctype_selrec_curs.Reset
inline void          ctype_zd_ctype_selrec_curs_Reset(ctype_zd_ctype_selrec_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.zd_ctype_selrec_curs.ValidQ
inline bool          ctype_zd_ctype_selrec_curs_ValidQ(ctype_zd_ctype_selrec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.zd_ctype_selrec_curs.Next
inline void          ctype_zd_ctype_selrec_curs_Next(ctype_zd_ctype_selrec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.zd_ctype_selrec_curs.Access
inline acr::FRec&    ctype_zd_ctype_selrec_curs_Access(ctype_zd_ctype_selrec_curs &curs) __attribute__((nothrow));
// func:acr.FCtype.c_child_curs.Reset
inline void          ctype_c_child_curs_Reset(ctype_c_child_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.c_child_curs.ValidQ
inline bool          ctype_c_child_curs_ValidQ(ctype_c_child_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.c_child_curs.Next
inline void          ctype_c_child_curs_Next(ctype_c_child_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.c_child_curs.Access
inline acr::FCtype&  ctype_c_child_curs_Access(ctype_c_child_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.zd_arg_curs.Reset
inline void          ctype_zd_arg_curs_Reset(ctype_zd_arg_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.zd_arg_curs.ValidQ
inline bool          ctype_zd_arg_curs_ValidQ(ctype_zd_arg_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.zd_arg_curs.Next
inline void          ctype_zd_arg_curs_Next(ctype_zd_arg_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.zd_arg_curs.Access
inline acr::FField&  ctype_zd_arg_curs_Access(ctype_zd_arg_curs &curs) __attribute__((nothrow));
// func:acr.FCtype.c_ssimreq_curs.Reset
inline void          ctype_c_ssimreq_curs_Reset(ctype_c_ssimreq_curs &curs, acr::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FCtype.c_ssimreq_curs.ValidQ
inline bool          ctype_c_ssimreq_curs_ValidQ(ctype_c_ssimreq_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FCtype.c_ssimreq_curs.Next
inline void          ctype_c_ssimreq_curs_Next(ctype_c_ssimreq_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FCtype.c_ssimreq_curs.Access
inline acr::FSsimreq& ctype_c_ssimreq_curs_Access(ctype_c_ssimreq_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.FCtype..Init
void                 FCtype_Init(acr::FCtype& ctype);
// func:acr.FCtype..Uninit
void                 FCtype_Uninit(acr::FCtype& ctype) __attribute__((nothrow));

// --- acr.trace
#pragma pack(push,1)
struct trace { // acr.trace
    // func:acr.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)

// print string representation of ROW to string STR
// cfmt:acr.trace.String  printfmt:Tuple
// func:acr.trace..Print
void                 trace_Print(acr::trace& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.FDb
// create: acr.FDb._db (Global)
struct FDb { // acr.FDb: In-memory database for acr
    u64                  pline_blocksize;                // # bytes per block
    acr::FPline*         pline_free;                     //
    u64                  pdep_blocksize;                 // # bytes per block
    acr::FPdep*          pdep_free;                      //
    acr::FPline*         zd_pline_head;                  // zero-terminated doubly linked list
    acr::FPline*         zd_pline_tail;                  // pointer to last element
    acr::FPdep*          zd_pdep_head;                   // zero-terminated doubly linked list
    acr::FPdep*          zd_pdep_tail;                   // pointer to last element
    command::acr         cmdline;                        // command line
    acr::FCtype*         ctype_lary[32];                 // level array
    i32                  ctype_n;                        // number of elements in array
    u64                  err_blocksize;                  // # bytes per block
    acr::FErr*           err_free;                       //
    acr::FAnonfld*       anonfld_lary[32];               // level array
    i32                  anonfld_n;                      // number of elements in array
    acr::FCdflt*         cdflt_lary[32];                 // level array
    i32                  cdflt_n;                        // number of elements in array
    u64                  rec_blocksize;                  // # bytes per block
    acr::FRec*           rec_free;                       //
    u64                  uniqueattr_blocksize;           // # bytes per block
    acr::FUniqueattr*    uniqueattr_free;                //
    u64                  query_blocksize;                // # bytes per block
    acr::FQuery*         query_free;                     //
    acr::FField*         field_lary[32];                 // level array
    i32                  field_n;                        // number of elements in array
    acr::FFile*          file_lary[32];                  // level array
    i32                  file_n;                         // number of elements in array
    u32                  err_seq;                        //   0
    bool                 check_failed;                   //   false
    acr::FCtype**        ind_ctype_buckets_elems;        // pointer to bucket array
    i32                  ind_ctype_buckets_n;            // number of elements in bucket array
    i32                  ind_ctype_n;                    // number of elements in the hash table
    acr::FField**        ind_field_buckets_elems;        // pointer to bucket array
    i32                  ind_field_buckets_n;            // number of elements in bucket array
    i32                  ind_field_n;                    // number of elements in the hash table
    acr::FFile**         ind_file_buckets_elems;         // pointer to bucket array
    i32                  ind_file_buckets_n;             // number of elements in bucket array
    i32                  ind_file_n;                     // number of elements in the hash table
    acr::FRec*           zd_all_selrec_head;             // zero-terminated doubly linked list
    i32                  zd_all_selrec_n;                // zero-terminated doubly linked list
    acr::FRec*           zd_all_selrec_tail;             // pointer to last element
    acr::FErr*           zd_all_err_head;                // zero-terminated doubly linked list
    i32                  zd_all_err_n;                   // zero-terminated doubly linked list
    acr::FErr*           zd_all_err_tail;                // pointer to last element
    acr::FCtype*         zd_sel_ctype_head;              // zero-terminated doubly linked list
    acr::FCtype*         zd_sel_ctype_tail;              // pointer to last element
    acr::FPline**        bh_pline_elems;                 // binary heap by key
    i32                  bh_pline_n;                     // number of elements in the heap
    i32                  bh_pline_max;                   // max elements in bh_pline_elems
    acr::FSubstr*        substr_lary[32];                // level array
    i32                  substr_n;                       // number of elements in array
    acr::FSsimfile*      ssimfile_lary[32];              // level array
    i32                  ssimfile_n;                     // number of elements in array
    acr::FTempkey*       tempkey_lary[32];               // level array
    i32                  tempkey_n;                      // number of elements in array
    acr::FTempkey**      ind_tempkey_buckets_elems;      // pointer to bucket array
    i32                  ind_tempkey_buckets_n;          // number of elements in bucket array
    i32                  ind_tempkey_n;                  // number of elements in the hash table
    acr::FSsimfile**     ind_ssimfile_buckets_elems;     // pointer to bucket array
    i32                  ind_ssimfile_buckets_n;         // number of elements in bucket array
    i32                  ind_ssimfile_n;                 // number of elements in the hash table
    acr::FQuery*         zs_query_head;                  // zero-terminated singly linked list
    acr::FQuery*         zs_query_tail;                  // pointer to last element
    acr::FSsimsort*      ssimsort_lary[32];              // level array
    i32                  ssimsort_n;                     // number of elements in array
    acr::FSsimsort**     ind_ssimsort_buckets_elems;     // pointer to bucket array
    i32                  ind_ssimsort_buckets_n;         // number of elements in bucket array
    i32                  ind_ssimsort_n;                 // number of elements in the hash table
    u32                  n_file_written;                 //   0  Number of files written
    report::acr          report;                         // Final report
    acr::FSmallstr*      smallstr_lary[32];              // level array
    i32                  smallstr_n;                     // number of elements in array
    acr::FFunique*       funique_lary[32];               // level array
    i32                  funique_n;                      // number of elements in array
    acr::FUniqueattr**   ind_uniqueattr_buckets_elems;   // pointer to bucket array
    i32                  ind_uniqueattr_buckets_n;       // number of elements in bucket array
    i32                  ind_uniqueattr_n;               // number of elements in the hash table
    acr::FBltin*         bltin_lary[32];                 // level array
    i32                  bltin_n;                        // number of elements in array
    bool                 ctype_rank_computed;            //   false
    bool                 file_input;                     //   false
    acr::FCtype**        bh_ctype_topo_elems;            // binary heap by topokey
    i32                  bh_ctype_topo_n;                // number of elements in the heap
    i32                  bh_ctype_topo_max;              // max elements in bh_ctype_topo_elems
    acr::FCppfunc*       cppfunc_lary[32];               // level array
    i32                  cppfunc_n;                      // number of elements in array
    acr::FSsimreq*       ssimreq_lary[32];               // level array
    i32                  ssimreq_n;                      // number of elements in array
    acr::FRec**          c_ssimreq_rec_elems;            // array of pointers
    u32                  c_ssimreq_rec_n;                // array of pointers
    u32                  c_ssimreq_rec_max;              // capacity of allocated array
    acr::FCtype*         c_field_ctype;                  // ctype describing dmmeta.Field. optional pointer
    acr::FCtype*         c_ssimfile_ctype;               // ctype describing dmmeta.Ssimfile. optional pointer
    acr::FCtype**        c_ctype_front_elems;            // array of pointers
    u32                  c_ctype_front_n;                // array of pointers
    u32                  c_ctype_front_max;              // capacity of allocated array
    acr::FSortkey*       sortkey_lary[32];               // level array
    i32                  sortkey_n;                      // number of elements in array
    acr::FSortkey**      ind_sortkey_buckets_elems;      // pointer to bucket array
    i32                  ind_sortkey_buckets_n;          // number of elements in bucket array
    i32                  ind_sortkey_n;                  // number of elements in the hash table
    acr::trace           trace;                          //
};

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.pline.Alloc
acr::FPline&         pline_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.pline.AllocMaybe
acr::FPline*         pline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.pline.Delete
void                 pline_Delete(acr::FPline &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:acr.FDb.pline.AllocMem
void*                pline_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.pline.FreeMem
void                 pline_FreeMem(acr::FPline &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:acr.FDb.pline.Reserve
u64                  pline_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:acr.FDb.pline.ReserveMem
u64                  pline_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.pline.XrefMaybe
bool                 pline_XrefMaybe(acr::FPline &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.pdep.Alloc
acr::FPdep&          pdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.pdep.AllocMaybe
acr::FPdep*          pdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.pdep.Delete
void                 pdep_Delete(acr::FPdep &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:acr.FDb.pdep.AllocMem
void*                pdep_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.pdep.FreeMem
void                 pdep_FreeMem(acr::FPdep &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:acr.FDb.pdep.Reserve
u64                  pdep_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:acr.FDb.pdep.ReserveMem
u64                  pdep_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.pdep.XrefMaybe
bool                 pdep_XrefMaybe(acr::FPdep &row);

// Delete all elements in the linked list.
// func:acr.FDb.zd_pline.Cascdel
void                 zd_pline_Cascdel() __attribute__((nothrow));
// Return true if index is empty
// func:acr.FDb.zd_pline.EmptyQ
inline bool          zd_pline_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.zd_pline.First
inline acr::FPline*  zd_pline_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FDb.zd_pline.InLlistQ
inline bool          zd_pline_InLlistQ(acr::FPline& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FDb.zd_pline.Insert
void                 zd_pline_Insert(acr::FPline& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FDb.zd_pline.Last
inline acr::FPline*  zd_pline_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FDb.zd_pline.Next
inline acr::FPline*  zd_pline_Next(acr::FPline &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FDb.zd_pline.Prev
inline acr::FPline*  zd_pline_Prev(acr::FPline &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.zd_pline.Remove
void                 zd_pline_Remove(acr::FPline& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.zd_pline.RemoveAll
void                 zd_pline_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FDb.zd_pline.RemoveFirst
acr::FPline*         zd_pline_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FDb.zd_pline.qLast
inline acr::FPline&  zd_pline_qLast() __attribute__((__warn_unused_result__, nothrow));

// Delete all elements in the linked list.
// func:acr.FDb.zd_pdep.Cascdel
void                 zd_pdep_Cascdel() __attribute__((nothrow));
// Return true if index is empty
// func:acr.FDb.zd_pdep.EmptyQ
inline bool          zd_pdep_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.zd_pdep.First
inline acr::FPdep*   zd_pdep_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FDb.zd_pdep.InLlistQ
inline bool          zd_pdep_InLlistQ(acr::FPdep& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FDb.zd_pdep.Insert
void                 zd_pdep_Insert(acr::FPdep& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FDb.zd_pdep.Last
inline acr::FPdep*   zd_pdep_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FDb.zd_pdep.Next
inline acr::FPdep*   zd_pdep_Next(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FDb.zd_pdep.Prev
inline acr::FPdep*   zd_pdep_Prev(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.zd_pdep.Remove
void                 zd_pdep_Remove(acr::FPdep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.zd_pdep.RemoveAll
void                 zd_pdep_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FDb.zd_pdep.RemoveFirst
acr::FPdep*          zd_pdep_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FDb.zd_pdep.qLast
inline acr::FPdep&   zd_pdep_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.ctype.Alloc
acr::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.ctype.AllocMaybe
acr::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.ctype.InsertMaybe
acr::FCtype*         ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.ctype.AllocMem
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.ctype.EmptyQ
inline bool          ctype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.ctype.Find
inline acr::FCtype*  ctype_Find(i32 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.ctype.Last
inline acr::FCtype*  ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.ctype.N
inline i32           ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.ctype.RemoveLast
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.ctype.qFind
inline acr::FCtype&  ctype_qFind(i32 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.ctype.XrefMaybe
bool                 ctype_XrefMaybe(acr::FCtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.err.Alloc
acr::FErr&           err_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.err.AllocMaybe
acr::FErr*           err_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.err.InsertMaybe
acr::FErr*           err_InsertMaybe(const acr::Err &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.err.Delete
void                 err_Delete(acr::FErr &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:acr.FDb.err.AllocMem
void*                err_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.err.FreeMem
void                 err_FreeMem(acr::FErr &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:acr.FDb.err.Reserve
u64                  err_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:acr.FDb.err.ReserveMem
u64                  err_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.err.XrefMaybe
bool                 err_XrefMaybe(acr::FErr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.anonfld.Alloc
acr::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.anonfld.AllocMaybe
acr::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.anonfld.InsertMaybe
acr::FAnonfld*       anonfld_InsertMaybe(const dmmeta::Anonfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.anonfld.AllocMem
void*                anonfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.anonfld.EmptyQ
inline bool          anonfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.anonfld.Find
inline acr::FAnonfld* anonfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.anonfld.Last
inline acr::FAnonfld* anonfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.anonfld.N
inline i32           anonfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.anonfld.RemoveLast
void                 anonfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.anonfld.qFind
inline acr::FAnonfld& anonfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.anonfld.XrefMaybe
bool                 anonfld_XrefMaybe(acr::FAnonfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.cdflt.Alloc
acr::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.cdflt.AllocMaybe
acr::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.cdflt.InsertMaybe
acr::FCdflt*         cdflt_InsertMaybe(const dmmeta::Cdflt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.cdflt.AllocMem
void*                cdflt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.cdflt.EmptyQ
inline bool          cdflt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.cdflt.Find
inline acr::FCdflt*  cdflt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.cdflt.Last
inline acr::FCdflt*  cdflt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.cdflt.N
inline i32           cdflt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.cdflt.RemoveLast
void                 cdflt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.cdflt.qFind
inline acr::FCdflt&  cdflt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.cdflt.XrefMaybe
bool                 cdflt_XrefMaybe(acr::FCdflt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.rec.Alloc
acr::FRec&           rec_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.rec.AllocMaybe
acr::FRec*           rec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.rec.Delete
void                 rec_Delete(acr::FRec &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:acr.FDb.rec.AllocMem
void*                rec_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.rec.FreeMem
void                 rec_FreeMem(acr::FRec &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:acr.FDb.rec.Reserve
u64                  rec_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:acr.FDb.rec.ReserveMem
u64                  rec_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.rec.XrefMaybe
bool                 rec_XrefMaybe(acr::FRec &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.uniqueattr.Alloc
acr::FUniqueattr&    uniqueattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.uniqueattr.AllocMaybe
acr::FUniqueattr*    uniqueattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.uniqueattr.Delete
void                 uniqueattr_Delete(acr::FUniqueattr &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:acr.FDb.uniqueattr.AllocMem
void*                uniqueattr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.uniqueattr.FreeMem
void                 uniqueattr_FreeMem(acr::FUniqueattr &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:acr.FDb.uniqueattr.Reserve
u64                  uniqueattr_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:acr.FDb.uniqueattr.ReserveMem
u64                  uniqueattr_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.uniqueattr.XrefMaybe
bool                 uniqueattr_XrefMaybe(acr::FUniqueattr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.query.Alloc
acr::FQuery&         query_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.query.AllocMaybe
acr::FQuery*         query_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.query.Delete
void                 query_Delete(acr::FQuery &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:acr.FDb.query.AllocMem
void*                query_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.query.FreeMem
void                 query_FreeMem(acr::FQuery &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:acr.FDb.query.Reserve
u64                  query_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:acr.FDb.query.ReserveMem
u64                  query_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.query.XrefMaybe
bool                 query_XrefMaybe(acr::FQuery &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.field.Alloc
acr::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.field.AllocMaybe
acr::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.field.InsertMaybe
acr::FField*         field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.field.AllocMem
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.field.EmptyQ
inline bool          field_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.field.Find
inline acr::FField*  field_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.field.Last
inline acr::FField*  field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.field.N
inline i32           field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.field.RemoveLast
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.field.qFind
inline acr::FField&  field_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.field.XrefMaybe
bool                 field_XrefMaybe(acr::FField &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.file.Alloc
acr::FFile&          file_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.file.AllocMaybe
acr::FFile*          file_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.file.AllocMem
void*                file_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.file.EmptyQ
inline bool          file_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.file.Find
inline acr::FFile*   file_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.file.Last
inline acr::FFile*   file_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.file.N
inline i32           file_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr.FDb.file.RemoveAll
void                 file_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.file.RemoveLast
void                 file_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.file.qFind
inline acr::FFile&   file_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.file.XrefMaybe
bool                 file_XrefMaybe(acr::FFile &row);

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     acr.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:acr.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
// func:acr.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:acr.FDb._db.Step
void                 Step();
// Main function
// func:acr.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:acr.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:acr.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:acr.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:acr.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load specified ssimfile.
// func:acr.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:acr.FDb._db.Steps
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();

// Return true if hash is empty
// func:acr.FDb.ind_ctype.EmptyQ
inline bool          ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_ctype.Find
acr::FCtype*         ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_ctype.N
inline i32           ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_ctype.InsertMaybe
bool                 ind_ctype_InsertMaybe(acr::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_ctype.Remove
void                 ind_ctype_Remove(acr::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_ctype.Reserve
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:acr.FDb.ind_field.EmptyQ
inline bool          ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_field.Find
acr::FField*         ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_field.N
inline i32           ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_field.InsertMaybe
bool                 ind_field_InsertMaybe(acr::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_field.Remove
void                 ind_field_Remove(acr::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_field.Reserve
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:acr.FDb.ind_file.EmptyQ
inline bool          ind_file_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_file.Find
acr::FFile*          ind_file_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr.FDb.ind_file.GetOrCreate
acr::FFile&          ind_file_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_file.N
inline i32           ind_file_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_file.InsertMaybe
bool                 ind_file_InsertMaybe(acr::FFile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_file.Remove
void                 ind_file_Remove(acr::FFile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_file.Reserve
void                 ind_file_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FDb.zd_all_selrec.EmptyQ
inline bool          zd_all_selrec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.zd_all_selrec.First
inline acr::FRec*    zd_all_selrec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FDb.zd_all_selrec.InLlistQ
inline bool          zd_all_selrec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FDb.zd_all_selrec.Insert
void                 zd_all_selrec_Insert(acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FDb.zd_all_selrec.Last
inline acr::FRec*    zd_all_selrec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:acr.FDb.zd_all_selrec.N
inline i32           zd_all_selrec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FDb.zd_all_selrec.Next
inline acr::FRec*    zd_all_selrec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FDb.zd_all_selrec.Prev
inline acr::FRec*    zd_all_selrec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.zd_all_selrec.Remove
void                 zd_all_selrec_Remove(acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.zd_all_selrec.RemoveAll
void                 zd_all_selrec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FDb.zd_all_selrec.RemoveFirst
acr::FRec*           zd_all_selrec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FDb.zd_all_selrec.qLast
inline acr::FRec&    zd_all_selrec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:acr.FDb.zd_all_err.EmptyQ
inline bool          zd_all_err_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.zd_all_err.First
inline acr::FErr*    zd_all_err_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FDb.zd_all_err.InLlistQ
inline bool          zd_all_err_InLlistQ(acr::FErr& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FDb.zd_all_err.Insert
void                 zd_all_err_Insert(acr::FErr& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FDb.zd_all_err.Last
inline acr::FErr*    zd_all_err_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:acr.FDb.zd_all_err.N
inline i32           zd_all_err_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FDb.zd_all_err.Next
inline acr::FErr*    zd_all_err_Next(acr::FErr &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FDb.zd_all_err.Prev
inline acr::FErr*    zd_all_err_Prev(acr::FErr &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.zd_all_err.Remove
void                 zd_all_err_Remove(acr::FErr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.zd_all_err.RemoveAll
void                 zd_all_err_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FDb.zd_all_err.RemoveFirst
acr::FErr*           zd_all_err_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FDb.zd_all_err.qLast
inline acr::FErr&    zd_all_err_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:acr.FDb.zd_sel_ctype.EmptyQ
inline bool          zd_sel_ctype_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.zd_sel_ctype.First
inline acr::FCtype*  zd_sel_ctype_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FDb.zd_sel_ctype.InLlistQ
inline bool          zd_sel_ctype_InLlistQ(acr::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FDb.zd_sel_ctype.Insert
void                 zd_sel_ctype_Insert(acr::FCtype& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FDb.zd_sel_ctype.Last
inline acr::FCtype*  zd_sel_ctype_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FDb.zd_sel_ctype.Next
inline acr::FCtype*  zd_sel_ctype_Next(acr::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FDb.zd_sel_ctype.Prev
inline acr::FCtype*  zd_sel_ctype_Prev(acr::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.zd_sel_ctype.Remove
void                 zd_sel_ctype_Remove(acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.zd_sel_ctype.RemoveAll
void                 zd_sel_ctype_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FDb.zd_sel_ctype.RemoveFirst
acr::FCtype*         zd_sel_ctype_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FDb.zd_sel_ctype.qLast
inline acr::FCtype&  zd_sel_ctype_qLast() __attribute__((__warn_unused_result__, nothrow));

// Remove all elements from heap and free memory used by the array.
// func:acr.FDb.bh_pline.Dealloc
void                 bh_pline_Dealloc() __attribute__((nothrow));
// Return true if index is empty
// func:acr.FDb.bh_pline.EmptyQ
inline bool          bh_pline_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.bh_pline.First
inline acr::FPline*  bh_pline_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:acr.FDb.bh_pline.InBheapQ
inline bool          bh_pline_InBheapQ(acr::FPline& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:acr.FDb.bh_pline.Insert
void                 bh_pline_Insert(acr::FPline& row) __attribute__((nothrow));
// Return number of items in the heap
// func:acr.FDb.bh_pline.N
inline i32           bh_pline_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:acr.FDb.bh_pline.Reheap
i32                  bh_pline_Reheap(acr::FPline& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:acr.FDb.bh_pline.ReheapFirst
i32                  bh_pline_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.bh_pline.Remove
void                 bh_pline_Remove(acr::FPline& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:acr.FDb.bh_pline.RemoveAll
void                 bh_pline_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:acr.FDb.bh_pline.RemoveFirst
acr::FPline*         bh_pline_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
// func:acr.FDb.bh_pline.Reserve
void                 bh_pline_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.substr.Alloc
acr::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.substr.AllocMaybe
acr::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.substr.InsertMaybe
acr::FSubstr*        substr_InsertMaybe(const dmmeta::Substr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.substr.AllocMem
void*                substr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.substr.EmptyQ
inline bool          substr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.substr.Find
inline acr::FSubstr* substr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.substr.Last
inline acr::FSubstr* substr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.substr.N
inline i32           substr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.substr.RemoveLast
void                 substr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.substr.qFind
inline acr::FSubstr& substr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.substr.XrefMaybe
bool                 substr_XrefMaybe(acr::FSubstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.ssimfile.Alloc
acr::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.ssimfile.AllocMaybe
acr::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.ssimfile.InsertMaybe
acr::FSsimfile*      ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.ssimfile.AllocMem
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.ssimfile.EmptyQ
inline bool          ssimfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.ssimfile.Find
inline acr::FSsimfile* ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.ssimfile.Last
inline acr::FSsimfile* ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.ssimfile.N
inline i32           ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.ssimfile.RemoveLast
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.ssimfile.qFind
inline acr::FSsimfile& ssimfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.ssimfile.XrefMaybe
bool                 ssimfile_XrefMaybe(acr::FSsimfile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.tempkey.Alloc
acr::FTempkey&       tempkey_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.tempkey.AllocMaybe
acr::FTempkey*       tempkey_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.tempkey.AllocMem
void*                tempkey_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.tempkey.EmptyQ
inline bool          tempkey_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.tempkey.Find
inline acr::FTempkey* tempkey_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.tempkey.Last
inline acr::FTempkey* tempkey_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.tempkey.N
inline i32           tempkey_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr.FDb.tempkey.RemoveAll
void                 tempkey_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.tempkey.RemoveLast
void                 tempkey_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.tempkey.qFind
inline acr::FTempkey& tempkey_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.tempkey.XrefMaybe
bool                 tempkey_XrefMaybe(acr::FTempkey &row);

// Return true if hash is empty
// func:acr.FDb.ind_tempkey.EmptyQ
inline bool          ind_tempkey_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_tempkey.Find
acr::FTempkey*       ind_tempkey_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr.FDb.ind_tempkey.GetOrCreate
acr::FTempkey&       ind_tempkey_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_tempkey.N
inline i32           ind_tempkey_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_tempkey.InsertMaybe
bool                 ind_tempkey_InsertMaybe(acr::FTempkey& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_tempkey.Remove
void                 ind_tempkey_Remove(acr::FTempkey& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_tempkey.Reserve
void                 ind_tempkey_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:acr.FDb.ind_ssimfile.EmptyQ
inline bool          ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_ssimfile.Find
acr::FSsimfile*      ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_ssimfile.N
inline i32           ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_ssimfile.InsertMaybe
bool                 ind_ssimfile_InsertMaybe(acr::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_ssimfile.Remove
void                 ind_ssimfile_Remove(acr::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_ssimfile.Reserve
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.print.XrefMaybe
bool                 print_XrefMaybe(acr::FPrint &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.printattr.Alloc
acr::FPrintAttr&     printattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.printattr.AllocMaybe
acr::FPrintAttr*     printattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:acr.FDb.printattr.Delete
void                 printattr_Delete(acr::FPrintAttr &row) __attribute__((nothrow));
// Allocate n bytes. If no memory available, return NULL.
// func:acr.FDb.printattr.AllocMem
void*                printattr_AllocMem(size_t n) __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:acr.FDb.printattr.FreeMem
void                 printattr_FreeMem(void *mem, size_t n) __attribute__((nothrow));
// Reallocate n bytes. If the call fails, return value is NULL.
// In this case, original MEM pointer is untouched.
// func:acr.FDb.printattr.ReallocMem
void*                printattr_ReallocMem(void *mem, size_t old_size, size_t new_size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.printattr.XrefMaybe
bool                 printattr_XrefMaybe(acr::FPrintAttr &row);

// Return true if index is empty
// func:acr.FDb.zs_query.EmptyQ
inline bool          zs_query_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.zs_query.First
inline acr::FQuery*  zs_query_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FDb.zs_query.InLlistQ
inline bool          zs_query_InLlistQ(acr::FQuery& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FDb.zs_query.Insert
void                 zs_query_Insert(acr::FQuery& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FDb.zs_query.Last
inline acr::FQuery*  zs_query_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FDb.zs_query.Next
inline acr::FQuery*  zs_query_Next(acr::FQuery &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:acr.FDb.zs_query.Remove
void                 zs_query_Remove(acr::FQuery& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.zs_query.RemoveAll
void                 zs_query_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FDb.zs_query.RemoveFirst
acr::FQuery*         zs_query_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FDb.zs_query.qLast
inline acr::FQuery&  zs_query_qLast() __attribute__((__warn_unused_result__, nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.check.XrefMaybe
bool                 check_XrefMaybe(acr::FCheck &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.ssimsort.Alloc
acr::FSsimsort&      ssimsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.ssimsort.AllocMaybe
acr::FSsimsort*      ssimsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.ssimsort.InsertMaybe
acr::FSsimsort*      ssimsort_InsertMaybe(const dmmeta::Ssimsort &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.ssimsort.AllocMem
void*                ssimsort_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.ssimsort.EmptyQ
inline bool          ssimsort_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.ssimsort.Find
inline acr::FSsimsort* ssimsort_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.ssimsort.Last
inline acr::FSsimsort* ssimsort_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.ssimsort.N
inline i32           ssimsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.ssimsort.RemoveLast
void                 ssimsort_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.ssimsort.qFind
inline acr::FSsimsort& ssimsort_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.ssimsort.XrefMaybe
bool                 ssimsort_XrefMaybe(acr::FSsimsort &row);

// Return true if hash is empty
// func:acr.FDb.ind_ssimsort.EmptyQ
inline bool          ind_ssimsort_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_ssimsort.Find
acr::FSsimsort*      ind_ssimsort_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_ssimsort.N
inline i32           ind_ssimsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_ssimsort.InsertMaybe
bool                 ind_ssimsort_InsertMaybe(acr::FSsimsort& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_ssimsort.Remove
void                 ind_ssimsort_Remove(acr::FSsimsort& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_ssimsort.Reserve
void                 ind_ssimsort_Reserve(int n) __attribute__((nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.write.XrefMaybe
bool                 write_XrefMaybe(acr::FWrite &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.smallstr.Alloc
acr::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.smallstr.AllocMaybe
acr::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.smallstr.InsertMaybe
acr::FSmallstr*      smallstr_InsertMaybe(const dmmeta::Smallstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.smallstr.AllocMem
void*                smallstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.smallstr.EmptyQ
inline bool          smallstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.smallstr.Find
inline acr::FSmallstr* smallstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.smallstr.Last
inline acr::FSmallstr* smallstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.smallstr.N
inline i32           smallstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.smallstr.RemoveLast
void                 smallstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.smallstr.qFind
inline acr::FSmallstr& smallstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.smallstr.XrefMaybe
bool                 smallstr_XrefMaybe(acr::FSmallstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.funique.Alloc
acr::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.funique.AllocMaybe
acr::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.funique.InsertMaybe
acr::FFunique*       funique_InsertMaybe(const dmmeta::Funique &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.funique.AllocMem
void*                funique_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.funique.EmptyQ
inline bool          funique_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.funique.Find
inline acr::FFunique* funique_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.funique.Last
inline acr::FFunique* funique_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.funique.N
inline i32           funique_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.funique.RemoveLast
void                 funique_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.funique.qFind
inline acr::FFunique& funique_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.funique.XrefMaybe
bool                 funique_XrefMaybe(acr::FFunique &row);

// Return true if hash is empty
// func:acr.FDb.ind_uniqueattr.EmptyQ
inline bool          ind_uniqueattr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_uniqueattr.Find
acr::FUniqueattr*    ind_uniqueattr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr.FDb.ind_uniqueattr.GetOrCreate
acr::FUniqueattr&    ind_uniqueattr_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_uniqueattr.N
inline i32           ind_uniqueattr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_uniqueattr.InsertMaybe
bool                 ind_uniqueattr_InsertMaybe(acr::FUniqueattr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_uniqueattr.Remove
void                 ind_uniqueattr_Remove(acr::FUniqueattr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_uniqueattr.Reserve
void                 ind_uniqueattr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.bltin.Alloc
acr::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.bltin.AllocMaybe
acr::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.bltin.InsertMaybe
acr::FBltin*         bltin_InsertMaybe(const amcdb::Bltin &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.bltin.AllocMem
void*                bltin_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.bltin.EmptyQ
inline bool          bltin_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.bltin.Find
inline acr::FBltin*  bltin_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.bltin.Last
inline acr::FBltin*  bltin_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.bltin.N
inline i32           bltin_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.bltin.RemoveLast
void                 bltin_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.bltin.qFind
inline acr::FBltin&  bltin_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.bltin.XrefMaybe
bool                 bltin_XrefMaybe(acr::FBltin &row);

// Remove all elements from heap and free memory used by the array.
// func:acr.FDb.bh_ctype_topo.Dealloc
void                 bh_ctype_topo_Dealloc() __attribute__((nothrow));
// Return true if index is empty
// func:acr.FDb.bh_ctype_topo.EmptyQ
inline bool          bh_ctype_topo_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FDb.bh_ctype_topo.First
inline acr::FCtype*  bh_ctype_topo_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:acr.FDb.bh_ctype_topo.InBheapQ
inline bool          bh_ctype_topo_InBheapQ(acr::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:acr.FDb.bh_ctype_topo.Insert
void                 bh_ctype_topo_Insert(acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the heap
// func:acr.FDb.bh_ctype_topo.N
inline i32           bh_ctype_topo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:acr.FDb.bh_ctype_topo.Reheap
i32                  bh_ctype_topo_Reheap(acr::FCtype& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:acr.FDb.bh_ctype_topo.ReheapFirst
i32                  bh_ctype_topo_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FDb.bh_ctype_topo.Remove
void                 bh_ctype_topo_Remove(acr::FCtype& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:acr.FDb.bh_ctype_topo.RemoveAll
void                 bh_ctype_topo_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:acr.FDb.bh_ctype_topo.RemoveFirst
acr::FCtype*         bh_ctype_topo_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
// func:acr.FDb.bh_ctype_topo.Reserve
void                 bh_ctype_topo_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.cppfunc.Alloc
acr::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.cppfunc.AllocMaybe
acr::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.cppfunc.InsertMaybe
acr::FCppfunc*       cppfunc_InsertMaybe(const dmmeta::Cppfunc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.cppfunc.AllocMem
void*                cppfunc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.cppfunc.EmptyQ
inline bool          cppfunc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.cppfunc.Find
inline acr::FCppfunc* cppfunc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.cppfunc.Last
inline acr::FCppfunc* cppfunc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.cppfunc.N
inline i32           cppfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr.FDb.cppfunc.RemoveAll
void                 cppfunc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.cppfunc.RemoveLast
void                 cppfunc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.cppfunc.qFind
inline acr::FCppfunc& cppfunc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.cppfunc.XrefMaybe
bool                 cppfunc_XrefMaybe(acr::FCppfunc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.ssimreq.Alloc
acr::FSsimreq&       ssimreq_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.ssimreq.AllocMaybe
acr::FSsimreq*       ssimreq_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:acr.FDb.ssimreq.InsertMaybe
acr::FSsimreq*       ssimreq_InsertMaybe(const dmmeta::Ssimreq &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.ssimreq.AllocMem
void*                ssimreq_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.ssimreq.EmptyQ
inline bool          ssimreq_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.ssimreq.Find
inline acr::FSsimreq* ssimreq_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.ssimreq.Last
inline acr::FSsimreq* ssimreq_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.ssimreq.N
inline i32           ssimreq_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr.FDb.ssimreq.RemoveAll
void                 ssimreq_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.ssimreq.RemoveLast
void                 ssimreq_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.ssimreq.qFind
inline acr::FSsimreq& ssimreq_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.ssimreq.XrefMaybe
bool                 ssimreq_XrefMaybe(acr::FSsimreq &row);

// Return true if index is empty
// func:acr.FDb.c_ssimreq_rec.EmptyQ
inline bool          c_ssimreq_rec_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.c_ssimreq_rec.Find
inline acr::FRec*    c_ssimreq_rec_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FDb.c_ssimreq_rec.Getary
inline algo::aryptr<acr::FRec*> c_ssimreq_rec_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FDb.c_ssimreq_rec.Insert
void                 c_ssimreq_rec_Insert(acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:acr.FDb.c_ssimreq_rec.InsertMaybe
bool                 c_ssimreq_rec_InsertMaybe(acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FDb.c_ssimreq_rec.N
inline i32           c_ssimreq_rec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FDb.c_ssimreq_rec.Remove
void                 c_ssimreq_rec_Remove(acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.c_ssimreq_rec.RemoveAll
inline void          c_ssimreq_rec_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FDb.c_ssimreq_rec.Reserve
void                 c_ssimreq_rec_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FDb.c_ssimreq_rec.qFind
inline acr::FRec&    c_ssimreq_rec_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:acr.FDb.c_ssimreq_rec.InAryQ
inline bool          c_ssimreq_rec_InAryQ(acr::FRec& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FDb.c_ssimreq_rec.qLast
inline acr::FRec&    c_ssimreq_rec_qLast() __attribute__((nothrow));

// Return true if index is empty
// func:acr.FDb.c_ctype_front.EmptyQ
inline bool          c_ctype_front_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.c_ctype_front.Find
inline acr::FCtype*  c_ctype_front_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FDb.c_ctype_front.Getary
inline algo::aryptr<acr::FCtype*> c_ctype_front_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FDb.c_ctype_front.Insert
void                 c_ctype_front_Insert(acr::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:acr.FDb.c_ctype_front.InsertMaybe
bool                 c_ctype_front_InsertMaybe(acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FDb.c_ctype_front.N
inline i32           c_ctype_front_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FDb.c_ctype_front.Remove
void                 c_ctype_front_Remove(acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FDb.c_ctype_front.RemoveAll
inline void          c_ctype_front_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FDb.c_ctype_front.Reserve
void                 c_ctype_front_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FDb.c_ctype_front.qFind
inline acr::FCtype&  c_ctype_front_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:acr.FDb.c_ctype_front.InAryQ
inline bool          c_ctype_front_InAryQ(acr::FCtype& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FDb.c_ctype_front.qLast
inline acr::FCtype&  c_ctype_front_qLast() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:acr.FDb.sortkey.Alloc
acr::FSortkey&       sortkey_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:acr.FDb.sortkey.AllocMaybe
acr::FSortkey*       sortkey_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:acr.FDb.sortkey.AllocMem
void*                sortkey_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FDb.sortkey.EmptyQ
inline bool          sortkey_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:acr.FDb.sortkey.Find
inline acr::FSortkey* sortkey_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FDb.sortkey.Last
inline acr::FSortkey* sortkey_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:acr.FDb.sortkey.N
inline i32           sortkey_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:acr.FDb.sortkey.RemoveAll
void                 sortkey_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FDb.sortkey.RemoveLast
void                 sortkey_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FDb.sortkey.qFind
inline acr::FSortkey& sortkey_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:acr.FDb.sortkey.XrefMaybe
bool                 sortkey_XrefMaybe(acr::FSortkey &row);

// Return true if hash is empty
// func:acr.FDb.ind_sortkey.EmptyQ
inline bool          ind_sortkey_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FDb.ind_sortkey.Find
acr::FSortkey*       ind_sortkey_Find(const acr::RecSortkey& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:acr.FDb.ind_sortkey.GetOrCreate
acr::FSortkey&       ind_sortkey_GetOrCreate(const acr::RecSortkey& key) __attribute__((nothrow));
// Return number of items in the hash
// func:acr.FDb.ind_sortkey.N
inline i32           ind_sortkey_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FDb.ind_sortkey.InsertMaybe
bool                 ind_sortkey_InsertMaybe(acr::FSortkey& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FDb.ind_sortkey.Remove
void                 ind_sortkey_Remove(acr::FSortkey& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FDb.ind_sortkey.Reserve
void                 ind_sortkey_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
// func:acr.FDb.zd_pline_curs.Reset
inline void          _db_zd_pline_curs_Reset(_db_zd_pline_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_pline_curs.ValidQ
inline bool          _db_zd_pline_curs_ValidQ(_db_zd_pline_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zd_pline_curs.Next
inline void          _db_zd_pline_curs_Next(_db_zd_pline_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zd_pline_curs.Access
inline acr::FPline&  _db_zd_pline_curs_Access(_db_zd_pline_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_pdep_curs.Reset
inline void          _db_zd_pdep_curs_Reset(_db_zd_pdep_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_pdep_curs.ValidQ
inline bool          _db_zd_pdep_curs_ValidQ(_db_zd_pdep_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zd_pdep_curs.Next
inline void          _db_zd_pdep_curs_Next(_db_zd_pdep_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zd_pdep_curs.Access
inline acr::FPdep&   _db_zd_pdep_curs_Access(_db_zd_pdep_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ctype_curs.Reset
inline void          _db_ctype_curs_Reset(_db_ctype_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ctype_curs.ValidQ
inline bool          _db_ctype_curs_ValidQ(_db_ctype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.ctype_curs.Next
inline void          _db_ctype_curs_Next(_db_ctype_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.ctype_curs.Access
inline acr::FCtype&  _db_ctype_curs_Access(_db_ctype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.anonfld_curs.Reset
inline void          _db_anonfld_curs_Reset(_db_anonfld_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.anonfld_curs.ValidQ
inline bool          _db_anonfld_curs_ValidQ(_db_anonfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.anonfld_curs.Next
inline void          _db_anonfld_curs_Next(_db_anonfld_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.anonfld_curs.Access
inline acr::FAnonfld& _db_anonfld_curs_Access(_db_anonfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.cdflt_curs.Reset
inline void          _db_cdflt_curs_Reset(_db_cdflt_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.cdflt_curs.ValidQ
inline bool          _db_cdflt_curs_ValidQ(_db_cdflt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.cdflt_curs.Next
inline void          _db_cdflt_curs_Next(_db_cdflt_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.cdflt_curs.Access
inline acr::FCdflt&  _db_cdflt_curs_Access(_db_cdflt_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.field_curs.Reset
inline void          _db_field_curs_Reset(_db_field_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.field_curs.ValidQ
inline bool          _db_field_curs_ValidQ(_db_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.field_curs.Next
inline void          _db_field_curs_Next(_db_field_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.field_curs.Access
inline acr::FField&  _db_field_curs_Access(_db_field_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.file_curs.Reset
inline void          _db_file_curs_Reset(_db_file_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.file_curs.ValidQ
inline bool          _db_file_curs_ValidQ(_db_file_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.file_curs.Next
inline void          _db_file_curs_Next(_db_file_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.file_curs.Access
inline acr::FFile&   _db_file_curs_Access(_db_file_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_all_selrec_curs.Reset
inline void          _db_zd_all_selrec_curs_Reset(_db_zd_all_selrec_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_all_selrec_curs.ValidQ
inline bool          _db_zd_all_selrec_curs_ValidQ(_db_zd_all_selrec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zd_all_selrec_curs.Next
inline void          _db_zd_all_selrec_curs_Next(_db_zd_all_selrec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zd_all_selrec_curs.Access
inline acr::FRec&    _db_zd_all_selrec_curs_Access(_db_zd_all_selrec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_all_selrec_delcurs.Reset
inline void          _db_zd_all_selrec_delcurs_Reset(_db_zd_all_selrec_delcurs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_all_selrec_delcurs.ValidQ
inline bool          _db_zd_all_selrec_delcurs_ValidQ(_db_zd_all_selrec_delcurs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zd_all_selrec_delcurs.Next
inline void          _db_zd_all_selrec_delcurs_Next(_db_zd_all_selrec_delcurs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zd_all_selrec_delcurs.Access
inline acr::FRec&    _db_zd_all_selrec_delcurs_Access(_db_zd_all_selrec_delcurs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_all_err_curs.Reset
inline void          _db_zd_all_err_curs_Reset(_db_zd_all_err_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_all_err_curs.ValidQ
inline bool          _db_zd_all_err_curs_ValidQ(_db_zd_all_err_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zd_all_err_curs.Next
inline void          _db_zd_all_err_curs_Next(_db_zd_all_err_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zd_all_err_curs.Access
inline acr::FErr&    _db_zd_all_err_curs_Access(_db_zd_all_err_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_sel_ctype_curs.Reset
inline void          _db_zd_sel_ctype_curs_Reset(_db_zd_sel_ctype_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zd_sel_ctype_curs.ValidQ
inline bool          _db_zd_sel_ctype_curs_ValidQ(_db_zd_sel_ctype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zd_sel_ctype_curs.Next
inline void          _db_zd_sel_ctype_curs_Next(_db_zd_sel_ctype_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zd_sel_ctype_curs.Access
inline acr::FCtype&  _db_zd_sel_ctype_curs_Access(_db_zd_sel_ctype_curs &curs) __attribute__((nothrow));
// func:acr.FDb.bh_pline_curs.Reserve
void                 _db_bh_pline_curs_Reserve(_db_bh_pline_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:acr.FDb.bh_pline_curs.Reset
void                 _db_bh_pline_curs_Reset(_db_bh_pline_curs &curs, acr::FDb &parent);
// Advance cursor.
// func:acr.FDb.bh_pline_curs.Next
void                 _db_bh_pline_curs_Next(_db_bh_pline_curs &curs);
// Access current element. If not more elements, return NULL
// func:acr.FDb.bh_pline_curs.Access
inline acr::FPline&  _db_bh_pline_curs_Access(_db_bh_pline_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:acr.FDb.bh_pline_curs.ValidQ
inline bool          _db_bh_pline_curs_ValidQ(_db_bh_pline_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.substr_curs.Reset
inline void          _db_substr_curs_Reset(_db_substr_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.substr_curs.ValidQ
inline bool          _db_substr_curs_ValidQ(_db_substr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.substr_curs.Next
inline void          _db_substr_curs_Next(_db_substr_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.substr_curs.Access
inline acr::FSubstr& _db_substr_curs_Access(_db_substr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ssimfile_curs.Reset
inline void          _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ssimfile_curs.ValidQ
inline bool          _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.ssimfile_curs.Next
inline void          _db_ssimfile_curs_Next(_db_ssimfile_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.ssimfile_curs.Access
inline acr::FSsimfile& _db_ssimfile_curs_Access(_db_ssimfile_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.tempkey_curs.Reset
inline void          _db_tempkey_curs_Reset(_db_tempkey_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.tempkey_curs.ValidQ
inline bool          _db_tempkey_curs_ValidQ(_db_tempkey_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.tempkey_curs.Next
inline void          _db_tempkey_curs_Next(_db_tempkey_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.tempkey_curs.Access
inline acr::FTempkey& _db_tempkey_curs_Access(_db_tempkey_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zs_query_curs.Reset
inline void          _db_zs_query_curs_Reset(_db_zs_query_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.zs_query_curs.ValidQ
inline bool          _db_zs_query_curs_ValidQ(_db_zs_query_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.zs_query_curs.Next
inline void          _db_zs_query_curs_Next(_db_zs_query_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.zs_query_curs.Access
inline acr::FQuery&  _db_zs_query_curs_Access(_db_zs_query_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ssimsort_curs.Reset
inline void          _db_ssimsort_curs_Reset(_db_ssimsort_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ssimsort_curs.ValidQ
inline bool          _db_ssimsort_curs_ValidQ(_db_ssimsort_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.ssimsort_curs.Next
inline void          _db_ssimsort_curs_Next(_db_ssimsort_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.ssimsort_curs.Access
inline acr::FSsimsort& _db_ssimsort_curs_Access(_db_ssimsort_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.smallstr_curs.Reset
inline void          _db_smallstr_curs_Reset(_db_smallstr_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.smallstr_curs.ValidQ
inline bool          _db_smallstr_curs_ValidQ(_db_smallstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.smallstr_curs.Next
inline void          _db_smallstr_curs_Next(_db_smallstr_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.smallstr_curs.Access
inline acr::FSmallstr& _db_smallstr_curs_Access(_db_smallstr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.funique_curs.Reset
inline void          _db_funique_curs_Reset(_db_funique_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.funique_curs.ValidQ
inline bool          _db_funique_curs_ValidQ(_db_funique_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.funique_curs.Next
inline void          _db_funique_curs_Next(_db_funique_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.funique_curs.Access
inline acr::FFunique& _db_funique_curs_Access(_db_funique_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.bltin_curs.Reset
inline void          _db_bltin_curs_Reset(_db_bltin_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.bltin_curs.ValidQ
inline bool          _db_bltin_curs_ValidQ(_db_bltin_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.bltin_curs.Next
inline void          _db_bltin_curs_Next(_db_bltin_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.bltin_curs.Access
inline acr::FBltin&  _db_bltin_curs_Access(_db_bltin_curs &curs) __attribute__((nothrow));
// func:acr.FDb.bh_ctype_topo_curs.Reserve
void                 _db_bh_ctype_topo_curs_Reserve(_db_bh_ctype_topo_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:acr.FDb.bh_ctype_topo_curs.Reset
void                 _db_bh_ctype_topo_curs_Reset(_db_bh_ctype_topo_curs &curs, acr::FDb &parent);
// Advance cursor.
// func:acr.FDb.bh_ctype_topo_curs.Next
void                 _db_bh_ctype_topo_curs_Next(_db_bh_ctype_topo_curs &curs);
// Access current element. If not more elements, return NULL
// func:acr.FDb.bh_ctype_topo_curs.Access
inline acr::FCtype&  _db_bh_ctype_topo_curs_Access(_db_bh_ctype_topo_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:acr.FDb.bh_ctype_topo_curs.ValidQ
inline bool          _db_bh_ctype_topo_curs_ValidQ(_db_bh_ctype_topo_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.cppfunc_curs.Reset
inline void          _db_cppfunc_curs_Reset(_db_cppfunc_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.cppfunc_curs.ValidQ
inline bool          _db_cppfunc_curs_ValidQ(_db_cppfunc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.cppfunc_curs.Next
inline void          _db_cppfunc_curs_Next(_db_cppfunc_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.cppfunc_curs.Access
inline acr::FCppfunc& _db_cppfunc_curs_Access(_db_cppfunc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ssimreq_curs.Reset
inline void          _db_ssimreq_curs_Reset(_db_ssimreq_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.ssimreq_curs.ValidQ
inline bool          _db_ssimreq_curs_ValidQ(_db_ssimreq_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.ssimreq_curs.Next
inline void          _db_ssimreq_curs_Next(_db_ssimreq_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.ssimreq_curs.Access
inline acr::FSsimreq& _db_ssimreq_curs_Access(_db_ssimreq_curs &curs) __attribute__((nothrow));
// func:acr.FDb.c_ssimreq_rec_curs.Reset
inline void          _db_c_ssimreq_rec_curs_Reset(_db_c_ssimreq_rec_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.c_ssimreq_rec_curs.ValidQ
inline bool          _db_c_ssimreq_rec_curs_ValidQ(_db_c_ssimreq_rec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.c_ssimreq_rec_curs.Next
inline void          _db_c_ssimreq_rec_curs_Next(_db_c_ssimreq_rec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.c_ssimreq_rec_curs.Access
inline acr::FRec&    _db_c_ssimreq_rec_curs_Access(_db_c_ssimreq_rec_curs &curs) __attribute__((nothrow));
// func:acr.FDb.c_ctype_front_curs.Reset
inline void          _db_c_ctype_front_curs_Reset(_db_c_ctype_front_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.c_ctype_front_curs.ValidQ
inline bool          _db_c_ctype_front_curs_ValidQ(_db_c_ctype_front_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.c_ctype_front_curs.Next
inline void          _db_c_ctype_front_curs_Next(_db_c_ctype_front_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.c_ctype_front_curs.Access
inline acr::FCtype&  _db_c_ctype_front_curs_Access(_db_c_ctype_front_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.sortkey_curs.Reset
inline void          _db_sortkey_curs_Reset(_db_sortkey_curs &curs, acr::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FDb.sortkey_curs.ValidQ
inline bool          _db_sortkey_curs_ValidQ(_db_sortkey_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FDb.sortkey_curs.Next
inline void          _db_sortkey_curs_Next(_db_sortkey_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FDb.sortkey_curs.Access
inline acr::FSortkey& _db_sortkey_curs_Access(_db_sortkey_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.FDb..Init
void                 FDb_Init();
// func:acr.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));

// --- acr.FErr
// create: acr.FDb.err (Tpool)
// global access: zd_all_err (Llist)
struct FErr { // acr.FErr
    acr::FErr*      err_next;          // Pointer to next free element int tpool
    acr::FErr*      zd_all_err_next;   // zslist link; -1 means not-in-list
    acr::FErr*      zd_all_err_prev;   // previous element
    acr::FCtype*    ctype;             // Parent ctype. optional pointer
    u32             id;                //   0  ID
    algo::cstring   text;              // Error text
    acr::FRec*      rec;               // Parent record. optional pointer
    acr::FField*    fld;               // Parent field. optional pointer
    // func:acr.FErr..AssignOp
    inline acr::FErr&    operator =(const acr::FErr &rhs) = delete;
    // func:acr.FErr..CopyCtor
    inline               FErr(const acr::FErr &rhs) = delete;
private:
    // func:acr.FErr..Ctor
    inline               FErr() __attribute__((nothrow));
    // func:acr.FErr..Dtor
    inline               ~FErr() __attribute__((nothrow));
    friend acr::FErr&           err_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FErr*           err_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 err_Delete(acr::FErr &row) __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FErr.base.CopyOut
void                 err_CopyOut(acr::FErr &row, acr::Err &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FErr.base.CopyIn
void                 err_CopyIn(acr::FErr &row, acr::Err &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FErr..Init
inline void          FErr_Init(acr::FErr& err);
// func:acr.FErr..Uninit
void                 FErr_Uninit(acr::FErr& err) __attribute__((nothrow));

// --- acr.FEvalattr
struct FEvalattr { // acr.FEvalattr
    bool              pick_dflt;   //   false  (in) If attr not found, choose default?
    bool              normalize;   //   false  (in) Normalize input value if possible
    acr::FField*      field;       // (in) field. optional pointer
    algo::Attr*       attr;        // (out) Tuple attribute. optional pointer
    algo::cstring     value;       // (out) Resulting value
    algo::i32_Range   val_range;   // (out) Range in attribute corresponding to value
    // func:acr.FEvalattr..Ctor
    inline               FEvalattr() __attribute__((nothrow));
    // func:acr.FEvalattr..FieldwiseCtor
    explicit inline               FEvalattr(bool in_pick_dflt, bool in_normalize, acr::FField* in_field, algo::Attr* in_attr, const algo::strptr& in_value, const algo::i32_Range& in_val_range) __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.FEvalattr..Init
inline void          FEvalattr_Init(acr::FEvalattr& parent);

// --- acr.FField
// create: acr.FDb.field (Lary)
// global access: field (Lary, by rowid)
// global access: ind_field (Thash, hash field field)
// access: acr.Err.fld (Ptr)
// access: acr.FCtype.c_field (Ptrary)
// access: acr.FCtype.zd_arg (Llist)
// access: acr.FEvalattr.field (Ptr)
// access: acr.FQuery.c_field (Ptrary)
// access: acr.FSsimreq.p_parent_field (Upptr)
// access: acr.FErr.fld (Ptr)
struct FField { // acr.FField
    acr::FField*        zd_arg_next;            // zslist link; -1 means not-in-list
    acr::FField*        zd_arg_prev;            // previous element
    acr::FField*        ind_field_next;         // hash next
    algo::Smallstr100   field;                  // Primary key, as ctype.name
    algo::Smallstr100   arg;                    // Type of field
    algo::Smallstr50    reftype;                //   "Val"  Type constructor
    algo::CppExpr       dflt;                   // Default value (c++ expression)
    algo::Comment       comment;                //
    acr::FCtype*        p_ctype;                // reference to parent row
    acr::FCtype*        p_arg;                  // reference to parent row
    acr::FSubstr*       c_substr;               // optional pointer
    u32                 max_attr_len;           //   0  Column width in chars
    u32                 col_width;              //   0  Column width in chars
    bool                isfldfunc;              //   false
    bool                anon;                   //   false
    bool                unique;                 //   false
    bool                ctype_c_field_in_ary;   //   false  membership flag
    // x-reference on acr.FField.p_ctype prevents copy
    // x-reference on acr.FField.p_arg prevents copy
    // x-reference on acr.FField.c_substr prevents copy
    // func:acr.FField..AssignOp
    acr::FField&         operator =(const acr::FField &rhs) = delete;
    // x-reference on acr.FField.p_ctype prevents copy
    // x-reference on acr.FField.p_arg prevents copy
    // x-reference on acr.FField.c_substr prevents copy
    // func:acr.FField..CopyCtor
    FField(const acr::FField &rhs) = delete;
private:
    // func:acr.FField..Ctor
    inline               FField() __attribute__((nothrow));
    // func:acr.FField..Dtor
    inline               ~FField() __attribute__((nothrow));
    friend acr::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FField.base.CopyOut
void                 field_CopyOut(acr::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FField.base.CopyIn
void                 field_CopyIn(acr::FField &row, dmmeta::Field &in) __attribute__((nothrow));

// func:acr.FField.ctype.Get
algo::Smallstr100    ctype_Get(acr::FField& field) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FField.ns.Get
algo::Smallstr16     ns_Get(acr::FField& field) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FField.name.Get
algo::Smallstr50     name_Get(acr::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr.FField.c_substr.InsertMaybe
inline bool          c_substr_InsertMaybe(acr::FField& field, acr::FSubstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FField.c_substr.Remove
inline void          c_substr_Remove(acr::FField& field, acr::FSubstr& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FField..Init
void                 FField_Init(acr::FField& field);
// func:acr.FField..Uninit
void                 FField_Uninit(acr::FField& field) __attribute__((nothrow));

// --- acr.FFile
// create: acr.FDb.file (Lary)
// global access: file (Lary, by rowid)
// global access: ind_file (Thash, hash field file)
// access: acr.FRec.p_outfile (Upptr)
// access: acr.FRec.p_infile (Upptr)
// access: acr.FSsimfile.c_file (Ptr)
struct FFile { // acr.FFile
    acr::FFile*     ind_file_next;   // hash next
    algo::cstring   file;            // Primary key
    algo::cstring   filename;        // Non-empty if it's a real file
    bool            ephemeral;       //   false  Do not save back
    bool            sticky;          //   false  Records loaded from file are written back to file
    u32             lineno;          //   1  Current line number
    acr::FRec*      zd_frec_head;    // zero-terminated doubly linked list
    acr::FRec*      zd_frec_tail;    // pointer to last element
    algo::UnTime    modtime;         // File modification time at time of loading
    bool            autoloaded;      //   false  File was pulled in implicitly: loaded records are not 'inserted'
    // reftype Llist of acr.FFile.zd_frec prohibits copy
    // func:acr.FFile..AssignOp
    inline acr::FFile&   operator =(const acr::FFile &rhs) = delete;
    // reftype Llist of acr.FFile.zd_frec prohibits copy
    // func:acr.FFile..CopyCtor
    inline               FFile(const acr::FFile &rhs) = delete;
private:
    // func:acr.FFile..Ctor
    inline               FFile() __attribute__((nothrow));
    // func:acr.FFile..Dtor
    inline               ~FFile() __attribute__((nothrow));
    friend acr::FFile&          file_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FFile*          file_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 file_RemoveAll() __attribute__((nothrow));
    friend void                 file_RemoveLast() __attribute__((nothrow));
};

// Return true if index is empty
// func:acr.FFile.zd_frec.EmptyQ
inline bool          zd_frec_EmptyQ(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FFile.zd_frec.First
inline acr::FRec*    zd_frec_First(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FFile.zd_frec.InLlistQ
inline bool          zd_frec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FFile.zd_frec.Insert
void                 zd_frec_Insert(acr::FFile& file, acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FFile.zd_frec.Last
inline acr::FRec*    zd_frec_Last(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FFile.zd_frec.Next
inline acr::FRec*    zd_frec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FFile.zd_frec.Prev
inline acr::FRec*    zd_frec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FFile.zd_frec.Remove
void                 zd_frec_Remove(acr::FFile& file, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FFile.zd_frec.RemoveAll
void                 zd_frec_RemoveAll(acr::FFile& file) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FFile.zd_frec.RemoveFirst
acr::FRec*           zd_frec_RemoveFirst(acr::FFile& file) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FFile.zd_frec.qLast
inline acr::FRec&    zd_frec_qLast(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr.FFile..Init
inline void          FFile_Init(acr::FFile& file);
// cursor points to valid item
// func:acr.FFile.zd_frec_curs.Reset
inline void          file_zd_frec_curs_Reset(file_zd_frec_curs &curs, acr::FFile &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FFile.zd_frec_curs.ValidQ
inline bool          file_zd_frec_curs_ValidQ(file_zd_frec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FFile.zd_frec_curs.Next
inline void          file_zd_frec_curs_Next(file_zd_frec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FFile.zd_frec_curs.Access
inline acr::FRec&    file_zd_frec_curs_Access(file_zd_frec_curs &curs) __attribute__((nothrow));
// func:acr.FFile..Uninit
void                 FFile_Uninit(acr::FFile& file) __attribute__((nothrow));

// --- acr.FFunique
// create: acr.FDb.funique (Lary)
// global access: funique (Lary, by rowid)
struct FFunique { // acr.FFunique
    algo::Smallstr100   field;   //
private:
    // func:acr.FFunique..Ctor
    inline               FFunique() __attribute__((nothrow));
    friend acr::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 funique_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FFunique.base.CopyOut
void                 funique_CopyOut(acr::FFunique &row, dmmeta::Funique &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FFunique.base.CopyIn
void                 funique_CopyIn(acr::FFunique &row, dmmeta::Funique &in) __attribute__((nothrow));


// --- acr.FPdep
// create: acr.FDb.pdep (Tpool)
// global access: zd_pdep (Llist)
// access: acr.FPline.zd_child (Llist)
struct FPdep { // acr.FPdep: Dependency between two print-line records
    acr::FPdep*    pdep_next;       // Pointer to next free element int tpool
    acr::FPdep*    zd_pdep_next;    // zslist link; -1 means not-in-list
    acr::FPdep*    zd_pdep_prev;    // previous element
    acr::FPline*   p_parent;        // reference to parent row
    acr::FPline*   p_child;         // reference to parent row
    i32            weight;          //   0
    i32            lindex;          //   0  Index of child referencing attr
    acr::FPdep*    zd_child_next;   // zslist link; -1 means not-in-list
    acr::FPdep*    zd_child_prev;   // previous element
    // func:acr.FPdep..AssignOp
    inline acr::FPdep&   operator =(const acr::FPdep &rhs) = delete;
    // func:acr.FPdep..CopyCtor
    inline               FPdep(const acr::FPdep &rhs) = delete;
private:
    // func:acr.FPdep..Ctor
    inline               FPdep() __attribute__((nothrow));
    // func:acr.FPdep..Dtor
    inline               ~FPdep() __attribute__((nothrow));
    friend acr::FPdep&          pdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FPdep*          pdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pdep_Delete(acr::FPdep &row) __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.FPdep..Init
inline void          FPdep_Init(acr::FPdep& pdep);
// func:acr.FPdep..Uninit
void                 FPdep_Uninit(acr::FPdep& pdep) __attribute__((nothrow));

// --- acr.RecSortkey
struct RecSortkey { // acr.RecSortkey: One record
    algo::Smallstr100   ctype;   // Type prefix
    double              num;     //   0.0  Numeric key (if present)
    algo::cstring       str;     // String key (sort key)
    float               rowid;   //   0.f  row id
    // func:acr.RecSortkey..EqOp
    inline bool          operator ==(const acr::RecSortkey &rhs) const __attribute__((nothrow));
    // func:acr.RecSortkey..NeOp
    inline bool          operator !=(const acr::RecSortkey &rhs) const __attribute__((nothrow));
    // func:acr.RecSortkey..LtOp
    inline bool          operator <(const acr::RecSortkey &rhs) const __attribute__((nothrow));
    // func:acr.RecSortkey..GtOp
    inline bool          operator >(const acr::RecSortkey &rhs) const __attribute__((nothrow));
    // func:acr.RecSortkey..LeOp
    inline bool          operator <=(const acr::RecSortkey &rhs) const __attribute__((nothrow));
    // func:acr.RecSortkey..GeOp
    inline bool          operator >=(const acr::RecSortkey &rhs) const __attribute__((nothrow));
    // func:acr.RecSortkey..Ctor
    inline               RecSortkey() __attribute__((nothrow));
};

// func:acr.RecSortkey..Hash
inline u32           RecSortkey_Hash(u32 prev, const acr::RecSortkey& rhs) __attribute__((nothrow));
// func:acr.RecSortkey..Lt
inline bool          RecSortkey_Lt(acr::RecSortkey& lhs, acr::RecSortkey& rhs) __attribute__((nothrow));
// func:acr.RecSortkey..Cmp
i32                  RecSortkey_Cmp(acr::RecSortkey& lhs, acr::RecSortkey& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.RecSortkey..Init
inline void          RecSortkey_Init(acr::RecSortkey& parent);
// func:acr.RecSortkey..Eq
bool                 RecSortkey_Eq(acr::RecSortkey& lhs, acr::RecSortkey& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:acr.RecSortkey..Update
inline bool          RecSortkey_Update(acr::RecSortkey &lhs, acr::RecSortkey& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:acr.RecSortkey.String  printfmt:Tuple
// func:acr.RecSortkey..Print
void                 RecSortkey_Print(acr::RecSortkey& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.PlineKey
struct PlineKey { // acr.PlineKey: Key for sorting print-line records
    i32               alldep;       //   0  # Unresolved references
    i32               negdepth;     //   0  Minus tree depth for depth-first print
    i32               ctype_rank;   //   0  Topological key for ctype
    acr::RecSortkey   sortkey;      // Sort key of original record
    // func:acr.PlineKey..EqOp
    inline bool          operator ==(const acr::PlineKey &rhs) const __attribute__((nothrow));
    // func:acr.PlineKey..NeOp
    inline bool          operator !=(const acr::PlineKey &rhs) const __attribute__((nothrow));
    // func:acr.PlineKey..LtOp
    inline bool          operator <(const acr::PlineKey &rhs) const __attribute__((nothrow));
    // func:acr.PlineKey..GtOp
    inline bool          operator >(const acr::PlineKey &rhs) const __attribute__((nothrow));
    // func:acr.PlineKey..LeOp
    inline bool          operator <=(const acr::PlineKey &rhs) const __attribute__((nothrow));
    // func:acr.PlineKey..GeOp
    inline bool          operator >=(const acr::PlineKey &rhs) const __attribute__((nothrow));
    // func:acr.PlineKey..Ctor
    inline               PlineKey() __attribute__((nothrow));
};

// func:acr.PlineKey..Hash
inline u32           PlineKey_Hash(u32 prev, const acr::PlineKey& rhs) __attribute__((nothrow));
// func:acr.PlineKey..Lt
inline bool          PlineKey_Lt(acr::PlineKey& lhs, acr::PlineKey& rhs) __attribute__((nothrow));
// func:acr.PlineKey..Cmp
i32                  PlineKey_Cmp(acr::PlineKey& lhs, acr::PlineKey& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.PlineKey..Init
inline void          PlineKey_Init(acr::PlineKey& parent);
// func:acr.PlineKey..Eq
bool                 PlineKey_Eq(acr::PlineKey& lhs, acr::PlineKey& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:acr.PlineKey..Update
inline bool          PlineKey_Update(acr::PlineKey &lhs, acr::PlineKey& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:acr.PlineKey.String  printfmt:Tuple
// func:acr.PlineKey..Print
void                 PlineKey_Print(acr::PlineKey& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.FPline
// create: acr.FDb.pline (Tpool)
// global access: zd_pline (Llist)
// global access: bh_pline (Bheap, sort field key)
// access: acr.FPdep.p_parent (Upptr)
// access: acr.FPdep.p_child (Upptr)
// access: acr.FPrint.c_pline (Ptrary)
// access: acr.FRec.c_pline (Ptr)
struct FPline { // acr.FPline: Print-line
    acr::FPline*    pline_next;      // Pointer to next free element int tpool
    acr::FPline*    zd_pline_next;   // zslist link; -1 means not-in-list
    acr::FPline*    zd_pline_prev;   // previous element
    i32             bh_pline_idx;    // index in heap; -1 means not-in-heap
    acr::PlineKey   key;             // Sort key
    acr::FRec*      p_rec;           // reference to parent row
    acr::FPdep*     zd_child_head;   // zero-terminated doubly linked list
    acr::FPdep*     zd_child_tail;   // pointer to last element
    // reftype Llist of acr.FPline.zd_child prohibits copy
    // func:acr.FPline..AssignOp
    inline acr::FPline&  operator =(const acr::FPline &rhs) = delete;
    // reftype Llist of acr.FPline.zd_child prohibits copy
    // func:acr.FPline..CopyCtor
    inline               FPline(const acr::FPline &rhs) = delete;
private:
    // func:acr.FPline..Ctor
    inline               FPline() __attribute__((nothrow));
    // func:acr.FPline..Dtor
    inline               ~FPline() __attribute__((nothrow));
    friend acr::FPline&         pline_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FPline*         pline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pline_Delete(acr::FPline &row) __attribute__((nothrow));
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
// func:acr.FPline.key.Lt
inline bool          key_Lt(acr::FPline& pline, acr::FPline &rhs) __attribute__((nothrow));
// Compare two fields.
// func:acr.FPline.key.Cmp
inline i32           key_Cmp(acr::FPline& pline, acr::FPline &rhs) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FPline.zd_child.EmptyQ
inline bool          zd_child_EmptyQ(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:acr.FPline.zd_child.First
inline acr::FPdep*   zd_child_First(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:acr.FPline.zd_child.InLlistQ
inline bool          zd_child_InLlistQ(acr::FPdep& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:acr.FPline.zd_child.Insert
void                 zd_child_Insert(acr::FPline& pline, acr::FPdep& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:acr.FPline.zd_child.Last
inline acr::FPdep*   zd_child_Last(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:acr.FPline.zd_child.Next
inline acr::FPdep*   zd_child_Next(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:acr.FPline.zd_child.Prev
inline acr::FPdep*   zd_child_Prev(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FPline.zd_child.Remove
void                 zd_child_Remove(acr::FPline& pline, acr::FPdep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FPline.zd_child.RemoveAll
void                 zd_child_RemoveAll(acr::FPline& pline) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:acr.FPline.zd_child.RemoveFirst
acr::FPdep*          zd_child_RemoveFirst(acr::FPline& pline) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:acr.FPline.zd_child.qLast
inline acr::FPdep&   zd_child_qLast(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr.FPline..Init
inline void          FPline_Init(acr::FPline& pline);
// cursor points to valid item
// func:acr.FPline.zd_child_curs.Reset
inline void          pline_zd_child_curs_Reset(pline_zd_child_curs &curs, acr::FPline &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FPline.zd_child_curs.ValidQ
inline bool          pline_zd_child_curs_ValidQ(pline_zd_child_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FPline.zd_child_curs.Next
inline void          pline_zd_child_curs_Next(pline_zd_child_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FPline.zd_child_curs.Access
inline acr::FPdep&   pline_zd_child_curs_Access(pline_zd_child_curs &curs) __attribute__((nothrow));
// func:acr.FPline..Uninit
void                 FPline_Uninit(acr::FPline& pline) __attribute__((nothrow));

// --- acr.FPrint
// create: acr.FDb.print (Cppstack)
// access: acr.FPrintAttr.p_print (Upptr)
struct FPrint { // acr.FPrint: Print function
    acr::FPrintAttr**   ind_printattr_buckets_elems;   // pointer to bucket array
    i32                 ind_printattr_buckets_n;       // number of elements in bucket array
    i32                 ind_printattr_n;               // number of elements in the hash table
    acr::FPline**       c_pline_elems;                 // array of pointers
    u32                 c_pline_n;                     // array of pointers
    u32                 c_pline_max;                   // capacity of allocated array
    bool                pretty;                        //   false  Block alignment
    bool                tree;                          //   false
    bool                fldfunc;                       //   false
    i32                 maxgroup;                      //   25
    bool                cmt;                           //   false
    bool                rowid;                         //   true  Show row ids of records when printing
    algo::cstring       out;                           // Output
    bool                fstdout;                       //   true  Dump to stdout?
    bool                loose;                         //   false  Loose referential integrity
    bool                showstatus;                    //   false  show record status (acr.insert etc)
    i32                 skip_line;                     //   0
    i32                 this_depth;                    //   0
    i32                 prev_depth;                    //   0
    // func:acr.FPrint..Ctor
    inline               FPrint() __attribute__((nothrow));
    // func:acr.FPrint..Dtor
    inline               ~FPrint() __attribute__((nothrow));
};

// Delete all rows reachable through the hash index
// func:acr.FPrint.ind_printattr.Cascdel
void                 ind_printattr_Cascdel(acr::FPrint& print) __attribute__((nothrow));
// Return true if hash is empty
// func:acr.FPrint.ind_printattr.EmptyQ
inline bool          ind_printattr_EmptyQ(acr::FPrint& print) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:acr.FPrint.ind_printattr.Find
acr::FPrintAttr*     ind_printattr_Find(acr::FPrint& print, const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:acr.FPrint.ind_printattr.N
inline i32           ind_printattr_N(const acr::FPrint& print) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:acr.FPrint.ind_printattr.InsertMaybe
bool                 ind_printattr_InsertMaybe(acr::FPrint& print, acr::FPrintAttr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:acr.FPrint.ind_printattr.Remove
void                 ind_printattr_Remove(acr::FPrint& print, acr::FPrintAttr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:acr.FPrint.ind_printattr.Reserve
void                 ind_printattr_Reserve(acr::FPrint& print, int n) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FPrint.c_pline.EmptyQ
inline bool          c_pline_EmptyQ(acr::FPrint& print) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FPrint.c_pline.Find
inline acr::FPline*  c_pline_Find(acr::FPrint& print, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FPrint.c_pline.Getary
inline algo::aryptr<acr::FPline*> c_pline_Getary(acr::FPrint& print) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FPrint.c_pline.Insert
void                 c_pline_Insert(acr::FPrint& print, acr::FPline& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FPrint.c_pline.ScanInsertMaybe
bool                 c_pline_ScanInsertMaybe(acr::FPrint& print, acr::FPline& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FPrint.c_pline.N
inline i32           c_pline_N(const acr::FPrint& print) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FPrint.c_pline.Remove
void                 c_pline_Remove(acr::FPrint& print, acr::FPline& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FPrint.c_pline.RemoveAll
inline void          c_pline_RemoveAll(acr::FPrint& print) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FPrint.c_pline.Reserve
void                 c_pline_Reserve(acr::FPrint& print, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FPrint.c_pline.qFind
inline acr::FPline&  c_pline_qFind(acr::FPrint& print, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FPrint.c_pline.qLast
inline acr::FPline&  c_pline_qLast(acr::FPrint& print) __attribute__((nothrow));

// func:acr.FPrint.c_pline_curs.Reset
inline void          print_c_pline_curs_Reset(print_c_pline_curs &curs, acr::FPrint &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FPrint.c_pline_curs.ValidQ
inline bool          print_c_pline_curs_ValidQ(print_c_pline_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FPrint.c_pline_curs.Next
inline void          print_c_pline_curs_Next(print_c_pline_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FPrint.c_pline_curs.Access
inline acr::FPline&  print_c_pline_curs_Access(print_c_pline_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.FPrint..Init
void                 FPrint_Init(acr::FPrint& print);
// func:acr.FPrint..Uninit
void                 FPrint_Uninit(acr::FPrint& print) __attribute__((nothrow));

// --- acr.FPrintAttr
// create: acr.FDb.printattr (Malloc)
// access: acr.FPrint.ind_printattr (Thash)
struct FPrintAttr { // acr.FPrintAttr
    acr::FPrintAttr*    ind_printattr_next;   // hash next
    acr::FPrint*        p_print;              // reference to parent row
    algo::Smallstr100   field;                //   0
    u32                 width;                //   0  Name width
    // func:acr.FPrintAttr..AssignOp
    inline acr::FPrintAttr& operator =(const acr::FPrintAttr &rhs) = delete;
    // func:acr.FPrintAttr..CopyCtor
    inline               FPrintAttr(const acr::FPrintAttr &rhs) = delete;
private:
    // func:acr.FPrintAttr..Ctor
    inline               FPrintAttr() __attribute__((nothrow));
    // func:acr.FPrintAttr..Dtor
    inline               ~FPrintAttr() __attribute__((nothrow));
    friend acr::FPrintAttr&     printattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FPrintAttr*     printattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 printattr_Delete(acr::FPrintAttr &row) __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.FPrintAttr..Init
inline void          FPrintAttr_Init(acr::FPrintAttr& printattr);
// func:acr.FPrintAttr..Uninit
void                 FPrintAttr_Uninit(acr::FPrintAttr& printattr) __attribute__((nothrow));

// --- acr.Queryop
struct Queryop { // acr.Queryop: Operation to perform
    u8   value;   //   0
    // func:acr.Queryop.value.Cast
    inline               operator acr_Queryop_value_Enum() const __attribute__((nothrow));
    // func:acr.Queryop..Ctor
    inline               Queryop() __attribute__((nothrow));
    // func:acr.Queryop..FieldwiseCtor
    explicit inline               Queryop(u8 in_value) __attribute__((nothrow));
    // func:acr.Queryop..EnumCtor
    inline               Queryop(acr_Queryop_value_Enum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:acr.Queryop.value.GetEnum
inline acr_Queryop_value_Enum value_GetEnum(const acr::Queryop& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:acr.Queryop.value.SetEnum
inline void          value_SetEnum(acr::Queryop& parent, acr_Queryop_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:acr.Queryop.value.ToCstr
const char*          value_ToCstr(const acr::Queryop& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:acr.Queryop.value.Print
void                 value_Print(const acr::Queryop& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:acr.Queryop.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(acr::Queryop& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:acr.Queryop.value.SetStrptr
void                 value_SetStrptr(acr::Queryop& parent, algo::strptr rhs, acr_Queryop_value_Enum dflt) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.Queryop..Init
inline void          Queryop_Init(acr::Queryop& parent);
// print string representation of ROW to string STR
// cfmt:acr.Queryop.String  printfmt:Raw
// func:acr.Queryop..Print
void                 Queryop_Print(acr::Queryop& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.FQuery
// create: acr.FDb.query (Tpool)
// global access: zs_query (Llist)
struct FQuery { // acr.FQuery
    acr::FQuery*     query_next;      // Pointer to next free element int tpool
    acr::FQuery*     zs_query_next;   // zslist link; -1 means not-in-list
    acr::Queryop     queryop;         // Type of operation to perform
    acr::AttrRegx    query;           // Field name (SQL regex as string)
    acr::AttrRegx*   where_elems;     // pointer to elements
    u32              where_n;         // number of elements in array
    u32              where_max;       // max. capacity of array before realloc
    algo::cstring    new_val;         //   ""  New value, used with rename
    algo_lib::Regx   ssimfile;        //   ""  Acr Regx
    algo::cstring    comment;         //   ""  Debug info
    acr::FCtype**    c_ctype_elems;   // array of pointers
    u32              c_ctype_n;       // array of pointers
    u32              c_ctype_max;     // capacity of allocated array
    acr::FField**    c_field_elems;   // array of pointers
    u32              c_field_n;       // array of pointers
    u32              c_field_max;     // capacity of allocated array
    acr::FRec**      c_rec_elems;     // array of pointers
    u32              c_rec_n;         // array of pointers
    u32              c_rec_max;       // capacity of allocated array
    i32              n_regx_match;    //   0  Number of regex matches executed
    i32              n_visit_field;   //   0  Number of fields visited
    i32              n_visit_ctype;   //   0  Number of ctypes visited
    i32              n_mod_rec;       //   0  Number of records modified
    // reftype Ptrary of acr.FQuery.c_ctype prohibits copy
    // reftype Ptrary of acr.FQuery.c_field prohibits copy
    // reftype Ptrary of acr.FQuery.c_rec prohibits copy
    // func:acr.FQuery..AssignOp
    acr::FQuery&         operator =(const acr::FQuery &rhs) = delete;
    // reftype Ptrary of acr.FQuery.c_ctype prohibits copy
    // reftype Ptrary of acr.FQuery.c_field prohibits copy
    // reftype Ptrary of acr.FQuery.c_rec prohibits copy
    // func:acr.FQuery..CopyCtor
    FQuery(const acr::FQuery &rhs) = delete;
private:
    // func:acr.FQuery..Ctor
    inline               FQuery() __attribute__((nothrow));
    // func:acr.FQuery..Dtor
    inline               ~FQuery() __attribute__((nothrow));
    friend acr::FQuery&         query_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FQuery*         query_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 query_Delete(acr::FQuery &row) __attribute__((nothrow));
};

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:acr.FQuery.where.Addary
algo::aryptr<acr::AttrRegx> where_Addary(acr::FQuery& query, algo::aryptr<acr::AttrRegx> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:acr.FQuery.where.Alloc
acr::AttrRegx&       where_Alloc(acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:acr.FQuery.where.AllocAt
acr::AttrRegx&       where_AllocAt(acr::FQuery& query, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:acr.FQuery.where.AllocN
algo::aryptr<acr::AttrRegx> where_AllocN(acr::FQuery& query, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:acr.FQuery.where.EmptyQ
inline bool          where_EmptyQ(acr::FQuery& query) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FQuery.where.Find
inline acr::AttrRegx* where_Find(acr::FQuery& query, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:acr.FQuery.where.Getary
inline algo::aryptr<acr::AttrRegx> where_Getary(const acr::FQuery& query) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:acr.FQuery.where.Last
inline acr::AttrRegx* where_Last(acr::FQuery& query) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:acr.FQuery.where.Max
inline i32           where_Max(acr::FQuery& query) __attribute__((nothrow));
// Return number of items in the array
// func:acr.FQuery.where.N
inline i32           where_N(const acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:acr.FQuery.where.Remove
void                 where_Remove(acr::FQuery& query, u32 i) __attribute__((nothrow));
// func:acr.FQuery.where.RemoveAll
void                 where_RemoveAll(acr::FQuery& query) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:acr.FQuery.where.RemoveLast
void                 where_RemoveLast(acr::FQuery& query) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:acr.FQuery.where.Reserve
inline void          where_Reserve(acr::FQuery& query, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:acr.FQuery.where.AbsReserve
void                 where_AbsReserve(acr::FQuery& query, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:acr.FQuery.where.Setary
void                 where_Setary(acr::FQuery& query, acr::FQuery &rhs) __attribute__((nothrow));
// Copy specified array into where, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:acr.FQuery.where.Setary2
void                 where_Setary(acr::FQuery& query, const algo::aryptr<acr::AttrRegx> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:acr.FQuery.where.qFind
inline acr::AttrRegx& where_qFind(acr::FQuery& query, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:acr.FQuery.where.qLast
inline acr::AttrRegx& where_qLast(acr::FQuery& query) __attribute__((nothrow));
// Return row id of specified element
// func:acr.FQuery.where.rowid_Get
inline u64           where_rowid_Get(acr::FQuery& query, acr::AttrRegx &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:acr.FQuery.where.AllocNVal
algo::aryptr<acr::AttrRegx> where_AllocNVal(acr::FQuery& query, int n_elems, const acr::AttrRegx& val) __attribute__((nothrow));

// Print back to string
// func:acr.FQuery.ssimfile.Print
void                 ssimfile_Print(acr::FQuery& query, algo::cstring &out) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FQuery.c_ctype.EmptyQ
inline bool          c_ctype_EmptyQ(acr::FQuery& query) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FQuery.c_ctype.Find
inline acr::FCtype*  c_ctype_Find(acr::FQuery& query, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FQuery.c_ctype.Getary
inline algo::aryptr<acr::FCtype*> c_ctype_Getary(acr::FQuery& query) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FQuery.c_ctype.Insert
void                 c_ctype_Insert(acr::FQuery& query, acr::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FQuery.c_ctype.ScanInsertMaybe
bool                 c_ctype_ScanInsertMaybe(acr::FQuery& query, acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FQuery.c_ctype.N
inline i32           c_ctype_N(const acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FQuery.c_ctype.Remove
void                 c_ctype_Remove(acr::FQuery& query, acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FQuery.c_ctype.RemoveAll
inline void          c_ctype_RemoveAll(acr::FQuery& query) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FQuery.c_ctype.Reserve
void                 c_ctype_Reserve(acr::FQuery& query, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FQuery.c_ctype.qFind
inline acr::FCtype&  c_ctype_qFind(acr::FQuery& query, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FQuery.c_ctype.qLast
inline acr::FCtype&  c_ctype_qLast(acr::FQuery& query) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FQuery.c_field.EmptyQ
inline bool          c_field_EmptyQ(acr::FQuery& query) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FQuery.c_field.Find
inline acr::FField*  c_field_Find(acr::FQuery& query, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FQuery.c_field.Getary
inline algo::aryptr<acr::FField*> c_field_Getary(acr::FQuery& query) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FQuery.c_field.Insert
void                 c_field_Insert(acr::FQuery& query, acr::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FQuery.c_field.ScanInsertMaybe
bool                 c_field_ScanInsertMaybe(acr::FQuery& query, acr::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FQuery.c_field.N
inline i32           c_field_N(const acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FQuery.c_field.Remove
void                 c_field_Remove(acr::FQuery& query, acr::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FQuery.c_field.RemoveAll
inline void          c_field_RemoveAll(acr::FQuery& query) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FQuery.c_field.Reserve
void                 c_field_Reserve(acr::FQuery& query, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FQuery.c_field.qFind
inline acr::FField&  c_field_qFind(acr::FQuery& query, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FQuery.c_field.qLast
inline acr::FField&  c_field_qLast(acr::FQuery& query) __attribute__((nothrow));

// Return true if index is empty
// func:acr.FQuery.c_rec.EmptyQ
inline bool          c_rec_EmptyQ(acr::FQuery& query) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FQuery.c_rec.Find
inline acr::FRec*    c_rec_Find(acr::FQuery& query, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FQuery.c_rec.Getary
inline algo::aryptr<acr::FRec*> c_rec_Getary(acr::FQuery& query) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FQuery.c_rec.Insert
void                 c_rec_Insert(acr::FQuery& query, acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FQuery.c_rec.ScanInsertMaybe
bool                 c_rec_ScanInsertMaybe(acr::FQuery& query, acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FQuery.c_rec.N
inline i32           c_rec_N(const acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FQuery.c_rec.Remove
void                 c_rec_Remove(acr::FQuery& query, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FQuery.c_rec.RemoveAll
inline void          c_rec_RemoveAll(acr::FQuery& query) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FQuery.c_rec.Reserve
void                 c_rec_Reserve(acr::FQuery& query, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FQuery.c_rec.qFind
inline acr::FRec&    c_rec_qFind(acr::FQuery& query, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FQuery.c_rec.qLast
inline acr::FRec&    c_rec_qLast(acr::FQuery& query) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FQuery..Init
void                 FQuery_Init(acr::FQuery& query);
// proceed to next item
// func:acr.FQuery.where_curs.Next
inline void          query_where_curs_Next(query_where_curs &curs) __attribute__((nothrow));
// func:acr.FQuery.where_curs.Reset
inline void          query_where_curs_Reset(query_where_curs &curs, acr::FQuery &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FQuery.where_curs.ValidQ
inline bool          query_where_curs_ValidQ(query_where_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FQuery.where_curs.Access
inline acr::AttrRegx& query_where_curs_Access(query_where_curs &curs) __attribute__((nothrow));
// func:acr.FQuery.c_ctype_curs.Reset
inline void          query_c_ctype_curs_Reset(query_c_ctype_curs &curs, acr::FQuery &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FQuery.c_ctype_curs.ValidQ
inline bool          query_c_ctype_curs_ValidQ(query_c_ctype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FQuery.c_ctype_curs.Next
inline void          query_c_ctype_curs_Next(query_c_ctype_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FQuery.c_ctype_curs.Access
inline acr::FCtype&  query_c_ctype_curs_Access(query_c_ctype_curs &curs) __attribute__((nothrow));
// func:acr.FQuery.c_field_curs.Reset
inline void          query_c_field_curs_Reset(query_c_field_curs &curs, acr::FQuery &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FQuery.c_field_curs.ValidQ
inline bool          query_c_field_curs_ValidQ(query_c_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FQuery.c_field_curs.Next
inline void          query_c_field_curs_Next(query_c_field_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FQuery.c_field_curs.Access
inline acr::FField&  query_c_field_curs_Access(query_c_field_curs &curs) __attribute__((nothrow));
// func:acr.FQuery.c_rec_curs.Reset
inline void          query_c_rec_curs_Reset(query_c_rec_curs &curs, acr::FQuery &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FQuery.c_rec_curs.ValidQ
inline bool          query_c_rec_curs_ValidQ(query_c_rec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FQuery.c_rec_curs.Next
inline void          query_c_rec_curs_Next(query_c_rec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FQuery.c_rec_curs.Access
inline acr::FRec&    query_c_rec_curs_Access(query_c_rec_curs &curs) __attribute__((nothrow));
// func:acr.FQuery..Uninit
void                 FQuery_Uninit(acr::FQuery& query) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:acr.FQuery.String  printfmt:Tuple
// func:acr.FQuery..Print
void                 FQuery_Print(acr::FQuery& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.FRec
// create: acr.FDb.rec (Tpool)
// global access: zd_all_selrec (Llist)
// global access: c_ssimreq_rec (Ptrary)
// access: acr.Err.rec (Ptr)
// access: acr.FCheck.c_bad_rec (Ptrary)
// access: acr.FCtype.zd_ctype_rec (Llist)
// access: acr.FCtype.ind_ctype_rec (Thash)
// access: acr.FCtype.zd_ctype_selrec (Llist)
// access: acr.FFile.zd_frec (Llist)
// access: acr.FPline.p_rec (Upptr)
// access: acr.FQuery.c_rec (Ptrary)
// access: acr.FWrite.c_cmtrec (Ptrary)
// access: acr.FErr.rec (Ptr)
struct FRec { // acr.FRec
    acr::FRec*        zd_ctype_rec_next;          // zslist link; -1 means not-in-list
    acr::FRec*        zd_ctype_rec_prev;          // previous element
    acr::FRec*        ind_ctype_rec_next;         // hash next
    acr::FRec*        zd_ctype_selrec_next;       // zslist link; -1 means not-in-list
    acr::FRec*        zd_ctype_selrec_prev;       // previous element
    acr::FRec*        rec_next;                   // Pointer to next free element int tpool
    acr::FRec*        zd_all_selrec_next;         // zslist link; -1 means not-in-list
    acr::FRec*        zd_all_selrec_prev;         // previous element
    acr::FRec*        zd_frec_next;               // zslist link; -1 means not-in-list
    acr::FRec*        zd_frec_prev;               // previous element
    algo::cstring     pkey;                       // Record key (arbitrary string)
    algo::cstring*    oldpkey;                    // Private pointer to value
    algo::Tuple       tuple;                      // Data item
    bool              del;                        //   false  Delete?
    bool              mod;                        //   false  Record was modified?
    bool              metasel;                    //   false  Select for meta-data
    bool              isnew;                      //   false  Inserted newly
    i32               seldist;                    //   0  Distance to selection. >0 is up, <0 is down
    acr::RecSortkey   sortkey;                    // Output sort key
    acr::FPline*      c_pline;                    // Optional pline. optional pointer
    acr::FFile*       p_outfile;                  // reference to parent row
    acr::FFile*       p_infile;                   // reference to parent row
    acr::FCtype*      p_ctype;                    // reference to parent row
    i32               lineno;                     //   0
    bool              _db_c_ssimreq_rec_in_ary;   //   false  membership flag
    // reftype Delptr of acr.FRec.oldpkey prohibits copy
    // x-reference on acr.FRec.c_pline prevents copy
    // func:acr.FRec..AssignOp
    acr::FRec&           operator =(const acr::FRec &rhs) = delete;
    // reftype Delptr of acr.FRec.oldpkey prohibits copy
    // x-reference on acr.FRec.c_pline prevents copy
    // func:acr.FRec..CopyCtor
    FRec(const acr::FRec &rhs) = delete;
private:
    // func:acr.FRec..Ctor
    inline               FRec() __attribute__((nothrow));
    // func:acr.FRec..Dtor
    inline               ~FRec() __attribute__((nothrow));
    friend acr::FRec&           rec_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FRec*           rec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 rec_Delete(acr::FRec &row) __attribute__((nothrow));
};

// Get or Create
// Access value, creating it if necessary. Process dies if not successful.
// func:acr.FRec.oldpkey.Access
algo::cstring&       oldpkey_Access(acr::FRec& rec) __attribute__((nothrow));
// Delete value.
// func:acr.FRec.oldpkey.Delete
void                 oldpkey_Delete(acr::FRec& rec) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr.FRec.c_pline.InsertMaybe
inline bool          c_pline_InsertMaybe(acr::FRec& rec, acr::FPline& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FRec.c_pline.Remove
inline void          c_pline_Remove(acr::FRec& rec, acr::FPline& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FRec..Init
void                 FRec_Init(acr::FRec& rec);
// func:acr.FRec..Uninit
void                 FRec_Uninit(acr::FRec& rec) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:acr.FRec.String  printfmt:Tuple
// func:acr.FRec..Print
void                 FRec_Print(acr::FRec& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.FSmallstr
// create: acr.FDb.smallstr (Lary)
// global access: smallstr (Lary, by rowid)
struct FSmallstr { // acr.FSmallstr
    algo::Smallstr100   field;     //
    i32                 length;    //   0  Maximum characters in the string
    algo::Smallstr50    strtype;   // Data format for string
    algo::CppExpr       pad;       // Pad character (if applicable)
    bool                strict;    //   false
private:
    // func:acr.FSmallstr..Ctor
    inline               FSmallstr() __attribute__((nothrow));
    friend acr::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 smallstr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FSmallstr.base.CopyOut
void                 smallstr_CopyOut(acr::FSmallstr &row, dmmeta::Smallstr &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FSmallstr.base.CopyIn
void                 smallstr_CopyIn(acr::FSmallstr &row, dmmeta::Smallstr &in) __attribute__((nothrow));

// func:acr.FSmallstr.ctype.Get
algo::Smallstr100    ctype_Get(acr::FSmallstr& smallstr) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:acr.FSmallstr..Init
inline void          FSmallstr_Init(acr::FSmallstr& smallstr);

// --- acr.FSortkey
// create: acr.FDb.sortkey (Lary)
// global access: sortkey (Lary, by rowid)
// global access: ind_sortkey (Thash, hash field sortkey)
struct FSortkey { // acr.FSortkey: Keep track of next rowid for each sortkey
    acr::FSortkey*    ind_sortkey_next;   // hash next
    acr::RecSortkey   sortkey;            // Sort key
    double            next_rowid;         //   0
    // func:acr.FSortkey..AssignOp
    inline acr::FSortkey& operator =(const acr::FSortkey &rhs) = delete;
    // func:acr.FSortkey..CopyCtor
    inline               FSortkey(const acr::FSortkey &rhs) = delete;
private:
    // func:acr.FSortkey..Ctor
    inline               FSortkey() __attribute__((nothrow));
    // func:acr.FSortkey..Dtor
    inline               ~FSortkey() __attribute__((nothrow));
    friend acr::FSortkey&       sortkey_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSortkey*       sortkey_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 sortkey_RemoveAll() __attribute__((nothrow));
    friend void                 sortkey_RemoveLast() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.FSortkey..Init
inline void          FSortkey_Init(acr::FSortkey& sortkey);
// func:acr.FSortkey..Uninit
void                 FSortkey_Uninit(acr::FSortkey& sortkey) __attribute__((nothrow));

// --- acr.FSsimfile
// create: acr.FDb.ssimfile (Lary)
// global access: ssimfile (Lary, by rowid)
// global access: ind_ssimfile (Thash, hash field ssimfile)
// access: acr.FCtype.c_ssimfile (Ptr)
// access: acr.FSsimreq.p_child_ssimfile (Upptr)
struct FSsimfile { // acr.FSsimfile: One full table
    acr::FSsimfile*     ind_ssimfile_next;   // hash next
    algo::Smallstr50    ssimfile;            //
    algo::Smallstr100   ctype;               //
    acr::FFile*         c_file;              // optional!. optional pointer
    acr::FCtype*        p_ctype;             // reference to parent row
    acr::FSsimsort*     c_ssimsort;          // Optional sort order. optional pointer
    // x-reference on acr.FSsimfile.p_ctype prevents copy
    // x-reference on acr.FSsimfile.c_ssimsort prevents copy
    // func:acr.FSsimfile..AssignOp
    inline acr::FSsimfile& operator =(const acr::FSsimfile &rhs) = delete;
    // x-reference on acr.FSsimfile.p_ctype prevents copy
    // x-reference on acr.FSsimfile.c_ssimsort prevents copy
    // func:acr.FSsimfile..CopyCtor
    inline               FSsimfile(const acr::FSsimfile &rhs) = delete;
private:
    // func:acr.FSsimfile..Ctor
    inline               FSsimfile() __attribute__((nothrow));
    // func:acr.FSsimfile..Dtor
    inline               ~FSsimfile() __attribute__((nothrow));
    friend acr::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FSsimfile.base.CopyOut
void                 ssimfile_CopyOut(acr::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FSsimfile.base.CopyIn
void                 ssimfile_CopyIn(acr::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

// func:acr.FSsimfile.ssimns.Get
algo::Smallstr16     ssimns_Get(acr::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FSsimfile.ns.Get
algo::Smallstr16     ns_Get(acr::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FSsimfile.name.Get
algo::Smallstr50     name_Get(acr::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:acr.FSsimfile.c_ssimsort.InsertMaybe
inline bool          c_ssimsort_InsertMaybe(acr::FSsimfile& ssimfile, acr::FSsimsort& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:acr.FSsimfile.c_ssimsort.Remove
inline void          c_ssimsort_Remove(acr::FSsimfile& ssimfile, acr::FSsimsort& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FSsimfile..Init
inline void          FSsimfile_Init(acr::FSsimfile& ssimfile);
// func:acr.FSsimfile..Uninit
void                 FSsimfile_Uninit(acr::FSsimfile& ssimfile) __attribute__((nothrow));

// --- acr.FSsimreq
// create: acr.FDb.ssimreq (Lary)
// global access: ssimreq (Lary, by rowid)
// access: acr.FCtype.c_ssimreq (Ptrary)
struct FSsimreq { // acr.FSsimreq
    algo::Smallstr100   ssimreq;                  //
    algo::Smallstr100   parent;                   //
    bool                reqchild;                 //   false
    bool                bidir;                    //   false
    algo::Comment       comment;                  //
    acr::FCtype*        p_ctype;                  // reference to parent row
    acr::FSsimfile*     p_child_ssimfile;         // reference to parent row
    acr::FField*        p_parent_field;           // reference to parent row
    algo_lib::Regx      regx_value;               // Sql Regx
    bool                ctype_c_ssimreq_in_ary;   //   false  membership flag
    // x-reference on acr.FSsimreq.p_ctype prevents copy
    // x-reference on acr.FSsimreq.p_child_ssimfile prevents copy
    // x-reference on acr.FSsimreq.p_parent_field prevents copy
    // func:acr.FSsimreq..AssignOp
    acr::FSsimreq&       operator =(const acr::FSsimreq &rhs) = delete;
    // x-reference on acr.FSsimreq.p_ctype prevents copy
    // x-reference on acr.FSsimreq.p_child_ssimfile prevents copy
    // x-reference on acr.FSsimreq.p_parent_field prevents copy
    // func:acr.FSsimreq..CopyCtor
    FSsimreq(const acr::FSsimreq &rhs) = delete;
private:
    // func:acr.FSsimreq..Ctor
    inline               FSsimreq() __attribute__((nothrow));
    // func:acr.FSsimreq..Dtor
    inline               ~FSsimreq() __attribute__((nothrow));
    friend acr::FSsimreq&       ssimreq_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSsimreq*       ssimreq_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimreq_RemoveAll() __attribute__((nothrow));
    friend void                 ssimreq_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FSsimreq.base.CopyOut
void                 ssimreq_CopyOut(acr::FSsimreq &row, dmmeta::Ssimreq &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FSsimreq.base.CopyIn
void                 ssimreq_CopyIn(acr::FSsimreq &row, dmmeta::Ssimreq &in) __attribute__((nothrow));

// func:acr.FSsimreq.parent_field.Get
algo::Smallstr100    parent_field_Get(acr::FSsimreq& ssimreq) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FSsimreq.parent_ctype.Get
algo::Smallstr100    parent_ctype_Get(acr::FSsimreq& ssimreq) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FSsimreq.value.Get
algo::Smallstr100    value_Get(acr::FSsimreq& ssimreq) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FSsimreq.child_ssimfile.Get
algo::Smallstr50     child_ssimfile_Get(acr::FSsimreq& ssimreq) __attribute__((__warn_unused_result__, nothrow));

// func:acr.FSsimreq.child_key.Get
algo::Smallstr100    child_key_Get(acr::FSsimreq& ssimreq) __attribute__((__warn_unused_result__, nothrow));

// Print back to string
// func:acr.FSsimreq.regx_value.Print
void                 regx_value_Print(acr::FSsimreq& ssimreq, algo::cstring &out) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FSsimreq..Init
void                 FSsimreq_Init(acr::FSsimreq& ssimreq);
// func:acr.FSsimreq..Uninit
void                 FSsimreq_Uninit(acr::FSsimreq& ssimreq) __attribute__((nothrow));

// --- acr.FSsimsort
// create: acr.FDb.ssimsort (Lary)
// global access: ssimsort (Lary, by rowid)
// global access: ind_ssimsort (Thash, hash field ssimfile)
// access: acr.FSsimfile.c_ssimsort (Ptr)
struct FSsimsort { // acr.FSsimsort
    acr::FSsimsort*     ind_ssimsort_next;   // hash next
    algo::Smallstr50    ssimfile;            //
    algo::Smallstr100   sortfld;             //
    // func:acr.FSsimsort..AssignOp
    inline acr::FSsimsort& operator =(const acr::FSsimsort &rhs) = delete;
    // func:acr.FSsimsort..CopyCtor
    inline               FSsimsort(const acr::FSsimsort &rhs) = delete;
private:
    // func:acr.FSsimsort..Ctor
    inline               FSsimsort() __attribute__((nothrow));
    // func:acr.FSsimsort..Dtor
    inline               ~FSsimsort() __attribute__((nothrow));
    friend acr::FSsimsort&      ssimsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSsimsort*      ssimsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimsort_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FSsimsort.base.CopyOut
void                 ssimsort_CopyOut(acr::FSsimsort &row, dmmeta::Ssimsort &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FSsimsort.base.CopyIn
void                 ssimsort_CopyIn(acr::FSsimsort &row, dmmeta::Ssimsort &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:acr.FSsimsort..Init
inline void          FSsimsort_Init(acr::FSsimsort& ssimsort);
// func:acr.FSsimsort..Uninit
void                 FSsimsort_Uninit(acr::FSsimsort& ssimsort) __attribute__((nothrow));

// --- acr.FSubstr
// create: acr.FDb.substr (Lary)
// global access: substr (Lary, by rowid)
// access: acr.FField.c_substr (Ptr)
struct FSubstr { // acr.FSubstr
    algo::Smallstr100   field;      //
    algo::CppExpr       expr;       //
    algo::Smallstr100   srcfield;   //
    // func:acr.FSubstr..AssignOp
    inline acr::FSubstr& operator =(const acr::FSubstr &rhs) = delete;
    // func:acr.FSubstr..CopyCtor
    inline               FSubstr(const acr::FSubstr &rhs) = delete;
private:
    // func:acr.FSubstr..Ctor
    inline               FSubstr() __attribute__((nothrow));
    // func:acr.FSubstr..Dtor
    inline               ~FSubstr() __attribute__((nothrow));
    friend acr::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 substr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:acr.FSubstr.base.CopyOut
void                 substr_CopyOut(acr::FSubstr &row, dmmeta::Substr &out) __attribute__((nothrow));
// Copy fields in to row
// func:acr.FSubstr.base.CopyIn
void                 substr_CopyIn(acr::FSubstr &row, dmmeta::Substr &in) __attribute__((nothrow));

// func:acr.FSubstr..Uninit
void                 FSubstr_Uninit(acr::FSubstr& substr) __attribute__((nothrow));

// --- acr.FTempkey
// create: acr.FDb.tempkey (Lary)
// global access: tempkey (Lary, by rowid)
// global access: ind_tempkey (Thash, hash field tempkey)
struct FTempkey { // acr.FTempkey
    acr::FTempkey*   ind_tempkey_next;   // hash next
    algo::cstring    tempkey;            //
    // func:acr.FTempkey..AssignOp
    inline acr::FTempkey& operator =(const acr::FTempkey &rhs) = delete;
    // func:acr.FTempkey..CopyCtor
    inline               FTempkey(const acr::FTempkey &rhs) = delete;
private:
    // func:acr.FTempkey..Ctor
    inline               FTempkey() __attribute__((nothrow));
    // func:acr.FTempkey..Dtor
    inline               ~FTempkey() __attribute__((nothrow));
    friend acr::FTempkey&       tempkey_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FTempkey*       tempkey_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tempkey_RemoveAll() __attribute__((nothrow));
    friend void                 tempkey_RemoveLast() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.FTempkey..Init
inline void          FTempkey_Init(acr::FTempkey& tempkey);
// func:acr.FTempkey..Uninit
void                 FTempkey_Uninit(acr::FTempkey& tempkey) __attribute__((nothrow));

// --- acr.FUniqueattr
// create: acr.FDb.uniqueattr (Tpool)
// global access: ind_uniqueattr (Thash, hash field uniqueattr)
struct FUniqueattr { // acr.FUniqueattr
    acr::FUniqueattr*   uniqueattr_next;       // Pointer to next free element int tpool
    acr::FUniqueattr*   ind_uniqueattr_next;   // hash next
    algo::cstring       uniqueattr;            // Data
    // func:acr.FUniqueattr..AssignOp
    inline acr::FUniqueattr& operator =(const acr::FUniqueattr &rhs) = delete;
    // func:acr.FUniqueattr..CopyCtor
    inline               FUniqueattr(const acr::FUniqueattr &rhs) = delete;
private:
    // func:acr.FUniqueattr..Ctor
    inline               FUniqueattr() __attribute__((nothrow));
    // func:acr.FUniqueattr..Dtor
    inline               ~FUniqueattr() __attribute__((nothrow));
    friend acr::FUniqueattr&    uniqueattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FUniqueattr*    uniqueattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 uniqueattr_Delete(acr::FUniqueattr &row) __attribute__((nothrow));
};

// Set all fields to initial values.
// func:acr.FUniqueattr..Init
inline void          FUniqueattr_Init(acr::FUniqueattr& uniqueattr);
// func:acr.FUniqueattr..Uninit
void                 FUniqueattr_Uninit(acr::FUniqueattr& uniqueattr) __attribute__((nothrow));

// --- acr.FWrite
// create: acr.FDb.write (Cppstack)
struct FWrite { // acr.FWrite: Print function
    acr::FRec**   c_cmtrec_elems;   // array of pointers
    u32           c_cmtrec_n;       // array of pointers
    u32           c_cmtrec_max;     // capacity of allocated array
    // func:acr.FWrite..Ctor
    inline               FWrite() __attribute__((nothrow));
    // func:acr.FWrite..Dtor
    inline               ~FWrite() __attribute__((nothrow));
};

// Return true if index is empty
// func:acr.FWrite.c_cmtrec.EmptyQ
inline bool          c_cmtrec_EmptyQ(acr::FWrite& write) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:acr.FWrite.c_cmtrec.Find
inline acr::FRec*    c_cmtrec_Find(acr::FWrite& write, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:acr.FWrite.c_cmtrec.Getary
inline algo::aryptr<acr::FRec*> c_cmtrec_Getary(acr::FWrite& write) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:acr.FWrite.c_cmtrec.Insert
void                 c_cmtrec_Insert(acr::FWrite& write, acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:acr.FWrite.c_cmtrec.ScanInsertMaybe
bool                 c_cmtrec_ScanInsertMaybe(acr::FWrite& write, acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:acr.FWrite.c_cmtrec.N
inline i32           c_cmtrec_N(const acr::FWrite& write) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:acr.FWrite.c_cmtrec.Remove
void                 c_cmtrec_Remove(acr::FWrite& write, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:acr.FWrite.c_cmtrec.RemoveAll
inline void          c_cmtrec_RemoveAll(acr::FWrite& write) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:acr.FWrite.c_cmtrec.Reserve
void                 c_cmtrec_Reserve(acr::FWrite& write, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:acr.FWrite.c_cmtrec.qFind
inline acr::FRec&    c_cmtrec_qFind(acr::FWrite& write, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:acr.FWrite.c_cmtrec.qLast
inline acr::FRec&    c_cmtrec_qLast(acr::FWrite& write) __attribute__((nothrow));
// Verify whether array is sorted
// func:acr.FWrite.c_cmtrec.SortedQ
bool                 c_cmtrec_SortedQ(acr::FWrite& write) __attribute__((nothrow));
// Insertion sort
// func:acr.FWrite.c_cmtrec.InsertionSort
void                 c_cmtrec_InsertionSort(acr::FWrite& write) __attribute__((nothrow));
// Heap sort
// func:acr.FWrite.c_cmtrec.HeapSort
void                 c_cmtrec_HeapSort(acr::FWrite& write) __attribute__((nothrow));
// Quick sort
// func:acr.FWrite.c_cmtrec.QuickSort
void                 c_cmtrec_QuickSort(acr::FWrite& write) __attribute__((nothrow));

// func:acr.FWrite.c_cmtrec_curs.Reset
inline void          write_c_cmtrec_curs_Reset(write_c_cmtrec_curs &curs, acr::FWrite &parent) __attribute__((nothrow));
// cursor points to valid item
// func:acr.FWrite.c_cmtrec_curs.ValidQ
inline bool          write_c_cmtrec_curs_ValidQ(write_c_cmtrec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:acr.FWrite.c_cmtrec_curs.Next
inline void          write_c_cmtrec_curs_Next(write_c_cmtrec_curs &curs) __attribute__((nothrow));
// item access
// func:acr.FWrite.c_cmtrec_curs.Access
inline acr::FRec&    write_c_cmtrec_curs_Access(write_c_cmtrec_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.FWrite..Init
inline void          FWrite_Init(acr::FWrite& write);
// func:acr.FWrite..Uninit
void                 FWrite_Uninit(acr::FWrite& write) __attribute__((nothrow));

// --- acr.FieldId
#pragma pack(push,1)
struct FieldId { // acr.FieldId: Field read helper
    i32   value;   //   -1
    // func:acr.FieldId.value.Cast
    inline               operator acr_FieldIdEnum() const __attribute__((nothrow));
    // func:acr.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:acr.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:acr.FieldId..EnumCtor
    inline               FieldId(acr_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:acr.FieldId.value.GetEnum
inline acr_FieldIdEnum value_GetEnum(const acr::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:acr.FieldId.value.SetEnum
inline void          value_SetEnum(acr::FieldId& parent, acr_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:acr.FieldId.value.ToCstr
const char*          value_ToCstr(const acr::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:acr.FieldId.value.Print
void                 value_Print(const acr::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:acr.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(acr::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:acr.FieldId.value.SetStrptr
void                 value_SetStrptr(acr::FieldId& parent, algo::strptr rhs, acr_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:acr.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(acr::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr::FieldId from an ascii string.
// The format of the string is the format of the acr::FieldId's only field
// func:acr.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(acr::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.FieldId..Init
inline void          FieldId_Init(acr::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:acr.FieldId.String  printfmt:Raw
// func:acr.FieldId..Print
void                 FieldId_Print(acr::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.ReadMode
struct ReadMode { // acr.ReadMode
    u8   read_mode;   //   0
    // func:acr.ReadMode.read_mode.Cast
    inline               operator acr_ReadModeEnum() const __attribute__((nothrow));
    // func:acr.ReadMode..Ctor
    inline               ReadMode() __attribute__((nothrow));
    // func:acr.ReadMode..FieldwiseCtor
    explicit inline               ReadMode(u8 in_read_mode) __attribute__((nothrow));
    // func:acr.ReadMode..EnumCtor
    inline               ReadMode(acr_ReadModeEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:acr.ReadMode.read_mode.GetEnum
inline acr_ReadModeEnum read_mode_GetEnum(const acr::ReadMode& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:acr.ReadMode.read_mode.SetEnum
inline void          read_mode_SetEnum(acr::ReadMode& parent, acr_ReadModeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:acr.ReadMode.read_mode.ToCstr
const char*          read_mode_ToCstr(const acr::ReadMode& parent) __attribute__((nothrow));
// Convert read_mode to a string. First, attempt conversion to a known string.
// If no string matches, print read_mode as a numeric value.
// func:acr.ReadMode.read_mode.Print
void                 read_mode_Print(const acr::ReadMode& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:acr.ReadMode.read_mode.SetStrptrMaybe
bool                 read_mode_SetStrptrMaybe(acr::ReadMode& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:acr.ReadMode.read_mode.SetStrptr
void                 read_mode_SetStrptr(acr::ReadMode& parent, algo::strptr rhs, acr_ReadModeEnum dflt) __attribute__((nothrow));

// func:acr.ReadMode..Cmp
inline i32           ReadMode_Cmp(acr::ReadMode& lhs, acr::ReadMode& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.ReadMode..Init
inline void          ReadMode_Init(acr::ReadMode& parent);
// func:acr.ReadMode..Eq
inline bool          ReadMode_Eq(acr::ReadMode& lhs, acr::ReadMode& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:acr.ReadMode.String  printfmt:Raw
// func:acr.ReadMode..Print
void                 ReadMode_Print(acr::ReadMode& row, algo::cstring& str) __attribute__((nothrow));

// --- acr.TableId
struct TableId { // acr.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    // func:acr.TableId.value.Cast
    inline               operator acr_TableIdEnum() const __attribute__((nothrow));
    // func:acr.TableId..Ctor
    inline               TableId() __attribute__((nothrow));
    // func:acr.TableId..FieldwiseCtor
    explicit inline               TableId(i32 in_value) __attribute__((nothrow));
    // func:acr.TableId..EnumCtor
    inline               TableId(acr_TableIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:acr.TableId.value.GetEnum
inline acr_TableIdEnum value_GetEnum(const acr::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:acr.TableId.value.SetEnum
inline void          value_SetEnum(acr::TableId& parent, acr_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:acr.TableId.value.ToCstr
const char*          value_ToCstr(const acr::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:acr.TableId.value.Print
void                 value_Print(const acr::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:acr.TableId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(acr::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:acr.TableId.value.SetStrptr
void                 value_SetStrptr(acr::TableId& parent, algo::strptr rhs, acr_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:acr.TableId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(acr::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr::TableId from an ascii string.
// The format of the string is the format of the acr::TableId's only field
// func:acr.TableId..ReadStrptrMaybe
bool                 TableId_ReadStrptrMaybe(acr::TableId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:acr.TableId..Init
inline void          TableId_Init(acr::TableId& parent);
// print string representation of ROW to string STR
// cfmt:acr.TableId.String  printfmt:Raw
// func:acr.TableId..Print
void                 TableId_Print(acr::TableId& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace acr { // gen:ns_curstext

struct check_c_bad_rec_curs {// fcurs:acr.FCheck.c_bad_rec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    check_c_bad_rec_curs() { elems=NULL; n_elems=0; index=0; }
};


struct check_ary_name_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    check_ary_name_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_field_curs {// fcurs:acr.FCtype.c_field/curs
    typedef acr::FField ChildType;
    acr::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_ctype_rec_curs {// fcurs:acr.FCtype.zd_ctype_rec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    ctype_zd_ctype_rec_curs() {
        row = NULL;
    }
};


struct ctype_ind_ctype_rec_curs {// cursor
    typedef acr::FRec ChildType;
    acr::FCtype *parent;
    int bucket;
    acr::FRec **prow;
    ctype_ind_ctype_rec_curs() { parent=NULL; bucket=0; prow=NULL; }
};


struct ctype_zd_ctype_selrec_curs {// fcurs:acr.FCtype.zd_ctype_selrec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    ctype_zd_ctype_selrec_curs() {
        row = NULL;
    }
};


struct ctype_c_child_curs {// fcurs:acr.FCtype.c_child/curs
    typedef acr::FCtype ChildType;
    acr::FCtype** elems;
    u32 n_elems;
    u32 index;
    ctype_c_child_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_arg_curs {// fcurs:acr.FCtype.zd_arg/curs
    typedef acr::FField ChildType;
    acr::FField* row;
    ctype_zd_arg_curs() {
        row = NULL;
    }
};


struct ctype_c_ssimreq_curs {// fcurs:acr.FCtype.c_ssimreq/curs
    typedef acr::FSsimreq ChildType;
    acr::FSsimreq** elems;
    u32 n_elems;
    u32 index;
    ctype_c_ssimreq_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_zd_pline_curs {// fcurs:acr.FDb.zd_pline/curs
    typedef acr::FPline ChildType;
    acr::FPline* row;
    _db_zd_pline_curs() {
        row = NULL;
    }
};


struct _db_zd_pdep_curs {// fcurs:acr.FDb.zd_pdep/curs
    typedef acr::FPdep ChildType;
    acr::FPdep* row;
    _db_zd_pdep_curs() {
        row = NULL;
    }
};


struct _db_ctype_curs {// cursor
    typedef acr::FCtype ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_anonfld_curs {// cursor
    typedef acr::FAnonfld ChildType;
    acr::FDb *parent;
    i64 index;
    _db_anonfld_curs(){ parent=NULL; index=0; }
};


struct _db_cdflt_curs {// cursor
    typedef acr::FCdflt ChildType;
    acr::FDb *parent;
    i64 index;
    _db_cdflt_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef acr::FField ChildType;
    acr::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_file_curs {// cursor
    typedef acr::FFile ChildType;
    acr::FDb *parent;
    i64 index;
    _db_file_curs(){ parent=NULL; index=0; }
};


struct _db_zd_all_selrec_curs {// fcurs:acr.FDb.zd_all_selrec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    _db_zd_all_selrec_curs() {
        row = NULL;
    }
};


struct _db_zd_all_selrec_delcurs {// fcurs:acr.FDb.zd_all_selrec/delcurs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    acr::FRec *next;
    _db_zd_all_selrec_delcurs() {
        row = NULL;
        next = NULL;
    }
};


struct _db_zd_all_err_curs {// fcurs:acr.FDb.zd_all_err/curs
    typedef acr::FErr ChildType;
    acr::FErr* row;
    _db_zd_all_err_curs() {
        row = NULL;
    }
};


struct _db_zd_sel_ctype_curs {// fcurs:acr.FDb.zd_sel_ctype/curs
    typedef acr::FCtype ChildType;
    acr::FCtype* row;
    _db_zd_sel_ctype_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_pline_curs {
    typedef acr::FPline ChildType;
    acr::FDb      *parent;        // parent
    acr::FPline*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_pline_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_pline_curs();
};


struct _db_substr_curs {// cursor
    typedef acr::FSubstr ChildType;
    acr::FDb *parent;
    i64 index;
    _db_substr_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef acr::FSsimfile ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_tempkey_curs {// cursor
    typedef acr::FTempkey ChildType;
    acr::FDb *parent;
    i64 index;
    _db_tempkey_curs(){ parent=NULL; index=0; }
};


struct _db_zs_query_curs {// fcurs:acr.FDb.zs_query/curs
    typedef acr::FQuery ChildType;
    acr::FQuery* row;
    _db_zs_query_curs() {
        row = NULL;
    }
};


struct _db_ssimsort_curs {// cursor
    typedef acr::FSsimsort ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ssimsort_curs(){ parent=NULL; index=0; }
};


struct _db_smallstr_curs {// cursor
    typedef acr::FSmallstr ChildType;
    acr::FDb *parent;
    i64 index;
    _db_smallstr_curs(){ parent=NULL; index=0; }
};


struct _db_funique_curs {// cursor
    typedef acr::FFunique ChildType;
    acr::FDb *parent;
    i64 index;
    _db_funique_curs(){ parent=NULL; index=0; }
};


struct _db_bltin_curs {// cursor
    typedef acr::FBltin ChildType;
    acr::FDb *parent;
    i64 index;
    _db_bltin_curs(){ parent=NULL; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_ctype_topo_curs {
    typedef acr::FCtype ChildType;
    acr::FDb      *parent;        // parent
    acr::FCtype*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_ctype_topo_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_ctype_topo_curs();
};


struct _db_cppfunc_curs {// cursor
    typedef acr::FCppfunc ChildType;
    acr::FDb *parent;
    i64 index;
    _db_cppfunc_curs(){ parent=NULL; index=0; }
};


struct _db_ssimreq_curs {// cursor
    typedef acr::FSsimreq ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ssimreq_curs(){ parent=NULL; index=0; }
};


struct _db_c_ssimreq_rec_curs {// fcurs:acr.FDb.c_ssimreq_rec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    _db_c_ssimreq_rec_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_c_ctype_front_curs {// fcurs:acr.FDb.c_ctype_front/curs
    typedef acr::FCtype ChildType;
    acr::FCtype** elems;
    u32 n_elems;
    u32 index;
    _db_c_ctype_front_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_sortkey_curs {// cursor
    typedef acr::FSortkey ChildType;
    acr::FDb *parent;
    i64 index;
    _db_sortkey_curs(){ parent=NULL; index=0; }
};


struct file_zd_frec_curs {// fcurs:acr.FFile.zd_frec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    file_zd_frec_curs() {
        row = NULL;
    }
};


struct pline_zd_child_curs {// fcurs:acr.FPline.zd_child/curs
    typedef acr::FPdep ChildType;
    acr::FPdep* row;
    pline_zd_child_curs() {
        row = NULL;
    }
};


struct print_c_pline_curs {// fcurs:acr.FPrint.c_pline/curs
    typedef acr::FPline ChildType;
    acr::FPline** elems;
    u32 n_elems;
    u32 index;
    print_c_pline_curs() { elems=NULL; n_elems=0; index=0; }
};


struct query_where_curs {// cursor
    typedef acr::AttrRegx ChildType;
    acr::AttrRegx* elems;
    int n_elems;
    int index;
    query_where_curs() { elems=NULL; n_elems=0; index=0; }
};


struct query_c_ctype_curs {// fcurs:acr.FQuery.c_ctype/curs
    typedef acr::FCtype ChildType;
    acr::FCtype** elems;
    u32 n_elems;
    u32 index;
    query_c_ctype_curs() { elems=NULL; n_elems=0; index=0; }
};


struct query_c_field_curs {// fcurs:acr.FQuery.c_field/curs
    typedef acr::FField ChildType;
    acr::FField** elems;
    u32 n_elems;
    u32 index;
    query_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct query_c_rec_curs {// fcurs:acr.FQuery.c_rec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    query_c_rec_curs() { elems=NULL; n_elems=0; index=0; }
};


struct write_c_cmtrec_curs {// fcurs:acr.FWrite.c_cmtrec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    write_c_cmtrec_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace acr { // gen:ns_func
// func:acr...StaticCheck
void                 StaticCheck();
} // gen:ns_func
// func:acr...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:acr...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const acr::CtypeTopoKey &row);// cfmt:acr.CtypeTopoKey.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::trace &row);// cfmt:acr.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::RecSortkey &row);// cfmt:acr.RecSortkey.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::PlineKey &row);// cfmt:acr.PlineKey.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::Queryop &row);// cfmt:acr.Queryop.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::FQuery &row);// cfmt:acr.FQuery.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::FRec &row);// cfmt:acr.FRec.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::FieldId &row);// cfmt:acr.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::ReadMode &row);// cfmt:acr.ReadMode.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::TableId &row);// cfmt:acr.TableId.String
}
