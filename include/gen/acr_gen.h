//
// include/gen/acr_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/amcdb_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/report_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- acr_Queryop_value_Enum

enum acr_Queryop_value_Enum {                     // acr.Queryop.value
     acr_Queryop_value_none                  = 0
    ,acr_Queryop_value_select                = 1
    ,acr_Queryop_value_set_attr              = 2
    ,acr_Queryop_value_rename_attr           = 3
    ,acr_Queryop_value_del_attr              = 4
    ,acr_Queryop_value_finish_rename_field   = 5
};

enum { acr_Queryop_value_Enum_N = 6 };


// --- acr_FieldIdEnum

enum acr_FieldIdEnum {        // acr.FieldId.value
     acr_FieldId_value   = 0
};

enum { acr_FieldIdEnum_N = 1 };


// --- acr_TableIdEnum

enum acr_TableIdEnum {                    // acr.TableId.value
     acr_TableId_dmmeta_Anonfld    = 0    // dmmeta.Anonfld -> acr.FAnonfld
    ,acr_TableId_dmmeta_anonfld    = 0    // dmmeta.anonfld -> acr.FAnonfld
    ,acr_TableId_amcdb_Bltin       = 1    // amcdb.Bltin -> acr.FBltin
    ,acr_TableId_amcdb_bltin       = 1    // amcdb.bltin -> acr.FBltin
    ,acr_TableId_dmmeta_Cdflt      = 2    // dmmeta.Cdflt -> acr.FCdflt
    ,acr_TableId_dmmeta_cdflt      = 2    // dmmeta.cdflt -> acr.FCdflt
    ,acr_TableId_dmmeta_Cppfunc    = 3    // dmmeta.Cppfunc -> acr.FCppfunc
    ,acr_TableId_dmmeta_cppfunc    = 3    // dmmeta.cppfunc -> acr.FCppfunc
    ,acr_TableId_dmmeta_Ctype      = 4    // dmmeta.Ctype -> acr.FCtype
    ,acr_TableId_dmmeta_ctype      = 4    // dmmeta.ctype -> acr.FCtype
    ,acr_TableId_dmmeta_Field      = 5    // dmmeta.Field -> acr.FField
    ,acr_TableId_dmmeta_field      = 5    // dmmeta.field -> acr.FField
    ,acr_TableId_dmmeta_Funique    = 6    // dmmeta.Funique -> acr.FFunique
    ,acr_TableId_dmmeta_funique    = 6    // dmmeta.funique -> acr.FFunique
    ,acr_TableId_dmmeta_Smallstr   = 7    // dmmeta.Smallstr -> acr.FSmallstr
    ,acr_TableId_dmmeta_smallstr   = 7    // dmmeta.smallstr -> acr.FSmallstr
    ,acr_TableId_dmmeta_Ssimfile   = 8    // dmmeta.Ssimfile -> acr.FSsimfile
    ,acr_TableId_dmmeta_ssimfile   = 8    // dmmeta.ssimfile -> acr.FSsimfile
    ,acr_TableId_dmmeta_Ssimreq    = 9    // dmmeta.Ssimreq -> acr.FSsimreq
    ,acr_TableId_dmmeta_ssimreq    = 9    // dmmeta.ssimreq -> acr.FSsimreq
    ,acr_TableId_dmmeta_Ssimsort   = 10   // dmmeta.Ssimsort -> acr.FSsimsort
    ,acr_TableId_dmmeta_ssimsort   = 10   // dmmeta.ssimsort -> acr.FSsimsort
    ,acr_TableId_dmmeta_Substr     = 11   // dmmeta.Substr -> acr.FSubstr
    ,acr_TableId_dmmeta_substr     = 11   // dmmeta.substr -> acr.FSubstr
};

enum { acr_TableIdEnum_N = 24 };

namespace acr { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace acr { // gen:ns_field
extern const char *acr_help;
} // gen:ns_field
// gen:ns_fwddecl2
namespace dmmeta { struct Anonfld; }
namespace amcdb { struct Bltin; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Ctype; }
namespace acr { struct Err; }
namespace dmmeta { struct Field; }
namespace acr { struct FCtype; }
namespace dmmeta { struct Funique; }
namespace acr { struct FPline; }
namespace acr { struct FRec; }
namespace acr { struct FPrint; }
namespace acr { struct FFile; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimreq; }
namespace acr { struct FSsimfile; }
namespace acr { struct FField; }
namespace dmmeta { struct Ssimsort; }
namespace dmmeta { struct Substr; }
namespace acr { struct check_c_bad_rec_curs; }
namespace acr { struct check_ary_name_curs; }
namespace acr { struct ctype_c_field_curs; }
namespace acr { struct ctype_zd_trec_curs; }
namespace acr { struct ctype_ind_rec_curs; }
namespace acr { struct ctype_zd_selrec_curs; }
namespace acr { struct ctype_c_child_curs; }
namespace acr { struct ctype_zd_arg_curs; }
namespace acr { struct _db_zd_pline_curs; }
namespace acr { struct _db_zd_pdep_curs; }
namespace acr { struct _db_ctype_curs; }
namespace acr { struct _db_anonfld_curs; }
namespace acr { struct _db_cdflt_curs; }
namespace acr { struct _db_field_curs; }
namespace acr { struct _db_file_curs; }
namespace acr { struct _db_zd_all_selrec_curs; }
namespace acr { struct _db_zd_all_err_curs; }
namespace acr { struct _db_zd_sel_ctype_curs; }
namespace acr { struct _db_bh_pline_curs; }
namespace acr { struct _db_substr_curs; }
namespace acr { struct _db_ssimfile_curs; }
namespace acr { struct _db_tempkey_curs; }
namespace acr { struct _db_zs_query_curs; }
namespace acr { struct _db_ssimsort_curs; }
namespace acr { struct _db_smallstr_curs; }
namespace acr { struct _db_funique_curs; }
namespace acr { struct _db_bltin_curs; }
namespace acr { struct _db_bh_ctype_topo_curs; }
namespace acr { struct _db_cppfunc_curs; }
namespace acr { struct _db_ssimreq_curs; }
namespace acr { struct file_zd_frec_curs; }
namespace acr { struct pline_zd_child_curs; }
namespace acr { struct print_c_pline_curs; }
namespace acr { struct query_where_curs; }
namespace acr { struct run_c_ctype_curs; }
namespace acr { struct run_c_field_curs; }
namespace acr { struct run_c_rec_curs; }
namespace acr { struct run_c_child_curs; }
namespace acr { struct write_c_cmtrec_curs; }
namespace acr { struct AttrRegx; }
namespace acr { struct CtypeTopoKey; }
namespace acr { struct FAnonfld; }
namespace acr { struct FBltin; }
namespace acr { struct FCdflt; }
namespace acr { struct FCheck; }
namespace acr { struct FCppfunc; }
namespace acr { struct trace; }
namespace acr { struct FDb; }
namespace acr { struct FErr; }
namespace acr { struct FEvalattr; }
namespace acr { struct FFunique; }
namespace acr { struct FPdep; }
namespace acr { struct PlineKey; }
namespace acr { struct FPrintAttr; }
namespace acr { struct Queryop; }
namespace acr { struct FQuery; }
namespace acr { struct RecSortkey; }
namespace acr { struct FRun; }
namespace acr { struct FSmallstr; }
namespace acr { struct FSsimreq; }
namespace acr { struct FSsimsort; }
namespace acr { struct FSubstr; }
namespace acr { struct FTempkey; }
namespace acr { struct FUniqueattr; }
namespace acr { struct FWrite; }
namespace acr { struct FieldId; }
namespace acr { struct TableId; }
namespace acr { extern struct acr::FDb _db; }
namespace acr { // gen:ns_print_struct

// --- acr.AttrRegx
// create: acr.FQuery.where (Tary)
struct AttrRegx { // acr.AttrRegx: Filters that must match input key/value pairs
    algo_lib::Regx   name;    // Acr Regx
    algo_lib::Regx   value;   // Acr Regx
    AttrRegx();
private:
    // reftype Regx of acr.AttrRegx.name prohibits copy
    // reftype Regx of acr.AttrRegx.value prohibits copy
    AttrRegx(const AttrRegx&){ /*disallow copy constructor */}
    void operator =(const AttrRegx&){ /*disallow direct assignment */}
};

// Print back to string
void                 name_Print(acr::AttrRegx& where, algo::cstring &out) __attribute__((nothrow));

// Print back to string
void                 value_Print(acr::AttrRegx& where, algo::cstring &out) __attribute__((nothrow));

// print string representation of acr::AttrRegx to string LHS, no header -- cprint:acr.AttrRegx.String
void                 AttrRegx_Print(acr::AttrRegx & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.CtypeTopoKey
struct CtypeTopoKey { // acr.CtypeTopoKey: Key for sorting print-line records
    i32   alldep;   //   0  # Unresolved references
    i32   rowid;    //   0  Rowid of original record
    bool operator ==(const acr::CtypeTopoKey &rhs) const;
    bool operator !=(const acr::CtypeTopoKey &rhs) const;
    bool operator <(const acr::CtypeTopoKey &rhs) const;
    bool operator >(const acr::CtypeTopoKey &rhs) const;
    bool operator <=(const acr::CtypeTopoKey &rhs) const;
    bool operator >=(const acr::CtypeTopoKey &rhs) const;
    CtypeTopoKey();
};

u32                  CtypeTopoKey_Hash(u32 prev, const acr::CtypeTopoKey & rhs) __attribute__((nothrow));
bool                 CtypeTopoKey_Lt(acr::CtypeTopoKey & lhs, acr::CtypeTopoKey & rhs) __attribute__((nothrow));
i32                  CtypeTopoKey_Cmp(acr::CtypeTopoKey & lhs, acr::CtypeTopoKey & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 CtypeTopoKey_Init(acr::CtypeTopoKey& parent);
bool                 CtypeTopoKey_Eq(const acr::CtypeTopoKey & lhs,const acr::CtypeTopoKey & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 CtypeTopoKey_Update(acr::CtypeTopoKey &lhs, acr::CtypeTopoKey & rhs) __attribute__((nothrow));
// print string representation of acr::CtypeTopoKey to string LHS, no header -- cprint:acr.CtypeTopoKey.String
void                 CtypeTopoKey_Print(acr::CtypeTopoKey & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.Err
// access: acr.FErr.base (Base)
struct Err { // acr.Err
    acr::FCtype*    ctype;   // Parent ctype. optional pointer
    u32             id;      //   0  ID
    algo::cstring   text;    // Error text
    acr::FRec*      rec;     // Parent record. optional pointer
    acr::FField*    fld;     // Parent field. optional pointer
    Err();
};

// Set all fields to initial values.
void                 Err_Init(acr::Err& parent);
// print string representation of acr::Err to string LHS, no header -- cprint:acr.Err.String
void                 Err_Print(acr::Err & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.FAnonfld
// create: acr.FDb.anonfld (Lary)
struct FAnonfld { // acr.FAnonfld
    algo::Smallstr100   field;   //
private:
    friend acr::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 anonfld_RemoveLast() __attribute__((nothrow));
    FAnonfld();
};

// Copy fields out of row
void                 anonfld_CopyOut(acr::FAnonfld &row, dmmeta::Anonfld &out) __attribute__((nothrow));
// Copy fields in to row
void                 anonfld_CopyIn(acr::FAnonfld &row, dmmeta::Anonfld &in) __attribute__((nothrow));


// --- acr.FBltin
// create: acr.FDb.bltin (Lary)
// access: acr.FCtype.c_bltin (Ptr)
struct FBltin { // acr.FBltin
    algo::Smallstr50   ctype;      //
    bool               likeu64;    //   false
    bool               bigendok;   //   false
    bool               issigned;   //   false
private:
    friend acr::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 bltin_RemoveLast() __attribute__((nothrow));
    FBltin();
    ~FBltin();
    FBltin(const FBltin&){ /*disallow copy constructor */}
    void operator =(const FBltin&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 bltin_CopyOut(acr::FBltin &row, amcdb::Bltin &out) __attribute__((nothrow));
// Copy fields in to row
void                 bltin_CopyIn(acr::FBltin &row, amcdb::Bltin &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FBltin_Init(acr::FBltin& bltin);
void                 FBltin_Uninit(acr::FBltin& bltin) __attribute__((nothrow));

// --- acr.FCdflt
// create: acr.FDb.cdflt (Lary)
// access: acr.FCtype.c_cdflt (Ptr)
struct FCdflt { // acr.FCdflt
    algo::Smallstr50   ctype;      //
    dmmeta::CppExpr    dflt;       //
    dmmeta::CppExpr    cppdflt;    //
    algo::Smallstr50   ssimdflt;   //
    algo::Smallstr50   jsdflt;     //
private:
    friend acr::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cdflt_RemoveLast() __attribute__((nothrow));
    FCdflt();
    ~FCdflt();
    FCdflt(const FCdflt&){ /*disallow copy constructor */}
    void operator =(const FCdflt&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cdflt_CopyOut(acr::FCdflt &row, dmmeta::Cdflt &out) __attribute__((nothrow));
// Copy fields in to row
void                 cdflt_CopyIn(acr::FCdflt &row, dmmeta::Cdflt &in) __attribute__((nothrow));

void                 FCdflt_Uninit(acr::FCdflt& cdflt) __attribute__((nothrow));

// --- acr.FCheck
// create: acr.FDb.check (Cppstack)
struct FCheck { // acr.FCheck: Function to check for consistency
    acr::FRec**      c_bad_rec_elems;   // array of pointers
    u32              c_bad_rec_n;       // array of pointers
    u32              c_bad_rec_max;     // capacity of allocated array
    u32              n_record;          //   0
    i32              n_err;             //   0
    algo::cstring*   ary_name_elems;    // pointer to elements
    u32              ary_name_n;        // number of elements in array
    u32              ary_name_max;      // max. capacity of array before realloc
    FCheck();
    ~FCheck();
private:
    // reftype Ptrary of acr.FCheck.c_bad_rec prohibits copy
    // reftype Tary of acr.FCheck.ary_name prohibits copy
    FCheck(const FCheck&){ /*disallow copy constructor */}
    void operator =(const FCheck&){ /*disallow direct assignment */}
};

// Return true if index is empty
bool                 c_bad_rec_EmptyQ(acr::FCheck& check) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FRec*           c_bad_rec_Find(acr::FCheck& check, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FRec*> c_bad_rec_Getary(acr::FCheck& check) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_bad_rec_Insert(acr::FCheck& check, acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_bad_rec_ScanInsertMaybe(acr::FCheck& check, acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_bad_rec_N(const acr::FCheck& check) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_bad_rec_Remove(acr::FCheck& check, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_bad_rec_RemoveAll(acr::FCheck& check) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_bad_rec_Reserve(acr::FCheck& check, u32 n) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       ary_name_Alloc(acr::FCheck& check) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       ary_name_AllocAt(acr::FCheck& check, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> ary_name_AllocN(acr::FCheck& check, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ary_name_EmptyQ(acr::FCheck& check) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       ary_name_Find(acr::FCheck& check, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> ary_name_Getary(acr::FCheck& check) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       ary_name_Last(acr::FCheck& check) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  ary_name_Max(acr::FCheck& check) __attribute__((nothrow));
// Return number of items in the array
i32                  ary_name_N(const acr::FCheck& check) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 ary_name_Remove(acr::FCheck& check, u32 i) __attribute__((nothrow));
void                 ary_name_RemoveAll(acr::FCheck& check) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ary_name_RemoveLast(acr::FCheck& check) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 ary_name_Reserve(acr::FCheck& check, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 ary_name_AbsReserve(acr::FCheck& check, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 ary_name_Setary(acr::FCheck& check, acr::FCheck &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       ary_name_qFind(acr::FCheck& check, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       ary_name_qLast(acr::FCheck& check) __attribute__((nothrow));
// Return row id of specified element
u64                  ary_name_rowid_Get(acr::FCheck& check, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> ary_name_AllocNVal(acr::FCheck& check, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));

void                 check_c_bad_rec_curs_Reset(check_c_bad_rec_curs &curs, acr::FCheck &parent);
// cursor points to valid item
bool                 check_c_bad_rec_curs_ValidQ(check_c_bad_rec_curs &curs);
// proceed to next item
void                 check_c_bad_rec_curs_Next(check_c_bad_rec_curs &curs);
// item access
acr::FRec&           check_c_bad_rec_curs_Access(check_c_bad_rec_curs &curs);
// proceed to next item
void                 check_ary_name_curs_Next(check_ary_name_curs &curs);
void                 check_ary_name_curs_Reset(check_ary_name_curs &curs, acr::FCheck &parent);
// cursor points to valid item
bool                 check_ary_name_curs_ValidQ(check_ary_name_curs &curs);
// item access
algo::cstring&       check_ary_name_curs_Access(check_ary_name_curs &curs);
// Set all fields to initial values.
void                 FCheck_Init(acr::FCheck& check);
void                 FCheck_Uninit(acr::FCheck& check) __attribute__((nothrow));

// --- acr.FCppfunc
// create: acr.FDb.cppfunc (Lary)
struct FCppfunc { // acr.FCppfunc
    algo::Smallstr100   field;   //
    dmmeta::CppExpr     expr;    //
private:
    friend acr::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cppfunc_RemoveAll() __attribute__((nothrow));
    friend void                 cppfunc_RemoveLast() __attribute__((nothrow));
    FCppfunc();
};

// Copy fields out of row
void                 cppfunc_CopyOut(acr::FCppfunc &row, dmmeta::Cppfunc &out) __attribute__((nothrow));
// Copy fields in to row
void                 cppfunc_CopyIn(acr::FCppfunc &row, dmmeta::Cppfunc &in) __attribute__((nothrow));


// --- acr.FCtype
// create: acr.FDb.ctype (Lary)
// global access: ind_ctype (Thash)
// global access: zd_sel_ctype (Llist)
// global access: bh_ctype_topo (Bheap)
// access: acr.Err.ctype (Ptr)
// access: acr.FCtype.c_child (Ptrary)
// access: acr.FField.p_ctype (Upptr)
// access: acr.FField.p_arg (Upptr)
// access: acr.FRec.p_ctype (Upptr)
// access: acr.FRun.c_ctype (Ptrary)
// access: acr.FRun.c_child (Ptrary)
// access: acr.FSsimfile.p_ctype (Upptr)
// access: acr.FErr.ctype (Ptr)
struct FCtype { // acr.FCtype
    algo::Smallstr50    ctype;                   // Identifier. must be ns.typename
    algo::Comment       comment;                 //
    acr::FField**       c_field_elems;           // array of pointers
    u32                 c_field_n;               // array of pointers
    u32                 c_field_max;             // capacity of allocated array
    acr::FCdflt*        c_cdflt;                 // optional pointer
    acr::FSsimfile*     c_ssimfile;              // optional pointer
    acr::FRec*          zd_trec_head;            // zero-terminated doubly linked list
    acr::FRec*          zd_trec_tail;            // pointer to last element
    acr::FRec**         ind_rec_buckets_elems;   // pointer to bucket array
    i32                 ind_rec_buckets_n;       // number of elements in bucket array
    i32                 ind_rec_n;               // number of elements in the hash table
    acr::FRec*          zd_selrec_head;          // zero-terminated doubly linked list
    acr::FRec*          zd_selrec_tail;          // pointer to last element
    i32                 n_insert;                //   0  Number of tuples inserted
    i32                 rank;                    //   false  Topological sort rank
    acr::FCtype**       c_child_elems;           // array of pointers
    u32                 c_child_n;               // array of pointers
    u32                 c_child_max;             // capacity of allocated array
    bool                show_rowid;              //   false
    u64                 next_rowid;              //   0
    bool                numeric;                 //   false
    acr::FBltin*        c_bltin;                 // optional pointer
    acr::FField*        zd_arg_head;             // zero-terminated doubly linked list
    i32                 zd_arg_n;                // zero-terminated doubly linked list
    acr::FField*        zd_arg_tail;             // pointer to last element
    i32                 rowid;                   //   0
    acr::CtypeTopoKey   topokey;                 //
    bool                visit;                   //   false  Temporary flag
    bool                cmt_printed;             //   false
    bool                mark_sel;                //   false  Ctype tree scheduled to be selected (with -meta)
    bool                mark_cascupdate;         //   false
    bool                run_c_child_in_ary;      //   false  membership flag
    acr::FCtype*        ind_ctype_next;          // hash next
    acr::FCtype*        zd_sel_ctype_next;       // zslist link; -1 means not-in-list
    acr::FCtype*        zd_sel_ctype_prev;       // previous element
    i32                 bh_ctype_topo_idx;       // index in heap; -1 means not-in-heap
private:
    friend acr::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
    FCtype();
    ~FCtype();
    FCtype(const FCtype&){ /*disallow copy constructor */}
    void operator =(const FCtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ctype_CopyOut(acr::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
void                 ctype_CopyIn(acr::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_field_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FField*         c_field_Find(acr::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FField*> c_field_Getary(acr::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_field_Insert(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_field_InsertMaybe(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_field_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_field_Remove(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_field_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_field_Reserve(acr::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cdflt_InsertMaybe(acr::FCtype& ctype, acr::FCdflt& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cdflt_Remove(acr::FCtype& ctype, acr::FCdflt& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ssimfile_InsertMaybe(acr::FCtype& ctype, acr::FSsimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ssimfile_Remove(acr::FCtype& ctype, acr::FSsimfile& row) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_trec_EmptyQ(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FRec*           zd_trec_First(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_trec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_trec_Insert(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FRec*           zd_trec_Last(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FRec*           zd_trec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FRec*           zd_trec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_trec_Remove(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_trec_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec*           zd_trec_RemoveFirst(acr::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FRec&           zd_trec_qLast(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if hash is empty
bool                 ind_rec_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FRec*           ind_rec_Find(acr::FCtype& ctype, const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_rec_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_rec_InsertMaybe(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_rec_Remove(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_rec_Reserve(acr::FCtype& ctype, int n) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_selrec_EmptyQ(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FRec*           zd_selrec_First(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_selrec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_selrec_Insert(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FRec*           zd_selrec_Last(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FRec*           zd_selrec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FRec*           zd_selrec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_selrec_Remove(acr::FCtype& ctype, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_selrec_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec*           zd_selrec_RemoveFirst(acr::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FRec&           zd_selrec_qLast(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_child_EmptyQ(acr::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FCtype*         c_child_Find(acr::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FCtype*> c_child_Getary(acr::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_child_Insert(acr::FCtype& ctype, acr::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_child_ScanInsertMaybe(acr::FCtype& ctype, acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_child_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_child_Remove(acr::FCtype& ctype, acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_child_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_child_Reserve(acr::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_bltin_InsertMaybe(acr::FCtype& ctype, acr::FBltin& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_bltin_Remove(acr::FCtype& ctype, acr::FBltin& row) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_arg_EmptyQ(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FField*         zd_arg_First(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_arg_InLlistQ(acr::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_arg_Insert(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FField*         zd_arg_Last(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_arg_N(const acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FField*         zd_arg_Next(acr::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FField*         zd_arg_Prev(acr::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_arg_Remove(acr::FCtype& ctype, acr::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_arg_RemoveAll(acr::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FField*         zd_arg_RemoveFirst(acr::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FField&         zd_arg_qLast(acr::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 topokey_Lt(acr::FCtype& ctype, acr::FCtype &rhs) __attribute__((nothrow));
// Compare two fields.
i32                  topokey_Cmp(acr::FCtype& ctype, acr::FCtype &rhs) __attribute__((nothrow));

void                 ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs);
// proceed to next item
void                 ctype_c_field_curs_Next(ctype_c_field_curs &curs);
// item access
acr::FField&         ctype_c_field_curs_Access(ctype_c_field_curs &curs);
// cursor points to valid item
void                 ctype_zd_trec_curs_Reset(ctype_zd_trec_curs &curs, acr::FCtype &parent);
// cursor points to valid item
bool                 ctype_zd_trec_curs_ValidQ(ctype_zd_trec_curs &curs);
// proceed to next item
void                 ctype_zd_trec_curs_Next(ctype_zd_trec_curs &curs);
// item access
acr::FRec&           ctype_zd_trec_curs_Access(ctype_zd_trec_curs &curs);
void                 ctype_ind_rec_curs_Reset(ctype_ind_rec_curs &curs, acr::FCtype &parent);
// cursor points to valid item
bool                 ctype_ind_rec_curs_ValidQ(ctype_ind_rec_curs &curs);
// proceed to next item
void                 ctype_ind_rec_curs_Next(ctype_ind_rec_curs &curs);
// item access
acr::FRec&           ctype_ind_rec_curs_Access(ctype_ind_rec_curs &curs);
// cursor points to valid item
void                 ctype_zd_selrec_curs_Reset(ctype_zd_selrec_curs &curs, acr::FCtype &parent);
// cursor points to valid item
bool                 ctype_zd_selrec_curs_ValidQ(ctype_zd_selrec_curs &curs);
// proceed to next item
void                 ctype_zd_selrec_curs_Next(ctype_zd_selrec_curs &curs);
// item access
acr::FRec&           ctype_zd_selrec_curs_Access(ctype_zd_selrec_curs &curs);
void                 ctype_c_child_curs_Reset(ctype_c_child_curs &curs, acr::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_child_curs_ValidQ(ctype_c_child_curs &curs);
// proceed to next item
void                 ctype_c_child_curs_Next(ctype_c_child_curs &curs);
// item access
acr::FCtype&         ctype_c_child_curs_Access(ctype_c_child_curs &curs);
// cursor points to valid item
void                 ctype_zd_arg_curs_Reset(ctype_zd_arg_curs &curs, acr::FCtype &parent);
// cursor points to valid item
bool                 ctype_zd_arg_curs_ValidQ(ctype_zd_arg_curs &curs);
// proceed to next item
void                 ctype_zd_arg_curs_Next(ctype_zd_arg_curs &curs);
// item access
acr::FField&         ctype_zd_arg_curs_Access(ctype_zd_arg_curs &curs);
// Set all fields to initial values.
void                 FCtype_Init(acr::FCtype& ctype);
void                 FCtype_Uninit(acr::FCtype& ctype) __attribute__((nothrow));

// --- acr.trace
#pragma pack(push,1)
struct trace { // acr.trace
    trace();
};
#pragma pack(pop)

// print string representation of acr::trace to string LHS, no header -- cprint:acr.trace.String
void                 trace_Print(acr::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.FDb
// create: acr.FDb._db (Global)
struct FDb { // acr.FDb
    u64                  pline_blocksize;                // # bytes per block
    acr::FPline*         pline_free;                     //
    u64                  pdep_blocksize;                 // # bytes per block
    acr::FPdep*          pdep_free;                      //
    acr::FPline*         zd_pline_head;                  // zero-terminated doubly linked list
    acr::FPline*         zd_pline_tail;                  // pointer to last element
    acr::FPdep*          zd_pdep_head;                   // zero-terminated doubly linked list
    acr::FPdep*          zd_pdep_tail;                   // pointer to last element
    command::acr         cmdline;                        // command line
    acr::FCtype*         ctype_lary[32];                 // level array
    i32                  ctype_n;                        // number of elements in array
    u64                  err_blocksize;                  // # bytes per block
    acr::FErr*           err_free;                       //
    acr::FAnonfld*       anonfld_lary[32];               // level array
    i32                  anonfld_n;                      // number of elements in array
    acr::FCdflt*         cdflt_lary[32];                 // level array
    i32                  cdflt_n;                        // number of elements in array
    u64                  rec_blocksize;                  // # bytes per block
    acr::FRec*           rec_free;                       //
    u64                  uniqueattr_blocksize;           // # bytes per block
    acr::FUniqueattr*    uniqueattr_free;                //
    u64                  query_blocksize;                // # bytes per block
    acr::FQuery*         query_free;                     //
    acr::FField*         field_lary[32];                 // level array
    i32                  field_n;                        // number of elements in array
    acr::FFile*          file_lary[32];                  // level array
    i32                  file_n;                         // number of elements in array
    u32                  err_seq;                        //   0
    bool                 check_failed;                   //   false
    acr::FCtype**        ind_ctype_buckets_elems;        // pointer to bucket array
    i32                  ind_ctype_buckets_n;            // number of elements in bucket array
    i32                  ind_ctype_n;                    // number of elements in the hash table
    acr::FField**        ind_field_buckets_elems;        // pointer to bucket array
    i32                  ind_field_buckets_n;            // number of elements in bucket array
    i32                  ind_field_n;                    // number of elements in the hash table
    acr::FFile**         ind_file_buckets_elems;         // pointer to bucket array
    i32                  ind_file_buckets_n;             // number of elements in bucket array
    i32                  ind_file_n;                     // number of elements in the hash table
    acr::FRec*           zd_all_selrec_head;             // zero-terminated doubly linked list
    i32                  zd_all_selrec_n;                // zero-terminated doubly linked list
    acr::FRec*           zd_all_selrec_tail;             // pointer to last element
    acr::FErr*           zd_all_err_head;                // zero-terminated doubly linked list
    i32                  zd_all_err_n;                   // zero-terminated doubly linked list
    acr::FErr*           zd_all_err_tail;                // pointer to last element
    acr::FCtype*         zd_sel_ctype_head;              // zero-terminated doubly linked list
    acr::FCtype*         zd_sel_ctype_tail;              // pointer to last element
    acr::FPline**        bh_pline_elems;                 // binary heap by key
    i32                  bh_pline_n;                     // number of elements in the heap
    i32                  bh_pline_max;                   // max elements in bh_pline_elems
    acr::FSubstr*        substr_lary[32];                // level array
    i32                  substr_n;                       // number of elements in array
    acr::FSsimfile*      ssimfile_lary[32];              // level array
    i32                  ssimfile_n;                     // number of elements in array
    acr::FTempkey*       tempkey_lary[32];               // level array
    i32                  tempkey_n;                      // number of elements in array
    acr::FTempkey**      ind_tempkey_buckets_elems;      // pointer to bucket array
    i32                  ind_tempkey_buckets_n;          // number of elements in bucket array
    i32                  ind_tempkey_n;                  // number of elements in the hash table
    acr::FSsimfile**     ind_ssimfile_buckets_elems;     // pointer to bucket array
    i32                  ind_ssimfile_buckets_n;         // number of elements in bucket array
    i32                  ind_ssimfile_n;                 // number of elements in the hash table
    acr::FQuery*         zs_query_head;                  // zero-terminated singly linked list
    acr::FQuery*         zs_query_tail;                  // pointer to last element
    acr::FSsimsort*      ssimsort_lary[32];              // level array
    i32                  ssimsort_n;                     // number of elements in array
    acr::FSsimsort**     ind_ssimsort_buckets_elems;     // pointer to bucket array
    i32                  ind_ssimsort_buckets_n;         // number of elements in bucket array
    i32                  ind_ssimsort_n;                 // number of elements in the hash table
    u32                  n_file_written;                 //   0  Number of files written
    report::acr          report;                         //
    acr::FSmallstr*      smallstr_lary[32];              // level array
    i32                  smallstr_n;                     // number of elements in array
    acr::FFunique*       funique_lary[32];               // level array
    i32                  funique_n;                      // number of elements in array
    acr::FUniqueattr**   ind_uniqueattr_buckets_elems;   // pointer to bucket array
    i32                  ind_uniqueattr_buckets_n;       // number of elements in bucket array
    i32                  ind_uniqueattr_n;               // number of elements in the hash table
    acr::FBltin*         bltin_lary[32];                 // level array
    i32                  bltin_n;                        // number of elements in array
    bool                 ctype_rank_computed;            //   false
    bool                 file_input;                     //   false
    acr::FCtype**        bh_ctype_topo_elems;            // binary heap by topokey
    i32                  bh_ctype_topo_n;                // number of elements in the heap
    i32                  bh_ctype_topo_max;              // max elements in bh_ctype_topo_elems
    acr::FCppfunc*       cppfunc_lary[32];               // level array
    i32                  cppfunc_n;                      // number of elements in array
    acr::FSsimreq*       ssimreq_lary[32];               // level array
    i32                  ssimreq_n;                      // number of elements in array
    acr::trace           trace;                          //
};

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FPline&         pline_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FPline*         pline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 pline_Delete(acr::FPline &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                pline_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 pline_FreeMem(acr::FPline &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  pline_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  pline_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 pline_XrefMaybe(acr::FPline &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FPdep&          pdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FPdep*          pdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 pdep_Delete(acr::FPdep &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                pdep_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 pdep_FreeMem(acr::FPdep &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  pdep_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  pdep_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 pdep_XrefMaybe(acr::FPdep &row);

// Delete all elements in the linked list.
void                 zd_pline_Cascdel() __attribute__((nothrow));
// Return true if index is empty
bool                 zd_pline_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FPline*         zd_pline_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_pline_InLlistQ(acr::FPline& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_pline_Insert(acr::FPline& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FPline*         zd_pline_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FPline*         zd_pline_Next(acr::FPline &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FPline*         zd_pline_Prev(acr::FPline &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_pline_Remove(acr::FPline& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_pline_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FPline*         zd_pline_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FPline&         zd_pline_qLast() __attribute__((__warn_unused_result__, nothrow));

// Delete all elements in the linked list.
void                 zd_pdep_Cascdel() __attribute__((nothrow));
// Return true if index is empty
bool                 zd_pdep_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FPdep*          zd_pdep_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_pdep_InLlistQ(acr::FPdep& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_pdep_Insert(acr::FPdep& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FPdep*          zd_pdep_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FPdep*          zd_pdep_Next(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FPdep*          zd_pdep_Prev(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_pdep_Remove(acr::FPdep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_pdep_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FPdep*          zd_pdep_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FPdep&          zd_pdep_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FCtype*         ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ctype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FCtype*         ctype_Find(i32 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FCtype*         ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FCtype&         ctype_qFind(i32 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ctype_XrefMaybe(acr::FCtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FErr&           err_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FErr*           err_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FErr*           err_InsertMaybe(const acr::Err &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 err_Delete(acr::FErr &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                err_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 err_FreeMem(acr::FErr &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  err_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  err_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 err_XrefMaybe(acr::FErr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FAnonfld*       anonfld_InsertMaybe(const dmmeta::Anonfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                anonfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 anonfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FAnonfld*       anonfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FAnonfld*       anonfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  anonfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 anonfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FAnonfld&       anonfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 anonfld_XrefMaybe(acr::FAnonfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FCdflt*         cdflt_InsertMaybe(const dmmeta::Cdflt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cdflt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cdflt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FCdflt*         cdflt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FCdflt*         cdflt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cdflt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cdflt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FCdflt&         cdflt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cdflt_XrefMaybe(acr::FCdflt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FRec&           rec_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FRec*           rec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 rec_Delete(acr::FRec &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                rec_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 rec_FreeMem(acr::FRec &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  rec_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  rec_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 rec_XrefMaybe(acr::FRec &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FUniqueattr&    uniqueattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FUniqueattr*    uniqueattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 uniqueattr_Delete(acr::FUniqueattr &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                uniqueattr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 uniqueattr_FreeMem(acr::FUniqueattr &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  uniqueattr_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  uniqueattr_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 uniqueattr_XrefMaybe(acr::FUniqueattr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FQuery&         query_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FQuery*         query_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 query_Delete(acr::FQuery &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                query_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 query_FreeMem(acr::FQuery &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  query_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  query_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 query_XrefMaybe(acr::FQuery &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FField*         field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 field_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FField*         field_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FField*         field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FField&         field_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 field_XrefMaybe(acr::FField &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FFile&          file_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FFile*          file_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                file_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 file_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FFile*          file_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FFile*          file_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  file_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 file_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 file_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FFile&          file_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 file_XrefMaybe(acr::FFile &row);

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     acr.FDb.cmdline
//     algo_lib.FDb.cmdline
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Calls Step function of dependencies
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Return true if hash is empty
bool                 ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FCtype*         ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ctype_InsertMaybe(acr::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ctype_Remove(acr::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FField*         ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_field_InsertMaybe(acr::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_field_Remove(acr::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_file_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FFile*          ind_file_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
acr::FFile&          ind_file_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_file_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_file_InsertMaybe(acr::FFile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_file_Remove(acr::FFile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_file_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_all_selrec_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FRec*           zd_all_selrec_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_all_selrec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_all_selrec_Insert(acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FRec*           zd_all_selrec_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_all_selrec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FRec*           zd_all_selrec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FRec*           zd_all_selrec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_all_selrec_Remove(acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_all_selrec_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec*           zd_all_selrec_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FRec&           zd_all_selrec_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zd_all_err_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FErr*           zd_all_err_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_all_err_InLlistQ(acr::FErr& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_all_err_Insert(acr::FErr& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FErr*           zd_all_err_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_all_err_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FErr*           zd_all_err_Next(acr::FErr &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FErr*           zd_all_err_Prev(acr::FErr &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_all_err_Remove(acr::FErr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_all_err_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FErr*           zd_all_err_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FErr&           zd_all_err_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zd_sel_ctype_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FCtype*         zd_sel_ctype_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_sel_ctype_InLlistQ(acr::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_sel_ctype_Insert(acr::FCtype& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FCtype*         zd_sel_ctype_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FCtype*         zd_sel_ctype_Next(acr::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FCtype*         zd_sel_ctype_Prev(acr::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_sel_ctype_Remove(acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_sel_ctype_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FCtype*         zd_sel_ctype_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FCtype&         zd_sel_ctype_qLast() __attribute__((__warn_unused_result__, nothrow));

// Remove all elements from heap and free memory used by the array.
void                 bh_pline_Dealloc() __attribute__((nothrow));
// Return true if index is empty
bool                 bh_pline_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FPline*         bh_pline_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_pline_InBheapQ(acr::FPline& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_pline_Insert(acr::FPline& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_pline_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_pline_Reheap(acr::FPline& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_pline_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_pline_Remove(acr::FPline& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_pline_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
acr::FPline*         bh_pline_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_pline_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSubstr*        substr_InsertMaybe(const dmmeta::Substr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                substr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 substr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FSubstr*        substr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FSubstr*        substr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  substr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 substr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FSubstr&        substr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 substr_XrefMaybe(acr::FSubstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSsimfile*      ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FSsimfile*      ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FSsimfile*      ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FSsimfile&      ssimfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimfile_XrefMaybe(acr::FSsimfile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FTempkey&       tempkey_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FTempkey*       tempkey_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tempkey_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tempkey_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FTempkey*       tempkey_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FTempkey*       tempkey_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tempkey_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 tempkey_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tempkey_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FTempkey&       tempkey_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 tempkey_XrefMaybe(acr::FTempkey &row);

// Return true if hash is empty
bool                 ind_tempkey_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FTempkey*       ind_tempkey_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
acr::FTempkey&       ind_tempkey_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_tempkey_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_tempkey_InsertMaybe(acr::FTempkey& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_tempkey_Remove(acr::FTempkey& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_tempkey_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FSsimfile*      ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimfile_InsertMaybe(acr::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimfile_Remove(acr::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 print_XrefMaybe(acr::FPrint &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FPrintAttr&     printattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FPrintAttr*     printattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 printattr_Delete(acr::FPrintAttr &row) __attribute__((nothrow));
// Allocate n bytes. If no memory available, return NULL.
void*                printattr_AllocMem(size_t n) __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 printattr_FreeMem(void *mem, size_t n) __attribute__((nothrow));
// Reallocate n bytes. If the call fails, return value is NULL.
// In this case, original MEM pointer is untouched.
void*                printattr_ReallocMem(void *mem, size_t old_size, size_t new_size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 printattr_XrefMaybe(acr::FPrintAttr &row);

// Return true if index is empty
bool                 zs_query_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FQuery*         zs_query_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_query_InLlistQ(acr::FQuery& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_query_Insert(acr::FQuery& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FQuery*         zs_query_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FQuery*         zs_query_Next(acr::FQuery &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_query_Remove(acr::FQuery& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_query_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FQuery*         zs_query_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FQuery&         zs_query_qLast() __attribute__((__warn_unused_result__, nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 run_XrefMaybe(acr::FRun &row);

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 check_XrefMaybe(acr::FCheck &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSsimsort&      ssimsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FSsimsort*      ssimsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSsimsort*      ssimsort_InsertMaybe(const dmmeta::Ssimsort &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimsort_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimsort_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FSsimsort*      ssimsort_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FSsimsort*      ssimsort_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimsort_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FSsimsort&      ssimsort_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimsort_XrefMaybe(acr::FSsimsort &row);

// Return true if hash is empty
bool                 ind_ssimsort_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FSsimsort*      ind_ssimsort_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_ssimsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimsort_InsertMaybe(acr::FSsimsort& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimsort_Remove(acr::FSsimsort& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimsort_Reserve(int n) __attribute__((nothrow));

// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 write_XrefMaybe(acr::FWrite &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSmallstr*      smallstr_InsertMaybe(const dmmeta::Smallstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                smallstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 smallstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FSmallstr*      smallstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FSmallstr*      smallstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  smallstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 smallstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FSmallstr&      smallstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 smallstr_XrefMaybe(acr::FSmallstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FFunique*       funique_InsertMaybe(const dmmeta::Funique &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                funique_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 funique_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FFunique*       funique_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FFunique*       funique_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  funique_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 funique_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FFunique&       funique_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 funique_XrefMaybe(acr::FFunique &row);

// Return true if hash is empty
bool                 ind_uniqueattr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FUniqueattr*    ind_uniqueattr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
acr::FUniqueattr&    ind_uniqueattr_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_uniqueattr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_uniqueattr_InsertMaybe(acr::FUniqueattr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_uniqueattr_Remove(acr::FUniqueattr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_uniqueattr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FBltin*         bltin_InsertMaybe(const amcdb::Bltin &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                bltin_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 bltin_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FBltin*         bltin_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FBltin*         bltin_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  bltin_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 bltin_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FBltin&         bltin_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 bltin_XrefMaybe(acr::FBltin &row);

// Remove all elements from heap and free memory used by the array.
void                 bh_ctype_topo_Dealloc() __attribute__((nothrow));
// Return true if index is empty
bool                 bh_ctype_topo_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FCtype*         bh_ctype_topo_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_ctype_topo_InBheapQ(acr::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_ctype_topo_Insert(acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_ctype_topo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_ctype_topo_Reheap(acr::FCtype& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_ctype_topo_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_ctype_topo_Remove(acr::FCtype& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_ctype_topo_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
acr::FCtype*         bh_ctype_topo_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_ctype_topo_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FCppfunc*       cppfunc_InsertMaybe(const dmmeta::Cppfunc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cppfunc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cppfunc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FCppfunc*       cppfunc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FCppfunc*       cppfunc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cppfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cppfunc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cppfunc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FCppfunc&       cppfunc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cppfunc_XrefMaybe(acr::FCppfunc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
acr::FSsimreq&       ssimreq_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
acr::FSsimreq*       ssimreq_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
acr::FSsimreq*       ssimreq_InsertMaybe(const dmmeta::Ssimreq &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimreq_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimreq_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
acr::FSsimreq*       ssimreq_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
acr::FSsimreq*       ssimreq_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimreq_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 ssimreq_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ssimreq_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::FSsimreq&       ssimreq_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimreq_XrefMaybe(acr::FSsimreq &row);

// cursor points to valid item
void                 _db_zd_pline_curs_Reset(_db_zd_pline_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_zd_pline_curs_ValidQ(_db_zd_pline_curs &curs);
// proceed to next item
void                 _db_zd_pline_curs_Next(_db_zd_pline_curs &curs);
// item access
acr::FPline&         _db_zd_pline_curs_Access(_db_zd_pline_curs &curs);
// cursor points to valid item
void                 _db_zd_pdep_curs_Reset(_db_zd_pdep_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_zd_pdep_curs_ValidQ(_db_zd_pdep_curs &curs);
// proceed to next item
void                 _db_zd_pdep_curs_Next(_db_zd_pdep_curs &curs);
// item access
acr::FPdep&          _db_zd_pdep_curs_Access(_db_zd_pdep_curs &curs);
// cursor points to valid item
void                 _db_ctype_curs_Reset(_db_ctype_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_ctype_curs_ValidQ(_db_ctype_curs &curs);
// proceed to next item
void                 _db_ctype_curs_Next(_db_ctype_curs &curs);
// item access
acr::FCtype&         _db_ctype_curs_Access(_db_ctype_curs &curs);
// cursor points to valid item
void                 _db_anonfld_curs_Reset(_db_anonfld_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_anonfld_curs_ValidQ(_db_anonfld_curs &curs);
// proceed to next item
void                 _db_anonfld_curs_Next(_db_anonfld_curs &curs);
// item access
acr::FAnonfld&       _db_anonfld_curs_Access(_db_anonfld_curs &curs);
// cursor points to valid item
void                 _db_cdflt_curs_Reset(_db_cdflt_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_cdflt_curs_ValidQ(_db_cdflt_curs &curs);
// proceed to next item
void                 _db_cdflt_curs_Next(_db_cdflt_curs &curs);
// item access
acr::FCdflt&         _db_cdflt_curs_Access(_db_cdflt_curs &curs);
// cursor points to valid item
void                 _db_field_curs_Reset(_db_field_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_field_curs_ValidQ(_db_field_curs &curs);
// proceed to next item
void                 _db_field_curs_Next(_db_field_curs &curs);
// item access
acr::FField&         _db_field_curs_Access(_db_field_curs &curs);
// cursor points to valid item
void                 _db_file_curs_Reset(_db_file_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_file_curs_ValidQ(_db_file_curs &curs);
// proceed to next item
void                 _db_file_curs_Next(_db_file_curs &curs);
// item access
acr::FFile&          _db_file_curs_Access(_db_file_curs &curs);
// cursor points to valid item
void                 _db_zd_all_selrec_curs_Reset(_db_zd_all_selrec_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_zd_all_selrec_curs_ValidQ(_db_zd_all_selrec_curs &curs);
// proceed to next item
void                 _db_zd_all_selrec_curs_Next(_db_zd_all_selrec_curs &curs);
// item access
acr::FRec&           _db_zd_all_selrec_curs_Access(_db_zd_all_selrec_curs &curs);
// cursor points to valid item
void                 _db_zd_all_err_curs_Reset(_db_zd_all_err_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_zd_all_err_curs_ValidQ(_db_zd_all_err_curs &curs);
// proceed to next item
void                 _db_zd_all_err_curs_Next(_db_zd_all_err_curs &curs);
// item access
acr::FErr&           _db_zd_all_err_curs_Access(_db_zd_all_err_curs &curs);
// cursor points to valid item
void                 _db_zd_sel_ctype_curs_Reset(_db_zd_sel_ctype_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_zd_sel_ctype_curs_ValidQ(_db_zd_sel_ctype_curs &curs);
// proceed to next item
void                 _db_zd_sel_ctype_curs_Next(_db_zd_sel_ctype_curs &curs);
// item access
acr::FCtype&         _db_zd_sel_ctype_curs_Access(_db_zd_sel_ctype_curs &curs);
void                 _db_bh_pline_curs_Reserve(_db_bh_pline_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 _db_bh_pline_curs_Reset(_db_bh_pline_curs &curs, acr::FDb &parent);
// Advance cursor.
void                 _db_bh_pline_curs_Next(_db_bh_pline_curs &curs);
// Access current element. If not more elements, return NULL
acr::FPline&         _db_bh_pline_curs_Access(_db_bh_pline_curs &curs);
// Return true if Access() will return non-NULL.
bool                 _db_bh_pline_curs_ValidQ(_db_bh_pline_curs &curs);
// cursor points to valid item
void                 _db_substr_curs_Reset(_db_substr_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_substr_curs_ValidQ(_db_substr_curs &curs);
// proceed to next item
void                 _db_substr_curs_Next(_db_substr_curs &curs);
// item access
acr::FSubstr&        _db_substr_curs_Access(_db_substr_curs &curs);
// cursor points to valid item
void                 _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs);
// proceed to next item
void                 _db_ssimfile_curs_Next(_db_ssimfile_curs &curs);
// item access
acr::FSsimfile&      _db_ssimfile_curs_Access(_db_ssimfile_curs &curs);
// cursor points to valid item
void                 _db_tempkey_curs_Reset(_db_tempkey_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_tempkey_curs_ValidQ(_db_tempkey_curs &curs);
// proceed to next item
void                 _db_tempkey_curs_Next(_db_tempkey_curs &curs);
// item access
acr::FTempkey&       _db_tempkey_curs_Access(_db_tempkey_curs &curs);
// cursor points to valid item
void                 _db_zs_query_curs_Reset(_db_zs_query_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_zs_query_curs_ValidQ(_db_zs_query_curs &curs);
// proceed to next item
void                 _db_zs_query_curs_Next(_db_zs_query_curs &curs);
// item access
acr::FQuery&         _db_zs_query_curs_Access(_db_zs_query_curs &curs);
// cursor points to valid item
void                 _db_ssimsort_curs_Reset(_db_ssimsort_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_ssimsort_curs_ValidQ(_db_ssimsort_curs &curs);
// proceed to next item
void                 _db_ssimsort_curs_Next(_db_ssimsort_curs &curs);
// item access
acr::FSsimsort&      _db_ssimsort_curs_Access(_db_ssimsort_curs &curs);
// cursor points to valid item
void                 _db_smallstr_curs_Reset(_db_smallstr_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_smallstr_curs_ValidQ(_db_smallstr_curs &curs);
// proceed to next item
void                 _db_smallstr_curs_Next(_db_smallstr_curs &curs);
// item access
acr::FSmallstr&      _db_smallstr_curs_Access(_db_smallstr_curs &curs);
// cursor points to valid item
void                 _db_funique_curs_Reset(_db_funique_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_funique_curs_ValidQ(_db_funique_curs &curs);
// proceed to next item
void                 _db_funique_curs_Next(_db_funique_curs &curs);
// item access
acr::FFunique&       _db_funique_curs_Access(_db_funique_curs &curs);
// cursor points to valid item
void                 _db_bltin_curs_Reset(_db_bltin_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_bltin_curs_ValidQ(_db_bltin_curs &curs);
// proceed to next item
void                 _db_bltin_curs_Next(_db_bltin_curs &curs);
// item access
acr::FBltin&         _db_bltin_curs_Access(_db_bltin_curs &curs);
void                 _db_bh_ctype_topo_curs_Reserve(_db_bh_ctype_topo_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 _db_bh_ctype_topo_curs_Reset(_db_bh_ctype_topo_curs &curs, acr::FDb &parent);
// Advance cursor.
void                 _db_bh_ctype_topo_curs_Next(_db_bh_ctype_topo_curs &curs);
// Access current element. If not more elements, return NULL
acr::FCtype&         _db_bh_ctype_topo_curs_Access(_db_bh_ctype_topo_curs &curs);
// Return true if Access() will return non-NULL.
bool                 _db_bh_ctype_topo_curs_ValidQ(_db_bh_ctype_topo_curs &curs);
// cursor points to valid item
void                 _db_cppfunc_curs_Reset(_db_cppfunc_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_cppfunc_curs_ValidQ(_db_cppfunc_curs &curs);
// proceed to next item
void                 _db_cppfunc_curs_Next(_db_cppfunc_curs &curs);
// item access
acr::FCppfunc&       _db_cppfunc_curs_Access(_db_cppfunc_curs &curs);
// cursor points to valid item
void                 _db_ssimreq_curs_Reset(_db_ssimreq_curs &curs, acr::FDb &parent);
// cursor points to valid item
bool                 _db_ssimreq_curs_ValidQ(_db_ssimreq_curs &curs);
// proceed to next item
void                 _db_ssimreq_curs_Next(_db_ssimreq_curs &curs);
// item access
acr::FSsimreq&       _db_ssimreq_curs_Access(_db_ssimreq_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- acr.FErr
// create: acr.FDb.err (Tpool)
// global access: zd_all_err (Llist)
struct FErr { // acr.FErr
    acr::FErr*      err_next;          // Pointer to next free element int tpool
    acr::FErr*      zd_all_err_next;   // zslist link; -1 means not-in-list
    acr::FErr*      zd_all_err_prev;   // previous element
    acr::FCtype*    ctype;             // Parent ctype. optional pointer
    u32             id;                //   0  ID
    algo::cstring   text;              // Error text
    acr::FRec*      rec;               // Parent record. optional pointer
    acr::FField*    fld;               // Parent field. optional pointer
private:
    friend acr::FErr&           err_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FErr*           err_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 err_Delete(acr::FErr &row) __attribute__((nothrow));
    FErr();
    ~FErr();
    FErr(const FErr&){ /*disallow copy constructor */}
    void operator =(const FErr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 err_CopyOut(acr::FErr &row, acr::Err &out) __attribute__((nothrow));
// Copy fields in to row
void                 err_CopyIn(acr::FErr &row, acr::Err &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FErr_Init(acr::FErr& err);
void                 FErr_Uninit(acr::FErr& err) __attribute__((nothrow));

// --- acr.FEvalattr
struct FEvalattr { // acr.FEvalattr
    bool              pick_dflt;   //   false  (in) If attr not found, choose default?
    bool              normalize;   //   false  (in) Normalize input value if possible
    acr::FField*      field;       // (in) field. optional pointer
    algo::Attr*       attr;        // (out) Tuple attribute. optional pointer
    algo::cstring     value;       // (out) Resulting value
    algo::i32_Range   val_range;   // (out) Range in attribute corresponding to value
    explicit FEvalattr(bool                           in_pick_dflt
        ,bool                           in_normalize
        ,acr::FField*                   in_field
        ,algo::Attr*                    in_attr
        ,const algo::strptr&            in_value
        ,const algo::i32_Range&         in_val_range);
    FEvalattr();
};

// Set all fields to initial values.
void                 FEvalattr_Init(acr::FEvalattr& parent);

// --- acr.FField
// create: acr.FDb.field (Lary)
// global access: ind_field (Thash)
// access: acr.Err.fld (Ptr)
// access: acr.FCtype.c_field (Ptrary)
// access: acr.FCtype.zd_arg (Llist)
// access: acr.FEvalattr.field (Ptr)
// access: acr.FRun.c_field (Ptrary)
// access: acr.FSsimreq.p_field (Upptr)
// access: acr.FErr.fld (Ptr)
struct FField { // acr.FField
    acr::FField*        zd_arg_next;            // zslist link; -1 means not-in-list
    acr::FField*        zd_arg_prev;            // previous element
    acr::FField*        ind_field_next;         // hash next
    algo::Smallstr100   field;                  //
    algo::Smallstr50    arg;                    // type of field
    algo::Smallstr50    reftype;                //   "Val"
    dmmeta::CppExpr     dflt;                   // default value (c++ expression)
    algo::Comment       comment;                //
    acr::FCtype*        p_ctype;                // reference to parent row
    acr::FCtype*        p_arg;                  // reference to parent row
    acr::FSubstr*       c_substr;               // optional pointer
    u32                 max_attr_len;           //   0  Column width in chars
    u32                 col_width;              //   0  Column width in chars
    bool                isfldfunc;              //   false
    bool                anon;                   //   false
    bool                unique;                 //   false
    bool                ctype_c_field_in_ary;   //   false  membership flag
private:
    friend acr::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
    FField();
    ~FField();
    FField(const FField&){ /*disallow copy constructor */}
    void operator =(const FField&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 field_CopyOut(acr::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
void                 field_CopyIn(acr::FField &row, dmmeta::Field &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(acr::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(acr::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_substr_InsertMaybe(acr::FField& field, acr::FSubstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_substr_Remove(acr::FField& field, acr::FSubstr& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FField_Init(acr::FField& field);
void                 FField_Uninit(acr::FField& field) __attribute__((nothrow));

// --- acr.FFile
// create: acr.FDb.file (Lary)
// global access: ind_file (Thash)
// access: acr.FRec.p_outfile (Upptr)
// access: acr.FRec.p_infile (Upptr)
// access: acr.FSsimfile.c_file (Ptr)
struct FFile { // acr.FFile
    acr::FFile*     ind_file_next;   // hash next
    algo::cstring   file;            // Primary key
    algo::cstring   filename;        // Non-empty if it's a real file
    bool            ephemeral;       //   false  Do not save back
    bool            sticky;          //   false  Records loaded from file are written back to file
    u32             lineno;          //   1  Current line number
    acr::FRec*      zd_frec_head;    // zero-terminated doubly linked list
    acr::FRec*      zd_frec_tail;    // pointer to last element
    algo::UnTime    modtime;         // File modification time at time of loading
    bool            autoloaded;      //   false  File was pulled in implicitly: loaded records are not 'inserted'
    bool            deselect;        //   false  De-select input records
private:
    friend acr::FFile&          file_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FFile*          file_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 file_RemoveAll() __attribute__((nothrow));
    friend void                 file_RemoveLast() __attribute__((nothrow));
    FFile();
    ~FFile();
    FFile(const FFile&){ /*disallow copy constructor */}
    void operator =(const FFile&){ /*disallow direct assignment */}
};

// Return true if index is empty
bool                 zd_frec_EmptyQ(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FRec*           zd_frec_First(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_frec_InLlistQ(acr::FRec& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_frec_Insert(acr::FFile& file, acr::FRec& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FRec*           zd_frec_Last(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FRec*           zd_frec_Next(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FRec*           zd_frec_Prev(acr::FRec &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_frec_Remove(acr::FFile& file, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_frec_RemoveAll(acr::FFile& file) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FRec*           zd_frec_RemoveFirst(acr::FFile& file) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FRec&           zd_frec_qLast(acr::FFile& file) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFile_Init(acr::FFile& file);
// cursor points to valid item
void                 file_zd_frec_curs_Reset(file_zd_frec_curs &curs, acr::FFile &parent);
// cursor points to valid item
bool                 file_zd_frec_curs_ValidQ(file_zd_frec_curs &curs);
// proceed to next item
void                 file_zd_frec_curs_Next(file_zd_frec_curs &curs);
// item access
acr::FRec&           file_zd_frec_curs_Access(file_zd_frec_curs &curs);
void                 FFile_Uninit(acr::FFile& file) __attribute__((nothrow));

// --- acr.FFunique
// create: acr.FDb.funique (Lary)
struct FFunique { // acr.FFunique
    algo::Smallstr100   field;   //
private:
    friend acr::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 funique_RemoveLast() __attribute__((nothrow));
    FFunique();
};

// Copy fields out of row
void                 funique_CopyOut(acr::FFunique &row, dmmeta::Funique &out) __attribute__((nothrow));
// Copy fields in to row
void                 funique_CopyIn(acr::FFunique &row, dmmeta::Funique &in) __attribute__((nothrow));


// --- acr.FPdep
// create: acr.FDb.pdep (Tpool)
// global access: zd_pdep (Llist)
// access: acr.FPline.zd_child (Llist)
struct FPdep { // acr.FPdep: Dependency between two print-line records
    acr::FPdep*    pdep_next;       // Pointer to next free element int tpool
    acr::FPdep*    zd_pdep_next;    // zslist link; -1 means not-in-list
    acr::FPdep*    zd_pdep_prev;    // previous element
    acr::FPline*   p_parent;        // reference to parent row
    acr::FPline*   p_child;         // reference to parent row
    i32            weight;          //   0
    i32            lindex;          //   0  Index of child referencing attr
    acr::FPdep*    zd_child_next;   // zslist link; -1 means not-in-list
    acr::FPdep*    zd_child_prev;   // previous element
private:
    friend acr::FPdep&          pdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FPdep*          pdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pdep_Delete(acr::FPdep &row) __attribute__((nothrow));
    FPdep();
    ~FPdep();
    FPdep(const FPdep&){ /*disallow copy constructor */}
    void operator =(const FPdep&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FPdep_Init(acr::FPdep& pdep);
void                 FPdep_Uninit(acr::FPdep& pdep) __attribute__((nothrow));

// --- acr.PlineKey
struct PlineKey { // acr.PlineKey: Key for sorting print-line records
    i32   alldep;       //   0  # Unresolved references
    i32   negdepth;     //   0  Minus tree depth for depth-first print
    i32   ctype_rank;   //   0  Topological key for ctype
    i32   rowid;        //   0  Rowid of original record
    bool operator ==(const acr::PlineKey &rhs) const;
    bool operator !=(const acr::PlineKey &rhs) const;
    bool operator <(const acr::PlineKey &rhs) const;
    bool operator >(const acr::PlineKey &rhs) const;
    bool operator <=(const acr::PlineKey &rhs) const;
    bool operator >=(const acr::PlineKey &rhs) const;
    PlineKey();
};

u32                  PlineKey_Hash(u32 prev, const acr::PlineKey & rhs) __attribute__((nothrow));
bool                 PlineKey_Lt(acr::PlineKey & lhs, acr::PlineKey & rhs) __attribute__((nothrow));
i32                  PlineKey_Cmp(acr::PlineKey & lhs, acr::PlineKey & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 PlineKey_Init(acr::PlineKey& parent);
bool                 PlineKey_Eq(const acr::PlineKey & lhs,const acr::PlineKey & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 PlineKey_Update(acr::PlineKey &lhs, acr::PlineKey & rhs) __attribute__((nothrow));
// print string representation of acr::PlineKey to string LHS, no header -- cprint:acr.PlineKey.String
void                 PlineKey_Print(acr::PlineKey & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.FPline
// create: acr.FDb.pline (Tpool)
// global access: zd_pline (Llist)
// global access: bh_pline (Bheap)
// access: acr.FPdep.p_parent (Upptr)
// access: acr.FPdep.p_child (Upptr)
// access: acr.FPrint.c_pline (Ptrary)
// access: acr.FRec.c_pline (Ptr)
struct FPline { // acr.FPline: Print-line
    acr::FPline*    pline_next;      // Pointer to next free element int tpool
    acr::FPline*    zd_pline_next;   // zslist link; -1 means not-in-list
    acr::FPline*    zd_pline_prev;   // previous element
    i32             bh_pline_idx;    // index in heap; -1 means not-in-heap
    acr::PlineKey   key;             // Sort key
    acr::FRec*      p_rec;           // reference to parent row
    acr::FPdep*     zd_child_head;   // zero-terminated doubly linked list
    acr::FPdep*     zd_child_tail;   // pointer to last element
private:
    friend acr::FPline&         pline_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FPline*         pline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pline_Delete(acr::FPline &row) __attribute__((nothrow));
    FPline();
    ~FPline();
    FPline(const FPline&){ /*disallow copy constructor */}
    void operator =(const FPline&){ /*disallow direct assignment */}
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 key_Lt(acr::FPline& pline, acr::FPline &rhs) __attribute__((nothrow));
// Compare two fields.
i32                  key_Cmp(acr::FPline& pline, acr::FPline &rhs) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_child_EmptyQ(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
acr::FPdep*          zd_child_First(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_child_InLlistQ(acr::FPdep& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_child_Insert(acr::FPline& pline, acr::FPdep& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
acr::FPdep*          zd_child_Last(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
acr::FPdep*          zd_child_Next(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
acr::FPdep*          zd_child_Prev(acr::FPdep &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_child_Remove(acr::FPline& pline, acr::FPdep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_child_RemoveAll(acr::FPline& pline) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
acr::FPdep*          zd_child_RemoveFirst(acr::FPline& pline) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
acr::FPdep&          zd_child_qLast(acr::FPline& pline) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FPline_Init(acr::FPline& pline);
// cursor points to valid item
void                 pline_zd_child_curs_Reset(pline_zd_child_curs &curs, acr::FPline &parent);
// cursor points to valid item
bool                 pline_zd_child_curs_ValidQ(pline_zd_child_curs &curs);
// proceed to next item
void                 pline_zd_child_curs_Next(pline_zd_child_curs &curs);
// item access
acr::FPdep&          pline_zd_child_curs_Access(pline_zd_child_curs &curs);
void                 FPline_Uninit(acr::FPline& pline) __attribute__((nothrow));

// --- acr.FPrint
// create: acr.FDb.print (Cppstack)
// access: acr.FPrintAttr.p_print (Upptr)
struct FPrint { // acr.FPrint: Print function
    acr::FPrintAttr**   ind_printattr_buckets_elems;   // pointer to bucket array
    i32                 ind_printattr_buckets_n;       // number of elements in bucket array
    i32                 ind_printattr_n;               // number of elements in the hash table
    acr::FPline**       c_pline_elems;                 // array of pointers
    u32                 c_pline_n;                     // array of pointers
    u32                 c_pline_max;                   // capacity of allocated array
    bool                pretty;                        //   false  Block alignment
    bool                tree;                          //   false
    bool                fldfunc;                       //   false
    i32                 maxgroup;                      //   25
    bool                cmt;                           //   false
    bool                rowid;                         //   true
    algo::cstring       out;                           // Output
    bool                fstdout;                       //   true  Dump to stdout?
    bool                loose;                         //   false  Loose referential integrity
    bool                showstatus;                    //   false  show record status (acr.insert etc)
    i32                 skip_line;                     //   0
    i32                 this_depth;                    //   0
    i32                 prev_depth;                    //   0
    FPrint();
    ~FPrint();
private:
    // reftype Thash of acr.FPrint.ind_printattr prohibits copy
    // reftype Ptrary of acr.FPrint.c_pline prohibits copy
    FPrint(const FPrint&){ /*disallow copy constructor */}
    void operator =(const FPrint&){ /*disallow direct assignment */}
};

// Delete all rows reachable through the hash index
void                 ind_printattr_Cascdel(acr::FPrint& print) __attribute__((nothrow));
// Return true if hash is empty
bool                 ind_printattr_EmptyQ(acr::FPrint& print) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
acr::FPrintAttr*     ind_printattr_Find(acr::FPrint& print, const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_printattr_N(const acr::FPrint& print) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_printattr_InsertMaybe(acr::FPrint& print, acr::FPrintAttr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_printattr_Remove(acr::FPrint& print, acr::FPrintAttr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_printattr_Reserve(acr::FPrint& print, int n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_pline_EmptyQ(acr::FPrint& print) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FPline*         c_pline_Find(acr::FPrint& print, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FPline*> c_pline_Getary(acr::FPrint& print) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_pline_Insert(acr::FPrint& print, acr::FPline& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_pline_ScanInsertMaybe(acr::FPrint& print, acr::FPline& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_pline_N(const acr::FPrint& print) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_pline_Remove(acr::FPrint& print, acr::FPline& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_pline_RemoveAll(acr::FPrint& print) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_pline_Reserve(acr::FPrint& print, u32 n) __attribute__((nothrow));

void                 print_c_pline_curs_Reset(print_c_pline_curs &curs, acr::FPrint &parent);
// cursor points to valid item
bool                 print_c_pline_curs_ValidQ(print_c_pline_curs &curs);
// proceed to next item
void                 print_c_pline_curs_Next(print_c_pline_curs &curs);
// item access
acr::FPline&         print_c_pline_curs_Access(print_c_pline_curs &curs);
// Set all fields to initial values.
void                 FPrint_Init(acr::FPrint& print);
void                 FPrint_Uninit(acr::FPrint& print) __attribute__((nothrow));

// --- acr.FPrintAttr
// create: acr.FDb.printattr (Malloc)
// access: acr.FPrint.ind_printattr (Thash)
struct FPrintAttr { // acr.FPrintAttr
    acr::FPrintAttr*    ind_printattr_next;   // hash next
    acr::FPrint*        p_print;              // reference to parent row
    algo::Smallstr100   field;                //   0
    u32                 width;                //   0  Name width
private:
    friend acr::FPrintAttr&     printattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FPrintAttr*     printattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 printattr_Delete(acr::FPrintAttr &row) __attribute__((nothrow));
    FPrintAttr();
    ~FPrintAttr();
    FPrintAttr(const FPrintAttr&){ /*disallow copy constructor */}
    void operator =(const FPrintAttr&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FPrintAttr_Init(acr::FPrintAttr& printattr);
void                 FPrintAttr_Uninit(acr::FPrintAttr& printattr) __attribute__((nothrow));

// --- acr.Queryop
struct Queryop { // acr.Queryop: Operation to perform
    u8   value;   //   0
    inline operator acr_Queryop_value_Enum() const;
    explicit Queryop(u8                             in_value);
    Queryop(acr_Queryop_value_Enum arg);
    Queryop();
};

// Get value of field as enum type
acr_Queryop_value_Enum value_GetEnum(const acr::Queryop& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr::Queryop& parent, acr_Queryop_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr::Queryop& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr::Queryop& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr::Queryop& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr::Queryop& parent, algo::strptr rhs, acr_Queryop_value_Enum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 Queryop_Init(acr::Queryop& parent);
// print string representation of acr::Queryop to string LHS, no header -- cprint:acr.Queryop.String
void                 Queryop_Print(acr::Queryop & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.FQuery
// create: acr.FDb.query (Tpool)
// global access: zs_query (Llist)
struct FQuery { // acr.FQuery
    acr::FQuery*     query_next;      // Pointer to next free element int tpool
    acr::FQuery*     zs_query_next;   // zslist link; -1 means not-in-list
    acr::Queryop     queryop;         // Type of operation to perform
    acr::AttrRegx    query;           // Field name (SQL regex as string)
    acr::AttrRegx*   where_elems;     // pointer to elements
    u32              where_n;         // number of elements in array
    u32              where_max;       // max. capacity of array before realloc
    algo::cstring    new_val;         //   ""  New value, used with rename
    algo_lib::Regx   ssimfile;        //   ""  Acr Regx
    i32              nup;             //   0  Number of levels to go up (transitive closure)
    i32              ndown;           //   0  Number of levels to go down (transitive closure)
    bool             unused;          //   false  Only select records which are not referenced.
    bool             selmeta;         //   false  Only select meta records of matched records
    bool             delrec;          //   false  Delete matching record
    algo::cstring    comment;         //   ""  Debug info
private:
    friend acr::FQuery&         query_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FQuery*         query_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 query_Delete(acr::FQuery &row) __attribute__((nothrow));
    FQuery();
    ~FQuery();
    FQuery(const FQuery&){ /*disallow copy constructor */}
    void operator =(const FQuery&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
acr::AttrRegx&       where_Alloc(acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
acr::AttrRegx&       where_AllocAt(acr::FQuery& query, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<acr::AttrRegx> where_AllocN(acr::FQuery& query, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 where_EmptyQ(acr::FQuery& query) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::AttrRegx*       where_Find(acr::FQuery& query, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<acr::AttrRegx> where_Getary(acr::FQuery& query) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
acr::AttrRegx*       where_Last(acr::FQuery& query) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  where_Max(acr::FQuery& query) __attribute__((nothrow));
// Return number of items in the array
i32                  where_N(const acr::FQuery& query) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 where_Remove(acr::FQuery& query, u32 i) __attribute__((nothrow));
void                 where_RemoveAll(acr::FQuery& query) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 where_RemoveLast(acr::FQuery& query) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 where_Reserve(acr::FQuery& query, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 where_AbsReserve(acr::FQuery& query, int n) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
acr::AttrRegx&       where_qFind(acr::FQuery& query, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
acr::AttrRegx&       where_qLast(acr::FQuery& query) __attribute__((nothrow));
// Return row id of specified element
u64                  where_rowid_Get(acr::FQuery& query, acr::AttrRegx &elem) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 where_XrefMaybe(acr::AttrRegx &row);

// Print back to string
void                 ssimfile_Print(acr::FQuery& query, algo::cstring &out) __attribute__((nothrow));

// Set all fields to initial values.
void                 FQuery_Init(acr::FQuery& query);
// proceed to next item
void                 query_where_curs_Next(query_where_curs &curs);
void                 query_where_curs_Reset(query_where_curs &curs, acr::FQuery &parent);
// cursor points to valid item
bool                 query_where_curs_ValidQ(query_where_curs &curs);
// item access
acr::AttrRegx&       query_where_curs_Access(query_where_curs &curs);
void                 FQuery_Uninit(acr::FQuery& query) __attribute__((nothrow));
// print string representation of acr::FQuery to string LHS, no header -- cprint:acr.FQuery.String
void                 FQuery_Print(acr::FQuery & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.RecSortkey
struct RecSortkey { // acr.RecSortkey: One record
    double          num;     //   0.0  Numeric key (if present)
    algo::cstring   str;     // String key (sort key)
    float           rowid;   //   0.f  row id
    bool operator ==(const acr::RecSortkey &rhs) const;
    bool operator !=(const acr::RecSortkey &rhs) const;
    bool operator <(const acr::RecSortkey &rhs) const;
    bool operator >(const acr::RecSortkey &rhs) const;
    bool operator <=(const acr::RecSortkey &rhs) const;
    bool operator >=(const acr::RecSortkey &rhs) const;
    RecSortkey();
};

u32                  RecSortkey_Hash(u32 prev, const acr::RecSortkey & rhs) __attribute__((nothrow));
bool                 RecSortkey_Lt(acr::RecSortkey & lhs, acr::RecSortkey & rhs) __attribute__((nothrow));
i32                  RecSortkey_Cmp(acr::RecSortkey & lhs, acr::RecSortkey & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 RecSortkey_Init(acr::RecSortkey& parent);
bool                 RecSortkey_Eq(const acr::RecSortkey & lhs,const acr::RecSortkey & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 RecSortkey_Update(acr::RecSortkey &lhs, acr::RecSortkey & rhs) __attribute__((nothrow));
// print string representation of acr::RecSortkey to string LHS, no header -- cprint:acr.RecSortkey.String
void                 RecSortkey_Print(acr::RecSortkey & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.FRec
// create: acr.FDb.rec (Tpool)
// global access: zd_all_selrec (Llist)
// access: acr.Err.rec (Ptr)
// access: acr.FCheck.c_bad_rec (Ptrary)
// access: acr.FCtype.zd_trec (Llist)
// access: acr.FCtype.ind_rec (Thash)
// access: acr.FCtype.zd_selrec (Llist)
// access: acr.FFile.zd_frec (Llist)
// access: acr.FPline.p_rec (Upptr)
// access: acr.FRun.c_rec (Ptrary)
// access: acr.FWrite.c_cmtrec (Ptrary)
// access: acr.FErr.rec (Ptr)
struct FRec { // acr.FRec
    acr::FRec*        zd_trec_next;         // zslist link; -1 means not-in-list
    acr::FRec*        zd_trec_prev;         // previous element
    acr::FRec*        ind_rec_next;         // hash next
    acr::FRec*        zd_selrec_next;       // zslist link; -1 means not-in-list
    acr::FRec*        zd_selrec_prev;       // previous element
    acr::FRec*        rec_next;             // Pointer to next free element int tpool
    acr::FRec*        zd_all_selrec_next;   // zslist link; -1 means not-in-list
    acr::FRec*        zd_all_selrec_prev;   // previous element
    acr::FRec*        zd_frec_next;         // zslist link; -1 means not-in-list
    acr::FRec*        zd_frec_prev;         // previous element
    algo::cstring     pkey;                 // Record key (arbitrary string)
    algo::Tuple       tuple;                // Data item
    bool              del;                  //   false  Delete?
    bool              mod;                  //   false  Record was modified?
    bool              metasel;              //   false  Select for meta-data
    bool              isnew;                //   false  Inserted newly
    i32               seldist;              //   0  Distance to selection. >0 is up, <0 is down
    acr::RecSortkey   sortkey;              // Output sort key
    acr::FPline*      c_pline;              // Optional pline. optional pointer
    acr::FFile*       p_outfile;            // reference to parent row
    acr::FFile*       p_infile;             // reference to parent row
    acr::FCtype*      p_ctype;              // reference to parent row
    i32               lineno;               //   0
private:
    friend acr::FRec&           rec_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FRec*           rec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 rec_Delete(acr::FRec &row) __attribute__((nothrow));
    FRec();
    ~FRec();
    FRec(const FRec&){ /*disallow copy constructor */}
    void operator =(const FRec&){ /*disallow direct assignment */}
};

// Insert row into pointer index. Return final membership status.
bool                 c_pline_InsertMaybe(acr::FRec& rec, acr::FPline& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_pline_Remove(acr::FRec& rec, acr::FPline& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FRec_Init(acr::FRec& rec);
void                 FRec_Uninit(acr::FRec& rec) __attribute__((nothrow));

// --- acr.FRun
// create: acr.FDb.run (Cppstack)
struct FRun { // acr.FRun: Function to read/process query
    acr::FCtype**   c_ctype_elems;   // array of pointers
    u32             c_ctype_n;       // array of pointers
    u32             c_ctype_max;     // capacity of allocated array
    acr::FField**   c_field_elems;   // array of pointers
    u32             c_field_n;       // array of pointers
    u32             c_field_max;     // capacity of allocated array
    acr::FRec**     c_rec_elems;     // array of pointers
    u32             c_rec_n;         // array of pointers
    u32             c_rec_max;       // capacity of allocated array
    acr::FCtype**   c_child_elems;   // array of pointers
    u32             c_child_n;       // array of pointers
    u32             c_child_max;     // capacity of allocated array
    i32             n_regx_match;    //   0  Number of regex matches executed
    i32             n_visit_field;   //   0  Number of fields visited
    i32             n_visit_ctype;   //   0  Number of ctypes visited
    i32             n_mod_rec;       //   0  Number of records modified
    FRun();
    ~FRun();
private:
    // reftype Ptrary of acr.FRun.c_ctype prohibits copy
    // reftype Ptrary of acr.FRun.c_field prohibits copy
    // reftype Ptrary of acr.FRun.c_rec prohibits copy
    // ... and several other reasons
    FRun(const FRun&){ /*disallow copy constructor */}
    void operator =(const FRun&){ /*disallow direct assignment */}
};

// Return true if index is empty
bool                 c_ctype_EmptyQ(acr::FRun& run) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FCtype*         c_ctype_Find(acr::FRun& run, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FCtype*> c_ctype_Getary(acr::FRun& run) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ctype_Insert(acr::FRun& run, acr::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_ctype_ScanInsertMaybe(acr::FRun& run, acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ctype_N(const acr::FRun& run) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ctype_Remove(acr::FRun& run, acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ctype_RemoveAll(acr::FRun& run) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ctype_Reserve(acr::FRun& run, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_field_EmptyQ(acr::FRun& run) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FField*         c_field_Find(acr::FRun& run, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FField*> c_field_Getary(acr::FRun& run) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_field_Insert(acr::FRun& run, acr::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_field_ScanInsertMaybe(acr::FRun& run, acr::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_field_N(const acr::FRun& run) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_field_Remove(acr::FRun& run, acr::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_field_RemoveAll(acr::FRun& run) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_field_Reserve(acr::FRun& run, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_rec_EmptyQ(acr::FRun& run) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FRec*           c_rec_Find(acr::FRun& run, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FRec*> c_rec_Getary(acr::FRun& run) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_rec_Insert(acr::FRun& run, acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_rec_ScanInsertMaybe(acr::FRun& run, acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_rec_N(const acr::FRun& run) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_rec_Remove(acr::FRun& run, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_rec_RemoveAll(acr::FRun& run) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_rec_Reserve(acr::FRun& run, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_child_EmptyQ(acr::FRun& run) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FCtype*         c_child_Find(acr::FRun& run, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FCtype*> c_child_Getary(acr::FRun& run) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_child_Insert(acr::FRun& run, acr::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_child_InsertMaybe(acr::FRun& run, acr::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_child_N(const acr::FRun& run) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_child_Remove(acr::FRun& run, acr::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_child_RemoveAll(acr::FRun& run) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_child_Reserve(acr::FRun& run, u32 n) __attribute__((nothrow));

void                 run_c_ctype_curs_Reset(run_c_ctype_curs &curs, acr::FRun &parent);
// cursor points to valid item
bool                 run_c_ctype_curs_ValidQ(run_c_ctype_curs &curs);
// proceed to next item
void                 run_c_ctype_curs_Next(run_c_ctype_curs &curs);
// item access
acr::FCtype&         run_c_ctype_curs_Access(run_c_ctype_curs &curs);
void                 run_c_field_curs_Reset(run_c_field_curs &curs, acr::FRun &parent);
// cursor points to valid item
bool                 run_c_field_curs_ValidQ(run_c_field_curs &curs);
// proceed to next item
void                 run_c_field_curs_Next(run_c_field_curs &curs);
// item access
acr::FField&         run_c_field_curs_Access(run_c_field_curs &curs);
void                 run_c_rec_curs_Reset(run_c_rec_curs &curs, acr::FRun &parent);
// cursor points to valid item
bool                 run_c_rec_curs_ValidQ(run_c_rec_curs &curs);
// proceed to next item
void                 run_c_rec_curs_Next(run_c_rec_curs &curs);
// item access
acr::FRec&           run_c_rec_curs_Access(run_c_rec_curs &curs);
void                 run_c_child_curs_Reset(run_c_child_curs &curs, acr::FRun &parent);
// cursor points to valid item
bool                 run_c_child_curs_ValidQ(run_c_child_curs &curs);
// proceed to next item
void                 run_c_child_curs_Next(run_c_child_curs &curs);
// item access
acr::FCtype&         run_c_child_curs_Access(run_c_child_curs &curs);
// Set all fields to initial values.
void                 FRun_Init(acr::FRun& run);
void                 FRun_Uninit(acr::FRun& run) __attribute__((nothrow));
// print string representation of acr::FRun to string LHS, no header -- cprint:acr.FRun.String
void                 FRun_Print(acr::FRun & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.FSmallstr
// create: acr.FDb.smallstr (Lary)
struct FSmallstr { // acr.FSmallstr
    algo::Smallstr100   field;     //
    i32                 length;    //   0  Maximum characters in the string
    algo::Smallstr50    strtype;   // Data format for string
    dmmeta::CppExpr     pad;       // Pad character (if applicable)
    bool                strict;    //   false
private:
    friend acr::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 smallstr_RemoveLast() __attribute__((nothrow));
    FSmallstr();
};

// Copy fields out of row
void                 smallstr_CopyOut(acr::FSmallstr &row, dmmeta::Smallstr &out) __attribute__((nothrow));
// Copy fields in to row
void                 smallstr_CopyIn(acr::FSmallstr &row, dmmeta::Smallstr &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(acr::FSmallstr& smallstr) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FSmallstr_Init(acr::FSmallstr& smallstr);

// --- acr.FSsimfile
// create: acr.FDb.ssimfile (Lary)
// global access: ind_ssimfile (Thash)
// access: acr.FCtype.c_ssimfile (Ptr)
// access: acr.FSsimreq.p_ssimfile (Upptr)
struct FSsimfile { // acr.FSsimfile: One full table
    acr::FSsimfile*    ind_ssimfile_next;   // hash next
    algo::Smallstr50   ssimfile;            //
    algo::Smallstr50   ctype;               //
    acr::FFile*        c_file;              // optional!. optional pointer
    acr::FCtype*       p_ctype;             // reference to parent row
    acr::FSsimsort*    c_ssimsort;          // Optional sort order. optional pointer
    acr::FSsimreq*     c_ssimreq;           // optional pointer
private:
    friend acr::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
    FSsimfile();
    ~FSsimfile();
    FSsimfile(const FSsimfile&){ /*disallow copy constructor */}
    void operator =(const FSsimfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimfile_CopyOut(acr::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimfile_CopyIn(acr::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

algo::Smallstr16     ssimns_Get(acr::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(acr::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(acr::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ssimsort_InsertMaybe(acr::FSsimfile& ssimfile, acr::FSsimsort& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ssimsort_Remove(acr::FSsimfile& ssimfile, acr::FSsimsort& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ssimreq_InsertMaybe(acr::FSsimfile& ssimfile, acr::FSsimreq& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ssimreq_Remove(acr::FSsimfile& ssimfile, acr::FSsimreq& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSsimfile_Init(acr::FSsimfile& ssimfile);
void                 FSsimfile_Uninit(acr::FSsimfile& ssimfile) __attribute__((nothrow));

// --- acr.FSsimreq
// create: acr.FDb.ssimreq (Lary)
// access: acr.FSsimfile.c_ssimreq (Ptr)
struct FSsimreq { // acr.FSsimreq
    algo::Smallstr50    ssimfile;     // Ssimfile with constraint
    algo::Smallstr100   field;        // Field (must belong to pkey superset)
    algo::Smallstr100   value;        // Required value
    bool                bidir;        //   false  Constraint is bidirectional
    algo::Comment       comment;      //
    acr::FSsimfile*     p_ssimfile;   // reference to parent row
    acr::FField*        p_field;      // reference to parent row
private:
    friend acr::FSsimreq&       ssimreq_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSsimreq*       ssimreq_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimreq_RemoveAll() __attribute__((nothrow));
    friend void                 ssimreq_RemoveLast() __attribute__((nothrow));
    FSsimreq();
    ~FSsimreq();
    FSsimreq(const FSsimreq&){ /*disallow copy constructor */}
    void operator =(const FSsimreq&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimreq_CopyOut(acr::FSsimreq &row, dmmeta::Ssimreq &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimreq_CopyIn(acr::FSsimreq &row, dmmeta::Ssimreq &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSsimreq_Init(acr::FSsimreq& ssimreq);
void                 FSsimreq_Uninit(acr::FSsimreq& ssimreq) __attribute__((nothrow));

// --- acr.FSsimsort
// create: acr.FDb.ssimsort (Lary)
// global access: ind_ssimsort (Thash)
// access: acr.FSsimfile.c_ssimsort (Ptr)
struct FSsimsort { // acr.FSsimsort
    acr::FSsimsort*     ind_ssimsort_next;   // hash next
    algo::Smallstr50    ssimfile;            //
    algo::Smallstr100   sortfld;             //
private:
    friend acr::FSsimsort&      ssimsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSsimsort*      ssimsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimsort_RemoveLast() __attribute__((nothrow));
    FSsimsort();
    ~FSsimsort();
    FSsimsort(const FSsimsort&){ /*disallow copy constructor */}
    void operator =(const FSsimsort&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimsort_CopyOut(acr::FSsimsort &row, dmmeta::Ssimsort &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimsort_CopyIn(acr::FSsimsort &row, dmmeta::Ssimsort &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSsimsort_Init(acr::FSsimsort& ssimsort);
void                 FSsimsort_Uninit(acr::FSsimsort& ssimsort) __attribute__((nothrow));

// --- acr.FSubstr
// create: acr.FDb.substr (Lary)
// access: acr.FField.c_substr (Ptr)
struct FSubstr { // acr.FSubstr
    algo::Smallstr100   field;      //
    dmmeta::CppExpr     expr;       //
    algo::Smallstr100   srcfield;   //
private:
    friend acr::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 substr_RemoveLast() __attribute__((nothrow));
    FSubstr();
    ~FSubstr();
    FSubstr(const FSubstr&){ /*disallow copy constructor */}
    void operator =(const FSubstr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 substr_CopyOut(acr::FSubstr &row, dmmeta::Substr &out) __attribute__((nothrow));
// Copy fields in to row
void                 substr_CopyIn(acr::FSubstr &row, dmmeta::Substr &in) __attribute__((nothrow));

void                 FSubstr_Uninit(acr::FSubstr& substr) __attribute__((nothrow));

// --- acr.FTempkey
// create: acr.FDb.tempkey (Lary)
// global access: ind_tempkey (Thash)
struct FTempkey { // acr.FTempkey
    acr::FTempkey*   ind_tempkey_next;   // hash next
    algo::cstring    tempkey;            //
private:
    friend acr::FTempkey&       tempkey_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FTempkey*       tempkey_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tempkey_RemoveAll() __attribute__((nothrow));
    friend void                 tempkey_RemoveLast() __attribute__((nothrow));
    FTempkey();
    ~FTempkey();
    FTempkey(const FTempkey&){ /*disallow copy constructor */}
    void operator =(const FTempkey&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FTempkey_Init(acr::FTempkey& tempkey);
void                 FTempkey_Uninit(acr::FTempkey& tempkey) __attribute__((nothrow));

// --- acr.FUniqueattr
// create: acr.FDb.uniqueattr (Tpool)
// global access: ind_uniqueattr (Thash)
struct FUniqueattr { // acr.FUniqueattr
    acr::FUniqueattr*   uniqueattr_next;       // Pointer to next free element int tpool
    acr::FUniqueattr*   ind_uniqueattr_next;   // hash next
    algo::cstring       uniqueattr;            // Data
private:
    friend acr::FUniqueattr&    uniqueattr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend acr::FUniqueattr*    uniqueattr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 uniqueattr_Delete(acr::FUniqueattr &row) __attribute__((nothrow));
    FUniqueattr();
    ~FUniqueattr();
    FUniqueattr(const FUniqueattr&){ /*disallow copy constructor */}
    void operator =(const FUniqueattr&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FUniqueattr_Init(acr::FUniqueattr& uniqueattr);
void                 FUniqueattr_Uninit(acr::FUniqueattr& uniqueattr) __attribute__((nothrow));

// --- acr.FWrite
// create: acr.FDb.write (Cppstack)
struct FWrite { // acr.FWrite: Print function
    acr::FRec**   c_cmtrec_elems;   // array of pointers
    u32           c_cmtrec_n;       // array of pointers
    u32           c_cmtrec_max;     // capacity of allocated array
    FWrite();
    ~FWrite();
private:
    // reftype Ptrary of acr.FWrite.c_cmtrec prohibits copy
    FWrite(const FWrite&){ /*disallow copy constructor */}
    void operator =(const FWrite&){ /*disallow direct assignment */}
};

// Return true if index is empty
bool                 c_cmtrec_EmptyQ(acr::FWrite& write) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
acr::FRec*           c_cmtrec_Find(acr::FWrite& write, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<acr::FRec*> c_cmtrec_Getary(acr::FWrite& write) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_cmtrec_Insert(acr::FWrite& write, acr::FRec& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_cmtrec_ScanInsertMaybe(acr::FWrite& write, acr::FRec& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_cmtrec_N(const acr::FWrite& write) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_cmtrec_Remove(acr::FWrite& write, acr::FRec& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_cmtrec_RemoveAll(acr::FWrite& write) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_cmtrec_Reserve(acr::FWrite& write, u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_cmtrec_SortedQ(acr::FWrite& write) __attribute__((nothrow));
// Insertion sort
void                 c_cmtrec_InsertionSort(acr::FWrite& write) __attribute__((nothrow));
// Heap sort
void                 c_cmtrec_HeapSort(acr::FWrite& write) __attribute__((nothrow));
// Quick sort
void                 c_cmtrec_QuickSort(acr::FWrite& write) __attribute__((nothrow));

void                 write_c_cmtrec_curs_Reset(write_c_cmtrec_curs &curs, acr::FWrite &parent);
// cursor points to valid item
bool                 write_c_cmtrec_curs_ValidQ(write_c_cmtrec_curs &curs);
// proceed to next item
void                 write_c_cmtrec_curs_Next(write_c_cmtrec_curs &curs);
// item access
acr::FRec&           write_c_cmtrec_curs_Access(write_c_cmtrec_curs &curs);
// Set all fields to initial values.
void                 FWrite_Init(acr::FWrite& write);
void                 FWrite_Uninit(acr::FWrite& write) __attribute__((nothrow));

// --- acr.FieldId
#pragma pack(push,1)
struct FieldId { // acr.FieldId: Field read helper
    i32   value;   //   -1
    inline operator acr_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(acr_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
acr_FieldIdEnum      value_GetEnum(const acr::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr::FieldId& parent, acr_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr::FieldId& parent, algo::strptr rhs, acr_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(acr::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr::FieldId from an ascii string.
// The format of the string is the format of the acr::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(acr::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(acr::FieldId& parent);
// print string representation of acr::FieldId to string LHS, no header -- cprint:acr.FieldId.String
void                 FieldId_Print(acr::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- acr.TableId
struct TableId { // acr.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator acr_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(acr_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
acr_TableIdEnum      value_GetEnum(const acr::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(acr::TableId& parent, acr_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const acr::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const acr::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(acr::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(acr::TableId& parent, algo::strptr rhs, acr_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(acr::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of acr::TableId from an ascii string.
// The format of the string is the format of the acr::TableId's only field
bool                 TableId_ReadStrptrMaybe(acr::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(acr::TableId& parent);
// print string representation of acr::TableId to string LHS, no header -- cprint:acr.TableId.String
void                 TableId_Print(acr::TableId & row, algo::cstring &str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace acr { // gen:ns_curstext

struct check_c_bad_rec_curs {// fcurs:acr.FCheck.c_bad_rec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    check_c_bad_rec_curs() { elems=NULL; n_elems=0; index=0; }
};


struct check_ary_name_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    check_ary_name_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_field_curs {// fcurs:acr.FCtype.c_field/curs
    typedef acr::FField ChildType;
    acr::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_trec_curs {// fcurs:acr.FCtype.zd_trec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    ctype_zd_trec_curs() {
        row = NULL;
    }
};


struct ctype_ind_rec_curs {// cursor
    typedef acr::FRec ChildType;
    acr::FCtype *parent;
    int bucket;
    acr::FRec **prow;
    ctype_ind_rec_curs() { parent=NULL; bucket=0; prow=NULL; }
};


struct ctype_zd_selrec_curs {// fcurs:acr.FCtype.zd_selrec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    ctype_zd_selrec_curs() {
        row = NULL;
    }
};


struct ctype_c_child_curs {// fcurs:acr.FCtype.c_child/curs
    typedef acr::FCtype ChildType;
    acr::FCtype** elems;
    u32 n_elems;
    u32 index;
    ctype_c_child_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_arg_curs {// fcurs:acr.FCtype.zd_arg/curs
    typedef acr::FField ChildType;
    acr::FField* row;
    ctype_zd_arg_curs() {
        row = NULL;
    }
};


struct _db_zd_pline_curs {// fcurs:acr.FDb.zd_pline/curs
    typedef acr::FPline ChildType;
    acr::FPline* row;
    _db_zd_pline_curs() {
        row = NULL;
    }
};


struct _db_zd_pdep_curs {// fcurs:acr.FDb.zd_pdep/curs
    typedef acr::FPdep ChildType;
    acr::FPdep* row;
    _db_zd_pdep_curs() {
        row = NULL;
    }
};


struct _db_ctype_curs {// cursor
    typedef acr::FCtype ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_anonfld_curs {// cursor
    typedef acr::FAnonfld ChildType;
    acr::FDb *parent;
    i64 index;
    _db_anonfld_curs(){ parent=NULL; index=0; }
};


struct _db_cdflt_curs {// cursor
    typedef acr::FCdflt ChildType;
    acr::FDb *parent;
    i64 index;
    _db_cdflt_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef acr::FField ChildType;
    acr::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_file_curs {// cursor
    typedef acr::FFile ChildType;
    acr::FDb *parent;
    i64 index;
    _db_file_curs(){ parent=NULL; index=0; }
};


struct _db_zd_all_selrec_curs {// fcurs:acr.FDb.zd_all_selrec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    _db_zd_all_selrec_curs() {
        row = NULL;
    }
};


struct _db_zd_all_err_curs {// fcurs:acr.FDb.zd_all_err/curs
    typedef acr::FErr ChildType;
    acr::FErr* row;
    _db_zd_all_err_curs() {
        row = NULL;
    }
};


struct _db_zd_sel_ctype_curs {// fcurs:acr.FDb.zd_sel_ctype/curs
    typedef acr::FCtype ChildType;
    acr::FCtype* row;
    _db_zd_sel_ctype_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_pline_curs {
    typedef acr::FPline ChildType;
    acr::FDb      *parent;        // parent
    acr::FPline*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_pline_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_pline_curs();
};


struct _db_substr_curs {// cursor
    typedef acr::FSubstr ChildType;
    acr::FDb *parent;
    i64 index;
    _db_substr_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef acr::FSsimfile ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_tempkey_curs {// cursor
    typedef acr::FTempkey ChildType;
    acr::FDb *parent;
    i64 index;
    _db_tempkey_curs(){ parent=NULL; index=0; }
};


struct _db_zs_query_curs {// fcurs:acr.FDb.zs_query/curs
    typedef acr::FQuery ChildType;
    acr::FQuery* row;
    _db_zs_query_curs() {
        row = NULL;
    }
};


struct _db_ssimsort_curs {// cursor
    typedef acr::FSsimsort ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ssimsort_curs(){ parent=NULL; index=0; }
};


struct _db_smallstr_curs {// cursor
    typedef acr::FSmallstr ChildType;
    acr::FDb *parent;
    i64 index;
    _db_smallstr_curs(){ parent=NULL; index=0; }
};


struct _db_funique_curs {// cursor
    typedef acr::FFunique ChildType;
    acr::FDb *parent;
    i64 index;
    _db_funique_curs(){ parent=NULL; index=0; }
};


struct _db_bltin_curs {// cursor
    typedef acr::FBltin ChildType;
    acr::FDb *parent;
    i64 index;
    _db_bltin_curs(){ parent=NULL; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_ctype_topo_curs {
    typedef acr::FCtype ChildType;
    acr::FDb      *parent;        // parent
    acr::FCtype*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_ctype_topo_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_ctype_topo_curs();
};


struct _db_cppfunc_curs {// cursor
    typedef acr::FCppfunc ChildType;
    acr::FDb *parent;
    i64 index;
    _db_cppfunc_curs(){ parent=NULL; index=0; }
};


struct _db_ssimreq_curs {// cursor
    typedef acr::FSsimreq ChildType;
    acr::FDb *parent;
    i64 index;
    _db_ssimreq_curs(){ parent=NULL; index=0; }
};


struct file_zd_frec_curs {// fcurs:acr.FFile.zd_frec/curs
    typedef acr::FRec ChildType;
    acr::FRec* row;
    file_zd_frec_curs() {
        row = NULL;
    }
};


struct pline_zd_child_curs {// fcurs:acr.FPline.zd_child/curs
    typedef acr::FPdep ChildType;
    acr::FPdep* row;
    pline_zd_child_curs() {
        row = NULL;
    }
};


struct print_c_pline_curs {// fcurs:acr.FPrint.c_pline/curs
    typedef acr::FPline ChildType;
    acr::FPline** elems;
    u32 n_elems;
    u32 index;
    print_c_pline_curs() { elems=NULL; n_elems=0; index=0; }
};


struct query_where_curs {// cursor
    typedef acr::AttrRegx ChildType;
    acr::AttrRegx* elems;
    int n_elems;
    int index;
    query_where_curs() { elems=NULL; n_elems=0; index=0; }
};


struct run_c_ctype_curs {// fcurs:acr.FRun.c_ctype/curs
    typedef acr::FCtype ChildType;
    acr::FCtype** elems;
    u32 n_elems;
    u32 index;
    run_c_ctype_curs() { elems=NULL; n_elems=0; index=0; }
};


struct run_c_field_curs {// fcurs:acr.FRun.c_field/curs
    typedef acr::FField ChildType;
    acr::FField** elems;
    u32 n_elems;
    u32 index;
    run_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct run_c_rec_curs {// fcurs:acr.FRun.c_rec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    run_c_rec_curs() { elems=NULL; n_elems=0; index=0; }
};


struct run_c_child_curs {// fcurs:acr.FRun.c_child/curs
    typedef acr::FCtype ChildType;
    acr::FCtype** elems;
    u32 n_elems;
    u32 index;
    run_c_child_curs() { elems=NULL; n_elems=0; index=0; }
};


struct write_c_cmtrec_curs {// fcurs:acr.FWrite.c_cmtrec/curs
    typedef acr::FRec ChildType;
    acr::FRec** elems;
    u32 n_elems;
    u32 index;
    write_c_cmtrec_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace acr { // gen:ns_func
} // gen:ns_func
int                  main(int argc, char **argv);
#if defined(WIN32)
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const acr::CtypeTopoKey &row);// cfmt:acr.CtypeTopoKey.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::trace &row);// cfmt:acr.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::PlineKey &row);// cfmt:acr.PlineKey.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::Queryop &row);// cfmt:acr.Queryop.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::FQuery &row);// cfmt:acr.FQuery.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::FRun &row);// cfmt:acr.FRun.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::FieldId &row);// cfmt:acr.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const acr::TableId &row);// cfmt:acr.TableId.String
}
