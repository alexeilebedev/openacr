//
// include/gen/abt_md_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/atfdb_gen.inl.h"
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/amcdb_gen.inl.h"
//#pragma endinclude
static abt_md::FMdsection &abt_md_mdsection_Title           = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[0];
static abt_md::FMdsection &abt_md_mdsection_Chapters        = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[1];
static abt_md::FMdsection &abt_md_mdsection_Toc             = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[2];
static abt_md::FMdsection &abt_md_mdsection_Reftypes        = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[3];
static abt_md::FMdsection &abt_md_mdsection_Syntax          = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[4];
static abt_md::FMdsection &abt_md_mdsection_Description     = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[5];
static abt_md::FMdsection &abt_md_mdsection_Limitations     = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[6];
static abt_md::FMdsection &abt_md_mdsection_Content         = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[7];
static abt_md::FMdsection &abt_md_mdsection_Example         = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[8];
static abt_md::FMdsection &abt_md_mdsection_Attributes      = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[9];
static abt_md::FMdsection &abt_md_mdsection_Ctypes          = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[10];
static abt_md::FMdsection &abt_md_mdsection_Functions       = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[11];
static abt_md::FMdsection &abt_md_mdsection_Tables          = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[12];
static abt_md::FMdsection &abt_md_mdsection_Subsets         = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[13];
static abt_md::FMdsection &abt_md_mdsection_Related         = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[14];
static abt_md::FMdsection &abt_md_mdsection_Constants       = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[15];
static abt_md::FMdsection &abt_md_mdsection_CmdlineUses     = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[16];
static abt_md::FMdsection &abt_md_mdsection_Options         = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[17];
static abt_md::FMdsection &abt_md_mdsection_Inputs          = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[18];
static abt_md::FMdsection &abt_md_mdsection_InputMessages   = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[19];
static abt_md::FMdsection &abt_md_mdsection_Sources         = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[20];
static abt_md::FMdsection &abt_md_mdsection_Dependencies    = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[21];
static abt_md::FMdsection &abt_md_mdsection_Imdb            = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[22];
static abt_md::FMdsection &abt_md_mdsection_ImdbUses        = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[23];
static abt_md::FMdsection &abt_md_mdsection_Tests           = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[24];
static abt_md::FMdsection &abt_md_mdsection_Copyright       = ((abt_md::FMdsection*)abt_md::_db.mdsection_data)[25];

// --- abt_md.FAnchor..Init
// Set all fields to initial values.
inline void abt_md::FAnchor_Init(abt_md::FAnchor& anchor) {
    anchor.ind_anchor_next = (abt_md::FAnchor*)-1; // (abt_md.FDb.ind_anchor) not-in-hash
    anchor.ind_anchor_hashval = 0; // stored hash value
}

// --- abt_md.FAnchor..Ctor
inline  abt_md::FAnchor::FAnchor() {
    abt_md::FAnchor_Init(*this);
}

// --- abt_md.FAnchor..Dtor
inline  abt_md::FAnchor::~FAnchor() {
    abt_md::FAnchor_Uninit(*this);
}

// --- abt_md.FComptest..Ctor
inline  abt_md::FComptest::FComptest() {
    abt_md::FComptest_Init(*this);
}

// --- abt_md.FComptest..Dtor
inline  abt_md::FComptest::~FComptest() {
    abt_md::FComptest_Uninit(*this);
}

// --- abt_md.FCtype.c_ssimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool abt_md::c_ssimfile_InsertMaybe(abt_md::FCtype& ctype, abt_md::FSsimfile& row) {
    abt_md::FSsimfile* ptr = ctype.c_ssimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ssimfile = &row;
    }
    return retval;
}

// --- abt_md.FCtype.c_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void abt_md::c_ssimfile_Remove(abt_md::FCtype& ctype, abt_md::FSsimfile& row) {
    abt_md::FSsimfile *ptr = ctype.c_ssimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_ssimfile = NULL;
    }
}

// --- abt_md.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool abt_md::c_field_EmptyQ(abt_md::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- abt_md.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FField* abt_md::c_field_Find(abt_md::FCtype& ctype, u32 t) {
    abt_md::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- abt_md.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FField*> abt_md::c_field_Getary(abt_md::FCtype& ctype) {
    return algo::aryptr<abt_md::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- abt_md.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 abt_md::c_field_N(const abt_md::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- abt_md.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_field_RemoveAll(abt_md::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_elems[i]->ctype_c_field_in_ary = false;
    }
    ctype.c_field_n = 0;
}

// --- abt_md.FCtype.c_field.qFind
// Return reference without bounds checking
inline abt_md::FField& abt_md::c_field_qFind(abt_md::FCtype& ctype, u32 idx) {
    return *ctype.c_field_elems[idx];
}

// --- abt_md.FCtype.c_field.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::ctype_c_field_InAryQ(abt_md::FField& row) {
    return row.ctype_c_field_in_ary;
}

// --- abt_md.FCtype.c_field.qLast
// Reference to last element without bounds checking
inline abt_md::FField& abt_md::c_field_qLast(abt_md::FCtype& ctype) {
    return *ctype.c_field_elems[ctype.c_field_n-1];
}

// --- abt_md.FCtype.c_field_arg.EmptyQ
// Return true if index is empty
inline bool abt_md::c_field_arg_EmptyQ(abt_md::FCtype& ctype) {
    return ctype.c_field_arg_n == 0;
}

// --- abt_md.FCtype.c_field_arg.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FField* abt_md::c_field_arg_Find(abt_md::FCtype& ctype, u32 t) {
    abt_md::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_arg_n;
    if (idx < lim) {
        retval = ctype.c_field_arg_elems[idx];
    }
    return retval;
}

// --- abt_md.FCtype.c_field_arg.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FField*> abt_md::c_field_arg_Getary(abt_md::FCtype& ctype) {
    return algo::aryptr<abt_md::FField*>(ctype.c_field_arg_elems, ctype.c_field_arg_n);
}

// --- abt_md.FCtype.c_field_arg.N
// Return number of items in the pointer array
inline i32 abt_md::c_field_arg_N(const abt_md::FCtype& ctype) {
    return ctype.c_field_arg_n;
}

// --- abt_md.FCtype.c_field_arg.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_field_arg_RemoveAll(abt_md::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_arg_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_arg_elems[i]->ctype_c_field_arg_in_ary = false;
    }
    ctype.c_field_arg_n = 0;
}

// --- abt_md.FCtype.c_field_arg.qFind
// Return reference without bounds checking
inline abt_md::FField& abt_md::c_field_arg_qFind(abt_md::FCtype& ctype, u32 idx) {
    return *ctype.c_field_arg_elems[idx];
}

// --- abt_md.FCtype.c_field_arg.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::ctype_c_field_arg_InAryQ(abt_md::FField& row) {
    return row.ctype_c_field_arg_in_ary;
}

// --- abt_md.FCtype.c_field_arg.qLast
// Reference to last element without bounds checking
inline abt_md::FField& abt_md::c_field_arg_qLast(abt_md::FCtype& ctype) {
    return *ctype.c_field_arg_elems[ctype.c_field_arg_n-1];
}

// --- abt_md.FCtype.c_field_curs.Reset
inline void abt_md::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, abt_md::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- abt_md.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FCtype.c_field_curs.Next
// proceed to next item
inline void abt_md::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- abt_md.FCtype.c_field_curs.Access
// item access
inline abt_md::FField& abt_md::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FCtype.c_field_arg_curs.Reset
inline void abt_md::ctype_c_field_arg_curs_Reset(ctype_c_field_arg_curs &curs, abt_md::FCtype &parent) {
    curs.elems = parent.c_field_arg_elems;
    curs.n_elems = parent.c_field_arg_n;
    curs.index = 0;
}

// --- abt_md.FCtype.c_field_arg_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ctype_c_field_arg_curs_ValidQ(ctype_c_field_arg_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FCtype.c_field_arg_curs.Next
// proceed to next item
inline void abt_md::ctype_c_field_arg_curs_Next(ctype_c_field_arg_curs &curs) {
    curs.index++;
}

// --- abt_md.FCtype.c_field_arg_curs.Access
// item access
inline abt_md::FField& abt_md::ctype_c_field_arg_curs_Access(ctype_c_field_arg_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FCtype..Init
// Set all fields to initial values.
inline void abt_md::FCtype_Init(abt_md::FCtype& ctype) {
    ctype.c_ssimfile = NULL;
    ctype.c_field_elems = NULL; // (abt_md.FCtype.c_field)
    ctype.c_field_n = 0; // (abt_md.FCtype.c_field)
    ctype.c_field_max = 0; // (abt_md.FCtype.c_field)
    ctype.p_ns = NULL;
    ctype.c_field_arg_elems = NULL; // (abt_md.FCtype.c_field_arg)
    ctype.c_field_arg_n = 0; // (abt_md.FCtype.c_field_arg)
    ctype.c_field_arg_max = 0; // (abt_md.FCtype.c_field_arg)
    ctype.ns_c_ctype_in_ary = bool(false);
    ctype.ind_ctype_next = (abt_md::FCtype*)-1; // (abt_md.FDb.ind_ctype) not-in-hash
    ctype.ind_ctype_hashval = 0; // stored hash value
}

// --- abt_md.FCtype..Ctor
inline  abt_md::FCtype::FCtype() {
    abt_md::FCtype_Init(*this);
}

// --- abt_md.FCtype..Dtor
inline  abt_md::FCtype::~FCtype() {
    abt_md::FCtype_Uninit(*this);
}

// --- abt_md.FMdsection.step.Call
// Invoke function by pointer
inline void abt_md::step_Call(abt_md::FMdsection& mdsection, abt_md::FFileSection& arg) {
    mdsection.step(arg);
}

// --- abt_md.FMdsection.zd_file_section.EmptyQ
// Return true if index is empty
inline bool abt_md::zd_file_section_EmptyQ(abt_md::FMdsection& mdsection) {
    return mdsection.zd_file_section_head == NULL;
}

// --- abt_md.FMdsection.zd_file_section.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt_md::FFileSection* abt_md::zd_file_section_First(abt_md::FMdsection& mdsection) {
    abt_md::FFileSection *row = NULL;
    row = mdsection.zd_file_section_head;
    return row;
}

// --- abt_md.FMdsection.zd_file_section.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt_md::mdsection_zd_file_section_InLlistQ(abt_md::FFileSection& row) {
    bool result = false;
    result = !(row.mdsection_zd_file_section_next == (abt_md::FFileSection*)-1);
    return result;
}

// --- abt_md.FMdsection.zd_file_section.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt_md::FFileSection* abt_md::zd_file_section_Last(abt_md::FMdsection& mdsection) {
    abt_md::FFileSection *row = NULL;
    row = mdsection.zd_file_section_tail;
    return row;
}

// --- abt_md.FMdsection.zd_file_section.N
// Return number of items in the linked list
inline i32 abt_md::zd_file_section_N(const abt_md::FMdsection& mdsection) {
    return mdsection.zd_file_section_n;
}

// --- abt_md.FMdsection.zd_file_section.Next
// Return pointer to next element in the list
inline abt_md::FFileSection* abt_md::mdsection_zd_file_section_Next(abt_md::FFileSection &row) {
    return row.mdsection_zd_file_section_next;
}

// --- abt_md.FMdsection.zd_file_section.Prev
// Return pointer to previous element in the list
inline abt_md::FFileSection* abt_md::mdsection_zd_file_section_Prev(abt_md::FFileSection &row) {
    return row.mdsection_zd_file_section_prev;
}

// --- abt_md.FMdsection.zd_file_section.qLast
// Return reference to last element in the index. No bounds checking.
inline abt_md::FFileSection& abt_md::zd_file_section_qLast(abt_md::FMdsection& mdsection) {
    abt_md::FFileSection *row = NULL;
    row = mdsection.zd_file_section_tail;
    return *row;
}

// --- abt_md.FMdsection.zd_file_section_curs.Reset
// cursor points to valid item
inline void abt_md::mdsection_zd_file_section_curs_Reset(mdsection_zd_file_section_curs &curs, abt_md::FMdsection &parent) {
    curs.row = parent.zd_file_section_head;
}

// --- abt_md.FMdsection.zd_file_section_curs.ValidQ
// cursor points to valid item
inline bool abt_md::mdsection_zd_file_section_curs_ValidQ(mdsection_zd_file_section_curs &curs) {
    return curs.row != NULL;
}

// --- abt_md.FMdsection.zd_file_section_curs.Next
// proceed to next item
inline void abt_md::mdsection_zd_file_section_curs_Next(mdsection_zd_file_section_curs &curs) {
    abt_md::FFileSection *next = (*curs.row).mdsection_zd_file_section_next;
    curs.row = next;
}

// --- abt_md.FMdsection.zd_file_section_curs.Access
// item access
inline abt_md::FFileSection& abt_md::mdsection_zd_file_section_curs_Access(mdsection_zd_file_section_curs &curs) {
    return *curs.row;
}

// --- abt_md.FMdsection..Ctor
inline  abt_md::FMdsection::FMdsection() {
    abt_md::FMdsection_Init(*this);
}

// --- abt_md.trace..Ctor
inline  abt_md::trace::trace() {
}

// --- abt_md.FDb.readmefile.EmptyQ
// Return true if index is empty
inline bool abt_md::readmefile_EmptyQ() {
    return _db.readmefile_n == 0;
}

// --- abt_md.FDb.readmefile.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FReadmefile* abt_md::readmefile_Find(u64 t) {
    abt_md::FReadmefile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.readmefile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.readmefile_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.readmefile.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FReadmefile* abt_md::readmefile_Last() {
    return readmefile_Find(u64(_db.readmefile_n-1));
}

// --- abt_md.FDb.readmefile.N
// Return number of items in the pool
inline i32 abt_md::readmefile_N() {
    return _db.readmefile_n;
}

// --- abt_md.FDb.readmefile.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FReadmefile& abt_md::readmefile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.readmefile_lary[bsr][index];
}

// --- abt_md.FDb.ind_readmefile.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_readmefile_EmptyQ() {
    return _db.ind_readmefile_n == 0;
}

// --- abt_md.FDb.ind_readmefile.N
// Return number of items in the hash
inline i32 abt_md::ind_readmefile_N() {
    return _db.ind_readmefile_n;
}

// --- abt_md.FDb.mdsection.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* abt_md::mdsection_AllocMem() {
    void *row = reinterpret_cast<abt_md::FMdsection*>(_db.mdsection_data) + _db.mdsection_n;
    if (_db.mdsection_n == 26) row = NULL;
    if (row) _db.mdsection_n++;
    return row;
}

// --- abt_md.FDb.mdsection.EmptyQ
// Return true if index is empty
inline bool abt_md::mdsection_EmptyQ() {
    return _db.mdsection_n == 0;
}

// --- abt_md.FDb.mdsection.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FMdsection* abt_md::mdsection_Find(i32 t) {
    u64 idx = t;
    u64 lim = _db.mdsection_n;
    return idx < lim ? reinterpret_cast<abt_md::FMdsection*>(_db.mdsection_data) + idx : NULL; // unsigned comparison with limit
}

// --- abt_md.FDb.mdsection.Getary
// Return array pointer by value
inline algo::aryptr<abt_md::FMdsection> abt_md::mdsection_Getary() {
    return algo::aryptr<abt_md::FMdsection>(reinterpret_cast<abt_md::FMdsection*>(_db.mdsection_data), _db.mdsection_n);
}

// --- abt_md.FDb.mdsection.Max
// Return constant 26 -- max. number of items in the pool
inline i32 abt_md::mdsection_Max() {
    return 26;
}

// --- abt_md.FDb.mdsection.N
// Return number of items in the array
inline i32 abt_md::mdsection_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return _db.mdsection_n;
}

// --- abt_md.FDb.mdsection.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline abt_md::FMdsection& abt_md::mdsection_qFind(i32 t) {
    return reinterpret_cast<abt_md::FMdsection*>(_db.mdsection_data)[u64(t)];
}

// --- abt_md.FDb.mdsection.rowid_Get
// Compute row id of element given element's address
inline i32 abt_md::mdsection_rowid_Get(abt_md::FMdsection &row) {
    u64 ret = u64(&row - reinterpret_cast<abt_md::FMdsection*>(_db.mdsection_data));
    return i32(ret);
}

// --- abt_md.FDb.file_section.EmptyQ
// Return true if index is empty
inline bool abt_md::file_section_EmptyQ() {
    return _db.file_section_n == 0;
}

// --- abt_md.FDb.file_section.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FFileSection* abt_md::file_section_Find(u64 t) {
    abt_md::FFileSection *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.file_section_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.file_section_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.file_section.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FFileSection* abt_md::file_section_Last() {
    return file_section_Find(u64(_db.file_section_n-1));
}

// --- abt_md.FDb.file_section.N
// Return number of items in the pool
inline i32 abt_md::file_section_N() {
    return _db.file_section_n;
}

// --- abt_md.FDb.file_section.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FFileSection& abt_md::file_section_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.file_section_lary[bsr][index];
}

// --- abt_md.FDb.bh_file_section.EmptyQ
// Return true if index is empty
inline bool abt_md::bh_file_section_EmptyQ() {
    return _db.bh_file_section_n == 0;
}

// --- abt_md.FDb.bh_file_section.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt_md::FFileSection* abt_md::bh_file_section_First() {
    abt_md::FFileSection *row = NULL;
    if (_db.bh_file_section_n > 0) {
        row = _db.bh_file_section_elems[0];
    }
    return row;
}

// --- abt_md.FDb.bh_file_section.InBheapQ
// Return true if row is in index, false otherwise
inline bool abt_md::bh_file_section_InBheapQ(abt_md::FFileSection& row) {
    bool result = false;
    result = row.bh_file_section_idx != -1;
    return result;
}

// --- abt_md.FDb.bh_file_section.N
// Return number of items in the heap
inline i32 abt_md::bh_file_section_N() {
    return _db.bh_file_section_n;
}

// --- abt_md.FDb.ns.EmptyQ
// Return true if index is empty
inline bool abt_md::ns_EmptyQ() {
    return _db.ns_n == 0;
}

// --- abt_md.FDb.ns.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FNs* abt_md::ns_Find(u64 t) {
    abt_md::FNs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ns_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ns_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.ns.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FNs* abt_md::ns_Last() {
    return ns_Find(u64(_db.ns_n-1));
}

// --- abt_md.FDb.ns.N
// Return number of items in the pool
inline i32 abt_md::ns_N() {
    return _db.ns_n;
}

// --- abt_md.FDb.ns.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FNs& abt_md::ns_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ns_lary[bsr][index];
}

// --- abt_md.FDb.ind_ns.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_ns_EmptyQ() {
    return _db.ind_ns_n == 0;
}

// --- abt_md.FDb.ind_ns.N
// Return number of items in the hash
inline i32 abt_md::ind_ns_N() {
    return _db.ind_ns_n;
}

// --- abt_md.FDb.ssimfile.EmptyQ
// Return true if index is empty
inline bool abt_md::ssimfile_EmptyQ() {
    return _db.ssimfile_n == 0;
}

// --- abt_md.FDb.ssimfile.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FSsimfile* abt_md::ssimfile_Find(u64 t) {
    abt_md::FSsimfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ssimfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ssimfile_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.ssimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FSsimfile* abt_md::ssimfile_Last() {
    return ssimfile_Find(u64(_db.ssimfile_n-1));
}

// --- abt_md.FDb.ssimfile.N
// Return number of items in the pool
inline i32 abt_md::ssimfile_N() {
    return _db.ssimfile_n;
}

// --- abt_md.FDb.ssimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FSsimfile& abt_md::ssimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimfile_lary[bsr][index];
}

// --- abt_md.FDb.ind_ssimfile.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_ssimfile_EmptyQ() {
    return _db.ind_ssimfile_n == 0;
}

// --- abt_md.FDb.ind_ssimfile.N
// Return number of items in the hash
inline i32 abt_md::ind_ssimfile_N() {
    return _db.ind_ssimfile_n;
}

// --- abt_md.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool abt_md::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- abt_md.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FCtype* abt_md::ctype_Find(u64 t) {
    abt_md::FCtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ctype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FCtype* abt_md::ctype_Last() {
    return ctype_Find(u64(_db.ctype_n-1));
}

// --- abt_md.FDb.ctype.N
// Return number of items in the pool
inline i32 abt_md::ctype_N() {
    return _db.ctype_n;
}

// --- abt_md.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FCtype& abt_md::ctype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- abt_md.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- abt_md.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 abt_md::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- abt_md.FDb.field.EmptyQ
// Return true if index is empty
inline bool abt_md::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- abt_md.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FField* abt_md::field_Find(u64 t) {
    abt_md::FField *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.field_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FField* abt_md::field_Last() {
    return field_Find(u64(_db.field_n-1));
}

// --- abt_md.FDb.field.N
// Return number of items in the pool
inline i32 abt_md::field_N() {
    return _db.field_n;
}

// --- abt_md.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FField& abt_md::field_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- abt_md.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- abt_md.FDb.ind_field.N
// Return number of items in the hash
inline i32 abt_md::ind_field_N() {
    return _db.ind_field_n;
}

// --- abt_md.FDb.targsrc.EmptyQ
// Return true if index is empty
inline bool abt_md::targsrc_EmptyQ() {
    return _db.targsrc_n == 0;
}

// --- abt_md.FDb.targsrc.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FTargsrc* abt_md::targsrc_Find(u64 t) {
    abt_md::FTargsrc *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targsrc_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targsrc_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.targsrc.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FTargsrc* abt_md::targsrc_Last() {
    return targsrc_Find(u64(_db.targsrc_n-1));
}

// --- abt_md.FDb.targsrc.N
// Return number of items in the pool
inline i32 abt_md::targsrc_N() {
    return _db.targsrc_n;
}

// --- abt_md.FDb.targsrc.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FTargsrc& abt_md::targsrc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targsrc_lary[bsr][index];
}

// --- abt_md.FDb.substr.EmptyQ
// Return true if index is empty
inline bool abt_md::substr_EmptyQ() {
    return _db.substr_n == 0;
}

// --- abt_md.FDb.substr.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FSubstr* abt_md::substr_Find(u64 t) {
    abt_md::FSubstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.substr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.substr_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.substr.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FSubstr* abt_md::substr_Last() {
    return substr_Find(u64(_db.substr_n-1));
}

// --- abt_md.FDb.substr.N
// Return number of items in the pool
inline i32 abt_md::substr_N() {
    return _db.substr_n;
}

// --- abt_md.FDb.substr.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FSubstr& abt_md::substr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.substr_lary[bsr][index];
}

// --- abt_md.FDb.ind_human_text.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_human_text_EmptyQ() {
    return _db.ind_human_text_n == 0;
}

// --- abt_md.FDb.ind_human_text.N
// Return number of items in the hash
inline i32 abt_md::ind_human_text_N() {
    return _db.ind_human_text_n;
}

// --- abt_md.FDb.scriptfile.EmptyQ
// Return true if index is empty
inline bool abt_md::scriptfile_EmptyQ() {
    return _db.scriptfile_n == 0;
}

// --- abt_md.FDb.scriptfile.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FScriptfile* abt_md::scriptfile_Find(u64 t) {
    abt_md::FScriptfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.scriptfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.scriptfile_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.scriptfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FScriptfile* abt_md::scriptfile_Last() {
    return scriptfile_Find(u64(_db.scriptfile_n-1));
}

// --- abt_md.FDb.scriptfile.N
// Return number of items in the pool
inline i32 abt_md::scriptfile_N() {
    return _db.scriptfile_n;
}

// --- abt_md.FDb.scriptfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FScriptfile& abt_md::scriptfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.scriptfile_lary[bsr][index];
}

// --- abt_md.FDb.ind_scriptfile.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_scriptfile_EmptyQ() {
    return _db.ind_scriptfile_n == 0;
}

// --- abt_md.FDb.ind_scriptfile.N
// Return number of items in the hash
inline i32 abt_md::ind_scriptfile_N() {
    return _db.ind_scriptfile_n;
}

// --- abt_md.FDb.nstype.EmptyQ
// Return true if index is empty
inline bool abt_md::nstype_EmptyQ() {
    return _db.nstype_n == 0;
}

// --- abt_md.FDb.nstype.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FNstype* abt_md::nstype_Find(u64 t) {
    abt_md::FNstype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nstype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nstype_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.nstype.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FNstype* abt_md::nstype_Last() {
    return nstype_Find(u64(_db.nstype_n-1));
}

// --- abt_md.FDb.nstype.N
// Return number of items in the pool
inline i32 abt_md::nstype_N() {
    return _db.nstype_n;
}

// --- abt_md.FDb.nstype.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FNstype& abt_md::nstype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nstype_lary[bsr][index];
}

// --- abt_md.FDb.ind_nstype.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_nstype_EmptyQ() {
    return _db.ind_nstype_n == 0;
}

// --- abt_md.FDb.ind_nstype.N
// Return number of items in the hash
inline i32 abt_md::ind_nstype_N() {
    return _db.ind_nstype_n;
}

// --- abt_md.FDb.comptest.EmptyQ
// Return true if index is empty
inline bool abt_md::comptest_EmptyQ() {
    return _db.comptest_n == 0;
}

// --- abt_md.FDb.comptest.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FComptest* abt_md::comptest_Find(u64 t) {
    abt_md::FComptest *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.comptest_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.comptest_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.comptest.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FComptest* abt_md::comptest_Last() {
    return comptest_Find(u64(_db.comptest_n-1));
}

// --- abt_md.FDb.comptest.N
// Return number of items in the pool
inline i32 abt_md::comptest_N() {
    return _db.comptest_n;
}

// --- abt_md.FDb.comptest.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FComptest& abt_md::comptest_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.comptest_lary[bsr][index];
}

// --- abt_md.FDb.anchor.EmptyQ
// Return true if index is empty
inline bool abt_md::anchor_EmptyQ() {
    return _db.anchor_n == 0;
}

// --- abt_md.FDb.anchor.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FAnchor* abt_md::anchor_Find(u64 t) {
    abt_md::FAnchor *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.anchor_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.anchor_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.anchor.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FAnchor* abt_md::anchor_Last() {
    return anchor_Find(u64(_db.anchor_n-1));
}

// --- abt_md.FDb.anchor.N
// Return number of items in the pool
inline i32 abt_md::anchor_N() {
    return _db.anchor_n;
}

// --- abt_md.FDb.anchor.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FAnchor& abt_md::anchor_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.anchor_lary[bsr][index];
}

// --- abt_md.FDb.ind_anchor.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_anchor_EmptyQ() {
    return _db.ind_anchor_n == 0;
}

// --- abt_md.FDb.ind_anchor.N
// Return number of items in the hash
inline i32 abt_md::ind_anchor_N() {
    return _db.ind_anchor_n;
}

// --- abt_md.FDb.link.EmptyQ
// Return true if index is empty
inline bool abt_md::link_EmptyQ() {
    return _db.link_n == 0;
}

// --- abt_md.FDb.link.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FLink* abt_md::link_Find(u64 t) {
    abt_md::FLink *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.link_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.link_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.link.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FLink* abt_md::link_Last() {
    return link_Find(u64(_db.link_n-1));
}

// --- abt_md.FDb.link.N
// Return number of items in the pool
inline i32 abt_md::link_N() {
    return _db.link_n;
}

// --- abt_md.FDb.link.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FLink& abt_md::link_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.link_lary[bsr][index];
}

// --- abt_md.FDb.reftype.EmptyQ
// Return true if index is empty
inline bool abt_md::reftype_EmptyQ() {
    return _db.reftype_n == 0;
}

// --- abt_md.FDb.reftype.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FReftype* abt_md::reftype_Find(u64 t) {
    abt_md::FReftype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.reftype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.reftype_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.reftype.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FReftype* abt_md::reftype_Last() {
    return reftype_Find(u64(_db.reftype_n-1));
}

// --- abt_md.FDb.reftype.N
// Return number of items in the pool
inline i32 abt_md::reftype_N() {
    return _db.reftype_n;
}

// --- abt_md.FDb.reftype.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FReftype& abt_md::reftype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.reftype_lary[bsr][index];
}

// --- abt_md.FDb.tclass.EmptyQ
// Return true if index is empty
inline bool abt_md::tclass_EmptyQ() {
    return _db.tclass_n == 0;
}

// --- abt_md.FDb.tclass.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FTclass* abt_md::tclass_Find(u64 t) {
    abt_md::FTclass *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.tclass_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.tclass_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.tclass.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FTclass* abt_md::tclass_Last() {
    return tclass_Find(u64(_db.tclass_n-1));
}

// --- abt_md.FDb.tclass.N
// Return number of items in the pool
inline i32 abt_md::tclass_N() {
    return _db.tclass_n;
}

// --- abt_md.FDb.tclass.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FTclass& abt_md::tclass_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.tclass_lary[bsr][index];
}

// --- abt_md.FDb.ind_tclass.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_tclass_EmptyQ() {
    return _db.ind_tclass_n == 0;
}

// --- abt_md.FDb.ind_tclass.N
// Return number of items in the hash
inline i32 abt_md::ind_tclass_N() {
    return _db.ind_tclass_n;
}

// --- abt_md.FDb.fconst.EmptyQ
// Return true if index is empty
inline bool abt_md::fconst_EmptyQ() {
    return _db.fconst_n == 0;
}

// --- abt_md.FDb.fconst.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FFconst* abt_md::fconst_Find(u64 t) {
    abt_md::FFconst *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fconst_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fconst_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.fconst.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FFconst* abt_md::fconst_Last() {
    return fconst_Find(u64(_db.fconst_n-1));
}

// --- abt_md.FDb.fconst.N
// Return number of items in the pool
inline i32 abt_md::fconst_N() {
    return _db.fconst_n;
}

// --- abt_md.FDb.fconst.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FFconst& abt_md::fconst_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fconst_lary[bsr][index];
}

// --- abt_md.FDb.gconst.EmptyQ
// Return true if index is empty
inline bool abt_md::gconst_EmptyQ() {
    return _db.gconst_n == 0;
}

// --- abt_md.FDb.gconst.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FGconst* abt_md::gconst_Find(u64 t) {
    abt_md::FGconst *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gconst_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gconst_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.gconst.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FGconst* abt_md::gconst_Last() {
    return gconst_Find(u64(_db.gconst_n-1));
}

// --- abt_md.FDb.gconst.N
// Return number of items in the pool
inline i32 abt_md::gconst_N() {
    return _db.gconst_n;
}

// --- abt_md.FDb.gconst.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FGconst& abt_md::gconst_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gconst_lary[bsr][index];
}

// --- abt_md.FDb.readmesort.EmptyQ
// Return true if index is empty
inline bool abt_md::readmesort_EmptyQ() {
    return _db.readmesort_n == 0;
}

// --- abt_md.FDb.readmesort.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FReadmesort* abt_md::readmesort_Find(u64 t) {
    abt_md::FReadmesort *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.readmesort_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.readmesort_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.readmesort.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FReadmesort* abt_md::readmesort_Last() {
    return readmesort_Find(u64(_db.readmesort_n-1));
}

// --- abt_md.FDb.readmesort.N
// Return number of items in the pool
inline i32 abt_md::readmesort_N() {
    return _db.readmesort_n;
}

// --- abt_md.FDb.readmesort.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FReadmesort& abt_md::readmesort_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.readmesort_lary[bsr][index];
}

// --- abt_md.FDb.ind_readmesort.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_readmesort_EmptyQ() {
    return _db.ind_readmesort_n == 0;
}

// --- abt_md.FDb.ind_readmesort.N
// Return number of items in the hash
inline i32 abt_md::ind_readmesort_N() {
    return _db.ind_readmesort_n;
}

// --- abt_md.FDb.gstatic.EmptyQ
// Return true if index is empty
inline bool abt_md::gstatic_EmptyQ() {
    return _db.gstatic_n == 0;
}

// --- abt_md.FDb.gstatic.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FGstatic* abt_md::gstatic_Find(u64 t) {
    abt_md::FGstatic *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gstatic_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gstatic_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.gstatic.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FGstatic* abt_md::gstatic_Last() {
    return gstatic_Find(u64(_db.gstatic_n-1));
}

// --- abt_md.FDb.gstatic.N
// Return number of items in the pool
inline i32 abt_md::gstatic_N() {
    return _db.gstatic_n;
}

// --- abt_md.FDb.gstatic.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FGstatic& abt_md::gstatic_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gstatic_lary[bsr][index];
}

// --- abt_md.FDb.ind_gstatic.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_gstatic_EmptyQ() {
    return _db.ind_gstatic_n == 0;
}

// --- abt_md.FDb.ind_gstatic.N
// Return number of items in the hash
inline i32 abt_md::ind_gstatic_N() {
    return _db.ind_gstatic_n;
}

// --- abt_md.FDb.target.EmptyQ
// Return true if index is empty
inline bool abt_md::target_EmptyQ() {
    return _db.target_n == 0;
}

// --- abt_md.FDb.target.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FTarget* abt_md::target_Find(u64 t) {
    abt_md::FTarget *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.target_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.target_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.target.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FTarget* abt_md::target_Last() {
    return target_Find(u64(_db.target_n-1));
}

// --- abt_md.FDb.target.N
// Return number of items in the pool
inline i32 abt_md::target_N() {
    return _db.target_n;
}

// --- abt_md.FDb.target.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FTarget& abt_md::target_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.target_lary[bsr][index];
}

// --- abt_md.FDb.targdep.EmptyQ
// Return true if index is empty
inline bool abt_md::targdep_EmptyQ() {
    return _db.targdep_n == 0;
}

// --- abt_md.FDb.targdep.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FTargdep* abt_md::targdep_Find(u64 t) {
    abt_md::FTargdep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targdep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targdep_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.targdep.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FTargdep* abt_md::targdep_Last() {
    return targdep_Find(u64(_db.targdep_n-1));
}

// --- abt_md.FDb.targdep.N
// Return number of items in the pool
inline i32 abt_md::targdep_N() {
    return _db.targdep_n;
}

// --- abt_md.FDb.targdep.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FTargdep& abt_md::targdep_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targdep_lary[bsr][index];
}

// --- abt_md.FDb.ind_target.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_target_EmptyQ() {
    return _db.ind_target_n == 0;
}

// --- abt_md.FDb.ind_target.N
// Return number of items in the hash
inline i32 abt_md::ind_target_N() {
    return _db.ind_target_n;
}

// --- abt_md.FDb.finput.EmptyQ
// Return true if index is empty
inline bool abt_md::finput_EmptyQ() {
    return _db.finput_n == 0;
}

// --- abt_md.FDb.finput.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FFinput* abt_md::finput_Find(u64 t) {
    abt_md::FFinput *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.finput_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.finput_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.finput.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FFinput* abt_md::finput_Last() {
    return finput_Find(u64(_db.finput_n-1));
}

// --- abt_md.FDb.finput.N
// Return number of items in the pool
inline i32 abt_md::finput_N() {
    return _db.finput_n;
}

// --- abt_md.FDb.finput.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FFinput& abt_md::finput_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.finput_lary[bsr][index];
}

// --- abt_md.FDb.zd_scanns.EmptyQ
// Return true if index is empty
inline bool abt_md::zd_scanns_EmptyQ() {
    return _db.zd_scanns_head == NULL;
}

// --- abt_md.FDb.zd_scanns.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt_md::FNs* abt_md::zd_scanns_First() {
    abt_md::FNs *row = NULL;
    row = _db.zd_scanns_head;
    return row;
}

// --- abt_md.FDb.zd_scanns.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt_md::zd_scanns_InLlistQ(abt_md::FNs& row) {
    bool result = false;
    result = !(row.zd_scanns_next == (abt_md::FNs*)-1);
    return result;
}

// --- abt_md.FDb.zd_scanns.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt_md::FNs* abt_md::zd_scanns_Last() {
    abt_md::FNs *row = NULL;
    row = _db.zd_scanns_tail;
    return row;
}

// --- abt_md.FDb.zd_scanns.N
// Return number of items in the linked list
inline i32 abt_md::zd_scanns_N() {
    return _db.zd_scanns_n;
}

// --- abt_md.FDb.zd_scanns.Next
// Return pointer to next element in the list
inline abt_md::FNs* abt_md::zd_scanns_Next(abt_md::FNs &row) {
    return row.zd_scanns_next;
}

// --- abt_md.FDb.zd_scanns.Prev
// Return pointer to previous element in the list
inline abt_md::FNs* abt_md::zd_scanns_Prev(abt_md::FNs &row) {
    return row.zd_scanns_prev;
}

// --- abt_md.FDb.zd_scanns.qLast
// Return reference to last element in the index. No bounds checking.
inline abt_md::FNs& abt_md::zd_scanns_qLast() {
    abt_md::FNs *row = NULL;
    row = _db.zd_scanns_tail;
    return *row;
}

// --- abt_md.FDb.dispatch.EmptyQ
// Return true if index is empty
inline bool abt_md::dispatch_EmptyQ() {
    return _db.dispatch_n == 0;
}

// --- abt_md.FDb.dispatch.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FDispatch* abt_md::dispatch_Find(u64 t) {
    abt_md::FDispatch *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispatch_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispatch_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.dispatch.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FDispatch* abt_md::dispatch_Last() {
    return dispatch_Find(u64(_db.dispatch_n-1));
}

// --- abt_md.FDb.dispatch.N
// Return number of items in the pool
inline i32 abt_md::dispatch_N() {
    return _db.dispatch_n;
}

// --- abt_md.FDb.dispatch.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FDispatch& abt_md::dispatch_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispatch_lary[bsr][index];
}

// --- abt_md.FDb.ind_dispatch.EmptyQ
// Return true if hash is empty
inline bool abt_md::ind_dispatch_EmptyQ() {
    return _db.ind_dispatch_n == 0;
}

// --- abt_md.FDb.ind_dispatch.N
// Return number of items in the hash
inline i32 abt_md::ind_dispatch_N() {
    return _db.ind_dispatch_n;
}

// --- abt_md.FDb.dispatch_msg.EmptyQ
// Return true if index is empty
inline bool abt_md::dispatch_msg_EmptyQ() {
    return _db.dispatch_msg_n == 0;
}

// --- abt_md.FDb.dispatch_msg.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FDispatchMsg* abt_md::dispatch_msg_Find(u64 t) {
    abt_md::FDispatchMsg *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispatch_msg_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispatch_msg_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDb.dispatch_msg.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FDispatchMsg* abt_md::dispatch_msg_Last() {
    return dispatch_msg_Find(u64(_db.dispatch_msg_n-1));
}

// --- abt_md.FDb.dispatch_msg.N
// Return number of items in the pool
inline i32 abt_md::dispatch_msg_N() {
    return _db.dispatch_msg_n;
}

// --- abt_md.FDb.dispatch_msg.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FDispatchMsg& abt_md::dispatch_msg_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispatch_msg_lary[bsr][index];
}

// --- abt_md.FDb.readmefile_curs.Reset
// cursor points to valid item
inline void abt_md::_db_readmefile_curs_Reset(_db_readmefile_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.readmefile_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_readmefile_curs_ValidQ(_db_readmefile_curs &curs) {
    return curs.index < _db.readmefile_n;
}

// --- abt_md.FDb.readmefile_curs.Next
// proceed to next item
inline void abt_md::_db_readmefile_curs_Next(_db_readmefile_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.readmefile_curs.Access
// item access
inline abt_md::FReadmefile& abt_md::_db_readmefile_curs_Access(_db_readmefile_curs &curs) {
    return readmefile_qFind(u64(curs.index));
}

// --- abt_md.FDb.mdsection_curs.Reset
// cursor points to valid item
inline void abt_md::_db_mdsection_curs_Reset(_db_mdsection_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.mdsection_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_mdsection_curs_ValidQ(_db_mdsection_curs &curs) {
    return u64(curs.index) < u64(curs.parent->mdsection_n);
}

// --- abt_md.FDb.mdsection_curs.Next
// proceed to next item
inline void abt_md::_db_mdsection_curs_Next(_db_mdsection_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.mdsection_curs.Access
// item access
inline abt_md::FMdsection& abt_md::_db_mdsection_curs_Access(_db_mdsection_curs &curs) {
    return mdsection_qFind(i32(curs.index));
}

// --- abt_md.FDb.file_section_curs.Reset
// cursor points to valid item
inline void abt_md::_db_file_section_curs_Reset(_db_file_section_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.file_section_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_file_section_curs_ValidQ(_db_file_section_curs &curs) {
    return curs.index < _db.file_section_n;
}

// --- abt_md.FDb.file_section_curs.Next
// proceed to next item
inline void abt_md::_db_file_section_curs_Next(_db_file_section_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.file_section_curs.Access
// item access
inline abt_md::FFileSection& abt_md::_db_file_section_curs_Access(_db_file_section_curs &curs) {
    return file_section_qFind(u64(curs.index));
}

// --- abt_md.FDb.bh_file_section_curs.Access
// Access current element. If not more elements, return NULL
inline abt_md::FFileSection& abt_md::_db_bh_file_section_curs_Access(_db_bh_file_section_curs &curs) {
    return *curs.temp_elems[0];
}

// --- abt_md.FDb.bh_file_section_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool abt_md::_db_bh_file_section_curs_ValidQ(_db_bh_file_section_curs &curs) {
    return curs.temp_n > 0;
}

// --- abt_md.FDb.ns_curs.Reset
// cursor points to valid item
inline void abt_md::_db_ns_curs_Reset(_db_ns_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.ns_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_ns_curs_ValidQ(_db_ns_curs &curs) {
    return curs.index < _db.ns_n;
}

// --- abt_md.FDb.ns_curs.Next
// proceed to next item
inline void abt_md::_db_ns_curs_Next(_db_ns_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.ns_curs.Access
// item access
inline abt_md::FNs& abt_md::_db_ns_curs_Access(_db_ns_curs &curs) {
    return ns_qFind(u64(curs.index));
}

// --- abt_md.FDb.ssimfile_curs.Reset
// cursor points to valid item
inline void abt_md::_db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.ssimfile_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) {
    return curs.index < _db.ssimfile_n;
}

// --- abt_md.FDb.ssimfile_curs.Next
// proceed to next item
inline void abt_md::_db_ssimfile_curs_Next(_db_ssimfile_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.ssimfile_curs.Access
// item access
inline abt_md::FSsimfile& abt_md::_db_ssimfile_curs_Access(_db_ssimfile_curs &curs) {
    return ssimfile_qFind(u64(curs.index));
}

// --- abt_md.FDb.ctype_curs.Reset
// cursor points to valid item
inline void abt_md::_db_ctype_curs_Reset(_db_ctype_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- abt_md.FDb.ctype_curs.Next
// proceed to next item
inline void abt_md::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.ctype_curs.Access
// item access
inline abt_md::FCtype& abt_md::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(u64(curs.index));
}

// --- abt_md.FDb.field_curs.Reset
// cursor points to valid item
inline void abt_md::_db_field_curs_Reset(_db_field_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- abt_md.FDb.field_curs.Next
// proceed to next item
inline void abt_md::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.field_curs.Access
// item access
inline abt_md::FField& abt_md::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u64(curs.index));
}

// --- abt_md.FDb.targsrc_curs.Reset
// cursor points to valid item
inline void abt_md::_db_targsrc_curs_Reset(_db_targsrc_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.targsrc_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_targsrc_curs_ValidQ(_db_targsrc_curs &curs) {
    return curs.index < _db.targsrc_n;
}

// --- abt_md.FDb.targsrc_curs.Next
// proceed to next item
inline void abt_md::_db_targsrc_curs_Next(_db_targsrc_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.targsrc_curs.Access
// item access
inline abt_md::FTargsrc& abt_md::_db_targsrc_curs_Access(_db_targsrc_curs &curs) {
    return targsrc_qFind(u64(curs.index));
}

// --- abt_md.FDb.substr_curs.Reset
// cursor points to valid item
inline void abt_md::_db_substr_curs_Reset(_db_substr_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.substr_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_substr_curs_ValidQ(_db_substr_curs &curs) {
    return curs.index < _db.substr_n;
}

// --- abt_md.FDb.substr_curs.Next
// proceed to next item
inline void abt_md::_db_substr_curs_Next(_db_substr_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.substr_curs.Access
// item access
inline abt_md::FSubstr& abt_md::_db_substr_curs_Access(_db_substr_curs &curs) {
    return substr_qFind(u64(curs.index));
}

// --- abt_md.FDb.ind_human_text_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_ind_human_text_curs_ValidQ(_db_ind_human_text_curs &curs) {
    return *curs.prow != NULL;
}

// --- abt_md.FDb.ind_human_text_curs.Next
// proceed to next item
inline void abt_md::_db_ind_human_text_curs_Next(_db_ind_human_text_curs &curs) {
    curs.prow = &(*curs.prow)->ind_human_text_next;
    while (!*curs.prow) {
        curs.bucket += 1;
        if (curs.bucket >= curs.parent->ind_human_text_buckets_n) break;
        curs.prow = &curs.parent->ind_human_text_buckets_elems[curs.bucket];
    }
}

// --- abt_md.FDb.ind_human_text_curs.Access
// item access
inline abt_md::FHumanText& abt_md::_db_ind_human_text_curs_Access(_db_ind_human_text_curs &curs) {
    return **curs.prow;
}

// --- abt_md.FDb.scriptfile_curs.Reset
// cursor points to valid item
inline void abt_md::_db_scriptfile_curs_Reset(_db_scriptfile_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.scriptfile_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_scriptfile_curs_ValidQ(_db_scriptfile_curs &curs) {
    return curs.index < _db.scriptfile_n;
}

// --- abt_md.FDb.scriptfile_curs.Next
// proceed to next item
inline void abt_md::_db_scriptfile_curs_Next(_db_scriptfile_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.scriptfile_curs.Access
// item access
inline abt_md::FScriptfile& abt_md::_db_scriptfile_curs_Access(_db_scriptfile_curs &curs) {
    return scriptfile_qFind(u64(curs.index));
}

// --- abt_md.FDb.nstype_curs.Reset
// cursor points to valid item
inline void abt_md::_db_nstype_curs_Reset(_db_nstype_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.nstype_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_nstype_curs_ValidQ(_db_nstype_curs &curs) {
    return curs.index < _db.nstype_n;
}

// --- abt_md.FDb.nstype_curs.Next
// proceed to next item
inline void abt_md::_db_nstype_curs_Next(_db_nstype_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.nstype_curs.Access
// item access
inline abt_md::FNstype& abt_md::_db_nstype_curs_Access(_db_nstype_curs &curs) {
    return nstype_qFind(u64(curs.index));
}

// --- abt_md.FDb.comptest_curs.Reset
// cursor points to valid item
inline void abt_md::_db_comptest_curs_Reset(_db_comptest_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.comptest_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_comptest_curs_ValidQ(_db_comptest_curs &curs) {
    return curs.index < _db.comptest_n;
}

// --- abt_md.FDb.comptest_curs.Next
// proceed to next item
inline void abt_md::_db_comptest_curs_Next(_db_comptest_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.comptest_curs.Access
// item access
inline abt_md::FComptest& abt_md::_db_comptest_curs_Access(_db_comptest_curs &curs) {
    return comptest_qFind(u64(curs.index));
}

// --- abt_md.FDb.anchor_curs.Reset
// cursor points to valid item
inline void abt_md::_db_anchor_curs_Reset(_db_anchor_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.anchor_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_anchor_curs_ValidQ(_db_anchor_curs &curs) {
    return curs.index < _db.anchor_n;
}

// --- abt_md.FDb.anchor_curs.Next
// proceed to next item
inline void abt_md::_db_anchor_curs_Next(_db_anchor_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.anchor_curs.Access
// item access
inline abt_md::FAnchor& abt_md::_db_anchor_curs_Access(_db_anchor_curs &curs) {
    return anchor_qFind(u64(curs.index));
}

// --- abt_md.FDb.link_curs.Reset
// cursor points to valid item
inline void abt_md::_db_link_curs_Reset(_db_link_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.link_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_link_curs_ValidQ(_db_link_curs &curs) {
    return curs.index < _db.link_n;
}

// --- abt_md.FDb.link_curs.Next
// proceed to next item
inline void abt_md::_db_link_curs_Next(_db_link_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.link_curs.Access
// item access
inline abt_md::FLink& abt_md::_db_link_curs_Access(_db_link_curs &curs) {
    return link_qFind(u64(curs.index));
}

// --- abt_md.FDb.reftype_curs.Reset
// cursor points to valid item
inline void abt_md::_db_reftype_curs_Reset(_db_reftype_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.reftype_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_reftype_curs_ValidQ(_db_reftype_curs &curs) {
    return curs.index < _db.reftype_n;
}

// --- abt_md.FDb.reftype_curs.Next
// proceed to next item
inline void abt_md::_db_reftype_curs_Next(_db_reftype_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.reftype_curs.Access
// item access
inline abt_md::FReftype& abt_md::_db_reftype_curs_Access(_db_reftype_curs &curs) {
    return reftype_qFind(u64(curs.index));
}

// --- abt_md.FDb.tclass_curs.Reset
// cursor points to valid item
inline void abt_md::_db_tclass_curs_Reset(_db_tclass_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.tclass_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_tclass_curs_ValidQ(_db_tclass_curs &curs) {
    return curs.index < _db.tclass_n;
}

// --- abt_md.FDb.tclass_curs.Next
// proceed to next item
inline void abt_md::_db_tclass_curs_Next(_db_tclass_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.tclass_curs.Access
// item access
inline abt_md::FTclass& abt_md::_db_tclass_curs_Access(_db_tclass_curs &curs) {
    return tclass_qFind(u64(curs.index));
}

// --- abt_md.FDb.fconst_curs.Reset
// cursor points to valid item
inline void abt_md::_db_fconst_curs_Reset(_db_fconst_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.fconst_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_fconst_curs_ValidQ(_db_fconst_curs &curs) {
    return curs.index < _db.fconst_n;
}

// --- abt_md.FDb.fconst_curs.Next
// proceed to next item
inline void abt_md::_db_fconst_curs_Next(_db_fconst_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.fconst_curs.Access
// item access
inline abt_md::FFconst& abt_md::_db_fconst_curs_Access(_db_fconst_curs &curs) {
    return fconst_qFind(u64(curs.index));
}

// --- abt_md.FDb.gconst_curs.Reset
// cursor points to valid item
inline void abt_md::_db_gconst_curs_Reset(_db_gconst_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.gconst_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_gconst_curs_ValidQ(_db_gconst_curs &curs) {
    return curs.index < _db.gconst_n;
}

// --- abt_md.FDb.gconst_curs.Next
// proceed to next item
inline void abt_md::_db_gconst_curs_Next(_db_gconst_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.gconst_curs.Access
// item access
inline abt_md::FGconst& abt_md::_db_gconst_curs_Access(_db_gconst_curs &curs) {
    return gconst_qFind(u64(curs.index));
}

// --- abt_md.FDb.readmesort_curs.Reset
// cursor points to valid item
inline void abt_md::_db_readmesort_curs_Reset(_db_readmesort_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.readmesort_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_readmesort_curs_ValidQ(_db_readmesort_curs &curs) {
    return curs.index < _db.readmesort_n;
}

// --- abt_md.FDb.readmesort_curs.Next
// proceed to next item
inline void abt_md::_db_readmesort_curs_Next(_db_readmesort_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.readmesort_curs.Access
// item access
inline abt_md::FReadmesort& abt_md::_db_readmesort_curs_Access(_db_readmesort_curs &curs) {
    return readmesort_qFind(u64(curs.index));
}

// --- abt_md.FDb.gstatic_curs.Reset
// cursor points to valid item
inline void abt_md::_db_gstatic_curs_Reset(_db_gstatic_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.gstatic_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_gstatic_curs_ValidQ(_db_gstatic_curs &curs) {
    return curs.index < _db.gstatic_n;
}

// --- abt_md.FDb.gstatic_curs.Next
// proceed to next item
inline void abt_md::_db_gstatic_curs_Next(_db_gstatic_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.gstatic_curs.Access
// item access
inline abt_md::FGstatic& abt_md::_db_gstatic_curs_Access(_db_gstatic_curs &curs) {
    return gstatic_qFind(u64(curs.index));
}

// --- abt_md.FDb.target_curs.Reset
// cursor points to valid item
inline void abt_md::_db_target_curs_Reset(_db_target_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.target_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_target_curs_ValidQ(_db_target_curs &curs) {
    return curs.index < _db.target_n;
}

// --- abt_md.FDb.target_curs.Next
// proceed to next item
inline void abt_md::_db_target_curs_Next(_db_target_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.target_curs.Access
// item access
inline abt_md::FTarget& abt_md::_db_target_curs_Access(_db_target_curs &curs) {
    return target_qFind(u64(curs.index));
}

// --- abt_md.FDb.targdep_curs.Reset
// cursor points to valid item
inline void abt_md::_db_targdep_curs_Reset(_db_targdep_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.targdep_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_targdep_curs_ValidQ(_db_targdep_curs &curs) {
    return curs.index < _db.targdep_n;
}

// --- abt_md.FDb.targdep_curs.Next
// proceed to next item
inline void abt_md::_db_targdep_curs_Next(_db_targdep_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.targdep_curs.Access
// item access
inline abt_md::FTargdep& abt_md::_db_targdep_curs_Access(_db_targdep_curs &curs) {
    return targdep_qFind(u64(curs.index));
}

// --- abt_md.FDb.finput_curs.Reset
// cursor points to valid item
inline void abt_md::_db_finput_curs_Reset(_db_finput_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.finput_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_finput_curs_ValidQ(_db_finput_curs &curs) {
    return curs.index < _db.finput_n;
}

// --- abt_md.FDb.finput_curs.Next
// proceed to next item
inline void abt_md::_db_finput_curs_Next(_db_finput_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.finput_curs.Access
// item access
inline abt_md::FFinput& abt_md::_db_finput_curs_Access(_db_finput_curs &curs) {
    return finput_qFind(u64(curs.index));
}

// --- abt_md.FDb.zd_scanns_curs.Reset
// cursor points to valid item
inline void abt_md::_db_zd_scanns_curs_Reset(_db_zd_scanns_curs &curs, abt_md::FDb &parent) {
    curs.row = parent.zd_scanns_head;
}

// --- abt_md.FDb.zd_scanns_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_zd_scanns_curs_ValidQ(_db_zd_scanns_curs &curs) {
    return curs.row != NULL;
}

// --- abt_md.FDb.zd_scanns_curs.Next
// proceed to next item
inline void abt_md::_db_zd_scanns_curs_Next(_db_zd_scanns_curs &curs) {
    abt_md::FNs *next = (*curs.row).zd_scanns_next;
    curs.row = next;
}

// --- abt_md.FDb.zd_scanns_curs.Access
// item access
inline abt_md::FNs& abt_md::_db_zd_scanns_curs_Access(_db_zd_scanns_curs &curs) {
    return *curs.row;
}

// --- abt_md.FDb.dispatch_curs.Reset
// cursor points to valid item
inline void abt_md::_db_dispatch_curs_Reset(_db_dispatch_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.dispatch_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_dispatch_curs_ValidQ(_db_dispatch_curs &curs) {
    return curs.index < _db.dispatch_n;
}

// --- abt_md.FDb.dispatch_curs.Next
// proceed to next item
inline void abt_md::_db_dispatch_curs_Next(_db_dispatch_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.dispatch_curs.Access
// item access
inline abt_md::FDispatch& abt_md::_db_dispatch_curs_Access(_db_dispatch_curs &curs) {
    return dispatch_qFind(u64(curs.index));
}

// --- abt_md.FDb.dispatch_msg_curs.Reset
// cursor points to valid item
inline void abt_md::_db_dispatch_msg_curs_Reset(_db_dispatch_msg_curs &curs, abt_md::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDb.dispatch_msg_curs.ValidQ
// cursor points to valid item
inline bool abt_md::_db_dispatch_msg_curs_ValidQ(_db_dispatch_msg_curs &curs) {
    return curs.index < _db.dispatch_msg_n;
}

// --- abt_md.FDb.dispatch_msg_curs.Next
// proceed to next item
inline void abt_md::_db_dispatch_msg_curs_Next(_db_dispatch_msg_curs &curs) {
    curs.index++;
}

// --- abt_md.FDb.dispatch_msg_curs.Access
// item access
inline abt_md::FDispatchMsg& abt_md::_db_dispatch_msg_curs_Access(_db_dispatch_msg_curs &curs) {
    return dispatch_msg_qFind(u64(curs.index));
}

// --- abt_md.FDirent.sortfld.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool abt_md::sortfld_Lt(abt_md::FDirent& dirent, abt_md::FDirent &rhs) {
    return algo::cstring_Lt(dirent.sortfld,rhs.sortfld);
}

// --- abt_md.FDirent.sortfld.Cmp
// Compare two fields.
inline i32 abt_md::sortfld_Cmp(abt_md::FDirent& dirent, abt_md::FDirent &rhs) {
    i32 retval = 0;
    retval = algo::cstring_Cmp(dirent.sortfld, rhs.sortfld);
    return retval;
}

// --- abt_md.FDirent..Init
// Set all fields to initial values.
inline void abt_md::FDirent_Init(abt_md::FDirent& dirent) {
    dirent.is_dir = bool(false);
    dirent.p_dirscan = NULL;
    dirent.parent_bh_dirent_idx = -1; // (abt_md.FDirscan.bh_dirent) not-in-heap
}

// --- abt_md.FDirent..Ctor
inline  abt_md::FDirent::FDirent() {
    abt_md::FDirent_Init(*this);
}

// --- abt_md.FDirent..Dtor
inline  abt_md::FDirent::~FDirent() {
    abt_md::FDirent_Uninit(*this);
}

// --- abt_md.FDirscan.bh_dirent.EmptyQ
// Return true if index is empty
inline bool abt_md::bh_dirent_EmptyQ(abt_md::FDirscan& parent) {
    return parent.bh_dirent_n == 0;
}

// --- abt_md.FDirscan.bh_dirent.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt_md::FDirent* abt_md::bh_dirent_First(abt_md::FDirscan& parent) {
    abt_md::FDirent *row = NULL;
    if (parent.bh_dirent_n > 0) {
        row = parent.bh_dirent_elems[0];
    }
    return row;
}

// --- abt_md.FDirscan.bh_dirent.InBheapQ
// Return true if row is in index, false otherwise
inline bool abt_md::bh_dirent_InBheapQ(abt_md::FDirent& row) {
    bool result = false;
    result = row.parent_bh_dirent_idx != -1;
    return result;
}

// --- abt_md.FDirscan.bh_dirent.N
// Return number of items in the heap
inline i32 abt_md::bh_dirent_N(const abt_md::FDirscan& parent) {
    return parent.bh_dirent_n;
}

// --- abt_md.FDirscan.dirent.EmptyQ
// Return true if index is empty
inline bool abt_md::dirent_EmptyQ(abt_md::FDirscan& parent) {
    return parent.dirent_n == 0;
}

// --- abt_md.FDirscan.dirent.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FDirent* abt_md::dirent_Find(abt_md::FDirscan& parent, u64 t) {
    abt_md::FDirent *retval = NULL;
    if (LIKELY(u64(t) < u64(parent.dirent_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &parent.dirent_lary[bsr][index];
    }
    return retval;
}

// --- abt_md.FDirscan.dirent.Last
// Return pointer to last element of array, or NULL if array is empty
inline abt_md::FDirent* abt_md::dirent_Last(abt_md::FDirscan& parent) {
    return dirent_Find(parent, u64(parent.dirent_n-1));
}

// --- abt_md.FDirscan.dirent.N
// Return number of items in the pool
inline i32 abt_md::dirent_N(const abt_md::FDirscan& parent) {
    return parent.dirent_n;
}

// --- abt_md.FDirscan.dirent.qFind
// 'quick' Access row by row id. No bounds checking.
inline abt_md::FDirent& abt_md::dirent_qFind(abt_md::FDirscan& parent, u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return parent.dirent_lary[bsr][index];
}

// --- abt_md.FDirscan.bh_dirent_curs.Access
// Access current element. If not more elements, return NULL
inline abt_md::FDirent& abt_md::FDirscan_bh_dirent_curs_Access(FDirscan_bh_dirent_curs &curs) {
    return *curs.temp_elems[0];
}

// --- abt_md.FDirscan.bh_dirent_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool abt_md::FDirscan_bh_dirent_curs_ValidQ(FDirscan_bh_dirent_curs &curs) {
    return curs.temp_n > 0;
}

// --- abt_md.FDirscan.dirent_curs.Reset
// cursor points to valid item
inline void abt_md::FDirscan_dirent_curs_Reset(FDirscan_dirent_curs &curs, abt_md::FDirscan &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- abt_md.FDirscan.dirent_curs.ValidQ
// cursor points to valid item
inline bool abt_md::FDirscan_dirent_curs_ValidQ(FDirscan_dirent_curs &curs) {
    return curs.index < (*curs.parent).dirent_n;
}

// --- abt_md.FDirscan.dirent_curs.Next
// proceed to next item
inline void abt_md::FDirscan_dirent_curs_Next(FDirscan_dirent_curs &curs) {
    curs.index++;
}

// --- abt_md.FDirscan.dirent_curs.Access
// item access
inline abt_md::FDirent& abt_md::FDirscan_dirent_curs_Access(FDirscan_dirent_curs &curs) {
    return dirent_qFind((*curs.parent), u64(curs.index));
}

// --- abt_md.FDirscan..Ctor
inline  abt_md::FDirscan::FDirscan() {
    abt_md::FDirscan_Init(*this);
}

// --- abt_md.FDirscan..Dtor
inline  abt_md::FDirscan::~FDirscan() {
    abt_md::FDirscan_Uninit(*this);
}

// --- abt_md.FDispatch.c_dispatch_msg.EmptyQ
// Return true if index is empty
inline bool abt_md::c_dispatch_msg_EmptyQ(abt_md::FDispatch& dispatch) {
    return dispatch.c_dispatch_msg_n == 0;
}

// --- abt_md.FDispatch.c_dispatch_msg.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FDispatchMsg* abt_md::c_dispatch_msg_Find(abt_md::FDispatch& dispatch, u32 t) {
    abt_md::FDispatchMsg *retval = NULL;
    u64 idx = t;
    u64 lim = dispatch.c_dispatch_msg_n;
    if (idx < lim) {
        retval = dispatch.c_dispatch_msg_elems[idx];
    }
    return retval;
}

// --- abt_md.FDispatch.c_dispatch_msg.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FDispatchMsg*> abt_md::c_dispatch_msg_Getary(abt_md::FDispatch& dispatch) {
    return algo::aryptr<abt_md::FDispatchMsg*>(dispatch.c_dispatch_msg_elems, dispatch.c_dispatch_msg_n);
}

// --- abt_md.FDispatch.c_dispatch_msg.N
// Return number of items in the pointer array
inline i32 abt_md::c_dispatch_msg_N(const abt_md::FDispatch& dispatch) {
    return dispatch.c_dispatch_msg_n;
}

// --- abt_md.FDispatch.c_dispatch_msg.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_dispatch_msg_RemoveAll(abt_md::FDispatch& dispatch) {
    for (u32 i = 0; i < dispatch.c_dispatch_msg_n; i++) {
        // mark all elements as not-in-array
        dispatch.c_dispatch_msg_elems[i]->dispatch_c_dispatch_msg_in_ary = false;
    }
    dispatch.c_dispatch_msg_n = 0;
}

// --- abt_md.FDispatch.c_dispatch_msg.qFind
// Return reference without bounds checking
inline abt_md::FDispatchMsg& abt_md::c_dispatch_msg_qFind(abt_md::FDispatch& dispatch, u32 idx) {
    return *dispatch.c_dispatch_msg_elems[idx];
}

// --- abt_md.FDispatch.c_dispatch_msg.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::dispatch_c_dispatch_msg_InAryQ(abt_md::FDispatchMsg& row) {
    return row.dispatch_c_dispatch_msg_in_ary;
}

// --- abt_md.FDispatch.c_dispatch_msg.qLast
// Reference to last element without bounds checking
inline abt_md::FDispatchMsg& abt_md::c_dispatch_msg_qLast(abt_md::FDispatch& dispatch) {
    return *dispatch.c_dispatch_msg_elems[dispatch.c_dispatch_msg_n-1];
}

// --- abt_md.FDispatch.c_dispatch_msg_curs.Reset
inline void abt_md::dispatch_c_dispatch_msg_curs_Reset(dispatch_c_dispatch_msg_curs &curs, abt_md::FDispatch &parent) {
    curs.elems = parent.c_dispatch_msg_elems;
    curs.n_elems = parent.c_dispatch_msg_n;
    curs.index = 0;
}

// --- abt_md.FDispatch.c_dispatch_msg_curs.ValidQ
// cursor points to valid item
inline bool abt_md::dispatch_c_dispatch_msg_curs_ValidQ(dispatch_c_dispatch_msg_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FDispatch.c_dispatch_msg_curs.Next
// proceed to next item
inline void abt_md::dispatch_c_dispatch_msg_curs_Next(dispatch_c_dispatch_msg_curs &curs) {
    curs.index++;
}

// --- abt_md.FDispatch.c_dispatch_msg_curs.Access
// item access
inline abt_md::FDispatchMsg& abt_md::dispatch_c_dispatch_msg_curs_Access(dispatch_c_dispatch_msg_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FDispatch..Ctor
inline  abt_md::FDispatch::FDispatch() {
    abt_md::FDispatch_Init(*this);
}

// --- abt_md.FDispatch..Dtor
inline  abt_md::FDispatch::~FDispatch() {
    abt_md::FDispatch_Uninit(*this);
}

// --- abt_md.FDispatchMsg..Init
// Set all fields to initial values.
inline void abt_md::FDispatchMsg_Init(abt_md::FDispatchMsg& dispatch_msg) {
    dispatch_msg.p_ctype = NULL;
    dispatch_msg.dispatch_c_dispatch_msg_in_ary = bool(false);
}

// --- abt_md.FDispatchMsg..Ctor
inline  abt_md::FDispatchMsg::FDispatchMsg() {
    abt_md::FDispatchMsg_Init(*this);
}

// --- abt_md.FDispatchMsg..Dtor
inline  abt_md::FDispatchMsg::~FDispatchMsg() {
    abt_md::FDispatchMsg_Uninit(*this);
}

// --- abt_md.FFconst..Init
// Set all fields to initial values.
inline void abt_md::FFconst_Init(abt_md::FFconst& fconst) {
    fconst.field_c_fconst_in_ary = bool(false);
}

// --- abt_md.FFconst..Ctor
inline  abt_md::FFconst::FFconst() {
    abt_md::FFconst_Init(*this);
}

// --- abt_md.FFconst..Dtor
inline  abt_md::FFconst::~FFconst() {
    abt_md::FFconst_Uninit(*this);
}

// --- abt_md.FField.c_substr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool abt_md::c_substr_InsertMaybe(abt_md::FField& field, abt_md::FSubstr& row) {
    abt_md::FSubstr* ptr = field.c_substr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_substr = &row;
    }
    return retval;
}

// --- abt_md.FField.c_substr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void abt_md::c_substr_Remove(abt_md::FField& field, abt_md::FSubstr& row) {
    abt_md::FSubstr *ptr = field.c_substr;
    if (LIKELY(ptr == &row)) {
        field.c_substr = NULL;
    }
}

// --- abt_md.FField.c_fconst.EmptyQ
// Return true if index is empty
inline bool abt_md::c_fconst_EmptyQ(abt_md::FField& field) {
    return field.c_fconst_n == 0;
}

// --- abt_md.FField.c_fconst.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FFconst* abt_md::c_fconst_Find(abt_md::FField& field, u32 t) {
    abt_md::FFconst *retval = NULL;
    u64 idx = t;
    u64 lim = field.c_fconst_n;
    if (idx < lim) {
        retval = field.c_fconst_elems[idx];
    }
    return retval;
}

// --- abt_md.FField.c_fconst.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FFconst*> abt_md::c_fconst_Getary(abt_md::FField& field) {
    return algo::aryptr<abt_md::FFconst*>(field.c_fconst_elems, field.c_fconst_n);
}

// --- abt_md.FField.c_fconst.N
// Return number of items in the pointer array
inline i32 abt_md::c_fconst_N(const abt_md::FField& field) {
    return field.c_fconst_n;
}

// --- abt_md.FField.c_fconst.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_fconst_RemoveAll(abt_md::FField& field) {
    for (u32 i = 0; i < field.c_fconst_n; i++) {
        // mark all elements as not-in-array
        field.c_fconst_elems[i]->field_c_fconst_in_ary = false;
    }
    field.c_fconst_n = 0;
}

// --- abt_md.FField.c_fconst.qFind
// Return reference without bounds checking
inline abt_md::FFconst& abt_md::c_fconst_qFind(abt_md::FField& field, u32 idx) {
    return *field.c_fconst_elems[idx];
}

// --- abt_md.FField.c_fconst.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::field_c_fconst_InAryQ(abt_md::FFconst& row) {
    return row.field_c_fconst_in_ary;
}

// --- abt_md.FField.c_fconst.qLast
// Reference to last element without bounds checking
inline abt_md::FFconst& abt_md::c_fconst_qLast(abt_md::FField& field) {
    return *field.c_fconst_elems[field.c_fconst_n-1];
}

// --- abt_md.FField.c_gconst.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool abt_md::c_gconst_InsertMaybe(abt_md::FField& field, abt_md::FGconst& row) {
    abt_md::FGconst* ptr = field.c_gconst;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_gconst = &row;
    }
    return retval;
}

// --- abt_md.FField.c_gconst.Remove
// Remove element from index. If element is not in index, do nothing.
inline void abt_md::c_gconst_Remove(abt_md::FField& field, abt_md::FGconst& row) {
    abt_md::FGconst *ptr = field.c_gconst;
    if (LIKELY(ptr == &row)) {
        field.c_gconst = NULL;
    }
}

// --- abt_md.FField.c_fconst_curs.Reset
inline void abt_md::field_c_fconst_curs_Reset(field_c_fconst_curs &curs, abt_md::FField &parent) {
    curs.elems = parent.c_fconst_elems;
    curs.n_elems = parent.c_fconst_n;
    curs.index = 0;
}

// --- abt_md.FField.c_fconst_curs.ValidQ
// cursor points to valid item
inline bool abt_md::field_c_fconst_curs_ValidQ(field_c_fconst_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FField.c_fconst_curs.Next
// proceed to next item
inline void abt_md::field_c_fconst_curs_Next(field_c_fconst_curs &curs) {
    curs.index++;
}

// --- abt_md.FField.c_fconst_curs.Access
// item access
inline abt_md::FFconst& abt_md::field_c_fconst_curs_Access(field_c_fconst_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FField..Ctor
inline  abt_md::FField::FField() {
    abt_md::FField_Init(*this);
}

// --- abt_md.FField..Dtor
inline  abt_md::FField::~FField() {
    abt_md::FField_Uninit(*this);
}

// --- abt_md.FFileSection..Init
// Set all fields to initial values.
inline void abt_md::FFileSection_Init(abt_md::FFileSection& file_section) {
    file_section.sortkey = i32(0);
    file_section.select = bool(true);
    file_section.firstline = i32(0);
    file_section.p_mdsection = NULL;
    file_section.mdsection_zd_file_section_next = (abt_md::FFileSection*)-1; // (abt_md.FMdsection.zd_file_section) not-in-list
    file_section.mdsection_zd_file_section_prev = NULL; // (abt_md.FMdsection.zd_file_section)
    file_section.bh_file_section_idx = -1; // (abt_md.FDb.bh_file_section) not-in-heap
}

// --- abt_md.FFileSection..Ctor
inline  abt_md::FFileSection::FFileSection() {
    abt_md::FFileSection_Init(*this);
}

// --- abt_md.FFileSection..Dtor
inline  abt_md::FFileSection::~FFileSection() {
    abt_md::FFileSection_Uninit(*this);
}

// --- abt_md.FFinput..Init
// Set all fields to initial values.
inline void abt_md::FFinput_Init(abt_md::FFinput& finput) {
    finput.extrn = bool(false);
    finput.update = bool(false);
    finput.strict = bool(true);
    finput.p_field = NULL;
    finput.ns_zd_finput_next = (abt_md::FFinput*)-1; // (abt_md.FNs.zd_finput) not-in-list
    finput.ns_zd_finput_prev = NULL; // (abt_md.FNs.zd_finput)
}

// --- abt_md.FFinput..Ctor
inline  abt_md::FFinput::FFinput() {
    abt_md::FFinput_Init(*this);
}

// --- abt_md.FFinput..Dtor
inline  abt_md::FFinput::~FFinput() {
    abt_md::FFinput_Uninit(*this);
}

// --- abt_md.FGconst..Init
// Set all fields to initial values.
inline void abt_md::FGconst_Init(abt_md::FGconst& gconst) {
    gconst.wantenum = bool(true);
}

// --- abt_md.FGconst..Ctor
inline  abt_md::FGconst::FGconst() {
    abt_md::FGconst_Init(*this);
}

// --- abt_md.FGconst..Dtor
inline  abt_md::FGconst::~FGconst() {
    abt_md::FGconst_Uninit(*this);
}

// --- abt_md.FGstatic..Init
// Set all fields to initial values.
inline void abt_md::FGstatic_Init(abt_md::FGstatic& gstatic) {
    gstatic.ind_gstatic_next = (abt_md::FGstatic*)-1; // (abt_md.FDb.ind_gstatic) not-in-hash
    gstatic.ind_gstatic_hashval = 0; // stored hash value
}

// --- abt_md.FGstatic..Ctor
inline  abt_md::FGstatic::FGstatic() {
    abt_md::FGstatic_Init(*this);
}

// --- abt_md.FGstatic..Dtor
inline  abt_md::FGstatic::~FGstatic() {
    abt_md::FGstatic_Uninit(*this);
}

// --- abt_md.FHumanText..Init
// Set all fields to initial values.
inline void abt_md::FHumanText_Init(abt_md::FHumanText& human_text) {
    human_text.used = bool(false);
    human_text.human_text_next = (abt_md::FHumanText*)-1; // (abt_md.FDb.human_text) not-in-tpool's freelist
    human_text.ind_human_text_next = (abt_md::FHumanText*)-1; // (abt_md.FDb.ind_human_text) not-in-hash
    human_text.ind_human_text_hashval = 0; // stored hash value
}

// --- abt_md.FHumanText..Ctor
inline  abt_md::FHumanText::FHumanText() {
    abt_md::FHumanText_Init(*this);
}

// --- abt_md.FHumanText..Dtor
inline  abt_md::FHumanText::~FHumanText() {
    abt_md::FHumanText_Uninit(*this);
}

// --- abt_md.FLink..Ctor
inline  abt_md::FLink::FLink() {
}

// --- abt_md.FNs.c_targsrc.EmptyQ
// Return true if index is empty
inline bool abt_md::c_targsrc_EmptyQ(abt_md::FNs& ns) {
    return ns.c_targsrc_n == 0;
}

// --- abt_md.FNs.c_targsrc.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FTargsrc* abt_md::c_targsrc_Find(abt_md::FNs& ns, u32 t) {
    abt_md::FTargsrc *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_targsrc_n;
    if (idx < lim) {
        retval = ns.c_targsrc_elems[idx];
    }
    return retval;
}

// --- abt_md.FNs.c_targsrc.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FTargsrc*> abt_md::c_targsrc_Getary(abt_md::FNs& ns) {
    return algo::aryptr<abt_md::FTargsrc*>(ns.c_targsrc_elems, ns.c_targsrc_n);
}

// --- abt_md.FNs.c_targsrc.N
// Return number of items in the pointer array
inline i32 abt_md::c_targsrc_N(const abt_md::FNs& ns) {
    return ns.c_targsrc_n;
}

// --- abt_md.FNs.c_targsrc.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_targsrc_RemoveAll(abt_md::FNs& ns) {
    for (u32 i = 0; i < ns.c_targsrc_n; i++) {
        // mark all elements as not-in-array
        ns.c_targsrc_elems[i]->ns_c_targsrc_in_ary = false;
    }
    ns.c_targsrc_n = 0;
}

// --- abt_md.FNs.c_targsrc.qFind
// Return reference without bounds checking
inline abt_md::FTargsrc& abt_md::c_targsrc_qFind(abt_md::FNs& ns, u32 idx) {
    return *ns.c_targsrc_elems[idx];
}

// --- abt_md.FNs.c_targsrc.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::ns_c_targsrc_InAryQ(abt_md::FTargsrc& row) {
    return row.ns_c_targsrc_in_ary;
}

// --- abt_md.FNs.c_targsrc.qLast
// Reference to last element without bounds checking
inline abt_md::FTargsrc& abt_md::c_targsrc_qLast(abt_md::FNs& ns) {
    return *ns.c_targsrc_elems[ns.c_targsrc_n-1];
}

// --- abt_md.FNs.c_ctype.EmptyQ
// Return true if index is empty
inline bool abt_md::c_ctype_EmptyQ(abt_md::FNs& ns) {
    return ns.c_ctype_n == 0;
}

// --- abt_md.FNs.c_ctype.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FCtype* abt_md::c_ctype_Find(abt_md::FNs& ns, u32 t) {
    abt_md::FCtype *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_ctype_n;
    if (idx < lim) {
        retval = ns.c_ctype_elems[idx];
    }
    return retval;
}

// --- abt_md.FNs.c_ctype.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FCtype*> abt_md::c_ctype_Getary(abt_md::FNs& ns) {
    return algo::aryptr<abt_md::FCtype*>(ns.c_ctype_elems, ns.c_ctype_n);
}

// --- abt_md.FNs.c_ctype.N
// Return number of items in the pointer array
inline i32 abt_md::c_ctype_N(const abt_md::FNs& ns) {
    return ns.c_ctype_n;
}

// --- abt_md.FNs.c_ctype.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_ctype_RemoveAll(abt_md::FNs& ns) {
    for (u32 i = 0; i < ns.c_ctype_n; i++) {
        // mark all elements as not-in-array
        ns.c_ctype_elems[i]->ns_c_ctype_in_ary = false;
    }
    ns.c_ctype_n = 0;
}

// --- abt_md.FNs.c_ctype.qFind
// Return reference without bounds checking
inline abt_md::FCtype& abt_md::c_ctype_qFind(abt_md::FNs& ns, u32 idx) {
    return *ns.c_ctype_elems[idx];
}

// --- abt_md.FNs.c_ctype.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::ns_c_ctype_InAryQ(abt_md::FCtype& row) {
    return row.ns_c_ctype_in_ary;
}

// --- abt_md.FNs.c_ctype.qLast
// Reference to last element without bounds checking
inline abt_md::FCtype& abt_md::c_ctype_qLast(abt_md::FNs& ns) {
    return *ns.c_ctype_elems[ns.c_ctype_n-1];
}

// --- abt_md.FNs.c_comptest.EmptyQ
// Return true if index is empty
inline bool abt_md::c_comptest_EmptyQ(abt_md::FNs& ns) {
    return ns.c_comptest_n == 0;
}

// --- abt_md.FNs.c_comptest.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FComptest* abt_md::c_comptest_Find(abt_md::FNs& ns, u32 t) {
    abt_md::FComptest *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_comptest_n;
    if (idx < lim) {
        retval = ns.c_comptest_elems[idx];
    }
    return retval;
}

// --- abt_md.FNs.c_comptest.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FComptest*> abt_md::c_comptest_Getary(abt_md::FNs& ns) {
    return algo::aryptr<abt_md::FComptest*>(ns.c_comptest_elems, ns.c_comptest_n);
}

// --- abt_md.FNs.c_comptest.N
// Return number of items in the pointer array
inline i32 abt_md::c_comptest_N(const abt_md::FNs& ns) {
    return ns.c_comptest_n;
}

// --- abt_md.FNs.c_comptest.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_comptest_RemoveAll(abt_md::FNs& ns) {
    for (u32 i = 0; i < ns.c_comptest_n; i++) {
        // mark all elements as not-in-array
        ns.c_comptest_elems[i]->ns_c_comptest_in_ary = false;
    }
    ns.c_comptest_n = 0;
}

// --- abt_md.FNs.c_comptest.qFind
// Return reference without bounds checking
inline abt_md::FComptest& abt_md::c_comptest_qFind(abt_md::FNs& ns, u32 idx) {
    return *ns.c_comptest_elems[idx];
}

// --- abt_md.FNs.c_comptest.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::ns_c_comptest_InAryQ(abt_md::FComptest& row) {
    return row.ns_c_comptest_in_ary;
}

// --- abt_md.FNs.c_comptest.qLast
// Reference to last element without bounds checking
inline abt_md::FComptest& abt_md::c_comptest_qLast(abt_md::FNs& ns) {
    return *ns.c_comptest_elems[ns.c_comptest_n-1];
}

// --- abt_md.FNs.c_target.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool abt_md::c_target_InsertMaybe(abt_md::FNs& ns, abt_md::FTarget& row) {
    abt_md::FTarget* ptr = ns.c_target;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ns.c_target = &row;
    }
    return retval;
}

// --- abt_md.FNs.c_target.Remove
// Remove element from index. If element is not in index, do nothing.
inline void abt_md::c_target_Remove(abt_md::FNs& ns, abt_md::FTarget& row) {
    abt_md::FTarget *ptr = ns.c_target;
    if (LIKELY(ptr == &row)) {
        ns.c_target = NULL;
    }
}

// --- abt_md.FNs.zd_finput.EmptyQ
// Return true if index is empty
inline bool abt_md::zd_finput_EmptyQ(abt_md::FNs& ns) {
    return ns.zd_finput_head == NULL;
}

// --- abt_md.FNs.zd_finput.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline abt_md::FFinput* abt_md::zd_finput_First(abt_md::FNs& ns) {
    abt_md::FFinput *row = NULL;
    row = ns.zd_finput_head;
    return row;
}

// --- abt_md.FNs.zd_finput.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool abt_md::ns_zd_finput_InLlistQ(abt_md::FFinput& row) {
    bool result = false;
    result = !(row.ns_zd_finput_next == (abt_md::FFinput*)-1);
    return result;
}

// --- abt_md.FNs.zd_finput.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline abt_md::FFinput* abt_md::zd_finput_Last(abt_md::FNs& ns) {
    abt_md::FFinput *row = NULL;
    row = ns.zd_finput_tail;
    return row;
}

// --- abt_md.FNs.zd_finput.N
// Return number of items in the linked list
inline i32 abt_md::zd_finput_N(const abt_md::FNs& ns) {
    return ns.zd_finput_n;
}

// --- abt_md.FNs.zd_finput.Next
// Return pointer to next element in the list
inline abt_md::FFinput* abt_md::ns_zd_finput_Next(abt_md::FFinput &row) {
    return row.ns_zd_finput_next;
}

// --- abt_md.FNs.zd_finput.Prev
// Return pointer to previous element in the list
inline abt_md::FFinput* abt_md::ns_zd_finput_Prev(abt_md::FFinput &row) {
    return row.ns_zd_finput_prev;
}

// --- abt_md.FNs.zd_finput.qLast
// Return reference to last element in the index. No bounds checking.
inline abt_md::FFinput& abt_md::zd_finput_qLast(abt_md::FNs& ns) {
    abt_md::FFinput *row = NULL;
    row = ns.zd_finput_tail;
    return *row;
}

// --- abt_md.FNs.c_dispatch.EmptyQ
// Return true if index is empty
inline bool abt_md::c_dispatch_EmptyQ(abt_md::FNs& ns) {
    return ns.c_dispatch_n == 0;
}

// --- abt_md.FNs.c_dispatch.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FDispatch* abt_md::c_dispatch_Find(abt_md::FNs& ns, u32 t) {
    abt_md::FDispatch *retval = NULL;
    u64 idx = t;
    u64 lim = ns.c_dispatch_n;
    if (idx < lim) {
        retval = ns.c_dispatch_elems[idx];
    }
    return retval;
}

// --- abt_md.FNs.c_dispatch.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FDispatch*> abt_md::c_dispatch_Getary(abt_md::FNs& ns) {
    return algo::aryptr<abt_md::FDispatch*>(ns.c_dispatch_elems, ns.c_dispatch_n);
}

// --- abt_md.FNs.c_dispatch.N
// Return number of items in the pointer array
inline i32 abt_md::c_dispatch_N(const abt_md::FNs& ns) {
    return ns.c_dispatch_n;
}

// --- abt_md.FNs.c_dispatch.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_dispatch_RemoveAll(abt_md::FNs& ns) {
    for (u32 i = 0; i < ns.c_dispatch_n; i++) {
        // mark all elements as not-in-array
        ns.c_dispatch_elems[i]->ns_c_dispatch_in_ary = false;
    }
    ns.c_dispatch_n = 0;
}

// --- abt_md.FNs.c_dispatch.qFind
// Return reference without bounds checking
inline abt_md::FDispatch& abt_md::c_dispatch_qFind(abt_md::FNs& ns, u32 idx) {
    return *ns.c_dispatch_elems[idx];
}

// --- abt_md.FNs.c_dispatch.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::ns_c_dispatch_InAryQ(abt_md::FDispatch& row) {
    return row.ns_c_dispatch_in_ary;
}

// --- abt_md.FNs.c_dispatch.qLast
// Reference to last element without bounds checking
inline abt_md::FDispatch& abt_md::c_dispatch_qLast(abt_md::FNs& ns) {
    return *ns.c_dispatch_elems[ns.c_dispatch_n-1];
}

// --- abt_md.FNs.c_targsrc_curs.Reset
inline void abt_md::ns_c_targsrc_curs_Reset(ns_c_targsrc_curs &curs, abt_md::FNs &parent) {
    curs.elems = parent.c_targsrc_elems;
    curs.n_elems = parent.c_targsrc_n;
    curs.index = 0;
}

// --- abt_md.FNs.c_targsrc_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ns_c_targsrc_curs_ValidQ(ns_c_targsrc_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FNs.c_targsrc_curs.Next
// proceed to next item
inline void abt_md::ns_c_targsrc_curs_Next(ns_c_targsrc_curs &curs) {
    curs.index++;
}

// --- abt_md.FNs.c_targsrc_curs.Access
// item access
inline abt_md::FTargsrc& abt_md::ns_c_targsrc_curs_Access(ns_c_targsrc_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FNs.c_ctype_curs.Reset
inline void abt_md::ns_c_ctype_curs_Reset(ns_c_ctype_curs &curs, abt_md::FNs &parent) {
    curs.elems = parent.c_ctype_elems;
    curs.n_elems = parent.c_ctype_n;
    curs.index = 0;
}

// --- abt_md.FNs.c_ctype_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ns_c_ctype_curs_ValidQ(ns_c_ctype_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FNs.c_ctype_curs.Next
// proceed to next item
inline void abt_md::ns_c_ctype_curs_Next(ns_c_ctype_curs &curs) {
    curs.index++;
}

// --- abt_md.FNs.c_ctype_curs.Access
// item access
inline abt_md::FCtype& abt_md::ns_c_ctype_curs_Access(ns_c_ctype_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FNs.c_comptest_curs.Reset
inline void abt_md::ns_c_comptest_curs_Reset(ns_c_comptest_curs &curs, abt_md::FNs &parent) {
    curs.elems = parent.c_comptest_elems;
    curs.n_elems = parent.c_comptest_n;
    curs.index = 0;
}

// --- abt_md.FNs.c_comptest_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ns_c_comptest_curs_ValidQ(ns_c_comptest_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FNs.c_comptest_curs.Next
// proceed to next item
inline void abt_md::ns_c_comptest_curs_Next(ns_c_comptest_curs &curs) {
    curs.index++;
}

// --- abt_md.FNs.c_comptest_curs.Access
// item access
inline abt_md::FComptest& abt_md::ns_c_comptest_curs_Access(ns_c_comptest_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FNs.zd_finput_curs.Reset
// cursor points to valid item
inline void abt_md::ns_zd_finput_curs_Reset(ns_zd_finput_curs &curs, abt_md::FNs &parent) {
    curs.row = parent.zd_finput_head;
}

// --- abt_md.FNs.zd_finput_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ns_zd_finput_curs_ValidQ(ns_zd_finput_curs &curs) {
    return curs.row != NULL;
}

// --- abt_md.FNs.zd_finput_curs.Next
// proceed to next item
inline void abt_md::ns_zd_finput_curs_Next(ns_zd_finput_curs &curs) {
    abt_md::FFinput *next = (*curs.row).ns_zd_finput_next;
    curs.row = next;
}

// --- abt_md.FNs.zd_finput_curs.Access
// item access
inline abt_md::FFinput& abt_md::ns_zd_finput_curs_Access(ns_zd_finput_curs &curs) {
    return *curs.row;
}

// --- abt_md.FNs.c_dispatch_curs.Reset
inline void abt_md::ns_c_dispatch_curs_Reset(ns_c_dispatch_curs &curs, abt_md::FNs &parent) {
    curs.elems = parent.c_dispatch_elems;
    curs.n_elems = parent.c_dispatch_n;
    curs.index = 0;
}

// --- abt_md.FNs.c_dispatch_curs.ValidQ
// cursor points to valid item
inline bool abt_md::ns_c_dispatch_curs_ValidQ(ns_c_dispatch_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FNs.c_dispatch_curs.Next
// proceed to next item
inline void abt_md::ns_c_dispatch_curs_Next(ns_c_dispatch_curs &curs) {
    curs.index++;
}

// --- abt_md.FNs.c_dispatch_curs.Access
// item access
inline abt_md::FDispatch& abt_md::ns_c_dispatch_curs_Access(ns_c_dispatch_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FNs..Ctor
inline  abt_md::FNs::FNs() {
    abt_md::FNs_Init(*this);
}

// --- abt_md.FNs..Dtor
inline  abt_md::FNs::~FNs() {
    abt_md::FNs_Uninit(*this);
}

// --- abt_md.FNstype..Init
// Set all fields to initial values.
inline void abt_md::FNstype_Init(abt_md::FNstype& nstype) {
    nstype.ind_nstype_next = (abt_md::FNstype*)-1; // (abt_md.FDb.ind_nstype) not-in-hash
    nstype.ind_nstype_hashval = 0; // stored hash value
}

// --- abt_md.FNstype..Ctor
inline  abt_md::FNstype::FNstype() {
    abt_md::FNstype_Init(*this);
}

// --- abt_md.FNstype..Dtor
inline  abt_md::FNstype::~FNstype() {
    abt_md::FNstype_Uninit(*this);
}

// --- abt_md.FReadmefile..Ctor
inline  abt_md::FReadmefile::FReadmefile() {
    abt_md::FReadmefile_Init(*this);
}

// --- abt_md.FReadmefile..Dtor
inline  abt_md::FReadmefile::~FReadmefile() {
    abt_md::FReadmefile_Uninit(*this);
}

// --- abt_md.FReadmesort..Init
// Set all fields to initial values.
inline void abt_md::FReadmesort_Init(abt_md::FReadmesort& readmesort) {
    readmesort.ind_readmesort_next = (abt_md::FReadmesort*)-1; // (abt_md.FDb.ind_readmesort) not-in-hash
    readmesort.ind_readmesort_hashval = 0; // stored hash value
}

// --- abt_md.FReadmesort..Ctor
inline  abt_md::FReadmesort::FReadmesort() {
    abt_md::FReadmesort_Init(*this);
}

// --- abt_md.FReadmesort..Dtor
inline  abt_md::FReadmesort::~FReadmesort() {
    abt_md::FReadmesort_Uninit(*this);
}

// --- abt_md.FReftype..Ctor
inline  abt_md::FReftype::FReftype() {
    abt_md::FReftype_Init(*this);
}

// --- abt_md.FScriptfile..Init
// Set all fields to initial values.
inline void abt_md::FScriptfile_Init(abt_md::FScriptfile& scriptfile) {
    scriptfile.ind_scriptfile_next = (abt_md::FScriptfile*)-1; // (abt_md.FDb.ind_scriptfile) not-in-hash
    scriptfile.ind_scriptfile_hashval = 0; // stored hash value
}

// --- abt_md.FScriptfile..Ctor
inline  abt_md::FScriptfile::FScriptfile() {
    abt_md::FScriptfile_Init(*this);
}

// --- abt_md.FScriptfile..Dtor
inline  abt_md::FScriptfile::~FScriptfile() {
    abt_md::FScriptfile_Uninit(*this);
}

// --- abt_md.FSsimfile..Init
// Set all fields to initial values.
inline void abt_md::FSsimfile_Init(abt_md::FSsimfile& ssimfile) {
    ssimfile.p_ctype = NULL;
    ssimfile.ind_ssimfile_next = (abt_md::FSsimfile*)-1; // (abt_md.FDb.ind_ssimfile) not-in-hash
    ssimfile.ind_ssimfile_hashval = 0; // stored hash value
}

// --- abt_md.FSsimfile..Ctor
inline  abt_md::FSsimfile::FSsimfile() {
    abt_md::FSsimfile_Init(*this);
}

// --- abt_md.FSsimfile..Dtor
inline  abt_md::FSsimfile::~FSsimfile() {
    abt_md::FSsimfile_Uninit(*this);
}

// --- abt_md.FSubstr..Init
// Set all fields to initial values.
inline void abt_md::FSubstr_Init(abt_md::FSubstr& substr) {
    substr.p_srcfield = NULL;
}

// --- abt_md.FSubstr..Ctor
inline  abt_md::FSubstr::FSubstr() {
    abt_md::FSubstr_Init(*this);
}

// --- abt_md.FSubstr..Dtor
inline  abt_md::FSubstr::~FSubstr() {
    abt_md::FSubstr_Uninit(*this);
}

// --- abt_md.FTargdep..Init
// Set all fields to initial values.
inline void abt_md::FTargdep_Init(abt_md::FTargdep& targdep) {
    targdep.p_parent = NULL;
    targdep.target_c_targdep_in_ary = bool(false);
}

// --- abt_md.FTargdep..Ctor
inline  abt_md::FTargdep::FTargdep() {
    abt_md::FTargdep_Init(*this);
}

// --- abt_md.FTargdep..Dtor
inline  abt_md::FTargdep::~FTargdep() {
    abt_md::FTargdep_Uninit(*this);
}

// --- abt_md.FTarget.c_targdep.EmptyQ
// Return true if index is empty
inline bool abt_md::c_targdep_EmptyQ(abt_md::FTarget& target) {
    return target.c_targdep_n == 0;
}

// --- abt_md.FTarget.c_targdep.Find
// Look up row by row id. Return NULL if out of range
inline abt_md::FTargdep* abt_md::c_targdep_Find(abt_md::FTarget& target, u32 t) {
    abt_md::FTargdep *retval = NULL;
    u64 idx = t;
    u64 lim = target.c_targdep_n;
    if (idx < lim) {
        retval = target.c_targdep_elems[idx];
    }
    return retval;
}

// --- abt_md.FTarget.c_targdep.Getary
// Return array of pointers
inline algo::aryptr<abt_md::FTargdep*> abt_md::c_targdep_Getary(abt_md::FTarget& target) {
    return algo::aryptr<abt_md::FTargdep*>(target.c_targdep_elems, target.c_targdep_n);
}

// --- abt_md.FTarget.c_targdep.N
// Return number of items in the pointer array
inline i32 abt_md::c_targdep_N(const abt_md::FTarget& target) {
    return target.c_targdep_n;
}

// --- abt_md.FTarget.c_targdep.RemoveAll
// Empty the index. (The rows are not deleted)
inline void abt_md::c_targdep_RemoveAll(abt_md::FTarget& target) {
    for (u32 i = 0; i < target.c_targdep_n; i++) {
        // mark all elements as not-in-array
        target.c_targdep_elems[i]->target_c_targdep_in_ary = false;
    }
    target.c_targdep_n = 0;
}

// --- abt_md.FTarget.c_targdep.qFind
// Return reference without bounds checking
inline abt_md::FTargdep& abt_md::c_targdep_qFind(abt_md::FTarget& target, u32 idx) {
    return *target.c_targdep_elems[idx];
}

// --- abt_md.FTarget.c_targdep.InAryQ
// True if row is in any ptrary instance
inline bool abt_md::target_c_targdep_InAryQ(abt_md::FTargdep& row) {
    return row.target_c_targdep_in_ary;
}

// --- abt_md.FTarget.c_targdep.qLast
// Reference to last element without bounds checking
inline abt_md::FTargdep& abt_md::c_targdep_qLast(abt_md::FTarget& target) {
    return *target.c_targdep_elems[target.c_targdep_n-1];
}

// --- abt_md.FTarget..Init
// Set all fields to initial values.
inline void abt_md::FTarget_Init(abt_md::FTarget& target) {
    target.c_targdep_elems = NULL; // (abt_md.FTarget.c_targdep)
    target.c_targdep_n = 0; // (abt_md.FTarget.c_targdep)
    target.c_targdep_max = 0; // (abt_md.FTarget.c_targdep)
    target.p_ns = NULL;
    target.ind_target_next = (abt_md::FTarget*)-1; // (abt_md.FDb.ind_target) not-in-hash
    target.ind_target_hashval = 0; // stored hash value
}

// --- abt_md.FTarget.c_targdep_curs.Reset
inline void abt_md::target_c_targdep_curs_Reset(target_c_targdep_curs &curs, abt_md::FTarget &parent) {
    curs.elems = parent.c_targdep_elems;
    curs.n_elems = parent.c_targdep_n;
    curs.index = 0;
}

// --- abt_md.FTarget.c_targdep_curs.ValidQ
// cursor points to valid item
inline bool abt_md::target_c_targdep_curs_ValidQ(target_c_targdep_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- abt_md.FTarget.c_targdep_curs.Next
// proceed to next item
inline void abt_md::target_c_targdep_curs_Next(target_c_targdep_curs &curs) {
    curs.index++;
}

// --- abt_md.FTarget.c_targdep_curs.Access
// item access
inline abt_md::FTargdep& abt_md::target_c_targdep_curs_Access(target_c_targdep_curs &curs) {
    return *curs.elems[curs.index];
}

// --- abt_md.FTarget..Ctor
inline  abt_md::FTarget::FTarget() {
    abt_md::FTarget_Init(*this);
}

// --- abt_md.FTarget..Dtor
inline  abt_md::FTarget::~FTarget() {
    abt_md::FTarget_Uninit(*this);
}

// --- abt_md.FTargsrc..Init
// Set all fields to initial values.
inline void abt_md::FTargsrc_Init(abt_md::FTargsrc& targsrc) {
    targsrc.ns_c_targsrc_in_ary = bool(false);
}

// --- abt_md.FTargsrc..Ctor
inline  abt_md::FTargsrc::FTargsrc() {
    abt_md::FTargsrc_Init(*this);
}

// --- abt_md.FTargsrc..Dtor
inline  abt_md::FTargsrc::~FTargsrc() {
    abt_md::FTargsrc_Uninit(*this);
}

// --- abt_md.FTclass..Init
// Set all fields to initial values.
inline void abt_md::FTclass_Init(abt_md::FTclass& tclass) {
    tclass.ind_tclass_next = (abt_md::FTclass*)-1; // (abt_md.FDb.ind_tclass) not-in-hash
    tclass.ind_tclass_hashval = 0; // stored hash value
}

// --- abt_md.FTclass..Ctor
inline  abt_md::FTclass::FTclass() {
    abt_md::FTclass_Init(*this);
}

// --- abt_md.FTclass..Dtor
inline  abt_md::FTclass::~FTclass() {
    abt_md::FTclass_Uninit(*this);
}

// --- abt_md.FieldId.value.GetEnum
// Get value of field as enum type
inline abt_md_FieldIdEnum abt_md::value_GetEnum(const abt_md::FieldId& parent) {
    return abt_md_FieldIdEnum(parent.value);
}

// --- abt_md.FieldId.value.SetEnum
// Set value of field from enum type.
inline void abt_md::value_SetEnum(abt_md::FieldId& parent, abt_md_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- abt_md.FieldId.value.Cast
inline  abt_md::FieldId::operator abt_md_FieldIdEnum() const {
    return abt_md_FieldIdEnum((*this).value);
}

// --- abt_md.FieldId..Init
// Set all fields to initial values.
inline void abt_md::FieldId_Init(abt_md::FieldId& parent) {
    parent.value = i32(-1);
}

// --- abt_md.FieldId..Ctor
inline  abt_md::FieldId::FieldId() {
    abt_md::FieldId_Init(*this);
}

// --- abt_md.FieldId..FieldwiseCtor
inline  abt_md::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- abt_md.FieldId..EnumCtor
inline  abt_md::FieldId::FieldId(abt_md_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- abt_md.TableId.value.GetEnum
// Get value of field as enum type
inline abt_md_TableIdEnum abt_md::value_GetEnum(const abt_md::TableId& parent) {
    return abt_md_TableIdEnum(parent.value);
}

// --- abt_md.TableId.value.SetEnum
// Set value of field from enum type.
inline void abt_md::value_SetEnum(abt_md::TableId& parent, abt_md_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- abt_md.TableId.value.Cast
inline  abt_md::TableId::operator abt_md_TableIdEnum() const {
    return abt_md_TableIdEnum((*this).value);
}

// --- abt_md.TableId..Init
// Set all fields to initial values.
inline void abt_md::TableId_Init(abt_md::TableId& parent) {
    parent.value = i32(-1);
}

// --- abt_md.TableId..Ctor
inline  abt_md::TableId::TableId() {
    abt_md::TableId_Init(*this);
}

// --- abt_md.TableId..FieldwiseCtor
inline  abt_md::TableId::TableId(i32 in_value)
    : value(in_value)
 {
}

// --- abt_md.TableId..EnumCtor
inline  abt_md::TableId::TableId(abt_md_TableIdEnum arg) {
    this->value = i32(arg);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const abt_md::trace &row) {// cfmt:abt_md.trace.String
    abt_md::trace_Print(const_cast<abt_md::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const abt_md::FieldId &row) {// cfmt:abt_md.FieldId.String
    abt_md::FieldId_Print(const_cast<abt_md::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const abt_md::TableId &row) {// cfmt:abt_md.TableId.String
    abt_md::TableId_Print(const_cast<abt_md::TableId&>(row), str);
    return str;
}
