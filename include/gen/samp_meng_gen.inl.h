//
// include/gen/samp_meng_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude

// --- samp_meng.CancelOrderMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of CancelOrderMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of CancelOrderMsg.
// If not successful, quietly return NULL.
inline samp_meng::CancelOrderMsg* samp_meng::CancelOrderMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (3);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::CancelOrderMsg);
    return cond ? reinterpret_cast<samp_meng::CancelOrderMsg*>(&hdr) : NULL;
}

// --- samp_meng.CancelOrderMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::CancelOrderMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.CancelOrderMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::CancelOrderMsg& parent) {
    return i32(const_cast<samp_meng::CancelOrderMsg&>(parent).length);
}

// --- samp_meng.CancelOrderMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::CancelOrderMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::CancelOrderMsg&>(row).length));
}

// --- samp_meng.CancelOrderMsg..Init
// Set all fields to initial values.
inline void samp_meng::CancelOrderMsg_Init(samp_meng::CancelOrderMsg& parent) {
    parent.type = u8(3);
    parent.length = u8(ssizeof(parent) + (0));
    parent.order = u64(0);
}

// --- samp_meng.CancelOrderMsg..Ctor
inline  samp_meng::CancelOrderMsg::CancelOrderMsg() {
    samp_meng::CancelOrderMsg_Init(*this);
}

// --- samp_meng.CancelOrderMsg..FieldwiseCtor
inline  samp_meng::CancelOrderMsg::CancelOrderMsg(u64 in_order)
    : order(in_order)
 {
    this->type = u8(3);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.CancelReqMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of CancelReqMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of CancelReqMsg.
// If not successful, quietly return NULL.
inline samp_meng::CancelReqMsg* samp_meng::CancelReqMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (11);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::CancelReqMsg);
    return cond ? reinterpret_cast<samp_meng::CancelReqMsg*>(&hdr) : NULL;
}

// --- samp_meng.CancelReqMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::CancelReqMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.CancelReqMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::CancelReqMsg& parent) {
    return i32(const_cast<samp_meng::CancelReqMsg&>(parent).length);
}

// --- samp_meng.CancelReqMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::CancelReqMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::CancelReqMsg&>(row).length));
}

// --- samp_meng.CancelReqMsg..Init
// Set all fields to initial values.
inline void samp_meng::CancelReqMsg_Init(samp_meng::CancelReqMsg& parent) {
    parent.type = u8(11);
    parent.length = u8(ssizeof(parent) + (0));
    parent.order = u64(0);
}

// --- samp_meng.CancelReqMsg..Ctor
inline  samp_meng::CancelReqMsg::CancelReqMsg() {
    samp_meng::CancelReqMsg_Init(*this);
}

// --- samp_meng.CancelReqMsg..FieldwiseCtor
inline  samp_meng::CancelReqMsg::CancelReqMsg(u64 in_order)
    : order(in_order)
 {
    this->type = u8(11);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.trace..Ctor
inline  samp_meng::trace::trace() {
}

// --- samp_meng.FDb.fdin.EmptyQ
// Return true if index is empty
inline bool samp_meng::fdin_EmptyQ() {
    return _db.fdin_n == 0;
}

// --- samp_meng.FDb.fdin.Find
// Look up row by row id. Return NULL if out of range
inline samp_meng::FFdin* samp_meng::fdin_Find(u64 t) {
    samp_meng::FFdin *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fdin_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fdin_lary[bsr][index];
    }
    return retval;
}

// --- samp_meng.FDb.fdin.Last
// Return pointer to last element of array, or NULL if array is empty
inline samp_meng::FFdin* samp_meng::fdin_Last() {
    return fdin_Find(u64(_db.fdin_n-1));
}

// --- samp_meng.FDb.fdin.N
// Return number of items in the pool
inline i32 samp_meng::fdin_N() {
    return _db.fdin_n;
}

// --- samp_meng.FDb.fdin.qFind
// 'quick' Access row by row id. No bounds checking.
inline samp_meng::FFdin& samp_meng::fdin_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fdin_lary[bsr][index];
}

// --- samp_meng.FDb.cd_fdin_eof.EmptyQ
// Return true if index is empty
inline bool samp_meng::cd_fdin_eof_EmptyQ() {
    return _db.cd_fdin_eof_head == NULL;
}

// --- samp_meng.FDb.cd_fdin_eof.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline samp_meng::FFdin* samp_meng::cd_fdin_eof_First() {
    samp_meng::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head;
    return row;
}

// --- samp_meng.FDb.cd_fdin_eof.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool samp_meng::cd_fdin_eof_InLlistQ(samp_meng::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_eof_next == (samp_meng::FFdin*)-1);
    return result;
}

// --- samp_meng.FDb.cd_fdin_eof.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline samp_meng::FFdin* samp_meng::cd_fdin_eof_Last() {
    samp_meng::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head ? _db.cd_fdin_eof_head->cd_fdin_eof_prev : NULL;
    return row;
}

// --- samp_meng.FDb.cd_fdin_eof.N
// Return number of items in the linked list
inline i32 samp_meng::cd_fdin_eof_N() {
    return _db.cd_fdin_eof_n;
}

// --- samp_meng.FDb.cd_fdin_eof.Next
// Return pointer to next element in the list
inline samp_meng::FFdin* samp_meng::cd_fdin_eof_Next(samp_meng::FFdin &row) {
    return row.cd_fdin_eof_next;
}

// --- samp_meng.FDb.cd_fdin_eof.Prev
// Return pointer to previous element in the list
inline samp_meng::FFdin* samp_meng::cd_fdin_eof_Prev(samp_meng::FFdin &row) {
    return row.cd_fdin_eof_prev;
}

// --- samp_meng.FDb.cd_fdin_eof.qLast
// Return reference to last element in the index. No bounds checking.
inline samp_meng::FFdin& samp_meng::cd_fdin_eof_qLast() {
    samp_meng::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head ? _db.cd_fdin_eof_head->cd_fdin_eof_prev : NULL;
    return *row;
}

// --- samp_meng.FDb.symbol.EmptyQ
// Return true if index is empty
inline bool samp_meng::symbol_EmptyQ() {
    return _db.symbol_n == 0;
}

// --- samp_meng.FDb.symbol.Find
// Look up row by row id. Return NULL if out of range
inline samp_meng::FSymbol* samp_meng::symbol_Find(u64 t) {
    samp_meng::FSymbol *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.symbol_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.symbol_lary[bsr][index];
    }
    return retval;
}

// --- samp_meng.FDb.symbol.Last
// Return pointer to last element of array, or NULL if array is empty
inline samp_meng::FSymbol* samp_meng::symbol_Last() {
    return symbol_Find(u64(_db.symbol_n-1));
}

// --- samp_meng.FDb.symbol.N
// Return number of items in the pool
inline i32 samp_meng::symbol_N() {
    return _db.symbol_n;
}

// --- samp_meng.FDb.symbol.qFind
// 'quick' Access row by row id. No bounds checking.
inline samp_meng::FSymbol& samp_meng::symbol_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.symbol_lary[bsr][index];
}

// --- samp_meng.FDb.cd_fdin_read.EmptyQ
// Return true if index is empty
inline bool samp_meng::cd_fdin_read_EmptyQ() {
    return _db.cd_fdin_read_head == NULL;
}

// --- samp_meng.FDb.cd_fdin_read.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline samp_meng::FFdin* samp_meng::cd_fdin_read_First() {
    samp_meng::FFdin *row = NULL;
    row = _db.cd_fdin_read_head;
    return row;
}

// --- samp_meng.FDb.cd_fdin_read.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool samp_meng::cd_fdin_read_InLlistQ(samp_meng::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_read_next == (samp_meng::FFdin*)-1);
    return result;
}

// --- samp_meng.FDb.cd_fdin_read.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline samp_meng::FFdin* samp_meng::cd_fdin_read_Last() {
    samp_meng::FFdin *row = NULL;
    row = _db.cd_fdin_read_head ? _db.cd_fdin_read_head->cd_fdin_read_prev : NULL;
    return row;
}

// --- samp_meng.FDb.cd_fdin_read.N
// Return number of items in the linked list
inline i32 samp_meng::cd_fdin_read_N() {
    return _db.cd_fdin_read_n;
}

// --- samp_meng.FDb.cd_fdin_read.Next
// Return pointer to next element in the list
inline samp_meng::FFdin* samp_meng::cd_fdin_read_Next(samp_meng::FFdin &row) {
    return row.cd_fdin_read_next;
}

// --- samp_meng.FDb.cd_fdin_read.Prev
// Return pointer to previous element in the list
inline samp_meng::FFdin* samp_meng::cd_fdin_read_Prev(samp_meng::FFdin &row) {
    return row.cd_fdin_read_prev;
}

// --- samp_meng.FDb.cd_fdin_read.qLast
// Return reference to last element in the index. No bounds checking.
inline samp_meng::FFdin& samp_meng::cd_fdin_read_qLast() {
    samp_meng::FFdin *row = NULL;
    row = _db.cd_fdin_read_head ? _db.cd_fdin_read_head->cd_fdin_read_prev : NULL;
    return *row;
}

// --- samp_meng.FDb.ind_symbol.EmptyQ
// Return true if hash is empty
inline bool samp_meng::ind_symbol_EmptyQ() {
    return _db.ind_symbol_n == 0;
}

// --- samp_meng.FDb.ind_symbol.N
// Return number of items in the hash
inline i32 samp_meng::ind_symbol_N() {
    return _db.ind_symbol_n;
}

// --- samp_meng.FDb.ind_order.EmptyQ
// Return true if hash is empty
inline bool samp_meng::ind_order_EmptyQ() {
    return _db.ind_order_n == 0;
}

// --- samp_meng.FDb.ind_order.N
// Return number of items in the hash
inline i32 samp_meng::ind_order_N() {
    return _db.ind_order_n;
}

// --- samp_meng.FDb.user.EmptyQ
// Return true if index is empty
inline bool samp_meng::user_EmptyQ() {
    return _db.user_n == 0;
}

// --- samp_meng.FDb.user.Find
// Look up row by row id. Return NULL if out of range
inline samp_meng::FUser* samp_meng::user_Find(u64 t) {
    samp_meng::FUser *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.user_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.user_lary[bsr][index];
    }
    return retval;
}

// --- samp_meng.FDb.user.Last
// Return pointer to last element of array, or NULL if array is empty
inline samp_meng::FUser* samp_meng::user_Last() {
    return user_Find(u64(_db.user_n-1));
}

// --- samp_meng.FDb.user.N
// Return number of items in the pool
inline i32 samp_meng::user_N() {
    return _db.user_n;
}

// --- samp_meng.FDb.user.qFind
// 'quick' Access row by row id. No bounds checking.
inline samp_meng::FUser& samp_meng::user_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.user_lary[bsr][index];
}

// --- samp_meng.FDb.ind_user.EmptyQ
// Return true if hash is empty
inline bool samp_meng::ind_user_EmptyQ() {
    return _db.ind_user_n == 0;
}

// --- samp_meng.FDb.ind_user.N
// Return number of items in the hash
inline i32 samp_meng::ind_user_N() {
    return _db.ind_user_n;
}

// --- samp_meng.FDb.fdin_curs.Reset
// cursor points to valid item
inline void samp_meng::_db_fdin_curs_Reset(_db_fdin_curs &curs, samp_meng::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- samp_meng.FDb.fdin_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::_db_fdin_curs_ValidQ(_db_fdin_curs &curs) {
    return curs.index < _db.fdin_n;
}

// --- samp_meng.FDb.fdin_curs.Next
// proceed to next item
inline void samp_meng::_db_fdin_curs_Next(_db_fdin_curs &curs) {
    curs.index++;
}

// --- samp_meng.FDb.fdin_curs.Access
// item access
inline samp_meng::FFdin& samp_meng::_db_fdin_curs_Access(_db_fdin_curs &curs) {
    return fdin_qFind(u64(curs.index));
}

// --- samp_meng.FDb.cd_fdin_eof_curs.Reset
// cursor points to valid item
inline void samp_meng::_db_cd_fdin_eof_curs_Reset(_db_cd_fdin_eof_curs &curs, samp_meng::FDb &parent) {
    curs.row = parent.cd_fdin_eof_head;
    curs.head = &parent.cd_fdin_eof_head;
}

// --- samp_meng.FDb.cd_fdin_eof_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::_db_cd_fdin_eof_curs_ValidQ(_db_cd_fdin_eof_curs &curs) {
    return curs.row != NULL;
}

// --- samp_meng.FDb.cd_fdin_eof_curs.Next
// proceed to next item
inline void samp_meng::_db_cd_fdin_eof_curs_Next(_db_cd_fdin_eof_curs &curs) {
    samp_meng::FFdin *next = (*curs.row).cd_fdin_eof_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- samp_meng.FDb.cd_fdin_eof_curs.Access
// item access
inline samp_meng::FFdin& samp_meng::_db_cd_fdin_eof_curs_Access(_db_cd_fdin_eof_curs &curs) {
    return *curs.row;
}

// --- samp_meng.FDb.symbol_curs.Reset
// cursor points to valid item
inline void samp_meng::_db_symbol_curs_Reset(_db_symbol_curs &curs, samp_meng::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- samp_meng.FDb.symbol_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::_db_symbol_curs_ValidQ(_db_symbol_curs &curs) {
    return curs.index < _db.symbol_n;
}

// --- samp_meng.FDb.symbol_curs.Next
// proceed to next item
inline void samp_meng::_db_symbol_curs_Next(_db_symbol_curs &curs) {
    curs.index++;
}

// --- samp_meng.FDb.symbol_curs.Access
// item access
inline samp_meng::FSymbol& samp_meng::_db_symbol_curs_Access(_db_symbol_curs &curs) {
    return symbol_qFind(u64(curs.index));
}

// --- samp_meng.FDb.cd_fdin_read_curs.Reset
// cursor points to valid item
inline void samp_meng::_db_cd_fdin_read_curs_Reset(_db_cd_fdin_read_curs &curs, samp_meng::FDb &parent) {
    curs.row = parent.cd_fdin_read_head;
    curs.head = &parent.cd_fdin_read_head;
}

// --- samp_meng.FDb.cd_fdin_read_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::_db_cd_fdin_read_curs_ValidQ(_db_cd_fdin_read_curs &curs) {
    return curs.row != NULL;
}

// --- samp_meng.FDb.cd_fdin_read_curs.Next
// proceed to next item
inline void samp_meng::_db_cd_fdin_read_curs_Next(_db_cd_fdin_read_curs &curs) {
    samp_meng::FFdin *next = (*curs.row).cd_fdin_read_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- samp_meng.FDb.cd_fdin_read_curs.Access
// item access
inline samp_meng::FFdin& samp_meng::_db_cd_fdin_read_curs_Access(_db_cd_fdin_read_curs &curs) {
    return *curs.row;
}

// --- samp_meng.FDb.user_curs.Reset
// cursor points to valid item
inline void samp_meng::_db_user_curs_Reset(_db_user_curs &curs, samp_meng::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- samp_meng.FDb.user_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::_db_user_curs_ValidQ(_db_user_curs &curs) {
    return curs.index < _db.user_n;
}

// --- samp_meng.FDb.user_curs.Next
// proceed to next item
inline void samp_meng::_db_user_curs_Next(_db_user_curs &curs) {
    curs.index++;
}

// --- samp_meng.FDb.user_curs.Access
// item access
inline samp_meng::FUser& samp_meng::_db_user_curs_Access(_db_user_curs &curs) {
    return user_qFind(u64(curs.index));
}

// --- samp_meng.FFdin.in.Max
// Return max. number of bytes in the buffer.
inline i32 samp_meng::in_Max(samp_meng::FFdin& fdin) {
    return 8192;
    (void)fdin;//only to avoid -Wunused-parameter
}

// --- samp_meng.FFdin.in.N
// Return number of bytes in the buffer.
inline i32 samp_meng::in_N(samp_meng::FFdin& fdin) {
    return fdin.in_end - fdin.in_start;
}

// --- samp_meng.FFdin..Ctor
inline  samp_meng::FFdin::FFdin() {
    samp_meng::FFdin_Init(*this);
    // added because samp_meng.FFdin.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}

// --- samp_meng.FFdin..Dtor
inline  samp_meng::FFdin::~FFdin() {
    samp_meng::FFdin_Uninit(*this);
}

// --- samp_meng.I64Price8.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void samp_meng::value_qSetDouble(samp_meng::I64Price8& parent, double val) {
    double intval = val * 100000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- samp_meng.I64Price8.value.GetDouble
inline double samp_meng::value_GetDouble(const samp_meng::I64Price8& parent) {
    double ret;
    ret = parent.value / double(100000000);
    return ret;
}

// --- samp_meng.I64Price8.value.GetInt
// Return integer portion (divide number by 100000000)
inline i64 samp_meng::value_GetInt(const samp_meng::I64Price8& parent) {
    i64 ret;
    ret = parent.value / 100000000;
    return ret;
}

// --- samp_meng.I64Price8.value.GetScale
// Return constant 100000000
inline i64 samp_meng::I64Price8_GetScale() {
    return 100000000;
}

// --- samp_meng.I64Price8..Hash
inline u32 samp_meng::I64Price8_Hash(u32 prev, samp_meng::I64Price8 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- samp_meng.I64Price8..EqOp
inline bool samp_meng::I64Price8::operator ==(const samp_meng::I64Price8 &rhs) const {
    return samp_meng::I64Price8_Eq(const_cast<samp_meng::I64Price8&>(*this),const_cast<samp_meng::I64Price8&>(rhs));
}

// --- samp_meng.I64Price8..NeOp
inline bool samp_meng::I64Price8::operator !=(const samp_meng::I64Price8 &rhs) const {
    return !samp_meng::I64Price8_Eq(const_cast<samp_meng::I64Price8&>(*this),const_cast<samp_meng::I64Price8&>(rhs));
}

// --- samp_meng.I64Price8..LtOp
inline bool samp_meng::I64Price8::operator <(const samp_meng::I64Price8 &rhs) const {
    return samp_meng::I64Price8_Lt(const_cast<samp_meng::I64Price8&>(*this),const_cast<samp_meng::I64Price8&>(rhs));
}

// --- samp_meng.I64Price8..GtOp
inline bool samp_meng::I64Price8::operator >(const samp_meng::I64Price8 &rhs) const {
    return samp_meng::I64Price8_Lt(const_cast<samp_meng::I64Price8&>(rhs),const_cast<samp_meng::I64Price8&>(*this));
}

// --- samp_meng.I64Price8..LeOp
inline bool samp_meng::I64Price8::operator <=(const samp_meng::I64Price8 &rhs) const {
    return !samp_meng::I64Price8_Lt(const_cast<samp_meng::I64Price8&>(rhs),const_cast<samp_meng::I64Price8&>(*this));
}

// --- samp_meng.I64Price8..GeOp
inline bool samp_meng::I64Price8::operator >=(const samp_meng::I64Price8 &rhs) const {
    return !samp_meng::I64Price8_Lt(const_cast<samp_meng::I64Price8&>(*this),const_cast<samp_meng::I64Price8&>(rhs));
}

// --- samp_meng.I64Price8..Lt
inline bool samp_meng::I64Price8_Lt(samp_meng::I64Price8 lhs, samp_meng::I64Price8 rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- samp_meng.I64Price8..Cmp
inline i32 samp_meng::I64Price8_Cmp(samp_meng::I64Price8 lhs, samp_meng::I64Price8 rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- samp_meng.I64Price8..Init
// Set all fields to initial values.
inline void samp_meng::I64Price8_Init(samp_meng::I64Price8& parent) {
    parent.value = i64(0);
}

// --- samp_meng.I64Price8..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool samp_meng::I64Price8_UpdateMax(samp_meng::I64Price8 &lhs, samp_meng::I64Price8 rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- samp_meng.I64Price8..Min
// Return the lesser of two values
inline samp_meng::I64Price8 samp_meng::I64Price8_Min(samp_meng::I64Price8 lhs, samp_meng::I64Price8 rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- samp_meng.I64Price8..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool samp_meng::I64Price8_UpdateMin(samp_meng::I64Price8 &lhs, samp_meng::I64Price8 rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- samp_meng.I64Price8..Max
// Return the greater of two values
inline samp_meng::I64Price8 samp_meng::I64Price8_Max(samp_meng::I64Price8 lhs, samp_meng::I64Price8 rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- samp_meng.I64Price8..Eq
inline bool samp_meng::I64Price8_Eq(samp_meng::I64Price8 lhs, samp_meng::I64Price8 rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- samp_meng.I64Price8..Update
// Set value. Return true if new value is different from old value.
inline bool samp_meng::I64Price8_Update(samp_meng::I64Price8 &lhs, samp_meng::I64Price8 rhs) {
    bool ret = !I64Price8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- samp_meng.I64Price8..Ctor
inline  samp_meng::I64Price8::I64Price8() {
    samp_meng::I64Price8_Init(*this);
}

// --- samp_meng.I64Price8..FieldwiseCtor
inline  samp_meng::I64Price8::I64Price8(i64 in_value)
    : value(in_value)
 {
}

// --- samp_meng.Ordkey..EqOp
inline bool samp_meng::Ordkey::operator ==(const samp_meng::Ordkey &rhs) const {
    return samp_meng::Ordkey_Eq(const_cast<samp_meng::Ordkey&>(*this),const_cast<samp_meng::Ordkey&>(rhs));
}

// --- samp_meng.Ordkey..NeOp
inline bool samp_meng::Ordkey::operator !=(const samp_meng::Ordkey &rhs) const {
    return !samp_meng::Ordkey_Eq(const_cast<samp_meng::Ordkey&>(*this),const_cast<samp_meng::Ordkey&>(rhs));
}

// --- samp_meng.Ordkey..LtOp
inline bool samp_meng::Ordkey::operator <(const samp_meng::Ordkey &rhs) const {
    return samp_meng::Ordkey_Lt(const_cast<samp_meng::Ordkey&>(*this),const_cast<samp_meng::Ordkey&>(rhs));
}

// --- samp_meng.Ordkey..GtOp
inline bool samp_meng::Ordkey::operator >(const samp_meng::Ordkey &rhs) const {
    return samp_meng::Ordkey_Lt(const_cast<samp_meng::Ordkey&>(rhs),const_cast<samp_meng::Ordkey&>(*this));
}

// --- samp_meng.Ordkey..LeOp
inline bool samp_meng::Ordkey::operator <=(const samp_meng::Ordkey &rhs) const {
    return !samp_meng::Ordkey_Lt(const_cast<samp_meng::Ordkey&>(rhs),const_cast<samp_meng::Ordkey&>(*this));
}

// --- samp_meng.Ordkey..GeOp
inline bool samp_meng::Ordkey::operator >=(const samp_meng::Ordkey &rhs) const {
    return !samp_meng::Ordkey_Lt(const_cast<samp_meng::Ordkey&>(*this),const_cast<samp_meng::Ordkey&>(rhs));
}

// --- samp_meng.Ordkey..Lt
inline bool samp_meng::Ordkey_Lt(samp_meng::Ordkey& lhs, samp_meng::Ordkey& rhs) {
    return Ordkey_Cmp(lhs,rhs) < 0;
}

// --- samp_meng.Ordkey..Cmp
inline i32 samp_meng::Ordkey_Cmp(samp_meng::Ordkey& lhs, samp_meng::Ordkey& rhs) {
    i32 retval = 0;
    retval = u64_Cmp(lhs.price, rhs.price);
    if (retval != 0) {
        return retval;
    }
    retval = u64_Cmp(lhs.time, rhs.time);
    return retval;
}

// --- samp_meng.Ordkey..Init
// Set all fields to initial values.
inline void samp_meng::Ordkey_Init(samp_meng::Ordkey& parent) {
    parent.price = u64(0);
    parent.time = u64(0);
}

// --- samp_meng.Ordkey..Eq
inline bool samp_meng::Ordkey_Eq(samp_meng::Ordkey& lhs, samp_meng::Ordkey& rhs) {
    bool retval = true;
    retval = u64_Eq(lhs.price, rhs.price);
    if (!retval) {
        return false;
    }
    retval = u64_Eq(lhs.time, rhs.time);
    return retval;
}

// --- samp_meng.Ordkey..Update
// Set value. Return true if new value is different from old value.
inline bool samp_meng::Ordkey_Update(samp_meng::Ordkey &lhs, samp_meng::Ordkey& rhs) {
    bool ret = !Ordkey_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- samp_meng.Ordkey..Ctor
inline  samp_meng::Ordkey::Ordkey() {
    samp_meng::Ordkey_Init(*this);
}

// --- samp_meng.FOrder.ordkey.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool samp_meng::ordkey_Lt(samp_meng::FOrder& order, samp_meng::FOrder &rhs) {
    return samp_meng::Ordkey_Lt(order.ordkey,rhs.ordkey);
}

// --- samp_meng.FOrder.ordkey.Cmp
// Compare two fields.
inline i32 samp_meng::ordkey_Cmp(samp_meng::FOrder& order, samp_meng::FOrder &rhs) {
    i32 retval = 0;
    retval = samp_meng::Ordkey_Cmp(order.ordkey, rhs.ordkey);
    return retval;
}

// --- samp_meng.FOrder..Init
// Set all fields to initial values.
inline void samp_meng::FOrder_Init(samp_meng::FOrder& order) {
    order.order = i64(0);
    order.p_ordq = NULL;
    order.qty = u32(0);
    order.p_user = NULL;
    order.order_next = (samp_meng::FOrder*)-1; // (samp_meng.FDb.order) not-in-tpool's freelist
    order.ind_order_next = (samp_meng::FOrder*)-1; // (samp_meng.FDb.ind_order) not-in-hash
    order.bh_order_idx = -1; // (samp_meng.FOrdq.bh_order) not-in-heap
    order.zd_order_next = (samp_meng::FOrder*)-1; // (samp_meng.FUser.zd_order) not-in-list
    order.zd_order_prev = NULL; // (samp_meng.FUser.zd_order)
}

// --- samp_meng.FOrder..Ctor
inline  samp_meng::FOrder::FOrder() {
    samp_meng::FOrder_Init(*this);
}

// --- samp_meng.FOrder..Dtor
inline  samp_meng::FOrder::~FOrder() {
    samp_meng::FOrder_Uninit(*this);
}

// --- samp_meng.FOrdq.bh_order.EmptyQ
// Return true if index is empty
inline bool samp_meng::bh_order_EmptyQ(samp_meng::FOrdq& ordq) {
    return ordq.bh_order_n == 0;
}

// --- samp_meng.FOrdq.bh_order.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline samp_meng::FOrder* samp_meng::bh_order_First(samp_meng::FOrdq& ordq) {
    samp_meng::FOrder *row = NULL;
    if (ordq.bh_order_n > 0) {
        row = ordq.bh_order_elems[0];
    }
    return row;
}

// --- samp_meng.FOrdq.bh_order.InBheapQ
// Return true if row is in index, false otherwise
inline bool samp_meng::bh_order_InBheapQ(samp_meng::FOrder& row) {
    bool result = false;
    result = row.bh_order_idx != -1;
    return result;
}

// --- samp_meng.FOrdq.bh_order.N
// Return number of items in the heap
inline i32 samp_meng::bh_order_N(const samp_meng::FOrdq& ordq) {
    return ordq.bh_order_n;
}

// --- samp_meng.FOrdq..Init
// Set all fields to initial values.
inline void samp_meng::FOrdq_Init(samp_meng::FOrdq& ordq) {
    ordq.side = u8(0);
    ordq.p_symbol = NULL;
    ordq.bh_order_max   	= 0; // (samp_meng.FOrdq.bh_order)
    ordq.bh_order_n     	= 0; // (samp_meng.FOrdq.bh_order)
    ordq.bh_order_elems 	= NULL; // (samp_meng.FOrdq.bh_order)
    ordq.symbol_c_ordq_in_ary = bool(false);
    ordq.ordq_next = (samp_meng::FOrdq*)-1; // (samp_meng.FDb.ordq) not-in-tpool's freelist
}

// --- samp_meng.FOrdq.bh_order_curs.Access
// Access current element. If not more elements, return NULL
inline samp_meng::FOrder& samp_meng::ordq_bh_order_curs_Access(ordq_bh_order_curs &curs) {
    return *curs.temp_elems[0];
}

// --- samp_meng.FOrdq.bh_order_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool samp_meng::ordq_bh_order_curs_ValidQ(ordq_bh_order_curs &curs) {
    return curs.temp_n > 0;
}

// --- samp_meng.FOrdq..Ctor
inline  samp_meng::FOrdq::FOrdq() {
    samp_meng::FOrdq_Init(*this);
}

// --- samp_meng.FOrdq..Dtor
inline  samp_meng::FOrdq::~FOrdq() {
    samp_meng::FOrdq_Uninit(*this);
}

// --- samp_meng.Symbol..Hash
inline u32 samp_meng::Symbol_Hash(u32 prev, const samp_meng::Symbol& rhs) {
    prev = RnullStr8_Hash(prev, rhs.symbol);
    return prev;
}

// --- samp_meng.Symbol..EqOp
inline bool samp_meng::Symbol::operator ==(const samp_meng::Symbol &rhs) const {
    return samp_meng::Symbol_Eq(const_cast<samp_meng::Symbol&>(*this),const_cast<samp_meng::Symbol&>(rhs));
}

// --- samp_meng.Symbol..NeOp
inline bool samp_meng::Symbol::operator !=(const samp_meng::Symbol &rhs) const {
    return !samp_meng::Symbol_Eq(const_cast<samp_meng::Symbol&>(*this),const_cast<samp_meng::Symbol&>(rhs));
}

// --- samp_meng.Symbol..Cmp
inline i32 samp_meng::Symbol_Cmp(samp_meng::Symbol& lhs, samp_meng::Symbol& rhs) {
    i32 retval = 0;
    retval = algo::RnullStr8_Cmp(lhs.symbol, rhs.symbol);
    return retval;
}

// --- samp_meng.Symbol..Eq
inline bool samp_meng::Symbol_Eq(samp_meng::Symbol& lhs, samp_meng::Symbol& rhs) {
    bool retval = true;
    retval = algo::RnullStr8_Eq(lhs.symbol, rhs.symbol);
    return retval;
}

// --- samp_meng.Symbol..Ctor
inline  samp_meng::Symbol::Symbol() {
}

// --- samp_meng.FSymbol.c_ordq.EmptyQ
// Return true if index is empty
inline bool samp_meng::c_ordq_EmptyQ(samp_meng::FSymbol& symbol) {
    return symbol.c_ordq_n == 0;
}

// --- samp_meng.FSymbol.c_ordq.Find
// Look up row by row id. Return NULL if out of range
inline samp_meng::FOrdq* samp_meng::c_ordq_Find(samp_meng::FSymbol& symbol, u32 t) {
    samp_meng::FOrdq *retval = NULL;
    u64 idx = t;
    u64 lim = symbol.c_ordq_n;
    if (idx < lim) {
        retval = symbol.c_ordq_elems[idx];
    }
    return retval;
}

// --- samp_meng.FSymbol.c_ordq.Getary
// Return array of pointers
inline algo::aryptr<samp_meng::FOrdq*> samp_meng::c_ordq_Getary(samp_meng::FSymbol& symbol) {
    return algo::aryptr<samp_meng::FOrdq*>(symbol.c_ordq_elems, symbol.c_ordq_n);
}

// --- samp_meng.FSymbol.c_ordq.N
// Return number of items in the pointer array
inline i32 samp_meng::c_ordq_N(const samp_meng::FSymbol& symbol) {
    return symbol.c_ordq_n;
}

// --- samp_meng.FSymbol.c_ordq.RemoveAll
// Empty the index. (The rows are not deleted)
inline void samp_meng::c_ordq_RemoveAll(samp_meng::FSymbol& symbol) {
    for (u32 i = 0; i < symbol.c_ordq_n; i++) {
        // mark all elements as not-in-array
        symbol.c_ordq_elems[i]->symbol_c_ordq_in_ary = false;
    }
    symbol.c_ordq_n = 0;
}

// --- samp_meng.FSymbol.c_ordq.qFind
// Return reference without bounds checking
inline samp_meng::FOrdq& samp_meng::c_ordq_qFind(samp_meng::FSymbol& symbol, u32 idx) {
    return *symbol.c_ordq_elems[idx];
}

// --- samp_meng.FSymbol.c_ordq.InAryQ
// True if row is in any ptrary instance
inline bool samp_meng::symbol_c_ordq_InAryQ(samp_meng::FOrdq& row) {
    return row.symbol_c_ordq_in_ary;
}

// --- samp_meng.FSymbol.c_ordq.qLast
// Reference to last element without bounds checking
inline samp_meng::FOrdq& samp_meng::c_ordq_qLast(samp_meng::FSymbol& symbol) {
    return *symbol.c_ordq_elems[symbol.c_ordq_n-1];
}

// --- samp_meng.FSymbol..Init
// Set all fields to initial values.
inline void samp_meng::FSymbol_Init(samp_meng::FSymbol& symbol) {
    symbol.id = i32(0);
    symbol.c_ordq_elems = NULL; // (samp_meng.FSymbol.c_ordq)
    symbol.c_ordq_n = 0; // (samp_meng.FSymbol.c_ordq)
    symbol.c_ordq_max = 0; // (samp_meng.FSymbol.c_ordq)
    symbol.ind_symbol_next = (samp_meng::FSymbol*)-1; // (samp_meng.FDb.ind_symbol) not-in-hash
}

// --- samp_meng.FSymbol.c_ordq_curs.Reset
inline void samp_meng::symbol_c_ordq_curs_Reset(symbol_c_ordq_curs &curs, samp_meng::FSymbol &parent) {
    curs.elems = parent.c_ordq_elems;
    curs.n_elems = parent.c_ordq_n;
    curs.index = 0;
}

// --- samp_meng.FSymbol.c_ordq_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::symbol_c_ordq_curs_ValidQ(symbol_c_ordq_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- samp_meng.FSymbol.c_ordq_curs.Next
// proceed to next item
inline void samp_meng::symbol_c_ordq_curs_Next(symbol_c_ordq_curs &curs) {
    curs.index++;
}

// --- samp_meng.FSymbol.c_ordq_curs.Access
// item access
inline samp_meng::FOrdq& samp_meng::symbol_c_ordq_curs_Access(symbol_c_ordq_curs &curs) {
    return *curs.elems[curs.index];
}

// --- samp_meng.FSymbol..Ctor
inline  samp_meng::FSymbol::FSymbol() {
    samp_meng::FSymbol_Init(*this);
}

// --- samp_meng.FSymbol..Dtor
inline  samp_meng::FSymbol::~FSymbol() {
    samp_meng::FSymbol_Uninit(*this);
}

// --- samp_meng.FUser.zd_order.EmptyQ
// Return true if index is empty
inline bool samp_meng::zd_order_EmptyQ(samp_meng::FUser& user) {
    return user.zd_order_head == NULL;
}

// --- samp_meng.FUser.zd_order.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline samp_meng::FOrder* samp_meng::zd_order_First(samp_meng::FUser& user) {
    samp_meng::FOrder *row = NULL;
    row = user.zd_order_head;
    return row;
}

// --- samp_meng.FUser.zd_order.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool samp_meng::zd_order_InLlistQ(samp_meng::FOrder& row) {
    bool result = false;
    result = !(row.zd_order_next == (samp_meng::FOrder*)-1);
    return result;
}

// --- samp_meng.FUser.zd_order.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline samp_meng::FOrder* samp_meng::zd_order_Last(samp_meng::FUser& user) {
    samp_meng::FOrder *row = NULL;
    row = user.zd_order_tail;
    return row;
}

// --- samp_meng.FUser.zd_order.N
// Return number of items in the linked list
inline i32 samp_meng::zd_order_N(const samp_meng::FUser& user) {
    return user.zd_order_n;
}

// --- samp_meng.FUser.zd_order.Next
// Return pointer to next element in the list
inline samp_meng::FOrder* samp_meng::zd_order_Next(samp_meng::FOrder &row) {
    return row.zd_order_next;
}

// --- samp_meng.FUser.zd_order.Prev
// Return pointer to previous element in the list
inline samp_meng::FOrder* samp_meng::zd_order_Prev(samp_meng::FOrder &row) {
    return row.zd_order_prev;
}

// --- samp_meng.FUser.zd_order.qLast
// Return reference to last element in the index. No bounds checking.
inline samp_meng::FOrder& samp_meng::zd_order_qLast(samp_meng::FUser& user) {
    samp_meng::FOrder *row = NULL;
    row = user.zd_order_tail;
    return *row;
}

// --- samp_meng.FUser..Init
// Set all fields to initial values.
inline void samp_meng::FUser_Init(samp_meng::FUser& user) {
    user.user = i32(0);
    user.zd_order_head = NULL; // (samp_meng.FUser.zd_order)
    user.zd_order_n = 0; // (samp_meng.FUser.zd_order)
    user.zd_order_tail = NULL; // (samp_meng.FUser.zd_order)
    user.ind_user_next = (samp_meng::FUser*)-1; // (samp_meng.FDb.ind_user) not-in-hash
}

// --- samp_meng.FUser.zd_order_curs.Reset
// cursor points to valid item
inline void samp_meng::user_zd_order_curs_Reset(user_zd_order_curs &curs, samp_meng::FUser &parent) {
    curs.row = parent.zd_order_head;
}

// --- samp_meng.FUser.zd_order_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::user_zd_order_curs_ValidQ(user_zd_order_curs &curs) {
    return curs.row != NULL;
}

// --- samp_meng.FUser.zd_order_curs.Next
// proceed to next item
inline void samp_meng::user_zd_order_curs_Next(user_zd_order_curs &curs) {
    samp_meng::FOrder *next = (*curs.row).zd_order_next;
    curs.row = next;
}

// --- samp_meng.FUser.zd_order_curs.Access
// item access
inline samp_meng::FOrder& samp_meng::user_zd_order_curs_Access(user_zd_order_curs &curs) {
    return *curs.row;
}

// --- samp_meng.FUser..Ctor
inline  samp_meng::FUser::FUser() {
    samp_meng::FUser_Init(*this);
}

// --- samp_meng.FUser..Dtor
inline  samp_meng::FUser::~FUser() {
    samp_meng::FUser_Uninit(*this);
}

// --- samp_meng.FieldId.value.GetEnum
// Get value of field as enum type
inline samp_meng_FieldIdEnum samp_meng::value_GetEnum(const samp_meng::FieldId& parent) {
    return samp_meng_FieldIdEnum(parent.value);
}

// --- samp_meng.FieldId.value.SetEnum
// Set value of field from enum type.
inline void samp_meng::value_SetEnum(samp_meng::FieldId& parent, samp_meng_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- samp_meng.FieldId.value.Cast
inline  samp_meng::FieldId::operator samp_meng_FieldIdEnum() const {
    return samp_meng_FieldIdEnum((*this).value);
}

// --- samp_meng.FieldId..Init
// Set all fields to initial values.
inline void samp_meng::FieldId_Init(samp_meng::FieldId& parent) {
    parent.value = i32(-1);
}

// --- samp_meng.FieldId..Ctor
inline  samp_meng::FieldId::FieldId() {
    samp_meng::FieldId_Init(*this);
}

// --- samp_meng.FieldId..FieldwiseCtor
inline  samp_meng::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- samp_meng.FieldId..EnumCtor
inline  samp_meng::FieldId::FieldId(samp_meng_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- samp_meng.InCase.value.GetEnum
// Get value of field as enum type
inline samp_meng_InCaseEnum samp_meng::value_GetEnum(const samp_meng::InCase& parent) {
    return samp_meng_InCaseEnum(parent.value);
}

// --- samp_meng.InCase.value.SetEnum
// Set value of field from enum type.
inline void samp_meng::value_SetEnum(samp_meng::InCase& parent, samp_meng_InCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- samp_meng.InCase.value.Cast
inline  samp_meng::InCase::operator samp_meng_InCaseEnum() const {
    return samp_meng_InCaseEnum((*this).value);
}

// --- samp_meng.InCase..Init
// Set all fields to initial values.
inline void samp_meng::InCase_Init(samp_meng::InCase& parent) {
    parent.value = u32(0);
}

// --- samp_meng.InCase..Ctor
inline  samp_meng::InCase::InCase() {
    samp_meng::InCase_Init(*this);
}

// --- samp_meng.InCase..FieldwiseCtor
inline  samp_meng::InCase::InCase(u32 in_value)
    : value(in_value)
 {
}

// --- samp_meng.InCase..EnumCtor
inline  samp_meng::InCase::InCase(samp_meng_InCaseEnum arg) {
    this->value = u32(arg);
}

// --- samp_meng.MassCancelReqMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of MassCancelReqMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MassCancelReqMsg.
// If not successful, quietly return NULL.
inline samp_meng::MassCancelReqMsg* samp_meng::MassCancelReqMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (12);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::MassCancelReqMsg);
    return cond ? reinterpret_cast<samp_meng::MassCancelReqMsg*>(&hdr) : NULL;
}

// --- samp_meng.MassCancelReqMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::MassCancelReqMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.MassCancelReqMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::MassCancelReqMsg& parent) {
    return i32(const_cast<samp_meng::MassCancelReqMsg&>(parent).length);
}

// --- samp_meng.MassCancelReqMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::MassCancelReqMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::MassCancelReqMsg&>(row).length));
}

// --- samp_meng.MassCancelReqMsg..Init
// Set all fields to initial values.
inline void samp_meng::MassCancelReqMsg_Init(samp_meng::MassCancelReqMsg& parent) {
    parent.type = u8(12);
    parent.length = u8(ssizeof(parent) + (0));
    parent.user = u32(0);
}

// --- samp_meng.MassCancelReqMsg..Ctor
inline  samp_meng::MassCancelReqMsg::MassCancelReqMsg() {
    samp_meng::MassCancelReqMsg_Init(*this);
}

// --- samp_meng.MassCancelReqMsg..FieldwiseCtor
inline  samp_meng::MassCancelReqMsg::MassCancelReqMsg(u32 in_user)
    : user(in_user)
 {
    this->type = u8(12);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.MsgHeader.type.GetEnum
// Get value of field as enum type
inline samp_meng_MsgHeader_type_Enum samp_meng::type_GetEnum(const samp_meng::MsgHeader& parent) {
    return samp_meng_MsgHeader_type_Enum(parent.type);
}

// --- samp_meng.MsgHeader.type.SetEnum
// Set value of field from enum type.
inline void samp_meng::type_SetEnum(samp_meng::MsgHeader& parent, samp_meng_MsgHeader_type_Enum rhs) {
    parent.type = u8(rhs);
}

// --- samp_meng.MsgHeader..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::MsgHeader& parent) {
    return i32(const_cast<samp_meng::MsgHeader&>(parent).length);
}

// --- samp_meng.MsgHeader..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::MsgHeader& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::MsgHeader&>(row).length));
}

// --- samp_meng.MsgHeader..Init
// Set all fields to initial values.
inline void samp_meng::MsgHeader_Init(samp_meng::MsgHeader& parent) {
    parent.type = u8(0);
    parent.length = u8(0);
}

// --- samp_meng.MsgHeader..Ctor
inline  samp_meng::MsgHeader::MsgHeader() {
    samp_meng::MsgHeader_Init(*this);
}

// --- samp_meng.MsgHeader..FieldwiseCtor
inline  samp_meng::MsgHeader::MsgHeader(u8 in_type, u8 in_length)
    : type(in_type)
    , length(in_length)
 {
}

// --- samp_meng.MsgHeaderMsgsCase.value.GetEnum
// Get value of field as enum type
inline samp_meng_MsgHeaderMsgsCaseEnum samp_meng::value_GetEnum(const samp_meng::MsgHeaderMsgsCase& parent) {
    return samp_meng_MsgHeaderMsgsCaseEnum(parent.value);
}

// --- samp_meng.MsgHeaderMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void samp_meng::value_SetEnum(samp_meng::MsgHeaderMsgsCase& parent, samp_meng_MsgHeaderMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- samp_meng.MsgHeaderMsgsCase.value.Cast
inline  samp_meng::MsgHeaderMsgsCase::operator samp_meng_MsgHeaderMsgsCaseEnum() const {
    return samp_meng_MsgHeaderMsgsCaseEnum((*this).value);
}

// --- samp_meng.MsgHeaderMsgsCase..Init
// Set all fields to initial values.
inline void samp_meng::MsgHeaderMsgsCase_Init(samp_meng::MsgHeaderMsgsCase& parent) {
    parent.value = u32(0);
}

// --- samp_meng.MsgHeaderMsgsCase..Ctor
inline  samp_meng::MsgHeaderMsgsCase::MsgHeaderMsgsCase() {
    samp_meng::MsgHeaderMsgsCase_Init(*this);
}

// --- samp_meng.MsgHeaderMsgsCase..FieldwiseCtor
inline  samp_meng::MsgHeaderMsgsCase::MsgHeaderMsgsCase(u32 in_value)
    : value(in_value)
 {
}

// --- samp_meng.MsgHeaderMsgsCase..EnumCtor
inline  samp_meng::MsgHeaderMsgsCase::MsgHeaderMsgsCase(samp_meng_MsgHeaderMsgsCaseEnum arg) {
    this->value = u32(arg);
}

// --- samp_meng.MsgHeader_curs..ValidQ
inline bool samp_meng::MsgHeader_curs_ValidQ(samp_meng::MsgHeader_curs& curs) {
    return curs.msg != NULL;
}

// --- samp_meng.MsgHeader_curs..Reset
inline void samp_meng::MsgHeader_curs_Reset(samp_meng::MsgHeader_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    samp_meng::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(samp_meng::MsgHeader)) {
        samp_meng::MsgHeader *ptr = (samp_meng::MsgHeader*)curs.bytes;
        msglen = i32((*ptr).length);
        if (msglen >= ssizeof(samp_meng::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- samp_meng.MsgHeader_curs..Access
inline samp_meng::MsgHeader*& samp_meng::MsgHeader_curs_Access(samp_meng::MsgHeader_curs& curs) {
    return curs.msg;
}

// --- samp_meng.MsgHeader_curs..Next
inline void samp_meng::MsgHeader_curs_Next(samp_meng::MsgHeader_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    samp_meng::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(samp_meng::MsgHeader)) {
        samp_meng::MsgHeader *ptr = (samp_meng::MsgHeader*)curs.bytes;
        msglen = i32((*ptr).length);
        if (msglen >= ssizeof(samp_meng::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- samp_meng.MsgHeader_curs..Init
// Set all fields to initial values.
inline void samp_meng::MsgHeader_curs_Init(samp_meng::MsgHeader_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- samp_meng.MsgHeader_curs..Ctor
inline  samp_meng::MsgHeader_curs::MsgHeader_curs() {
    samp_meng::MsgHeader_curs_Init(*this);
}

// --- samp_meng.NewOrderMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of NewOrderMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of NewOrderMsg.
// If not successful, quietly return NULL.
inline samp_meng::NewOrderMsg* samp_meng::NewOrderMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (2);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::NewOrderMsg);
    return cond ? reinterpret_cast<samp_meng::NewOrderMsg*>(&hdr) : NULL;
}

// --- samp_meng.NewOrderMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::NewOrderMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.NewOrderMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::NewOrderMsg& parent) {
    return i32(const_cast<samp_meng::NewOrderMsg&>(parent).length);
}

// --- samp_meng.NewOrderMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::NewOrderMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::NewOrderMsg&>(row).length));
}

// --- samp_meng.NewOrderMsg..Init
// Set all fields to initial values.
inline void samp_meng::NewOrderMsg_Init(samp_meng::NewOrderMsg& parent) {
    parent.type = u8(2);
    parent.length = u8(ssizeof(parent) + (0));
    parent.order = u64(0);
    parent.qty = u32(0);
}

// --- samp_meng.NewOrderMsg..Ctor
inline  samp_meng::NewOrderMsg::NewOrderMsg() {
    samp_meng::NewOrderMsg_Init(*this);
}

// --- samp_meng.NewOrderMsg..FieldwiseCtor
inline  samp_meng::NewOrderMsg::NewOrderMsg(algo::UnTime in_time, samp_meng::I64Price8 in_price, u64 in_order, const samp_meng::Symbol& in_symbol, u32 in_qty)
    : time(in_time)
    , price(in_price)
    , order(in_order)
    , symbol(in_symbol)
    , qty(in_qty)
 {
    this->type = u8(2);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.NewOrderReqMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of NewOrderReqMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of NewOrderReqMsg.
// If not successful, quietly return NULL.
inline samp_meng::NewOrderReqMsg* samp_meng::NewOrderReqMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (10);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::NewOrderReqMsg);
    return cond ? reinterpret_cast<samp_meng::NewOrderReqMsg*>(&hdr) : NULL;
}

// --- samp_meng.NewOrderReqMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::NewOrderReqMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.NewOrderReqMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::NewOrderReqMsg& parent) {
    return i32(const_cast<samp_meng::NewOrderReqMsg&>(parent).length);
}

// --- samp_meng.NewOrderReqMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::NewOrderReqMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::NewOrderReqMsg&>(row).length));
}

// --- samp_meng.NewOrderReqMsg..Init
// Set all fields to initial values.
inline void samp_meng::NewOrderReqMsg_Init(samp_meng::NewOrderReqMsg& parent) {
    parent.type = u8(10);
    parent.length = u8(ssizeof(parent) + (0));
    parent.ioc = bool(false);
    parent.qty = i32(0);
    parent.user = u32(0);
}

// --- samp_meng.NewOrderReqMsg..Ctor
inline  samp_meng::NewOrderReqMsg::NewOrderReqMsg() {
    samp_meng::NewOrderReqMsg_Init(*this);
}

// --- samp_meng.NewOrderReqMsg..FieldwiseCtor
inline  samp_meng::NewOrderReqMsg::NewOrderReqMsg(bool in_ioc, i32 in_qty, samp_meng::I64Price8 in_price, const samp_meng::Symbol& in_symbol, u32 in_user)
    : ioc(in_ioc)
    , qty(in_qty)
    , price(in_price)
    , symbol(in_symbol)
    , user(in_user)
 {
    this->type = u8(10);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.NewSymbolMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of NewSymbolMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of NewSymbolMsg.
// If not successful, quietly return NULL.
inline samp_meng::NewSymbolMsg* samp_meng::NewSymbolMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (5);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::NewSymbolMsg);
    return cond ? reinterpret_cast<samp_meng::NewSymbolMsg*>(&hdr) : NULL;
}

// --- samp_meng.NewSymbolMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::NewSymbolMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.NewSymbolMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::NewSymbolMsg& parent) {
    return i32(const_cast<samp_meng::NewSymbolMsg&>(parent).length);
}

// --- samp_meng.NewSymbolMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::NewSymbolMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::NewSymbolMsg&>(row).length));
}

// --- samp_meng.NewSymbolMsg..Init
// Set all fields to initial values.
inline void samp_meng::NewSymbolMsg_Init(samp_meng::NewSymbolMsg& parent) {
    parent.type = u8(5);
    parent.length = u8(ssizeof(parent) + (0));
}

// --- samp_meng.NewSymbolMsg..Ctor
inline  samp_meng::NewSymbolMsg::NewSymbolMsg() {
    samp_meng::NewSymbolMsg_Init(*this);
}

// --- samp_meng.NewSymbolMsg..FieldwiseCtor
inline  samp_meng::NewSymbolMsg::NewSymbolMsg(const samp_meng::Symbol& in_symbol)
    : symbol(in_symbol)
 {
    this->type = u8(5);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.NewSymbolReqMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of NewSymbolReqMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of NewSymbolReqMsg.
// If not successful, quietly return NULL.
inline samp_meng::NewSymbolReqMsg* samp_meng::NewSymbolReqMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (13);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::NewSymbolReqMsg);
    return cond ? reinterpret_cast<samp_meng::NewSymbolReqMsg*>(&hdr) : NULL;
}

// --- samp_meng.NewSymbolReqMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::NewSymbolReqMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.NewSymbolReqMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::NewSymbolReqMsg& parent) {
    return i32(const_cast<samp_meng::NewSymbolReqMsg&>(parent).length);
}

// --- samp_meng.NewSymbolReqMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::NewSymbolReqMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::NewSymbolReqMsg&>(row).length));
}

// --- samp_meng.NewSymbolReqMsg..Init
// Set all fields to initial values.
inline void samp_meng::NewSymbolReqMsg_Init(samp_meng::NewSymbolReqMsg& parent) {
    parent.type = u8(13);
    parent.length = u8(ssizeof(parent) + (0));
}

// --- samp_meng.NewSymbolReqMsg..Ctor
inline  samp_meng::NewSymbolReqMsg::NewSymbolReqMsg() {
    samp_meng::NewSymbolReqMsg_Init(*this);
}

// --- samp_meng.NewSymbolReqMsg..FieldwiseCtor
inline  samp_meng::NewSymbolReqMsg::NewSymbolReqMsg(const samp_meng::Symbol& in_symbol)
    : symbol(in_symbol)
 {
    this->type = u8(13);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.NewUserMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of NewUserMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of NewUserMsg.
// If not successful, quietly return NULL.
inline samp_meng::NewUserMsg* samp_meng::NewUserMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (6);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::NewUserMsg);
    return cond ? reinterpret_cast<samp_meng::NewUserMsg*>(&hdr) : NULL;
}

// --- samp_meng.NewUserMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::NewUserMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.NewUserMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::NewUserMsg& parent) {
    return i32(const_cast<samp_meng::NewUserMsg&>(parent).length);
}

// --- samp_meng.NewUserMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::NewUserMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::NewUserMsg&>(row).length));
}

// --- samp_meng.NewUserMsg..Init
// Set all fields to initial values.
inline void samp_meng::NewUserMsg_Init(samp_meng::NewUserMsg& parent) {
    parent.type = u8(6);
    parent.length = u8(ssizeof(parent) + (0));
    parent.user = u32(0);
}

// --- samp_meng.NewUserMsg..Ctor
inline  samp_meng::NewUserMsg::NewUserMsg() {
    samp_meng::NewUserMsg_Init(*this);
}

// --- samp_meng.NewUserMsg..FieldwiseCtor
inline  samp_meng::NewUserMsg::NewUserMsg(u32 in_user)
    : user(in_user)
 {
    this->type = u8(6);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.NewUserReqMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of NewUserReqMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of NewUserReqMsg.
// If not successful, quietly return NULL.
inline samp_meng::NewUserReqMsg* samp_meng::NewUserReqMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (14);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::NewUserReqMsg);
    return cond ? reinterpret_cast<samp_meng::NewUserReqMsg*>(&hdr) : NULL;
}

// --- samp_meng.NewUserReqMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::NewUserReqMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.NewUserReqMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::NewUserReqMsg& parent) {
    return i32(const_cast<samp_meng::NewUserReqMsg&>(parent).length);
}

// --- samp_meng.NewUserReqMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::NewUserReqMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::NewUserReqMsg&>(row).length));
}

// --- samp_meng.NewUserReqMsg..Init
// Set all fields to initial values.
inline void samp_meng::NewUserReqMsg_Init(samp_meng::NewUserReqMsg& parent) {
    parent.type = u8(14);
    parent.length = u8(ssizeof(parent) + (0));
    parent.user = u32(0);
}

// --- samp_meng.NewUserReqMsg..Ctor
inline  samp_meng::NewUserReqMsg::NewUserReqMsg() {
    samp_meng::NewUserReqMsg_Init(*this);
}

// --- samp_meng.NewUserReqMsg..FieldwiseCtor
inline  samp_meng::NewUserReqMsg::NewUserReqMsg(u32 in_user)
    : user(in_user)
 {
    this->type = u8(14);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.OrderTradeMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of OrderTradeMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of OrderTradeMsg.
// If not successful, quietly return NULL.
inline samp_meng::OrderTradeMsg* samp_meng::OrderTradeMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (4);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::OrderTradeMsg);
    return cond ? reinterpret_cast<samp_meng::OrderTradeMsg*>(&hdr) : NULL;
}

// --- samp_meng.OrderTradeMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::OrderTradeMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.OrderTradeMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::OrderTradeMsg& parent) {
    return i32(const_cast<samp_meng::OrderTradeMsg&>(parent).length);
}

// --- samp_meng.OrderTradeMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::OrderTradeMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::OrderTradeMsg&>(row).length));
}

// --- samp_meng.OrderTradeMsg..Init
// Set all fields to initial values.
inline void samp_meng::OrderTradeMsg_Init(samp_meng::OrderTradeMsg& parent) {
    parent.type = u8(4);
    parent.length = u8(ssizeof(parent) + (0));
    parent.order = u64(0);
    parent.qty = u32(0);
}

// --- samp_meng.OrderTradeMsg..Ctor
inline  samp_meng::OrderTradeMsg::OrderTradeMsg() {
    samp_meng::OrderTradeMsg_Init(*this);
}

// --- samp_meng.OrderTradeMsg..FieldwiseCtor
inline  samp_meng::OrderTradeMsg::OrderTradeMsg(u64 in_order, u32 in_qty, samp_meng::I64Price8 in_price)
    : order(in_order)
    , qty(in_qty)
    , price(in_price)
 {
    this->type = u8(4);
    this->length = u8(ssizeof(*this) + (0));
}

// --- samp_meng.TextMsg.base.Castdown
// Check if samp_meng::MsgHeader is an instance of TextMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TextMsg.
// If not successful, quietly return NULL.
inline samp_meng::TextMsg* samp_meng::TextMsg_Castdown(samp_meng::MsgHeader &hdr) {
    bool cond = hdr.type == (7);
    cond &= i32(hdr.length) >= ssizeof(samp_meng::TextMsg);
    return cond ? reinterpret_cast<samp_meng::TextMsg*>(&hdr) : NULL;
}

// --- samp_meng.TextMsg.base.Castbase
inline samp_meng::MsgHeader& samp_meng::Castbase(samp_meng::TextMsg& parent) {
    return reinterpret_cast<samp_meng::MsgHeader&>(parent);
}

// --- samp_meng.TextMsg.text.N
// Return number of elements in varlen field
inline u32 samp_meng::text_N(const samp_meng::TextMsg& parent) {
    u32 length = i32(((samp_meng::TextMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(samp_meng::TextMsg)) - sizeof(samp_meng::TextMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- samp_meng.TextMsg.text_curs.Reset
inline void samp_meng::TextMsg_text_curs_Reset(TextMsg_text_curs &curs, samp_meng::TextMsg &parent) {
    curs.ptr = (u8*)&parent + sizeof(samp_meng::TextMsg);
    curs.length = i32(parent.length) - sizeof(samp_meng::TextMsg);
    curs.index = 0;
}

// --- samp_meng.TextMsg.text_curs.ValidQ
// cursor points to valid item
inline bool samp_meng::TextMsg_text_curs_ValidQ(TextMsg_text_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- samp_meng.TextMsg.text_curs.Next
// proceed to next item
inline void samp_meng::TextMsg_text_curs_Next(TextMsg_text_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- samp_meng.TextMsg.text_curs.Access
// item access
inline char& samp_meng::TextMsg_text_curs_Access(TextMsg_text_curs &curs) {
    return *(char*)curs.ptr;
}

// --- samp_meng.TextMsg..GetMsgLength
// Message length (uses length field)
inline i32 samp_meng::GetMsgLength(const samp_meng::TextMsg& parent) {
    return i32(const_cast<samp_meng::TextMsg&>(parent).length);
}

// --- samp_meng.TextMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr samp_meng::GetMsgMemptr(const samp_meng::TextMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<samp_meng::TextMsg&>(row).length));
}

// --- samp_meng.TextMsg..Init
// Set all fields to initial values.
inline void samp_meng::TextMsg_Init(samp_meng::TextMsg& parent) {
    parent.type = u8(7);
    parent.length = u8(ssizeof(parent) + (0));
}

// --- samp_meng.TextMsg..Ctor
inline  samp_meng::TextMsg::TextMsg() {
    samp_meng::TextMsg_Init(*this);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::CancelOrderMsg &row) {// cfmt:samp_meng.CancelOrderMsg.String
    samp_meng::CancelOrderMsg_Print(const_cast<samp_meng::CancelOrderMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::CancelReqMsg &row) {// cfmt:samp_meng.CancelReqMsg.String
    samp_meng::CancelReqMsg_Print(const_cast<samp_meng::CancelReqMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::trace &row) {// cfmt:samp_meng.trace.String
    samp_meng::trace_Print(const_cast<samp_meng::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::I64Price8 &row) {// cfmt:samp_meng.I64Price8.String
    samp_meng::I64Price8_Print(const_cast<samp_meng::I64Price8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::Symbol &row) {// cfmt:samp_meng.Symbol.String
    samp_meng::Symbol_Print(const_cast<samp_meng::Symbol&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::FieldId &row) {// cfmt:samp_meng.FieldId.String
    samp_meng::FieldId_Print(const_cast<samp_meng::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::MassCancelReqMsg &row) {// cfmt:samp_meng.MassCancelReqMsg.String
    samp_meng::MassCancelReqMsg_Print(const_cast<samp_meng::MassCancelReqMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::MsgHeader &row) {// cfmt:samp_meng.MsgHeader.String
    samp_meng::MsgHeader_Print(const_cast<samp_meng::MsgHeader&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::NewOrderMsg &row) {// cfmt:samp_meng.NewOrderMsg.String
    samp_meng::NewOrderMsg_Print(const_cast<samp_meng::NewOrderMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::NewOrderReqMsg &row) {// cfmt:samp_meng.NewOrderReqMsg.String
    samp_meng::NewOrderReqMsg_Print(const_cast<samp_meng::NewOrderReqMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::NewSymbolMsg &row) {// cfmt:samp_meng.NewSymbolMsg.String
    samp_meng::NewSymbolMsg_Print(const_cast<samp_meng::NewSymbolMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::NewSymbolReqMsg &row) {// cfmt:samp_meng.NewSymbolReqMsg.String
    samp_meng::NewSymbolReqMsg_Print(const_cast<samp_meng::NewSymbolReqMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::NewUserMsg &row) {// cfmt:samp_meng.NewUserMsg.String
    samp_meng::NewUserMsg_Print(const_cast<samp_meng::NewUserMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::NewUserReqMsg &row) {// cfmt:samp_meng.NewUserReqMsg.String
    samp_meng::NewUserReqMsg_Print(const_cast<samp_meng::NewUserReqMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::OrderTradeMsg &row) {// cfmt:samp_meng.OrderTradeMsg.String
    samp_meng::OrderTradeMsg_Print(const_cast<samp_meng::OrderTradeMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const samp_meng::TextMsg &row) {// cfmt:samp_meng.TextMsg.String
    samp_meng::TextMsg_Print(const_cast<samp_meng::TextMsg&>(row), str);
    return str;
}
