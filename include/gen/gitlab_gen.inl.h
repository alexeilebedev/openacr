//
// include/gen/gitlab_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/lib_json_gen.inl.h"
//#pragma endinclude
inline gitlab::trace::trace() {
}


// --- gitlab.FDb.ind_issue.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_issue_EmptyQ() {
    return _db.ind_issue_n == 0;
}

// --- gitlab.FDb.ind_issue.N
// Return number of items in the hash
inline i32 gitlab::ind_issue_N() {
    return _db.ind_issue_n;
}

// --- gitlab.FDb.issue.EmptyQ
// Return true if index is empty
inline bool gitlab::issue_EmptyQ() {
    return _db.issue_n == 0;
}

// --- gitlab.FDb.issue.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FIssue* gitlab::issue_Find(u64 t) {
    gitlab::FIssue *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.issue_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.issue_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.issue.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FIssue* gitlab::issue_Last() {
    return issue_Find(u64(_db.issue_n-1));
}

// --- gitlab.FDb.issue.N
// Return number of items in the pool
inline i32 gitlab::issue_N() {
    return _db.issue_n;
}

// --- gitlab.FDb.issue.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FIssue& gitlab::issue_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.issue_lary[bsr][index];
}

// --- gitlab.FDb.issue_note.EmptyQ
// Return true if index is empty
inline bool gitlab::issue_note_EmptyQ() {
    return _db.issue_note_n == 0;
}

// --- gitlab.FDb.issue_note.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FIssueNote* gitlab::issue_note_Find(u64 t) {
    gitlab::FIssueNote *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.issue_note_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.issue_note_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.issue_note.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FIssueNote* gitlab::issue_note_Last() {
    return issue_note_Find(u64(_db.issue_note_n-1));
}

// --- gitlab.FDb.issue_note.N
// Return number of items in the pool
inline i32 gitlab::issue_note_N() {
    return _db.issue_note_n;
}

// --- gitlab.FDb.issue_note.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FIssueNote& gitlab::issue_note_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.issue_note_lary[bsr][index];
}

// --- gitlab.FDb.ind_issue_note.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_issue_note_EmptyQ() {
    return _db.ind_issue_note_n == 0;
}

// --- gitlab.FDb.ind_issue_note.N
// Return number of items in the hash
inline i32 gitlab::ind_issue_note_N() {
    return _db.ind_issue_note_n;
}

// --- gitlab.FDb.issue_description.EmptyQ
// Return true if index is empty
inline bool gitlab::issue_description_EmptyQ() {
    return _db.issue_description_n == 0;
}

// --- gitlab.FDb.issue_description.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FIssueDescription* gitlab::issue_description_Find(u64 t) {
    gitlab::FIssueDescription *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.issue_description_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.issue_description_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.issue_description.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FIssueDescription* gitlab::issue_description_Last() {
    return issue_description_Find(u64(_db.issue_description_n-1));
}

// --- gitlab.FDb.issue_description.N
// Return number of items in the pool
inline i32 gitlab::issue_description_N() {
    return _db.issue_description_n;
}

// --- gitlab.FDb.issue_description.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FIssueDescription& gitlab::issue_description_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.issue_description_lary[bsr][index];
}

// --- gitlab.FDb.ind_mr.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_mr_EmptyQ() {
    return _db.ind_mr_n == 0;
}

// --- gitlab.FDb.ind_mr.N
// Return number of items in the hash
inline i32 gitlab::ind_mr_N() {
    return _db.ind_mr_n;
}

// --- gitlab.FDb.mr.EmptyQ
// Return true if index is empty
inline bool gitlab::mr_EmptyQ() {
    return _db.mr_n == 0;
}

// --- gitlab.FDb.mr.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FMr* gitlab::mr_Find(u64 t) {
    gitlab::FMr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.mr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.mr_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.mr.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FMr* gitlab::mr_Last() {
    return mr_Find(u64(_db.mr_n-1));
}

// --- gitlab.FDb.mr.N
// Return number of items in the pool
inline i32 gitlab::mr_N() {
    return _db.mr_n;
}

// --- gitlab.FDb.mr.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FMr& gitlab::mr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.mr_lary[bsr][index];
}

// --- gitlab.FDb.mr_note.EmptyQ
// Return true if index is empty
inline bool gitlab::mr_note_EmptyQ() {
    return _db.mr_note_n == 0;
}

// --- gitlab.FDb.mr_note.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FMrNote* gitlab::mr_note_Find(u64 t) {
    gitlab::FMrNote *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.mr_note_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.mr_note_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.mr_note.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FMrNote* gitlab::mr_note_Last() {
    return mr_note_Find(u64(_db.mr_note_n-1));
}

// --- gitlab.FDb.mr_note.N
// Return number of items in the pool
inline i32 gitlab::mr_note_N() {
    return _db.mr_note_n;
}

// --- gitlab.FDb.mr_note.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FMrNote& gitlab::mr_note_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.mr_note_lary[bsr][index];
}

// --- gitlab.FDb.ind_mr_note.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_mr_note_EmptyQ() {
    return _db.ind_mr_note_n == 0;
}

// --- gitlab.FDb.ind_mr_note.N
// Return number of items in the hash
inline i32 gitlab::ind_mr_note_N() {
    return _db.ind_mr_note_n;
}

// --- gitlab.FDb.mr_description.EmptyQ
// Return true if index is empty
inline bool gitlab::mr_description_EmptyQ() {
    return _db.mr_description_n == 0;
}

// --- gitlab.FDb.mr_description.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FMrDescription* gitlab::mr_description_Find(u64 t) {
    gitlab::FMrDescription *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.mr_description_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.mr_description_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.mr_description.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FMrDescription* gitlab::mr_description_Last() {
    return mr_description_Find(u64(_db.mr_description_n-1));
}

// --- gitlab.FDb.mr_description.N
// Return number of items in the pool
inline i32 gitlab::mr_description_N() {
    return _db.mr_description_n;
}

// --- gitlab.FDb.mr_description.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FMrDescription& gitlab::mr_description_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.mr_description_lary[bsr][index];
}

// --- gitlab.FDb.user.EmptyQ
// Return true if index is empty
inline bool gitlab::user_EmptyQ() {
    return _db.user_n == 0;
}

// --- gitlab.FDb.user.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FUser* gitlab::user_Find(u64 t) {
    gitlab::FUser *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.user_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.user_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.user.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FUser* gitlab::user_Last() {
    return user_Find(u64(_db.user_n-1));
}

// --- gitlab.FDb.user.N
// Return number of items in the pool
inline i32 gitlab::user_N() {
    return _db.user_n;
}

// --- gitlab.FDb.user.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FUser& gitlab::user_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.user_lary[bsr][index];
}

// --- gitlab.FDb.ind_user.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_user_EmptyQ() {
    return _db.ind_user_n == 0;
}

// --- gitlab.FDb.ind_user.N
// Return number of items in the hash
inline i32 gitlab::ind_user_N() {
    return _db.ind_user_n;
}

// --- gitlab.FDb.project.EmptyQ
// Return true if index is empty
inline bool gitlab::project_EmptyQ() {
    return _db.project_n == 0;
}

// --- gitlab.FDb.project.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FProject* gitlab::project_Find(u64 t) {
    gitlab::FProject *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.project_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.project_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.project.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FProject* gitlab::project_Last() {
    return project_Find(u64(_db.project_n-1));
}

// --- gitlab.FDb.project.N
// Return number of items in the pool
inline i32 gitlab::project_N() {
    return _db.project_n;
}

// --- gitlab.FDb.project.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FProject& gitlab::project_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.project_lary[bsr][index];
}

// --- gitlab.FDb.ind_project.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_project_EmptyQ() {
    return _db.ind_project_n == 0;
}

// --- gitlab.FDb.ind_project.N
// Return number of items in the hash
inline i32 gitlab::ind_project_N() {
    return _db.ind_project_n;
}

// --- gitlab.FDb.gitlab_auth.EmptyQ
// Return true if index is empty
inline bool gitlab::gitlab_auth_EmptyQ() {
    return _db.gitlab_auth_n == 0;
}

// --- gitlab.FDb.gitlab_auth.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FGitlabAuth* gitlab::gitlab_auth_Find(u64 t) {
    gitlab::FGitlabAuth *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gitlab_auth_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gitlab_auth_lary[bsr][index];
    }
    return retval;
}

// --- gitlab.FDb.gitlab_auth.Last
// Return pointer to last element of array, or NULL if array is empty
inline gitlab::FGitlabAuth* gitlab::gitlab_auth_Last() {
    return gitlab_auth_Find(u64(_db.gitlab_auth_n-1));
}

// --- gitlab.FDb.gitlab_auth.N
// Return number of items in the pool
inline i32 gitlab::gitlab_auth_N() {
    return _db.gitlab_auth_n;
}

// --- gitlab.FDb.gitlab_auth.qFind
// 'quick' Access row by row id. No bounds checking.
inline gitlab::FGitlabAuth& gitlab::gitlab_auth_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gitlab_auth_lary[bsr][index];
}

// --- gitlab.FDb.ind_gitlab_auth.EmptyQ
// Return true if hash is empty
inline bool gitlab::ind_gitlab_auth_EmptyQ() {
    return _db.ind_gitlab_auth_n == 0;
}

// --- gitlab.FDb.ind_gitlab_auth.N
// Return number of items in the hash
inline i32 gitlab::ind_gitlab_auth_N() {
    return _db.ind_gitlab_auth_n;
}

// --- gitlab.FDb.issue_curs.Reset
// cursor points to valid item
inline void gitlab::_db_issue_curs_Reset(_db_issue_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.issue_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_issue_curs_ValidQ(_db_issue_curs &curs) {
    return curs.index < _db.issue_n;
}

// --- gitlab.FDb.issue_curs.Next
// proceed to next item
inline void gitlab::_db_issue_curs_Next(_db_issue_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.issue_curs.Access
// item access
inline gitlab::FIssue& gitlab::_db_issue_curs_Access(_db_issue_curs &curs) {
    return issue_qFind(u64(curs.index));
}

// --- gitlab.FDb.issue_note_curs.Reset
// cursor points to valid item
inline void gitlab::_db_issue_note_curs_Reset(_db_issue_note_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.issue_note_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_issue_note_curs_ValidQ(_db_issue_note_curs &curs) {
    return curs.index < _db.issue_note_n;
}

// --- gitlab.FDb.issue_note_curs.Next
// proceed to next item
inline void gitlab::_db_issue_note_curs_Next(_db_issue_note_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.issue_note_curs.Access
// item access
inline gitlab::FIssueNote& gitlab::_db_issue_note_curs_Access(_db_issue_note_curs &curs) {
    return issue_note_qFind(u64(curs.index));
}

// --- gitlab.FDb.issue_description_curs.Reset
// cursor points to valid item
inline void gitlab::_db_issue_description_curs_Reset(_db_issue_description_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.issue_description_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_issue_description_curs_ValidQ(_db_issue_description_curs &curs) {
    return curs.index < _db.issue_description_n;
}

// --- gitlab.FDb.issue_description_curs.Next
// proceed to next item
inline void gitlab::_db_issue_description_curs_Next(_db_issue_description_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.issue_description_curs.Access
// item access
inline gitlab::FIssueDescription& gitlab::_db_issue_description_curs_Access(_db_issue_description_curs &curs) {
    return issue_description_qFind(u64(curs.index));
}

// --- gitlab.FDb.mr_curs.Reset
// cursor points to valid item
inline void gitlab::_db_mr_curs_Reset(_db_mr_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.mr_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_mr_curs_ValidQ(_db_mr_curs &curs) {
    return curs.index < _db.mr_n;
}

// --- gitlab.FDb.mr_curs.Next
// proceed to next item
inline void gitlab::_db_mr_curs_Next(_db_mr_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.mr_curs.Access
// item access
inline gitlab::FMr& gitlab::_db_mr_curs_Access(_db_mr_curs &curs) {
    return mr_qFind(u64(curs.index));
}

// --- gitlab.FDb.mr_note_curs.Reset
// cursor points to valid item
inline void gitlab::_db_mr_note_curs_Reset(_db_mr_note_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.mr_note_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_mr_note_curs_ValidQ(_db_mr_note_curs &curs) {
    return curs.index < _db.mr_note_n;
}

// --- gitlab.FDb.mr_note_curs.Next
// proceed to next item
inline void gitlab::_db_mr_note_curs_Next(_db_mr_note_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.mr_note_curs.Access
// item access
inline gitlab::FMrNote& gitlab::_db_mr_note_curs_Access(_db_mr_note_curs &curs) {
    return mr_note_qFind(u64(curs.index));
}

// --- gitlab.FDb.mr_description_curs.Reset
// cursor points to valid item
inline void gitlab::_db_mr_description_curs_Reset(_db_mr_description_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.mr_description_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_mr_description_curs_ValidQ(_db_mr_description_curs &curs) {
    return curs.index < _db.mr_description_n;
}

// --- gitlab.FDb.mr_description_curs.Next
// proceed to next item
inline void gitlab::_db_mr_description_curs_Next(_db_mr_description_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.mr_description_curs.Access
// item access
inline gitlab::FMrDescription& gitlab::_db_mr_description_curs_Access(_db_mr_description_curs &curs) {
    return mr_description_qFind(u64(curs.index));
}

// --- gitlab.FDb.user_curs.Reset
// cursor points to valid item
inline void gitlab::_db_user_curs_Reset(_db_user_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.user_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_user_curs_ValidQ(_db_user_curs &curs) {
    return curs.index < _db.user_n;
}

// --- gitlab.FDb.user_curs.Next
// proceed to next item
inline void gitlab::_db_user_curs_Next(_db_user_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.user_curs.Access
// item access
inline gitlab::FUser& gitlab::_db_user_curs_Access(_db_user_curs &curs) {
    return user_qFind(u64(curs.index));
}

// --- gitlab.FDb.project_curs.Reset
// cursor points to valid item
inline void gitlab::_db_project_curs_Reset(_db_project_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.project_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_project_curs_ValidQ(_db_project_curs &curs) {
    return curs.index < _db.project_n;
}

// --- gitlab.FDb.project_curs.Next
// proceed to next item
inline void gitlab::_db_project_curs_Next(_db_project_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.project_curs.Access
// item access
inline gitlab::FProject& gitlab::_db_project_curs_Access(_db_project_curs &curs) {
    return project_qFind(u64(curs.index));
}

// --- gitlab.FDb.gitlab_auth_curs.Reset
// cursor points to valid item
inline void gitlab::_db_gitlab_auth_curs_Reset(_db_gitlab_auth_curs &curs, gitlab::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- gitlab.FDb.gitlab_auth_curs.ValidQ
// cursor points to valid item
inline bool gitlab::_db_gitlab_auth_curs_ValidQ(_db_gitlab_auth_curs &curs) {
    return curs.index < _db.gitlab_auth_n;
}

// --- gitlab.FDb.gitlab_auth_curs.Next
// proceed to next item
inline void gitlab::_db_gitlab_auth_curs_Next(_db_gitlab_auth_curs &curs) {
    curs.index++;
}

// --- gitlab.FDb.gitlab_auth_curs.Access
// item access
inline gitlab::FGitlabAuth& gitlab::_db_gitlab_auth_curs_Access(_db_gitlab_auth_curs &curs) {
    return gitlab_auth_qFind(u64(curs.index));
}
inline gitlab::FGitlabAuth::FGitlabAuth() {
    gitlab::FGitlabAuth_Init(*this);
}

inline gitlab::FGitlabAuth::~FGitlabAuth() {
    gitlab::FGitlabAuth_Uninit(*this);
}

inline gitlab::FHttp::FHttp() {
    gitlab::FHttp_Init(*this);
}

inline gitlab::FHttp::~FHttp() {
    gitlab::FHttp_Uninit(*this);
}


// --- gitlab.FHttp.request_header.EmptyQ
// Return true if index is empty
inline bool gitlab::request_header_EmptyQ(gitlab::FHttp& parent) {
    return parent.request_header_n == 0;
}

// --- gitlab.FHttp.request_header.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* gitlab::request_header_Find(gitlab::FHttp& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.request_header_n;
    if (idx >= lim) return NULL;
    return parent.request_header_elems + idx;
}

// --- gitlab.FHttp.request_header.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> gitlab::request_header_Getary(gitlab::FHttp& parent) {
    return algo::aryptr<algo::cstring>(parent.request_header_elems, parent.request_header_n);
}

// --- gitlab.FHttp.request_header.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* gitlab::request_header_Last(gitlab::FHttp& parent) {
    return request_header_Find(parent, u64(parent.request_header_n-1));
}

// --- gitlab.FHttp.request_header.Max
// Return max. number of items in the array
inline i32 gitlab::request_header_Max(gitlab::FHttp& parent) {
    (void)parent;
    return parent.request_header_max;
}

// --- gitlab.FHttp.request_header.N
// Return number of items in the array
inline i32 gitlab::request_header_N(const gitlab::FHttp& parent) {
    return parent.request_header_n;
}

// --- gitlab.FHttp.request_header.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void gitlab::request_header_Reserve(gitlab::FHttp& parent, int n) {
    u32 new_n = parent.request_header_n + n;
    if (UNLIKELY(new_n > parent.request_header_max)) {
        request_header_AbsReserve(parent, new_n);
    }
}

// --- gitlab.FHttp.request_header.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& gitlab::request_header_qFind(gitlab::FHttp& parent, u64 t) {
    return parent.request_header_elems[t];
}

// --- gitlab.FHttp.request_header.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& gitlab::request_header_qLast(gitlab::FHttp& parent) {
    return request_header_qFind(parent, u64(parent.request_header_n-1));
}

// --- gitlab.FHttp.request_header.rowid_Get
// Return row id of specified element
inline u64 gitlab::request_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) {
    u64 id = &elem - parent.request_header_elems;
    return u64(id);
}

// --- gitlab.FHttp.request_method.GetEnum
// Get value of field as enum type
inline gitlab_FHttp_request_method_Enum gitlab::request_method_GetEnum(const gitlab::FHttp& parent) {
    return gitlab_FHttp_request_method_Enum(parent.request_method);
}

// --- gitlab.FHttp.request_method.SetEnum
// Set value of field from enum type.
inline void gitlab::request_method_SetEnum(gitlab::FHttp& parent, gitlab_FHttp_request_method_Enum rhs) {
    parent.request_method = u32(rhs);
}

// --- gitlab.FHttp.response_header.EmptyQ
// Return true if index is empty
inline bool gitlab::response_header_EmptyQ(gitlab::FHttp& parent) {
    return parent.response_header_n == 0;
}

// --- gitlab.FHttp.response_header.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* gitlab::response_header_Find(gitlab::FHttp& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.response_header_n;
    if (idx >= lim) return NULL;
    return parent.response_header_elems + idx;
}

// --- gitlab.FHttp.response_header.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> gitlab::response_header_Getary(gitlab::FHttp& parent) {
    return algo::aryptr<algo::cstring>(parent.response_header_elems, parent.response_header_n);
}

// --- gitlab.FHttp.response_header.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* gitlab::response_header_Last(gitlab::FHttp& parent) {
    return response_header_Find(parent, u64(parent.response_header_n-1));
}

// --- gitlab.FHttp.response_header.Max
// Return max. number of items in the array
inline i32 gitlab::response_header_Max(gitlab::FHttp& parent) {
    (void)parent;
    return parent.response_header_max;
}

// --- gitlab.FHttp.response_header.N
// Return number of items in the array
inline i32 gitlab::response_header_N(const gitlab::FHttp& parent) {
    return parent.response_header_n;
}

// --- gitlab.FHttp.response_header.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void gitlab::response_header_Reserve(gitlab::FHttp& parent, int n) {
    u32 new_n = parent.response_header_n + n;
    if (UNLIKELY(new_n > parent.response_header_max)) {
        response_header_AbsReserve(parent, new_n);
    }
}

// --- gitlab.FHttp.response_header.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& gitlab::response_header_qFind(gitlab::FHttp& parent, u64 t) {
    return parent.response_header_elems[t];
}

// --- gitlab.FHttp.response_header.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& gitlab::response_header_qLast(gitlab::FHttp& parent) {
    return response_header_qFind(parent, u64(parent.response_header_n-1));
}

// --- gitlab.FHttp.response_header.rowid_Get
// Return row id of specified element
inline u64 gitlab::response_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) {
    u64 id = &elem - parent.response_header_elems;
    return u64(id);
}

// --- gitlab.FHttp.request_header_curs.Next
// proceed to next item
inline void gitlab::FHttp_request_header_curs_Next(FHttp_request_header_curs &curs) {
    curs.index++;
}

// --- gitlab.FHttp.request_header_curs.Reset
inline void gitlab::FHttp_request_header_curs_Reset(FHttp_request_header_curs &curs, gitlab::FHttp &parent) {
    curs.elems = parent.request_header_elems;
    curs.n_elems = parent.request_header_n;
    curs.index = 0;
}

// --- gitlab.FHttp.request_header_curs.ValidQ
// cursor points to valid item
inline bool gitlab::FHttp_request_header_curs_ValidQ(FHttp_request_header_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- gitlab.FHttp.request_header_curs.Access
// item access
inline algo::cstring& gitlab::FHttp_request_header_curs_Access(FHttp_request_header_curs &curs) {
    return curs.elems[curs.index];
}

// --- gitlab.FHttp.response_header_curs.Next
// proceed to next item
inline void gitlab::FHttp_response_header_curs_Next(FHttp_response_header_curs &curs) {
    curs.index++;
}

// --- gitlab.FHttp.response_header_curs.Reset
inline void gitlab::FHttp_response_header_curs_Reset(FHttp_response_header_curs &curs, gitlab::FHttp &parent) {
    curs.elems = parent.response_header_elems;
    curs.n_elems = parent.response_header_n;
    curs.index = 0;
}

// --- gitlab.FHttp.response_header_curs.ValidQ
// cursor points to valid item
inline bool gitlab::FHttp_response_header_curs_ValidQ(FHttp_response_header_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- gitlab.FHttp.response_header_curs.Access
// item access
inline algo::cstring& gitlab::FHttp_response_header_curs_Access(FHttp_response_header_curs &curs) {
    return curs.elems[curs.index];
}
inline gitlab::FIssue::FIssue() {
    gitlab::FIssue_Init(*this);
}

inline gitlab::FIssue::~FIssue() {
    gitlab::FIssue_Uninit(*this);
}


// --- gitlab.FIssue.c_issue_note.EmptyQ
// Return true if index is empty
inline bool gitlab::c_issue_note_EmptyQ(gitlab::FIssue& issue) {
    return issue.c_issue_note_n == 0;
}

// --- gitlab.FIssue.c_issue_note.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FIssueNote* gitlab::c_issue_note_Find(gitlab::FIssue& issue, u32 t) {
    gitlab::FIssueNote *retval = NULL;
    u64 idx = t;
    u64 lim = issue.c_issue_note_n;
    if (idx < lim) {
        retval = issue.c_issue_note_elems[idx];
    }
    return retval;
}

// --- gitlab.FIssue.c_issue_note.Getary
// Return array of pointers
inline algo::aryptr<gitlab::FIssueNote*> gitlab::c_issue_note_Getary(gitlab::FIssue& issue) {
    return algo::aryptr<gitlab::FIssueNote*>(issue.c_issue_note_elems, issue.c_issue_note_n);
}

// --- gitlab.FIssue.c_issue_note.N
// Return number of items in the pointer array
inline i32 gitlab::c_issue_note_N(const gitlab::FIssue& issue) {
    return issue.c_issue_note_n;
}

// --- gitlab.FIssue.c_issue_note.RemoveAll
// Empty the index. (The rows are not deleted)
inline void gitlab::c_issue_note_RemoveAll(gitlab::FIssue& issue) {
    for (u32 i = 0; i < issue.c_issue_note_n; i++) {
        // mark all elements as not-in-array
        issue.c_issue_note_elems[i]->issue_c_issue_note_in_ary = false;
    }
    issue.c_issue_note_n = 0;
}

// --- gitlab.FIssue.c_issue_description.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool gitlab::c_issue_description_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueDescription& row) {
    gitlab::FIssueDescription* ptr = issue.c_issue_description;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        issue.c_issue_description = &row;
    }
    return retval;
}

// --- gitlab.FIssue.c_issue_description.Remove
// Remove element from index. If element is not in index, do nothing.
inline void gitlab::c_issue_description_Remove(gitlab::FIssue& issue, gitlab::FIssueDescription& row) {
    gitlab::FIssueDescription *ptr = issue.c_issue_description;
    if (LIKELY(ptr == &row)) {
        issue.c_issue_description = NULL;
    }
}

// --- gitlab.FIssue.c_issue_note_curs.Reset
inline void gitlab::issue_c_issue_note_curs_Reset(issue_c_issue_note_curs &curs, gitlab::FIssue &parent) {
    curs.elems = parent.c_issue_note_elems;
    curs.n_elems = parent.c_issue_note_n;
    curs.index = 0;
}

// --- gitlab.FIssue.c_issue_note_curs.ValidQ
// cursor points to valid item
inline bool gitlab::issue_c_issue_note_curs_ValidQ(issue_c_issue_note_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- gitlab.FIssue.c_issue_note_curs.Next
// proceed to next item
inline void gitlab::issue_c_issue_note_curs_Next(issue_c_issue_note_curs &curs) {
    curs.index++;
}

// --- gitlab.FIssue.c_issue_note_curs.Access
// item access
inline gitlab::FIssueNote& gitlab::issue_c_issue_note_curs_Access(issue_c_issue_note_curs &curs) {
    return *curs.elems[curs.index];
}
inline gitlab::FIssueDescription::FIssueDescription() {
    gitlab::FIssueDescription_Init(*this);
}

inline gitlab::FIssueDescription::~FIssueDescription() {
    gitlab::FIssueDescription_Uninit(*this);
}


// --- gitlab.FIssueDescription..Init
// Set all fields to initial values.
inline void gitlab::FIssueDescription_Init(gitlab::FIssueDescription& issue_description) {
    issue_description.p_issue = NULL;
}
inline gitlab::FIssueNote::FIssueNote() {
    gitlab::FIssueNote_Init(*this);
}

inline gitlab::FIssueNote::~FIssueNote() {
    gitlab::FIssueNote_Uninit(*this);
}


// --- gitlab.FIssueNote..Init
// Set all fields to initial values.
inline void gitlab::FIssueNote_Init(gitlab::FIssueNote& issue_note) {
    issue_note.p_issue = NULL;
    issue_note.issue_c_issue_note_in_ary = bool(false);
    issue_note.ind_issue_note_next = (gitlab::FIssueNote*)-1; // (gitlab.FDb.ind_issue_note) not-in-hash
}
inline gitlab::FMr::FMr() {
    gitlab::FMr_Init(*this);
}

inline gitlab::FMr::~FMr() {
    gitlab::FMr_Uninit(*this);
}


// --- gitlab.FMr.c_mr_note.EmptyQ
// Return true if index is empty
inline bool gitlab::c_mr_note_EmptyQ(gitlab::FMr& mr) {
    return mr.c_mr_note_n == 0;
}

// --- gitlab.FMr.c_mr_note.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FMrNote* gitlab::c_mr_note_Find(gitlab::FMr& mr, u32 t) {
    gitlab::FMrNote *retval = NULL;
    u64 idx = t;
    u64 lim = mr.c_mr_note_n;
    if (idx < lim) {
        retval = mr.c_mr_note_elems[idx];
    }
    return retval;
}

// --- gitlab.FMr.c_mr_note.Getary
// Return array of pointers
inline algo::aryptr<gitlab::FMrNote*> gitlab::c_mr_note_Getary(gitlab::FMr& mr) {
    return algo::aryptr<gitlab::FMrNote*>(mr.c_mr_note_elems, mr.c_mr_note_n);
}

// --- gitlab.FMr.c_mr_note.N
// Return number of items in the pointer array
inline i32 gitlab::c_mr_note_N(const gitlab::FMr& mr) {
    return mr.c_mr_note_n;
}

// --- gitlab.FMr.c_mr_note.RemoveAll
// Empty the index. (The rows are not deleted)
inline void gitlab::c_mr_note_RemoveAll(gitlab::FMr& mr) {
    for (u32 i = 0; i < mr.c_mr_note_n; i++) {
        // mark all elements as not-in-array
        mr.c_mr_note_elems[i]->mr_c_mr_note_in_ary = false;
    }
    mr.c_mr_note_n = 0;
}

// --- gitlab.FMr.c_mr_description.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool gitlab::c_mr_description_InsertMaybe(gitlab::FMr& mr, gitlab::FMrDescription& row) {
    gitlab::FMrDescription* ptr = mr.c_mr_description;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        mr.c_mr_description = &row;
    }
    return retval;
}

// --- gitlab.FMr.c_mr_description.Remove
// Remove element from index. If element is not in index, do nothing.
inline void gitlab::c_mr_description_Remove(gitlab::FMr& mr, gitlab::FMrDescription& row) {
    gitlab::FMrDescription *ptr = mr.c_mr_description;
    if (LIKELY(ptr == &row)) {
        mr.c_mr_description = NULL;
    }
}

// --- gitlab.FMr.c_mr_note_curs.Reset
inline void gitlab::mr_c_mr_note_curs_Reset(mr_c_mr_note_curs &curs, gitlab::FMr &parent) {
    curs.elems = parent.c_mr_note_elems;
    curs.n_elems = parent.c_mr_note_n;
    curs.index = 0;
}

// --- gitlab.FMr.c_mr_note_curs.ValidQ
// cursor points to valid item
inline bool gitlab::mr_c_mr_note_curs_ValidQ(mr_c_mr_note_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- gitlab.FMr.c_mr_note_curs.Next
// proceed to next item
inline void gitlab::mr_c_mr_note_curs_Next(mr_c_mr_note_curs &curs) {
    curs.index++;
}

// --- gitlab.FMr.c_mr_note_curs.Access
// item access
inline gitlab::FMrNote& gitlab::mr_c_mr_note_curs_Access(mr_c_mr_note_curs &curs) {
    return *curs.elems[curs.index];
}
inline gitlab::FMrDescription::FMrDescription() {
    gitlab::FMrDescription_Init(*this);
}

inline gitlab::FMrDescription::~FMrDescription() {
    gitlab::FMrDescription_Uninit(*this);
}


// --- gitlab.FMrDescription..Init
// Set all fields to initial values.
inline void gitlab::FMrDescription_Init(gitlab::FMrDescription& mr_description) {
    mr_description.p_mr = NULL;
}
inline gitlab::FMrNote::FMrNote() {
    gitlab::FMrNote_Init(*this);
}

inline gitlab::FMrNote::~FMrNote() {
    gitlab::FMrNote_Uninit(*this);
}


// --- gitlab.FMrNote..Init
// Set all fields to initial values.
inline void gitlab::FMrNote_Init(gitlab::FMrNote& mr_note) {
    mr_note.p_mr = NULL;
    mr_note.mr_c_mr_note_in_ary = bool(false);
    mr_note.ind_mr_note_next = (gitlab::FMrNote*)-1; // (gitlab.FDb.ind_mr_note) not-in-hash
}
inline gitlab::FProject::FProject() {
    gitlab::FProject_Init(*this);
}

inline gitlab::FProject::~FProject() {
    gitlab::FProject_Uninit(*this);
}


// --- gitlab.FProject.c_issue.EmptyQ
// Return true if index is empty
inline bool gitlab::c_issue_EmptyQ(gitlab::FProject& project) {
    return project.c_issue_n == 0;
}

// --- gitlab.FProject.c_issue.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FIssue* gitlab::c_issue_Find(gitlab::FProject& project, u32 t) {
    gitlab::FIssue *retval = NULL;
    u64 idx = t;
    u64 lim = project.c_issue_n;
    if (idx < lim) {
        retval = project.c_issue_elems[idx];
    }
    return retval;
}

// --- gitlab.FProject.c_issue.Getary
// Return array of pointers
inline algo::aryptr<gitlab::FIssue*> gitlab::c_issue_Getary(gitlab::FProject& project) {
    return algo::aryptr<gitlab::FIssue*>(project.c_issue_elems, project.c_issue_n);
}

// --- gitlab.FProject.c_issue.N
// Return number of items in the pointer array
inline i32 gitlab::c_issue_N(const gitlab::FProject& project) {
    return project.c_issue_n;
}

// --- gitlab.FProject.c_issue.RemoveAll
// Empty the index. (The rows are not deleted)
inline void gitlab::c_issue_RemoveAll(gitlab::FProject& project) {
    for (u32 i = 0; i < project.c_issue_n; i++) {
        // mark all elements as not-in-array
        project.c_issue_elems[i]->project_c_issue_in_ary = false;
    }
    project.c_issue_n = 0;
}

// --- gitlab.FProject.c_mr.EmptyQ
// Return true if index is empty
inline bool gitlab::c_mr_EmptyQ(gitlab::FProject& project) {
    return project.c_mr_n == 0;
}

// --- gitlab.FProject.c_mr.Find
// Look up row by row id. Return NULL if out of range
inline gitlab::FMr* gitlab::c_mr_Find(gitlab::FProject& project, u32 t) {
    gitlab::FMr *retval = NULL;
    u64 idx = t;
    u64 lim = project.c_mr_n;
    if (idx < lim) {
        retval = project.c_mr_elems[idx];
    }
    return retval;
}

// --- gitlab.FProject.c_mr.Getary
// Return array of pointers
inline algo::aryptr<gitlab::FMr*> gitlab::c_mr_Getary(gitlab::FProject& project) {
    return algo::aryptr<gitlab::FMr*>(project.c_mr_elems, project.c_mr_n);
}

// --- gitlab.FProject.c_mr.N
// Return number of items in the pointer array
inline i32 gitlab::c_mr_N(const gitlab::FProject& project) {
    return project.c_mr_n;
}

// --- gitlab.FProject.c_mr.RemoveAll
// Empty the index. (The rows are not deleted)
inline void gitlab::c_mr_RemoveAll(gitlab::FProject& project) {
    for (u32 i = 0; i < project.c_mr_n; i++) {
        // mark all elements as not-in-array
        project.c_mr_elems[i]->project_c_mr_in_ary = false;
    }
    project.c_mr_n = 0;
}

// --- gitlab.FProject..Init
// Set all fields to initial values.
inline void gitlab::FProject_Init(gitlab::FProject& project) {
    project.c_issue_elems = NULL; // (gitlab.FProject.c_issue)
    project.c_issue_n = 0; // (gitlab.FProject.c_issue)
    project.c_issue_max = 0; // (gitlab.FProject.c_issue)
    project.c_mr_elems = NULL; // (gitlab.FProject.c_mr)
    project.c_mr_n = 0; // (gitlab.FProject.c_mr)
    project.c_mr_max = 0; // (gitlab.FProject.c_mr)
    project.ind_project_next = (gitlab::FProject*)-1; // (gitlab.FDb.ind_project) not-in-hash
}

// --- gitlab.FProject.c_issue_curs.Reset
inline void gitlab::project_c_issue_curs_Reset(project_c_issue_curs &curs, gitlab::FProject &parent) {
    curs.elems = parent.c_issue_elems;
    curs.n_elems = parent.c_issue_n;
    curs.index = 0;
}

// --- gitlab.FProject.c_issue_curs.ValidQ
// cursor points to valid item
inline bool gitlab::project_c_issue_curs_ValidQ(project_c_issue_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- gitlab.FProject.c_issue_curs.Next
// proceed to next item
inline void gitlab::project_c_issue_curs_Next(project_c_issue_curs &curs) {
    curs.index++;
}

// --- gitlab.FProject.c_issue_curs.Access
// item access
inline gitlab::FIssue& gitlab::project_c_issue_curs_Access(project_c_issue_curs &curs) {
    return *curs.elems[curs.index];
}

// --- gitlab.FProject.c_mr_curs.Reset
inline void gitlab::project_c_mr_curs_Reset(project_c_mr_curs &curs, gitlab::FProject &parent) {
    curs.elems = parent.c_mr_elems;
    curs.n_elems = parent.c_mr_n;
    curs.index = 0;
}

// --- gitlab.FProject.c_mr_curs.ValidQ
// cursor points to valid item
inline bool gitlab::project_c_mr_curs_ValidQ(project_c_mr_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- gitlab.FProject.c_mr_curs.Next
// proceed to next item
inline void gitlab::project_c_mr_curs_Next(project_c_mr_curs &curs) {
    curs.index++;
}

// --- gitlab.FProject.c_mr_curs.Access
// item access
inline gitlab::FMr& gitlab::project_c_mr_curs_Access(project_c_mr_curs &curs) {
    return *curs.elems[curs.index];
}
inline gitlab::FUser::FUser() {
    gitlab::FUser_Init(*this);
}

inline gitlab::FUser::~FUser() {
    gitlab::FUser_Uninit(*this);
}


// --- gitlab.FUser..Init
// Set all fields to initial values.
inline void gitlab::FUser_Init(gitlab::FUser& user) {
    user.id = u32(0);
    user.ind_user_next = (gitlab::FUser*)-1; // (gitlab.FDb.ind_user) not-in-hash
}
inline gitlab::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline gitlab::FieldId::FieldId(gitlab_FieldIdEnum arg) { this->value = i32(arg); }
inline gitlab::FieldId::FieldId() {
    gitlab::FieldId_Init(*this);
}


// --- gitlab.FieldId.value.GetEnum
// Get value of field as enum type
inline gitlab_FieldIdEnum gitlab::value_GetEnum(const gitlab::FieldId& parent) {
    return gitlab_FieldIdEnum(parent.value);
}

// --- gitlab.FieldId.value.SetEnum
// Set value of field from enum type.
inline void gitlab::value_SetEnum(gitlab::FieldId& parent, gitlab_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- gitlab.FieldId.value.Cast
inline gitlab::FieldId::operator gitlab_FieldIdEnum () const {
    return gitlab_FieldIdEnum((*this).value);
}

// --- gitlab.FieldId..Init
// Set all fields to initial values.
inline void gitlab::FieldId_Init(gitlab::FieldId& parent) {
    parent.value = i32(-1);
}
inline gitlab::Issue::Issue() {
}

inline gitlab::IssueDescription::IssueDescription() {
}

inline gitlab::IssueNote::IssueNote() {
}

inline gitlab::Mr::Mr() {
}

inline gitlab::MrDescription::MrDescription() {
}

inline gitlab::MrNote::MrNote() {
}

inline gitlab::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline gitlab::TableId::TableId(gitlab_TableIdEnum arg) { this->value = i32(arg); }
inline gitlab::TableId::TableId() {
    gitlab::TableId_Init(*this);
}


// --- gitlab.TableId.value.GetEnum
// Get value of field as enum type
inline gitlab_TableIdEnum gitlab::value_GetEnum(const gitlab::TableId& parent) {
    return gitlab_TableIdEnum(parent.value);
}

// --- gitlab.TableId.value.SetEnum
// Set value of field from enum type.
inline void gitlab::value_SetEnum(gitlab::TableId& parent, gitlab_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- gitlab.TableId.value.Cast
inline gitlab::TableId::operator gitlab_TableIdEnum () const {
    return gitlab_TableIdEnum((*this).value);
}

// --- gitlab.TableId..Init
// Set all fields to initial values.
inline void gitlab::TableId_Init(gitlab::TableId& parent) {
    parent.value = i32(-1);
}
inline gitlab::User::User() {
    gitlab::User_Init(*this);
}


// --- gitlab.User..Init
// Set all fields to initial values.
inline void gitlab::User_Init(gitlab::User& parent) {
    parent.id = u32(0);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::trace &row) {// cfmt:gitlab.trace.String
    gitlab::trace_Print(const_cast<gitlab::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FHttp &row) {// cfmt:gitlab.FHttp.String
    gitlab::FHttp_Print(const_cast<gitlab::FHttp&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FIssue &row) {// cfmt:gitlab.FIssue.String
    gitlab::FIssue_Print(const_cast<gitlab::FIssue&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FMr &row) {// cfmt:gitlab.FMr.String
    gitlab::FMr_Print(const_cast<gitlab::FMr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::FieldId &row) {// cfmt:gitlab.FieldId.String
    gitlab::FieldId_Print(const_cast<gitlab::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::Issue &row) {// cfmt:gitlab.Issue.String
    gitlab::Issue_Print(const_cast<gitlab::Issue&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::IssueDescription &row) {// cfmt:gitlab.IssueDescription.String
    gitlab::IssueDescription_Print(const_cast<gitlab::IssueDescription&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::IssueNote &row) {// cfmt:gitlab.IssueNote.String
    gitlab::IssueNote_Print(const_cast<gitlab::IssueNote&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::Mr &row) {// cfmt:gitlab.Mr.String
    gitlab::Mr_Print(const_cast<gitlab::Mr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::MrDescription &row) {// cfmt:gitlab.MrDescription.String
    gitlab::MrDescription_Print(const_cast<gitlab::MrDescription&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::MrNote &row) {// cfmt:gitlab.MrNote.String
    gitlab::MrNote_Print(const_cast<gitlab::MrNote&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const gitlab::TableId &row) {// cfmt:gitlab.TableId.String
    gitlab::TableId_Print(const_cast<gitlab::TableId&>(row), str);
    return str;
}
