//
// include/gen/atf_ci_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/dev_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/dmmeta_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- atf_ci_FieldIdEnum

enum atf_ci_FieldIdEnum {        // atf_ci.FieldId.value
     atf_ci_FieldId_value   = 0
};

enum { atf_ci_FieldIdEnum_N = 1 };


// --- atf_ci_TableIdEnum

enum atf_ci_TableIdEnum {                    // atf_ci.TableId.value
     atf_ci_TableId_dev_Builddir      = 0    // dev.Builddir -> atf_ci.FBuilddir
    ,atf_ci_TableId_dev_builddir      = 0    // dev.builddir -> atf_ci.FBuilddir
    ,atf_ci_TableId_dev_Cfg           = 1    // dev.Cfg -> atf_ci.FCfg
    ,atf_ci_TableId_dev_cfg           = 1    // dev.cfg -> atf_ci.FCfg
    ,atf_ci_TableId_dev_Gitfile       = 2    // dev.Gitfile -> atf_ci.FGitfile
    ,atf_ci_TableId_dev_gitfile       = 2    // dev.gitfile -> atf_ci.FGitfile
    ,atf_ci_TableId_dev_Msgfile       = 3    // dev.Msgfile -> atf_ci.FMsgfile
    ,atf_ci_TableId_dev_msgfile       = 3    // dev.msgfile -> atf_ci.FMsgfile
    ,atf_ci_TableId_dev_Noindent      = 4    // dev.Noindent -> atf_ci.FNoindent
    ,atf_ci_TableId_dev_noindent      = 4    // dev.noindent -> atf_ci.FNoindent
    ,atf_ci_TableId_dmmeta_Ns         = 5    // dmmeta.Ns -> atf_ci.FNs
    ,atf_ci_TableId_dmmeta_ns         = 5    // dmmeta.ns -> atf_ci.FNs
    ,atf_ci_TableId_dev_Readme        = 6    // dev.Readme -> atf_ci.FReadme
    ,atf_ci_TableId_dev_readme        = 6    // dev.readme -> atf_ci.FReadme
    ,atf_ci_TableId_dev_Scriptfile    = 7    // dev.Scriptfile -> atf_ci.FScriptfile
    ,atf_ci_TableId_dev_scriptfile    = 7    // dev.scriptfile -> atf_ci.FScriptfile
    ,atf_ci_TableId_dmmeta_Ssimfile   = 8    // dmmeta.Ssimfile -> atf_ci.FSsimfile
    ,atf_ci_TableId_dmmeta_ssimfile   = 8    // dmmeta.ssimfile -> atf_ci.FSsimfile
    ,atf_ci_TableId_dev_Ssimfs        = 9    // dev.Ssimfs -> atf_ci.FSsimfs
    ,atf_ci_TableId_dev_ssimfs        = 9    // dev.ssimfs -> atf_ci.FSsimfs
    ,atf_ci_TableId_dev_Targsrc       = 10   // dev.Targsrc -> atf_ci.FTargsrc
    ,atf_ci_TableId_dev_targsrc       = 10   // dev.targsrc -> atf_ci.FTargsrc
};

enum { atf_ci_TableIdEnum_N = 22 };

namespace atf_ci { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace atf_ci { // gen:ns_field
extern const char *atf_ci_help;
} // gen:ns_field
// gen:ns_fwddecl2
namespace dev { struct Builddir; }
namespace dev { struct Cfg; }
namespace atfdb { struct Citest; }
namespace dev { struct Gitfile; }
namespace dev { struct Msgfile; }
namespace dev { struct Noindent; }
namespace dmmeta { struct Ns; }
namespace dev { struct Readme; }
namespace dev { struct Scriptfile; }
namespace dmmeta { struct Ssimfile; }
namespace dev { struct Ssimfs; }
namespace dev { struct Targsrc; }
namespace atf_ci { struct _db_citest_curs; }
namespace atf_ci { struct _db_ssimfile_curs; }
namespace atf_ci { struct _db_scriptfile_curs; }
namespace atf_ci { struct _db_ns_curs; }
namespace atf_ci { struct _db_readme_curs; }
namespace atf_ci { struct _db_builddir_curs; }
namespace atf_ci { struct _db_cfg_curs; }
namespace atf_ci { struct _db_gitfile_curs; }
namespace atf_ci { struct _db_noindent_curs; }
namespace atf_ci { struct _db_targsrc_curs; }
namespace atf_ci { struct _db_msgfile_curs; }
namespace atf_ci { struct _db_ssimfs_curs; }
namespace atf_ci { struct _db_file_curs; }
namespace atf_ci { struct FBuilddir; }
namespace atf_ci { struct FCfg; }
namespace atf_ci { struct FCitest; }
namespace atf_ci { struct trace; }
namespace atf_ci { struct FDb; }
namespace atf_ci { struct FExecLimit; }
namespace atf_ci { struct FGitfile; }
namespace atf_ci { struct FMsgfile; }
namespace atf_ci { struct FNoindent; }
namespace atf_ci { struct FNs; }
namespace atf_ci { struct FReadme; }
namespace atf_ci { struct FScriptfile; }
namespace atf_ci { struct FSsimfile; }
namespace atf_ci { struct FSsimfs; }
namespace atf_ci { struct FTargsrc; }
namespace atf_ci { struct FieldId; }
namespace atf_ci { struct File; }
namespace atf_ci { struct TableId; }
namespace atf_ci { extern struct atf_ci::FDb _db; }
namespace atf_ci { // hook_fcn_typedef
    typedef void (*citest_step_hook)(); // hook:atf_ci.FCitest.step
} // hook_decl
namespace atf_ci { // gen:ns_gsymbol
    extern const atfdb::CijobPkey atfdb_cijob_comp; // "comp"
    extern const atfdb::CijobPkey atfdb_cijob_memcheck; // "memcheck"
    extern const atfdb::CijobPkey atfdb_cijob_normalize; // "normalize"
} // gen:ns_gsymbol
namespace atf_ci { // gen:ns_gsymbol
    extern const dev::GitfilePkey dev_gitfile_conf_copyright_txt; // "conf/copyright.txt"
} // gen:ns_gsymbol
namespace atf_ci { // gen:ns_gsymbol
    extern const char* dev_scriptfile_bin_find_non_copyrighted; // "bin/find-non-copyrighted"
    extern const char* dev_scriptfile_bin_fix_gen_conflicts; // "bin/fix-gen-conflicts"
    extern const char* dev_scriptfile_bin_update_gitfile; // "bin/update-gitfile"
    extern const char* dev_scriptfile_bin_update_hdr; // "bin/update-hdr"
    extern const char* dev_scriptfile_bin_update_scriptfile; // "bin/update-scriptfile"
} // gen:ns_gsymbol
namespace atf_ci { // gen:ns_print_struct

// --- atf_ci.FBuilddir
// create: atf_ci.FDb.builddir (Lary)
// global access: ind_builddir (Thash)
struct FBuilddir { // atf_ci.FBuilddir
    algo::Smallstr50     builddir;            //
    algo::Comment        comment;             //
    atf_ci::FBuilddir*   ind_builddir_next;   // hash next
private:
    friend atf_ci::FBuilddir&   builddir_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FBuilddir*   builddir_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 builddir_RemoveAll() __attribute__((nothrow));
    friend void                 builddir_RemoveLast() __attribute__((nothrow));
    FBuilddir();
    ~FBuilddir();
    FBuilddir(const FBuilddir&){ /*disallow copy constructor */}
    void operator =(const FBuilddir&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 builddir_CopyOut(atf_ci::FBuilddir &row, dev::Builddir &out) __attribute__((nothrow));
// Copy fields in to row
void                 builddir_CopyIn(atf_ci::FBuilddir &row, dev::Builddir &in) __attribute__((nothrow));

algo::Smallstr50     uname_Get(atf_ci::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     compiler_Get(atf_ci::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     cfg_Get(atf_ci::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     arch_Get(atf_ci::FBuilddir& builddir) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FBuilddir_Init(atf_ci::FBuilddir& builddir);
void                 FBuilddir_Uninit(atf_ci::FBuilddir& builddir) __attribute__((nothrow));

// --- atf_ci.FCfg
// create: atf_ci.FDb.cfg (Lary)
struct FCfg { // atf_ci.FCfg
    algo::Smallstr50   cfg;       //
    algo::Smallstr5    suffix;    //
    algo::Comment      comment;   //
private:
    friend atf_ci::FCfg&        cfg_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FCfg*        cfg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfg_RemoveAll() __attribute__((nothrow));
    friend void                 cfg_RemoveLast() __attribute__((nothrow));
    FCfg();
};

// Copy fields out of row
void                 cfg_CopyOut(atf_ci::FCfg &row, dev::Cfg &out) __attribute__((nothrow));
// Copy fields in to row
void                 cfg_CopyIn(atf_ci::FCfg &row, dev::Cfg &in) __attribute__((nothrow));


// --- atf_ci.FCitest
// create: atf_ci.FDb.citest (Lary)
// global access: c_citest (Ptr)
// global access: ind_citest (Thash)
struct FCitest { // atf_ci.FCitest
    algo::Smallstr50           citest;            //
    algo::Smallstr50           cijob;             //   "test"
    bool                       sandbox;           //   false  Run test in sandbox
    algo::Comment              comment;           //
    i32                        nerr;              //   0
    atf_ci::citest_step_hook   step;              //   NULL  Pointer to a function
    atf_ci::FCitest*           ind_citest_next;   // hash next
private:
    friend atf_ci::FCitest&     citest_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FCitest*     citest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 citest_RemoveAll() __attribute__((nothrow));
    friend void                 citest_RemoveLast() __attribute__((nothrow));
    FCitest();
    ~FCitest();
    FCitest(const FCitest&){ /*disallow copy constructor */}
    void operator =(const FCitest&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 citest_CopyOut(atf_ci::FCitest &row, atfdb::Citest &out) __attribute__((nothrow));
// Copy fields in to row
void                 citest_CopyIn(atf_ci::FCitest &row, atfdb::Citest &in) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(atf_ci::FCitest& citest) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCitest_Init(atf_ci::FCitest& citest);
void                 FCitest_Uninit(atf_ci::FCitest& citest) __attribute__((nothrow));

// --- atf_ci.trace
#pragma pack(push,1)
struct trace { // atf_ci.trace
    trace();
};
#pragma pack(pop)

// print string representation of atf_ci::trace to string LHS, no header -- cprint:atf_ci.trace.String
void                 trace_Print(atf_ci::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_ci.FDb
// create: atf_ci.FDb._db (Global)
struct FDb { // atf_ci.FDb
    command::atf_ci         cmdline;                        //
    atf_ci::FCitest*        citest_lary[32];                // level array
    i32                     citest_n;                       // number of elements in array
    atf_ci::FSsimfile*      ssimfile_lary[32];              // level array
    i32                     ssimfile_n;                     // number of elements in array
    atf_ci::FSsimfile**     ind_ssimfile_buckets_elems;     // pointer to bucket array
    i32                     ind_ssimfile_buckets_n;         // number of elements in bucket array
    i32                     ind_ssimfile_n;                 // number of elements in the hash table
    atf_ci::FCitest*        c_citest;                       // optional pointer
    atf_ci::FScriptfile*    scriptfile_lary[32];            // level array
    i32                     scriptfile_n;                   // number of elements in array
    atf_ci::FScriptfile**   ind_scriptfile_buckets_elems;   // pointer to bucket array
    i32                     ind_scriptfile_buckets_n;       // number of elements in bucket array
    i32                     ind_scriptfile_n;               // number of elements in the hash table
    atf_ci::FNs*            ns_lary[32];                    // level array
    i32                     ns_n;                           // number of elements in array
    atf_ci::FNs**           ind_ns_buckets_elems;           // pointer to bucket array
    i32                     ind_ns_buckets_n;               // number of elements in bucket array
    i32                     ind_ns_n;                       // number of elements in the hash table
    atf_ci::FReadme*        readme_lary[32];                // level array
    i32                     readme_n;                       // number of elements in array
    atf_ci::FBuilddir*      builddir_lary[32];              // level array
    i32                     builddir_n;                     // number of elements in array
    atf_ci::FCfg*           cfg_lary[32];                   // level array
    i32                     cfg_n;                          // number of elements in array
    atf_ci::FBuilddir**     ind_builddir_buckets_elems;     // pointer to bucket array
    i32                     ind_builddir_buckets_n;         // number of elements in bucket array
    i32                     ind_builddir_n;                 // number of elements in the hash table
    atf_ci::FGitfile*       gitfile_lary[32];               // level array
    i32                     gitfile_n;                      // number of elements in array
    atf_ci::FGitfile**      ind_gitfile_buckets_elems;      // pointer to bucket array
    i32                     ind_gitfile_buckets_n;          // number of elements in bucket array
    i32                     ind_gitfile_n;                  // number of elements in the hash table
    atf_ci::FNoindent*      noindent_lary[32];              // level array
    i32                     noindent_n;                     // number of elements in array
    atf_ci::FTargsrc*       targsrc_lary[32];               // level array
    i32                     targsrc_n;                      // number of elements in array
    atf_ci::FMsgfile*       msgfile_lary[32];               // level array
    i32                     msgfile_n;                      // number of elements in array
    atf_ci::FCitest**       ind_citest_buckets_elems;       // pointer to bucket array
    i32                     ind_citest_buckets_n;           // number of elements in bucket array
    i32                     ind_citest_n;                   // number of elements in the hash table
    atf_ci::FSsimfs*        ssimfs_lary[32];                // level array
    i32                     ssimfs_n;                       // number of elements in array
    atf_ci::File*           file_lary[32];                  // level array
    i32                     file_n;                         // number of elements in array
    atf_ci::File**          ind_file_buckets_elems;         // pointer to bucket array
    i32                     ind_file_buckets_n;             // number of elements in bucket array
    i32                     ind_file_n;                     // number of elements in the hash table
    bool                    sandbox_need_init;              //   false
    atf_ci::trace           trace;                          //
};

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     atf_ci.FDb.cmdline
//     algo_lib.FDb.cmdline
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Calls Step function of dependencies
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FCitest&     citest_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FCitest*     citest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FCitest*     citest_InsertMaybe(const atfdb::Citest &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                citest_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 citest_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FCitest*     citest_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FCitest*     citest_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  citest_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 citest_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 citest_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FCitest&     citest_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 citest_XrefMaybe(atf_ci::FCitest &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FSsimfile*   ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FSsimfile*   ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FSsimfile*   ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FSsimfile&   ssimfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimfile_XrefMaybe(atf_ci::FSsimfile &row);

// Return true if hash is empty
bool                 ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::FSsimfile*   ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::FSsimfile&   ind_ssimfile_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_ci::FSsimfile&   ind_ssimfile_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimfile_InsertMaybe(atf_ci::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimfile_Remove(atf_ci::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FScriptfile& scriptfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FScriptfile* scriptfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FScriptfile* scriptfile_InsertMaybe(const dev::Scriptfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                scriptfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 scriptfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FScriptfile* scriptfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FScriptfile* scriptfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  scriptfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 scriptfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 scriptfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FScriptfile& scriptfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 scriptfile_XrefMaybe(atf_ci::FScriptfile &row);

// Return true if hash is empty
bool                 ind_scriptfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::FScriptfile* ind_scriptfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::FScriptfile& ind_scriptfile_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_scriptfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_scriptfile_InsertMaybe(atf_ci::FScriptfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_scriptfile_Remove(atf_ci::FScriptfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_scriptfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FNs*         ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ns_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FNs*         ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FNs*         ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 ns_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FNs&         ns_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ns_XrefMaybe(atf_ci::FNs &row);

// Return true if hash is empty
bool                 ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::FNs*         ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::FNs&         ind_ns_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_ci::FNs&         ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ns_InsertMaybe(atf_ci::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ns_Remove(atf_ci::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FReadme&     readme_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FReadme*     readme_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FReadme*     readme_InsertMaybe(const dev::Readme &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                readme_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 readme_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FReadme*     readme_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FReadme*     readme_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  readme_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 readme_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 readme_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FReadme&     readme_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 readme_XrefMaybe(atf_ci::FReadme &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FBuilddir&   builddir_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FBuilddir*   builddir_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FBuilddir*   builddir_InsertMaybe(const dev::Builddir &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                builddir_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 builddir_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FBuilddir*   builddir_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FBuilddir*   builddir_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  builddir_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 builddir_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 builddir_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FBuilddir&   builddir_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 builddir_XrefMaybe(atf_ci::FBuilddir &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FCfg&        cfg_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FCfg*        cfg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FCfg*        cfg_InsertMaybe(const dev::Cfg &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cfg_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cfg_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FCfg*        cfg_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FCfg*        cfg_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cfg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cfg_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cfg_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FCfg&        cfg_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 cfg_XrefMaybe(atf_ci::FCfg &row);

// Return true if hash is empty
bool                 ind_builddir_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::FBuilddir*   ind_builddir_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::FBuilddir&   ind_builddir_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_ci::FBuilddir&   ind_builddir_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_builddir_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_builddir_InsertMaybe(atf_ci::FBuilddir& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_builddir_Remove(atf_ci::FBuilddir& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_builddir_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FGitfile&    gitfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FGitfile*    gitfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FGitfile*    gitfile_InsertMaybe(const dev::Gitfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gitfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gitfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FGitfile*    gitfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FGitfile*    gitfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gitfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gitfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gitfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FGitfile&    gitfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gitfile_XrefMaybe(atf_ci::FGitfile &row);

// Return true if hash is empty
bool                 ind_gitfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::FGitfile*    ind_gitfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::FGitfile&    ind_gitfile_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_ci::FGitfile&    ind_gitfile_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gitfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gitfile_InsertMaybe(atf_ci::FGitfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gitfile_Remove(atf_ci::FGitfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gitfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FNoindent&   noindent_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FNoindent*   noindent_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FNoindent*   noindent_InsertMaybe(const dev::Noindent &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                noindent_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 noindent_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FNoindent*   noindent_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FNoindent*   noindent_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  noindent_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 noindent_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 noindent_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FNoindent&   noindent_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 noindent_XrefMaybe(atf_ci::FNoindent &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FTargsrc*    targsrc_InsertMaybe(const dev::Targsrc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                targsrc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 targsrc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FTargsrc*    targsrc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FTargsrc*    targsrc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  targsrc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 targsrc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 targsrc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FTargsrc&    targsrc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 targsrc_XrefMaybe(atf_ci::FTargsrc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FMsgfile&    msgfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FMsgfile*    msgfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FMsgfile*    msgfile_InsertMaybe(const dev::Msgfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                msgfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 msgfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FMsgfile*    msgfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FMsgfile*    msgfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  msgfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 msgfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 msgfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FMsgfile&    msgfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 msgfile_XrefMaybe(atf_ci::FMsgfile &row);

// Return true if hash is empty
bool                 ind_citest_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::FCitest*     ind_citest_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::FCitest&     ind_citest_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_ci::FCitest&     ind_citest_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_citest_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_citest_InsertMaybe(atf_ci::FCitest& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_citest_Remove(atf_ci::FCitest& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_citest_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::FSsimfs&     ssimfs_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::FSsimfs*     ssimfs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_ci::FSsimfs*     ssimfs_InsertMaybe(const dev::Ssimfs &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfs_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfs_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::FSsimfs*     ssimfs_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::FSsimfs*     ssimfs_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfs_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 ssimfs_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfs_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::FSsimfs&     ssimfs_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 ssimfs_XrefMaybe(atf_ci::FSsimfs &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_ci::File&        file_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_ci::File*        file_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                file_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 file_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
atf_ci::File*        file_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
atf_ci::File*        file_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  file_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 file_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 file_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_ci::File&        file_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 file_XrefMaybe(atf_ci::File &row);

// Return true if hash is empty
bool                 ind_file_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_ci::File*        ind_file_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_ci::File&        ind_file_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_ci::File&        ind_file_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_file_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_file_InsertMaybe(atf_ci::File& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_file_Remove(atf_ci::File& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_file_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
void                 _db_citest_curs_Reset(_db_citest_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_citest_curs_ValidQ(_db_citest_curs &curs);
// proceed to next item
void                 _db_citest_curs_Next(_db_citest_curs &curs);
// item access
atf_ci::FCitest&     _db_citest_curs_Access(_db_citest_curs &curs);
// cursor points to valid item
void                 _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs);
// proceed to next item
void                 _db_ssimfile_curs_Next(_db_ssimfile_curs &curs);
// item access
atf_ci::FSsimfile&   _db_ssimfile_curs_Access(_db_ssimfile_curs &curs);
// cursor points to valid item
void                 _db_scriptfile_curs_Reset(_db_scriptfile_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_scriptfile_curs_ValidQ(_db_scriptfile_curs &curs);
// proceed to next item
void                 _db_scriptfile_curs_Next(_db_scriptfile_curs &curs);
// item access
atf_ci::FScriptfile& _db_scriptfile_curs_Access(_db_scriptfile_curs &curs);
// cursor points to valid item
void                 _db_ns_curs_Reset(_db_ns_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_ns_curs_ValidQ(_db_ns_curs &curs);
// proceed to next item
void                 _db_ns_curs_Next(_db_ns_curs &curs);
// item access
atf_ci::FNs&         _db_ns_curs_Access(_db_ns_curs &curs);
// cursor points to valid item
void                 _db_readme_curs_Reset(_db_readme_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_readme_curs_ValidQ(_db_readme_curs &curs);
// proceed to next item
void                 _db_readme_curs_Next(_db_readme_curs &curs);
// item access
atf_ci::FReadme&     _db_readme_curs_Access(_db_readme_curs &curs);
// cursor points to valid item
void                 _db_builddir_curs_Reset(_db_builddir_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_builddir_curs_ValidQ(_db_builddir_curs &curs);
// proceed to next item
void                 _db_builddir_curs_Next(_db_builddir_curs &curs);
// item access
atf_ci::FBuilddir&   _db_builddir_curs_Access(_db_builddir_curs &curs);
// cursor points to valid item
void                 _db_cfg_curs_Reset(_db_cfg_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_cfg_curs_ValidQ(_db_cfg_curs &curs);
// proceed to next item
void                 _db_cfg_curs_Next(_db_cfg_curs &curs);
// item access
atf_ci::FCfg&        _db_cfg_curs_Access(_db_cfg_curs &curs);
// cursor points to valid item
void                 _db_gitfile_curs_Reset(_db_gitfile_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_gitfile_curs_ValidQ(_db_gitfile_curs &curs);
// proceed to next item
void                 _db_gitfile_curs_Next(_db_gitfile_curs &curs);
// item access
atf_ci::FGitfile&    _db_gitfile_curs_Access(_db_gitfile_curs &curs);
// cursor points to valid item
void                 _db_noindent_curs_Reset(_db_noindent_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_noindent_curs_ValidQ(_db_noindent_curs &curs);
// proceed to next item
void                 _db_noindent_curs_Next(_db_noindent_curs &curs);
// item access
atf_ci::FNoindent&   _db_noindent_curs_Access(_db_noindent_curs &curs);
// cursor points to valid item
void                 _db_targsrc_curs_Reset(_db_targsrc_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_targsrc_curs_ValidQ(_db_targsrc_curs &curs);
// proceed to next item
void                 _db_targsrc_curs_Next(_db_targsrc_curs &curs);
// item access
atf_ci::FTargsrc&    _db_targsrc_curs_Access(_db_targsrc_curs &curs);
// cursor points to valid item
void                 _db_msgfile_curs_Reset(_db_msgfile_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_msgfile_curs_ValidQ(_db_msgfile_curs &curs);
// proceed to next item
void                 _db_msgfile_curs_Next(_db_msgfile_curs &curs);
// item access
atf_ci::FMsgfile&    _db_msgfile_curs_Access(_db_msgfile_curs &curs);
// cursor points to valid item
void                 _db_ssimfs_curs_Reset(_db_ssimfs_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfs_curs_ValidQ(_db_ssimfs_curs &curs);
// proceed to next item
void                 _db_ssimfs_curs_Next(_db_ssimfs_curs &curs);
// item access
atf_ci::FSsimfs&     _db_ssimfs_curs_Access(_db_ssimfs_curs &curs);
// cursor points to valid item
void                 _db_file_curs_Reset(_db_file_curs &curs, atf_ci::FDb &parent);
// cursor points to valid item
bool                 _db_file_curs_ValidQ(_db_file_curs &curs);
// proceed to next item
void                 _db_file_curs_Next(_db_file_curs &curs);
// item access
atf_ci::File&        _db_file_curs_Access(_db_file_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- atf_ci.FExecLimit
struct FExecLimit { // atf_ci.FExecLimit
    FExecLimit();
};


// --- atf_ci.FGitfile
// create: atf_ci.FDb.gitfile (Lary)
// global access: ind_gitfile (Thash)
struct FGitfile { // atf_ci.FGitfile
    atf_ci::FGitfile*      ind_gitfile_next;   // hash next
    algo::Smallstr200      gitfile;            //
    atf_ci::FNoindent*     c_noindent;         // optional pointer
    atf_ci::FScriptfile*   c_scriptfile;       // optional pointer
    atf_ci::FTargsrc*      c_targsrc;          // optional pointer
private:
    friend atf_ci::FGitfile&    gitfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FGitfile*    gitfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gitfile_RemoveAll() __attribute__((nothrow));
    friend void                 gitfile_RemoveLast() __attribute__((nothrow));
    FGitfile();
    ~FGitfile();
    FGitfile(const FGitfile&){ /*disallow copy constructor */}
    void operator =(const FGitfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gitfile_CopyOut(atf_ci::FGitfile &row, dev::Gitfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 gitfile_CopyIn(atf_ci::FGitfile &row, dev::Gitfile &in) __attribute__((nothrow));

algo::Smallstr50     ext_Get(atf_ci::FGitfile& gitfile) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_noindent_InsertMaybe(atf_ci::FGitfile& gitfile, atf_ci::FNoindent& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_noindent_Remove(atf_ci::FGitfile& gitfile, atf_ci::FNoindent& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_scriptfile_InsertMaybe(atf_ci::FGitfile& gitfile, atf_ci::FScriptfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_scriptfile_Remove(atf_ci::FGitfile& gitfile, atf_ci::FScriptfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_targsrc_InsertMaybe(atf_ci::FGitfile& gitfile, atf_ci::FTargsrc& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_targsrc_Remove(atf_ci::FGitfile& gitfile, atf_ci::FTargsrc& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGitfile_Init(atf_ci::FGitfile& gitfile);
void                 FGitfile_Uninit(atf_ci::FGitfile& gitfile) __attribute__((nothrow));

// --- atf_ci.FMsgfile
// create: atf_ci.FDb.msgfile (Lary)
struct FMsgfile { // atf_ci.FMsgfile
    algo::Smallstr200   gitfile;   // Name of file containing messages
    bool                strict;    //   false  Delete unrecognizable lines (except comments)
    algo::Comment       comment;   //
private:
    friend atf_ci::FMsgfile&    msgfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FMsgfile*    msgfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 msgfile_RemoveAll() __attribute__((nothrow));
    friend void                 msgfile_RemoveLast() __attribute__((nothrow));
    FMsgfile();
};

// Copy fields out of row
void                 msgfile_CopyOut(atf_ci::FMsgfile &row, dev::Msgfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 msgfile_CopyIn(atf_ci::FMsgfile &row, dev::Msgfile &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FMsgfile_Init(atf_ci::FMsgfile& msgfile);

// --- atf_ci.FNoindent
// create: atf_ci.FDb.noindent (Lary)
// access: atf_ci.FGitfile.c_noindent (Ptr)
struct FNoindent { // atf_ci.FNoindent
    algo::Smallstr200   gitfile;   //
    algo::Comment       comment;   //
private:
    friend atf_ci::FNoindent&   noindent_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FNoindent*   noindent_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 noindent_RemoveAll() __attribute__((nothrow));
    friend void                 noindent_RemoveLast() __attribute__((nothrow));
    FNoindent();
    ~FNoindent();
    FNoindent(const FNoindent&){ /*disallow copy constructor */}
    void operator =(const FNoindent&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 noindent_CopyOut(atf_ci::FNoindent &row, dev::Noindent &out) __attribute__((nothrow));
// Copy fields in to row
void                 noindent_CopyIn(atf_ci::FNoindent &row, dev::Noindent &in) __attribute__((nothrow));

void                 FNoindent_Uninit(atf_ci::FNoindent& noindent) __attribute__((nothrow));

// --- atf_ci.FNs
// create: atf_ci.FDb.ns (Lary)
// global access: ind_ns (Thash)
struct FNs { // atf_ci.FNs
    atf_ci::FNs*       ind_ns_next;   // hash next
    algo::Smallstr16   ns;            // Namespace name (primary key)
    algo::Smallstr50   nstype;        //
    algo::Smallstr50   license;       //
    algo::Comment      comment;       //
private:
    friend atf_ci::FNs&         ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FNs*         ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveAll() __attribute__((nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
    FNs();
    ~FNs();
    FNs(const FNs&){ /*disallow copy constructor */}
    void operator =(const FNs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ns_CopyOut(atf_ci::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
void                 ns_CopyIn(atf_ci::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNs_Init(atf_ci::FNs& ns);
void                 FNs_Uninit(atf_ci::FNs& ns) __attribute__((nothrow));

// --- atf_ci.FReadme
// create: atf_ci.FDb.readme (Lary)
struct FReadme { // atf_ci.FReadme
    algo::Smallstr200   gitfile;   //
    bool                inl;       //   false
    bool                sandbox;   //   false
    algo::Smallstr100   filter;    //
    algo::Comment       comment;   //
private:
    friend atf_ci::FReadme&     readme_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FReadme*     readme_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 readme_RemoveAll() __attribute__((nothrow));
    friend void                 readme_RemoveLast() __attribute__((nothrow));
    FReadme();
};

// Copy fields out of row
void                 readme_CopyOut(atf_ci::FReadme &row, dev::Readme &out) __attribute__((nothrow));
// Copy fields in to row
void                 readme_CopyIn(atf_ci::FReadme &row, dev::Readme &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FReadme_Init(atf_ci::FReadme& readme);

// --- atf_ci.FScriptfile
// create: atf_ci.FDb.scriptfile (Lary)
// global access: ind_scriptfile (Thash)
// access: atf_ci.FGitfile.c_scriptfile (Ptr)
struct FScriptfile { // atf_ci.FScriptfile
    atf_ci::FScriptfile*   ind_scriptfile_next;   // hash next
    algo::Smallstr200      gitfile;               //
    algo::Smallstr50       license;               //
    algo::Comment          comment;               //
private:
    friend atf_ci::FScriptfile& scriptfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FScriptfile* scriptfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 scriptfile_RemoveAll() __attribute__((nothrow));
    friend void                 scriptfile_RemoveLast() __attribute__((nothrow));
    FScriptfile();
    ~FScriptfile();
    FScriptfile(const FScriptfile&){ /*disallow copy constructor */}
    void operator =(const FScriptfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 scriptfile_CopyOut(atf_ci::FScriptfile &row, dev::Scriptfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 scriptfile_CopyIn(atf_ci::FScriptfile &row, dev::Scriptfile &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FScriptfile_Init(atf_ci::FScriptfile& scriptfile);
void                 FScriptfile_Uninit(atf_ci::FScriptfile& scriptfile) __attribute__((nothrow));

// --- atf_ci.FSsimfile
// create: atf_ci.FDb.ssimfile (Lary)
// global access: ind_ssimfile (Thash)
struct FSsimfile { // atf_ci.FSsimfile
    atf_ci::FSsimfile*   ind_ssimfile_next;   // hash next
    algo::Smallstr50     ssimfile;            //
    algo::Smallstr50     ctype;               //
private:
    friend atf_ci::FSsimfile&   ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FSsimfile*   ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
    FSsimfile();
    ~FSsimfile();
    FSsimfile(const FSsimfile&){ /*disallow copy constructor */}
    void operator =(const FSsimfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimfile_CopyOut(atf_ci::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimfile_CopyIn(atf_ci::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

algo::Smallstr16     ssimns_Get(atf_ci::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(atf_ci::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(atf_ci::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FSsimfile_Init(atf_ci::FSsimfile& ssimfile);
void                 FSsimfile_Uninit(atf_ci::FSsimfile& ssimfile) __attribute__((nothrow));

// --- atf_ci.FSsimfs
// create: atf_ci.FDb.ssimfs (Lary)
struct FSsimfs { // atf_ci.FSsimfs
    algo::Smallstr200   ssimfs;     //
    bool                rmfile;     //   false  Remove extra files from directory
    bool                needfile;   //   false  File must exist
    algo::cstring       lscmd;      // Command that produces keys that should be in the table
    algo_lib::Regx      excl;       // Sql Regx
    algo::Comment       comment;    //
private:
    friend atf_ci::FSsimfs&     ssimfs_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FSsimfs*     ssimfs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfs_RemoveAll() __attribute__((nothrow));
    friend void                 ssimfs_RemoveLast() __attribute__((nothrow));
    FSsimfs();
    // reftype Regx of atf_ci.FSsimfs.excl prohibits copy
    FSsimfs(const FSsimfs&){ /*disallow copy constructor */}
    void operator =(const FSsimfs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimfs_CopyOut(atf_ci::FSsimfs &row, dev::Ssimfs &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimfs_CopyIn(atf_ci::FSsimfs &row, dev::Ssimfs &in) __attribute__((nothrow));

algo::Smallstr50     ssimfile_Get(atf_ci::FSsimfs& ssimfs) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr150    file_Get(atf_ci::FSsimfs& ssimfs) __attribute__((__warn_unused_result__, nothrow));

// Print back to string
void                 excl_Print(atf_ci::FSsimfs& ssimfs, algo::cstring &out) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSsimfs_Init(atf_ci::FSsimfs& ssimfs);

// --- atf_ci.FTargsrc
// create: atf_ci.FDb.targsrc (Lary)
// access: atf_ci.FGitfile.c_targsrc (Ptr)
struct FTargsrc { // atf_ci.FTargsrc
    algo::Smallstr100   targsrc;   //
    algo::Comment       comment;   //
private:
    friend atf_ci::FTargsrc&    targsrc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::FTargsrc*    targsrc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targsrc_RemoveAll() __attribute__((nothrow));
    friend void                 targsrc_RemoveLast() __attribute__((nothrow));
    FTargsrc();
    ~FTargsrc();
    FTargsrc(const FTargsrc&){ /*disallow copy constructor */}
    void operator =(const FTargsrc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 targsrc_CopyOut(atf_ci::FTargsrc &row, dev::Targsrc &out) __attribute__((nothrow));
// Copy fields in to row
void                 targsrc_CopyIn(atf_ci::FTargsrc &row, dev::Targsrc &in) __attribute__((nothrow));

algo::Smallstr16     target_Get(atf_ci::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr200    src_Get(atf_ci::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr10     ext_Get(atf_ci::FTargsrc& targsrc) __attribute__((__warn_unused_result__, nothrow));

void                 FTargsrc_Uninit(atf_ci::FTargsrc& targsrc) __attribute__((nothrow));

// --- atf_ci.FieldId
#pragma pack(push,1)
struct FieldId { // atf_ci.FieldId: Field read helper
    i32   value;   //   -1
    inline operator atf_ci_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(atf_ci_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
atf_ci_FieldIdEnum   value_GetEnum(const atf_ci::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_ci::FieldId& parent, atf_ci_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_ci::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_ci::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_ci::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_ci::FieldId& parent, algo::strptr rhs, atf_ci_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_ci::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_ci::FieldId from an ascii string.
// The format of the string is the format of the atf_ci::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(atf_ci::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(atf_ci::FieldId& parent);
// print string representation of atf_ci::FieldId to string LHS, no header -- cprint:atf_ci.FieldId.String
void                 FieldId_Print(atf_ci::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_ci.File
// create: atf_ci.FDb.file (Lary)
// global access: ind_file (Thash)
struct File { // atf_ci.File
    atf_ci::File*   ind_file_next;   // hash next
    algo::cstring   file;            // Filename
    bool            file_exists;     //   false
    bool            record_exists;   //   false
private:
    friend atf_ci::File&        file_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_ci::File*        file_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 file_RemoveAll() __attribute__((nothrow));
    friend void                 file_RemoveLast() __attribute__((nothrow));
    File();
    ~File();
    File(const File&){ /*disallow copy constructor */}
    void operator =(const File&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 File_Init(atf_ci::File& file);
void                 File_Uninit(atf_ci::File& file) __attribute__((nothrow));

// --- atf_ci.TableId
struct TableId { // atf_ci.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator atf_ci_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(atf_ci_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
atf_ci_TableIdEnum   value_GetEnum(const atf_ci::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_ci::TableId& parent, atf_ci_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_ci::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_ci::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_ci::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_ci::TableId& parent, algo::strptr rhs, atf_ci_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_ci::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_ci::TableId from an ascii string.
// The format of the string is the format of the atf_ci::TableId's only field
bool                 TableId_ReadStrptrMaybe(atf_ci::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(atf_ci::TableId& parent);
// print string representation of atf_ci::TableId to string LHS, no header -- cprint:atf_ci.TableId.String
void                 TableId_Print(atf_ci::TableId & row, algo::cstring &str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace atf_ci { // gen:ns_curstext

struct _db_citest_curs {// cursor
    typedef atf_ci::FCitest ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_citest_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef atf_ci::FSsimfile ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_scriptfile_curs {// cursor
    typedef atf_ci::FScriptfile ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_scriptfile_curs(){ parent=NULL; index=0; }
};


struct _db_ns_curs {// cursor
    typedef atf_ci::FNs ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_readme_curs {// cursor
    typedef atf_ci::FReadme ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_readme_curs(){ parent=NULL; index=0; }
};


struct _db_builddir_curs {// cursor
    typedef atf_ci::FBuilddir ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_builddir_curs(){ parent=NULL; index=0; }
};


struct _db_cfg_curs {// cursor
    typedef atf_ci::FCfg ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_cfg_curs(){ parent=NULL; index=0; }
};


struct _db_gitfile_curs {// cursor
    typedef atf_ci::FGitfile ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_gitfile_curs(){ parent=NULL; index=0; }
};


struct _db_noindent_curs {// cursor
    typedef atf_ci::FNoindent ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_noindent_curs(){ parent=NULL; index=0; }
};


struct _db_targsrc_curs {// cursor
    typedef atf_ci::FTargsrc ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_targsrc_curs(){ parent=NULL; index=0; }
};


struct _db_msgfile_curs {// cursor
    typedef atf_ci::FMsgfile ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_msgfile_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfs_curs {// cursor
    typedef atf_ci::FSsimfs ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_ssimfs_curs(){ parent=NULL; index=0; }
};


struct _db_file_curs {// cursor
    typedef atf_ci::File ChildType;
    atf_ci::FDb *parent;
    i64 index;
    _db_file_curs(){ parent=NULL; index=0; }
};

} // gen:ns_curstext
namespace atf_ci { // gen:ns_func
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_checkclean();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_atf_amc();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_gitfile();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_normalize_acr();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_ssimfs();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_src_lim();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_amc();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_bootstrap();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_shebang();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_encoding();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_readme();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_file_header();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_non_copyrighted();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_iffy_src();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_stray_gen();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_tempcode();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_lineendings();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_indent_script();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_comptest();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_cppcheck();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_bintests();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_indent_srcfile();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_normalize_amc_vis();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_ssimfile();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_normalize_acr_my();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_atf_unit();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_atf_comp();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_atf_comp_cov();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_atf_comp_mem();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_acr_ed_ssimfile();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_acr_ed_ssimdb();
// User-implemented function from gstatic:atf_ci.FDb.citest
void                 citest_acr_ed_target();
} // gen:ns_func
int                  main(int argc, char **argv);
#if defined(WIN32)
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const atf_ci::trace &row);// cfmt:atf_ci.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_ci::FieldId &row);// cfmt:atf_ci.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_ci::TableId &row);// cfmt:atf_ci.TableId.String
}
