//
// include/gen/atf_amc_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/atfdb_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/dmmeta_gen.inl.h"
//#pragma endinclude
static atf_amc::FListtype &atf_amc_listtype_cd    = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[0];
static atf_amc::FListtype &atf_amc_listtype_cdl   = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[1];
static atf_amc::FListtype &atf_amc_listtype_cs    = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[2];
static atf_amc::FListtype &atf_amc_listtype_csl   = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[3];
static atf_amc::FListtype &atf_amc_listtype_zd    = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[4];
static atf_amc::FListtype &atf_amc_listtype_zdl   = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[5];
static atf_amc::FListtype &atf_amc_listtype_zs    = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[6];
static atf_amc::FListtype &atf_amc_listtype_zsl   = ((atf_amc::FListtype*)atf_amc::_db.listtype_data)[7];
inline atf_amc::AmcCleanup2::AmcCleanup2() {
    atf_amc::AmcCleanup2_Init(*this);
}

inline atf_amc::AmcCleanup2::~AmcCleanup2() {
    atf_amc::AmcCleanup2_Uninit(*this);
}


// --- atf_amc.AmcCleanup2..Init
// Set all fields to initial values.
inline void atf_amc::AmcCleanup2_Init(atf_amc::AmcCleanup2& parent) {
    parent.field1 = i32(0);
    parent.field2 = i32(0);
}
inline atf_amc::AmcSubstr1::AmcSubstr1() {
}

inline atf_amc::BitfldType1::BitfldType1() {
    atf_amc::BitfldType1_Init(*this);
}


// --- atf_amc.BitfldType1.bit1.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline u64 atf_amc::bit1_Get(const atf_amc::BitfldType1& parent) {
    return u64((parent.value >> 1) & 0x01);
}

// --- atf_amc.BitfldType1.bit1.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void atf_amc::bit1_Set(atf_amc::BitfldType1& parent, u64 rhs) {
    u64 t1    = u64(0x01) << 1;
    u64 t2    = (u64(rhs) & 0x01) << 1;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldType1.bits5.Get
// Retrieve bitfield from value of field value
//    10 bits starting at bit 5.
inline u64 atf_amc::bits5_Get(const atf_amc::BitfldType1& parent) {
    return u64((parent.value >> 5) & 0x3ff);
}

// --- atf_amc.BitfldType1.bits5.Set
// Set bitfield in value of field 'value'
//    10 bits starting at bit 5.
inline void atf_amc::bits5_Set(atf_amc::BitfldType1& parent, u64 rhs) {
    u64 t1    = u64(0x3ff) << 5;
    u64 t2    = (u64(rhs) & 0x3ff) << 5;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldType1..Init
// Set all fields to initial values.
inline void atf_amc::BitfldType1_Init(atf_amc::BitfldType1& parent) {
    parent.value = u64(0);
}
inline atf_amc::BitfldType2::BitfldType2() {
    atf_amc::BitfldType2_Init(*this);
}


// --- atf_amc.BitfldType2.bit0.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool atf_amc::bit0_Get(const atf_amc::BitfldType2& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- atf_amc.BitfldType2.bit0.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void atf_amc::bit0_Set(atf_amc::BitfldType2& parent, bool rhs) {
    u64 t1    = u64(0x01) << 0;
    u64 t2    = (u64(rhs) & 0x01) << 0;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldType2.bit1.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool atf_amc::bit1_Get(const atf_amc::BitfldType2& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- atf_amc.BitfldType2.bit1.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void atf_amc::bit1_Set(atf_amc::BitfldType2& parent, bool rhs) {
    u64 t1    = u64(0x01) << 1;
    u64 t2    = (u64(rhs) & 0x01) << 1;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldType2..Init
// Set all fields to initial values.
inline void atf_amc::BitfldType2_Init(atf_amc::BitfldType2& parent) {
    parent.value = u64(0);
    parent.freebool = bool(false);
}
inline atf_amc::BitfldU128::BitfldU128() {
    atf_amc::BitfldU128_Init(*this);
}


// --- atf_amc.BitfldU128.bits1_65.Get
// Retrieve bitfield from value of field value
//    64 bits starting at bit 1.
inline u64 atf_amc::bits1_65_Get(const atf_amc::BitfldU128& parent) {
    return u64((parent.value >> 1) & 0xffffffffffffffff);
}

// --- atf_amc.BitfldU128.bits1_65.Set
// Set bitfield in value of field 'value'
//    64 bits starting at bit 1.
inline void atf_amc::bits1_65_Set(atf_amc::BitfldU128& parent, u64 rhs) {
    u128 t1    = u128(0xffffffffffffffff) << 1;
    u128 t2    = (u128(rhs) & 0xffffffffffffffff) << 1;
    parent.value = u128((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldU128.bits65_128.Get
// Retrieve bitfield from value of field value
//    63 bits starting at bit 65.
inline u64 atf_amc::bits65_128_Get(const atf_amc::BitfldU128& parent) {
    return u64((parent.value >> 65) & 0x7fffffffffffffff);
}

// --- atf_amc.BitfldU128.bits65_128.Set
// Set bitfield in value of field 'value'
//    63 bits starting at bit 65.
inline void atf_amc::bits65_128_Set(atf_amc::BitfldU128& parent, u64 rhs) {
    u128 t1    = u128(0x7fffffffffffffff) << 65;
    u128 t2    = (u128(rhs) & 0x7fffffffffffffff) << 65;
    parent.value = u128((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldU128..Init
// Set all fields to initial values.
inline void atf_amc::BitfldU128_Init(atf_amc::BitfldU128& parent) {
    parent.value = u128(0);
}
inline atf_amc::BitfldU16::BitfldU16() {
    atf_amc::BitfldU16_Init(*this);
}


// --- atf_amc.BitfldU16.bits0_4.Get
// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
inline u8 atf_amc::bits0_4_Get(const atf_amc::BitfldU16& parent) {
    return u8((parent.value >> 0) & 0x0f);
}

// --- atf_amc.BitfldU16.bits0_4.Set
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
inline void atf_amc::bits0_4_Set(atf_amc::BitfldU16& parent, u8 rhs) {
    u16 t1    = u16(0x0f) << 0;
    u16 t2    = (u16(rhs) & 0x0f) << 0;
    parent.value = u16((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldU16.bits8_12.Get
// Retrieve bitfield from value of field value
//    4 bits starting at bit 8.
inline u8 atf_amc::bits8_12_Get(const atf_amc::BitfldU16& parent) {
    return u8((parent.value >> 8) & 0x0f);
}

// --- atf_amc.BitfldU16.bits8_12.Set
// Set bitfield in value of field 'value'
//    4 bits starting at bit 8.
inline void atf_amc::bits8_12_Set(atf_amc::BitfldU16& parent, u8 rhs) {
    u16 t1    = u16(0x0f) << 8;
    u16 t2    = (u16(rhs) & 0x0f) << 8;
    parent.value = u16((parent.value & ~t1) | t2);
}

// --- atf_amc.BitfldU16..Init
// Set all fields to initial values.
inline void atf_amc::BitfldU16_Init(atf_amc::BitfldU16& parent) {
    parent.value = u16(0);
}
inline atf_amc::Bytebuf::Bytebuf() {
    atf_amc::Bytebuf_Init(*this);
    // added because atf_amc.Bytebuf.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}


// --- atf_amc.Bytebuf.in.Max
// Return max. number of bytes in the buffer.
inline i32 atf_amc::in_Max(atf_amc::Bytebuf& bytebuf) {
    return 64;
    (void)bytebuf;//only to avoid -Wunused-parameter
}

// --- atf_amc.Bytebuf.in.N
// Return number of bytes in the buffer.
inline i32 atf_amc::in_N(atf_amc::Bytebuf& bytebuf) {
    return bytebuf.in_end - bytebuf.in_start;
}
inline atf_amc::BytebufDyn::BytebufDyn() {
    atf_amc::BytebufDyn_Init(*this);
    // added because atf_amc.BytebufDyn.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}

inline atf_amc::BytebufDyn::~BytebufDyn() {
    atf_amc::BytebufDyn_Uninit(*this);
}


// --- atf_amc.BytebufDyn.in.Max
// Return max. number of bytes in the buffer.
inline i32 atf_amc::in_Max(atf_amc::BytebufDyn& bytebuf_dyn) {
    return bytebuf_dyn.in_max;
}

// --- atf_amc.BytebufDyn.in.N
// Return number of bytes in the buffer.
inline i32 atf_amc::in_N(atf_amc::BytebufDyn& bytebuf_dyn) {
    return bytebuf_dyn.in_end - bytebuf_dyn.in_start;
}
inline atf_amc::Cstr::Cstr(const algo::strptr&            in_val)
    : val(in_val)
{
}

inline bool atf_amc::Cstr::operator ==(const atf_amc::Cstr &rhs) const {
    return atf_amc::Cstr_Eq(const_cast<atf_amc::Cstr&>(*this),const_cast<atf_amc::Cstr&>(rhs));
}

inline bool atf_amc::Cstr::operator !=(const atf_amc::Cstr &rhs) const {
    return !atf_amc::Cstr_Eq(const_cast<atf_amc::Cstr&>(*this),const_cast<atf_amc::Cstr&>(rhs));
}

inline bool atf_amc::Cstr::operator <(const atf_amc::Cstr &rhs) const {
    return atf_amc::Cstr_Lt(const_cast<atf_amc::Cstr&>(*this),const_cast<atf_amc::Cstr&>(rhs));
}

inline bool atf_amc::Cstr::operator >(const atf_amc::Cstr &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::Cstr::operator <=(const atf_amc::Cstr &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::Cstr::operator >=(const atf_amc::Cstr &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::Cstr::Cstr() {
}


// --- atf_amc.Cstr.val.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool atf_amc::val_Lt(atf_amc::Cstr& orig, atf_amc::Cstr &rhs) {
    return algo::cstring_Lt(orig.val,rhs.val);
}

// --- atf_amc.Cstr.val.Cmp
// Compare two fields.
inline i32 atf_amc::val_Cmp(atf_amc::Cstr& orig, atf_amc::Cstr &rhs) {
    i32 retval = 0;
    retval = algo::cstring_Cmp(orig.val, rhs.val);
    return retval;
}

// --- atf_amc.Cstr.val.Cast
inline atf_amc::Cstr::operator algo::strptr () const {
    return algo::strptr((*this).val);
}

// --- atf_amc.Cstr..Hash
inline u32 atf_amc::Cstr_Hash(u32 prev, const atf_amc::Cstr & rhs) {
    prev = cstring_Hash(prev, rhs.val);
    return prev;
}

// --- atf_amc.Cstr..Lt
inline bool atf_amc::Cstr_Lt(atf_amc::Cstr & lhs, atf_amc::Cstr & rhs) {
    return val_Lt(lhs,rhs);
}

// --- atf_amc.Cstr..Cmp
inline i32 atf_amc::Cstr_Cmp(atf_amc::Cstr & lhs, atf_amc::Cstr & rhs) {
    i32 retval = 0;
    retval = val_Cmp(lhs,rhs);
    return retval;
}

// --- atf_amc.Cstr..Eq
inline bool atf_amc::Cstr_Eq(const atf_amc::Cstr & lhs,const atf_amc::Cstr & rhs) {
    bool retval = true;
    retval = algo::cstring_Eq(lhs.val, rhs.val);
    return retval;
}

// --- atf_amc.Cstr..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::Cstr_Update(atf_amc::Cstr &lhs, atf_amc::Cstr & rhs) {
    bool ret = !Cstr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::Cstring::Cstring() {
}

inline atf_amc::Ctype1Attr::Ctype1Attr(u32                            in_attr1)
    : attr1(in_attr1)
{
}

inline bool atf_amc::Ctype1Attr::operator ==(const atf_amc::Ctype1Attr &rhs) const {
    return atf_amc::Ctype1Attr_Eq(const_cast<atf_amc::Ctype1Attr&>(*this),const_cast<atf_amc::Ctype1Attr&>(rhs));
}

inline bool atf_amc::Ctype1Attr::operator !=(const atf_amc::Ctype1Attr &rhs) const {
    return !atf_amc::Ctype1Attr_Eq(const_cast<atf_amc::Ctype1Attr&>(*this),const_cast<atf_amc::Ctype1Attr&>(rhs));
}

inline bool atf_amc::Ctype1Attr::operator <(const atf_amc::Ctype1Attr &rhs) const {
    return atf_amc::Ctype1Attr_Lt(const_cast<atf_amc::Ctype1Attr&>(*this),const_cast<atf_amc::Ctype1Attr&>(rhs));
}

inline bool atf_amc::Ctype1Attr::operator >(const atf_amc::Ctype1Attr &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::Ctype1Attr::operator <=(const atf_amc::Ctype1Attr &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::Ctype1Attr::operator >=(const atf_amc::Ctype1Attr &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::Ctype1Attr::Ctype1Attr() {
    atf_amc::Ctype1Attr_Init(*this);
}


// --- atf_amc.Ctype1Attr.attr1.Cast
inline atf_amc::Ctype1Attr::operator u32 () const {
    return u32((*this).attr1);
}

// --- atf_amc.Ctype1Attr..Hash
inline u32 atf_amc::Ctype1Attr_Hash(u32 prev, const atf_amc::Ctype1Attr & rhs) {
    prev = u32_Hash(prev, rhs.attr1);
    return prev;
}

// --- atf_amc.Ctype1Attr..Lt
inline bool atf_amc::Ctype1Attr_Lt(atf_amc::Ctype1Attr & lhs, atf_amc::Ctype1Attr & rhs) {
    return u32_Lt(lhs.attr1, rhs.attr1);
}

// --- atf_amc.Ctype1Attr..Cmp
inline i32 atf_amc::Ctype1Attr_Cmp(atf_amc::Ctype1Attr & lhs, atf_amc::Ctype1Attr & rhs) {
    i32 retval = 0;
    retval = u32_Cmp(lhs.attr1, rhs.attr1);
    return retval;
}

// --- atf_amc.Ctype1Attr..Init
// Set all fields to initial values.
inline void atf_amc::Ctype1Attr_Init(atf_amc::Ctype1Attr& parent) {
    parent.attr1 = u32(0);
}

// --- atf_amc.Ctype1Attr..Eq
inline bool atf_amc::Ctype1Attr_Eq(const atf_amc::Ctype1Attr & lhs,const atf_amc::Ctype1Attr & rhs) {
    bool retval = true;
    retval = u32_Eq(lhs.attr1, rhs.attr1);
    return retval;
}

// --- atf_amc.Ctype1Attr..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::Ctype1Attr_Update(atf_amc::Ctype1Attr &lhs, atf_amc::Ctype1Attr & rhs) {
    bool ret = !Ctype1Attr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::Ctype2Attr::Ctype2Attr(u32                            in_attr1
        ,u32                            in_attr2)
    : attr1(in_attr1)
    , attr2(in_attr2)
{
}

inline bool atf_amc::Ctype2Attr::operator ==(const atf_amc::Ctype2Attr &rhs) const {
    return atf_amc::Ctype2Attr_Eq(const_cast<atf_amc::Ctype2Attr&>(*this),const_cast<atf_amc::Ctype2Attr&>(rhs));
}

inline bool atf_amc::Ctype2Attr::operator !=(const atf_amc::Ctype2Attr &rhs) const {
    return !atf_amc::Ctype2Attr_Eq(const_cast<atf_amc::Ctype2Attr&>(*this),const_cast<atf_amc::Ctype2Attr&>(rhs));
}

inline bool atf_amc::Ctype2Attr::operator <(const atf_amc::Ctype2Attr &rhs) const {
    return atf_amc::Ctype2Attr_Lt(const_cast<atf_amc::Ctype2Attr&>(*this),const_cast<atf_amc::Ctype2Attr&>(rhs));
}

inline bool atf_amc::Ctype2Attr::operator >(const atf_amc::Ctype2Attr &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::Ctype2Attr::operator <=(const atf_amc::Ctype2Attr &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::Ctype2Attr::operator >=(const atf_amc::Ctype2Attr &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::Ctype2Attr::Ctype2Attr() {
    atf_amc::Ctype2Attr_Init(*this);
}


// --- atf_amc.Ctype2Attr..Hash
inline u32 atf_amc::Ctype2Attr_Hash(u32 prev, const atf_amc::Ctype2Attr & rhs) {
    prev = u32_Hash(prev, rhs.attr1);
    prev = u32_Hash(prev, rhs.attr2);
    return prev;
}

// --- atf_amc.Ctype2Attr..Lt
inline bool atf_amc::Ctype2Attr_Lt(atf_amc::Ctype2Attr & lhs, atf_amc::Ctype2Attr & rhs) {
    return Ctype2Attr_Cmp(lhs,rhs) < 0;
}

// --- atf_amc.Ctype2Attr..Cmp
inline i32 atf_amc::Ctype2Attr_Cmp(atf_amc::Ctype2Attr & lhs, atf_amc::Ctype2Attr & rhs) {
    i32 retval = 0;
    retval = u32_Cmp(lhs.attr1, rhs.attr1);
    if (retval != 0) {
        return retval;
    }
    retval = u32_Cmp(lhs.attr2, rhs.attr2);
    return retval;
}

// --- atf_amc.Ctype2Attr..Init
// Set all fields to initial values.
inline void atf_amc::Ctype2Attr_Init(atf_amc::Ctype2Attr& parent) {
    parent.attr1 = u32(0);
    parent.attr2 = u32(0);
}

// --- atf_amc.Ctype2Attr..Eq
inline bool atf_amc::Ctype2Attr_Eq(const atf_amc::Ctype2Attr & lhs,const atf_amc::Ctype2Attr & rhs) {
    bool retval = true;
    retval = u32_Eq(lhs.attr1, rhs.attr1);
    if (!retval) {
        return false;
    }
    retval = u32_Eq(lhs.attr2, rhs.attr2);
    return retval;
}

// --- atf_amc.Ctype2Attr..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::Ctype2Attr_Update(atf_amc::Ctype2Attr &lhs, atf_amc::Ctype2Attr & rhs) {
    bool ret = !Ctype2Attr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::DelType1::DelType1() {
    atf_amc::DelType1_Init(*this);
}

inline atf_amc::DelType1::~DelType1() {
    atf_amc::DelType1_Uninit(*this);
}


// --- atf_amc.DelType1..Init
// Set all fields to initial values.
inline void atf_amc::DelType1_Init(atf_amc::DelType1& parent) {
    parent.u32val = NULL;
}
inline atf_amc::DispCase::DispCase(u32                            in_value)
    : value(in_value)
{
}
inline atf_amc::DispCase::DispCase(atf_amc_DispCaseEnum arg) { this->value = u32(arg); }
inline atf_amc::DispCase::DispCase() {
    atf_amc::DispCase_Init(*this);
}


// --- atf_amc.DispCase.value.GetEnum
// Get value of field as enum type
inline atf_amc_DispCaseEnum atf_amc::value_GetEnum(const atf_amc::DispCase& parent) {
    return atf_amc_DispCaseEnum(parent.value);
}

// --- atf_amc.DispCase.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::DispCase& parent, atf_amc_DispCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- atf_amc.DispCase.value.Cast
inline atf_amc::DispCase::operator atf_amc_DispCaseEnum () const {
    return atf_amc_DispCaseEnum((*this).value);
}

// --- atf_amc.DispCase..Init
// Set all fields to initial values.
inline void atf_amc::DispCase_Init(atf_amc::DispCase& parent) {
    parent.value = u32(0);
}
inline atf_amc::DispFilter::DispFilter() {
    atf_amc::DispFilter_Init(*this);
}


// --- atf_amc.DispFilter.pmask.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_amc::pmask_Nbits(atf_amc::DispFilter& parent) {
    return pmask_N(parent) * 64;
}

// --- atf_amc.DispFilter.pmask.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_amc::pmask_qGetBit(atf_amc::DispFilter& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_amc.DispFilter.pmask.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_amc::pmask_GetBit(atf_amc::DispFilter& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    bool ret = false;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u64 &elem = pmask_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_amc.DispFilter.pmask.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_amc::pmask_BitsEmptyQ(atf_amc::DispFilter& parent) {
    bool retval = true;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (pmask_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_amc.DispFilter.pmask.Sum1s
inline u64 atf_amc::pmask_Sum1s(atf_amc::DispFilter& parent) {
    u64 sum = 0;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u64_Count1s(pmask_qFind(parent, i));
    }
    return sum;
}

// --- atf_amc.DispFilter.pmask.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qClearBit(atf_amc::DispFilter& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u64(1) << shift); // clear bit
}

// --- atf_amc.DispFilter.pmask.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_amc::pmask_ClearBit(atf_amc::DispFilter& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u64 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u64(1) << shift); // clear bit
    }
}

// --- atf_amc.DispFilter.pmask.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBit(atf_amc::DispFilter& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(1) << shift); // set bit
}

// --- atf_amc.DispFilter.pmask.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_amc::pmask_SetBit(atf_amc::DispFilter& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u64 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem | (u64(1) << shift); // set bit
    }
}

// --- atf_amc.DispFilter.pmask.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBitVal(atf_amc::DispFilter& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u64(1) << shift)) | (u64(val) << shift); // insert new value
}

// --- atf_amc.DispFilter.pmask.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qOrBitVal(atf_amc::DispFilter& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(val) << shift); // Or in val into elem
}

// --- atf_amc.DispFilter.pmask.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_amc::pmask_ClearBitsAll(atf_amc::DispFilter& parent) {
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) = 0;
    }
}

// --- atf_amc.DispFilter.pmask.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_amc::pmask_ClearBits(atf_amc::DispFilter& parent, atf_amc::DispFilter &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) &= ~pmask_qFind(rhs, i);
    }
}

// --- atf_amc.DispFilter.pmask.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_amc::pmask_OrBits(atf_amc::DispFilter& parent, atf_amc::DispFilter &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) |= pmask_qFind(rhs, i);
    }
}

// --- atf_amc.DispFilter.pmask.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 atf_amc::pmask_Sup(atf_amc::DispFilter& parent) {
    u64 lim = pmask_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u64 &val = pmask_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 64 + bitidx;
            break;
        }
    }
    return ret;
}

// --- atf_amc.DispFilter.pmask.Fill
// Set all elements of fixed array to value RHS
inline void atf_amc::pmask_Fill(atf_amc::DispFilter& parent, const u64 &rhs) {
    for (int i = 0; i < 1; i++) {
        parent.pmask_elems[i] = rhs;
    }
}

// --- atf_amc.DispFilter.pmask.Find
// Look up row by row id. Return NULL if out of range
inline u64* atf_amc::pmask_Find(atf_amc::DispFilter& parent, u64 t) {
    u64 idx = t;
    u64 lim = 1;
    return idx < lim ? parent.pmask_elems + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.DispFilter.pmask.Getary
// Access fixed array pmask as aryptr.
inline algo::aryptr<u64> atf_amc::pmask_Getary(atf_amc::DispFilter& parent) {
    return algo::aryptr<u64>(parent.pmask_elems, 1);
}

// --- atf_amc.DispFilter.pmask.Max
// Return max number of items in the array
inline i32 atf_amc::pmask_Max(atf_amc::DispFilter& parent) {
    (void)parent;
    return 1;
}

// --- atf_amc.DispFilter.pmask.N
// Return number of items in the array
inline i32 atf_amc::pmask_N(const atf_amc::DispFilter& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 1;
}

// --- atf_amc.DispFilter.pmask.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void atf_amc::pmask_Setary(atf_amc::DispFilter& parent, const algo::aryptr<u64> &rhs) {
    int n = 1 < rhs.n_elems ? 1 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.pmask_elems[i] = rhs[i];
    }
}

// --- atf_amc.DispFilter.pmask.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u64& atf_amc::pmask_qFind(atf_amc::DispFilter& parent, u64 t) {
    return parent.pmask_elems[t];
}

// --- atf_amc.DispFilter.strval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::strval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 0);
}

// --- atf_amc.DispFilter.strval.SetPresent
inline void atf_amc::strval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.DispFilter.strval.Set
inline void atf_amc::strval_Set(atf_amc::DispFilter& parent, const algo::strptr& rhs) {
    parent.strval = rhs;
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.DispFilter.strval_regx.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::strval_regx_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 1);
}

// --- atf_amc.DispFilter.strval_regx.SetPresent
inline void atf_amc::strval_regx_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 1); // mark presence in pmask
}

// --- atf_amc.DispFilter.strval2.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::strval2_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 2);
}

// --- atf_amc.DispFilter.strval2.SetPresent
inline void atf_amc::strval2_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 2); // mark presence in pmask
}

// --- atf_amc.DispFilter.strval2.Set
inline void atf_amc::strval2_Set(atf_amc::DispFilter& parent, const algo::strptr& rhs) {
    parent.strval2 = rhs;
    pmask_qSetBit(parent, 2); // mark presence in pmask
}

// --- atf_amc.DispFilter.strval2_regx.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::strval2_regx_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 3);
}

// --- atf_amc.DispFilter.strval2_regx.SetPresent
inline void atf_amc::strval2_regx_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 3); // mark presence in pmask
}

// --- atf_amc.DispFilter.start_dateval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::start_dateval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 4);
}

// --- atf_amc.DispFilter.start_dateval.SetPresent
inline void atf_amc::start_dateval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 4); // mark presence in pmask
}

// --- atf_amc.DispFilter.start_dateval.Set
inline void atf_amc::start_dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) {
    parent.start_dateval = rhs;
    pmask_qSetBit(parent, 4); // mark presence in pmask
}

// --- atf_amc.DispFilter.end_dateval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::end_dateval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 5);
}

// --- atf_amc.DispFilter.end_dateval.SetPresent
inline void atf_amc::end_dateval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 5); // mark presence in pmask
}

// --- atf_amc.DispFilter.end_dateval.Set
inline void atf_amc::end_dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) {
    parent.end_dateval = rhs;
    pmask_qSetBit(parent, 5); // mark presence in pmask
}

// --- atf_amc.DispFilter.dateval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::dateval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 6);
}

// --- atf_amc.DispFilter.dateval.SetPresent
inline void atf_amc::dateval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 6); // mark presence in pmask
}

// --- atf_amc.DispFilter.dateval.Set
inline void atf_amc::dateval_Set(atf_amc::DispFilter& parent, algo::UnTime rhs) {
    parent.dateval = rhs;
    pmask_qSetBit(parent, 6); // mark presence in pmask
}

// --- atf_amc.DispFilter.start_intval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::start_intval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 7);
}

// --- atf_amc.DispFilter.start_intval.SetPresent
inline void atf_amc::start_intval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 7); // mark presence in pmask
}

// --- atf_amc.DispFilter.start_intval.Set
inline void atf_amc::start_intval_Set(atf_amc::DispFilter& parent, u32 rhs) {
    parent.start_intval = rhs;
    pmask_qSetBit(parent, 7); // mark presence in pmask
}

// --- atf_amc.DispFilter.end_intval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::end_intval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 8);
}

// --- atf_amc.DispFilter.end_intval.SetPresent
inline void atf_amc::end_intval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 8); // mark presence in pmask
}

// --- atf_amc.DispFilter.end_intval.Set
inline void atf_amc::end_intval_Set(atf_amc::DispFilter& parent, u32 rhs) {
    parent.end_intval = rhs;
    pmask_qSetBit(parent, 8); // mark presence in pmask
}

// --- atf_amc.DispFilter.intval.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::intval_PresentQ(atf_amc::DispFilter& parent) {
    return pmask_qGetBit(parent, 9);
}

// --- atf_amc.DispFilter.intval.SetPresent
inline void atf_amc::intval_SetPresent(atf_amc::DispFilter& parent) {
    pmask_qSetBit(parent, 9); // mark presence in pmask
}

// --- atf_amc.DispFilter.intval.Set
inline void atf_amc::intval_Set(atf_amc::DispFilter& parent, u32 rhs) {
    parent.intval = rhs;
    pmask_qSetBit(parent, 9); // mark presence in pmask
}

// --- atf_amc.DispFilter.pmask_curs.Reset
// cursor points to valid item
inline void atf_amc::DispFilter_pmask_curs_Reset(DispFilter_pmask_curs &curs, atf_amc::DispFilter &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.DispFilter.pmask_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::DispFilter_pmask_curs_ValidQ(DispFilter_pmask_curs &curs) {
    return u64(curs.index) < u64(1);
}

// --- atf_amc.DispFilter.pmask_curs.Next
// proceed to next item
inline void atf_amc::DispFilter_pmask_curs_Next(DispFilter_pmask_curs &curs) {
    curs.index++;
}

// --- atf_amc.DispFilter.pmask_curs.Access
// item access
inline u64& atf_amc::DispFilter_pmask_curs_Access(DispFilter_pmask_curs &curs) {
    return pmask_qFind((*curs.parent), u64(curs.index));
}
inline atf_amc::DispType1::DispType1() {
}

inline atf_amc::DispType2::DispType2() {
    atf_amc::DispType2_Init(*this);
}


// --- atf_amc.DispType2..Init
// Set all fields to initial values.
inline void atf_amc::DispType2_Init(atf_amc::DispType2& parent) {
    parent.intval = u32(0);
}
inline atf_amc::DispType3::DispType3() {
    atf_amc::DispType3_Init(*this);
}


// --- atf_amc.DispType3..Init
// Set all fields to initial values.
inline void atf_amc::DispType3_Init(atf_amc::DispType3& parent) {
    parent.intval = u32(0);
}
inline atf_amc::FAmctest::FAmctest() {
    atf_amc::FAmctest_Init(*this);
}


// --- atf_amc.FAmctest.step.Call
// Invoke function by pointer
inline void atf_amc::step_Call(atf_amc::FAmctest& amctest) {
    if (amctest.step) {
        amctest.step();
    }
}

// --- atf_amc.FAmctest..Init
// Set all fields to initial values.
inline void atf_amc::FAmctest_Init(atf_amc::FAmctest& amctest) {
    amctest.select = bool(false);
    amctest.success = bool(false);
    amctest.step = NULL;
}
inline atf_amc::FAvl::FAvl() {
    atf_amc::FAvl_Init(*this);
}

inline atf_amc::FAvl::~FAvl() {
    atf_amc::FAvl_Uninit(*this);
}


// --- atf_amc.FAvl..Init
// Set all fields to initial values.
inline void atf_amc::FAvl_Init(atf_amc::FAvl& avl) {
    avl.n = i32(0);
    avl.tr_avl_up = (atf_amc::FAvl*)-1; // (atf_amc.FDb.tr_avl) not in tree
    avl.tr_avl_left = NULL;
    avl.tr_avl_right = NULL;
    avl.tr_avl_depth = 0;
}
inline atf_amc::FCascdel::FCascdel() {
    atf_amc::FCascdel_Init(*this);
}

inline atf_amc::FCascdel::~FCascdel() {
    atf_amc::FCascdel_Uninit(*this);
}


// --- atf_amc.FCascdel.type.GetEnum
// Get value of field as enum type
inline atf_amc_FCascdel_type_Enum atf_amc::type_GetEnum(const atf_amc::FCascdel& cascdel) {
    return atf_amc_FCascdel_type_Enum(cascdel.type);
}

// --- atf_amc.FCascdel.type.SetEnum
// Set value of field from enum type.
inline void atf_amc::type_SetEnum(atf_amc::FCascdel& cascdel, atf_amc_FCascdel_type_Enum rhs) {
    cascdel.type = u32(rhs);
}

// --- atf_amc.FCascdel.child_ptr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool atf_amc::child_ptr_InsertMaybe(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    atf_amc::FCascdel* ptr = cascdel.child_ptr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        cascdel.child_ptr = &row;
    }
    return retval;
}

// --- atf_amc.FCascdel.child_ptr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void atf_amc::child_ptr_Remove(atf_amc::FCascdel& cascdel, atf_amc::FCascdel& row) {
    atf_amc::FCascdel *ptr = cascdel.child_ptr;
    if (LIKELY(ptr == &row)) {
        cascdel.child_ptr = NULL;
    }
}

// --- atf_amc.FCascdel.c_child_ptrary.EmptyQ
// Return true if index is empty
inline bool atf_amc::c_child_ptrary_EmptyQ(atf_amc::FCascdel& cascdel) {
    return cascdel.c_child_ptrary_n == 0;
}

// --- atf_amc.FCascdel.c_child_ptrary.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FCascdel* atf_amc::c_child_ptrary_Find(atf_amc::FCascdel& cascdel, u32 t) {
    atf_amc::FCascdel *retval = NULL;
    u64 idx = t;
    u64 lim = cascdel.c_child_ptrary_n;
    if (idx < lim) {
        retval = cascdel.c_child_ptrary_elems[idx];
    }
    return retval;
}

// --- atf_amc.FCascdel.c_child_ptrary.Getary
// Return array of pointers
inline algo::aryptr<atf_amc::FCascdel*> atf_amc::c_child_ptrary_Getary(atf_amc::FCascdel& cascdel) {
    return algo::aryptr<atf_amc::FCascdel*>(cascdel.c_child_ptrary_elems, cascdel.c_child_ptrary_n);
}

// --- atf_amc.FCascdel.c_child_ptrary.N
// Return number of items in the pointer array
inline i32 atf_amc::c_child_ptrary_N(const atf_amc::FCascdel& cascdel) {
    return cascdel.c_child_ptrary_n;
}

// --- atf_amc.FCascdel.c_child_ptrary.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_amc::c_child_ptrary_RemoveAll(atf_amc::FCascdel& cascdel) {
    for (u32 i = 0; i < cascdel.c_child_ptrary_n; i++) {
        // mark all elements as not-in-array
        cascdel.c_child_ptrary_elems[i]->cascdel_c_child_ptrary_in_ary = false;
    }
    cascdel.c_child_ptrary_n = 0;
}

// --- atf_amc.FCascdel.ind_child_thash.EmptyQ
// Return true if hash is empty
inline bool atf_amc::ind_child_thash_EmptyQ(atf_amc::FCascdel& cascdel) {
    return cascdel.ind_child_thash_n == 0;
}

// --- atf_amc.FCascdel.ind_child_thash.N
// Return number of items in the hash
inline i32 atf_amc::ind_child_thash_N(const atf_amc::FCascdel& cascdel) {
    return cascdel.ind_child_thash_n;
}

// --- atf_amc.FCascdel.bh_child_bheap.EmptyQ
// Return true if index is empty
inline bool atf_amc::bh_child_bheap_EmptyQ(atf_amc::FCascdel& cascdel) {
    return cascdel.bh_child_bheap_n == 0;
}

// --- atf_amc.FCascdel.bh_child_bheap.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FCascdel* atf_amc::bh_child_bheap_First(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *row = NULL;
    if (cascdel.bh_child_bheap_n > 0) {
        row = cascdel.bh_child_bheap_elems[0];
    }
    return row;
}

// --- atf_amc.FCascdel.bh_child_bheap.InBheapQ
// Return true if row is in index, false otherwise
inline bool atf_amc::bh_child_bheap_InBheapQ(atf_amc::FCascdel& row) {
    bool result = false;
    result = row.bh_child_bheap_idx != -1;
    return result;
}

// --- atf_amc.FCascdel.bh_child_bheap.N
// Return number of items in the heap
inline i32 atf_amc::bh_child_bheap_N(const atf_amc::FCascdel& cascdel) {
    return cascdel.bh_child_bheap_n;
}

// --- atf_amc.FCascdel.zd_childlist.EmptyQ
// Return true if index is empty
inline bool atf_amc::zd_childlist_EmptyQ(atf_amc::FCascdel& cascdel) {
    return cascdel.zd_childlist_head == NULL;
}

// --- atf_amc.FCascdel.zd_childlist.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FCascdel* atf_amc::zd_childlist_First(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *row = NULL;
    row = cascdel.zd_childlist_head;
    return row;
}

// --- atf_amc.FCascdel.zd_childlist.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zd_childlist_InLlistQ(atf_amc::FCascdel& row) {
    bool result = false;
    result = !(row.zd_childlist_next == (atf_amc::FCascdel*)-1);
    return result;
}

// --- atf_amc.FCascdel.zd_childlist.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FCascdel* atf_amc::zd_childlist_Last(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *row = NULL;
    row = cascdel.zd_childlist_tail;
    return row;
}

// --- atf_amc.FCascdel.zd_childlist.N
// Return number of items in the linked list
inline i32 atf_amc::zd_childlist_N(const atf_amc::FCascdel& cascdel) {
    return cascdel.zd_childlist_n;
}

// --- atf_amc.FCascdel.zd_childlist.Next
// Return pointer to next element in the list
inline atf_amc::FCascdel* atf_amc::zd_childlist_Next(atf_amc::FCascdel &row) {
    return row.zd_childlist_next;
}

// --- atf_amc.FCascdel.zd_childlist.Prev
// Return pointer to previous element in the list
inline atf_amc::FCascdel* atf_amc::zd_childlist_Prev(atf_amc::FCascdel &row) {
    return row.zd_childlist_prev;
}

// --- atf_amc.FCascdel.zd_childlist.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FCascdel& atf_amc::zd_childlist_qLast(atf_amc::FCascdel& cascdel) {
    atf_amc::FCascdel *row = NULL;
    row = cascdel.zd_childlist_tail;
    return *row;
}

// --- atf_amc.FCascdel.tr_child_atree.EmptyQ
// Return true if index is empty
inline bool atf_amc::tr_child_atree_EmptyQ(atf_amc::FCascdel& cascdel) {
    return cascdel.tr_child_atree_root == NULL;
}

// --- atf_amc.FCascdel.tr_child_atree.InTreeQ
// Return true if row is in the tree, false otherwise
inline bool atf_amc::tr_child_atree_InTreeQ(atf_amc::FCascdel& row) {
    return row.tr_child_atree_up != (atf_amc::FCascdel*)-1;
}

// --- atf_amc.FCascdel.tr_child_atree.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_amc::tr_child_atree_RemoveAll(atf_amc::FCascdel& cascdel) {
    tr_child_atree_RemoveAllImpl(cascdel, cascdel.tr_child_atree_root, false);
    cascdel.tr_child_atree_root = NULL;
    cascdel.tr_child_atree_n = 0;
}

// --- atf_amc.FCascdel.c_child_ptrary_curs.Reset
inline void atf_amc::cascdel_c_child_ptrary_curs_Reset(cascdel_c_child_ptrary_curs &curs, atf_amc::FCascdel &parent) {
    curs.elems = parent.c_child_ptrary_elems;
    curs.n_elems = parent.c_child_ptrary_n;
    curs.index = 0;
}

// --- atf_amc.FCascdel.c_child_ptrary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::cascdel_c_child_ptrary_curs_ValidQ(cascdel_c_child_ptrary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FCascdel.c_child_ptrary_curs.Next
// proceed to next item
inline void atf_amc::cascdel_c_child_ptrary_curs_Next(cascdel_c_child_ptrary_curs &curs) {
    curs.index++;
}

// --- atf_amc.FCascdel.c_child_ptrary_curs.Access
// item access
inline atf_amc::FCascdel& atf_amc::cascdel_c_child_ptrary_curs_Access(cascdel_c_child_ptrary_curs &curs) {
    return *curs.elems[curs.index];
}

// --- atf_amc.FCascdel.bh_child_bheap_curs.Access
// Access current element. If not more elements, return NULL
inline atf_amc::FCascdel& atf_amc::cascdel_bh_child_bheap_curs_Access(cascdel_bh_child_bheap_curs &curs) {
    return *curs.temp_elems[0];
}

// --- atf_amc.FCascdel.bh_child_bheap_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool atf_amc::cascdel_bh_child_bheap_curs_ValidQ(cascdel_bh_child_bheap_curs &curs) {
    return curs.temp_n > 0;
}

// --- atf_amc.FCascdel.zd_childlist_curs.Reset
// cursor points to valid item
inline void atf_amc::cascdel_zd_childlist_curs_Reset(cascdel_zd_childlist_curs &curs, atf_amc::FCascdel &parent) {
    curs.row = parent.zd_childlist_head;
}

// --- atf_amc.FCascdel.zd_childlist_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::cascdel_zd_childlist_curs_ValidQ(cascdel_zd_childlist_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FCascdel.zd_childlist_curs.Next
// proceed to next item
inline void atf_amc::cascdel_zd_childlist_curs_Next(cascdel_zd_childlist_curs &curs) {
    atf_amc::FCascdel *next = (*curs.row).zd_childlist_next;
    curs.row = next;
}

// --- atf_amc.FCascdel.zd_childlist_curs.Access
// item access
inline atf_amc::FCascdel& atf_amc::cascdel_zd_childlist_curs_Access(cascdel_zd_childlist_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FCascdel.tr_child_atree_curs.Reset
// cursor points to valid item
inline void atf_amc::cascdel_tr_child_atree_curs_Reset(cascdel_tr_child_atree_curs &curs, atf_amc::FCascdel& parent) {
    curs.row = tr_child_atree_First(parent);
}

// --- atf_amc.FCascdel.tr_child_atree_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::cascdel_tr_child_atree_curs_ValidQ(cascdel_tr_child_atree_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FCascdel.tr_child_atree_curs.Next
// proceed to next item
inline void atf_amc::cascdel_tr_child_atree_curs_Next(cascdel_tr_child_atree_curs &curs) {
    curs.row = tr_child_atree_Next(*curs.row);
}

// --- atf_amc.FCascdel.tr_child_atree_curs.Access
// item access
inline atf_amc::FCascdel& atf_amc::cascdel_tr_child_atree_curs_Access(cascdel_tr_child_atree_curs &curs) {
    return *curs.row;
}
inline atf_amc::FCstring::FCstring() {
    atf_amc::FCstring_Init(*this);
}

inline atf_amc::FCstring::~FCstring() {
    atf_amc::FCstring_Uninit(*this);
}


// --- atf_amc.FCstring..Init
// Set all fields to initial values.
inline void atf_amc::FCstring_Init(atf_amc::FCstring& cstring) {
    cstring.ind_cstring_next = (atf_amc::FCstring*)-1; // (atf_amc.FDb.ind_cstring) not-in-hash
}
inline atf_amc::FListtype::FListtype() {
    atf_amc::FListtype_Init(*this);
}


// --- atf_amc.FListtype.step.Call
// Invoke function by pointer
inline void atf_amc::step_Call(atf_amc::FListtype& listtype, atf_amc::FListtype& arg) {
    if (listtype.step) {
        listtype.step(arg);
    }
}

// --- atf_amc.FListtype..Init
// Set all fields to initial values.
inline void atf_amc::FListtype_Init(atf_amc::FListtype& listtype) {
    listtype.circular = bool(false);
    listtype.haveprev = bool(false);
    listtype.instail = bool(false);
    listtype.seen = bool(false);
    listtype.step = NULL;
}
inline atf_amc::trace::trace() {
    atf_amc::trace_Init(*this);
}


// --- atf_amc.FDb.bh_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::bh_typec_EmptyQ() {
    return _db.bh_typec_n == 0;
}

// --- atf_amc.FDb.bh_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::bh_typec_First() {
    atf_amc::FTypeC *row = NULL;
    if (_db.bh_typec_n > 0) {
        row = _db.bh_typec_elems[0];
    }
    return row;
}

// --- atf_amc.FDb.bh_typec.InBheapQ
// Return true if row is in index, false otherwise
inline bool atf_amc::bh_typec_InBheapQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = row.bh_typec_idx != -1;
    return result;
}

// --- atf_amc.FDb.bh_typec.N
// Return number of items in the heap
inline i32 atf_amc::bh_typec_N() {
    return _db.bh_typec_n;
}

// --- atf_amc.FDb.bh_typec.Call
inline void atf_amc::bh_typec_Call() {
    atf_amc::bh_typec_Step();
}

// --- atf_amc.FDb.zdl_h_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::zdl_h_typec_EmptyQ() {
    return _db.zdl_h_typec_head == NULL;
}

// --- atf_amc.FDb.zdl_h_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::zdl_h_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zdl_h_typec_head;
    return row;
}

// --- atf_amc.FDb.zdl_h_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zdl_h_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.zdl_h_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.zdl_h_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::zdl_h_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zdl_h_typec_tail;
    return row;
}

// --- atf_amc.FDb.zdl_h_typec.N
// Return number of items in the linked list
inline i32 atf_amc::zdl_h_typec_N() {
    return _db.zdl_h_typec_n;
}

// --- atf_amc.FDb.zdl_h_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::zdl_h_typec_Next(atf_amc::FTypeC &row) {
    return row.zdl_h_typec_next;
}

// --- atf_amc.FDb.zdl_h_typec.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeC* atf_amc::zdl_h_typec_Prev(atf_amc::FTypeC &row) {
    return row.zdl_h_typec_prev;
}

// --- atf_amc.FDb.zdl_h_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::zdl_h_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zdl_h_typec_tail;
    return *row;
}

// --- atf_amc.FDb.zd_t_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::zd_t_typec_EmptyQ() {
    return _db.zd_t_typec_head == NULL;
}

// --- atf_amc.FDb.zd_t_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::zd_t_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zd_t_typec_head;
    return row;
}

// --- atf_amc.FDb.zd_t_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zd_t_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.zd_t_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.zd_t_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::zd_t_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zd_t_typec_tail;
    return row;
}

// --- atf_amc.FDb.zd_t_typec.N
// Return number of items in the linked list
inline i32 atf_amc::zd_t_typec_N() {
    return _db.zd_t_typec_n;
}

// --- atf_amc.FDb.zd_t_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::zd_t_typec_Next(atf_amc::FTypeC &row) {
    return row.zd_t_typec_next;
}

// --- atf_amc.FDb.zd_t_typec.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeC* atf_amc::zd_t_typec_Prev(atf_amc::FTypeC &row) {
    return row.zd_t_typec_prev;
}

// --- atf_amc.FDb.zd_t_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::zd_t_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zd_t_typec_tail;
    return *row;
}

// --- atf_amc.FDb.zd_typed.EmptyQ
// Return true if index is empty
inline bool atf_amc::zd_typed_EmptyQ() {
    return _db.zd_typed_head == NULL;
}

// --- atf_amc.FDb.zd_typed.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeD* atf_amc::zd_typed_First() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zd_typed_head;
    return row;
}

// --- atf_amc.FDb.zd_typed.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zd_typed_InLlistQ(atf_amc::FTypeD& row) {
    bool result = false;
    result = !(row.zd_typed_next == (atf_amc::FTypeD*)-1);
    return result;
}

// --- atf_amc.FDb.zd_typed.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeD* atf_amc::zd_typed_Last() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zd_typed_tail;
    return row;
}

// --- atf_amc.FDb.zd_typed.N
// Return number of items in the linked list
inline i32 atf_amc::zd_typed_N() {
    return _db.zd_typed_n;
}

// --- atf_amc.FDb.zd_typed.Next
// Return pointer to next element in the list
inline atf_amc::FTypeD* atf_amc::zd_typed_Next(atf_amc::FTypeD &row) {
    return row.zd_typed_next;
}

// --- atf_amc.FDb.zd_typed.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeD* atf_amc::zd_typed_Prev(atf_amc::FTypeD &row) {
    return row.zd_typed_prev;
}

// --- atf_amc.FDb.zd_typed.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeD& atf_amc::zd_typed_qLast() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zd_typed_tail;
    return *row;
}

// --- atf_amc.FDb.zs_t_typed.EmptyQ
// Return true if index is empty
inline bool atf_amc::zs_t_typed_EmptyQ() {
    return _db.zs_t_typed_head == NULL;
}

// --- atf_amc.FDb.zs_t_typed.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeD* atf_amc::zs_t_typed_First() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zs_t_typed_head;
    return row;
}

// --- atf_amc.FDb.zs_t_typed.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zs_t_typed_InLlistQ(atf_amc::FTypeD& row) {
    bool result = false;
    result = !(row.zs_t_typed_next == (atf_amc::FTypeD*)-1);
    return result;
}

// --- atf_amc.FDb.zs_t_typed.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeD* atf_amc::zs_t_typed_Last() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zs_t_typed_tail;
    return row;
}

// --- atf_amc.FDb.zs_t_typed.N
// Return number of items in the linked list
inline i32 atf_amc::zs_t_typed_N() {
    return _db.zs_t_typed_n;
}

// --- atf_amc.FDb.zs_t_typed.Next
// Return pointer to next element in the list
inline atf_amc::FTypeD* atf_amc::zs_t_typed_Next(atf_amc::FTypeD &row) {
    return row.zs_t_typed_next;
}

// --- atf_amc.FDb.zs_t_typed.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeD& atf_amc::zs_t_typed_qLast() {
    atf_amc::FTypeD *row = NULL;
    row = _db.zs_t_typed_tail;
    return *row;
}

// --- atf_amc.FDb.cd_typed.EmptyQ
// Return true if index is empty
inline bool atf_amc::cd_typed_EmptyQ() {
    return _db.cd_typed_head == NULL;
}

// --- atf_amc.FDb.cd_typed.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeD* atf_amc::cd_typed_First() {
    atf_amc::FTypeD *row = NULL;
    row = _db.cd_typed_head;
    return row;
}

// --- atf_amc.FDb.cd_typed.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::cd_typed_InLlistQ(atf_amc::FTypeD& row) {
    bool result = false;
    result = !(row.cd_typed_next == (atf_amc::FTypeD*)-1);
    return result;
}

// --- atf_amc.FDb.cd_typed.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeD* atf_amc::cd_typed_Last() {
    atf_amc::FTypeD *row = NULL;
    row = _db.cd_typed_head ? _db.cd_typed_head->cd_typed_prev : NULL;
    return row;
}

// --- atf_amc.FDb.cd_typed.N
// Return number of items in the linked list
inline i32 atf_amc::cd_typed_N() {
    return _db.cd_typed_n;
}

// --- atf_amc.FDb.cd_typed.Next
// Return pointer to next element in the list
inline atf_amc::FTypeD* atf_amc::cd_typed_Next(atf_amc::FTypeD &row) {
    return row.cd_typed_next;
}

// --- atf_amc.FDb.cd_typed.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeD* atf_amc::cd_typed_Prev(atf_amc::FTypeD &row) {
    return row.cd_typed_prev;
}

// --- atf_amc.FDb.cd_typed.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeD& atf_amc::cd_typed_qLast() {
    atf_amc::FTypeD *row = NULL;
    row = _db.cd_typed_head ? _db.cd_typed_head->cd_typed_prev : NULL;
    return *row;
}

// --- atf_amc.FDb.zsl_h_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::zsl_h_typec_EmptyQ() {
    return _db.zsl_h_typec_head == NULL;
}

// --- atf_amc.FDb.zsl_h_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::zsl_h_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zsl_h_typec_head;
    return row;
}

// --- atf_amc.FDb.zsl_h_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zsl_h_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.zsl_h_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.zsl_h_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::zsl_h_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zsl_h_typec_tail;
    return row;
}

// --- atf_amc.FDb.zsl_h_typec.N
// Return number of items in the linked list
inline i32 atf_amc::zsl_h_typec_N() {
    return _db.zsl_h_typec_n;
}

// --- atf_amc.FDb.zsl_h_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::zsl_h_typec_Next(atf_amc::FTypeC &row) {
    return row.zsl_h_typec_next;
}

// --- atf_amc.FDb.zsl_h_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::zsl_h_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zsl_h_typec_tail;
    return *row;
}

// --- atf_amc.FDb.zsl_h_typec.Call
inline void atf_amc::zsl_h_typec_Call() {
    atf_amc::zsl_h_typec_Step();
}

// --- atf_amc.FDb.zs_t_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::zs_t_typec_EmptyQ() {
    return _db.zs_t_typec_head == NULL;
}

// --- atf_amc.FDb.zs_t_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::zs_t_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zs_t_typec_head;
    return row;
}

// --- atf_amc.FDb.zs_t_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zs_t_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.zs_t_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.zs_t_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::zs_t_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zs_t_typec_tail;
    return row;
}

// --- atf_amc.FDb.zs_t_typec.N
// Return number of items in the linked list
inline i32 atf_amc::zs_t_typec_N() {
    return _db.zs_t_typec_n;
}

// --- atf_amc.FDb.zs_t_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::zs_t_typec_Next(atf_amc::FTypeC &row) {
    return row.zs_t_typec_next;
}

// --- atf_amc.FDb.zs_t_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::zs_t_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zs_t_typec_tail;
    return *row;
}

// --- atf_amc.FDb.zs_t_typec.Call
inline void atf_amc::zs_t_typec_Call() {
    atf_amc::zs_t_typec_Step();
}

// --- atf_amc.FDb.zs_mt_typec.InLlistQ
// Return true if row is in index, false otherwise. Row must be non-NULL.
inline bool atf_amc::zs_mt_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.zs_mt_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.zdl_hnt_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::zdl_hnt_typec_EmptyQ() {
    return _db.zdl_hnt_typec_head == NULL;
}

// --- atf_amc.FDb.zdl_hnt_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::zdl_hnt_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.zdl_hnt_typec_head;
    return row;
}

// --- atf_amc.FDb.zdl_hnt_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zdl_hnt_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.zdl_hnt_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.zdl_hnt_typec.N
// Return number of items in the linked list
inline i32 atf_amc::zdl_hnt_typec_N() {
    return _db.zdl_hnt_typec_n;
}

// --- atf_amc.FDb.zdl_hnt_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::zdl_hnt_typec_Next(atf_amc::FTypeC &row) {
    return row.zdl_hnt_typec_next;
}

// --- atf_amc.FDb.zdl_hnt_typec.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeC* atf_amc::zdl_hnt_typec_Prev(atf_amc::FTypeC &row) {
    return row.zdl_hnt_typec_prev;
}

// --- atf_amc.FDb.cdl_h_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::cdl_h_typec_EmptyQ() {
    return _db.cdl_h_typec_head == NULL;
}

// --- atf_amc.FDb.cdl_h_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::cdl_h_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cdl_h_typec_head;
    return row;
}

// --- atf_amc.FDb.cdl_h_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::cdl_h_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.cdl_h_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.cdl_h_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::cdl_h_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cdl_h_typec_head ? _db.cdl_h_typec_head->cdl_h_typec_prev : NULL;
    return row;
}

// --- atf_amc.FDb.cdl_h_typec.N
// Return number of items in the linked list
inline i32 atf_amc::cdl_h_typec_N() {
    return _db.cdl_h_typec_n;
}

// --- atf_amc.FDb.cdl_h_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::cdl_h_typec_Next(atf_amc::FTypeC &row) {
    return row.cdl_h_typec_next;
}

// --- atf_amc.FDb.cdl_h_typec.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeC* atf_amc::cdl_h_typec_Prev(atf_amc::FTypeC &row) {
    return row.cdl_h_typec_prev;
}

// --- atf_amc.FDb.cdl_h_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::cdl_h_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cdl_h_typec_head ? _db.cdl_h_typec_head->cdl_h_typec_prev : NULL;
    return *row;
}

// --- atf_amc.FDb.cd_t_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::cd_t_typec_EmptyQ() {
    return _db.cd_t_typec_head == NULL;
}

// --- atf_amc.FDb.cd_t_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::cd_t_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cd_t_typec_head;
    return row;
}

// --- atf_amc.FDb.cd_t_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::cd_t_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.cd_t_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.cd_t_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::cd_t_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cd_t_typec_head ? _db.cd_t_typec_head->cd_t_typec_prev : NULL;
    return row;
}

// --- atf_amc.FDb.cd_t_typec.N
// Return number of items in the linked list
inline i32 atf_amc::cd_t_typec_N() {
    return _db.cd_t_typec_n;
}

// --- atf_amc.FDb.cd_t_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::cd_t_typec_Next(atf_amc::FTypeC &row) {
    return row.cd_t_typec_next;
}

// --- atf_amc.FDb.cd_t_typec.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeC* atf_amc::cd_t_typec_Prev(atf_amc::FTypeC &row) {
    return row.cd_t_typec_prev;
}

// --- atf_amc.FDb.cd_t_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::cd_t_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cd_t_typec_head ? _db.cd_t_typec_head->cd_t_typec_prev : NULL;
    return *row;
}

// --- atf_amc.FDb.csl_h_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::csl_h_typec_EmptyQ() {
    return _db.csl_h_typec_head == NULL;
}

// --- atf_amc.FDb.csl_h_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::csl_h_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.csl_h_typec_head;
    return row;
}

// --- atf_amc.FDb.csl_h_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::csl_h_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.csl_h_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.csl_h_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::csl_h_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.csl_h_typec_tail;
    return row;
}

// --- atf_amc.FDb.csl_h_typec.N
// Return number of items in the linked list
inline i32 atf_amc::csl_h_typec_N() {
    return _db.csl_h_typec_n;
}

// --- atf_amc.FDb.csl_h_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::csl_h_typec_Next(atf_amc::FTypeC &row) {
    return row.csl_h_typec_next;
}

// --- atf_amc.FDb.csl_h_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::csl_h_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.csl_h_typec_tail;
    return *row;
}

// --- atf_amc.FDb.csl_h_typec.Call
inline void atf_amc::csl_h_typec_Call() {
    atf_amc::csl_h_typec_Step();
}

// --- atf_amc.FDb.cs_t_typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::cs_t_typec_EmptyQ() {
    return _db.cs_t_typec_head == NULL;
}

// --- atf_amc.FDb.cs_t_typec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeC* atf_amc::cs_t_typec_First() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cs_t_typec_head;
    return row;
}

// --- atf_amc.FDb.cs_t_typec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::cs_t_typec_InLlistQ(atf_amc::FTypeC& row) {
    bool result = false;
    result = !(row.cs_t_typec_next == (atf_amc::FTypeC*)-1);
    return result;
}

// --- atf_amc.FDb.cs_t_typec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeC* atf_amc::cs_t_typec_Last() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cs_t_typec_tail;
    return row;
}

// --- atf_amc.FDb.cs_t_typec.N
// Return number of items in the linked list
inline i32 atf_amc::cs_t_typec_N() {
    return _db.cs_t_typec_n;
}

// --- atf_amc.FDb.cs_t_typec.Next
// Return pointer to next element in the list
inline atf_amc::FTypeC* atf_amc::cs_t_typec_Next(atf_amc::FTypeC &row) {
    return row.cs_t_typec_next;
}

// --- atf_amc.FDb.cs_t_typec.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeC& atf_amc::cs_t_typec_qLast() {
    atf_amc::FTypeC *row = NULL;
    row = _db.cs_t_typec_tail;
    return *row;
}

// --- atf_amc.FDb.cs_t_typec.Call
inline void atf_amc::cs_t_typec_Call() {
    atf_amc::cs_t_typec_Step();
}

// --- atf_amc.FDb.typea.EmptyQ
// Return true if index is empty
inline bool atf_amc::typea_EmptyQ() {
    return _db.typea_n == 0;
}

// --- atf_amc.FDb.typea.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FTypeA* atf_amc::typea_Find(i32 t) {
    atf_amc::FTypeA *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.typea_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.typea_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.FDb.typea.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::FTypeA* atf_amc::typea_Last() {
    return typea_Find(i32(_db.typea_n-1));
}

// --- atf_amc.FDb.typea.N
// Return number of items in the pool
inline i32 atf_amc::typea_N() {
    return _db.typea_n;
}

// --- atf_amc.FDb.typea.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::FTypeA& atf_amc::typea_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.typea_lary[bsr][index];
}

// --- atf_amc.FDb.types.EmptyQ
// Return true if index is empty
inline bool atf_amc::types_EmptyQ() {
    return _db.types_n == 0;
}

// --- atf_amc.FDb.types.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FTypeS* atf_amc::types_Find(u64 t) {
    atf_amc::FTypeS *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.types_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.types_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.FDb.types.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::FTypeS* atf_amc::types_Last() {
    return types_Find(u64(_db.types_n-1));
}

// --- atf_amc.FDb.types.N
// Return number of items in the pool
inline i32 atf_amc::types_N() {
    return _db.types_n;
}

// --- atf_amc.FDb.types.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::FTypeS& atf_amc::types_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.types_lary[bsr][index];
}

// --- atf_amc.FDb.ind_types.EmptyQ
// Return true if hash is empty
inline bool atf_amc::ind_types_EmptyQ() {
    return _db.ind_types_n == 0;
}

// --- atf_amc.FDb.ind_types.N
// Return number of items in the hash
inline i32 atf_amc::ind_types_N() {
    return _db.ind_types_n;
}

// --- atf_amc.FDb.ind_typea.EmptyQ
// Return true if hash is empty
inline bool atf_amc::ind_typea_EmptyQ() {
    return _db.ind_typea_n == 0;
}

// --- atf_amc.FDb.ind_typea.N
// Return number of items in the hash
inline i32 atf_amc::ind_typea_N() {
    return _db.ind_typea_n;
}

// --- atf_amc.FDb.typet.EmptyQ
// Return true if index is empty
inline bool atf_amc::typet_EmptyQ() {
    return _db.typet_n == 0;
}

// --- atf_amc.FDb.typet.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FTypeT* atf_amc::typet_Find(u64 t) {
    atf_amc::FTypeT *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.typet_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.typet_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.FDb.typet.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::FTypeT* atf_amc::typet_Last() {
    return typet_Find(u64(_db.typet_n-1));
}

// --- atf_amc.FDb.typet.N
// Return number of items in the pool
inline i32 atf_amc::typet_N() {
    return _db.typet_n;
}

// --- atf_amc.FDb.typet.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::FTypeT& atf_amc::typet_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.typet_lary[bsr][index];
}

// --- atf_amc.FDb.cstring.EmptyQ
// Return true if index is empty
inline bool atf_amc::cstring_EmptyQ() {
    return _db.cstring_n == 0;
}

// --- atf_amc.FDb.cstring.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FCstring* atf_amc::cstring_Find(u64 t) {
    atf_amc::FCstring *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cstring_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cstring_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.FDb.cstring.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::FCstring* atf_amc::cstring_Last() {
    return cstring_Find(u64(_db.cstring_n-1));
}

// --- atf_amc.FDb.cstring.N
// Return number of items in the pool
inline i32 atf_amc::cstring_N() {
    return _db.cstring_n;
}

// --- atf_amc.FDb.cstring.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::FCstring& atf_amc::cstring_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cstring_lary[bsr][index];
}

// --- atf_amc.FDb.ind_cstring.EmptyQ
// Return true if hash is empty
inline bool atf_amc::ind_cstring_EmptyQ() {
    return _db.ind_cstring_n == 0;
}

// --- atf_amc.FDb.ind_cstring.N
// Return number of items in the hash
inline i32 atf_amc::ind_cstring_N() {
    return _db.ind_cstring_n;
}

// --- atf_amc.FDb.cd_in_msg.EmptyQ
// Return true if index is empty
inline bool atf_amc::cd_in_msg_EmptyQ() {
    return _db.cd_in_msg_head == NULL;
}

// --- atf_amc.FDb.cd_in_msg.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::Msgbuf* atf_amc::cd_in_msg_First() {
    atf_amc::Msgbuf *row = NULL;
    row = _db.cd_in_msg_head;
    return row;
}

// --- atf_amc.FDb.cd_in_msg.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::cd_in_msg_InLlistQ(atf_amc::Msgbuf& row) {
    bool result = false;
    result = !(row.cd_in_msg_next == (atf_amc::Msgbuf*)-1);
    return result;
}

// --- atf_amc.FDb.cd_in_msg.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::Msgbuf* atf_amc::cd_in_msg_Last() {
    atf_amc::Msgbuf *row = NULL;
    row = _db.cd_in_msg_head ? _db.cd_in_msg_head->cd_in_msg_prev : NULL;
    return row;
}

// --- atf_amc.FDb.cd_in_msg.Next
// Return pointer to next element in the list
inline atf_amc::Msgbuf* atf_amc::cd_in_msg_Next(atf_amc::Msgbuf &row) {
    return row.cd_in_msg_next;
}

// --- atf_amc.FDb.cd_in_msg.Prev
// Return pointer to previous element in the list
inline atf_amc::Msgbuf* atf_amc::cd_in_msg_Prev(atf_amc::Msgbuf &row) {
    return row.cd_in_msg_prev;
}

// --- atf_amc.FDb.cd_in_msg.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::Msgbuf& atf_amc::cd_in_msg_qLast() {
    atf_amc::Msgbuf *row = NULL;
    row = _db.cd_in_msg_head ? _db.cd_in_msg_head->cd_in_msg_prev : NULL;
    return *row;
}

// --- atf_amc.FDb.varlen_extern.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
inline atf_amc::VarlenExtern* atf_amc::varlen_extern_AllocMaybe(i32 n_varfld) {
    atf_amc::VarlenExtern *row = varlen_extern_AllocExtraMaybe(NULL, sizeof(u32) * n_varfld);
    return row;
}

// --- atf_amc.FDb.varlen_extern.AllocVarlenMaybe
// Allocate element & copy memory from input parameter. If out of memory, return NULL.
// Allocate memory for a new row; Copy var-len portion from varlen.
// This is a convenience function that uses varlen_extern_Alloc
inline atf_amc::VarlenExtern* atf_amc::varlen_extern_AllocVarlenMaybe(algo::aryptr<u32> varlen) {
    return varlen_extern_AllocExtraMaybe(varlen.elems, varlen.n_elems * sizeof(u32));
}

// --- atf_amc.FDb.varlen_extern.AllocVarlen
// Allocate element & copy memory from input parameter. If out of memory, terminate process.
inline atf_amc::VarlenExtern& atf_amc::varlen_extern_AllocVarlen(algo::aryptr<u32> varlen) {
    return varlen_extern_AllocExtra(varlen.elems, varlen.n_elems * sizeof(u32));
}

// --- atf_amc.FDb.varlen_extern.N
// Return number of items in the pool
inline i64 atf_amc::varlen_extern_N() {
    return _db.varlen_extern_n;
}

// --- atf_amc.FDb.amctest.EmptyQ
// Return true if index is empty
inline bool atf_amc::amctest_EmptyQ() {
    return _db.amctest_n == 0;
}

// --- atf_amc.FDb.amctest.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FAmctest* atf_amc::amctest_Find(u64 t) {
    atf_amc::FAmctest *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.amctest_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.amctest_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.FDb.amctest.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::FAmctest* atf_amc::amctest_Last() {
    return amctest_Find(u64(_db.amctest_n-1));
}

// --- atf_amc.FDb.amctest.N
// Return number of items in the pool
inline i32 atf_amc::amctest_N() {
    return _db.amctest_n;
}

// --- atf_amc.FDb.amctest.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::FAmctest& atf_amc::amctest_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.amctest_lary[bsr][index];
}

// --- atf_amc.FDb.optalloc.N
// Return number of items in the pool
inline i64 atf_amc::optalloc_N() {
    return _db.optalloc_n;
}

// --- atf_amc.FDb.varlenalloc.AllocMaybe
// Allocate memory for new element. If out of memory, return NULL.
inline atf_amc::VarlenAlloc* atf_amc::varlenalloc_AllocMaybe(i32 n_varfld) {
    atf_amc::VarlenAlloc *row = varlenalloc_AllocExtraMaybe(NULL, sizeof(i32) * n_varfld);
    return row;
}

// --- atf_amc.FDb.varlenalloc.AllocVarlenMaybe
// Allocate element & copy memory from input parameter. If out of memory, return NULL.
// Allocate memory for a new row; Copy var-len portion from elem.
// This is a convenience function that uses varlenalloc_Alloc
inline atf_amc::VarlenAlloc* atf_amc::varlenalloc_AllocVarlenMaybe(algo::aryptr<i32> elem) {
    return varlenalloc_AllocExtraMaybe(elem.elems, elem.n_elems * sizeof(i32));
}

// --- atf_amc.FDb.varlenalloc.AllocVarlen
// Allocate element & copy memory from input parameter. If out of memory, terminate process.
inline atf_amc::VarlenAlloc& atf_amc::varlenalloc_AllocVarlen(algo::aryptr<i32> elem) {
    return varlenalloc_AllocExtra(elem.elems, elem.n_elems * sizeof(i32));
}

// --- atf_amc.FDb.varlenalloc.N
// Return number of items in the pool
inline i64 atf_amc::varlenalloc_N() {
    return _db.varlenalloc_n;
}

// --- atf_amc.FDb.optg.N
// Return number of items in the pool
inline i64 atf_amc::optg_N() {
    return _db.optg_n;
}

// --- atf_amc.FDb.c_typek.EmptyQ
// Return true if index is empty
inline bool atf_amc::c_typek_EmptyQ() {
    return _db.c_typek_n == 0;
}

// --- atf_amc.FDb.c_typek.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FTypeK* atf_amc::c_typek_Find(u32 t) {
    atf_amc::FTypeK *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_typek_n;
    if (idx < lim) {
        retval = _db.c_typek_elems[idx];
    }
    return retval;
}

// --- atf_amc.FDb.c_typek.Getary
// Return array of pointers
inline algo::aryptr<atf_amc::FTypeK*> atf_amc::c_typek_Getary() {
    return algo::aryptr<atf_amc::FTypeK*>(_db.c_typek_elems, _db.c_typek_n);
}

// --- atf_amc.FDb.c_typek.N
// Return number of items in the pointer array
inline i32 atf_amc::c_typek_N() {
    return _db.c_typek_n;
}

// --- atf_amc.FDb.c_typek.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_amc::c_typek_RemoveAll() {
    for (u32 i = 0; i < _db.c_typek_n; i++) {
        // mark all elements as not-in-array
        _db.c_typek_elems[i]->_db_c_typek_in_ary = false;
    }
    _db.c_typek_n = 0;
}

// --- atf_amc.FDb.avl.EmptyQ
// Return true if index is empty
inline bool atf_amc::avl_EmptyQ() {
    return _db.avl_n == 0;
}

// --- atf_amc.FDb.avl.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FAvl* atf_amc::avl_Find(u64 t) {
    atf_amc::FAvl *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.avl_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.avl_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.FDb.avl.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::FAvl* atf_amc::avl_Last() {
    return avl_Find(u64(_db.avl_n-1));
}

// --- atf_amc.FDb.avl.N
// Return number of items in the pool
inline i32 atf_amc::avl_N() {
    return _db.avl_n;
}

// --- atf_amc.FDb.avl.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::FAvl& atf_amc::avl_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.avl_lary[bsr][index];
}

// --- atf_amc.FDb.tr_avl.EmptyQ
// Return true if index is empty
inline bool atf_amc::tr_avl_EmptyQ() {
    return _db.tr_avl_root == NULL;
}

// --- atf_amc.FDb.tr_avl.InTreeQ
// Return true if row is in the tree, false otherwise
inline bool atf_amc::tr_avl_InTreeQ(atf_amc::FAvl& row) {
    return row.tr_avl_up != (atf_amc::FAvl*)-1;
}

// --- atf_amc.FDb.tr_avl.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_amc::tr_avl_RemoveAll() {
    tr_avl_RemoveAllImpl(_db.tr_avl_root, false);
    _db.tr_avl_root = NULL;
    _db.tr_avl_n = 0;
}

// --- atf_amc.FDb.listtype.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* atf_amc::listtype_AllocMem() {
    void *row = reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data) + _db.listtype_n;
    if (_db.listtype_n == 10) row = NULL;
    if (row) _db.listtype_n++;
    return row;
}

// --- atf_amc.FDb.listtype.EmptyQ
// Return true if index is empty
inline bool atf_amc::listtype_EmptyQ() {
    return _db.listtype_n == 0;
}

// --- atf_amc.FDb.listtype.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FListtype* atf_amc::listtype_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.listtype_n;
    return idx < lim ? reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data) + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.FDb.listtype.Getary
// Return array pointer by value
inline algo::aryptr<atf_amc::FListtype> atf_amc::listtype_Getary() {
    return algo::aryptr<atf_amc::FListtype>(reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data), _db.listtype_n);
}

// --- atf_amc.FDb.listtype.Max
// Return constant 10 -- max. number of items in the pool
inline i32 atf_amc::listtype_Max() {
    return 10;
}

// --- atf_amc.FDb.listtype.N
// Return number of items in the array
inline i32 atf_amc::listtype_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return _db.listtype_n;
}

// --- atf_amc.FDb.listtype.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline atf_amc::FListtype& atf_amc::listtype_qFind(u64 t) {
    u64 idx = t;
    return reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data)[idx];
}

// --- atf_amc.FDb.listtype.rowid_Get
// Compute row id of element given element's address
inline u64 atf_amc::listtype_rowid_Get(atf_amc::FListtype &row) {
    u64 ret = u64(&row - reinterpret_cast<atf_amc::FListtype*>(_db.listtype_data));
    return u64(ret);
}

// --- atf_amc.FDb.bh_typec_curs.Access
// Access current element. If not more elements, return NULL
inline atf_amc::FTypeC& atf_amc::_db_bh_typec_curs_Access(_db_bh_typec_curs &curs) {
    return *curs.temp_elems[0];
}

// --- atf_amc.FDb.bh_typec_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool atf_amc::_db_bh_typec_curs_ValidQ(_db_bh_typec_curs &curs) {
    return curs.temp_n > 0;
}

// --- atf_amc.FDb.zdl_h_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zdl_h_typec_curs_Reset(_db_zdl_h_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zdl_h_typec_head;
}

// --- atf_amc.FDb.zdl_h_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zdl_h_typec_curs_ValidQ(_db_zdl_h_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zdl_h_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_zdl_h_typec_curs_Next(_db_zdl_h_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).zdl_h_typec_next;
    curs.row = next;
}

// --- atf_amc.FDb.zdl_h_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_zdl_h_typec_curs_Access(_db_zdl_h_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zd_t_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zd_t_typec_curs_Reset(_db_zd_t_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zd_t_typec_head;
}

// --- atf_amc.FDb.zd_t_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zd_t_typec_curs_ValidQ(_db_zd_t_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zd_t_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_zd_t_typec_curs_Next(_db_zd_t_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).zd_t_typec_next;
    curs.row = next;
}

// --- atf_amc.FDb.zd_t_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_zd_t_typec_curs_Access(_db_zd_t_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zd_typed_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zd_typed_curs_Reset(_db_zd_typed_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zd_typed_head;
}

// --- atf_amc.FDb.zd_typed_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zd_typed_curs_ValidQ(_db_zd_typed_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zd_typed_curs.Next
// proceed to next item
inline void atf_amc::_db_zd_typed_curs_Next(_db_zd_typed_curs &curs) {
    atf_amc::FTypeD *next = (*curs.row).zd_typed_next;
    curs.row = next;
}

// --- atf_amc.FDb.zd_typed_curs.Access
// item access
inline atf_amc::FTypeD& atf_amc::_db_zd_typed_curs_Access(_db_zd_typed_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zd_typed_delcurs.Reset
// cursor points to valid item
inline void atf_amc::_db_zd_typed_delcurs_Reset(_db_zd_typed_delcurs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zd_typed_head;
    if (curs.row) {
        curs.next = (*curs.row).zd_typed_next;
    }
}

// --- atf_amc.FDb.zd_typed_delcurs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zd_typed_delcurs_ValidQ(_db_zd_typed_delcurs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zd_typed_delcurs.Next
// proceed to next item
inline void atf_amc::_db_zd_typed_delcurs_Next(_db_zd_typed_delcurs &curs) {
    atf_amc::FTypeD *next = curs.next;
    curs.row = next;
    if (curs.row) {
        curs.next = (*curs.row).zd_typed_next;
    }
}

// --- atf_amc.FDb.zd_typed_delcurs.Access
// item access
inline atf_amc::FTypeD& atf_amc::_db_zd_typed_delcurs_Access(_db_zd_typed_delcurs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zs_t_typed_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zs_t_typed_curs_Reset(_db_zs_t_typed_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zs_t_typed_head;
}

// --- atf_amc.FDb.zs_t_typed_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zs_t_typed_curs_ValidQ(_db_zs_t_typed_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zs_t_typed_curs.Next
// proceed to next item
inline void atf_amc::_db_zs_t_typed_curs_Next(_db_zs_t_typed_curs &curs) {
    atf_amc::FTypeD *next = (*curs.row).zs_t_typed_next;
    curs.row = next;
}

// --- atf_amc.FDb.zs_t_typed_curs.Access
// item access
inline atf_amc::FTypeD& atf_amc::_db_zs_t_typed_curs_Access(_db_zs_t_typed_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zs_t_typed_delcurs.Reset
// cursor points to valid item
inline void atf_amc::_db_zs_t_typed_delcurs_Reset(_db_zs_t_typed_delcurs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zs_t_typed_head;
    if (curs.row) {
        curs.next = (*curs.row).zs_t_typed_next;
    }
}

// --- atf_amc.FDb.zs_t_typed_delcurs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zs_t_typed_delcurs_ValidQ(_db_zs_t_typed_delcurs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zs_t_typed_delcurs.Next
// proceed to next item
inline void atf_amc::_db_zs_t_typed_delcurs_Next(_db_zs_t_typed_delcurs &curs) {
    atf_amc::FTypeD *next = curs.next;
    curs.row = next;
    if (curs.row) {
        curs.next = (*curs.row).zs_t_typed_next;
    }
}

// --- atf_amc.FDb.zs_t_typed_delcurs.Access
// item access
inline atf_amc::FTypeD& atf_amc::_db_zs_t_typed_delcurs_Access(_db_zs_t_typed_delcurs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.cd_typed_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_cd_typed_curs_Reset(_db_cd_typed_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.cd_typed_head;
    curs.head = &parent.cd_typed_head;
}

// --- atf_amc.FDb.cd_typed_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cd_typed_curs_ValidQ(_db_cd_typed_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.cd_typed_curs.Next
// proceed to next item
inline void atf_amc::_db_cd_typed_curs_Next(_db_cd_typed_curs &curs) {
    atf_amc::FTypeD *next = (*curs.row).cd_typed_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_amc.FDb.cd_typed_curs.Access
// item access
inline atf_amc::FTypeD& atf_amc::_db_cd_typed_curs_Access(_db_cd_typed_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.cd_typed_delcurs.Reset
// cursor points to valid item
inline void atf_amc::_db_cd_typed_delcurs_Reset(_db_cd_typed_delcurs &curs, atf_amc::FDb &parent) {
    curs.row = parent.cd_typed_head;
    curs.head = &parent.cd_typed_head;
    if (curs.row) {
        curs.next = (*curs.row).cd_typed_next;
        if (curs.next == *curs.head) {
            curs.next = NULL;
        }
    }
}

// --- atf_amc.FDb.cd_typed_delcurs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cd_typed_delcurs_ValidQ(_db_cd_typed_delcurs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.cd_typed_delcurs.Next
// proceed to next item
inline void atf_amc::_db_cd_typed_delcurs_Next(_db_cd_typed_delcurs &curs) {
    atf_amc::FTypeD *next = curs.next;
    curs.row = next;
    if (curs.row) {
        curs.next = (*curs.row).cd_typed_next;
        if (curs.next == *curs.head) {
            curs.next = NULL;
        }
    }
}

// --- atf_amc.FDb.cd_typed_delcurs.Access
// item access
inline atf_amc::FTypeD& atf_amc::_db_cd_typed_delcurs_Access(_db_cd_typed_delcurs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zsl_h_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zsl_h_typec_curs_Reset(_db_zsl_h_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zsl_h_typec_head;
}

// --- atf_amc.FDb.zsl_h_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zsl_h_typec_curs_ValidQ(_db_zsl_h_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zsl_h_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_zsl_h_typec_curs_Next(_db_zsl_h_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).zsl_h_typec_next;
    curs.row = next;
}

// --- atf_amc.FDb.zsl_h_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_zsl_h_typec_curs_Access(_db_zsl_h_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zs_t_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zs_t_typec_curs_Reset(_db_zs_t_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zs_t_typec_head;
}

// --- atf_amc.FDb.zs_t_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zs_t_typec_curs_ValidQ(_db_zs_t_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zs_t_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_zs_t_typec_curs_Next(_db_zs_t_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).zs_t_typec_next;
    curs.row = next;
}

// --- atf_amc.FDb.zs_t_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_zs_t_typec_curs_Access(_db_zs_t_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.zdl_hnt_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_zdl_hnt_typec_curs_Reset(_db_zdl_hnt_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.zdl_hnt_typec_head;
}

// --- atf_amc.FDb.zdl_hnt_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_zdl_hnt_typec_curs_ValidQ(_db_zdl_hnt_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.zdl_hnt_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_zdl_hnt_typec_curs_Next(_db_zdl_hnt_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).zdl_hnt_typec_next;
    curs.row = next;
}

// --- atf_amc.FDb.zdl_hnt_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_zdl_hnt_typec_curs_Access(_db_zdl_hnt_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.cdl_h_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_cdl_h_typec_curs_Reset(_db_cdl_h_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.cdl_h_typec_head;
    curs.head = &parent.cdl_h_typec_head;
}

// --- atf_amc.FDb.cdl_h_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cdl_h_typec_curs_ValidQ(_db_cdl_h_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.cdl_h_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_cdl_h_typec_curs_Next(_db_cdl_h_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).cdl_h_typec_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_amc.FDb.cdl_h_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_cdl_h_typec_curs_Access(_db_cdl_h_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.cd_t_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_cd_t_typec_curs_Reset(_db_cd_t_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.cd_t_typec_head;
    curs.head = &parent.cd_t_typec_head;
}

// --- atf_amc.FDb.cd_t_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cd_t_typec_curs_ValidQ(_db_cd_t_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.cd_t_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_cd_t_typec_curs_Next(_db_cd_t_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).cd_t_typec_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_amc.FDb.cd_t_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_cd_t_typec_curs_Access(_db_cd_t_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.csl_h_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_csl_h_typec_curs_Reset(_db_csl_h_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.csl_h_typec_head;
    curs.head = &parent.csl_h_typec_head;
}

// --- atf_amc.FDb.csl_h_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_csl_h_typec_curs_ValidQ(_db_csl_h_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.csl_h_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_csl_h_typec_curs_Next(_db_csl_h_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).csl_h_typec_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_amc.FDb.csl_h_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_csl_h_typec_curs_Access(_db_csl_h_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.cs_t_typec_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_cs_t_typec_curs_Reset(_db_cs_t_typec_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.cs_t_typec_head;
    curs.head = &parent.cs_t_typec_head;
}

// --- atf_amc.FDb.cs_t_typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cs_t_typec_curs_ValidQ(_db_cs_t_typec_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.cs_t_typec_curs.Next
// proceed to next item
inline void atf_amc::_db_cs_t_typec_curs_Next(_db_cs_t_typec_curs &curs) {
    atf_amc::FTypeC *next = (*curs.row).cs_t_typec_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_amc.FDb.cs_t_typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::_db_cs_t_typec_curs_Access(_db_cs_t_typec_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.typea_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_typea_curs_Reset(_db_typea_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.typea_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_typea_curs_ValidQ(_db_typea_curs &curs) {
    return curs.index < _db.typea_n;
}

// --- atf_amc.FDb.typea_curs.Next
// proceed to next item
inline void atf_amc::_db_typea_curs_Next(_db_typea_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.typea_curs.Access
// item access
inline atf_amc::FTypeA& atf_amc::_db_typea_curs_Access(_db_typea_curs &curs) {
    return typea_qFind(i32(curs.index));
}

// --- atf_amc.FDb.types_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_types_curs_Reset(_db_types_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.types_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_types_curs_ValidQ(_db_types_curs &curs) {
    return curs.index < _db.types_n;
}

// --- atf_amc.FDb.types_curs.Next
// proceed to next item
inline void atf_amc::_db_types_curs_Next(_db_types_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.types_curs.Access
// item access
inline atf_amc::FTypeS& atf_amc::_db_types_curs_Access(_db_types_curs &curs) {
    return types_qFind(u64(curs.index));
}

// --- atf_amc.FDb.typet_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_typet_curs_Reset(_db_typet_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.typet_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_typet_curs_ValidQ(_db_typet_curs &curs) {
    return curs.index < _db.typet_n;
}

// --- atf_amc.FDb.typet_curs.Next
// proceed to next item
inline void atf_amc::_db_typet_curs_Next(_db_typet_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.typet_curs.Access
// item access
inline atf_amc::FTypeT& atf_amc::_db_typet_curs_Access(_db_typet_curs &curs) {
    return typet_qFind(u64(curs.index));
}

// --- atf_amc.FDb.cstring_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_cstring_curs_Reset(_db_cstring_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.cstring_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cstring_curs_ValidQ(_db_cstring_curs &curs) {
    return curs.index < _db.cstring_n;
}

// --- atf_amc.FDb.cstring_curs.Next
// proceed to next item
inline void atf_amc::_db_cstring_curs_Next(_db_cstring_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.cstring_curs.Access
// item access
inline atf_amc::FCstring& atf_amc::_db_cstring_curs_Access(_db_cstring_curs &curs) {
    return cstring_qFind(u64(curs.index));
}

// --- atf_amc.FDb.cd_in_msg_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_cd_in_msg_curs_Reset(_db_cd_in_msg_curs &curs, atf_amc::FDb &parent) {
    curs.row = parent.cd_in_msg_head;
    curs.head = &parent.cd_in_msg_head;
}

// --- atf_amc.FDb.cd_in_msg_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_cd_in_msg_curs_ValidQ(_db_cd_in_msg_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.cd_in_msg_curs.Next
// proceed to next item
inline void atf_amc::_db_cd_in_msg_curs_Next(_db_cd_in_msg_curs &curs) {
    atf_amc::Msgbuf *next = (*curs.row).cd_in_msg_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- atf_amc.FDb.cd_in_msg_curs.Access
// item access
inline atf_amc::Msgbuf& atf_amc::_db_cd_in_msg_curs_Access(_db_cd_in_msg_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.amctest_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_amctest_curs_Reset(_db_amctest_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.amctest_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_amctest_curs_ValidQ(_db_amctest_curs &curs) {
    return curs.index < _db.amctest_n;
}

// --- atf_amc.FDb.amctest_curs.Next
// proceed to next item
inline void atf_amc::_db_amctest_curs_Next(_db_amctest_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.amctest_curs.Access
// item access
inline atf_amc::FAmctest& atf_amc::_db_amctest_curs_Access(_db_amctest_curs &curs) {
    return amctest_qFind(u64(curs.index));
}

// --- atf_amc.FDb.c_typek_curs.Reset
inline void atf_amc::_db_c_typek_curs_Reset(_db_c_typek_curs &curs, atf_amc::FDb &parent) {
    curs.elems = parent.c_typek_elems;
    curs.n_elems = parent.c_typek_n;
    curs.index = 0;
}

// --- atf_amc.FDb.c_typek_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_c_typek_curs_ValidQ(_db_c_typek_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FDb.c_typek_curs.Next
// proceed to next item
inline void atf_amc::_db_c_typek_curs_Next(_db_c_typek_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.c_typek_curs.Access
// item access
inline atf_amc::FTypeK& atf_amc::_db_c_typek_curs_Access(_db_c_typek_curs &curs) {
    return *curs.elems[curs.index];
}

// --- atf_amc.FDb.c_typek_oncecurs.Reset
inline void atf_amc::_db_c_typek_oncecurs_Reset(_db_c_typek_oncecurs &curs, atf_amc::FDb &parent) {
    curs.elems = parent.c_typek_elems;
    curs.n_elems = parent.c_typek_n;
    parent.c_typek_n = 0;
    curs.index = 0;
}

// --- atf_amc.FDb.c_typek_oncecurs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_c_typek_oncecurs_ValidQ(_db_c_typek_oncecurs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FDb.c_typek_oncecurs.Next
// proceed to next item
inline void atf_amc::_db_c_typek_oncecurs_Next(_db_c_typek_oncecurs &curs) {
    curs.elems[curs.index]->_db_c_typek_in_ary = false;
    curs.index++;
}

// --- atf_amc.FDb.c_typek_oncecurs.Access
// item access
inline atf_amc::FTypeK& atf_amc::_db_c_typek_oncecurs_Access(_db_c_typek_oncecurs &curs) {
    return *curs.elems[curs.index];
}

// --- atf_amc.FDb.avl_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_avl_curs_Reset(_db_avl_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.avl_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_avl_curs_ValidQ(_db_avl_curs &curs) {
    return curs.index < _db.avl_n;
}

// --- atf_amc.FDb.avl_curs.Next
// proceed to next item
inline void atf_amc::_db_avl_curs_Next(_db_avl_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.avl_curs.Access
// item access
inline atf_amc::FAvl& atf_amc::_db_avl_curs_Access(_db_avl_curs &curs) {
    return avl_qFind(u64(curs.index));
}

// --- atf_amc.FDb.tr_avl_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_tr_avl_curs_Reset(_db_tr_avl_curs &curs, atf_amc::FDb& ) {
    curs.row = tr_avl_First();
}

// --- atf_amc.FDb.tr_avl_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_tr_avl_curs_ValidQ(_db_tr_avl_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FDb.tr_avl_curs.Next
// proceed to next item
inline void atf_amc::_db_tr_avl_curs_Next(_db_tr_avl_curs &curs) {
    curs.row = tr_avl_Next(*curs.row);
}

// --- atf_amc.FDb.tr_avl_curs.Access
// item access
inline atf_amc::FAvl& atf_amc::_db_tr_avl_curs_Access(_db_tr_avl_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FDb.listtype_curs.Reset
// cursor points to valid item
inline void atf_amc::_db_listtype_curs_Reset(_db_listtype_curs &curs, atf_amc::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FDb.listtype_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::_db_listtype_curs_ValidQ(_db_listtype_curs &curs) {
    return u64(curs.index) < u64(curs.parent->listtype_n);
}

// --- atf_amc.FDb.listtype_curs.Next
// proceed to next item
inline void atf_amc::_db_listtype_curs_Next(_db_listtype_curs &curs) {
    curs.index++;
}

// --- atf_amc.FDb.listtype_curs.Access
// item access
inline atf_amc::FListtype& atf_amc::_db_listtype_curs_Access(_db_listtype_curs &curs) {
    return listtype_qFind(u64(curs.index));
}

inline bool atf_amc::TypeG::operator ==(const atf_amc::TypeG &rhs) const {
    return atf_amc::TypeG_Eq(const_cast<atf_amc::TypeG&>(*this),const_cast<atf_amc::TypeG&>(rhs));
}

inline bool atf_amc::TypeG::operator !=(const atf_amc::TypeG &rhs) const {
    return !atf_amc::TypeG_Eq(const_cast<atf_amc::TypeG&>(*this),const_cast<atf_amc::TypeG&>(rhs));
}

inline bool atf_amc::TypeG::operator <(const atf_amc::TypeG &rhs) const {
    return atf_amc::TypeG_Lt(const_cast<atf_amc::TypeG&>(*this),const_cast<atf_amc::TypeG&>(rhs));
}

inline bool atf_amc::TypeG::operator >(const atf_amc::TypeG &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::TypeG::operator <=(const atf_amc::TypeG &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::TypeG::operator >=(const atf_amc::TypeG &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::TypeG::TypeG() {
    atf_amc::TypeG_Init(*this);
}


// --- atf_amc.TypeG..Hash
inline u32 atf_amc::TypeG_Hash(u32 prev, const atf_amc::TypeG & rhs) {
    prev = i32_Hash(prev, rhs.typeg);
    return prev;
}

// --- atf_amc.TypeG..Lt
inline bool atf_amc::TypeG_Lt(atf_amc::TypeG & lhs, atf_amc::TypeG & rhs) {
    return i32_Lt(lhs.typeg, rhs.typeg);
}

// --- atf_amc.TypeG..Cmp
inline i32 atf_amc::TypeG_Cmp(atf_amc::TypeG & lhs, atf_amc::TypeG & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typeg, rhs.typeg);
    return retval;
}

// --- atf_amc.TypeG..Init
// Set all fields to initial values.
inline void atf_amc::TypeG_Init(atf_amc::TypeG& typeg) {
    typeg.typeg = i32(0);
}

// --- atf_amc.TypeG..Eq
inline bool atf_amc::TypeG_Eq(const atf_amc::TypeG & lhs,const atf_amc::TypeG & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typeg, rhs.typeg);
    return retval;
}

// --- atf_amc.TypeG..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::TypeG_Update(atf_amc::TypeG &lhs, atf_amc::TypeG & rhs) {
    bool ret = !TypeG_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::FOptG::FOptG() {
    atf_amc::FOptG_Init(*this);
}


// --- atf_amc.FOptG.typeg.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
inline atf_amc::TypeG* atf_amc::typeg_Get(atf_amc::FOptG& optg) {
    i32 totlen = i32(optg.length);
    u8 *end = (u8*)&optg + sizeof(atf_amc::FOptG);
    atf_amc::TypeG *ptr = (atf_amc::TypeG*)end;
    bool exists = ssizeof(atf_amc::FOptG) + sizeof_atf_amc_TypeG <= totlen;
    return exists ? ptr : NULL;
}

// --- atf_amc.FOptG..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::FOptG& row) {
    return i32(const_cast<atf_amc::FOptG&>(row).length);
}

// --- atf_amc.FOptG..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::FOptG& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::FOptG&>(row).length));
}

// --- atf_amc.FOptG..Init
// Set all fields to initial values.
inline void atf_amc::FOptG_Init(atf_amc::FOptG& optg) {
    optg.length = u32(0);
}
inline atf_amc::FPerfSortString::FPerfSortString() {
    atf_amc::FPerfSortString_Init(*this);
}

inline atf_amc::FPerfSortString::~FPerfSortString() {
    atf_amc::FPerfSortString_Uninit(*this);
}


// --- atf_amc.FPerfSortString.orig.EmptyQ
// Return true if index is empty
inline bool atf_amc::orig_EmptyQ(atf_amc::FPerfSortString& parent) {
    return parent.orig_n == 0;
}

// --- atf_amc.FPerfSortString.orig.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::Cstr* atf_amc::orig_Find(atf_amc::FPerfSortString& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.orig_n;
    if (idx >= lim) return NULL;
    return parent.orig_elems + idx;
}

// --- atf_amc.FPerfSortString.orig.Getary
// Return array pointer by value
inline algo::aryptr<atf_amc::Cstr> atf_amc::orig_Getary(atf_amc::FPerfSortString& parent) {
    return algo::aryptr<atf_amc::Cstr>(parent.orig_elems, parent.orig_n);
}

// --- atf_amc.FPerfSortString.orig.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::Cstr* atf_amc::orig_Last(atf_amc::FPerfSortString& parent) {
    return orig_Find(parent, u64(parent.orig_n-1));
}

// --- atf_amc.FPerfSortString.orig.Max
// Return max. number of items in the array
inline i32 atf_amc::orig_Max(atf_amc::FPerfSortString& parent) {
    (void)parent;
    return parent.orig_max;
}

// --- atf_amc.FPerfSortString.orig.N
// Return number of items in the array
inline i32 atf_amc::orig_N(const atf_amc::FPerfSortString& parent) {
    return parent.orig_n;
}

// --- atf_amc.FPerfSortString.orig.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_amc::orig_Reserve(atf_amc::FPerfSortString& parent, int n) {
    u32 new_n = parent.orig_n + n;
    if (UNLIKELY(new_n > parent.orig_max)) {
        orig_AbsReserve(parent, new_n);
    }
}

// --- atf_amc.FPerfSortString.orig.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::Cstr& atf_amc::orig_qFind(atf_amc::FPerfSortString& parent, u64 t) {
    return parent.orig_elems[t];
}

// --- atf_amc.FPerfSortString.orig.qLast
// Return reference to last element of array. No bounds checking
inline atf_amc::Cstr& atf_amc::orig_qLast(atf_amc::FPerfSortString& parent) {
    return orig_qFind(parent, u64(parent.orig_n-1));
}

// --- atf_amc.FPerfSortString.orig.rowid_Get
// Return row id of specified element
inline u64 atf_amc::orig_rowid_Get(atf_amc::FPerfSortString& parent, atf_amc::Cstr &elem) {
    u64 id = &elem - parent.orig_elems;
    return u64(id);
}

// --- atf_amc.FPerfSortString.sorted1.EmptyQ
// Return true if index is empty
inline bool atf_amc::sorted1_EmptyQ(atf_amc::FPerfSortString& parent) {
    return parent.sorted1_n == 0;
}

// --- atf_amc.FPerfSortString.sorted1.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::Cstr* atf_amc::sorted1_Find(atf_amc::FPerfSortString& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.sorted1_n;
    if (idx >= lim) return NULL;
    return parent.sorted1_elems + idx;
}

// --- atf_amc.FPerfSortString.sorted1.Getary
// Return array pointer by value
inline algo::aryptr<atf_amc::Cstr> atf_amc::sorted1_Getary(atf_amc::FPerfSortString& parent) {
    return algo::aryptr<atf_amc::Cstr>(parent.sorted1_elems, parent.sorted1_n);
}

// --- atf_amc.FPerfSortString.sorted1.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::Cstr* atf_amc::sorted1_Last(atf_amc::FPerfSortString& parent) {
    return sorted1_Find(parent, u64(parent.sorted1_n-1));
}

// --- atf_amc.FPerfSortString.sorted1.Max
// Return max. number of items in the array
inline i32 atf_amc::sorted1_Max(atf_amc::FPerfSortString& parent) {
    (void)parent;
    return parent.sorted1_max;
}

// --- atf_amc.FPerfSortString.sorted1.N
// Return number of items in the array
inline i32 atf_amc::sorted1_N(const atf_amc::FPerfSortString& parent) {
    return parent.sorted1_n;
}

// --- atf_amc.FPerfSortString.sorted1.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_amc::sorted1_Reserve(atf_amc::FPerfSortString& parent, int n) {
    u32 new_n = parent.sorted1_n + n;
    if (UNLIKELY(new_n > parent.sorted1_max)) {
        sorted1_AbsReserve(parent, new_n);
    }
}

// --- atf_amc.FPerfSortString.sorted1.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::Cstr& atf_amc::sorted1_qFind(atf_amc::FPerfSortString& parent, u64 t) {
    return parent.sorted1_elems[t];
}

// --- atf_amc.FPerfSortString.sorted1.qLast
// Return reference to last element of array. No bounds checking
inline atf_amc::Cstr& atf_amc::sorted1_qLast(atf_amc::FPerfSortString& parent) {
    return sorted1_qFind(parent, u64(parent.sorted1_n-1));
}

// --- atf_amc.FPerfSortString.sorted1.rowid_Get
// Return row id of specified element
inline u64 atf_amc::sorted1_rowid_Get(atf_amc::FPerfSortString& parent, atf_amc::Cstr &elem) {
    u64 id = &elem - parent.sorted1_elems;
    return u64(id);
}

// --- atf_amc.FPerfSortString.orig_curs.Next
// proceed to next item
inline void atf_amc::FPerfSortString_orig_curs_Next(FPerfSortString_orig_curs &curs) {
    curs.index++;
}

// --- atf_amc.FPerfSortString.orig_curs.Reset
inline void atf_amc::FPerfSortString_orig_curs_Reset(FPerfSortString_orig_curs &curs, atf_amc::FPerfSortString &parent) {
    curs.elems = parent.orig_elems;
    curs.n_elems = parent.orig_n;
    curs.index = 0;
}

// --- atf_amc.FPerfSortString.orig_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::FPerfSortString_orig_curs_ValidQ(FPerfSortString_orig_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FPerfSortString.orig_curs.Access
// item access
inline atf_amc::Cstr& atf_amc::FPerfSortString_orig_curs_Access(FPerfSortString_orig_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_amc.FPerfSortString.sorted1_curs.Next
// proceed to next item
inline void atf_amc::FPerfSortString_sorted1_curs_Next(FPerfSortString_sorted1_curs &curs) {
    curs.index++;
}

// --- atf_amc.FPerfSortString.sorted1_curs.Reset
inline void atf_amc::FPerfSortString_sorted1_curs_Reset(FPerfSortString_sorted1_curs &curs, atf_amc::FPerfSortString &parent) {
    curs.elems = parent.sorted1_elems;
    curs.n_elems = parent.sorted1_n;
    curs.index = 0;
}

// --- atf_amc.FPerfSortString.sorted1_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::FPerfSortString_sorted1_curs_ValidQ(FPerfSortString_sorted1_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FPerfSortString.sorted1_curs.Access
// item access
inline atf_amc::Cstr& atf_amc::FPerfSortString_sorted1_curs_Access(FPerfSortString_sorted1_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_amc.FPerfSortString..Init
// Set all fields to initial values.
inline void atf_amc::FPerfSortString_Init(atf_amc::FPerfSortString& parent) {
    parent.orig_elems 	= 0; // (atf_amc.FPerfSortString.orig)
    parent.orig_n     	= 0; // (atf_amc.FPerfSortString.orig)
    parent.orig_max   	= 0; // (atf_amc.FPerfSortString.orig)
    parent.sorted1_elems 	= 0; // (atf_amc.FPerfSortString.sorted1)
    parent.sorted1_n     	= 0; // (atf_amc.FPerfSortString.sorted1)
    parent.sorted1_max   	= 0; // (atf_amc.FPerfSortString.sorted1)
}
inline atf_amc::FTypeC::FTypeC() {
    atf_amc::FTypeC_Init(*this);
}

inline atf_amc::FTypeC::~FTypeC() {
    atf_amc::FTypeC_Uninit(*this);
}


// --- atf_amc.FTypeC..Init
// Set all fields to initial values.
inline void atf_amc::FTypeC_Init(atf_amc::FTypeC& typec) {
    typec.typec = i32(0);
    typec.bh_typec_idx = -1; // (atf_amc.FDb.bh_typec) not-in-heap
    typec.zdl_h_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.zdl_h_typec) not-in-list
    typec.zdl_h_typec_prev = NULL; // (atf_amc.FDb.zdl_h_typec)
    typec.zd_t_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.zd_t_typec) not-in-list
    typec.zd_t_typec_prev = NULL; // (atf_amc.FDb.zd_t_typec)
    typec.zsl_h_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.zsl_h_typec) not-in-list
    typec.zs_t_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.zs_t_typec) not-in-list

    // (atf_amc.FDb.zs_mt_typec) not-in-list
    typec.zs_mt_typec_next = (atf_amc::FTypeC*)-1;
    typec.zdl_hnt_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.zdl_hnt_typec) not-in-list
    typec.zdl_hnt_typec_prev = NULL; // (atf_amc.FDb.zdl_hnt_typec)
    typec.cdl_h_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.cdl_h_typec) not-in-list
    typec.cdl_h_typec_prev = NULL; // (atf_amc.FDb.cdl_h_typec)
    typec.cd_t_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.cd_t_typec) not-in-list
    typec.cd_t_typec_prev = NULL; // (atf_amc.FDb.cd_t_typec)
    typec.csl_h_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.csl_h_typec) not-in-list
    typec.cs_t_typec_next = (atf_amc::FTypeC*)-1; // (atf_amc.FDb.cs_t_typec) not-in-list
}
inline atf_amc::FTypeA::FTypeA() {
    atf_amc::FTypeA_Init(*this);
    // added because atf_amc.FTypeA.typec (Inlary) does not need initialization
    // coverity[uninit_member]
}

inline atf_amc::FTypeA::~FTypeA() {
    atf_amc::FTypeA_Uninit(*this);
}


// --- atf_amc.FTypeA.typec.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* atf_amc::typec_AllocMem(atf_amc::FTypeA& typea) {
    void *row = reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data) + typea.typec_n;
    if (typea.typec_n == 10) row = NULL;
    if (row) typea.typec_n++;
    return row;
}

// --- atf_amc.FTypeA.typec.EmptyQ
// Return true if index is empty
inline bool atf_amc::typec_EmptyQ(atf_amc::FTypeA& typea) {
    return typea.typec_n == 0;
}

// --- atf_amc.FTypeA.typec.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::FTypeC* atf_amc::typec_Find(atf_amc::FTypeA& typea, u64 t) {
    u64 idx = t;
    u64 lim = typea.typec_n;
    return idx < lim ? reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data) + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.FTypeA.typec.Getary
// Return array pointer by value
inline algo::aryptr<atf_amc::FTypeC> atf_amc::typec_Getary(atf_amc::FTypeA& typea) {
    return algo::aryptr<atf_amc::FTypeC>(reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data), typea.typec_n);
}

// --- atf_amc.FTypeA.typec.Max
// Return constant 10 -- max. number of items in the pool
inline i32 atf_amc::typec_Max(atf_amc::FTypeA& typea) {
    (void)typea;
    return 10;
}

// --- atf_amc.FTypeA.typec.N
// Return number of items in the array
inline i32 atf_amc::typec_N(const atf_amc::FTypeA& typea) {
    (void)typea;//only to avoid -Wunused-parameter
    return typea.typec_n;
}

// --- atf_amc.FTypeA.typec.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline atf_amc::FTypeC& atf_amc::typec_qFind(atf_amc::FTypeA& typea, u64 t) {
    u64 idx = t;
    return reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data)[idx];
}

// --- atf_amc.FTypeA.typec.rowid_Get
// Compute row id of element given element's address
inline u64 atf_amc::typec_rowid_Get(atf_amc::FTypeA& typea, atf_amc::FTypeC &row) {
    u64 ret = u64(&row - reinterpret_cast<atf_amc::FTypeC*>(typea.typec_data));
    return u64(ret);
}

// --- atf_amc.FTypeA.zdl_typeb.EmptyQ
// Return true if index is empty
inline bool atf_amc::zdl_typeb_EmptyQ(atf_amc::FTypeA& typea) {
    return typea.zdl_typeb_head == NULL;
}

// --- atf_amc.FTypeA.zdl_typeb.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeB* atf_amc::zdl_typeb_First(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB *row = NULL;
    row = typea.zdl_typeb_head;
    return row;
}

// --- atf_amc.FTypeA.zdl_typeb.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zdl_typeb_InLlistQ(atf_amc::FTypeB& row) {
    bool result = false;
    result = !(row.zdl_typeb_next == (atf_amc::FTypeB*)-1);
    return result;
}

// --- atf_amc.FTypeA.zdl_typeb.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeB* atf_amc::zdl_typeb_Last(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB *row = NULL;
    row = typea.zdl_typeb_tail;
    return row;
}

// --- atf_amc.FTypeA.zdl_typeb.N
// Return number of items in the linked list
inline i32 atf_amc::zdl_typeb_N(const atf_amc::FTypeA& typea) {
    return typea.zdl_typeb_n;
}

// --- atf_amc.FTypeA.zdl_typeb.Next
// Return pointer to next element in the list
inline atf_amc::FTypeB* atf_amc::zdl_typeb_Next(atf_amc::FTypeB &row) {
    return row.zdl_typeb_next;
}

// --- atf_amc.FTypeA.zdl_typeb.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeB* atf_amc::zdl_typeb_Prev(atf_amc::FTypeB &row) {
    return row.zdl_typeb_prev;
}

// --- atf_amc.FTypeA.zdl_typeb.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeB& atf_amc::zdl_typeb_qLast(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB *row = NULL;
    row = typea.zdl_typeb_tail;
    return *row;
}

// --- atf_amc.FTypeA.bh_typeb.EmptyQ
// Return true if index is empty
inline bool atf_amc::bh_typeb_EmptyQ(atf_amc::FTypeA& typea) {
    return typea.bh_typeb_n == 0;
}

// --- atf_amc.FTypeA.bh_typeb.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeB* atf_amc::bh_typeb_First(atf_amc::FTypeA& typea) {
    atf_amc::FTypeB *row = NULL;
    if (typea.bh_typeb_n > 0) {
        row = typea.bh_typeb_elems[0];
    }
    return row;
}

// --- atf_amc.FTypeA.bh_typeb.InBheapQ
// Return true if row is in index, false otherwise
inline bool atf_amc::bh_typeb_InBheapQ(atf_amc::FTypeB& row) {
    bool result = false;
    result = row.bh_typeb_idx != -1;
    return result;
}

// --- atf_amc.FTypeA.bh_typeb.N
// Return number of items in the heap
inline i32 atf_amc::bh_typeb_N(const atf_amc::FTypeA& typea) {
    return typea.bh_typeb_n;
}

// --- atf_amc.FTypeA.typec_curs.Reset
// cursor points to valid item
inline void atf_amc::typea_typec_curs_Reset(typea_typec_curs &curs, atf_amc::FTypeA &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FTypeA.typec_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::typea_typec_curs_ValidQ(typea_typec_curs &curs) {
    return u64(curs.index) < u64(curs.parent->typec_n);
}

// --- atf_amc.FTypeA.typec_curs.Next
// proceed to next item
inline void atf_amc::typea_typec_curs_Next(typea_typec_curs &curs) {
    curs.index++;
}

// --- atf_amc.FTypeA.typec_curs.Access
// item access
inline atf_amc::FTypeC& atf_amc::typea_typec_curs_Access(typea_typec_curs &curs) {
    return typec_qFind((*curs.parent), u64(curs.index));
}

// --- atf_amc.FTypeA.zdl_typeb_curs.Reset
// cursor points to valid item
inline void atf_amc::typea_zdl_typeb_curs_Reset(typea_zdl_typeb_curs &curs, atf_amc::FTypeA &parent) {
    curs.row = parent.zdl_typeb_head;
}

// --- atf_amc.FTypeA.zdl_typeb_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::typea_zdl_typeb_curs_ValidQ(typea_zdl_typeb_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FTypeA.zdl_typeb_curs.Next
// proceed to next item
inline void atf_amc::typea_zdl_typeb_curs_Next(typea_zdl_typeb_curs &curs) {
    atf_amc::FTypeB *next = (*curs.row).zdl_typeb_next;
    curs.row = next;
}

// --- atf_amc.FTypeA.zdl_typeb_curs.Access
// item access
inline atf_amc::FTypeB& atf_amc::typea_zdl_typeb_curs_Access(typea_zdl_typeb_curs &curs) {
    return *curs.row;
}

// --- atf_amc.FTypeA.bh_typeb_curs.Access
// Access current element. If not more elements, return NULL
inline atf_amc::FTypeB& atf_amc::typea_bh_typeb_curs_Access(typea_bh_typeb_curs &curs) {
    return *curs.temp_elems[0];
}

// --- atf_amc.FTypeA.bh_typeb_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool atf_amc::typea_bh_typeb_curs_ValidQ(typea_bh_typeb_curs &curs) {
    return curs.temp_n > 0;
}
inline atf_amc::FTypeB::FTypeB() {
    atf_amc::FTypeB_Init(*this);
}

inline atf_amc::FTypeB::~FTypeB() {
    atf_amc::FTypeB_Uninit(*this);
}


// --- atf_amc.FTypeB..Init
// Set all fields to initial values.
inline void atf_amc::FTypeB_Init(atf_amc::FTypeB& typeb) {
    typeb.typea = i32(0);
    typeb.j = i32(0);
    typeb.typeb_next = (atf_amc::FTypeB*)-1; // (atf_amc.FDb.typeb) not-in-tpool's freelist
    typeb.zdl_typeb_next = (atf_amc::FTypeB*)-1; // (atf_amc.FTypeA.zdl_typeb) not-in-list
    typeb.zdl_typeb_prev = NULL; // (atf_amc.FTypeA.zdl_typeb)
    typeb.bh_typeb_idx = -1; // (atf_amc.FTypeA.bh_typeb) not-in-heap
}
inline atf_amc::FTypeD::FTypeD() {
    atf_amc::FTypeD_Init(*this);
}

inline atf_amc::FTypeD::~FTypeD() {
    atf_amc::FTypeD_Uninit(*this);
}


// --- atf_amc.FTypeD..Init
// Set all fields to initial values.
inline void atf_amc::FTypeD_Init(atf_amc::FTypeD& typed) {
    typed.typec = i32(0);
    typed.zd_typed_next = (atf_amc::FTypeD*)-1; // (atf_amc.FDb.zd_typed) not-in-list
    typed.zd_typed_prev = NULL; // (atf_amc.FDb.zd_typed)
    typed.zs_t_typed_next = (atf_amc::FTypeD*)-1; // (atf_amc.FDb.zs_t_typed) not-in-list
    typed.cd_typed_next = (atf_amc::FTypeD*)-1; // (atf_amc.FDb.cd_typed) not-in-list
    typed.cd_typed_prev = NULL; // (atf_amc.FDb.cd_typed)
    typed.typed_next = (atf_amc::FTypeD*)-1; // (atf_amc.FDb.typed) not-in-tpool's freelist
}
inline atf_amc::FTypeK::FTypeK() {
    atf_amc::FTypeK_Init(*this);
}


// --- atf_amc.FTypeK..Init
// Set all fields to initial values.
inline void atf_amc::FTypeK_Init(atf_amc::FTypeK& parent) {
    parent.value = u32(0);
    parent._db_c_typek_in_ary = bool(false);
}
inline atf_amc::FTypeS::FTypeS() {
    atf_amc::FTypeS_Init(*this);
}

inline atf_amc::FTypeS::~FTypeS() {
    atf_amc::FTypeS_Uninit(*this);
}


// --- atf_amc.FTypeS.zdl_typet.EmptyQ
// Return true if index is empty
inline bool atf_amc::zdl_typet_EmptyQ(atf_amc::FTypeS& types) {
    return types.zdl_typet_head == NULL;
}

// --- atf_amc.FTypeS.zdl_typet.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline atf_amc::FTypeT* atf_amc::zdl_typet_First(atf_amc::FTypeS& types) {
    atf_amc::FTypeT *row = NULL;
    row = types.zdl_typet_head;
    return row;
}

// --- atf_amc.FTypeS.zdl_typet.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool atf_amc::zdl_typet_InLlistQ(atf_amc::FTypeT& row) {
    bool result = false;
    result = !(row.zdl_typet_next == (atf_amc::FTypeT*)-1);
    return result;
}

// --- atf_amc.FTypeS.zdl_typet.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline atf_amc::FTypeT* atf_amc::zdl_typet_Last(atf_amc::FTypeS& types) {
    atf_amc::FTypeT *row = NULL;
    row = types.zdl_typet_tail;
    return row;
}

// --- atf_amc.FTypeS.zdl_typet.N
// Return number of items in the linked list
inline i32 atf_amc::zdl_typet_N(const atf_amc::FTypeS& types) {
    return types.zdl_typet_n;
}

// --- atf_amc.FTypeS.zdl_typet.Next
// Return pointer to next element in the list
inline atf_amc::FTypeT* atf_amc::zdl_typet_Next(atf_amc::FTypeT &row) {
    return row.zdl_typet_next;
}

// --- atf_amc.FTypeS.zdl_typet.Prev
// Return pointer to previous element in the list
inline atf_amc::FTypeT* atf_amc::zdl_typet_Prev(atf_amc::FTypeT &row) {
    return row.zdl_typet_prev;
}

// --- atf_amc.FTypeS.zdl_typet.qLast
// Return reference to last element in the index. No bounds checking.
inline atf_amc::FTypeT& atf_amc::zdl_typet_qLast(atf_amc::FTypeS& types) {
    atf_amc::FTypeT *row = NULL;
    row = types.zdl_typet_tail;
    return *row;
}

// --- atf_amc.FTypeS..Init
// Set all fields to initial values.
inline void atf_amc::FTypeS_Init(atf_amc::FTypeS& types) {
    types.types = i32(0);
    types.zdl_typet_head = NULL; // (atf_amc.FTypeS.zdl_typet)
    types.zdl_typet_n = 0; // (atf_amc.FTypeS.zdl_typet)
    types.zdl_typet_tail = NULL; // (atf_amc.FTypeS.zdl_typet)
    types.ind_types_next = (atf_amc::FTypeS*)-1; // (atf_amc.FDb.ind_types) not-in-hash
}

// --- atf_amc.FTypeS.zdl_typet_curs.Reset
// cursor points to valid item
inline void atf_amc::types_zdl_typet_curs_Reset(types_zdl_typet_curs &curs, atf_amc::FTypeS &parent) {
    curs.row = parent.zdl_typet_head;
}

// --- atf_amc.FTypeS.zdl_typet_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::types_zdl_typet_curs_ValidQ(types_zdl_typet_curs &curs) {
    return curs.row != NULL;
}

// --- atf_amc.FTypeS.zdl_typet_curs.Next
// proceed to next item
inline void atf_amc::types_zdl_typet_curs_Next(types_zdl_typet_curs &curs) {
    atf_amc::FTypeT *next = (*curs.row).zdl_typet_next;
    curs.row = next;
}

// --- atf_amc.FTypeS.zdl_typet_curs.Access
// item access
inline atf_amc::FTypeT& atf_amc::types_zdl_typet_curs_Access(types_zdl_typet_curs &curs) {
    return *curs.row;
}
inline atf_amc::FTypeT::FTypeT() {
    atf_amc::FTypeT_Init(*this);
}

inline atf_amc::FTypeT::~FTypeT() {
    atf_amc::FTypeT_Uninit(*this);
}


// --- atf_amc.FTypeT..Init
// Set all fields to initial values.
inline void atf_amc::FTypeT_Init(atf_amc::FTypeT& typet) {
    typet.types = i32(0);
    typet.j = i32(0);
    typet.zdl_typet_next = (atf_amc::FTypeT*)-1; // (atf_amc.FTypeS.zdl_typet) not-in-list
    typet.zdl_typet_prev = NULL; // (atf_amc.FTypeS.zdl_typet)
}

inline bool atf_amc::TypeA::operator ==(const atf_amc::TypeA &rhs) const {
    return atf_amc::TypeA_Eq(const_cast<atf_amc::TypeA&>(*this),const_cast<atf_amc::TypeA&>(rhs));
}

inline bool atf_amc::TypeA::operator !=(const atf_amc::TypeA &rhs) const {
    return !atf_amc::TypeA_Eq(const_cast<atf_amc::TypeA&>(*this),const_cast<atf_amc::TypeA&>(rhs));
}

inline bool atf_amc::TypeA::operator <(const atf_amc::TypeA &rhs) const {
    return atf_amc::TypeA_Lt(const_cast<atf_amc::TypeA&>(*this),const_cast<atf_amc::TypeA&>(rhs));
}

inline bool atf_amc::TypeA::operator >(const atf_amc::TypeA &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::TypeA::operator <=(const atf_amc::TypeA &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::TypeA::operator >=(const atf_amc::TypeA &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::TypeA::TypeA() {
    atf_amc::TypeA_Init(*this);
}


// --- atf_amc.TypeA..Hash
inline u32 atf_amc::TypeA_Hash(u32 prev, const atf_amc::TypeA & rhs) {
    prev = i32_Hash(prev, rhs.typea);
    return prev;
}

// --- atf_amc.TypeA..Lt
inline bool atf_amc::TypeA_Lt(atf_amc::TypeA & lhs, atf_amc::TypeA & rhs) {
    return i32_Lt(lhs.typea, rhs.typea);
}

// --- atf_amc.TypeA..Cmp
inline i32 atf_amc::TypeA_Cmp(atf_amc::TypeA & lhs, atf_amc::TypeA & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typea, rhs.typea);
    return retval;
}

// --- atf_amc.TypeA..Init
// Set all fields to initial values.
inline void atf_amc::TypeA_Init(atf_amc::TypeA& tary) {
    tary.typea = i32(0);
}

// --- atf_amc.TypeA..Eq
inline bool atf_amc::TypeA_Eq(const atf_amc::TypeA & lhs,const atf_amc::TypeA & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typea, rhs.typea);
    return retval;
}

// --- atf_amc.TypeA..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::TypeA_Update(atf_amc::TypeA &lhs, atf_amc::TypeA & rhs) {
    bool ret = !TypeA_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::FUnitSort::FUnitSort() {
    atf_amc::FUnitSort_Init(*this);
}

inline atf_amc::FUnitSort::~FUnitSort() {
    atf_amc::FUnitSort_Uninit(*this);
}


// --- atf_amc.FUnitSort.tary.EmptyQ
// Return true if index is empty
inline bool atf_amc::tary_EmptyQ(atf_amc::FUnitSort& parent) {
    return parent.tary_n == 0;
}

// --- atf_amc.FUnitSort.tary.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::TypeA* atf_amc::tary_Find(atf_amc::FUnitSort& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.tary_n;
    if (idx >= lim) return NULL;
    return parent.tary_elems + idx;
}

// --- atf_amc.FUnitSort.tary.Getary
// Return array pointer by value
inline algo::aryptr<atf_amc::TypeA> atf_amc::tary_Getary(atf_amc::FUnitSort& parent) {
    return algo::aryptr<atf_amc::TypeA>(parent.tary_elems, parent.tary_n);
}

// --- atf_amc.FUnitSort.tary.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_amc::TypeA* atf_amc::tary_Last(atf_amc::FUnitSort& parent) {
    return tary_Find(parent, u64(parent.tary_n-1));
}

// --- atf_amc.FUnitSort.tary.Max
// Return max. number of items in the array
inline i32 atf_amc::tary_Max(atf_amc::FUnitSort& parent) {
    (void)parent;
    return parent.tary_max;
}

// --- atf_amc.FUnitSort.tary.N
// Return number of items in the array
inline i32 atf_amc::tary_N(const atf_amc::FUnitSort& parent) {
    return parent.tary_n;
}

// --- atf_amc.FUnitSort.tary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_amc::tary_Reserve(atf_amc::FUnitSort& parent, int n) {
    u32 new_n = parent.tary_n + n;
    if (UNLIKELY(new_n > parent.tary_max)) {
        tary_AbsReserve(parent, new_n);
    }
}

// --- atf_amc.FUnitSort.tary.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_amc::TypeA& atf_amc::tary_qFind(atf_amc::FUnitSort& parent, u64 t) {
    return parent.tary_elems[t];
}

// --- atf_amc.FUnitSort.tary.qLast
// Return reference to last element of array. No bounds checking
inline atf_amc::TypeA& atf_amc::tary_qLast(atf_amc::FUnitSort& parent) {
    return tary_qFind(parent, u64(parent.tary_n-1));
}

// --- atf_amc.FUnitSort.tary.rowid_Get
// Return row id of specified element
inline u64 atf_amc::tary_rowid_Get(atf_amc::FUnitSort& parent, atf_amc::TypeA &elem) {
    u64 id = &elem - parent.tary_elems;
    return u64(id);
}

// --- atf_amc.FUnitSort.c_ptrary.EmptyQ
// Return true if index is empty
inline bool atf_amc::c_ptrary_EmptyQ(atf_amc::FUnitSort& parent) {
    return parent.c_ptrary_n == 0;
}

// --- atf_amc.FUnitSort.c_ptrary.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::TypeA* atf_amc::c_ptrary_Find(atf_amc::FUnitSort& parent, u32 t) {
    atf_amc::TypeA *retval = NULL;
    u64 idx = t;
    u64 lim = parent.c_ptrary_n;
    if (idx < lim) {
        retval = parent.c_ptrary_elems[idx];
    }
    return retval;
}

// --- atf_amc.FUnitSort.c_ptrary.Getary
// Return array of pointers
inline algo::aryptr<atf_amc::TypeA*> atf_amc::c_ptrary_Getary(atf_amc::FUnitSort& parent) {
    return algo::aryptr<atf_amc::TypeA*>(parent.c_ptrary_elems, parent.c_ptrary_n);
}

// --- atf_amc.FUnitSort.c_ptrary.N
// Return number of items in the pointer array
inline i32 atf_amc::c_ptrary_N(const atf_amc::FUnitSort& parent) {
    return parent.c_ptrary_n;
}

// --- atf_amc.FUnitSort.c_ptrary.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_amc::c_ptrary_RemoveAll(atf_amc::FUnitSort& parent) {
    parent.c_ptrary_n = 0;
}

// --- atf_amc.FUnitSort.fixary.Fill
// Set all elements of fixed array to value RHS
inline void atf_amc::fixary_Fill(atf_amc::FUnitSort& parent, const atf_amc::TypeA &rhs) {
    for (int i = 0; i < 100; i++) {
        parent.fixary_elems[i] = rhs;
    }
}

// --- atf_amc.FUnitSort.fixary.Find
// Look up row by row id. Return NULL if out of range
inline atf_amc::TypeA* atf_amc::fixary_Find(atf_amc::FUnitSort& parent, u64 t) {
    u64 idx = t;
    u64 lim = 100;
    return idx < lim ? parent.fixary_elems + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.FUnitSort.fixary.Getary
// Access fixed array fixary as aryptr.
inline algo::aryptr<atf_amc::TypeA> atf_amc::fixary_Getary(atf_amc::FUnitSort& parent) {
    return algo::aryptr<atf_amc::TypeA>(parent.fixary_elems, 100);
}

// --- atf_amc.FUnitSort.fixary.Max
// Return max number of items in the array
inline i32 atf_amc::fixary_Max(atf_amc::FUnitSort& parent) {
    (void)parent;
    return 100;
}

// --- atf_amc.FUnitSort.fixary.N
// Return number of items in the array
inline i32 atf_amc::fixary_N(const atf_amc::FUnitSort& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 100;
}

// --- atf_amc.FUnitSort.fixary.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void atf_amc::fixary_Setary(atf_amc::FUnitSort& parent, const algo::aryptr<atf_amc::TypeA> &rhs) {
    int n = 100 < rhs.n_elems ? 100 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.fixary_elems[i] = rhs[i];
    }
}

// --- atf_amc.FUnitSort.fixary.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline atf_amc::TypeA& atf_amc::fixary_qFind(atf_amc::FUnitSort& parent, u64 t) {
    return parent.fixary_elems[t];
}

// --- atf_amc.FUnitSort.tary_curs.Next
// proceed to next item
inline void atf_amc::FUnitSort_tary_curs_Next(FUnitSort_tary_curs &curs) {
    curs.index++;
}

// --- atf_amc.FUnitSort.tary_curs.Reset
inline void atf_amc::FUnitSort_tary_curs_Reset(FUnitSort_tary_curs &curs, atf_amc::FUnitSort &parent) {
    curs.elems = parent.tary_elems;
    curs.n_elems = parent.tary_n;
    curs.index = 0;
}

// --- atf_amc.FUnitSort.tary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::FUnitSort_tary_curs_ValidQ(FUnitSort_tary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FUnitSort.tary_curs.Access
// item access
inline atf_amc::TypeA& atf_amc::FUnitSort_tary_curs_Access(FUnitSort_tary_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_amc.FUnitSort.c_ptrary_curs.Reset
inline void atf_amc::FUnitSort_c_ptrary_curs_Reset(FUnitSort_c_ptrary_curs &curs, atf_amc::FUnitSort &parent) {
    curs.elems = parent.c_ptrary_elems;
    curs.n_elems = parent.c_ptrary_n;
    curs.index = 0;
}

// --- atf_amc.FUnitSort.c_ptrary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::FUnitSort_c_ptrary_curs_ValidQ(FUnitSort_c_ptrary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.FUnitSort.c_ptrary_curs.Next
// proceed to next item
inline void atf_amc::FUnitSort_c_ptrary_curs_Next(FUnitSort_c_ptrary_curs &curs) {
    curs.index++;
}

// --- atf_amc.FUnitSort.c_ptrary_curs.Access
// item access
inline atf_amc::TypeA& atf_amc::FUnitSort_c_ptrary_curs_Access(FUnitSort_c_ptrary_curs &curs) {
    return *curs.elems[curs.index];
}

// --- atf_amc.FUnitSort.fixary_curs.Reset
// cursor points to valid item
inline void atf_amc::FUnitSort_fixary_curs_Reset(FUnitSort_fixary_curs &curs, atf_amc::FUnitSort &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.FUnitSort.fixary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::FUnitSort_fixary_curs_ValidQ(FUnitSort_fixary_curs &curs) {
    return u64(curs.index) < u64(100);
}

// --- atf_amc.FUnitSort.fixary_curs.Next
// proceed to next item
inline void atf_amc::FUnitSort_fixary_curs_Next(FUnitSort_fixary_curs &curs) {
    curs.index++;
}

// --- atf_amc.FUnitSort.fixary_curs.Access
// item access
inline atf_amc::TypeA& atf_amc::FUnitSort_fixary_curs_Access(FUnitSort_fixary_curs &curs) {
    return fixary_qFind((*curs.parent), u64(curs.index));
}

// --- atf_amc.FUnitSort..Init
// Set all fields to initial values.
inline void atf_amc::FUnitSort_Init(atf_amc::FUnitSort& parent) {
    parent.tary_elems 	= 0; // (atf_amc.FUnitSort.tary)
    parent.tary_n     	= 0; // (atf_amc.FUnitSort.tary)
    parent.tary_max   	= 0; // (atf_amc.FUnitSort.tary)
    parent.c_ptrary_elems = NULL; // (atf_amc.FUnitSort.c_ptrary)
    parent.c_ptrary_n = 0; // (atf_amc.FUnitSort.c_ptrary)
    parent.c_ptrary_max = 0; // (atf_amc.FUnitSort.c_ptrary)
}
inline atf_amc::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline atf_amc::FieldId::FieldId(atf_amc_FieldIdEnum arg) { this->value = i32(arg); }
inline atf_amc::FieldId::FieldId() {
    atf_amc::FieldId_Init(*this);
}


// --- atf_amc.FieldId.value.GetEnum
// Get value of field as enum type
inline atf_amc_FieldIdEnum atf_amc::value_GetEnum(const atf_amc::FieldId& parent) {
    return atf_amc_FieldIdEnum(parent.value);
}

// --- atf_amc.FieldId.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::FieldId& parent, atf_amc_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- atf_amc.FieldId.value.Cast
inline atf_amc::FieldId::operator atf_amc_FieldIdEnum () const {
    return atf_amc_FieldIdEnum((*this).value);
}

// --- atf_amc.FieldId..Init
// Set all fields to initial values.
inline void atf_amc::FieldId_Init(atf_amc::FieldId& parent) {
    parent.value = i32(-1);
}
inline atf_amc::Hooktype::Hooktype() {
    atf_amc::Hooktype_Init(*this);
}


// --- atf_amc.Hooktype.callback.Call
// Invoke function by pointer
inline void atf_amc::callback_Call(atf_amc::Hooktype& parent, atf_amc::Hooktype& arg) {
    if (parent.callback) {
        parent.callback((void*)parent.callback_ctx, arg);
    }
}

// --- atf_amc.Hooktype.callback.Set0
// Assign 0-argument hook with no context pointer
inline void atf_amc::callback_Set0(atf_amc::Hooktype& parent, void (*fcn)() ) {
    parent.callback_ctx = 0;
    parent.callback = (atf_amc::parent_callback_hook)fcn;
}

// --- atf_amc.Hooktype.callback.Set1
// Assign 1-argument hook with context pointer
template<class T> inline void atf_amc::callback_Set1(atf_amc::Hooktype& parent, T& ctx, void (*fcn)(T&) ) {
    parent.callback_ctx = (u64)&ctx;
    parent.callback = (atf_amc::parent_callback_hook)fcn;
}

// --- atf_amc.Hooktype.callback.Set2
// Assign 2-argument hook with context pointer
template<class T> inline void atf_amc::callback_Set2(atf_amc::Hooktype& parent, T& ctx, void (*fcn)(T&, atf_amc::Hooktype& arg) ) {
    parent.callback_ctx = (u64)&ctx;
    parent.callback = (atf_amc::parent_callback_hook)fcn;
}

// --- atf_amc.Hooktype..Init
// Set all fields to initial values.
inline void atf_amc::Hooktype_Init(atf_amc::Hooktype& parent) {
    parent.value = i32(0);
    parent.callback = NULL;
    parent.callback_ctx = 0;
}
inline atf_amc::InlaryPrint::InlaryPrint() {
    atf_amc::InlaryPrint_Init(*this);
    // added because atf_amc.InlaryPrint.inlary (Inlary) does not need initialization
    // coverity[uninit_member]
}

inline atf_amc::InlaryPrint::~InlaryPrint() {
    atf_amc::InlaryPrint_Uninit(*this);
}


// --- atf_amc.InlaryPrint.fixary.Fill
// Set all elements of fixed array to value RHS
inline void atf_amc::fixary_Fill(atf_amc::InlaryPrint& parent, const u32 &rhs) {
    for (int i = 0; i < 3; i++) {
        parent.fixary_elems[i] = rhs;
    }
}

// --- atf_amc.InlaryPrint.fixary.Find
// Look up row by row id. Return NULL if out of range
inline u32* atf_amc::fixary_Find(atf_amc::InlaryPrint& parent, u64 t) {
    u64 idx = t;
    u64 lim = 3;
    return idx < lim ? parent.fixary_elems + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.InlaryPrint.fixary.Getary
// Access fixed array fixary as aryptr.
inline algo::aryptr<u32> atf_amc::fixary_Getary(atf_amc::InlaryPrint& parent) {
    return algo::aryptr<u32>(parent.fixary_elems, 3);
}

// --- atf_amc.InlaryPrint.fixary.Max
// Return max number of items in the array
inline i32 atf_amc::fixary_Max(atf_amc::InlaryPrint& parent) {
    (void)parent;
    return 3;
}

// --- atf_amc.InlaryPrint.fixary.N
// Return number of items in the array
inline i32 atf_amc::fixary_N(const atf_amc::InlaryPrint& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 3;
}

// --- atf_amc.InlaryPrint.fixary.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void atf_amc::fixary_Setary(atf_amc::InlaryPrint& parent, const algo::aryptr<u32> &rhs) {
    int n = 3 < rhs.n_elems ? 3 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.fixary_elems[i] = rhs[i];
    }
}

// --- atf_amc.InlaryPrint.fixary.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u32& atf_amc::fixary_qFind(atf_amc::InlaryPrint& parent, u64 t) {
    return parent.fixary_elems[t];
}

// --- atf_amc.InlaryPrint.inlary.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* atf_amc::inlary_AllocMem(atf_amc::InlaryPrint& parent) {
    void *row = reinterpret_cast<u32*>(parent.inlary_data) + parent.inlary_n;
    if (parent.inlary_n == 10) row = NULL;
    if (row) parent.inlary_n++;
    return row;
}

// --- atf_amc.InlaryPrint.inlary.EmptyQ
// Return true if index is empty
inline bool atf_amc::inlary_EmptyQ(atf_amc::InlaryPrint& parent) {
    return parent.inlary_n == 0;
}

// --- atf_amc.InlaryPrint.inlary.Find
// Look up row by row id. Return NULL if out of range
inline u32* atf_amc::inlary_Find(atf_amc::InlaryPrint& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.inlary_n;
    return idx < lim ? reinterpret_cast<u32*>(parent.inlary_data) + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.InlaryPrint.inlary.Getary
// Return array pointer by value
inline algo::aryptr<u32> atf_amc::inlary_Getary(atf_amc::InlaryPrint& parent) {
    return algo::aryptr<u32>(reinterpret_cast<u32*>(parent.inlary_data), parent.inlary_n);
}

// --- atf_amc.InlaryPrint.inlary.Max
// Return constant 10 -- max. number of items in the pool
inline i32 atf_amc::inlary_Max(atf_amc::InlaryPrint& parent) {
    (void)parent;
    return 10;
}

// --- atf_amc.InlaryPrint.inlary.N
// Return number of items in the array
inline i32 atf_amc::inlary_N(const atf_amc::InlaryPrint& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return parent.inlary_n;
}

// --- atf_amc.InlaryPrint.inlary.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u32& atf_amc::inlary_qFind(atf_amc::InlaryPrint& parent, u64 t) {
    u64 idx = t;
    return reinterpret_cast<u32*>(parent.inlary_data)[idx];
}

// --- atf_amc.InlaryPrint.inlary.rowid_Get
// Compute row id of element given element's address
inline u64 atf_amc::inlary_rowid_Get(atf_amc::InlaryPrint& parent, u32 &row) {
    u64 ret = u64(&row - reinterpret_cast<u32*>(parent.inlary_data));
    return u64(ret);
}

// --- atf_amc.InlaryPrint.fixary_curs.Reset
// cursor points to valid item
inline void atf_amc::InlaryPrint_fixary_curs_Reset(InlaryPrint_fixary_curs &curs, atf_amc::InlaryPrint &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.InlaryPrint.fixary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::InlaryPrint_fixary_curs_ValidQ(InlaryPrint_fixary_curs &curs) {
    return u64(curs.index) < u64(3);
}

// --- atf_amc.InlaryPrint.fixary_curs.Next
// proceed to next item
inline void atf_amc::InlaryPrint_fixary_curs_Next(InlaryPrint_fixary_curs &curs) {
    curs.index++;
}

// --- atf_amc.InlaryPrint.fixary_curs.Access
// item access
inline u32& atf_amc::InlaryPrint_fixary_curs_Access(InlaryPrint_fixary_curs &curs) {
    return fixary_qFind((*curs.parent), u64(curs.index));
}

// --- atf_amc.InlaryPrint.inlary_curs.Reset
// cursor points to valid item
inline void atf_amc::InlaryPrint_inlary_curs_Reset(InlaryPrint_inlary_curs &curs, atf_amc::InlaryPrint &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.InlaryPrint.inlary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::InlaryPrint_inlary_curs_ValidQ(InlaryPrint_inlary_curs &curs) {
    return u64(curs.index) < u64(curs.parent->inlary_n);
}

// --- atf_amc.InlaryPrint.inlary_curs.Next
// proceed to next item
inline void atf_amc::InlaryPrint_inlary_curs_Next(InlaryPrint_inlary_curs &curs) {
    curs.index++;
}

// --- atf_amc.InlaryPrint.inlary_curs.Access
// item access
inline u32& atf_amc::InlaryPrint_inlary_curs_Access(InlaryPrint_inlary_curs &curs) {
    return inlary_qFind((*curs.parent), u64(curs.index));
}
inline atf_amc::Lary32::Lary32() {
    atf_amc::Lary32_Init(*this);
}

inline atf_amc::Lary32::~Lary32() {
    atf_amc::Lary32_Uninit(*this);
}


// --- atf_amc.Lary32.lary.EmptyQ
// Return true if index is empty
inline bool atf_amc::lary_EmptyQ(atf_amc::Lary32& parent) {
    return parent.lary_n == 0;
}

// --- atf_amc.Lary32.lary.Find
// Look up row by row id. Return NULL if out of range
inline u32* atf_amc::lary_Find(atf_amc::Lary32& parent, u64 t) {
    u32 *retval = NULL;
    if (LIKELY(u64(t) < u64(parent.lary_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &parent.lary_lary[bsr][index];
    }
    return retval;
}

// --- atf_amc.Lary32.lary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u32* atf_amc::lary_Last(atf_amc::Lary32& parent) {
    return lary_Find(parent, u64(parent.lary_n-1));
}

// --- atf_amc.Lary32.lary.N
// Return number of items in the pool
inline i32 atf_amc::lary_N(const atf_amc::Lary32& parent) {
    return parent.lary_n;
}

// --- atf_amc.Lary32.lary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u32& atf_amc::lary_qFind(atf_amc::Lary32& parent, u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return parent.lary_lary[bsr][index];
}

// --- atf_amc.Lary32.lary_curs.Reset
// cursor points to valid item
inline void atf_amc::Lary32_lary_curs_Reset(Lary32_lary_curs &curs, atf_amc::Lary32 &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.Lary32.lary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::Lary32_lary_curs_ValidQ(Lary32_lary_curs &curs) {
    return curs.index < (*curs.parent).lary_n;
}

// --- atf_amc.Lary32.lary_curs.Next
// proceed to next item
inline void atf_amc::Lary32_lary_curs_Next(Lary32_lary_curs &curs) {
    curs.index++;
}

// --- atf_amc.Lary32.lary_curs.Access
// item access
inline u32& atf_amc::Lary32_lary_curs_Access(Lary32_lary_curs &curs) {
    return lary_qFind((*curs.parent), u64(curs.index));
}
inline atf_amc::Linebuf::Linebuf() {
    atf_amc::Linebuf_Init(*this);
    // added because atf_amc.Linebuf.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}


// --- atf_amc.Linebuf.in.Max
// Return max. number of bytes in the buffer.
inline i32 atf_amc::in_Max(atf_amc::Linebuf& linebuf) {
    return 64;
    (void)linebuf;//only to avoid -Wunused-parameter
}

// --- atf_amc.Linebuf.in.N
// Return number of bytes in the buffer.
inline i32 atf_amc::in_N(atf_amc::Linebuf& linebuf) {
    return linebuf.in_end - linebuf.in_start;
}
inline atf_amc::MsgHdrLT::MsgHdrLT(u8                             in_len
        ,char                           in_type)
    : len(in_len)
    , type(in_type)
{
}
inline atf_amc::MsgHdrLT::MsgHdrLT() {
    atf_amc::MsgHdrLT_Init(*this);
}


// --- atf_amc.MsgHdrLT.type.GetEnum
// Get value of field as enum type
inline atf_amc_MsgHdrLT_type_Enum atf_amc::type_GetEnum(const atf_amc::MsgHdrLT& o) {
    return atf_amc_MsgHdrLT_type_Enum(o.type);
}

// --- atf_amc.MsgHdrLT.type.SetEnum
// Set value of field from enum type.
inline void atf_amc::type_SetEnum(atf_amc::MsgHdrLT& o, atf_amc_MsgHdrLT_type_Enum rhs) {
    o.type = char(rhs);
}

// --- atf_amc.MsgHdrLT..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::MsgHdrLT& row) {
    return i32(const_cast<atf_amc::MsgHdrLT&>(row).len + 2);
}

// --- atf_amc.MsgHdrLT..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::MsgHdrLT& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::MsgHdrLT&>(row).len + 2));
}

// --- atf_amc.MsgHdrLT..Init
// Set all fields to initial values.
inline void atf_amc::MsgHdrLT_Init(atf_amc::MsgHdrLT& o) {
    o.len = u8(0);
    o.type = char(0);
}
inline atf_amc::MsgHdrLTMsgsCase::MsgHdrLTMsgsCase(u32                            in_value)
    : value(in_value)
{
}
inline atf_amc::MsgHdrLTMsgsCase::MsgHdrLTMsgsCase(atf_amc_MsgHdrLTMsgsCaseEnum arg) { this->value = u32(arg); }
inline atf_amc::MsgHdrLTMsgsCase::MsgHdrLTMsgsCase() {
    atf_amc::MsgHdrLTMsgsCase_Init(*this);
}


// --- atf_amc.MsgHdrLTMsgsCase.value.GetEnum
// Get value of field as enum type
inline atf_amc_MsgHdrLTMsgsCaseEnum atf_amc::value_GetEnum(const atf_amc::MsgHdrLTMsgsCase& parent) {
    return atf_amc_MsgHdrLTMsgsCaseEnum(parent.value);
}

// --- atf_amc.MsgHdrLTMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::MsgHdrLTMsgsCase& parent, atf_amc_MsgHdrLTMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- atf_amc.MsgHdrLTMsgsCase.value.Cast
inline atf_amc::MsgHdrLTMsgsCase::operator atf_amc_MsgHdrLTMsgsCaseEnum () const {
    return atf_amc_MsgHdrLTMsgsCaseEnum((*this).value);
}

// --- atf_amc.MsgHdrLTMsgsCase..Init
// Set all fields to initial values.
inline void atf_amc::MsgHdrLTMsgsCase_Init(atf_amc::MsgHdrLTMsgsCase& parent) {
    parent.value = u32(0);
}
inline atf_amc::MsgHdrLT_curs::MsgHdrLT_curs() {
    atf_amc::MsgHdrLT_curs_Init(*this);
}


// --- atf_amc.MsgHdrLT_curs..ValidQ
inline bool atf_amc::MsgHdrLT_curs_ValidQ(atf_amc::MsgHdrLT_curs& curs) {
    return curs.msg != NULL;
}

// --- atf_amc.MsgHdrLT_curs..Reset
inline void atf_amc::MsgHdrLT_curs_Reset(atf_amc::MsgHdrLT_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    atf_amc::MsgHdrLT *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(atf_amc::MsgHdrLT)) {
        atf_amc::MsgHdrLT *ptr = (atf_amc::MsgHdrLT*)curs.bytes;
        msglen = (*ptr).len;
        if (msglen >= ssizeof(atf_amc::MsgHdrLT) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- atf_amc.MsgHdrLT_curs..Access
inline atf_amc::MsgHdrLT*& atf_amc::MsgHdrLT_curs_Access(atf_amc::MsgHdrLT_curs& curs) {
    return curs.msg;
}

// --- atf_amc.MsgHdrLT_curs..Next
inline void atf_amc::MsgHdrLT_curs_Next(atf_amc::MsgHdrLT_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    atf_amc::MsgHdrLT *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(atf_amc::MsgHdrLT)) {
        atf_amc::MsgHdrLT *ptr = (atf_amc::MsgHdrLT*)curs.bytes;
        msglen = (*ptr).len;
        if (msglen >= ssizeof(atf_amc::MsgHdrLT) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- atf_amc.MsgHdrLT_curs..Init
// Set all fields to initial values.
inline void atf_amc::MsgHdrLT_curs_Init(atf_amc::MsgHdrLT_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}
inline atf_amc::MsgType::MsgType(u16                            in_value)
    : value(in_value)
{
}
inline atf_amc::MsgType::MsgType(atf_amc_MsgTypeEnum arg) { this->value = u16(arg); }

inline bool atf_amc::MsgType::operator ==(const atf_amc::MsgType &rhs) const {
    return atf_amc::MsgType_Eq(const_cast<atf_amc::MsgType&>(*this),const_cast<atf_amc::MsgType&>(rhs));
}

inline bool atf_amc::MsgType::operator !=(const atf_amc::MsgType &rhs) const {
    return !atf_amc::MsgType_Eq(const_cast<atf_amc::MsgType&>(*this),const_cast<atf_amc::MsgType&>(rhs));
}

inline bool atf_amc::MsgType::operator <(const atf_amc::MsgType &rhs) const {
    return atf_amc::MsgType_Lt(const_cast<atf_amc::MsgType&>(*this),const_cast<atf_amc::MsgType&>(rhs));
}

inline bool atf_amc::MsgType::operator >(const atf_amc::MsgType &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::MsgType::operator <=(const atf_amc::MsgType &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::MsgType::operator >=(const atf_amc::MsgType &rhs) const {
    return !(*this < rhs);
}

inline bool atf_amc::MsgType::operator ==(atf_amc_MsgTypeEnum rhs) const {
    return atf_amc::MsgType_EqEnum(const_cast<atf_amc::MsgType&>(*this),rhs);
}
inline atf_amc::MsgType::MsgType() {
    atf_amc::MsgType_Init(*this);
}


// --- atf_amc.MsgType.value.GetEnum
// Get value of field as enum type
inline atf_amc_MsgTypeEnum atf_amc::value_GetEnum(const atf_amc::MsgType& parent) {
    return atf_amc_MsgTypeEnum(parent.value);
}

// --- atf_amc.MsgType.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::MsgType& parent, atf_amc_MsgTypeEnum rhs) {
    parent.value = u16(rhs);
}

// --- atf_amc.MsgType.value.Cast
inline atf_amc::MsgType::operator atf_amc_MsgTypeEnum () const {
    return atf_amc_MsgTypeEnum((*this).value);
}

// --- atf_amc.MsgType..Hash
inline u32 atf_amc::MsgType_Hash(u32 prev, atf_amc::MsgType rhs) {
    prev = u16_Hash(prev, rhs.value);
    return prev;
}

// --- atf_amc.MsgType..Lt
inline bool atf_amc::MsgType_Lt(atf_amc::MsgType lhs, atf_amc::MsgType rhs) {
    return u16_Lt(lhs.value, rhs.value);
}

// --- atf_amc.MsgType..Cmp
inline i32 atf_amc::MsgType_Cmp(atf_amc::MsgType lhs, atf_amc::MsgType rhs) {
    i32 retval = 0;
    retval = u16_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- atf_amc.MsgType..Init
// Set all fields to initial values.
inline void atf_amc::MsgType_Init(atf_amc::MsgType& parent) {
    parent.value = u16(0);
}

// --- atf_amc.MsgType..Eq
inline bool atf_amc::MsgType_Eq(atf_amc::MsgType lhs, atf_amc::MsgType rhs) {
    bool retval = true;
    retval = u16_Eq(lhs.value, rhs.value);
    return retval;
}

// --- atf_amc.MsgType..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::MsgType_Update(atf_amc::MsgType &lhs, atf_amc::MsgType rhs) {
    bool ret = !MsgType_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- atf_amc.MsgType..EqEnum
// define enum comparison operator to avoid ambiguity
inline bool atf_amc::MsgType_EqEnum(atf_amc::MsgType lhs, atf_amc_MsgTypeEnum rhs) {
    return atf_amc_MsgTypeEnum(lhs.value) == rhs;
}
inline atf_amc::MsgLength::MsgLength(u16                            in_value)
    : value(in_value)
{
}
inline atf_amc::MsgLength::MsgLength() {
    atf_amc::MsgLength_Init(*this);
}


// --- atf_amc.MsgLength.value.Cast
inline atf_amc::MsgLength::operator u16 () const {
    return u16((*this).value);
}

// --- atf_amc.MsgLength..Hash
inline u32 atf_amc::MsgLength_Hash(u32 prev, atf_amc::MsgLength rhs) {
    prev = u16_Hash(prev, rhs.value);
    return prev;
}

// --- atf_amc.MsgLength..Lt
inline bool atf_amc::MsgLength_Lt(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) {
    return u16_Lt(lhs.value, rhs.value);
}

// --- atf_amc.MsgLength..Cmp
inline i32 atf_amc::MsgLength_Cmp(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) {
    i32 retval = 0;
    retval = u16_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- atf_amc.MsgLength..Init
// Set all fields to initial values.
inline void atf_amc::MsgLength_Init(atf_amc::MsgLength& parent) {
    parent.value = u16(0);
}

// --- atf_amc.MsgLength..Eq
inline bool atf_amc::MsgLength_Eq(atf_amc::MsgLength lhs, atf_amc::MsgLength rhs) {
    bool retval = true;
    retval = u16_Eq(lhs.value, rhs.value);
    return retval;
}

// --- atf_amc.MsgLength..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::MsgLength_Update(atf_amc::MsgLength &lhs, atf_amc::MsgLength rhs) {
    bool ret = !MsgLength_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::MsgHeader::MsgHeader(atf_amc::MsgType               in_type
        ,atf_amc::MsgLength             in_length)
    : type(in_type)
    , length(in_length)
{
}

inline bool atf_amc::MsgHeader::operator ==(const atf_amc::MsgHeader &rhs) const {
    return atf_amc::MsgHeader_Eq(const_cast<atf_amc::MsgHeader&>(*this),const_cast<atf_amc::MsgHeader&>(rhs));
}

inline bool atf_amc::MsgHeader::operator !=(const atf_amc::MsgHeader &rhs) const {
    return !atf_amc::MsgHeader_Eq(const_cast<atf_amc::MsgHeader&>(*this),const_cast<atf_amc::MsgHeader&>(rhs));
}
inline atf_amc::MsgHeader::MsgHeader() {
}


// --- atf_amc.MsgHeader..Hash
inline u32 atf_amc::MsgHeader_Hash(u32 prev, const atf_amc::MsgHeader & rhs) {
    prev = MsgType_Hash(prev, rhs.type);
    prev = MsgLength_Hash(prev, rhs.length);
    return prev;
}

// --- atf_amc.MsgHeader..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::MsgHeader& row) {
    return i32(const_cast<atf_amc::MsgHeader&>(row).length);
}

// --- atf_amc.MsgHeader..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::MsgHeader& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::MsgHeader&>(row).length));
}

// --- atf_amc.MsgHeader..Cmp
inline i32 atf_amc::MsgHeader_Cmp(atf_amc::MsgHeader & lhs, atf_amc::MsgHeader & rhs) {
    i32 retval = 0;
    retval = atf_amc::MsgType_Cmp(lhs.type, rhs.type);
    if (retval != 0) {
        return retval;
    }
    retval = atf_amc::MsgLength_Cmp(lhs.length, rhs.length);
    return retval;
}

// --- atf_amc.MsgHeader..Eq
inline bool atf_amc::MsgHeader_Eq(const atf_amc::MsgHeader & lhs,const atf_amc::MsgHeader & rhs) {
    bool retval = true;
    retval = atf_amc::MsgType_Eq(lhs.type, rhs.type);
    if (!retval) {
        return false;
    }
    retval = atf_amc::MsgLength_Eq(lhs.length, rhs.length);
    return retval;
}
inline atf_amc::MsgHeader_curs::MsgHeader_curs() {
    atf_amc::MsgHeader_curs_Init(*this);
}


// --- atf_amc.MsgHeader_curs..ValidQ
inline bool atf_amc::MsgHeader_curs_ValidQ(atf_amc::MsgHeader_curs& curs) {
    return curs.msg != NULL;
}

// --- atf_amc.MsgHeader_curs..Reset
inline void atf_amc::MsgHeader_curs_Reset(atf_amc::MsgHeader_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    atf_amc::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(atf_amc::MsgHeader)) {
        atf_amc::MsgHeader *ptr = (atf_amc::MsgHeader*)curs.bytes;
        msglen = (*ptr).length;
        if (msglen >= ssizeof(atf_amc::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- atf_amc.MsgHeader_curs..Access
inline atf_amc::MsgHeader*& atf_amc::MsgHeader_curs_Access(atf_amc::MsgHeader_curs& curs) {
    return curs.msg;
}

// --- atf_amc.MsgHeader_curs..Next
inline void atf_amc::MsgHeader_curs_Next(atf_amc::MsgHeader_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    atf_amc::MsgHeader *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(atf_amc::MsgHeader)) {
        atf_amc::MsgHeader *ptr = (atf_amc::MsgHeader*)curs.bytes;
        msglen = (*ptr).length;
        if (msglen >= ssizeof(atf_amc::MsgHeader) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- atf_amc.MsgHeader_curs..Init
// Set all fields to initial values.
inline void atf_amc::MsgHeader_curs_Init(atf_amc::MsgHeader_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}
inline atf_amc::MsgLTA::MsgLTA(const algo::strptr&            in_a)
    : a(in_a)
{
    this->len = u8(ssizeof(*this) + (-2));
    this->type = char('A');
}
inline atf_amc::MsgLTA::MsgLTA() {
    atf_amc::MsgLTA_Init(*this);
}


// --- atf_amc.MsgLTA.base.Castdown
// Check if atf_amc::MsgHdrLT is an instance of MsgLTA by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTA.
// If not successful, quietly return NULL.
inline atf_amc::MsgLTA* atf_amc::MsgLTA_Castdown(atf_amc::MsgHdrLT &hdr) {
    bool cond = hdr.type == ('A');
    cond &= i32(hdr.len + 2) >= ssizeof(atf_amc::MsgLTA);
    return cond ? reinterpret_cast<atf_amc::MsgLTA*>(&hdr) : NULL;
}

// --- atf_amc.MsgLTA.base.Castbase
inline atf_amc::MsgHdrLT& atf_amc::Castbase(atf_amc::MsgLTA& parent) {
    return reinterpret_cast<atf_amc::MsgHdrLT&>(parent);
}

// --- atf_amc.MsgLTA..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::MsgLTA& row) {
    return i32(const_cast<atf_amc::MsgLTA&>(row).len + 2);
}

// --- atf_amc.MsgLTA..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::MsgLTA& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::MsgLTA&>(row).len + 2));
}

// --- atf_amc.MsgLTA..Init
// Set all fields to initial values.
inline void atf_amc::MsgLTA_Init(atf_amc::MsgLTA& parent) {
    parent.len = u8(ssizeof(parent) + (-2));
    parent.type = char('A');
}
inline atf_amc::MsgLTB::MsgLTB(const algo::strptr&            in_b)
    : b(in_b)
{
    this->len = u8(ssizeof(*this) + (-2));
    this->type = char('B');
}
inline atf_amc::MsgLTB::MsgLTB() {
    atf_amc::MsgLTB_Init(*this);
}


// --- atf_amc.MsgLTB.base.Castdown
// Check if atf_amc::MsgHdrLT is an instance of MsgLTB by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTB.
// If not successful, quietly return NULL.
inline atf_amc::MsgLTB* atf_amc::MsgLTB_Castdown(atf_amc::MsgHdrLT &hdr) {
    bool cond = hdr.type == ('B');
    cond &= i32(hdr.len + 2) >= ssizeof(atf_amc::MsgLTB);
    return cond ? reinterpret_cast<atf_amc::MsgLTB*>(&hdr) : NULL;
}

// --- atf_amc.MsgLTB.base.Castbase
inline atf_amc::MsgHdrLT& atf_amc::Castbase(atf_amc::MsgLTB& parent) {
    return reinterpret_cast<atf_amc::MsgHdrLT&>(parent);
}

// --- atf_amc.MsgLTB..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::MsgLTB& row) {
    return i32(const_cast<atf_amc::MsgLTB&>(row).len + 2);
}

// --- atf_amc.MsgLTB..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::MsgLTB& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::MsgLTB&>(row).len + 2));
}

// --- atf_amc.MsgLTB..Init
// Set all fields to initial values.
inline void atf_amc::MsgLTB_Init(atf_amc::MsgLTB& parent) {
    parent.len = u8(ssizeof(parent) + (-2));
    parent.type = char('B');
}
inline atf_amc::MsgLTO::MsgLTO() {
    atf_amc::MsgLTO_Init(*this);
}


// --- atf_amc.MsgLTO.base.Castdown
// Check if atf_amc::MsgHdrLT is an instance of MsgLTO by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTO.
// If not successful, quietly return NULL.
inline atf_amc::MsgLTO* atf_amc::MsgLTO_Castdown(atf_amc::MsgHdrLT &hdr) {
    bool cond = hdr.type == ('O');
    cond &= i32(hdr.len + 2) >= ssizeof(atf_amc::MsgLTO);
    return cond ? reinterpret_cast<atf_amc::MsgLTO*>(&hdr) : NULL;
}

// --- atf_amc.MsgLTO.base.Castbase
inline atf_amc::MsgHdrLT& atf_amc::Castbase(atf_amc::MsgLTO& parent) {
    return reinterpret_cast<atf_amc::MsgHdrLT&>(parent);
}

// --- atf_amc.MsgLTO.o.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized o, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If o's length field value is too short, return NULL.
// If o's length field value extends past parent's allowed length, return NULL.
inline atf_amc::MsgHdrLT* atf_amc::o_Get(atf_amc::MsgLTO& parent) {
    i32 totlen = i32(parent.len + 2);
    u8 *end = (u8*)&parent + sizeof(atf_amc::MsgLTO);
    atf_amc::MsgHdrLT *ptr = (atf_amc::MsgHdrLT*)end;
    bool exists = ssizeof(atf_amc::MsgLTO) + sizeof_atf_amc_MsgHdrLT <= totlen;
    exists = exists && i32((*ptr).len + 2) >= sizeof_atf_amc_MsgHdrLT && ssizeof(atf_amc::MsgLTO) + i32((*ptr).len + 2) <= totlen;
    return exists ? ptr : NULL;
}

// --- atf_amc.MsgLTO..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::MsgLTO& row) {
    return i32(const_cast<atf_amc::MsgLTO&>(row).len + 2);
}

// --- atf_amc.MsgLTO..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::MsgLTO& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::MsgLTO&>(row).len + 2));
}

// --- atf_amc.MsgLTO..Init
// Set all fields to initial values.
inline void atf_amc::MsgLTO_Init(atf_amc::MsgLTO& parent) {
    parent.len = u8(ssizeof(parent) + (-2));
    parent.type = char('O');
}
inline atf_amc::MsgLTV::MsgLTV() {
    atf_amc::MsgLTV_Init(*this);
}


// --- atf_amc.MsgLTV.base.Castdown
// Check if atf_amc::MsgHdrLT is an instance of MsgLTV by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgLTV.
// If not successful, quietly return NULL.
inline atf_amc::MsgLTV* atf_amc::MsgLTV_Castdown(atf_amc::MsgHdrLT &hdr) {
    bool cond = hdr.type == ('V');
    cond &= i32(hdr.len + 2) >= ssizeof(atf_amc::MsgLTV);
    return cond ? reinterpret_cast<atf_amc::MsgLTV*>(&hdr) : NULL;
}

// --- atf_amc.MsgLTV.base.Castbase
inline atf_amc::MsgHdrLT& atf_amc::Castbase(atf_amc::MsgLTV& parent) {
    return reinterpret_cast<atf_amc::MsgHdrLT&>(parent);
}

// --- atf_amc.MsgLTV.v.N
// Return number of elements in varlen field
inline u32 atf_amc::v_N(const atf_amc::MsgLTV& parent) {
    u32 length = i32(((atf_amc::MsgLTV&)parent).len + 2);
    u32 extra_bytes = u32_Max(length,sizeof(atf_amc::MsgLTV)) - sizeof(atf_amc::MsgLTV); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u8));
}

// --- atf_amc.MsgLTV.v_curs.Reset
inline void atf_amc::MsgLTV_v_curs_Reset(MsgLTV_v_curs &curs, atf_amc::MsgLTV &parent) {
    curs.ptr = (u8*)&parent + sizeof(atf_amc::MsgLTV);
    curs.length = i32(parent.len + 2) - sizeof(atf_amc::MsgLTV);
    curs.index = 0;
}

// --- atf_amc.MsgLTV.v_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::MsgLTV_v_curs_ValidQ(MsgLTV_v_curs &curs) {
    bool valid = ssizeof(atf_amc::MsgHdrLT) <= curs.length;
    valid = valid && unsigned(i32((*(atf_amc::MsgHdrLT*)curs.ptr).len + 2)-ssizeof(atf_amc::MsgHdrLT)) <= curs.length-ssizeof(atf_amc::MsgHdrLT);
    return valid;
}

// --- atf_amc.MsgLTV.v_curs.Next
// proceed to next item
inline void atf_amc::MsgLTV_v_curs_Next(MsgLTV_v_curs &curs) {
    i32 len = i32((*(atf_amc::MsgHdrLT*)curs.ptr).len + 2);
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- atf_amc.MsgLTV.v_curs.Access
// item access
inline atf_amc::MsgHdrLT& atf_amc::MsgLTV_v_curs_Access(MsgLTV_v_curs &curs) {
    return *(atf_amc::MsgHdrLT*)curs.ptr;
}

// --- atf_amc.MsgLTV..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::MsgLTV& row) {
    return i32(const_cast<atf_amc::MsgLTV&>(row).len + 2);
}

// --- atf_amc.MsgLTV..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::MsgLTV& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::MsgLTV&>(row).len + 2));
}

// --- atf_amc.MsgLTV..Init
// Set all fields to initial values.
inline void atf_amc::MsgLTV_Init(atf_amc::MsgLTV& parent) {
    parent.len = u8(ssizeof(parent) + (-2));
    parent.type = char('V');
}
inline atf_amc::Msgbuf::Msgbuf() {
    atf_amc::Msgbuf_Init(*this);
    // added because atf_amc.Msgbuf.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}

inline atf_amc::Msgbuf::~Msgbuf() {
    atf_amc::Msgbuf_Uninit(*this);
}


// --- atf_amc.Msgbuf.in.Max
// Return max. number of bytes in the buffer.
inline i32 atf_amc::in_Max(atf_amc::Msgbuf& msgbuf) {
    return 64;
    (void)msgbuf;//only to avoid -Wunused-parameter
}

// --- atf_amc.Msgbuf.in.N
// Return number of bytes in the buffer.
inline i32 atf_amc::in_N(atf_amc::Msgbuf& msgbuf) {
    return msgbuf.in_end - msgbuf.in_start;
}
inline atf_amc::MsgsCase::MsgsCase(u32                            in_value)
    : value(in_value)
{
}
inline atf_amc::MsgsCase::MsgsCase(atf_amc_MsgsCaseEnum arg) { this->value = u32(arg); }
inline atf_amc::MsgsCase::MsgsCase() {
    atf_amc::MsgsCase_Init(*this);
}


// --- atf_amc.MsgsCase.value.GetEnum
// Get value of field as enum type
inline atf_amc_MsgsCaseEnum atf_amc::value_GetEnum(const atf_amc::MsgsCase& parent) {
    return atf_amc_MsgsCaseEnum(parent.value);
}

// --- atf_amc.MsgsCase.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::MsgsCase& parent, atf_amc_MsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- atf_amc.MsgsCase.value.Cast
inline atf_amc::MsgsCase::operator atf_amc_MsgsCaseEnum () const {
    return atf_amc_MsgsCaseEnum((*this).value);
}

// --- atf_amc.MsgsCase..Init
// Set all fields to initial values.
inline void atf_amc::MsgsCase_Init(atf_amc::MsgsCase& parent) {
    parent.value = u32(0);
}
inline atf_amc::NetBitfld1::NetBitfld1() {
    atf_amc::NetBitfld1_Init(*this);
}


// --- atf_amc.NetBitfld1.value.Get
inline u16 atf_amc::value_Get(const atf_amc::NetBitfld1& parent) {
    return be16toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.NetBitfld1.value.Set
inline void atf_amc::value_Set(atf_amc::NetBitfld1& parent, u16 rhs) {
    parent.value_be = htobe16(rhs); // write big-endian value to memory
}

// --- atf_amc.NetBitfld1.bits0_4.Get
// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u8 atf_amc::bits0_4_Get(const atf_amc::NetBitfld1& parent) {
    return u8((value_Get(parent) >> 0) & 0x0f);
}

// --- atf_amc.NetBitfld1.bits0_4.Set
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits0_4_Set(atf_amc::NetBitfld1& parent, u8 rhs) {
    u16 t1    = u16(0x0f) << 0;
    u16 t2    = (u16(rhs) & 0x0f) << 0;
    value_Set(parent, u16((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.NetBitfld1.bits8_12.Get
// Retrieve bitfield from value of field value
//    4 bits starting at bit 8.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u8 atf_amc::bits8_12_Get(const atf_amc::NetBitfld1& parent) {
    return u8((value_Get(parent) >> 8) & 0x0f);
}

// --- atf_amc.NetBitfld1.bits8_12.Set
// Set bitfield in value of field 'value'
//    4 bits starting at bit 8.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits8_12_Set(atf_amc::NetBitfld1& parent, u8 rhs) {
    u16 t1    = u16(0x0f) << 8;
    u16 t2    = (u16(rhs) & 0x0f) << 8;
    value_Set(parent, u16((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.NetBitfld1..Init
// Set all fields to initial values.
inline void atf_amc::NetBitfld1_Init(atf_amc::NetBitfld1& parent) {
    parent.value_be = htobe16(0); // write big-endian value to memory
}
inline atf_amc::OptAlloc::OptAlloc() {
    atf_amc::OptAlloc_Init(*this);
}


// --- atf_amc.OptAlloc.typeg.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
inline atf_amc::TypeG* atf_amc::typeg_Get(atf_amc::OptAlloc& optalloc) {
    i32 totlen = i32(optalloc.length);
    u8 *end = (u8*)&optalloc + sizeof(atf_amc::OptAlloc);
    atf_amc::TypeG *ptr = (atf_amc::TypeG*)end;
    bool exists = ssizeof(atf_amc::OptAlloc) + sizeof_atf_amc_TypeG <= totlen;
    return exists ? ptr : NULL;
}

// --- atf_amc.OptAlloc..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::OptAlloc& row) {
    return i32(const_cast<atf_amc::OptAlloc&>(row).length);
}

// --- atf_amc.OptAlloc..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::OptAlloc& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::OptAlloc&>(row).length));
}

// --- atf_amc.OptAlloc..Init
// Set all fields to initial values.
inline void atf_amc::OptAlloc_Init(atf_amc::OptAlloc& optalloc) {
    optalloc.length = u32(0);
}
inline atf_amc::OptG::OptG() {
    atf_amc::OptG_Init(*this);
}


// --- atf_amc.OptG.typeg.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized typeg, return NULL.
inline atf_amc::TypeG* atf_amc::typeg_Get(atf_amc::OptG& optg) {
    i32 totlen = i32(optg.length);
    u8 *end = (u8*)&optg + sizeof(atf_amc::OptG);
    atf_amc::TypeG *ptr = (atf_amc::TypeG*)end;
    bool exists = ssizeof(atf_amc::OptG) + sizeof_atf_amc_TypeG <= totlen;
    return exists ? ptr : NULL;
}

// --- atf_amc.OptG..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::OptG& row) {
    return i32(const_cast<atf_amc::OptG&>(row).length);
}

// --- atf_amc.OptG..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::OptG& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::OptG&>(row).length));
}

// --- atf_amc.OptG..Init
// Set all fields to initial values.
inline void atf_amc::OptG_Init(atf_amc::OptG& optg) {
    optg.length = u32(0);
}
inline atf_amc::OptOptG::OptOptG() {
    atf_amc::OptOptG_Init(*this);
}


// --- atf_amc.OptOptG.optg.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized optg, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If optg's length field value is too short, return NULL.
// If optg's length field value extends past parent's allowed length, return NULL.
inline atf_amc::OptG* atf_amc::optg_Get(atf_amc::OptOptG& parent) {
    i32 totlen = i32(parent.length);
    u8 *end = (u8*)&parent + sizeof(atf_amc::OptOptG);
    atf_amc::OptG *ptr = (atf_amc::OptG*)end;
    bool exists = ssizeof(atf_amc::OptOptG) + sizeof_atf_amc_OptG <= totlen;
    exists = exists && i32((*ptr).length) >= sizeof_atf_amc_OptG && ssizeof(atf_amc::OptOptG) + i32((*ptr).length) <= totlen;
    return exists ? ptr : NULL;
}

// --- atf_amc.OptOptG..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::OptOptG& row) {
    return i32(const_cast<atf_amc::OptOptG&>(row).length);
}

// --- atf_amc.OptOptG..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::OptOptG& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::OptOptG&>(row).length));
}

// --- atf_amc.OptOptG..Init
// Set all fields to initial values.
inline void atf_amc::OptOptG_Init(atf_amc::OptOptG& parent) {
    parent.length = u32(0);
}
inline atf_amc::PmaskU128::PmaskU128() {
    atf_amc::PmaskU128_Init(*this);
}


// --- atf_amc.PmaskU128.pmask.N
// Return constant 1
inline int atf_amc::pmask_N(atf_amc::PmaskU128& parent) {
    (void)parent;
    return 1;
}

// --- atf_amc.PmaskU128.pmask.qFind
// Access value
inline u128& atf_amc::pmask_qFind(atf_amc::PmaskU128& parent, int) {
    return parent.pmask;
}

// --- atf_amc.PmaskU128.pmask.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_amc::pmask_Nbits(atf_amc::PmaskU128& parent) {
    return pmask_N(parent) * 128;
}

// --- atf_amc.PmaskU128.pmask.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_amc::pmask_qGetBit(atf_amc::PmaskU128& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = pmask_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_amc.PmaskU128.pmask.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_amc::pmask_GetBit(atf_amc::PmaskU128& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    bool ret = false;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u128 &elem = pmask_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_amc.PmaskU128.pmask.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_amc::pmask_BitsEmptyQ(atf_amc::PmaskU128& parent) {
    bool retval = true;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (pmask_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_amc.PmaskU128.pmask.Sum1s
inline u64 atf_amc::pmask_Sum1s(atf_amc::PmaskU128& parent) {
    u64 sum = 0;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u128_Count1s(pmask_qFind(parent, i));
    }
    return sum;
}

// --- atf_amc.PmaskU128.pmask.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qClearBit(atf_amc::PmaskU128& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u128(1) << shift); // clear bit
}

// --- atf_amc.PmaskU128.pmask.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_amc::pmask_ClearBit(atf_amc::PmaskU128& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u128 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u128(1) << shift); // clear bit
    }
}

// --- atf_amc.PmaskU128.pmask.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBit(atf_amc::PmaskU128& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u128(1) << shift); // set bit
}

// --- atf_amc.PmaskU128.pmask.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_amc::pmask_SetBit(atf_amc::PmaskU128& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u128 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem | (u128(1) << shift); // set bit
    }
}

// --- atf_amc.PmaskU128.pmask.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBitVal(atf_amc::PmaskU128& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u128(1) << shift)) | (u128(val) << shift); // insert new value
}

// --- atf_amc.PmaskU128.pmask.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qOrBitVal(atf_amc::PmaskU128& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u128(val) << shift); // Or in val into elem
}

// --- atf_amc.PmaskU128.pmask.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_amc::pmask_ClearBitsAll(atf_amc::PmaskU128& parent) {
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) = 0;
    }
}

// --- atf_amc.PmaskU128.pmask.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_amc::pmask_ClearBits(atf_amc::PmaskU128& parent, atf_amc::PmaskU128 &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) &= ~pmask_qFind(rhs, i);
    }
}

// --- atf_amc.PmaskU128.pmask.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_amc::pmask_OrBits(atf_amc::PmaskU128& parent, atf_amc::PmaskU128 &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) |= pmask_qFind(rhs, i);
    }
}

// --- atf_amc.PmaskU128.value.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 0);
}

// --- atf_amc.PmaskU128.value.SetPresent
inline void atf_amc::value_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value.Set
inline void atf_amc::value_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value = rhs;
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value2.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value2_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 1);
}

// --- atf_amc.PmaskU128.value2.SetPresent
inline void atf_amc::value2_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 1); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value2.Set
inline void atf_amc::value2_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value2 = rhs;
    pmask_qSetBit(parent, 1); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value3.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value3_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 2);
}

// --- atf_amc.PmaskU128.value3.SetPresent
inline void atf_amc::value3_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 2); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value3.Set
inline void atf_amc::value3_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value3 = rhs;
    pmask_qSetBit(parent, 2); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value21.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value21_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 3);
}

// --- atf_amc.PmaskU128.value21.SetPresent
inline void atf_amc::value21_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 3); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value21.Set
inline void atf_amc::value21_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value21 = rhs;
    pmask_qSetBit(parent, 3); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value22.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value22_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 4);
}

// --- atf_amc.PmaskU128.value22.SetPresent
inline void atf_amc::value22_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 4); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value22.Set
inline void atf_amc::value22_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value22 = rhs;
    pmask_qSetBit(parent, 4); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value23.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value23_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 5);
}

// --- atf_amc.PmaskU128.value23.SetPresent
inline void atf_amc::value23_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 5); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value23.Set
inline void atf_amc::value23_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value23 = rhs;
    pmask_qSetBit(parent, 5); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value24.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value24_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 6);
}

// --- atf_amc.PmaskU128.value24.SetPresent
inline void atf_amc::value24_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 6); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value24.Set
inline void atf_amc::value24_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value24 = rhs;
    pmask_qSetBit(parent, 6); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value25.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value25_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 7);
}

// --- atf_amc.PmaskU128.value25.SetPresent
inline void atf_amc::value25_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 7); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value25.Set
inline void atf_amc::value25_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value25 = rhs;
    pmask_qSetBit(parent, 7); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value26.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value26_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 8);
}

// --- atf_amc.PmaskU128.value26.SetPresent
inline void atf_amc::value26_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 8); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value26.Set
inline void atf_amc::value26_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value26 = rhs;
    pmask_qSetBit(parent, 8); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value20.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value20_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 9);
}

// --- atf_amc.PmaskU128.value20.SetPresent
inline void atf_amc::value20_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 9); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value20.Set
inline void atf_amc::value20_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value20 = rhs;
    pmask_qSetBit(parent, 9); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value28.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value28_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 10);
}

// --- atf_amc.PmaskU128.value28.SetPresent
inline void atf_amc::value28_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 10); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value28.Set
inline void atf_amc::value28_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value28 = rhs;
    pmask_qSetBit(parent, 10); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value29.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value29_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 11);
}

// --- atf_amc.PmaskU128.value29.SetPresent
inline void atf_amc::value29_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 11); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value29.Set
inline void atf_amc::value29_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value29 = rhs;
    pmask_qSetBit(parent, 11); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value30.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value30_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 12);
}

// --- atf_amc.PmaskU128.value30.SetPresent
inline void atf_amc::value30_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 12); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value30.Set
inline void atf_amc::value30_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value30 = rhs;
    pmask_qSetBit(parent, 12); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value31.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value31_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 13);
}

// --- atf_amc.PmaskU128.value31.SetPresent
inline void atf_amc::value31_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 13); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value31.Set
inline void atf_amc::value31_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value31 = rhs;
    pmask_qSetBit(parent, 13); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value32.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value32_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 14);
}

// --- atf_amc.PmaskU128.value32.SetPresent
inline void atf_amc::value32_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 14); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value32.Set
inline void atf_amc::value32_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value32 = rhs;
    pmask_qSetBit(parent, 14); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value27.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value27_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 15);
}

// --- atf_amc.PmaskU128.value27.SetPresent
inline void atf_amc::value27_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 15); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value27.Set
inline void atf_amc::value27_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value27 = rhs;
    pmask_qSetBit(parent, 15); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value19.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value19_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 16);
}

// --- atf_amc.PmaskU128.value19.SetPresent
inline void atf_amc::value19_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 16); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value19.Set
inline void atf_amc::value19_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value19 = rhs;
    pmask_qSetBit(parent, 16); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value18.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value18_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 17);
}

// --- atf_amc.PmaskU128.value18.SetPresent
inline void atf_amc::value18_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 17); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value18.Set
inline void atf_amc::value18_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value18 = rhs;
    pmask_qSetBit(parent, 17); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value4.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value4_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 18);
}

// --- atf_amc.PmaskU128.value4.SetPresent
inline void atf_amc::value4_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 18); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value4.Set
inline void atf_amc::value4_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value4 = rhs;
    pmask_qSetBit(parent, 18); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value5.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value5_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 19);
}

// --- atf_amc.PmaskU128.value5.SetPresent
inline void atf_amc::value5_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 19); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value5.Set
inline void atf_amc::value5_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value5 = rhs;
    pmask_qSetBit(parent, 19); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value6.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value6_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 20);
}

// --- atf_amc.PmaskU128.value6.SetPresent
inline void atf_amc::value6_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 20); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value6.Set
inline void atf_amc::value6_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value6 = rhs;
    pmask_qSetBit(parent, 20); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value7.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value7_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 21);
}

// --- atf_amc.PmaskU128.value7.SetPresent
inline void atf_amc::value7_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 21); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value7.Set
inline void atf_amc::value7_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value7 = rhs;
    pmask_qSetBit(parent, 21); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value8.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value8_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 22);
}

// --- atf_amc.PmaskU128.value8.SetPresent
inline void atf_amc::value8_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 22); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value8.Set
inline void atf_amc::value8_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value8 = rhs;
    pmask_qSetBit(parent, 22); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value9.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value9_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 23);
}

// --- atf_amc.PmaskU128.value9.SetPresent
inline void atf_amc::value9_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 23); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value9.Set
inline void atf_amc::value9_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value9 = rhs;
    pmask_qSetBit(parent, 23); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value69.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value69_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 24);
}

// --- atf_amc.PmaskU128.value69.SetPresent
inline void atf_amc::value69_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 24); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value69.Set
inline void atf_amc::value69_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value69 = rhs;
    pmask_qSetBit(parent, 24); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value11.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value11_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 25);
}

// --- atf_amc.PmaskU128.value11.SetPresent
inline void atf_amc::value11_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 25); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value11.Set
inline void atf_amc::value11_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value11 = rhs;
    pmask_qSetBit(parent, 25); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value12.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value12_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 26);
}

// --- atf_amc.PmaskU128.value12.SetPresent
inline void atf_amc::value12_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 26); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value12.Set
inline void atf_amc::value12_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value12 = rhs;
    pmask_qSetBit(parent, 26); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value13.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value13_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 27);
}

// --- atf_amc.PmaskU128.value13.SetPresent
inline void atf_amc::value13_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 27); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value13.Set
inline void atf_amc::value13_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value13 = rhs;
    pmask_qSetBit(parent, 27); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value14.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value14_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 28);
}

// --- atf_amc.PmaskU128.value14.SetPresent
inline void atf_amc::value14_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 28); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value14.Set
inline void atf_amc::value14_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value14 = rhs;
    pmask_qSetBit(parent, 28); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value15.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value15_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 29);
}

// --- atf_amc.PmaskU128.value15.SetPresent
inline void atf_amc::value15_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 29); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value15.Set
inline void atf_amc::value15_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value15 = rhs;
    pmask_qSetBit(parent, 29); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value16.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value16_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 30);
}

// --- atf_amc.PmaskU128.value16.SetPresent
inline void atf_amc::value16_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 30); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value16.Set
inline void atf_amc::value16_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value16 = rhs;
    pmask_qSetBit(parent, 30); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value33.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value33_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 31);
}

// --- atf_amc.PmaskU128.value33.SetPresent
inline void atf_amc::value33_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 31); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value33.Set
inline void atf_amc::value33_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value33 = rhs;
    pmask_qSetBit(parent, 31); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value10.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value10_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 32);
}

// --- atf_amc.PmaskU128.value10.SetPresent
inline void atf_amc::value10_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 32); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value10.Set
inline void atf_amc::value10_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value10 = rhs;
    pmask_qSetBit(parent, 32); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value17.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value17_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 33);
}

// --- atf_amc.PmaskU128.value17.SetPresent
inline void atf_amc::value17_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 33); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value17.Set
inline void atf_amc::value17_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value17 = rhs;
    pmask_qSetBit(parent, 33); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value35.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value35_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 34);
}

// --- atf_amc.PmaskU128.value35.SetPresent
inline void atf_amc::value35_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 34); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value35.Set
inline void atf_amc::value35_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value35 = rhs;
    pmask_qSetBit(parent, 34); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value55.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value55_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 35);
}

// --- atf_amc.PmaskU128.value55.SetPresent
inline void atf_amc::value55_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 35); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value55.Set
inline void atf_amc::value55_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value55 = rhs;
    pmask_qSetBit(parent, 35); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value56.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value56_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 36);
}

// --- atf_amc.PmaskU128.value56.SetPresent
inline void atf_amc::value56_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 36); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value56.Set
inline void atf_amc::value56_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value56 = rhs;
    pmask_qSetBit(parent, 36); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value57.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value57_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 37);
}

// --- atf_amc.PmaskU128.value57.SetPresent
inline void atf_amc::value57_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 37); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value57.Set
inline void atf_amc::value57_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value57 = rhs;
    pmask_qSetBit(parent, 37); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value58.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value58_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 38);
}

// --- atf_amc.PmaskU128.value58.SetPresent
inline void atf_amc::value58_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 38); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value58.Set
inline void atf_amc::value58_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value58 = rhs;
    pmask_qSetBit(parent, 38); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value59.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value59_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 39);
}

// --- atf_amc.PmaskU128.value59.SetPresent
inline void atf_amc::value59_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 39); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value59.Set
inline void atf_amc::value59_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value59 = rhs;
    pmask_qSetBit(parent, 39); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value60.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value60_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 40);
}

// --- atf_amc.PmaskU128.value60.SetPresent
inline void atf_amc::value60_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 40); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value60.Set
inline void atf_amc::value60_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value60 = rhs;
    pmask_qSetBit(parent, 40); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value54.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value54_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 41);
}

// --- atf_amc.PmaskU128.value54.SetPresent
inline void atf_amc::value54_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 41); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value54.Set
inline void atf_amc::value54_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value54 = rhs;
    pmask_qSetBit(parent, 41); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value62.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value62_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 42);
}

// --- atf_amc.PmaskU128.value62.SetPresent
inline void atf_amc::value62_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 42); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value62.Set
inline void atf_amc::value62_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value62 = rhs;
    pmask_qSetBit(parent, 42); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value63.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value63_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 43);
}

// --- atf_amc.PmaskU128.value63.SetPresent
inline void atf_amc::value63_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 43); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value63.Set
inline void atf_amc::value63_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value63 = rhs;
    pmask_qSetBit(parent, 43); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value64.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value64_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 44);
}

// --- atf_amc.PmaskU128.value64.SetPresent
inline void atf_amc::value64_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 44); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value64.Set
inline void atf_amc::value64_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value64 = rhs;
    pmask_qSetBit(parent, 44); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value65.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value65_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 45);
}

// --- atf_amc.PmaskU128.value65.SetPresent
inline void atf_amc::value65_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 45); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value65.Set
inline void atf_amc::value65_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value65 = rhs;
    pmask_qSetBit(parent, 45); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value66.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value66_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 46);
}

// --- atf_amc.PmaskU128.value66.SetPresent
inline void atf_amc::value66_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 46); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value66.Set
inline void atf_amc::value66_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value66 = rhs;
    pmask_qSetBit(parent, 46); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value67.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value67_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 47);
}

// --- atf_amc.PmaskU128.value67.SetPresent
inline void atf_amc::value67_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 47); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value67.Set
inline void atf_amc::value67_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value67 = rhs;
    pmask_qSetBit(parent, 47); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value68.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value68_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 48);
}

// --- atf_amc.PmaskU128.value68.SetPresent
inline void atf_amc::value68_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 48); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value68.Set
inline void atf_amc::value68_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value68 = rhs;
    pmask_qSetBit(parent, 48); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value61.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value61_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 49);
}

// --- atf_amc.PmaskU128.value61.SetPresent
inline void atf_amc::value61_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 49); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value61.Set
inline void atf_amc::value61_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value61 = rhs;
    pmask_qSetBit(parent, 49); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value34.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value34_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 50);
}

// --- atf_amc.PmaskU128.value34.SetPresent
inline void atf_amc::value34_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 50); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value34.Set
inline void atf_amc::value34_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value34 = rhs;
    pmask_qSetBit(parent, 50); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value52.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value52_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 51);
}

// --- atf_amc.PmaskU128.value52.SetPresent
inline void atf_amc::value52_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 51); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value52.Set
inline void atf_amc::value52_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value52 = rhs;
    pmask_qSetBit(parent, 51); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value36.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value36_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 52);
}

// --- atf_amc.PmaskU128.value36.SetPresent
inline void atf_amc::value36_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 52); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value36.Set
inline void atf_amc::value36_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value36 = rhs;
    pmask_qSetBit(parent, 52); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value37.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value37_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 53);
}

// --- atf_amc.PmaskU128.value37.SetPresent
inline void atf_amc::value37_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 53); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value37.Set
inline void atf_amc::value37_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value37 = rhs;
    pmask_qSetBit(parent, 53); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value38.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value38_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 54);
}

// --- atf_amc.PmaskU128.value38.SetPresent
inline void atf_amc::value38_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 54); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value38.Set
inline void atf_amc::value38_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value38 = rhs;
    pmask_qSetBit(parent, 54); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value39.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value39_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 55);
}

// --- atf_amc.PmaskU128.value39.SetPresent
inline void atf_amc::value39_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 55); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value39.Set
inline void atf_amc::value39_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value39 = rhs;
    pmask_qSetBit(parent, 55); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value40.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value40_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 56);
}

// --- atf_amc.PmaskU128.value40.SetPresent
inline void atf_amc::value40_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 56); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value40.Set
inline void atf_amc::value40_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value40 = rhs;
    pmask_qSetBit(parent, 56); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value41.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value41_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 57);
}

// --- atf_amc.PmaskU128.value41.SetPresent
inline void atf_amc::value41_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 57); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value41.Set
inline void atf_amc::value41_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value41 = rhs;
    pmask_qSetBit(parent, 57); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value42.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value42_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 58);
}

// --- atf_amc.PmaskU128.value42.SetPresent
inline void atf_amc::value42_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 58); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value42.Set
inline void atf_amc::value42_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value42 = rhs;
    pmask_qSetBit(parent, 58); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value53.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value53_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 59);
}

// --- atf_amc.PmaskU128.value53.SetPresent
inline void atf_amc::value53_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 59); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value53.Set
inline void atf_amc::value53_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value53 = rhs;
    pmask_qSetBit(parent, 59); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value44.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value44_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 60);
}

// --- atf_amc.PmaskU128.value44.SetPresent
inline void atf_amc::value44_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 60); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value44.Set
inline void atf_amc::value44_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value44 = rhs;
    pmask_qSetBit(parent, 60); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value45.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value45_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 61);
}

// --- atf_amc.PmaskU128.value45.SetPresent
inline void atf_amc::value45_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 61); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value45.Set
inline void atf_amc::value45_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value45 = rhs;
    pmask_qSetBit(parent, 61); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value46.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value46_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 62);
}

// --- atf_amc.PmaskU128.value46.SetPresent
inline void atf_amc::value46_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 62); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value46.Set
inline void atf_amc::value46_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value46 = rhs;
    pmask_qSetBit(parent, 62); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value47.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value47_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 63);
}

// --- atf_amc.PmaskU128.value47.SetPresent
inline void atf_amc::value47_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 63); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value47.Set
inline void atf_amc::value47_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value47 = rhs;
    pmask_qSetBit(parent, 63); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value48.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value48_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 64);
}

// --- atf_amc.PmaskU128.value48.SetPresent
inline void atf_amc::value48_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 64); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value48.Set
inline void atf_amc::value48_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value48 = rhs;
    pmask_qSetBit(parent, 64); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value49.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value49_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 65);
}

// --- atf_amc.PmaskU128.value49.SetPresent
inline void atf_amc::value49_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 65); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value49.Set
inline void atf_amc::value49_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value49 = rhs;
    pmask_qSetBit(parent, 65); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value50.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value50_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 66);
}

// --- atf_amc.PmaskU128.value50.SetPresent
inline void atf_amc::value50_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 66); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value50.Set
inline void atf_amc::value50_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value50 = rhs;
    pmask_qSetBit(parent, 66); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value51.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value51_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 67);
}

// --- atf_amc.PmaskU128.value51.SetPresent
inline void atf_amc::value51_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 67); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value51.Set
inline void atf_amc::value51_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value51 = rhs;
    pmask_qSetBit(parent, 67); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value43.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value43_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 68);
}

// --- atf_amc.PmaskU128.value43.SetPresent
inline void atf_amc::value43_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 68); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value43.Set
inline void atf_amc::value43_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value43 = rhs;
    pmask_qSetBit(parent, 68); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value70.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value70_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 69);
}

// --- atf_amc.PmaskU128.value70.SetPresent
inline void atf_amc::value70_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 69); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value70.Set
inline void atf_amc::value70_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value70 = rhs;
    pmask_qSetBit(parent, 69); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value71.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value71_PresentQ(atf_amc::PmaskU128& parent) {
    return pmask_qGetBit(parent, 70);
}

// --- atf_amc.PmaskU128.value71.SetPresent
inline void atf_amc::value71_SetPresent(atf_amc::PmaskU128& parent) {
    pmask_qSetBit(parent, 70); // mark presence in pmask
}

// --- atf_amc.PmaskU128.value71.Set
inline void atf_amc::value71_Set(atf_amc::PmaskU128& parent, u32 rhs) {
    parent.value71 = rhs;
    pmask_qSetBit(parent, 70); // mark presence in pmask
}
inline atf_amc::PmaskU32::PmaskU32() {
    atf_amc::PmaskU32_Init(*this);
}


// --- atf_amc.PmaskU32.pmask.N
// Return constant 1
inline int atf_amc::pmask_N(atf_amc::PmaskU32& parent) {
    (void)parent;
    return 1;
}

// --- atf_amc.PmaskU32.pmask.qFind
// Access value
inline u32& atf_amc::pmask_qFind(atf_amc::PmaskU32& parent, int) {
    return parent.pmask;
}

// --- atf_amc.PmaskU32.pmask.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_amc::pmask_Nbits(atf_amc::PmaskU32& parent) {
    return pmask_N(parent) * 32;
}

// --- atf_amc.PmaskU32.pmask.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_amc::pmask_qGetBit(atf_amc::PmaskU32& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u32 &elem = pmask_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_amc.PmaskU32.pmask.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_amc::pmask_GetBit(atf_amc::PmaskU32& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    bool ret = false;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u32 &elem = pmask_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_amc.PmaskU32.pmask.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_amc::pmask_BitsEmptyQ(atf_amc::PmaskU32& parent) {
    bool retval = true;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (pmask_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_amc.PmaskU32.pmask.Sum1s
inline u64 atf_amc::pmask_Sum1s(atf_amc::PmaskU32& parent) {
    u64 sum = 0;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u32_Count1s(pmask_qFind(parent, i));
    }
    return sum;
}

// --- atf_amc.PmaskU32.pmask.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qClearBit(atf_amc::PmaskU32& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u32 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u32(1) << shift); // clear bit
}

// --- atf_amc.PmaskU32.pmask.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_amc::pmask_ClearBit(atf_amc::PmaskU32& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u32 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u32(1) << shift); // clear bit
    }
}

// --- atf_amc.PmaskU32.pmask.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBit(atf_amc::PmaskU32& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u32 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u32(1) << shift); // set bit
}

// --- atf_amc.PmaskU32.pmask.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_amc::pmask_SetBit(atf_amc::PmaskU32& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u32 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem | (u32(1) << shift); // set bit
    }
}

// --- atf_amc.PmaskU32.pmask.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBitVal(atf_amc::PmaskU32& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u32 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u32(1) << shift)) | (u32(val) << shift); // insert new value
}

// --- atf_amc.PmaskU32.pmask.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qOrBitVal(atf_amc::PmaskU32& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 5;
    u64 shift = bit_idx & 31;
    u32 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u32(val) << shift); // Or in val into elem
}

// --- atf_amc.PmaskU32.pmask.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_amc::pmask_ClearBitsAll(atf_amc::PmaskU32& parent) {
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) = 0;
    }
}

// --- atf_amc.PmaskU32.pmask.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_amc::pmask_ClearBits(atf_amc::PmaskU32& parent, atf_amc::PmaskU32 &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) &= ~pmask_qFind(rhs, i);
    }
}

// --- atf_amc.PmaskU32.pmask.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_amc::pmask_OrBits(atf_amc::PmaskU32& parent, atf_amc::PmaskU32 &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) |= pmask_qFind(rhs, i);
    }
}

// --- atf_amc.PmaskU32.pmask.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 atf_amc::pmask_Sup(atf_amc::PmaskU32& parent) {
    u64 lim = pmask_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u32 &val = pmask_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 32 + bitidx;
            break;
        }
    }
    return ret;
}

// --- atf_amc.PmaskU32.value.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value_PresentQ(atf_amc::PmaskU32& parent) {
    return pmask_qGetBit(parent, 0);
}

// --- atf_amc.PmaskU32.value.SetPresent
inline void atf_amc::value_SetPresent(atf_amc::PmaskU32& parent) {
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value.Set
inline void atf_amc::value_Set(atf_amc::PmaskU32& parent, u32 rhs) {
    parent.value = rhs;
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value2.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value2_PresentQ(atf_amc::PmaskU32& parent) {
    return pmask_qGetBit(parent, 1);
}

// --- atf_amc.PmaskU32.value2.SetPresent
inline void atf_amc::value2_SetPresent(atf_amc::PmaskU32& parent) {
    pmask_qSetBit(parent, 1); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value2.Set
inline void atf_amc::value2_Set(atf_amc::PmaskU32& parent, u32 rhs) {
    parent.value2 = rhs;
    pmask_qSetBit(parent, 1); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value3.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value3_PresentQ(atf_amc::PmaskU32& parent) {
    return pmask_qGetBit(parent, 2);
}

// --- atf_amc.PmaskU32.value3.SetPresent
inline void atf_amc::value3_SetPresent(atf_amc::PmaskU32& parent) {
    pmask_qSetBit(parent, 2); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value3.Set
inline void atf_amc::value3_Set(atf_amc::PmaskU32& parent, u32 rhs) {
    parent.value3 = rhs;
    pmask_qSetBit(parent, 2); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value4.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value4_PresentQ(atf_amc::PmaskU32& parent) {
    return pmask_qGetBit(parent, 3);
}

// --- atf_amc.PmaskU32.value4.SetPresent
inline void atf_amc::value4_SetPresent(atf_amc::PmaskU32& parent) {
    pmask_qSetBit(parent, 3); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value4.Set
inline void atf_amc::value4_Set(atf_amc::PmaskU32& parent, u32 rhs) {
    parent.value4 = rhs;
    pmask_qSetBit(parent, 3); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value5.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value5_PresentQ(atf_amc::PmaskU32& parent) {
    return pmask_qGetBit(parent, 4);
}

// --- atf_amc.PmaskU32.value5.SetPresent
inline void atf_amc::value5_SetPresent(atf_amc::PmaskU32& parent) {
    pmask_qSetBit(parent, 4); // mark presence in pmask
}

// --- atf_amc.PmaskU32.value5.Set
inline void atf_amc::value5_Set(atf_amc::PmaskU32& parent, u32 rhs) {
    parent.value5 = rhs;
    pmask_qSetBit(parent, 4); // mark presence in pmask
}

// --- atf_amc.PmaskU32..Init
// Set all fields to initial values.
inline void atf_amc::PmaskU32_Init(atf_amc::PmaskU32& parent) {
    parent.pmask = u32(0);
    parent.value = u32(0);
    parent.value2 = u32(0);
    parent.value3 = u32(0);
    parent.value4 = u32(0);
    parent.value5 = u32(0);
}
inline atf_amc::PmaskU555::PmaskU555() {
    atf_amc::PmaskU555_Init(*this);
}


// --- atf_amc.PmaskU555.value.PresentQ
// Return true if the field is marked in the presence mask
inline bool atf_amc::value_PresentQ(atf_amc::PmaskU555& parent) {
    return pmask_qGetBit(parent, 0);
}

// --- atf_amc.PmaskU555.value.SetPresent
inline void atf_amc::value_SetPresent(atf_amc::PmaskU555& parent) {
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.PmaskU555.value.Set
inline void atf_amc::value_Set(atf_amc::PmaskU555& parent, u32 rhs) {
    parent.value = rhs;
    pmask_qSetBit(parent, 0); // mark presence in pmask
}

// --- atf_amc.PmaskU555.pmask.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_amc::pmask_Nbits(atf_amc::PmaskU555& parent) {
    return pmask_N(parent) * 64;
}

// --- atf_amc.PmaskU555.pmask.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_amc::pmask_qGetBit(atf_amc::PmaskU555& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_amc.PmaskU555.pmask.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_amc::pmask_GetBit(atf_amc::PmaskU555& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    bool ret = false;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u64 &elem = pmask_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_amc.PmaskU555.pmask.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_amc::pmask_BitsEmptyQ(atf_amc::PmaskU555& parent) {
    bool retval = true;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (pmask_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_amc.PmaskU555.pmask.Sum1s
inline u64 atf_amc::pmask_Sum1s(atf_amc::PmaskU555& parent) {
    u64 sum = 0;
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u64_Count1s(pmask_qFind(parent, i));
    }
    return sum;
}

// --- atf_amc.PmaskU555.pmask.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qClearBit(atf_amc::PmaskU555& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u64(1) << shift); // clear bit
}

// --- atf_amc.PmaskU555.pmask.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_amc::pmask_ClearBit(atf_amc::PmaskU555& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u64 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u64(1) << shift); // clear bit
    }
}

// --- atf_amc.PmaskU555.pmask.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBit(atf_amc::PmaskU555& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(1) << shift); // set bit
}

// --- atf_amc.PmaskU555.pmask.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_amc::pmask_SetBit(atf_amc::PmaskU555& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = pmask_N(parent);
    if (elem_idx < lim) {
        u64 &elem = pmask_qFind(parent, elem_idx); // fetch
        elem = elem | (u64(1) << shift); // set bit
    }
}

// --- atf_amc.PmaskU555.pmask.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qSetBitVal(atf_amc::PmaskU555& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u64(1) << shift)) | (u64(val) << shift); // insert new value
}

// --- atf_amc.PmaskU555.pmask.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_amc::pmask_qOrBitVal(atf_amc::PmaskU555& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = pmask_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(val) << shift); // Or in val into elem
}

// --- atf_amc.PmaskU555.pmask.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_amc::pmask_ClearBitsAll(atf_amc::PmaskU555& parent) {
    u64 n = pmask_N(parent);
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) = 0;
    }
}

// --- atf_amc.PmaskU555.pmask.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_amc::pmask_ClearBits(atf_amc::PmaskU555& parent, atf_amc::PmaskU555 &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) &= ~pmask_qFind(rhs, i);
    }
}

// --- atf_amc.PmaskU555.pmask.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_amc::pmask_OrBits(atf_amc::PmaskU555& parent, atf_amc::PmaskU555 &rhs) {
    u64 n = u64_Min(pmask_N(parent), pmask_N(rhs));
    for (u64 i = 0; i < n; i++) {
        pmask_qFind(parent, i) |= pmask_qFind(rhs, i);
    }
}

// --- atf_amc.PmaskU555.pmask.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 atf_amc::pmask_Sup(atf_amc::PmaskU555& parent) {
    u64 lim = pmask_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u64 &val = pmask_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 64 + bitidx;
            break;
        }
    }
    return ret;
}

// --- atf_amc.PmaskU555.pmask.Fill
// Set all elements of fixed array to value RHS
inline void atf_amc::pmask_Fill(atf_amc::PmaskU555& parent, const u64 &rhs) {
    for (int i = 0; i < 10; i++) {
        parent.pmask_elems[i] = rhs;
    }
}

// --- atf_amc.PmaskU555.pmask.Find
// Look up row by row id. Return NULL if out of range
inline u64* atf_amc::pmask_Find(atf_amc::PmaskU555& parent, u64 t) {
    u64 idx = t;
    u64 lim = 10;
    return idx < lim ? parent.pmask_elems + idx : NULL; // unsigned comparison with limit
}

// --- atf_amc.PmaskU555.pmask.Getary
// Access fixed array pmask as aryptr.
inline algo::aryptr<u64> atf_amc::pmask_Getary(atf_amc::PmaskU555& parent) {
    return algo::aryptr<u64>(parent.pmask_elems, 10);
}

// --- atf_amc.PmaskU555.pmask.Max
// Return max number of items in the array
inline i32 atf_amc::pmask_Max(atf_amc::PmaskU555& parent) {
    (void)parent;
    return 10;
}

// --- atf_amc.PmaskU555.pmask.N
// Return number of items in the array
inline i32 atf_amc::pmask_N(const atf_amc::PmaskU555& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 10;
}

// --- atf_amc.PmaskU555.pmask.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void atf_amc::pmask_Setary(atf_amc::PmaskU555& parent, const algo::aryptr<u64> &rhs) {
    int n = 10 < rhs.n_elems ? 10 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.pmask_elems[i] = rhs[i];
    }
}

// --- atf_amc.PmaskU555.pmask.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u64& atf_amc::pmask_qFind(atf_amc::PmaskU555& parent, u64 t) {
    return parent.pmask_elems[t];
}

// --- atf_amc.PmaskU555.pmask_curs.Reset
// cursor points to valid item
inline void atf_amc::PmaskU555_pmask_curs_Reset(PmaskU555_pmask_curs &curs, atf_amc::PmaskU555 &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_amc.PmaskU555.pmask_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::PmaskU555_pmask_curs_ValidQ(PmaskU555_pmask_curs &curs) {
    return u64(curs.index) < u64(10);
}

// --- atf_amc.PmaskU555.pmask_curs.Next
// proceed to next item
inline void atf_amc::PmaskU555_pmask_curs_Next(PmaskU555_pmask_curs &curs) {
    curs.index++;
}

// --- atf_amc.PmaskU555.pmask_curs.Access
// item access
inline u64& atf_amc::PmaskU555_pmask_curs_Access(PmaskU555_pmask_curs &curs) {
    return pmask_qFind((*curs.parent), u64(curs.index));
}

// --- atf_amc.PmaskU555..Init
// Set all fields to initial values.
inline void atf_amc::PmaskU555_Init(atf_amc::PmaskU555& parent) {
    parent.value = u32(0);
    for (int i = 0; i < 10; i++) {
        parent.pmask_elems[i] = 0;
    }
}
inline atf_amc::PooledBE64::PooledBE64() {
    atf_amc::PooledBE64_Init(*this);
}


// --- atf_amc.PooledBE64.value.Get
inline u64 atf_amc::value_Get(const atf_amc::PooledBE64& pooledbe64) {
    return be64toh(pooledbe64.value_be); // read big-endian value from memory
}

// --- atf_amc.PooledBE64.value.Set
inline void atf_amc::value_Set(atf_amc::PooledBE64& pooledbe64, u64 rhs) {
    pooledbe64.value_be = htobe64(rhs); // write big-endian value to memory
}

// --- atf_amc.PooledBE64.value.GetEnum
// Get value of field as enum type
inline atf_amc_PooledBE64_value_Enum atf_amc::value_GetEnum(const atf_amc::PooledBE64& pooledbe64) {
    return atf_amc_PooledBE64_value_Enum(value_Get(pooledbe64));
}

// --- atf_amc.PooledBE64.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::PooledBE64& pooledbe64, atf_amc_PooledBE64_value_Enum rhs) {
    value_Set(pooledbe64, u64(rhs));
}

// --- atf_amc.PooledBE64..Init
// Set all fields to initial values.
inline void atf_amc::PooledBE64_Init(atf_amc::PooledBE64& pooledbe64) {
    pooledbe64.value_be = htobe64(0); // write big-endian value to memory
    pooledbe64.pooledbe64_next = (atf_amc::PooledBE64*)-1; // (atf_amc.FDb.pooledbe64) not-in-tpool's freelist
}

inline bool atf_amc::RnullStr6_U32::operator ==(const atf_amc::RnullStr6_U32 &rhs) const {
    return atf_amc::RnullStr6_U32_Eq(const_cast<atf_amc::RnullStr6_U32&>(*this),const_cast<atf_amc::RnullStr6_U32&>(rhs));
}

inline bool atf_amc::RnullStr6_U32::operator !=(const atf_amc::RnullStr6_U32 &rhs) const {
    return !atf_amc::RnullStr6_U32_Eq(const_cast<atf_amc::RnullStr6_U32&>(*this),const_cast<atf_amc::RnullStr6_U32&>(rhs));
}

inline bool atf_amc::RnullStr6_U32::operator ==(const algo::strptr &rhs) const {
    return atf_amc::RnullStr6_U32_EqStrptr(const_cast<atf_amc::RnullStr6_U32&>(*this),rhs);
}

inline bool atf_amc::RnullStr6_U32::operator <(const atf_amc::RnullStr6_U32 &rhs) const {
    return atf_amc::RnullStr6_U32_Lt(const_cast<atf_amc::RnullStr6_U32&>(*this),const_cast<atf_amc::RnullStr6_U32&>(rhs));
}

inline bool atf_amc::RnullStr6_U32::operator >(const atf_amc::RnullStr6_U32 &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::RnullStr6_U32::operator <=(const atf_amc::RnullStr6_U32 &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::RnullStr6_U32::operator >=(const atf_amc::RnullStr6_U32 &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::RnullStr6_U32::RnullStr6_U32() {
    atf_amc::RnullStr6_U32_Init(*this);
}


// --- atf_amc.RnullStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> atf_amc::ch_Getary(const atf_amc::RnullStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- atf_amc.RnullStr6_U32.ch.HashStrptr
inline u32 atf_amc::RnullStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- atf_amc.RnullStr6_U32.ch.Init
inline void atf_amc::ch_Init(atf_amc::RnullStr6_U32 &parent) {
    memset(parent.ch, 0, 6);
}

// --- atf_amc.RnullStr6_U32.ch.Max
// always return constant 6
inline int atf_amc::ch_Max(atf_amc::RnullStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- atf_amc.RnullStr6_U32.ch.N
inline int atf_amc::ch_N(const atf_amc::RnullStr6_U32& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- atf_amc.RnullStr6_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void atf_amc::RnullStr6_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- atf_amc.RnullStr6_U32.ch.Set
// Copy from same type
// Copy value from RHS.
inline void atf_amc::RnullStr6_U32::operator =(const atf_amc::RnullStr6_U32& parent) {
    memcpy(ch, parent.ch, 6);
}

// --- atf_amc.RnullStr6_U32.ch.Ctor
inline  atf_amc::RnullStr6_U32::RnullStr6_U32(const atf_amc::RnullStr6_U32 &rhs) {
    operator =(rhs);
}

// --- atf_amc.RnullStr6_U32.ch.CtorStrptr
inline  atf_amc::RnullStr6_U32::RnullStr6_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- atf_amc.RnullStr6_U32..Lt
inline bool atf_amc::RnullStr6_U32_Lt(atf_amc::RnullStr6_U32 & lhs, atf_amc::RnullStr6_U32 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- atf_amc.RnullStr6_U32..Cmp
inline i32 atf_amc::RnullStr6_U32_Cmp(atf_amc::RnullStr6_U32 & lhs, atf_amc::RnullStr6_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- atf_amc.RnullStr6_U32..Init
// Set all fields to initial values.
inline void atf_amc::RnullStr6_U32_Init(atf_amc::RnullStr6_U32& parent) {
    memset(parent.ch, 0, 6);
}

// --- atf_amc.RnullStr6_U32..Eq
inline bool atf_amc::RnullStr6_U32_Eq(const atf_amc::RnullStr6_U32 & lhs,const atf_amc::RnullStr6_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- atf_amc.RnullStr6_U32..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::RnullStr6_U32_Update(atf_amc::RnullStr6_U32 &lhs, atf_amc::RnullStr6_U32 & rhs) {
    bool ret = !RnullStr6_U32_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- atf_amc.RnullStr6_U32..EqStrptr
inline bool atf_amc::RnullStr6_U32_EqStrptr(atf_amc::RnullStr6_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool atf_amc::RpasU32Str6::operator ==(const atf_amc::RpasU32Str6 &rhs) const {
    return atf_amc::RpasU32Str6_Eq(const_cast<atf_amc::RpasU32Str6&>(*this),const_cast<atf_amc::RpasU32Str6&>(rhs));
}

inline bool atf_amc::RpasU32Str6::operator !=(const atf_amc::RpasU32Str6 &rhs) const {
    return !atf_amc::RpasU32Str6_Eq(const_cast<atf_amc::RpasU32Str6&>(*this),const_cast<atf_amc::RpasU32Str6&>(rhs));
}

inline bool atf_amc::RpasU32Str6::operator ==(const algo::strptr &rhs) const {
    return atf_amc::RpasU32Str6_EqStrptr(const_cast<atf_amc::RpasU32Str6&>(*this),rhs);
}

inline bool atf_amc::RpasU32Str6::operator <(const atf_amc::RpasU32Str6 &rhs) const {
    return atf_amc::RpasU32Str6_Lt(const_cast<atf_amc::RpasU32Str6&>(*this),const_cast<atf_amc::RpasU32Str6&>(rhs));
}

inline bool atf_amc::RpasU32Str6::operator >(const atf_amc::RpasU32Str6 &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::RpasU32Str6::operator <=(const atf_amc::RpasU32Str6 &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::RpasU32Str6::operator >=(const atf_amc::RpasU32Str6 &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::RpasU32Str6::RpasU32Str6() {
    atf_amc::RpasU32Str6_Init(*this);
}


// --- atf_amc.RpasU32Str6.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void atf_amc::ch_Add(atf_amc::RpasU32Str6& parent, char c) {
    if (parent.n_ch < 6) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- atf_amc.RpasU32Str6.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void atf_amc::ch_AddStrptr(atf_amc::RpasU32Str6& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 6) {
        n_new = 6 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- atf_amc.RpasU32Str6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> atf_amc::ch_Getary(const atf_amc::RpasU32Str6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- atf_amc.RpasU32Str6.ch.HashStrptr
inline u32 atf_amc::RpasU32Str6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- atf_amc.RpasU32Str6.ch.Init
inline void atf_amc::ch_Init(atf_amc::RpasU32Str6 &parent) {
    parent.n_ch = 0;
}

// --- atf_amc.RpasU32Str6.ch.Max
// always return constant 6
inline int atf_amc::ch_Max(atf_amc::RpasU32Str6& parent) {
    (void)parent;
    return 6;
}

// --- atf_amc.RpasU32Str6.ch.N
inline int atf_amc::ch_N(const atf_amc::RpasU32Str6& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- atf_amc.RpasU32Str6.ch.AssignStrptr
// Copy from strptr (operator=)
inline void atf_amc::RpasU32Str6::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- atf_amc.RpasU32Str6.ch.Set
// Copy from same type
// Copy value from RHS.
inline void atf_amc::RpasU32Str6::operator =(const atf_amc::RpasU32Str6& parent) {
    memcpy(ch, parent.ch, parent.n_ch);
    n_ch = parent.n_ch;
}

// --- atf_amc.RpasU32Str6.ch.Ctor
inline  atf_amc::RpasU32Str6::RpasU32Str6(const atf_amc::RpasU32Str6 &rhs) {
    operator =(rhs);
}

// --- atf_amc.RpasU32Str6.ch.CtorStrptr
inline  atf_amc::RpasU32Str6::RpasU32Str6(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- atf_amc.RpasU32Str6..Lt
inline bool atf_amc::RpasU32Str6_Lt(atf_amc::RpasU32Str6 & lhs, atf_amc::RpasU32Str6 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- atf_amc.RpasU32Str6..Cmp
inline i32 atf_amc::RpasU32Str6_Cmp(atf_amc::RpasU32Str6 & lhs, atf_amc::RpasU32Str6 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- atf_amc.RpasU32Str6..Init
// Set all fields to initial values.
inline void atf_amc::RpasU32Str6_Init(atf_amc::RpasU32Str6& parent) {
    parent.n_ch = 0;
}

// --- atf_amc.RpasU32Str6..Eq
inline bool atf_amc::RpasU32Str6_Eq(const atf_amc::RpasU32Str6 & lhs,const atf_amc::RpasU32Str6 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- atf_amc.RpasU32Str6..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::RpasU32Str6_Update(atf_amc::RpasU32Str6 &lhs, atf_amc::RpasU32Str6 & rhs) {
    bool ret = !RpasU32Str6_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- atf_amc.RpasU32Str6..EqStrptr
inline bool atf_amc::RpasU32Str6_EqStrptr(atf_amc::RpasU32Str6 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline atf_amc::Sep1::Sep1(u32                            in_val1
        ,u32                            in_val2
        ,u32                            in_val3)
    : val1(in_val1)
    , val2(in_val2)
    , val3(in_val3)
{
}

inline bool atf_amc::Sep1::operator ==(const atf_amc::Sep1 &rhs) const {
    return atf_amc::Sep1_Eq(const_cast<atf_amc::Sep1&>(*this),const_cast<atf_amc::Sep1&>(rhs));
}

inline bool atf_amc::Sep1::operator !=(const atf_amc::Sep1 &rhs) const {
    return !atf_amc::Sep1_Eq(const_cast<atf_amc::Sep1&>(*this),const_cast<atf_amc::Sep1&>(rhs));
}

inline bool atf_amc::Sep1::operator <(const atf_amc::Sep1 &rhs) const {
    return atf_amc::Sep1_Lt(const_cast<atf_amc::Sep1&>(*this),const_cast<atf_amc::Sep1&>(rhs));
}

inline bool atf_amc::Sep1::operator >(const atf_amc::Sep1 &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::Sep1::operator <=(const atf_amc::Sep1 &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::Sep1::operator >=(const atf_amc::Sep1 &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::Sep1::Sep1() {
    atf_amc::Sep1_Init(*this);
}


// --- atf_amc.Sep1..Hash
inline u32 atf_amc::Sep1_Hash(u32 prev, const atf_amc::Sep1 & rhs) {
    prev = u32_Hash(prev, rhs.val1);
    prev = u32_Hash(prev, rhs.val2);
    prev = u32_Hash(prev, rhs.val3);
    return prev;
}

// --- atf_amc.Sep1..Lt
inline bool atf_amc::Sep1_Lt(atf_amc::Sep1 & lhs, atf_amc::Sep1 & rhs) {
    return Sep1_Cmp(lhs,rhs) < 0;
}

// --- atf_amc.Sep1..Cmp
inline i32 atf_amc::Sep1_Cmp(atf_amc::Sep1 & lhs, atf_amc::Sep1 & rhs) {
    i32 retval = 0;
    retval = u32_Cmp(lhs.val1, rhs.val1);
    if (retval != 0) {
        return retval;
    }
    retval = u32_Cmp(lhs.val2, rhs.val2);
    if (retval != 0) {
        return retval;
    }
    retval = u32_Cmp(lhs.val3, rhs.val3);
    return retval;
}

// --- atf_amc.Sep1..Init
// Set all fields to initial values.
inline void atf_amc::Sep1_Init(atf_amc::Sep1& parent) {
    parent.val1 = u32(0);
    parent.val2 = u32(0);
    parent.val3 = u32(0);
}

// --- atf_amc.Sep1..Eq
inline bool atf_amc::Sep1_Eq(const atf_amc::Sep1 & lhs,const atf_amc::Sep1 & rhs) {
    bool retval = true;
    retval = u32_Eq(lhs.val1, rhs.val1);
    if (!retval) {
        return false;
    }
    retval = u32_Eq(lhs.val2, rhs.val2);
    if (!retval) {
        return false;
    }
    retval = u32_Eq(lhs.val3, rhs.val3);
    return retval;
}

// --- atf_amc.Sep1..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::Sep1_Update(atf_amc::Sep1 &lhs, atf_amc::Sep1 & rhs) {
    bool ret = !Sep1_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::Seqmsg::Seqmsg() {
    atf_amc::Seqmsg_Init(*this);
}


// --- atf_amc.Seqmsg.msghdr.Castdown
// Check if atf_amc::MsgHeader is an instance of Seqmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Seqmsg.
// If not successful, quietly return NULL.
inline atf_amc::Seqmsg* atf_amc::Seqmsg_Castdown(atf_amc::MsgHeader &hdr) {
    bool cond = hdr.type == (0x0905);
    cond &= i32(hdr.length) >= ssizeof(atf_amc::Seqmsg);
    return cond ? reinterpret_cast<atf_amc::Seqmsg*>(&hdr) : NULL;
}

// --- atf_amc.Seqmsg.msghdr.Castbase
inline atf_amc::MsgHeader& atf_amc::Castbase(atf_amc::Seqmsg& parent) {
    return reinterpret_cast<atf_amc::MsgHeader&>(parent);
}

// --- atf_amc.Seqmsg.payload.Get
// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
inline atf_amc::MsgHeader* atf_amc::payload_Get(atf_amc::Seqmsg& parent) {
    i32 totlen = i32(parent.length);
    u8 *end = (u8*)&parent + sizeof(atf_amc::Seqmsg);
    atf_amc::MsgHeader *ptr = (atf_amc::MsgHeader*)end;
    bool exists = ssizeof(atf_amc::Seqmsg) + sizeof_atf_amc_MsgHeader <= totlen;
    exists = exists && i32((*ptr).length) >= sizeof_atf_amc_MsgHeader && ssizeof(atf_amc::Seqmsg) + i32((*ptr).length) <= totlen;
    return exists ? ptr : NULL;
}

// --- atf_amc.Seqmsg..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::Seqmsg& row) {
    return i32(const_cast<atf_amc::Seqmsg&>(row).length);
}

// --- atf_amc.Seqmsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::Seqmsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::Seqmsg&>(row).length));
}

// --- atf_amc.Seqmsg..Init
// Set all fields to initial values.
inline void atf_amc::Seqmsg_Init(atf_amc::Seqmsg& parent) {
    parent.type = atf_amc_MsgTypeEnum(0x0905);
    parent.length = atf_amc::MsgLength(ssizeof(parent) + (0));
}
inline atf_amc::SortedStr::SortedStr(const algo::strptr&            in_novs
        ,const algo::strptr&            in_vs)
    : novs(in_novs)
    , vs(in_vs)
{
}

inline bool atf_amc::SortedStr::operator ==(const atf_amc::SortedStr &rhs) const {
    return atf_amc::SortedStr_Eq(const_cast<atf_amc::SortedStr&>(*this),const_cast<atf_amc::SortedStr&>(rhs));
}

inline bool atf_amc::SortedStr::operator !=(const atf_amc::SortedStr &rhs) const {
    return !atf_amc::SortedStr_Eq(const_cast<atf_amc::SortedStr&>(*this),const_cast<atf_amc::SortedStr&>(rhs));
}

inline bool atf_amc::SortedStr::operator <(const atf_amc::SortedStr &rhs) const {
    return atf_amc::SortedStr_Lt(const_cast<atf_amc::SortedStr&>(*this),const_cast<atf_amc::SortedStr&>(rhs));
}

inline bool atf_amc::SortedStr::operator >(const atf_amc::SortedStr &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::SortedStr::operator <=(const atf_amc::SortedStr &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::SortedStr::operator >=(const atf_amc::SortedStr &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::SortedStr::SortedStr() {
}


// --- atf_amc.SortedStr.novs.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool atf_amc::novs_Lt(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) {
    return algo::cstring_Lt(parent.novs,rhs.novs);
}

// --- atf_amc.SortedStr.novs.Cmp
// Compare two fields.
inline i32 atf_amc::novs_Cmp(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) {
    i32 retval = 0;
    retval = algo::cstring_Cmp(parent.novs, rhs.novs);
    return retval;
}

// --- atf_amc.SortedStr.vs.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool atf_amc::vs_Lt(atf_amc::SortedStr& parent, atf_amc::SortedStr &rhs) {
    return vs_Cmp(parent,rhs) < 0;
}

// --- atf_amc.SortedStr..Lt
inline bool atf_amc::SortedStr_Lt(atf_amc::SortedStr & lhs, atf_amc::SortedStr & rhs) {
    return SortedStr_Cmp(lhs,rhs) < 0;
}

// --- atf_amc.SortedStr..Cmp
inline i32 atf_amc::SortedStr_Cmp(atf_amc::SortedStr & lhs, atf_amc::SortedStr & rhs) {
    i32 retval = 0;
    retval = novs_Cmp(lhs,rhs);
    if (retval != 0) {
        return retval;
    }
    retval = vs_Cmp(lhs,rhs);
    return retval;
}

// --- atf_amc.SortedStr..Eq
inline bool atf_amc::SortedStr_Eq(const atf_amc::SortedStr & lhs,const atf_amc::SortedStr & rhs) {
    bool retval = true;
    retval = algo::cstring_Eq(lhs.novs, rhs.novs);
    if (!retval) {
        return false;
    }
    retval = algo::cstring_Eq(lhs.vs, rhs.vs);
    return retval;
}

// --- atf_amc.SortedStr..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::SortedStr_Update(atf_amc::SortedStr &lhs, atf_amc::SortedStr & rhs) {
    bool ret = !SortedStr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::SsimfilesCase::SsimfilesCase(u32                            in_value)
    : value(in_value)
{
}
inline atf_amc::SsimfilesCase::SsimfilesCase(atf_amc_SsimfilesCaseEnum arg) { this->value = u32(arg); }
inline atf_amc::SsimfilesCase::SsimfilesCase() {
    atf_amc::SsimfilesCase_Init(*this);
}


// --- atf_amc.SsimfilesCase.value.GetEnum
// Get value of field as enum type
inline atf_amc_SsimfilesCaseEnum atf_amc::value_GetEnum(const atf_amc::SsimfilesCase& parent) {
    return atf_amc_SsimfilesCaseEnum(parent.value);
}

// --- atf_amc.SsimfilesCase.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::SsimfilesCase& parent, atf_amc_SsimfilesCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- atf_amc.SsimfilesCase.value.Cast
inline atf_amc::SsimfilesCase::operator atf_amc_SsimfilesCaseEnum () const {
    return atf_amc_SsimfilesCaseEnum((*this).value);
}

// --- atf_amc.SsimfilesCase..Init
// Set all fields to initial values.
inline void atf_amc::SsimfilesCase_Init(atf_amc::SsimfilesCase& parent) {
    parent.value = u32(0);
}
inline atf_amc::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline atf_amc::TableId::TableId(atf_amc_TableIdEnum arg) { this->value = i32(arg); }
inline atf_amc::TableId::TableId() {
    atf_amc::TableId_Init(*this);
}


// --- atf_amc.TableId.value.GetEnum
// Get value of field as enum type
inline atf_amc_TableIdEnum atf_amc::value_GetEnum(const atf_amc::TableId& parent) {
    return atf_amc_TableIdEnum(parent.value);
}

// --- atf_amc.TableId.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::TableId& parent, atf_amc_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- atf_amc.TableId.value.Cast
inline atf_amc::TableId::operator atf_amc_TableIdEnum () const {
    return atf_amc_TableIdEnum((*this).value);
}

// --- atf_amc.TableId..Init
// Set all fields to initial values.
inline void atf_amc::TableId_Init(atf_amc::TableId& parent) {
    parent.value = i32(-1);
}
inline atf_amc::TaryU32::TaryU32() {
    atf_amc::TaryU32_Init(*this);
}

inline atf_amc::TaryU32::~TaryU32() {
    atf_amc::TaryU32_Uninit(*this);
}


// --- atf_amc.TaryU32.tary_u32.EmptyQ
// Return true if index is empty
inline bool atf_amc::tary_u32_EmptyQ(atf_amc::TaryU32& parent) {
    return parent.tary_u32_n == 0;
}

// --- atf_amc.TaryU32.tary_u32.Find
// Look up row by row id. Return NULL if out of range
inline u32* atf_amc::tary_u32_Find(atf_amc::TaryU32& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.tary_u32_n;
    if (idx >= lim) return NULL;
    return parent.tary_u32_elems + idx;
}

// --- atf_amc.TaryU32.tary_u32.Getary
// Return array pointer by value
inline algo::aryptr<u32> atf_amc::tary_u32_Getary(atf_amc::TaryU32& parent) {
    return algo::aryptr<u32>(parent.tary_u32_elems, parent.tary_u32_n);
}

// --- atf_amc.TaryU32.tary_u32.Last
// Return pointer to last element of array, or NULL if array is empty
inline u32* atf_amc::tary_u32_Last(atf_amc::TaryU32& parent) {
    return tary_u32_Find(parent, u64(parent.tary_u32_n-1));
}

// --- atf_amc.TaryU32.tary_u32.Max
// Return max. number of items in the array
inline i32 atf_amc::tary_u32_Max(atf_amc::TaryU32& parent) {
    (void)parent;
    return parent.tary_u32_max;
}

// --- atf_amc.TaryU32.tary_u32.N
// Return number of items in the array
inline i32 atf_amc::tary_u32_N(const atf_amc::TaryU32& parent) {
    return parent.tary_u32_n;
}

// --- atf_amc.TaryU32.tary_u32.RemoveAll
inline void atf_amc::tary_u32_RemoveAll(atf_amc::TaryU32& parent) {
    parent.tary_u32_n = 0;
}

// --- atf_amc.TaryU32.tary_u32.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_amc::tary_u32_Reserve(atf_amc::TaryU32& parent, int n) {
    u32 new_n = parent.tary_u32_n + n;
    if (UNLIKELY(new_n > parent.tary_u32_max)) {
        tary_u32_AbsReserve(parent, new_n);
    }
}

// --- atf_amc.TaryU32.tary_u32.qFind
// 'quick' Access row by row id. No bounds checking.
inline u32& atf_amc::tary_u32_qFind(atf_amc::TaryU32& parent, u64 t) {
    return parent.tary_u32_elems[t];
}

// --- atf_amc.TaryU32.tary_u32.qLast
// Return reference to last element of array. No bounds checking
inline u32& atf_amc::tary_u32_qLast(atf_amc::TaryU32& parent) {
    return tary_u32_qFind(parent, u64(parent.tary_u32_n-1));
}

// --- atf_amc.TaryU32.tary_u32.rowid_Get
// Return row id of specified element
inline u64 atf_amc::tary_u32_rowid_Get(atf_amc::TaryU32& parent, u32 &elem) {
    u64 id = &elem - parent.tary_u32_elems;
    return u64(id);
}

// --- atf_amc.TaryU32.tary_u32_curs.Next
// proceed to next item
inline void atf_amc::TaryU32_tary_u32_curs_Next(TaryU32_tary_u32_curs &curs) {
    curs.index++;
}

// --- atf_amc.TaryU32.tary_u32_curs.Reset
inline void atf_amc::TaryU32_tary_u32_curs_Reset(TaryU32_tary_u32_curs &curs, atf_amc::TaryU32 &parent) {
    curs.elems = parent.tary_u32_elems;
    curs.n_elems = parent.tary_u32_n;
    curs.index = 0;
}

// --- atf_amc.TaryU32.tary_u32_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::TaryU32_tary_u32_curs_ValidQ(TaryU32_tary_u32_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.TaryU32.tary_u32_curs.Access
// item access
inline u32& atf_amc::TaryU32_tary_u32_curs_Access(TaryU32_tary_u32_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_amc.TaryU32..Init
// Set all fields to initial values.
inline void atf_amc::TaryU32_Init(atf_amc::TaryU32& parent) {
    parent.tary_u32_elems 	= 0; // (atf_amc.TaryU32.tary_u32)
    parent.tary_u32_n     	= 0; // (atf_amc.TaryU32.tary_u32)
    parent.tary_u32_max   	= 0; // (atf_amc.TaryU32.tary_u32)
}
inline atf_amc::TaryU8::TaryU8() {
    atf_amc::TaryU8_Init(*this);
}

inline atf_amc::TaryU8::~TaryU8() {
    atf_amc::TaryU8_Uninit(*this);
}


// --- atf_amc.TaryU8.ary.EmptyQ
// Return true if index is empty
inline bool atf_amc::ary_EmptyQ(atf_amc::TaryU8& parent) {
    return parent.ary_n == 0;
}

// --- atf_amc.TaryU8.ary.Find
// Look up row by row id. Return NULL if out of range
inline u8* atf_amc::ary_Find(atf_amc::TaryU8& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- atf_amc.TaryU8.ary.Getary
// Return array pointer by value
inline algo::aryptr<u8> atf_amc::ary_Getary(atf_amc::TaryU8& parent) {
    return algo::aryptr<u8>(parent.ary_elems, parent.ary_n);
}

// --- atf_amc.TaryU8.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* atf_amc::ary_Last(atf_amc::TaryU8& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- atf_amc.TaryU8.ary.Max
// Return max. number of items in the array
inline i32 atf_amc::ary_Max(atf_amc::TaryU8& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- atf_amc.TaryU8.ary.N
// Return number of items in the array
inline i32 atf_amc::ary_N(const atf_amc::TaryU8& parent) {
    return parent.ary_n;
}

// --- atf_amc.TaryU8.ary.RemoveAll
inline void atf_amc::ary_RemoveAll(atf_amc::TaryU8& parent) {
    parent.ary_n = 0;
}

// --- atf_amc.TaryU8.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_amc::ary_Reserve(atf_amc::TaryU8& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- atf_amc.TaryU8.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& atf_amc::ary_qFind(atf_amc::TaryU8& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- atf_amc.TaryU8.ary.qLast
// Return reference to last element of array. No bounds checking
inline u8& atf_amc::ary_qLast(atf_amc::TaryU8& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- atf_amc.TaryU8.ary.rowid_Get
// Return row id of specified element
inline u64 atf_amc::ary_rowid_Get(atf_amc::TaryU8& parent, u8 &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- atf_amc.TaryU8.ary_curs.Next
// proceed to next item
inline void atf_amc::TaryU8_ary_curs_Next(TaryU8_ary_curs &curs) {
    curs.index++;
}

// --- atf_amc.TaryU8.ary_curs.Reset
inline void atf_amc::TaryU8_ary_curs_Reset(TaryU8_ary_curs &curs, atf_amc::TaryU8 &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- atf_amc.TaryU8.ary_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::TaryU8_ary_curs_ValidQ(TaryU8_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_amc.TaryU8.ary_curs.Access
// item access
inline u8& atf_amc::TaryU8_ary_curs_Access(TaryU8_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_amc.TaryU8..Init
// Set all fields to initial values.
inline void atf_amc::TaryU8_Init(atf_amc::TaryU8& parent) {
    parent.ary_elems 	= 0; // (atf_amc.TaryU8.ary)
    parent.ary_n     	= 0; // (atf_amc.TaryU8.ary)
    parent.ary_max   	= 0; // (atf_amc.TaryU8.ary)
}
inline atf_amc::TestRegx1::TestRegx1() {
}

inline atf_amc::TestType::TestType() {
}

inline atf_amc::Text::Text() {
    atf_amc::Text_Init(*this);
}


// --- atf_amc.Text.msghdr.Castdown
// Check if atf_amc::MsgHeader is an instance of Text by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Text.
// If not successful, quietly return NULL.
inline atf_amc::Text* atf_amc::Text_Castdown(atf_amc::MsgHeader &hdr) {
    bool cond = hdr.type == (0x0412);
    cond &= i32(hdr.length) >= ssizeof(atf_amc::Text);
    return cond ? reinterpret_cast<atf_amc::Text*>(&hdr) : NULL;
}

// --- atf_amc.Text.msghdr.Castbase
inline atf_amc::MsgHeader& atf_amc::Castbase(atf_amc::Text& parent) {
    return reinterpret_cast<atf_amc::MsgHeader&>(parent);
}

// --- atf_amc.Text.text.N
// Return number of elements in varlen field
inline u32 atf_amc::text_N(const atf_amc::Text& parent) {
    u32 length = i32(((atf_amc::Text&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(atf_amc::Text)) - sizeof(atf_amc::Text); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- atf_amc.Text.text_curs.Reset
inline void atf_amc::Text_text_curs_Reset(Text_text_curs &curs, atf_amc::Text &parent) {
    curs.ptr = (u8*)&parent + sizeof(atf_amc::Text);
    curs.length = i32(parent.length) - sizeof(atf_amc::Text);
    curs.index = 0;
}

// --- atf_amc.Text.text_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::Text_text_curs_ValidQ(Text_text_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- atf_amc.Text.text_curs.Next
// proceed to next item
inline void atf_amc::Text_text_curs_Next(Text_text_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- atf_amc.Text.text_curs.Access
// item access
inline char& atf_amc::Text_text_curs_Access(Text_text_curs &curs) {
    return *(char*)curs.ptr;
}

// --- atf_amc.Text..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::Text& row) {
    return i32(const_cast<atf_amc::Text&>(row).length);
}

// --- atf_amc.Text..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::Text& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::Text&>(row).length));
}

// --- atf_amc.Text..Init
// Set all fields to initial values.
inline void atf_amc::Text_Init(atf_amc::Text& parent) {
    parent.type = atf_amc_MsgTypeEnum(0x0412);
    parent.length = atf_amc::MsgLength(ssizeof(parent) + (0));
}

inline bool atf_amc::TypeB::operator ==(const atf_amc::TypeB &rhs) const {
    return atf_amc::TypeB_Eq(const_cast<atf_amc::TypeB&>(*this),const_cast<atf_amc::TypeB&>(rhs));
}

inline bool atf_amc::TypeB::operator !=(const atf_amc::TypeB &rhs) const {
    return !atf_amc::TypeB_Eq(const_cast<atf_amc::TypeB&>(*this),const_cast<atf_amc::TypeB&>(rhs));
}

inline bool atf_amc::TypeB::operator <(const atf_amc::TypeB &rhs) const {
    return atf_amc::TypeB_Lt(const_cast<atf_amc::TypeB&>(*this),const_cast<atf_amc::TypeB&>(rhs));
}

inline bool atf_amc::TypeB::operator >(const atf_amc::TypeB &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::TypeB::operator <=(const atf_amc::TypeB &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::TypeB::operator >=(const atf_amc::TypeB &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::TypeB::TypeB() {
    atf_amc::TypeB_Init(*this);
}


// --- atf_amc.TypeB..Hash
inline u32 atf_amc::TypeB_Hash(u32 prev, const atf_amc::TypeB & rhs) {
    prev = i32_Hash(prev, rhs.typea);
    prev = i32_Hash(prev, rhs.j);
    return prev;
}

// --- atf_amc.TypeB..Lt
inline bool atf_amc::TypeB_Lt(atf_amc::TypeB & lhs, atf_amc::TypeB & rhs) {
    return TypeB_Cmp(lhs,rhs) < 0;
}

// --- atf_amc.TypeB..Cmp
inline i32 atf_amc::TypeB_Cmp(atf_amc::TypeB & lhs, atf_amc::TypeB & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typea, rhs.typea);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.j, rhs.j);
    return retval;
}

// --- atf_amc.TypeB..Init
// Set all fields to initial values.
inline void atf_amc::TypeB_Init(atf_amc::TypeB& parent) {
    parent.typea = i32(0);
    parent.j = i32(0);
}

// --- atf_amc.TypeB..Eq
inline bool atf_amc::TypeB_Eq(const atf_amc::TypeB & lhs,const atf_amc::TypeB & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typea, rhs.typea);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.j, rhs.j);
    return retval;
}

// --- atf_amc.TypeB..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::TypeB_Update(atf_amc::TypeB &lhs, atf_amc::TypeB & rhs) {
    bool ret = !TypeB_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::TypeBE16::TypeBE16() {
    atf_amc::TypeBE16_Init(*this);
}


// --- atf_amc.TypeBE16.value.Get
inline u16 atf_amc::value_Get(const atf_amc::TypeBE16& parent) {
    return be16toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.TypeBE16.value.Set
inline void atf_amc::value_Set(atf_amc::TypeBE16& parent, u16 rhs) {
    parent.value_be = htobe16(rhs); // write big-endian value to memory
}

// --- atf_amc.TypeBE16..Init
// Set all fields to initial values.
inline void atf_amc::TypeBE16_Init(atf_amc::TypeBE16& parent) {
    parent.value_be = htobe16(0); // write big-endian value to memory
}
inline atf_amc::TypeBE32::TypeBE32() {
    atf_amc::TypeBE32_Init(*this);
}


// --- atf_amc.TypeBE32.value.Get
inline u32 atf_amc::value_Get(const atf_amc::TypeBE32& parent) {
    return be32toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.TypeBE32.value.Set
inline void atf_amc::value_Set(atf_amc::TypeBE32& parent, u32 rhs) {
    parent.value_be = htobe32(rhs); // write big-endian value to memory
}

// --- atf_amc.TypeBE32..Init
// Set all fields to initial values.
inline void atf_amc::TypeBE32_Init(atf_amc::TypeBE32& parent) {
    parent.value_be = htobe32(0); // write big-endian value to memory
}
inline atf_amc::TypeBE32en::TypeBE32en(u32                            in_value)
{
    value_Set(*this,in_value);
}
inline atf_amc::TypeBE32en::TypeBE32en(atf_amc_TypeBE32en_value_Enum arg) { value_Set(*this, u32(arg)); }
inline atf_amc::TypeBE32en::TypeBE32en() {
    atf_amc::TypeBE32en_Init(*this);
}


// --- atf_amc.TypeBE32en.value.Get
inline u32 atf_amc::value_Get(const atf_amc::TypeBE32en& parent) {
    return be32toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.TypeBE32en.value.Set
inline void atf_amc::value_Set(atf_amc::TypeBE32en& parent, u32 rhs) {
    parent.value_be = htobe32(rhs); // write big-endian value to memory
}

// --- atf_amc.TypeBE32en.value.GetEnum
// Get value of field as enum type
inline atf_amc_TypeBE32en_value_Enum atf_amc::value_GetEnum(const atf_amc::TypeBE32en& parent) {
    return atf_amc_TypeBE32en_value_Enum(value_Get(parent));
}

// --- atf_amc.TypeBE32en.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::TypeBE32en& parent, atf_amc_TypeBE32en_value_Enum rhs) {
    value_Set(parent, u32(rhs));
}

// --- atf_amc.TypeBE32en.value.Cast
inline atf_amc::TypeBE32en::operator atf_amc_TypeBE32en_value_Enum () const {
    return atf_amc_TypeBE32en_value_Enum(value_Get((*this)));
}

// --- atf_amc.TypeBE32en..Hash
inline u32 atf_amc::TypeBE32en_Hash(u32 prev, const atf_amc::TypeBE32en & rhs) {
    prev = u32_Hash(prev, value_Get(rhs));
    return prev;
}

// --- atf_amc.TypeBE32en..Init
// Set all fields to initial values.
inline void atf_amc::TypeBE32en_Init(atf_amc::TypeBE32en& parent) {
    parent.value_be = htobe32(0); // write big-endian value to memory
}
inline atf_amc::TypeBE64::TypeBE64(u64                            in_value)
{
    value_Set(*this,in_value);
}

inline bool atf_amc::TypeBE64::operator ==(const atf_amc::TypeBE64 &rhs) const {
    return atf_amc::TypeBE64_Eq(const_cast<atf_amc::TypeBE64&>(*this),const_cast<atf_amc::TypeBE64&>(rhs));
}

inline bool atf_amc::TypeBE64::operator !=(const atf_amc::TypeBE64 &rhs) const {
    return !atf_amc::TypeBE64_Eq(const_cast<atf_amc::TypeBE64&>(*this),const_cast<atf_amc::TypeBE64&>(rhs));
}

inline bool atf_amc::TypeBE64::operator <(const atf_amc::TypeBE64 &rhs) const {
    return atf_amc::TypeBE64_Lt(const_cast<atf_amc::TypeBE64&>(*this),const_cast<atf_amc::TypeBE64&>(rhs));
}

inline bool atf_amc::TypeBE64::operator >(const atf_amc::TypeBE64 &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::TypeBE64::operator <=(const atf_amc::TypeBE64 &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::TypeBE64::operator >=(const atf_amc::TypeBE64 &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::TypeBE64::TypeBE64() {
    atf_amc::TypeBE64_Init(*this);
}


// --- atf_amc.TypeBE64.value.Get
inline u64 atf_amc::value_Get(const atf_amc::TypeBE64& parent) {
    return be64toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.TypeBE64.value.Set
inline void atf_amc::value_Set(atf_amc::TypeBE64& parent, u64 rhs) {
    parent.value_be = htobe64(rhs); // write big-endian value to memory
}

// --- atf_amc.TypeBE64.value.Cast
inline atf_amc::TypeBE64::operator u64 () const {
    return u64(value_Get((*this)));
}

// --- atf_amc.TypeBE64..Hash
inline u32 atf_amc::TypeBE64_Hash(u32 prev, const atf_amc::TypeBE64 & rhs) {
    prev = u64_Hash(prev, value_Get(rhs));
    return prev;
}

// --- atf_amc.TypeBE64..Lt
inline bool atf_amc::TypeBE64_Lt(atf_amc::TypeBE64 & lhs, atf_amc::TypeBE64 & rhs) {
    return u64_Lt(value_Get(lhs), value_Get(rhs));
}

// --- atf_amc.TypeBE64..Cmp
inline i32 atf_amc::TypeBE64_Cmp(atf_amc::TypeBE64 & lhs, atf_amc::TypeBE64 & rhs) {
    i32 retval = 0;
    retval = u64_Cmp(value_Get(lhs), value_Get(rhs));
    return retval;
}

// --- atf_amc.TypeBE64..Init
// Set all fields to initial values.
inline void atf_amc::TypeBE64_Init(atf_amc::TypeBE64& parent) {
    parent.value_be = htobe64(0); // write big-endian value to memory
}

// --- atf_amc.TypeBE64..Eq
inline bool atf_amc::TypeBE64_Eq(const atf_amc::TypeBE64 & lhs,const atf_amc::TypeBE64 & rhs) {
    bool retval = true;
    retval = u64_Eq(value_Get(lhs), value_Get(rhs));
    return retval;
}

// --- atf_amc.TypeBE64..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::TypeBE64_Update(atf_amc::TypeBE64 &lhs, atf_amc::TypeBE64 & rhs) {
    bool ret = !TypeBE64_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::TypeBE64dflt::TypeBE64dflt(u64                            in_value)
{
    value_Set(*this,in_value);
}
inline atf_amc::TypeBE64dflt::TypeBE64dflt() {
    atf_amc::TypeBE64dflt_Init(*this);
}


// --- atf_amc.TypeBE64dflt.value.Get
inline u64 atf_amc::value_Get(const atf_amc::TypeBE64dflt& parent) {
    return be64toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.TypeBE64dflt.value.Set
inline void atf_amc::value_Set(atf_amc::TypeBE64dflt& parent, u64 rhs) {
    parent.value_be = htobe64(rhs); // write big-endian value to memory
}

// --- atf_amc.TypeBE64dflt.value.Cast
inline atf_amc::TypeBE64dflt::operator u64 () const {
    return u64(value_Get((*this)));
}

// --- atf_amc.TypeBE64dflt..Init
// Set all fields to initial values.
inline void atf_amc::TypeBE64dflt_Init(atf_amc::TypeBE64dflt& parent) {
    parent.value_be = htobe64(0xfedcba9876543210); // write big-endian value to memory
}
inline atf_amc::TypeBE64sf::TypeBE64sf() {
    atf_amc::TypeBE64sf_Init(*this);
}


// --- atf_amc.TypeBE64sf.value.Get
inline u64 atf_amc::value_Get(const atf_amc::TypeBE64sf& parent) {
    return be64toh(parent.value_be); // read big-endian value from memory
}

// --- atf_amc.TypeBE64sf.value.Set
inline void atf_amc::value_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    parent.value_be = htobe64(rhs); // write big-endian value to memory
}

// --- atf_amc.TypeBE64sf.bit63.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 63.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bit63_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 63) & 0x01);
}

// --- atf_amc.TypeBE64sf.bit63.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 63.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bit63_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x01) << 63;
    u64 t2    = (u64(rhs) & 0x01) << 63;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits62_61.Get
// Retrieve bitfield from value of field value
//    2 bits starting at bit 61.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits62_61_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 61) & 0x03);
}

// --- atf_amc.TypeBE64sf.bits62_61.Set
// Set bitfield in value of field 'value'
//    2 bits starting at bit 61.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits62_61_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x03) << 61;
    u64 t2    = (u64(rhs) & 0x03) << 61;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits60_58.Get
// Retrieve bitfield from value of field value
//    3 bits starting at bit 58.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits60_58_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 58) & 0x07);
}

// --- atf_amc.TypeBE64sf.bits60_58.Set
// Set bitfield in value of field 'value'
//    3 bits starting at bit 58.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits60_58_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x07) << 58;
    u64 t2    = (u64(rhs) & 0x07) << 58;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits57_53.Get
// Retrieve bitfield from value of field value
//    5 bits starting at bit 53.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits57_53_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 53) & 0x1f);
}

// --- atf_amc.TypeBE64sf.bits57_53.Set
// Set bitfield in value of field 'value'
//    5 bits starting at bit 53.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits57_53_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x1f) << 53;
    u64 t2    = (u64(rhs) & 0x1f) << 53;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits52_45.Get
// Retrieve bitfield from value of field value
//    8 bits starting at bit 45.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits52_45_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 45) & 0xff);
}

// --- atf_amc.TypeBE64sf.bits52_45.Set
// Set bitfield in value of field 'value'
//    8 bits starting at bit 45.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits52_45_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0xff) << 45;
    u64 t2    = (u64(rhs) & 0xff) << 45;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits44_32.Get
// Retrieve bitfield from value of field value
//    13 bits starting at bit 32.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits44_32_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 32) & 0x1fff);
}

// --- atf_amc.TypeBE64sf.bits44_32.Set
// Set bitfield in value of field 'value'
//    13 bits starting at bit 32.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits44_32_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x1fff) << 32;
    u64 t2    = (u64(rhs) & 0x1fff) << 32;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits31_11.Get
// Retrieve bitfield from value of field value
//    21 bits starting at bit 11.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits31_11_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 11) & 0x1fffff);
}

// --- atf_amc.TypeBE64sf.bits31_11.Set
// Set bitfield in value of field 'value'
//    21 bits starting at bit 11.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits31_11_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x1fffff) << 11;
    u64 t2    = (u64(rhs) & 0x1fffff) << 11;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf.bits10_0.Get
// Retrieve bitfield from value of field value
//    11 bits starting at bit 0.
//    NOTE: bits correspond to the the integer value of the field.
//    The value is obtained by reading bytes from memory and swapping them.
inline u64 atf_amc::bits10_0_Get(const atf_amc::TypeBE64sf& parent) {
    return u64((value_Get(parent) >> 0) & 0x7ff);
}

// --- atf_amc.TypeBE64sf.bits10_0.Set
// Set bitfield in value of field 'value'
//    11 bits starting at bit 0.
//    NOTE: bits correspond to the integer value of 'value'.
//    value is stored in memory as big-endian.
//    The value is obtained by reading bytes from memory and swapping them.
inline void atf_amc::bits10_0_Set(atf_amc::TypeBE64sf& parent, u64 rhs) {
    u64 t1    = u64(0x7ff) << 0;
    u64 t2    = (u64(rhs) & 0x7ff) << 0;
    value_Set(parent, u64((value_Get(parent) & ~t1) | t2));
}

// --- atf_amc.TypeBE64sf..Init
// Set all fields to initial values.
inline void atf_amc::TypeBE64sf_Init(atf_amc::TypeBE64sf& parent) {
    parent.value_be = htobe64(0); // write big-endian value to memory
}

inline bool atf_amc::TypeC::operator ==(const atf_amc::TypeC &rhs) const {
    return atf_amc::TypeC_Eq(const_cast<atf_amc::TypeC&>(*this),const_cast<atf_amc::TypeC&>(rhs));
}

inline bool atf_amc::TypeC::operator !=(const atf_amc::TypeC &rhs) const {
    return !atf_amc::TypeC_Eq(const_cast<atf_amc::TypeC&>(*this),const_cast<atf_amc::TypeC&>(rhs));
}

inline bool atf_amc::TypeC::operator <(const atf_amc::TypeC &rhs) const {
    return atf_amc::TypeC_Lt(const_cast<atf_amc::TypeC&>(*this),const_cast<atf_amc::TypeC&>(rhs));
}

inline bool atf_amc::TypeC::operator >(const atf_amc::TypeC &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::TypeC::operator <=(const atf_amc::TypeC &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::TypeC::operator >=(const atf_amc::TypeC &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::TypeC::TypeC() {
    atf_amc::TypeC_Init(*this);
}


// --- atf_amc.TypeC..Hash
inline u32 atf_amc::TypeC_Hash(u32 prev, const atf_amc::TypeC & rhs) {
    prev = i32_Hash(prev, rhs.typec);
    return prev;
}

// --- atf_amc.TypeC..Lt
inline bool atf_amc::TypeC_Lt(atf_amc::TypeC & lhs, atf_amc::TypeC & rhs) {
    return i32_Lt(lhs.typec, rhs.typec);
}

// --- atf_amc.TypeC..Cmp
inline i32 atf_amc::TypeC_Cmp(atf_amc::TypeC & lhs, atf_amc::TypeC & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typec, rhs.typec);
    return retval;
}

// --- atf_amc.TypeC..Init
// Set all fields to initial values.
inline void atf_amc::TypeC_Init(atf_amc::TypeC& parent) {
    parent.typec = i32(0);
}

// --- atf_amc.TypeC..Eq
inline bool atf_amc::TypeC_Eq(const atf_amc::TypeC & lhs,const atf_amc::TypeC & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typec, rhs.typec);
    return retval;
}

// --- atf_amc.TypeC..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::TypeC_Update(atf_amc::TypeC &lhs, atf_amc::TypeC & rhs) {
    bool ret = !TypeC_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline bool atf_amc::TypeH::operator ==(const atf_amc::TypeH &rhs) const {
    return atf_amc::TypeH_Eq(const_cast<atf_amc::TypeH&>(*this),const_cast<atf_amc::TypeH&>(rhs));
}

inline bool atf_amc::TypeH::operator !=(const atf_amc::TypeH &rhs) const {
    return !atf_amc::TypeH_Eq(const_cast<atf_amc::TypeH&>(*this),const_cast<atf_amc::TypeH&>(rhs));
}

inline bool atf_amc::TypeH::operator <(const atf_amc::TypeH &rhs) const {
    return atf_amc::TypeH_Lt(const_cast<atf_amc::TypeH&>(*this),const_cast<atf_amc::TypeH&>(rhs));
}

inline bool atf_amc::TypeH::operator >(const atf_amc::TypeH &rhs) const {
    return rhs < *this;
}

inline bool atf_amc::TypeH::operator <=(const atf_amc::TypeH &rhs) const {
    return !(rhs < *this);
}

inline bool atf_amc::TypeH::operator >=(const atf_amc::TypeH &rhs) const {
    return !(*this < rhs);
}
inline atf_amc::TypeH::TypeH() {
    atf_amc::TypeH_Init(*this);
}


// --- atf_amc.TypeH..Hash
inline u32 atf_amc::TypeH_Hash(u32 prev, const atf_amc::TypeH & rhs) {
    prev = i32_Hash(prev, rhs.typeh);
    return prev;
}

// --- atf_amc.TypeH..Lt
inline bool atf_amc::TypeH_Lt(atf_amc::TypeH & lhs, atf_amc::TypeH & rhs) {
    return i32_Lt(lhs.typeh, rhs.typeh);
}

// --- atf_amc.TypeH..Cmp
inline i32 atf_amc::TypeH_Cmp(atf_amc::TypeH & lhs, atf_amc::TypeH & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typeh, rhs.typeh);
    return retval;
}

// --- atf_amc.TypeH..Init
// Set all fields to initial values.
inline void atf_amc::TypeH_Init(atf_amc::TypeH& typeh) {
    typeh.typeh = i32(0);
}

// --- atf_amc.TypeH..Eq
inline bool atf_amc::TypeH_Eq(const atf_amc::TypeH & lhs,const atf_amc::TypeH & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typeh, rhs.typeh);
    return retval;
}

// --- atf_amc.TypeH..Update
// Set value. Return true if new value is different from old value.
inline bool atf_amc::TypeH_Update(atf_amc::TypeH &lhs, atf_amc::TypeH & rhs) {
    bool ret = !TypeH_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_amc::TypeS::TypeS() {
    atf_amc::TypeS_Init(*this);
}


// --- atf_amc.TypeS..Init
// Set all fields to initial values.
inline void atf_amc::TypeS_Init(atf_amc::TypeS& parent) {
    parent.types = i32(0);
}
inline atf_amc::TypeT::TypeT() {
    atf_amc::TypeT_Init(*this);
}


// --- atf_amc.TypeT..Hash
inline u32 atf_amc::TypeT_Hash(u32 prev, const atf_amc::TypeT & rhs) {
    prev = i32_Hash(prev, rhs.types);
    prev = i32_Hash(prev, rhs.j);
    return prev;
}

// --- atf_amc.TypeT..Init
// Set all fields to initial values.
inline void atf_amc::TypeT_Init(atf_amc::TypeT& parent) {
    parent.types = i32(0);
    parent.j = i32(0);
}
inline atf_amc::Typefconst::Typefconst(u32                            in_value)
    : value(in_value)
{
}
inline atf_amc::Typefconst::Typefconst(atf_amc_Typefconst_value_Enum arg) { this->value = u32(arg); }
inline atf_amc::Typefconst::Typefconst() {
    atf_amc::Typefconst_Init(*this);
}


// --- atf_amc.Typefconst.value.GetEnum
// Get value of field as enum type
inline atf_amc_Typefconst_value_Enum atf_amc::value_GetEnum(const atf_amc::Typefconst& parent) {
    return atf_amc_Typefconst_value_Enum(parent.value);
}

// --- atf_amc.Typefconst.value.SetEnum
// Set value of field from enum type.
inline void atf_amc::value_SetEnum(atf_amc::Typefconst& parent, atf_amc_Typefconst_value_Enum rhs) {
    parent.value = u32(rhs);
}

// --- atf_amc.Typefconst.value.Cast
inline atf_amc::Typefconst::operator atf_amc_Typefconst_value_Enum () const {
    return atf_amc_Typefconst_value_Enum((*this).value);
}

// --- atf_amc.Typefconst..Init
// Set all fields to initial values.
inline void atf_amc::Typefconst_Init(atf_amc::Typefconst& parent) {
    parent.value = u32(0);
}
inline atf_amc::VarlenAlloc::VarlenAlloc() {
    atf_amc::VarlenAlloc_Init(*this);
}


// --- atf_amc.VarlenAlloc.elem.N
// Return number of elements in varlen field
inline u32 atf_amc::elem_N(const atf_amc::VarlenAlloc& varlenalloc) {
    u32 length = i32(((atf_amc::VarlenAlloc&)varlenalloc).length);
    u32 extra_bytes = u32_Max(length,sizeof(atf_amc::VarlenAlloc)) - sizeof(atf_amc::VarlenAlloc); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(i32));
}

// --- atf_amc.VarlenAlloc.elem_curs.Reset
inline void atf_amc::varlenalloc_elem_curs_Reset(varlenalloc_elem_curs &curs, atf_amc::VarlenAlloc &parent) {
    curs.ptr = (u8*)&parent + sizeof(atf_amc::VarlenAlloc);
    curs.length = i32(parent.length) - sizeof(atf_amc::VarlenAlloc);
    curs.index = 0;
}

// --- atf_amc.VarlenAlloc.elem_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::varlenalloc_elem_curs_ValidQ(varlenalloc_elem_curs &curs) {
    bool valid = ssizeof(i32) <= curs.length;
    return valid;
}

// --- atf_amc.VarlenAlloc.elem_curs.Next
// proceed to next item
inline void atf_amc::varlenalloc_elem_curs_Next(varlenalloc_elem_curs &curs) {
    i32 len = i32(sizeof(i32));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- atf_amc.VarlenAlloc.elem_curs.Access
// item access
inline i32& atf_amc::varlenalloc_elem_curs_Access(varlenalloc_elem_curs &curs) {
    return *(i32*)curs.ptr;
}

// --- atf_amc.VarlenAlloc..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::VarlenAlloc& row) {
    return i32(const_cast<atf_amc::VarlenAlloc&>(row).length);
}

// --- atf_amc.VarlenAlloc..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::VarlenAlloc& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::VarlenAlloc&>(row).length));
}

// --- atf_amc.VarlenAlloc..Init
// Set all fields to initial values.
inline void atf_amc::VarlenAlloc_Init(atf_amc::VarlenAlloc& varlenalloc) {
    varlenalloc.length = u32(0);
}
inline atf_amc::VarlenExtern::VarlenExtern() {
    atf_amc::VarlenExtern_Init(*this);
}


// --- atf_amc.VarlenExtern.varlen.N
// Return number of elements in varlen field
inline u32 atf_amc::varlen_N(const atf_amc::VarlenExtern& varlen_extern) {
    u32 length = i32(length_Get(((atf_amc::VarlenExtern&)varlen_extern)));
    u32 extra_bytes = u32_Max(length,sizeof(atf_amc::VarlenExtern)) - sizeof(atf_amc::VarlenExtern); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u32));
}

// --- atf_amc.VarlenExtern.varlen_curs.Reset
inline void atf_amc::varlen_extern_varlen_curs_Reset(varlen_extern_varlen_curs &curs, atf_amc::VarlenExtern &parent) {
    curs.ptr = (u8*)&parent + sizeof(atf_amc::VarlenExtern);
    curs.length = i32(length_Get(parent)) - sizeof(atf_amc::VarlenExtern);
    curs.index = 0;
}

// --- atf_amc.VarlenExtern.varlen_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::varlen_extern_varlen_curs_ValidQ(varlen_extern_varlen_curs &curs) {
    bool valid = ssizeof(u32) <= curs.length;
    return valid;
}

// --- atf_amc.VarlenExtern.varlen_curs.Next
// proceed to next item
inline void atf_amc::varlen_extern_varlen_curs_Next(varlen_extern_varlen_curs &curs) {
    i32 len = i32(sizeof(u32));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- atf_amc.VarlenExtern.varlen_curs.Access
// item access
inline u32& atf_amc::varlen_extern_varlen_curs_Access(varlen_extern_varlen_curs &curs) {
    return *(u32*)curs.ptr;
}

// --- atf_amc.VarlenExtern..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::VarlenExtern& row) {
    return i32(length_Get(const_cast<atf_amc::VarlenExtern&>(row)));
}

// --- atf_amc.VarlenExtern..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::VarlenExtern& row) {
    return algo::memptr((u8*)&row, i32(length_Get(const_cast<atf_amc::VarlenExtern&>(row))));
}

// --- atf_amc.VarlenExtern..Init
// Set all fields to initial values.
inline void atf_amc::VarlenExtern_Init(atf_amc::VarlenExtern& varlen_extern) {
    varlen_extern.n_elems = u32(0);
}
inline atf_amc::VarlenH::VarlenH() {
    atf_amc::VarlenH_Init(*this);
}


// --- atf_amc.VarlenH.typeh.N
// Return number of elements in varlen field
inline u32 atf_amc::typeh_N(const atf_amc::VarlenH& parent) {
    u32 length = i32(((atf_amc::VarlenH&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(atf_amc::VarlenH)) - sizeof(atf_amc::VarlenH); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(atf_amc::TypeH));
}

// --- atf_amc.VarlenH.typeh_curs.Reset
inline void atf_amc::VarlenH_typeh_curs_Reset(VarlenH_typeh_curs &curs, atf_amc::VarlenH &parent) {
    curs.ptr = (u8*)&parent + sizeof(atf_amc::VarlenH);
    curs.length = i32(parent.length) - sizeof(atf_amc::VarlenH);
    curs.index = 0;
}

// --- atf_amc.VarlenH.typeh_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::VarlenH_typeh_curs_ValidQ(VarlenH_typeh_curs &curs) {
    bool valid = ssizeof(atf_amc::TypeH) <= curs.length;
    return valid;
}

// --- atf_amc.VarlenH.typeh_curs.Next
// proceed to next item
inline void atf_amc::VarlenH_typeh_curs_Next(VarlenH_typeh_curs &curs) {
    i32 len = i32(sizeof(atf_amc::TypeH));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- atf_amc.VarlenH.typeh_curs.Access
// item access
inline atf_amc::TypeH& atf_amc::VarlenH_typeh_curs_Access(VarlenH_typeh_curs &curs) {
    return *(atf_amc::TypeH*)curs.ptr;
}

// --- atf_amc.VarlenH..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::VarlenH& row) {
    return i32(const_cast<atf_amc::VarlenH&>(row).length);
}

// --- atf_amc.VarlenH..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::VarlenH& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::VarlenH&>(row).length));
}

// --- atf_amc.VarlenH..Init
// Set all fields to initial values.
inline void atf_amc::VarlenH_Init(atf_amc::VarlenH& parent) {
    parent.length = u32(0);
}
inline atf_amc::VarlenK::VarlenK() {
    atf_amc::VarlenK_Init(*this);
}


// --- atf_amc.VarlenK.i.N
// Return number of elements in varlen field
inline u32 atf_amc::i_N(const atf_amc::VarlenK& parent) {
    u32 length = i32(((atf_amc::VarlenK&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(atf_amc::VarlenK)) - sizeof(atf_amc::VarlenK); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(u32));
}

// --- atf_amc.VarlenK.i_curs.Reset
inline void atf_amc::VarlenK_i_curs_Reset(VarlenK_i_curs &curs, atf_amc::VarlenK &parent) {
    curs.ptr = (u8*)&parent + sizeof(atf_amc::VarlenK);
    curs.length = i32(parent.length) - sizeof(atf_amc::VarlenK);
    curs.index = 0;
}

// --- atf_amc.VarlenK.i_curs.ValidQ
// cursor points to valid item
inline bool atf_amc::VarlenK_i_curs_ValidQ(VarlenK_i_curs &curs) {
    bool valid = ssizeof(u32) <= curs.length;
    return valid;
}

// --- atf_amc.VarlenK.i_curs.Next
// proceed to next item
inline void atf_amc::VarlenK_i_curs_Next(VarlenK_i_curs &curs) {
    i32 len = i32(sizeof(u32));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- atf_amc.VarlenK.i_curs.Access
// item access
inline u32& atf_amc::VarlenK_i_curs_Access(VarlenK_i_curs &curs) {
    return *(u32*)curs.ptr;
}

// --- atf_amc.VarlenK..GetMsgLength
// Message length (uses length field)
inline i32 atf_amc::GetMsgLength(const atf_amc::VarlenK& row) {
    return i32(const_cast<atf_amc::VarlenK&>(row).length);
}

// --- atf_amc.VarlenK..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr atf_amc::GetMsgMemptr(const atf_amc::VarlenK& row) {
    return algo::memptr((u8*)&row, i32(const_cast<atf_amc::VarlenK&>(row).length));
}

// --- atf_amc.VarlenK..Init
// Set all fields to initial values.
inline void atf_amc::VarlenK_Init(atf_amc::VarlenK& parent) {
    parent.length = u32(0);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::BitfldType1 &row) {// cfmt:atf_amc.BitfldType1.String
    atf_amc::BitfldType1_Print(const_cast<atf_amc::BitfldType1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::BitfldType2 &row) {// cfmt:atf_amc.BitfldType2.String
    atf_amc::BitfldType2_Print(const_cast<atf_amc::BitfldType2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::Ctype1Attr &row) {// cfmt:atf_amc.Ctype1Attr.String
    atf_amc::Ctype1Attr_Print(const_cast<atf_amc::Ctype1Attr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::Ctype2Attr &row) {// cfmt:atf_amc.Ctype2Attr.String
    atf_amc::Ctype2Attr_Print(const_cast<atf_amc::Ctype2Attr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::trace &row) {// cfmt:atf_amc.trace.String
    atf_amc::trace_Print(const_cast<atf_amc::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::TypeG &row) {// cfmt:atf_amc.TypeG.String
    atf_amc::TypeG_Print(const_cast<atf_amc::TypeG&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::FieldId &row) {// cfmt:atf_amc.FieldId.String
    atf_amc::FieldId_Print(const_cast<atf_amc::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgHdrLT &row) {// cfmt:atf_amc.MsgHdrLT.String
    atf_amc::MsgHdrLT_Print(const_cast<atf_amc::MsgHdrLT&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgType &row) {// cfmt:atf_amc.MsgType.String
    atf_amc::MsgType_Print(const_cast<atf_amc::MsgType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgLength &row) {// cfmt:atf_amc.MsgLength.String
    atf_amc::MsgLength_Print(const_cast<atf_amc::MsgLength&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgHeader &row) {// cfmt:atf_amc.MsgHeader.String
    atf_amc::MsgHeader_Print(const_cast<atf_amc::MsgHeader&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgLTA &row) {// cfmt:atf_amc.MsgLTA.String
    atf_amc::MsgLTA_Print(const_cast<atf_amc::MsgLTA&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgLTB &row) {// cfmt:atf_amc.MsgLTB.String
    atf_amc::MsgLTB_Print(const_cast<atf_amc::MsgLTB&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgLTO &row) {// cfmt:atf_amc.MsgLTO.String
    atf_amc::MsgLTO_Print(const_cast<atf_amc::MsgLTO&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::MsgLTV &row) {// cfmt:atf_amc.MsgLTV.String
    atf_amc::MsgLTV_Print(const_cast<atf_amc::MsgLTV&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::OptAlloc &row) {// cfmt:atf_amc.OptAlloc.String
    atf_amc::OptAlloc_Print(const_cast<atf_amc::OptAlloc&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::OptG &row) {// cfmt:atf_amc.OptG.String
    atf_amc::OptG_Print(const_cast<atf_amc::OptG&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::OptOptG &row) {// cfmt:atf_amc.OptOptG.String
    atf_amc::OptOptG_Print(const_cast<atf_amc::OptOptG&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::PooledBE64 &row) {// cfmt:atf_amc.PooledBE64.String
    atf_amc::PooledBE64_Print(const_cast<atf_amc::PooledBE64&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::Sep1 &row) {// cfmt:atf_amc.Sep1.String
    atf_amc::Sep1_Print(const_cast<atf_amc::Sep1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::Seqmsg &row) {// cfmt:atf_amc.Seqmsg.String
    atf_amc::Seqmsg_Print(const_cast<atf_amc::Seqmsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::TableId &row) {// cfmt:atf_amc.TableId.String
    atf_amc::TableId_Print(const_cast<atf_amc::TableId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::TestRegx1 &row) {// cfmt:atf_amc.TestRegx1.String
    atf_amc::TestRegx1_Print(const_cast<atf_amc::TestRegx1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::TypeBE32en &row) {// cfmt:atf_amc.TypeBE32en.String
    atf_amc::TypeBE32en_Print(const_cast<atf_amc::TypeBE32en&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::TypeBE64 &row) {// cfmt:atf_amc.TypeBE64.String
    atf_amc::TypeBE64_Print(const_cast<atf_amc::TypeBE64&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_amc::Typefconst &row) {// cfmt:atf_amc.Typefconst.String
    atf_amc::Typefconst_Print(const_cast<atf_amc::Typefconst&>(row), str);
    return str;
}
