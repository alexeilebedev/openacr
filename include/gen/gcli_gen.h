//
// include/gen/gcli_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.h"
#include "include/gen/gclidb_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/lib_json_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- gcli_FHttp_request_method_Enum

enum gcli_FHttp_request_method_Enum {         // gcli.FHttp.request_method
     gcli_FHttp_request_method_GET      = 0   // GET
    ,gcli_FHttp_request_method_POST     = 1   // POST
    ,gcli_FHttp_request_method_PUT      = 2   // PUT
    ,gcli_FHttp_request_method_PATCH    = 3   // PATCH
    ,gcli_FHttp_request_method_DELETE   = 4   // DELETE
};

enum { gcli_FHttp_request_method_Enum_N = 5 };


// --- gcli_FieldIdEnum

enum gcli_FieldIdEnum {        // gcli.FieldId.value
     gcli_FieldId_value   = 0
};

enum { gcli_FieldIdEnum_N = 1 };


// --- gcli_TableIdEnum

enum gcli_TableIdEnum {                        // gcli.TableId.value
     gcli_TableId_gclidb_Gact           = 0    // gclidb.Gact -> gcli.FGact
    ,gcli_TableId_gclidb_gact           = 0    // gclidb.gact -> gcli.FGact
    ,gcli_TableId_gclidb_Gclicmdf2j     = 1    // gclidb.Gclicmdf2j -> gcli.FGclicmdf2j
    ,gcli_TableId_gclidb_gclicmdf2j     = 1    // gclidb.gclicmdf2j -> gcli.FGclicmdf2j
    ,gcli_TableId_gclidb_Gclicmdt       = 2    // gclidb.Gclicmdt -> gcli.FGclicmdt
    ,gcli_TableId_gclidb_gclicmdt       = 2    // gclidb.gclicmdt -> gcli.FGclicmdt
    ,gcli_TableId_gclidb_Gfld           = 3    // gclidb.Gfld -> gcli.FGfld
    ,gcli_TableId_gclidb_gfld           = 3    // gclidb.gfld -> gcli.FGfld
    ,gcli_TableId_gclidb_Gmethod        = 4    // gclidb.Gmethod -> gcli.FGmethod
    ,gcli_TableId_gclidb_gmethod        = 4    // gclidb.gmethod -> gcli.FGmethod
    ,gcli_TableId_gclidb_Grepo          = 5    // gclidb.Grepo -> gcli.FGrepo
    ,gcli_TableId_gclidb_grepo          = 5    // gclidb.grepo -> gcli.FGrepo
    ,gcli_TableId_gclidb_Grepogitport   = 6    // gclidb.Grepogitport -> gcli.FGrepogitport
    ,gcli_TableId_gclidb_grepogitport   = 6    // gclidb.grepogitport -> gcli.FGrepogitport
    ,gcli_TableId_gclidb_Grepossh       = 7    // gclidb.Grepossh -> gcli.FGrepossh
    ,gcli_TableId_gclidb_grepossh       = 7    // gclidb.grepossh -> gcli.FGrepossh
    ,gcli_TableId_gclidb_Gstatet        = 8    // gclidb.Gstatet -> gcli.FGstatet
    ,gcli_TableId_gclidb_gstatet        = 8    // gclidb.gstatet -> gcli.FGstatet
    ,gcli_TableId_gclidb_Gtbl           = 9    // gclidb.Gtbl -> gcli.FGtbl
    ,gcli_TableId_gclidb_gtbl           = 9    // gclidb.gtbl -> gcli.FGtbl
    ,gcli_TableId_gclidb_Gtblactfld     = 10   // gclidb.Gtblactfld -> gcli.FGtblactfld
    ,gcli_TableId_gclidb_gtblactfld     = 10   // gclidb.gtblactfld -> gcli.FGtblactfld
    ,gcli_TableId_gclidb_Gtype          = 11   // gclidb.Gtype -> gcli.FGtype
    ,gcli_TableId_gclidb_gtype          = 11   // gclidb.gtype -> gcli.FGtype
    ,gcli_TableId_gclidb_Gtypeh         = 12   // gclidb.Gtypeh -> gcli.FGtypeh
    ,gcli_TableId_gclidb_gtypeh         = 12   // gclidb.gtypeh -> gcli.FGtypeh
    ,gcli_TableId_gclidb_Gtypeprefix    = 13   // gclidb.Gtypeprefix -> gcli.FGtypeprefix
    ,gcli_TableId_gclidb_gtypeprefix    = 13   // gclidb.gtypeprefix -> gcli.FGtypeprefix
};

enum { gcli_TableIdEnum_N = 28 };

namespace gcli { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace gcli { // gen:ns_field
extern const char *gcli_help;
} // gen:ns_field
// gen:ns_fwddecl2
namespace gclidb { struct Gact; }
namespace gclidb { struct Gclicmd; }
namespace gcli { struct FGclicmd; }
namespace gclidb { struct Gclicmdf2j; }
namespace gclidb { struct Gclicmdt; }
namespace gcli { struct FGtype; }
namespace gclidb { struct Gfld; }
namespace gclidb { struct Gmethod; }
namespace gclidb { struct Grepo; }
namespace gclidb { struct Grepogitport; }
namespace gclidb { struct Grepossh; }
namespace gclidb { struct Gstatet; }
namespace gclidb { struct Gtbl; }
namespace gclidb { struct Gtblact; }
namespace gclidb { struct Gtblactfld; }
namespace gcli { struct FGfld; }
namespace gclidb { struct Gtype; }
namespace gclidb { struct Gtypeh; }
namespace gclidb { struct Gtypeprefix; }
namespace gclidb { struct Issue; }
namespace gclidb { struct Issuenote; }
namespace gclidb { struct Milestone; }
namespace gclidb { struct Mr; }
namespace gclidb { struct Mrjob; }
namespace gclidb { struct Mrnote; }
namespace gclidb { struct User; }
namespace gcli { struct _db_gtype_curs; }
namespace gcli { struct _db_grepossh_curs; }
namespace gcli { struct _db_grepogitport_curs; }
namespace gcli { struct _db_githost_curs; }
namespace gcli { struct _db_gstatet_curs; }
namespace gcli { struct _db_gmethod_curs; }
namespace gcli { struct _db_gclicmdt_curs; }
namespace gcli { struct _db_gclicmdf_curs; }
namespace gcli { struct _db_gclicmdf2j_curs; }
namespace gcli { struct _db_gclicmd_curs; }
namespace gcli { struct _db_gtypeh_curs; }
namespace gcli { struct _db_c_gclicmd_curs; }
namespace gcli { struct _db_gclicmdj2f_curs; }
namespace gcli { struct _db_gclicmdc_curs; }
namespace gcli { struct _db_gclicmdarg_curs; }
namespace gcli { struct _db_issue_curs; }
namespace gcli { struct _db_grepo_curs; }
namespace gcli { struct _db_tuples_curs; }
namespace gcli { struct _db_issuenote_curs; }
namespace gcli { struct _db_mrjob_curs; }
namespace gcli { struct _db_mrnote_curs; }
namespace gcli { struct _db_user_curs; }
namespace gcli { struct _db_milestone_curs; }
namespace gcli { struct _db_mr_curs; }
namespace gcli { struct _db_gtypeprefix_curs; }
namespace gcli { struct _db_gtblact_curs; }
namespace gcli { struct _db_gtblactfld_curs; }
namespace gcli { struct _db_zd_gtblact_curs; }
namespace gcli { struct _db_gfld_curs; }
namespace gcli { struct _db_c_gfld_curs; }
namespace gcli { struct _db_gtbl_curs; }
namespace gcli { struct _db_gact_curs; }
namespace gcli { struct gclicmd_c_tuples_curs; }
namespace gcli { struct gclicmd_c_gclicmdarg_curs; }
namespace gcli { struct gclicmd_c_gclicmdc_curs; }
namespace gcli { struct gclicmd_c_gclicmdf2j_curs; }
namespace gcli { struct gclicmdc_c_gclicmdf_curs; }
namespace gcli { struct gclicmdj2f_c_gclicmdf_curs; }
namespace gcli { struct gfld_c_gtblactfld_curs; }
namespace gcli { struct gtbl_c_gtblact_curs; }
namespace gcli { struct gtblact_c_gtblactfld_curs; }
namespace gcli { struct gtype_c_gtypeh_curs; }
namespace gcli { struct gtype_c_gtypeprefix_curs; }
namespace gcli { struct FHttp_response_header_curs; }
namespace gcli { struct issue_c_mrjob_curs; }
namespace gcli { struct issue_c_issuenote_curs; }
namespace gcli { struct mr_c_mrnote_curs; }
namespace gcli { struct mr_c_mrjob_curs; }
namespace gcli { struct trace; }
namespace gcli { struct FDb; }
namespace gcli { struct FGact; }
namespace gcli { struct FGclicmdarg; }
namespace gcli { struct FGclicmdc; }
namespace gcli { struct FGclicmdf; }
namespace gcli { struct FGclicmdf2j; }
namespace gcli { struct FGclicmdj2f; }
namespace gcli { struct FGclicmdt; }
namespace gcli { struct FGithost; }
namespace gcli { struct FGmethod; }
namespace gcli { struct FGrepo; }
namespace gcli { struct FGrepogitport; }
namespace gcli { struct FGrepossh; }
namespace gcli { struct FGstatet; }
namespace gcli { struct FGtbl; }
namespace gcli { struct FGtblact; }
namespace gcli { struct FGtblactfld; }
namespace gcli { struct FGtypeh; }
namespace gcli { struct FGtypeprefix; }
namespace gcli { struct FHttp; }
namespace gcli { struct FIssue; }
namespace gcli { struct FIssuenote; }
namespace gcli { struct FMilestone; }
namespace gcli { struct FMr; }
namespace gcli { struct FMrjob; }
namespace gcli { struct FMrnote; }
namespace gcli { struct FTuples; }
namespace gcli { struct FUser; }
namespace gcli { struct FieldId; }
namespace gcli { struct TableId; }
namespace gcli { extern struct gcli::FDb _db; }
namespace gcli { // hook_fcn_typedef
    typedef void (*gclicmd_step_hook)(gcli::FGclicmd& arg); // hook:gcli.FGclicmd.step
    typedef void (*gtblact_step_hook)(gcli::FGtblact& arg); // hook:gcli.FGtblact.step
} // hook_decl
namespace gcli { // gen:ns_print_struct

// --- gcli.trace
#pragma pack(push,1)
struct trace { // gcli.trace
    trace();
};
#pragma pack(pop)

// print string representation of gcli::trace to string LHS, no header -- cprint:gcli.trace.String
void                 trace_Print(gcli::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- gcli.FDb
// create: gcli.FDb._db (Global)
struct FDb { // gcli.FDb
    command::gcli           cmdline;                          //
    gcli::FGtype*           gtype_lary[32];                   // level array
    i32                     gtype_n;                          // number of elements in array
    gcli::FGrepossh*        grepossh_lary[32];                // level array
    i32                     grepossh_n;                       // number of elements in array
    gcli::FGrepogitport*    grepogitport_lary[32];            // level array
    i32                     grepogitport_n;                   // number of elements in array
    gcli::FGithost*         githost_lary[32];                 // level array
    i32                     githost_n;                        // number of elements in array
    bool                    need_auth;                        //   false
    gcli::FGstatet*         gstatet_lary[32];                 // level array
    i32                     gstatet_n;                        // number of elements in array
    gcli::FGmethod*         gmethod_lary[32];                 // level array
    i32                     gmethod_n;                        // number of elements in array
    gcli::FGclicmdt*        gclicmdt_lary[32];                // level array
    i32                     gclicmdt_n;                       // number of elements in array
    gcli::FGclicmdf*        gclicmdf_lary[32];                // level array
    i32                     gclicmdf_n;                       // number of elements in array
    gcli::FGclicmdf2j*      gclicmdf2j_lary[32];              // level array
    i32                     gclicmdf2j_n;                     // number of elements in array
    gcli::FGclicmd*         gclicmd_lary[32];                 // level array
    i32                     gclicmd_n;                        // number of elements in array
    gcli::FGtypeh*          gtypeh_lary[32];                  // level array
    i32                     gtypeh_n;                         // number of elements in array
    gcli::FGtype*           p_gtype;                          // optional pointer
    gcli::FGtbl*            p_gtbl;                           // optional pointer
    gclidb::Grepo           grepo_sel;                        //
    gcli::FGclicmd**        ind_gclicmd_buckets_elems;        // pointer to bucket array
    i32                     ind_gclicmd_buckets_n;            // number of elements in bucket array
    i32                     ind_gclicmd_n;                    // number of elements in the hash table
    gcli::FGclicmdf**       ind_gclicmdf_buckets_elems;       // pointer to bucket array
    i32                     ind_gclicmdf_buckets_n;           // number of elements in bucket array
    i32                     ind_gclicmdf_n;                   // number of elements in the hash table
    gcli::FGclicmdt**       ind_gclicmdt_buckets_elems;       // pointer to bucket array
    i32                     ind_gclicmdt_buckets_n;           // number of elements in bucket array
    i32                     ind_gclicmdt_n;                   // number of elements in the hash table
    gcli::FGmethod**        ind_gmethod_buckets_elems;        // pointer to bucket array
    i32                     ind_gmethod_buckets_n;            // number of elements in bucket array
    i32                     ind_gmethod_n;                    // number of elements in the hash table
    gcli::FGrepo**          ind_grepo_buckets_elems;          // pointer to bucket array
    i32                     ind_grepo_buckets_n;              // number of elements in bucket array
    i32                     ind_grepo_n;                      // number of elements in the hash table
    gcli::FIssue**          ind_issue_buckets_elems;          // pointer to bucket array
    i32                     ind_issue_buckets_n;              // number of elements in bucket array
    i32                     ind_issue_n;                      // number of elements in the hash table
    algo_lib::Regx          regx_repo;                        //   "%"  Sql Regx
    gcli::FGstatet**        ind_gstatet_buckets_elems;        // pointer to bucket array
    i32                     ind_gstatet_buckets_n;            // number of elements in bucket array
    i32                     ind_gstatet_n;                    // number of elements in the hash table
    gcli::FGithost**        ind_githost_buckets_elems;        // pointer to bucket array
    i32                     ind_githost_buckets_n;            // number of elements in bucket array
    i32                     ind_githost_n;                    // number of elements in the hash table
    gcli::FGrepogitport**   ind_grepogitport_buckets_elems;   // pointer to bucket array
    i32                     ind_grepogitport_buckets_n;       // number of elements in bucket array
    i32                     ind_grepogitport_n;               // number of elements in the hash table
    gcli::FGrepossh**       ind_grepossh_buckets_elems;       // pointer to bucket array
    i32                     ind_grepossh_buckets_n;           // number of elements in bucket array
    i32                     ind_grepossh_n;                   // number of elements in the hash table
    gcli::FGtype**          ind_gtype_buckets_elems;          // pointer to bucket array
    i32                     ind_gtype_buckets_n;              // number of elements in bucket array
    i32                     ind_gtype_n;                      // number of elements in the hash table
    algo::cstring           home;                             // User's HOME directory
    algo::cstring           auth_file;                        //
    algo::cstring           edit_file;                        //
    gcli::FGclicmd**        c_gclicmd_elems;                  // array of pointers
    u32                     c_gclicmd_n;                      // array of pointers
    u32                     c_gclicmd_max;                    // capacity of allocated array
    algo::cstring           unix_user;                        // UNIX user login name
    algo::cstring           editor;                           // Command line to invoke editor
    gcli::FGclicmdj2f*      gclicmdj2f_lary[32];              // level array
    i32                     gclicmdj2f_n;                     // number of elements in array
    gcli::FGclicmdc*        gclicmdc_lary[32];                // level array
    i32                     gclicmdc_n;                       // number of elements in array
    gcli::FGclicmdarg*      gclicmdarg_lary[32];              // level array
    i32                     gclicmdarg_n;                     // number of elements in array
    gcli::FGclicmdj2f**     ind_gclicmdj2f_buckets_elems;     // pointer to bucket array
    i32                     ind_gclicmdj2f_buckets_n;         // number of elements in bucket array
    i32                     ind_gclicmdj2f_n;                 // number of elements in the hash table
    gcli::FGclicmdarg**     ind_gclicmdarg_buckets_elems;     // pointer to bucket array
    i32                     ind_gclicmdarg_buckets_n;         // number of elements in bucket array
    i32                     ind_gclicmdarg_n;                 // number of elements in the hash table
    gcli::FGclicmdc**       ind_gclicmdc_buckets_elems;       // pointer to bucket array
    i32                     ind_gclicmdc_buckets_n;           // number of elements in bucket array
    i32                     ind_gclicmdc_n;                   // number of elements in the hash table
    gcli::FIssue*           issue_lary[32];                   // level array
    i32                     issue_n;                          // number of elements in array
    gcli::FGrepo*           grepo_lary[32];                   // level array
    i32                     grepo_n;                          // number of elements in array
    gcli::FTuples*          tuples_lary[32];                  // level array
    i32                     tuples_n;                         // number of elements in array
    gcli::FIssuenote*       issuenote_lary[32];               // level array
    i32                     issuenote_n;                      // number of elements in array
    gcli::FMrjob*           mrjob_lary[32];                   // level array
    i32                     mrjob_n;                          // number of elements in array
    gcli::FMrnote*          mrnote_lary[32];                  // level array
    i32                     mrnote_n;                         // number of elements in array
    gcli::FMrnote**         ind_mrnote_buckets_elems;         // pointer to bucket array
    i32                     ind_mrnote_buckets_n;             // number of elements in bucket array
    i32                     ind_mrnote_n;                     // number of elements in the hash table
    gcli::FIssuenote**      ind_issuenote_buckets_elems;      // pointer to bucket array
    i32                     ind_issuenote_buckets_n;          // number of elements in bucket array
    i32                     ind_issuenote_n;                  // number of elements in the hash table
    gcli::FMrjob**          ind_mrjob_buckets_elems;          // pointer to bucket array
    i32                     ind_mrjob_buckets_n;              // number of elements in bucket array
    i32                     ind_mrjob_n;                      // number of elements in the hash table
    gcli::FUser*            user_lary[32];                    // level array
    i32                     user_n;                           // number of elements in array
    gcli::FUser**           ind_user_buckets_elems;           // pointer to bucket array
    i32                     ind_user_buckets_n;               // number of elements in bucket array
    i32                     ind_user_n;                       // number of elements in the hash table
    gcli::FMr**             ind_mr_buckets_elems;             // pointer to bucket array
    i32                     ind_mr_buckets_n;                 // number of elements in bucket array
    i32                     ind_mr_n;                         // number of elements in the hash table
    gcli::FMilestone**      ind_milestone_buckets_elems;      // pointer to bucket array
    i32                     ind_milestone_buckets_n;          // number of elements in bucket array
    i32                     ind_milestone_n;                  // number of elements in the hash table
    gcli::FMilestone*       milestone_lary[32];               // level array
    i32                     milestone_n;                      // number of elements in array
    gcli::FMr*              mr_lary[32];                      // level array
    i32                     mr_n;                             // number of elements in array
    gcli::FGtypeprefix*     gtypeprefix_lary[32];             // level array
    i32                     gtypeprefix_n;                    // number of elements in array
    gcli::FGtblact*         gtblact_lary[32];                 // level array
    i32                     gtblact_n;                        // number of elements in array
    gcli::FGtblactfld*      gtblactfld_lary[32];              // level array
    i32                     gtblactfld_n;                     // number of elements in array
    gcli::FGtblact**        ind_gtblact_buckets_elems;        // pointer to bucket array
    i32                     ind_gtblact_buckets_n;            // number of elements in bucket array
    i32                     ind_gtblact_n;                    // number of elements in the hash table
    gcli::FGtblact*         zd_gtblact_head;                  // zero-terminated doubly linked list
    i32                     zd_gtblact_n;                     // zero-terminated doubly linked list
    gcli::FGtblact*         zd_gtblact_tail;                  // pointer to last element
    gcli::FGtblactfld**     ind_gtblactfld_buckets_elems;     // pointer to bucket array
    i32                     ind_gtblactfld_buckets_n;         // number of elements in bucket array
    i32                     ind_gtblactfld_n;                 // number of elements in the hash table
    gcli::FGfld*            gfld_lary[32];                    // level array
    i32                     gfld_n;                           // number of elements in array
    gcli::FGfld**           ind_gfld_buckets_elems;           // pointer to bucket array
    i32                     ind_gfld_buckets_n;               // number of elements in bucket array
    i32                     ind_gfld_n;                       // number of elements in the hash table
    gcli::FGfld**           c_gfld_elems;                     // array of pointers
    u32                     c_gfld_n;                         // array of pointers
    u32                     c_gfld_max;                       // capacity of allocated array
    gcli::FGtbl*            gtbl_lary[32];                    // level array
    i32                     gtbl_n;                           // number of elements in array
    gcli::FGtbl**           ind_gtbl_buckets_elems;           // pointer to bucket array
    i32                     ind_gtbl_buckets_n;               // number of elements in bucket array
    i32                     ind_gtbl_n;                       // number of elements in the hash table
    gcli::FGact*            gact_lary[32];                    // level array
    i32                     gact_n;                           // number of elements in array
    gcli::FGact**           ind_gact_buckets_elems;           // pointer to bucket array
    i32                     ind_gact_buckets_n;               // number of elements in bucket array
    i32                     ind_gact_n;                       // number of elements in the hash table
    gcli::trace             trace;                            //
};

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     gcli.FDb.cmdline
//     algo_lib.FDb.cmdline
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Calls Step function of dependencies
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtype&        gtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtype*        gtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtype*        gtype_InsertMaybe(const gclidb::Gtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gtype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGtype*        gtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGtype*        gtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gtype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGtype&        gtype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gtype_XrefMaybe(gcli::FGtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGrepossh&     grepossh_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGrepossh*     grepossh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGrepossh*     grepossh_InsertMaybe(const gclidb::Grepossh &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                grepossh_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 grepossh_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGrepossh*     grepossh_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGrepossh*     grepossh_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  grepossh_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 grepossh_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 grepossh_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGrepossh&     grepossh_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 grepossh_XrefMaybe(gcli::FGrepossh &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGrepogitport& grepogitport_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGrepogitport* grepogitport_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGrepogitport* grepogitport_InsertMaybe(const gclidb::Grepogitport &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                grepogitport_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 grepogitport_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGrepogitport* grepogitport_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGrepogitport* grepogitport_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  grepogitport_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 grepogitport_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 grepogitport_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGrepogitport& grepogitport_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 grepogitport_XrefMaybe(gcli::FGrepogitport &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGithost&      githost_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGithost*      githost_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                githost_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 githost_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGithost*      githost_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGithost*      githost_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  githost_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 githost_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 githost_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGithost&      githost_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 githost_XrefMaybe(gcli::FGithost &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGstatet&      gstatet_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGstatet*      gstatet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGstatet*      gstatet_InsertMaybe(const gclidb::Gstatet &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gstatet_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gstatet_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGstatet*      gstatet_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGstatet*      gstatet_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gstatet_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gstatet_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gstatet_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGstatet&      gstatet_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gstatet_XrefMaybe(gcli::FGstatet &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGmethod&      gmethod_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGmethod*      gmethod_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGmethod*      gmethod_InsertMaybe(const gclidb::Gmethod &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gmethod_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gmethod_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGmethod*      gmethod_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGmethod*      gmethod_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gmethod_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gmethod_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gmethod_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGmethod&      gmethod_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gmethod_XrefMaybe(gcli::FGmethod &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdt&     gclicmdt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdt*     gclicmdt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGclicmdt*     gclicmdt_InsertMaybe(const gclidb::Gclicmdt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmdt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmdt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdt*     gclicmdt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmdt*     gclicmdt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmdt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmdt_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmdt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmdt&     gclicmdt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmdt_XrefMaybe(gcli::FGclicmdt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdf&     gclicmdf_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdf*     gclicmdf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmdf_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmdf_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdf*     gclicmdf_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmdf*     gclicmdf_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmdf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmdf_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmdf_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmdf&     gclicmdf_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmdf_XrefMaybe(gcli::FGclicmdf &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdf2j&   gclicmdf2j_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdf2j*   gclicmdf2j_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGclicmdf2j*   gclicmdf2j_InsertMaybe(const gclidb::Gclicmdf2j &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmdf2j_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmdf2j_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdf2j*   gclicmdf2j_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmdf2j*   gclicmdf2j_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmdf2j_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmdf2j_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmdf2j_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmdf2j&   gclicmdf2j_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmdf2j_XrefMaybe(gcli::FGclicmdf2j &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmd&      gclicmd_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmd*      gclicmd_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGclicmd*      gclicmd_InsertMaybe(const gclidb::Gclicmd &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmd_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmd_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmd*      gclicmd_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmd*      gclicmd_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmd_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmd_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmd_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmd&      gclicmd_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmd_XrefMaybe(gcli::FGclicmd &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtypeh&       gtypeh_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtypeh*       gtypeh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtypeh*       gtypeh_InsertMaybe(const gclidb::Gtypeh &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gtypeh_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gtypeh_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGtypeh*       gtypeh_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGtypeh*       gtypeh_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gtypeh_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gtypeh_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gtypeh_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGtypeh&       gtypeh_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gtypeh_XrefMaybe(gcli::FGtypeh &row);

// Return true if hash is empty
bool                 ind_gclicmd_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGclicmd*      ind_gclicmd_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmd&      ind_gclicmd_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmd&      ind_gclicmd_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gclicmd_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gclicmd_InsertMaybe(gcli::FGclicmd& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gclicmd_Remove(gcli::FGclicmd& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gclicmd_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gclicmdf_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGclicmdf*     ind_gclicmdf_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdf&     ind_gclicmdf_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdf&     ind_gclicmdf_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gclicmdf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gclicmdf_InsertMaybe(gcli::FGclicmdf& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gclicmdf_Remove(gcli::FGclicmdf& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gclicmdf_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gclicmdt_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGclicmdt*     ind_gclicmdt_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdt&     ind_gclicmdt_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_gclicmdt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gclicmdt_InsertMaybe(gcli::FGclicmdt& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gclicmdt_Remove(gcli::FGclicmdt& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gclicmdt_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gmethod_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGmethod*      ind_gmethod_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGmethod&      ind_gmethod_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGmethod&      ind_gmethod_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gmethod_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gmethod_InsertMaybe(gcli::FGmethod& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gmethod_Remove(gcli::FGmethod& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gmethod_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_grepo_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGrepo*        ind_grepo_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGrepo&        ind_grepo_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGrepo&        ind_grepo_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_grepo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_grepo_InsertMaybe(gcli::FGrepo& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_grepo_Remove(gcli::FGrepo& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_grepo_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_issue_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FIssue*        ind_issue_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FIssue&        ind_issue_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FIssue&        ind_issue_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_issue_InsertMaybe(gcli::FIssue& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_issue_Remove(gcli::FIssue& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_issue_Reserve(int n) __attribute__((nothrow));

// Print back to string
void                 regx_repo_Print(algo::cstring &out) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gstatet_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGstatet*      ind_gstatet_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGstatet&      ind_gstatet_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGstatet&      ind_gstatet_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gstatet_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gstatet_InsertMaybe(gcli::FGstatet& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gstatet_Remove(gcli::FGstatet& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gstatet_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_githost_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGithost*      ind_githost_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGithost&      ind_githost_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGithost&      ind_githost_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_githost_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_githost_InsertMaybe(gcli::FGithost& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_githost_Remove(gcli::FGithost& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_githost_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_grepogitport_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGrepogitport* ind_grepogitport_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGrepogitport& ind_grepogitport_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGrepogitport& ind_grepogitport_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_grepogitport_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_grepogitport_InsertMaybe(gcli::FGrepogitport& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_grepogitport_Remove(gcli::FGrepogitport& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_grepogitport_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_grepossh_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGrepossh*     ind_grepossh_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGrepossh&     ind_grepossh_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGrepossh&     ind_grepossh_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_grepossh_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_grepossh_InsertMaybe(gcli::FGrepossh& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_grepossh_Remove(gcli::FGrepossh& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_grepossh_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGtype*        ind_gtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGtype&        ind_gtype_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGtype&        ind_gtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gtype_InsertMaybe(gcli::FGtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gtype_Remove(gcli::FGtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gtype_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gclicmd_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmd*      c_gclicmd_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGclicmd*> c_gclicmd_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gclicmd_Insert(gcli::FGclicmd& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gclicmd_InsertMaybe(gcli::FGclicmd& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gclicmd_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gclicmd_Remove(gcli::FGclicmd& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gclicmd_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gclicmd_Reserve(u32 n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdj2f&   gclicmdj2f_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdj2f*   gclicmdj2f_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmdj2f_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmdj2f_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdj2f*   gclicmdj2f_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmdj2f*   gclicmdj2f_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmdj2f_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmdj2f_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmdj2f_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmdj2f&   gclicmdj2f_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmdj2f_XrefMaybe(gcli::FGclicmdj2f &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdc&     gclicmdc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdc*     gclicmdc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmdc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmdc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdc*     gclicmdc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmdc*     gclicmdc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmdc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmdc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmdc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmdc&     gclicmdc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmdc_XrefMaybe(gcli::FGclicmdc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGclicmdarg&   gclicmdarg_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGclicmdarg*   gclicmdarg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gclicmdarg_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gclicmdarg_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdarg*   gclicmdarg_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGclicmdarg*   gclicmdarg_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gclicmdarg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gclicmdarg_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gclicmdarg_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGclicmdarg&   gclicmdarg_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gclicmdarg_XrefMaybe(gcli::FGclicmdarg &row);

// Return true if hash is empty
bool                 ind_gclicmdj2f_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGclicmdj2f*   ind_gclicmdj2f_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdj2f&   ind_gclicmdj2f_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdj2f&   ind_gclicmdj2f_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gclicmdj2f_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gclicmdj2f_InsertMaybe(gcli::FGclicmdj2f& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gclicmdj2f_Remove(gcli::FGclicmdj2f& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gclicmdj2f_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gclicmdarg_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGclicmdarg*   ind_gclicmdarg_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdarg&   ind_gclicmdarg_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdarg&   ind_gclicmdarg_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gclicmdarg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gclicmdarg_InsertMaybe(gcli::FGclicmdarg& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gclicmdarg_Remove(gcli::FGclicmdarg& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gclicmdarg_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_gclicmdc_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGclicmdc*     ind_gclicmdc_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGclicmdc&     ind_gclicmdc_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGclicmdc&     ind_gclicmdc_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gclicmdc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gclicmdc_InsertMaybe(gcli::FGclicmdc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gclicmdc_Remove(gcli::FGclicmdc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gclicmdc_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FIssue&        issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FIssue*        issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FIssue*        issue_InsertMaybe(const gclidb::Issue &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                issue_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 issue_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FIssue*        issue_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FIssue*        issue_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 issue_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 issue_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FIssue&        issue_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 issue_XrefMaybe(gcli::FIssue &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGrepo&        grepo_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGrepo*        grepo_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGrepo*        grepo_InsertMaybe(const gclidb::Grepo &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                grepo_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 grepo_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGrepo*        grepo_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGrepo*        grepo_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  grepo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 grepo_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 grepo_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGrepo&        grepo_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 grepo_XrefMaybe(gcli::FGrepo &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FTuples&       tuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FTuples*       tuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tuples_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tuples_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FTuples*       tuples_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FTuples*       tuples_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tuples_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 tuples_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tuples_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FTuples&       tuples_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 tuples_XrefMaybe(gcli::FTuples &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FIssuenote&    issuenote_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FIssuenote*    issuenote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FIssuenote*    issuenote_InsertMaybe(const gclidb::Issuenote &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                issuenote_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 issuenote_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FIssuenote*    issuenote_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FIssuenote*    issuenote_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  issuenote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 issuenote_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 issuenote_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FIssuenote&    issuenote_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 issuenote_XrefMaybe(gcli::FIssuenote &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMrjob&        mrjob_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMrjob*        mrjob_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMrjob*        mrjob_InsertMaybe(const gclidb::Mrjob &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                mrjob_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mrjob_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FMrjob*        mrjob_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FMrjob*        mrjob_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  mrjob_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 mrjob_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mrjob_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FMrjob&        mrjob_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 mrjob_XrefMaybe(gcli::FMrjob &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMrnote&       mrnote_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMrnote*       mrnote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMrnote*       mrnote_InsertMaybe(const gclidb::Mrnote &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                mrnote_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mrnote_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FMrnote*       mrnote_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FMrnote*       mrnote_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  mrnote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 mrnote_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mrnote_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FMrnote&       mrnote_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 mrnote_XrefMaybe(gcli::FMrnote &row);

// Return true if hash is empty
bool                 ind_mrnote_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FMrnote*       ind_mrnote_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FMrnote&       ind_mrnote_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_mrnote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_mrnote_InsertMaybe(gcli::FMrnote& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_mrnote_Remove(gcli::FMrnote& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_mrnote_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_issuenote_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FIssuenote*    ind_issuenote_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FIssuenote&    ind_issuenote_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_issuenote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_issuenote_InsertMaybe(gcli::FIssuenote& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_issuenote_Remove(gcli::FIssuenote& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_issuenote_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_mrjob_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FMrjob*        ind_mrjob_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FMrjob&        ind_mrjob_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_mrjob_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_mrjob_InsertMaybe(gcli::FMrjob& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_mrjob_Remove(gcli::FMrjob& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_mrjob_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FUser&         user_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FUser*         user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FUser*         user_InsertMaybe(const gclidb::User &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                user_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 user_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FUser*         user_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FUser*         user_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 user_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 user_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FUser&         user_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 user_XrefMaybe(gcli::FUser &row);

// Return true if hash is empty
bool                 ind_user_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FUser*         ind_user_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FUser&         ind_user_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FUser&         ind_user_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_user_InsertMaybe(gcli::FUser& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_user_Remove(gcli::FUser& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_user_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_mr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FMr*           ind_mr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FMr&           ind_mr_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FMr&           ind_mr_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_mr_InsertMaybe(gcli::FMr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_mr_Remove(gcli::FMr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_mr_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_milestone_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FMilestone*    ind_milestone_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FMilestone&    ind_milestone_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FMilestone&    ind_milestone_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_milestone_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_milestone_InsertMaybe(gcli::FMilestone& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_milestone_Remove(gcli::FMilestone& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_milestone_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMilestone&    milestone_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMilestone*    milestone_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMilestone*    milestone_InsertMaybe(const gclidb::Milestone &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                milestone_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 milestone_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FMilestone*    milestone_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FMilestone*    milestone_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  milestone_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 milestone_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 milestone_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FMilestone&    milestone_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 milestone_XrefMaybe(gcli::FMilestone &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FMr&           mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FMr*           mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FMr*           mr_InsertMaybe(const gclidb::Mr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                mr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FMr*           mr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FMr*           mr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 mr_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FMr&           mr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 mr_XrefMaybe(gcli::FMr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtypeprefix&  gtypeprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtypeprefix*  gtypeprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtypeprefix*  gtypeprefix_InsertMaybe(const gclidb::Gtypeprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gtypeprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gtypeprefix_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGtypeprefix*  gtypeprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGtypeprefix*  gtypeprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gtypeprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gtypeprefix_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gtypeprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGtypeprefix&  gtypeprefix_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gtypeprefix_XrefMaybe(gcli::FGtypeprefix &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtblact&      gtblact_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtblact*      gtblact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtblact*      gtblact_InsertMaybe(const gclidb::Gtblact &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gtblact_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gtblact_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGtblact*      gtblact_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGtblact*      gtblact_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gtblact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gtblact_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gtblact_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGtblact&      gtblact_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gtblact_XrefMaybe(gcli::FGtblact &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtblactfld&   gtblactfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtblactfld*   gtblactfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtblactfld*   gtblactfld_InsertMaybe(const gclidb::Gtblactfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gtblactfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gtblactfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGtblactfld*   gtblactfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGtblactfld*   gtblactfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gtblactfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gtblactfld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gtblactfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGtblactfld&   gtblactfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gtblactfld_XrefMaybe(gcli::FGtblactfld &row);

// Return true if hash is empty
bool                 ind_gtblact_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGtblact*      ind_gtblact_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGtblact&      ind_gtblact_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGtblact&      ind_gtblact_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gtblact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gtblact_InsertMaybe(gcli::FGtblact& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gtblact_Remove(gcli::FGtblact& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gtblact_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_gtblact_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
gcli::FGtblact*      zd_gtblact_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_gtblact_InLlistQ(gcli::FGtblact& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_gtblact_Insert(gcli::FGtblact& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
gcli::FGtblact*      zd_gtblact_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_gtblact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
gcli::FGtblact*      zd_gtblact_Next(gcli::FGtblact &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
gcli::FGtblact*      zd_gtblact_Prev(gcli::FGtblact &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_gtblact_Remove(gcli::FGtblact& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_gtblact_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
gcli::FGtblact*      zd_gtblact_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
gcli::FGtblact&      zd_gtblact_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if hash is empty
bool                 ind_gtblactfld_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGtblactfld*   ind_gtblactfld_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGtblactfld&   ind_gtblactfld_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_gtblactfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gtblactfld_InsertMaybe(gcli::FGtblactfld& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gtblactfld_Remove(gcli::FGtblactfld& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gtblactfld_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGfld&         gfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGfld*         gfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGfld*         gfld_InsertMaybe(const gclidb::Gfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGfld*         gfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGfld*         gfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gfld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGfld&         gfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gfld_XrefMaybe(gcli::FGfld &row);

// Return true if hash is empty
bool                 ind_gfld_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGfld*         ind_gfld_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGfld&         ind_gfld_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGfld&         ind_gfld_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gfld_InsertMaybe(gcli::FGfld& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gfld_Remove(gcli::FGfld& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gfld_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGfld*         c_gfld_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGfld*> c_gfld_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gfld_Insert(gcli::FGfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gfld_InsertMaybe(gcli::FGfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gfld_Remove(gcli::FGfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gfld_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gfld_Reserve(u32 n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGtbl&         gtbl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGtbl*         gtbl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGtbl*         gtbl_InsertMaybe(const gclidb::Gtbl &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gtbl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gtbl_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGtbl*         gtbl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGtbl*         gtbl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gtbl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gtbl_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gtbl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGtbl&         gtbl_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gtbl_XrefMaybe(gcli::FGtbl &row);

// Return true if hash is empty
bool                 ind_gtbl_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGtbl*         ind_gtbl_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGtbl&         ind_gtbl_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGtbl&         ind_gtbl_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gtbl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gtbl_InsertMaybe(gcli::FGtbl& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gtbl_Remove(gcli::FGtbl& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gtbl_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gcli::FGact&         gact_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gcli::FGact*         gact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gcli::FGact*         gact_InsertMaybe(const gclidb::Gact &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gact_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gact_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
gcli::FGact*         gact_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
gcli::FGact*         gact_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gact_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gact_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gcli::FGact&         gact_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 gact_XrefMaybe(gcli::FGact &row);

// Return true if hash is empty
bool                 ind_gact_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gcli::FGact*         ind_gact_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gcli::FGact&         ind_gact_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gcli::FGact&         ind_gact_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_gact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_gact_InsertMaybe(gcli::FGact& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_gact_Remove(gcli::FGact& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_gact_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
void                 _db_gtype_curs_Reset(_db_gtype_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gtype_curs_ValidQ(_db_gtype_curs &curs);
// proceed to next item
void                 _db_gtype_curs_Next(_db_gtype_curs &curs);
// item access
gcli::FGtype&        _db_gtype_curs_Access(_db_gtype_curs &curs);
// cursor points to valid item
void                 _db_grepossh_curs_Reset(_db_grepossh_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_grepossh_curs_ValidQ(_db_grepossh_curs &curs);
// proceed to next item
void                 _db_grepossh_curs_Next(_db_grepossh_curs &curs);
// item access
gcli::FGrepossh&     _db_grepossh_curs_Access(_db_grepossh_curs &curs);
// cursor points to valid item
void                 _db_grepogitport_curs_Reset(_db_grepogitport_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_grepogitport_curs_ValidQ(_db_grepogitport_curs &curs);
// proceed to next item
void                 _db_grepogitport_curs_Next(_db_grepogitport_curs &curs);
// item access
gcli::FGrepogitport& _db_grepogitport_curs_Access(_db_grepogitport_curs &curs);
// cursor points to valid item
void                 _db_githost_curs_Reset(_db_githost_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_githost_curs_ValidQ(_db_githost_curs &curs);
// proceed to next item
void                 _db_githost_curs_Next(_db_githost_curs &curs);
// item access
gcli::FGithost&      _db_githost_curs_Access(_db_githost_curs &curs);
// cursor points to valid item
void                 _db_gstatet_curs_Reset(_db_gstatet_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gstatet_curs_ValidQ(_db_gstatet_curs &curs);
// proceed to next item
void                 _db_gstatet_curs_Next(_db_gstatet_curs &curs);
// item access
gcli::FGstatet&      _db_gstatet_curs_Access(_db_gstatet_curs &curs);
// cursor points to valid item
void                 _db_gmethod_curs_Reset(_db_gmethod_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gmethod_curs_ValidQ(_db_gmethod_curs &curs);
// proceed to next item
void                 _db_gmethod_curs_Next(_db_gmethod_curs &curs);
// item access
gcli::FGmethod&      _db_gmethod_curs_Access(_db_gmethod_curs &curs);
// cursor points to valid item
void                 _db_gclicmdt_curs_Reset(_db_gclicmdt_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmdt_curs_ValidQ(_db_gclicmdt_curs &curs);
// proceed to next item
void                 _db_gclicmdt_curs_Next(_db_gclicmdt_curs &curs);
// item access
gcli::FGclicmdt&     _db_gclicmdt_curs_Access(_db_gclicmdt_curs &curs);
// cursor points to valid item
void                 _db_gclicmdf_curs_Reset(_db_gclicmdf_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmdf_curs_ValidQ(_db_gclicmdf_curs &curs);
// proceed to next item
void                 _db_gclicmdf_curs_Next(_db_gclicmdf_curs &curs);
// item access
gcli::FGclicmdf&     _db_gclicmdf_curs_Access(_db_gclicmdf_curs &curs);
// cursor points to valid item
void                 _db_gclicmdf2j_curs_Reset(_db_gclicmdf2j_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmdf2j_curs_ValidQ(_db_gclicmdf2j_curs &curs);
// proceed to next item
void                 _db_gclicmdf2j_curs_Next(_db_gclicmdf2j_curs &curs);
// item access
gcli::FGclicmdf2j&   _db_gclicmdf2j_curs_Access(_db_gclicmdf2j_curs &curs);
// cursor points to valid item
void                 _db_gclicmd_curs_Reset(_db_gclicmd_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmd_curs_ValidQ(_db_gclicmd_curs &curs);
// proceed to next item
void                 _db_gclicmd_curs_Next(_db_gclicmd_curs &curs);
// item access
gcli::FGclicmd&      _db_gclicmd_curs_Access(_db_gclicmd_curs &curs);
// cursor points to valid item
void                 _db_gtypeh_curs_Reset(_db_gtypeh_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gtypeh_curs_ValidQ(_db_gtypeh_curs &curs);
// proceed to next item
void                 _db_gtypeh_curs_Next(_db_gtypeh_curs &curs);
// item access
gcli::FGtypeh&       _db_gtypeh_curs_Access(_db_gtypeh_curs &curs);
void                 _db_c_gclicmd_curs_Reset(_db_c_gclicmd_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_c_gclicmd_curs_ValidQ(_db_c_gclicmd_curs &curs);
// proceed to next item
void                 _db_c_gclicmd_curs_Next(_db_c_gclicmd_curs &curs);
// item access
gcli::FGclicmd&      _db_c_gclicmd_curs_Access(_db_c_gclicmd_curs &curs);
// cursor points to valid item
void                 _db_gclicmdj2f_curs_Reset(_db_gclicmdj2f_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmdj2f_curs_ValidQ(_db_gclicmdj2f_curs &curs);
// proceed to next item
void                 _db_gclicmdj2f_curs_Next(_db_gclicmdj2f_curs &curs);
// item access
gcli::FGclicmdj2f&   _db_gclicmdj2f_curs_Access(_db_gclicmdj2f_curs &curs);
// cursor points to valid item
void                 _db_gclicmdc_curs_Reset(_db_gclicmdc_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmdc_curs_ValidQ(_db_gclicmdc_curs &curs);
// proceed to next item
void                 _db_gclicmdc_curs_Next(_db_gclicmdc_curs &curs);
// item access
gcli::FGclicmdc&     _db_gclicmdc_curs_Access(_db_gclicmdc_curs &curs);
// cursor points to valid item
void                 _db_gclicmdarg_curs_Reset(_db_gclicmdarg_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gclicmdarg_curs_ValidQ(_db_gclicmdarg_curs &curs);
// proceed to next item
void                 _db_gclicmdarg_curs_Next(_db_gclicmdarg_curs &curs);
// item access
gcli::FGclicmdarg&   _db_gclicmdarg_curs_Access(_db_gclicmdarg_curs &curs);
// cursor points to valid item
void                 _db_issue_curs_Reset(_db_issue_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_issue_curs_ValidQ(_db_issue_curs &curs);
// proceed to next item
void                 _db_issue_curs_Next(_db_issue_curs &curs);
// item access
gcli::FIssue&        _db_issue_curs_Access(_db_issue_curs &curs);
// cursor points to valid item
void                 _db_grepo_curs_Reset(_db_grepo_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_grepo_curs_ValidQ(_db_grepo_curs &curs);
// proceed to next item
void                 _db_grepo_curs_Next(_db_grepo_curs &curs);
// item access
gcli::FGrepo&        _db_grepo_curs_Access(_db_grepo_curs &curs);
// cursor points to valid item
void                 _db_tuples_curs_Reset(_db_tuples_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_tuples_curs_ValidQ(_db_tuples_curs &curs);
// proceed to next item
void                 _db_tuples_curs_Next(_db_tuples_curs &curs);
// item access
gcli::FTuples&       _db_tuples_curs_Access(_db_tuples_curs &curs);
// cursor points to valid item
void                 _db_issuenote_curs_Reset(_db_issuenote_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_issuenote_curs_ValidQ(_db_issuenote_curs &curs);
// proceed to next item
void                 _db_issuenote_curs_Next(_db_issuenote_curs &curs);
// item access
gcli::FIssuenote&    _db_issuenote_curs_Access(_db_issuenote_curs &curs);
// cursor points to valid item
void                 _db_mrjob_curs_Reset(_db_mrjob_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_mrjob_curs_ValidQ(_db_mrjob_curs &curs);
// proceed to next item
void                 _db_mrjob_curs_Next(_db_mrjob_curs &curs);
// item access
gcli::FMrjob&        _db_mrjob_curs_Access(_db_mrjob_curs &curs);
// cursor points to valid item
void                 _db_mrnote_curs_Reset(_db_mrnote_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_mrnote_curs_ValidQ(_db_mrnote_curs &curs);
// proceed to next item
void                 _db_mrnote_curs_Next(_db_mrnote_curs &curs);
// item access
gcli::FMrnote&       _db_mrnote_curs_Access(_db_mrnote_curs &curs);
// cursor points to valid item
void                 _db_user_curs_Reset(_db_user_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_user_curs_ValidQ(_db_user_curs &curs);
// proceed to next item
void                 _db_user_curs_Next(_db_user_curs &curs);
// item access
gcli::FUser&         _db_user_curs_Access(_db_user_curs &curs);
// cursor points to valid item
void                 _db_milestone_curs_Reset(_db_milestone_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_milestone_curs_ValidQ(_db_milestone_curs &curs);
// proceed to next item
void                 _db_milestone_curs_Next(_db_milestone_curs &curs);
// item access
gcli::FMilestone&    _db_milestone_curs_Access(_db_milestone_curs &curs);
// cursor points to valid item
void                 _db_mr_curs_Reset(_db_mr_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_mr_curs_ValidQ(_db_mr_curs &curs);
// proceed to next item
void                 _db_mr_curs_Next(_db_mr_curs &curs);
// item access
gcli::FMr&           _db_mr_curs_Access(_db_mr_curs &curs);
// cursor points to valid item
void                 _db_gtypeprefix_curs_Reset(_db_gtypeprefix_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gtypeprefix_curs_ValidQ(_db_gtypeprefix_curs &curs);
// proceed to next item
void                 _db_gtypeprefix_curs_Next(_db_gtypeprefix_curs &curs);
// item access
gcli::FGtypeprefix&  _db_gtypeprefix_curs_Access(_db_gtypeprefix_curs &curs);
// cursor points to valid item
void                 _db_gtblact_curs_Reset(_db_gtblact_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gtblact_curs_ValidQ(_db_gtblact_curs &curs);
// proceed to next item
void                 _db_gtblact_curs_Next(_db_gtblact_curs &curs);
// item access
gcli::FGtblact&      _db_gtblact_curs_Access(_db_gtblact_curs &curs);
// cursor points to valid item
void                 _db_gtblactfld_curs_Reset(_db_gtblactfld_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gtblactfld_curs_ValidQ(_db_gtblactfld_curs &curs);
// proceed to next item
void                 _db_gtblactfld_curs_Next(_db_gtblactfld_curs &curs);
// item access
gcli::FGtblactfld&   _db_gtblactfld_curs_Access(_db_gtblactfld_curs &curs);
// cursor points to valid item
void                 _db_zd_gtblact_curs_Reset(_db_zd_gtblact_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_zd_gtblact_curs_ValidQ(_db_zd_gtblact_curs &curs);
// proceed to next item
void                 _db_zd_gtblact_curs_Next(_db_zd_gtblact_curs &curs);
// item access
gcli::FGtblact&      _db_zd_gtblact_curs_Access(_db_zd_gtblact_curs &curs);
// cursor points to valid item
void                 _db_gfld_curs_Reset(_db_gfld_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gfld_curs_ValidQ(_db_gfld_curs &curs);
// proceed to next item
void                 _db_gfld_curs_Next(_db_gfld_curs &curs);
// item access
gcli::FGfld&         _db_gfld_curs_Access(_db_gfld_curs &curs);
void                 _db_c_gfld_curs_Reset(_db_c_gfld_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_c_gfld_curs_ValidQ(_db_c_gfld_curs &curs);
// proceed to next item
void                 _db_c_gfld_curs_Next(_db_c_gfld_curs &curs);
// item access
gcli::FGfld&         _db_c_gfld_curs_Access(_db_c_gfld_curs &curs);
// cursor points to valid item
void                 _db_gtbl_curs_Reset(_db_gtbl_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gtbl_curs_ValidQ(_db_gtbl_curs &curs);
// proceed to next item
void                 _db_gtbl_curs_Next(_db_gtbl_curs &curs);
// item access
gcli::FGtbl&         _db_gtbl_curs_Access(_db_gtbl_curs &curs);
// cursor points to valid item
void                 _db_gact_curs_Reset(_db_gact_curs &curs, gcli::FDb &parent);
// cursor points to valid item
bool                 _db_gact_curs_ValidQ(_db_gact_curs &curs);
// proceed to next item
void                 _db_gact_curs_Next(_db_gact_curs &curs);
// item access
gcli::FGact&         _db_gact_curs_Access(_db_gact_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- gcli.FGact
// create: gcli.FDb.gact (Lary)
// global access: ind_gact (Thash)
struct FGact { // gcli.FGact
    gcli::FGact*       ind_gact_next;   // hash next
    algo::Smallstr50   gact;            //
    algo::Comment      comment;         //
private:
    friend gcli::FGact&         gact_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGact*         gact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gact_RemoveAll() __attribute__((nothrow));
    friend void                 gact_RemoveLast() __attribute__((nothrow));
    FGact();
    ~FGact();
    FGact(const FGact&){ /*disallow copy constructor */}
    void operator =(const FGact&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gact_CopyOut(gcli::FGact &row, gclidb::Gact &out) __attribute__((nothrow));
// Copy fields in to row
void                 gact_CopyIn(gcli::FGact &row, gclidb::Gact &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGact_Init(gcli::FGact& gact);
void                 FGact_Uninit(gcli::FGact& gact) __attribute__((nothrow));

// --- gcli.FGclicmd
// create: gcli.FDb.gclicmd (Lary)
// global access: ind_gclicmd (Thash)
// global access: c_gclicmd (Ptrary)
// access: gcli.FGclicmd.step (Hook)
// access: gcli.FGclicmd.p_gclicmd (Upptr)
// access: gcli.FGclicmdf2j.p_gclicmd (Upptr)
// access: gcli.FGclicmdt.p_gclicmd (Upptr)
struct FGclicmd { // gcli.FGclicmd
    gcli::FGclicmd*           ind_gclicmd_next;       // hash next
    algo::Smallstr250         gclicmd;                //
    algo::Smallstr250         gclicmdf2j;             // Base for gclicmdf2j
    algo::Comment             comment;                //
    algo::cstring             url;                    //
    algo::cstring             sep;                    //
    algo::cstring             host;                   //
    algo::cstring             proj;                   //
    algo::cstring             token;                  //
    algo::cstring             body;                   //
    algo::cstring             note_id;                //
    algo::cstring             issue_id;               //
    algo::cstring             cond;                   //
    bool                      select;                 //   false
    bool                      write_auth;             //   false
    bool                      finish;                 //   false
    algo::cstring             gclicmdt_key;           //
    u32                       method;                 //   0
    gcli::FIssue*             p_issue;                // optional pointer
    gcli::FMr*                p_mr;                   // optional pointer
    gcli::FTuples**           c_tuples_elems;         // array of pointers
    u32                       c_tuples_n;             // array of pointers
    u32                       c_tuples_max;           // capacity of allocated array
    gcli::gclicmd_step_hook   step;                   //   NULL  Pointer to a function
    gcli::FGclicmdarg**       c_gclicmdarg_elems;     // array of pointers
    u32                       c_gclicmdarg_n;         // array of pointers
    u32                       c_gclicmdarg_max;       // capacity of allocated array
    gcli::FGclicmdc**         c_gclicmdc_elems;       // array of pointers
    u32                       c_gclicmdc_n;           // array of pointers
    u32                       c_gclicmdc_max;         // capacity of allocated array
    gcli::FGclicmdf2j**       c_gclicmdf2j_elems;     // array of pointers
    u32                       c_gclicmdf2j_n;         // array of pointers
    u32                       c_gclicmdf2j_max;       // capacity of allocated array
    gcli::FGclicmd*           p_gclicmd;              // reference to parent row
    bool                      _db_c_gclicmd_in_ary;   //   false  membership flag
private:
    friend gcli::FGclicmd&      gclicmd_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmd*      gclicmd_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmd_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmd_RemoveLast() __attribute__((nothrow));
    FGclicmd();
    ~FGclicmd();
    FGclicmd(const FGclicmd&){ /*disallow copy constructor */}
    void operator =(const FGclicmd&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gclicmd_CopyOut(gcli::FGclicmd &row, gclidb::Gclicmd &out) __attribute__((nothrow));
// Copy fields in to row
void                 gclicmd_CopyIn(gcli::FGclicmd &row, gclidb::Gclicmd &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_tuples_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FTuples*       c_tuples_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FTuples*> c_tuples_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_tuples_Insert(gcli::FGclicmd& gclicmd, gcli::FTuples& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_tuples_ScanInsertMaybe(gcli::FGclicmd& gclicmd, gcli::FTuples& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_tuples_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_tuples_Remove(gcli::FGclicmd& gclicmd, gcli::FTuples& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_tuples_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_tuples_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(gcli::FGclicmd& gclicmd, gcli::FGclicmd& arg) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gclicmdarg_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdarg*   c_gclicmdarg_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGclicmdarg*> c_gclicmdarg_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gclicmdarg_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gclicmdarg_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gclicmdarg_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gclicmdarg_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gclicmdarg_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gclicmdarg_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gclicmdc_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdc*     c_gclicmdc_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGclicmdc*> c_gclicmdc_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gclicmdc_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gclicmdc_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gclicmdc_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gclicmdc_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gclicmdc_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gclicmdc_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gclicmdf2j_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdf2j*   c_gclicmdf2j_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGclicmdf2j*> c_gclicmdf2j_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gclicmdf2j_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gclicmdf2j_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gclicmdf2j_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gclicmdf2j_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gclicmdf2j_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gclicmdf2j_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGclicmd_Init(gcli::FGclicmd& gclicmd);
void                 gclicmd_c_tuples_curs_Reset(gclicmd_c_tuples_curs &curs, gcli::FGclicmd &parent);
// cursor points to valid item
bool                 gclicmd_c_tuples_curs_ValidQ(gclicmd_c_tuples_curs &curs);
// proceed to next item
void                 gclicmd_c_tuples_curs_Next(gclicmd_c_tuples_curs &curs);
// item access
gcli::FTuples&       gclicmd_c_tuples_curs_Access(gclicmd_c_tuples_curs &curs);
void                 gclicmd_c_gclicmdarg_curs_Reset(gclicmd_c_gclicmdarg_curs &curs, gcli::FGclicmd &parent);
// cursor points to valid item
bool                 gclicmd_c_gclicmdarg_curs_ValidQ(gclicmd_c_gclicmdarg_curs &curs);
// proceed to next item
void                 gclicmd_c_gclicmdarg_curs_Next(gclicmd_c_gclicmdarg_curs &curs);
// item access
gcli::FGclicmdarg&   gclicmd_c_gclicmdarg_curs_Access(gclicmd_c_gclicmdarg_curs &curs);
void                 gclicmd_c_gclicmdc_curs_Reset(gclicmd_c_gclicmdc_curs &curs, gcli::FGclicmd &parent);
// cursor points to valid item
bool                 gclicmd_c_gclicmdc_curs_ValidQ(gclicmd_c_gclicmdc_curs &curs);
// proceed to next item
void                 gclicmd_c_gclicmdc_curs_Next(gclicmd_c_gclicmdc_curs &curs);
// item access
gcli::FGclicmdc&     gclicmd_c_gclicmdc_curs_Access(gclicmd_c_gclicmdc_curs &curs);
void                 gclicmd_c_gclicmdf2j_curs_Reset(gclicmd_c_gclicmdf2j_curs &curs, gcli::FGclicmd &parent);
// cursor points to valid item
bool                 gclicmd_c_gclicmdf2j_curs_ValidQ(gclicmd_c_gclicmdf2j_curs &curs);
// proceed to next item
void                 gclicmd_c_gclicmdf2j_curs_Next(gclicmd_c_gclicmdf2j_curs &curs);
// item access
gcli::FGclicmdf2j&   gclicmd_c_gclicmdf2j_curs_Access(gclicmd_c_gclicmdf2j_curs &curs);
void                 FGclicmd_Uninit(gcli::FGclicmd& gclicmd) __attribute__((nothrow));

// --- gcli.FGclicmdarg
// create: gcli.FDb.gclicmdarg (Lary)
// global access: ind_gclicmdarg (Thash)
// access: gcli.FGclicmd.c_gclicmdarg (Ptrary)
struct FGclicmdarg { // gcli.FGclicmdarg
    gcli::FGclicmdarg*   ind_gclicmdarg_next;           // hash next
    algo::Smallstr250    gclicmdarg;                    //
    bool                 gclicmd_c_gclicmdarg_in_ary;   //   false  membership flag
private:
    friend gcli::FGclicmdarg&   gclicmdarg_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdarg*   gclicmdarg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdarg_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdarg_RemoveLast() __attribute__((nothrow));
    FGclicmdarg();
    ~FGclicmdarg();
    FGclicmdarg(const FGclicmdarg&){ /*disallow copy constructor */}
    void operator =(const FGclicmdarg&){ /*disallow direct assignment */}
};

algo::Smallstr250    gclicmd_Get(gcli::FGclicmdarg& gclicmdarg) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        arg_Get(gcli::FGclicmdarg& gclicmdarg) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGclicmdarg_Init(gcli::FGclicmdarg& gclicmdarg);
tempstr              FGclicmdarg_Concat_gclicmd_arg( const algo::strptr& gclicmd ,const algo::strptr& arg );
void                 FGclicmdarg_Uninit(gcli::FGclicmdarg& gclicmdarg) __attribute__((nothrow));

// --- gcli.FGclicmdc
// create: gcli.FDb.gclicmdc (Lary)
// global access: ind_gclicmdc (Thash)
// access: gcli.FGclicmd.c_gclicmdc (Ptrary)
struct FGclicmdc { // gcli.FGclicmdc
    gcli::FGclicmdc*    ind_gclicmdc_next;           // hash next
    algo::Smallstr250   gclicmdc;                    //
    gcli::FGclicmdf**   c_gclicmdf_elems;            // array of pointers
    u32                 c_gclicmdf_n;                // array of pointers
    u32                 c_gclicmdf_max;              // capacity of allocated array
    bool                gclicmd_c_gclicmdc_in_ary;   //   false  membership flag
private:
    friend gcli::FGclicmdc&     gclicmdc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdc*     gclicmdc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdc_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdc_RemoveLast() __attribute__((nothrow));
    FGclicmdc();
    ~FGclicmdc();
    FGclicmdc(const FGclicmdc&){ /*disallow copy constructor */}
    void operator =(const FGclicmdc&){ /*disallow direct assignment */}
};

algo::Smallstr250    gclicmd_Get(gcli::FGclicmdc& gclicmdc) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        ctype_Get(gcli::FGclicmdc& gclicmdc) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_gclicmdf_EmptyQ(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdf*     c_gclicmdf_Find(gcli::FGclicmdc& gclicmdc, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGclicmdf*> c_gclicmdf_Getary(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gclicmdf_Insert(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gclicmdf_InsertMaybe(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gclicmdf_N(const gcli::FGclicmdc& gclicmdc) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gclicmdf_Remove(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gclicmdf_RemoveAll(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gclicmdf_Reserve(gcli::FGclicmdc& gclicmdc, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGclicmdc_Init(gcli::FGclicmdc& gclicmdc);
tempstr              FGclicmdc_Concat_gclicmd_ctype( const algo::strptr& gclicmd ,const algo::strptr& ctype );
void                 gclicmdc_c_gclicmdf_curs_Reset(gclicmdc_c_gclicmdf_curs &curs, gcli::FGclicmdc &parent);
// cursor points to valid item
bool                 gclicmdc_c_gclicmdf_curs_ValidQ(gclicmdc_c_gclicmdf_curs &curs);
// proceed to next item
void                 gclicmdc_c_gclicmdf_curs_Next(gclicmdc_c_gclicmdf_curs &curs);
// item access
gcli::FGclicmdf&     gclicmdc_c_gclicmdf_curs_Access(gclicmdc_c_gclicmdf_curs &curs);
void                 FGclicmdc_Uninit(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));

// --- gcli.FGclicmdf
// create: gcli.FDb.gclicmdf (Lary)
// global access: ind_gclicmdf (Thash)
// access: gcli.FGclicmdc.c_gclicmdf (Ptrary)
// access: gcli.FGclicmdj2f.c_gclicmdf (Ptrary)
struct FGclicmdf { // gcli.FGclicmdf: fields
    gcli::FGclicmdf*    ind_gclicmdf_next;            // hash next
    algo::Smallstr250   gclicmdf;                     //
    algo::cstring       uval;                         //
    bool                gclicmdc_c_gclicmdf_in_ary;   //   false  membership flag
private:
    friend gcli::FGclicmdf&     gclicmdf_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdf*     gclicmdf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdf_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdf_RemoveLast() __attribute__((nothrow));
    FGclicmdf();
    ~FGclicmdf();
    FGclicmdf(const FGclicmdf&){ /*disallow copy constructor */}
    void operator =(const FGclicmdf&){ /*disallow direct assignment */}
};

algo::Smallstr250    gclicmd_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr100    field_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        name_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        gclicmdc_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGclicmdf_Init(gcli::FGclicmdf& gclicmdf);
tempstr              FGclicmdf_Concat_gclicmd_field( const algo::strptr& gclicmd ,const algo::strptr& field );
tempstr              FGclicmdf_Concat_gclicmdc_name( const algo::strptr& gclicmdc ,const algo::strptr& name );
void                 FGclicmdf_Uninit(gcli::FGclicmdf& gclicmdf) __attribute__((nothrow));

// --- gcli.FGclicmdf2j
// create: gcli.FDb.gclicmdf2j (Lary)
// access: gcli.FGclicmd.c_gclicmdf2j (Ptrary)
struct FGclicmdf2j { // gcli.FGclicmdf2j: mapping field to json key
    algo::Smallstr250   gclicmdf2j;                    //
    bool                dup;                           //   false
    algo::Comment       comment;                       //
    gcli::FGclicmd*     p_gclicmd;                     // reference to parent row
    bool                gclicmd_c_gclicmdf2j_in_ary;   //   false  membership flag
private:
    friend gcli::FGclicmdf2j&   gclicmdf2j_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdf2j*   gclicmdf2j_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdf2j_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdf2j_RemoveLast() __attribute__((nothrow));
    FGclicmdf2j();
    ~FGclicmdf2j();
    FGclicmdf2j(const FGclicmdf2j&){ /*disallow copy constructor */}
    void operator =(const FGclicmdf2j&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gclicmdf2j_CopyOut(gcli::FGclicmdf2j &row, gclidb::Gclicmdf2j &out) __attribute__((nothrow));
// Copy fields in to row
void                 gclicmdf2j_CopyIn(gcli::FGclicmdf2j &row, gclidb::Gclicmdf2j &in) __attribute__((nothrow));

algo::cstring        gclicmdf_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr250    gclicmd_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr100    field_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        jkey_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGclicmdf2j_Init(gcli::FGclicmdf2j& gclicmdf2j);
void                 FGclicmdf2j_Uninit(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((nothrow));

// --- gcli.FGclicmdj2f
// create: gcli.FDb.gclicmdj2f (Lary)
// global access: ind_gclicmdj2f (Thash)
struct FGclicmdj2f { // gcli.FGclicmdj2f
    gcli::FGclicmdj2f*   ind_gclicmdj2f_next;   // hash next
    algo::Smallstr250    gclicmdj2f;            //
    bool                 select;                //   false
    bool                 dup;                   //   false
    gcli::FGclicmdf**    c_gclicmdf_elems;      // array of pointers
    u32                  c_gclicmdf_n;          // array of pointers
    u32                  c_gclicmdf_max;        // capacity of allocated array
private:
    friend gcli::FGclicmdj2f&   gclicmdj2f_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdj2f*   gclicmdj2f_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdj2f_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdj2f_RemoveLast() __attribute__((nothrow));
    FGclicmdj2f();
    ~FGclicmdj2f();
    FGclicmdj2f(const FGclicmdj2f&){ /*disallow copy constructor */}
    void operator =(const FGclicmdj2f&){ /*disallow direct assignment */}
};

algo::Smallstr250    gclicmd_Get(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        jkey_Get(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_gclicmdf_EmptyQ(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGclicmdf*     c_gclicmdf_Find(gcli::FGclicmdj2f& gclicmdj2f, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGclicmdf*> c_gclicmdf_Getary(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gclicmdf_Insert(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_gclicmdf_ScanInsertMaybe(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gclicmdf_N(const gcli::FGclicmdj2f& gclicmdj2f) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gclicmdf_Remove(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gclicmdf_RemoveAll(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gclicmdf_Reserve(gcli::FGclicmdj2f& gclicmdj2f, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGclicmdj2f_Init(gcli::FGclicmdj2f& gclicmdj2f);
tempstr              FGclicmdj2f_Concat_gclicmd_jkey( const algo::strptr& gclicmd ,const algo::strptr& jkey );
void                 gclicmdj2f_c_gclicmdf_curs_Reset(gclicmdj2f_c_gclicmdf_curs &curs, gcli::FGclicmdj2f &parent);
// cursor points to valid item
bool                 gclicmdj2f_c_gclicmdf_curs_ValidQ(gclicmdj2f_c_gclicmdf_curs &curs);
// proceed to next item
void                 gclicmdj2f_c_gclicmdf_curs_Next(gclicmdj2f_c_gclicmdf_curs &curs);
// item access
gcli::FGclicmdf&     gclicmdj2f_c_gclicmdf_curs_Access(gclicmdj2f_c_gclicmdf_curs &curs);
void                 FGclicmdj2f_Uninit(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));

// --- gcli.FGclicmdt
// create: gcli.FDb.gclicmdt (Lary)
// global access: ind_gclicmdt (Thash)
struct FGclicmdt { // gcli.FGclicmdt
    gcli::FGclicmdt*    ind_gclicmdt_next;   // hash next
    algo::Smallstr250   gclicmdt;            //
    algo::Smallstr50    gmethod;             //   "GET"
    algo::Comment       uri;                 //
    algo::Comment       comment;             //
    gcli::FGclicmd*     p_gclicmd;           // reference to parent row
    gcli::FGtype*       p_gtype;             // reference to parent row
private:
    friend gcli::FGclicmdt&     gclicmdt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdt*     gclicmdt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdt_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdt_RemoveLast() __attribute__((nothrow));
    FGclicmdt();
    ~FGclicmdt();
    FGclicmdt(const FGclicmdt&){ /*disallow copy constructor */}
    void operator =(const FGclicmdt&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gclicmdt_CopyOut(gcli::FGclicmdt &row, gclidb::Gclicmdt &out) __attribute__((nothrow));
// Copy fields in to row
void                 gclicmdt_CopyIn(gcli::FGclicmdt &row, gclidb::Gclicmdt &in) __attribute__((nothrow));

algo::Smallstr250    gclicmd_Get(gcli::FGclicmdt& gclicmdt) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     gtype_Get(gcli::FGclicmdt& gclicmdt) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGclicmdt_Init(gcli::FGclicmdt& gclicmdt);
void                 FGclicmdt_Uninit(gcli::FGclicmdt& gclicmdt) __attribute__((nothrow));

// --- gcli.FGfld
// create: gcli.FDb.gfld (Lary)
// global access: ind_gfld (Thash)
// global access: c_gfld (Ptrary)
// access: gcli.FGtblactfld.p_gfld (Upptr)
struct FGfld { // gcli.FGfld
    gcli::FGfld*          ind_gfld_next;        // hash next
    algo::Smallstr50      gfld;                 //
    algo::Comment         comment;              //
    gcli::FGtblactfld**   c_gtblactfld_elems;   // array of pointers
    u32                   c_gtblactfld_n;       // array of pointers
    u32                   c_gtblactfld_max;     // capacity of allocated array
    bool                  _db_c_gfld_in_ary;    //   false  membership flag
private:
    friend gcli::FGfld&         gfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGfld*         gfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gfld_RemoveAll() __attribute__((nothrow));
    friend void                 gfld_RemoveLast() __attribute__((nothrow));
    FGfld();
    ~FGfld();
    FGfld(const FGfld&){ /*disallow copy constructor */}
    void operator =(const FGfld&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gfld_CopyOut(gcli::FGfld &row, gclidb::Gfld &out) __attribute__((nothrow));
// Copy fields in to row
void                 gfld_CopyIn(gcli::FGfld &row, gclidb::Gfld &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gtblactfld_EmptyQ(gcli::FGfld& gfld) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGtblactfld*   c_gtblactfld_Find(gcli::FGfld& gfld, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGtblactfld*> c_gtblactfld_Getary(gcli::FGfld& gfld) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gtblactfld_Insert(gcli::FGfld& gfld, gcli::FGtblactfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gtblactfld_InsertMaybe(gcli::FGfld& gfld, gcli::FGtblactfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gtblactfld_N(const gcli::FGfld& gfld) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gtblactfld_Remove(gcli::FGfld& gfld, gcli::FGtblactfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gtblactfld_RemoveAll(gcli::FGfld& gfld) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gtblactfld_Reserve(gcli::FGfld& gfld, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGfld_Init(gcli::FGfld& gfld);
void                 gfld_c_gtblactfld_curs_Reset(gfld_c_gtblactfld_curs &curs, gcli::FGfld &parent);
// cursor points to valid item
bool                 gfld_c_gtblactfld_curs_ValidQ(gfld_c_gtblactfld_curs &curs);
// proceed to next item
void                 gfld_c_gtblactfld_curs_Next(gfld_c_gtblactfld_curs &curs);
// item access
gcli::FGtblactfld&   gfld_c_gtblactfld_curs_Access(gfld_c_gtblactfld_curs &curs);
void                 FGfld_Uninit(gcli::FGfld& gfld) __attribute__((nothrow));

// --- gcli.FGithost
// create: gcli.FDb.githost (Lary)
// global access: ind_githost (Thash)
struct FGithost { // gcli.FGithost
    gcli::FGithost*     ind_githost_next;   // hash next
    algo::Smallstr250   githost;            //
    algo::cstring       ip;                 //
    algo::cstring       id;                 //
    algo::cstring       id_file;            //
    algo::cstring       port;               //
    algo::cstring       ssh_config;         //
    algo::cstring       ssh_cmd;            //
private:
    friend gcli::FGithost&      githost_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGithost*      githost_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 githost_RemoveAll() __attribute__((nothrow));
    friend void                 githost_RemoveLast() __attribute__((nothrow));
    FGithost();
    ~FGithost();
    FGithost(const FGithost&){ /*disallow copy constructor */}
    void operator =(const FGithost&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FGithost_Init(gcli::FGithost& githost);
void                 FGithost_Uninit(gcli::FGithost& githost) __attribute__((nothrow));

// --- gcli.FGmethod
// create: gcli.FDb.gmethod (Lary)
// global access: ind_gmethod (Thash)
struct FGmethod { // gcli.FGmethod
    gcli::FGmethod*    ind_gmethod_next;   // hash next
    algo::Smallstr50   gmethod;            //
    u32                val;                //   0
    algo::Comment      comment;            //
private:
    friend gcli::FGmethod&      gmethod_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGmethod*      gmethod_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gmethod_RemoveAll() __attribute__((nothrow));
    friend void                 gmethod_RemoveLast() __attribute__((nothrow));
    FGmethod();
    ~FGmethod();
    FGmethod(const FGmethod&){ /*disallow copy constructor */}
    void operator =(const FGmethod&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gmethod_CopyOut(gcli::FGmethod &row, gclidb::Gmethod &out) __attribute__((nothrow));
// Copy fields in to row
void                 gmethod_CopyIn(gcli::FGmethod &row, gclidb::Gmethod &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGmethod_Init(gcli::FGmethod& gmethod);
void                 FGmethod_Uninit(gcli::FGmethod& gmethod) __attribute__((nothrow));

// --- gcli.FGrepo
// create: gcli.FDb.grepo (Lary)
// global access: ind_grepo (Thash)
struct FGrepo { // gcli.FGrepo
    gcli::FGrepo*       ind_grepo_next;   // hash next
    algo::Smallstr250   grepo;            // gcli name/access token
    algo::cstring       token;            // gitlab project or repo access token
    algo::cstring       default_branch;   //   "origin"  gcli remote used in the workflow
    algo::cstring       keyid;            // gcli project id or repo
    algo::cstring       ssh_repo;         //
    algo::cstring       web_url;          //
    algo::cstring       descr;            //
    bool                active;           //   true  set to false to ignore the line but keep it in the file
    algo::cstring       priv;             //
    bool                select;           //   false
    algo::cstring       gitremote_cmd;    //
private:
    friend gcli::FGrepo&        grepo_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGrepo*        grepo_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 grepo_RemoveAll() __attribute__((nothrow));
    friend void                 grepo_RemoveLast() __attribute__((nothrow));
    FGrepo();
    ~FGrepo();
    FGrepo(const FGrepo&){ /*disallow copy constructor */}
    void operator =(const FGrepo&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 grepo_CopyOut(gcli::FGrepo &row, gclidb::Grepo &out) __attribute__((nothrow));
// Copy fields in to row
void                 grepo_CopyIn(gcli::FGrepo &row, gclidb::Grepo &in) __attribute__((nothrow));

algo::cstring        host_Get(gcli::FGrepo& grepo) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        name_Get(gcli::FGrepo& grepo) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGrepo_Init(gcli::FGrepo& grepo);
void                 FGrepo_Uninit(gcli::FGrepo& grepo) __attribute__((nothrow));

// --- gcli.FGrepogitport
// create: gcli.FDb.grepogitport (Lary)
// global access: ind_grepogitport (Thash)
struct FGrepogitport { // gcli.FGrepogitport
    gcli::FGrepogitport*   ind_grepogitport_next;   // hash next
    algo::Smallstr50       grepogitport;            // grepo git host
    algo::cstring          port;                    // ssh port for config
    algo::Comment          comment;                 //
private:
    friend gcli::FGrepogitport& grepogitport_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGrepogitport* grepogitport_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 grepogitport_RemoveAll() __attribute__((nothrow));
    friend void                 grepogitport_RemoveLast() __attribute__((nothrow));
    FGrepogitport();
    ~FGrepogitport();
    FGrepogitport(const FGrepogitport&){ /*disallow copy constructor */}
    void operator =(const FGrepogitport&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 grepogitport_CopyOut(gcli::FGrepogitport &row, gclidb::Grepogitport &out) __attribute__((nothrow));
// Copy fields in to row
void                 grepogitport_CopyIn(gcli::FGrepogitport &row, gclidb::Grepogitport &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGrepogitport_Init(gcli::FGrepogitport& grepogitport);
void                 FGrepogitport_Uninit(gcli::FGrepogitport& grepogitport) __attribute__((nothrow));

// --- gcli.FGrepossh
// create: gcli.FDb.grepossh (Lary)
// global access: ind_grepossh (Thash)
struct FGrepossh { // gcli.FGrepossh
    gcli::FGrepossh*    ind_grepossh_next;   // hash next
    algo::Smallstr50    grepossh;            // grepo project/repo name
    algo::Smallstr200   sshid;               // ssh id key name for ssh config
    algo::Comment       comment;             //
private:
    friend gcli::FGrepossh&     grepossh_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGrepossh*     grepossh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 grepossh_RemoveAll() __attribute__((nothrow));
    friend void                 grepossh_RemoveLast() __attribute__((nothrow));
    FGrepossh();
    ~FGrepossh();
    FGrepossh(const FGrepossh&){ /*disallow copy constructor */}
    void operator =(const FGrepossh&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 grepossh_CopyOut(gcli::FGrepossh &row, gclidb::Grepossh &out) __attribute__((nothrow));
// Copy fields in to row
void                 grepossh_CopyIn(gcli::FGrepossh &row, gclidb::Grepossh &in) __attribute__((nothrow));

algo::cstring        name_Get(gcli::FGrepossh& grepossh) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGrepossh_Init(gcli::FGrepossh& grepossh);
void                 FGrepossh_Uninit(gcli::FGrepossh& grepossh) __attribute__((nothrow));

// --- gcli.FGstatet
// create: gcli.FDb.gstatet (Lary)
// global access: ind_gstatet (Thash)
struct FGstatet { // gcli.FGstatet
    gcli::FGstatet*    ind_gstatet_next;   // hash next
    algo::Smallstr50   gstatet;            //
    algo::cstring      state;              //
private:
    friend gcli::FGstatet&      gstatet_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGstatet*      gstatet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gstatet_RemoveAll() __attribute__((nothrow));
    friend void                 gstatet_RemoveLast() __attribute__((nothrow));
    FGstatet();
    ~FGstatet();
    FGstatet(const FGstatet&){ /*disallow copy constructor */}
    void operator =(const FGstatet&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gstatet_CopyOut(gcli::FGstatet &row, gclidb::Gstatet &out) __attribute__((nothrow));
// Copy fields in to row
void                 gstatet_CopyIn(gcli::FGstatet &row, gclidb::Gstatet &in) __attribute__((nothrow));

algo::Smallstr50     gtype_Get(gcli::FGstatet& gstatet) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     gstate_Get(gcli::FGstatet& gstatet) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGstatet_Init(gcli::FGstatet& gstatet);
void                 FGstatet_Uninit(gcli::FGstatet& gstatet) __attribute__((nothrow));

// --- gcli.FGtbl
// create: gcli.FDb.gtbl (Lary)
// global access: p_gtbl (Ptr)
// global access: ind_gtbl (Thash)
struct FGtbl { // gcli.FGtbl
    gcli::FGtbl*        ind_gtbl_next;     // hash next
    algo::Smallstr250   gtbl;              //
    algo::Comment       comment;           //
    algo::cstring       id;                //
    bool                set_as_dflt;       //   false
    bool                tail_dot;          //   false
    gcli::FGtblact**    c_gtblact_elems;   // array of pointers
    u32                 c_gtblact_n;       // array of pointers
    u32                 c_gtblact_max;     // capacity of allocated array
private:
    friend gcli::FGtbl&         gtbl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtbl*         gtbl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtbl_RemoveAll() __attribute__((nothrow));
    friend void                 gtbl_RemoveLast() __attribute__((nothrow));
    FGtbl();
    ~FGtbl();
    FGtbl(const FGtbl&){ /*disallow copy constructor */}
    void operator =(const FGtbl&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gtbl_CopyOut(gcli::FGtbl &row, gclidb::Gtbl &out) __attribute__((nothrow));
// Copy fields in to row
void                 gtbl_CopyIn(gcli::FGtbl &row, gclidb::Gtbl &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gtblact_EmptyQ(gcli::FGtbl& gtbl) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGtblact*      c_gtblact_Find(gcli::FGtbl& gtbl, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGtblact*> c_gtblact_Getary(gcli::FGtbl& gtbl) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gtblact_Insert(gcli::FGtbl& gtbl, gcli::FGtblact& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gtblact_InsertMaybe(gcli::FGtbl& gtbl, gcli::FGtblact& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gtblact_N(const gcli::FGtbl& gtbl) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gtblact_Remove(gcli::FGtbl& gtbl, gcli::FGtblact& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gtblact_RemoveAll(gcli::FGtbl& gtbl) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gtblact_Reserve(gcli::FGtbl& gtbl, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGtbl_Init(gcli::FGtbl& gtbl);
void                 gtbl_c_gtblact_curs_Reset(gtbl_c_gtblact_curs &curs, gcli::FGtbl &parent);
// cursor points to valid item
bool                 gtbl_c_gtblact_curs_ValidQ(gtbl_c_gtblact_curs &curs);
// proceed to next item
void                 gtbl_c_gtblact_curs_Next(gtbl_c_gtblact_curs &curs);
// item access
gcli::FGtblact&      gtbl_c_gtblact_curs_Access(gtbl_c_gtblact_curs &curs);
void                 FGtbl_Uninit(gcli::FGtbl& gtbl) __attribute__((nothrow));

// --- gcli.FGtblact
// create: gcli.FDb.gtblact (Lary)
// global access: ind_gtblact (Thash)
// global access: zd_gtblact (Llist)
// access: gcli.FGtbl.c_gtblact (Ptrary)
// access: gcli.FGtblact.step (Hook)
struct FGtblact { // gcli.FGtblact
    gcli::FGtblact*           ind_gtblact_next;        // hash next
    gcli::FGtblact*           zd_gtblact_next;         // zslist link; -1 means not-in-list
    gcli::FGtblact*           zd_gtblact_prev;         // previous element
    algo::Smallstr50          gtblact;                 //
    bool                      t;                       //   false
    bool                      e;                       //   false
    bool                      auth;                    //   false
    algo::cstring             id;                      //
    gcli::gtblact_step_hook   step;                    //   NULL  Pointer to a function
    gcli::FGtblactfld**       c_gtblactfld_elems;      // array of pointers
    u32                       c_gtblactfld_n;          // array of pointers
    u32                       c_gtblactfld_max;        // capacity of allocated array
    bool                      select;                  //   false
    algo::cstring             aliascmd;                //
    bool                      gtbl_c_gtblact_in_ary;   //   false  membership flag
private:
    friend gcli::FGtblact&      gtblact_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtblact*      gtblact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtblact_RemoveAll() __attribute__((nothrow));
    friend void                 gtblact_RemoveLast() __attribute__((nothrow));
    FGtblact();
    ~FGtblact();
    FGtblact(const FGtblact&){ /*disallow copy constructor */}
    void operator =(const FGtblact&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gtblact_CopyOut(gcli::FGtblact &row, gclidb::Gtblact &out) __attribute__((nothrow));
// Copy fields in to row
void                 gtblact_CopyIn(gcli::FGtblact &row, gclidb::Gtblact &in) __attribute__((nothrow));

algo::Smallstr250    gtbl_Get(gcli::FGtblact& gtblact) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     gact_Get(gcli::FGtblact& gtblact) __attribute__((__warn_unused_result__, nothrow));

// Invoke function by pointer
void                 step_Call(gcli::FGtblact& gtblact, gcli::FGtblact& arg) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gtblactfld_EmptyQ(gcli::FGtblact& gtblact) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGtblactfld*   c_gtblactfld_Find(gcli::FGtblact& gtblact, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGtblactfld*> c_gtblactfld_Getary(gcli::FGtblact& gtblact) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gtblactfld_Insert(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gtblactfld_InsertMaybe(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gtblactfld_N(const gcli::FGtblact& gtblact) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gtblactfld_Remove(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gtblactfld_RemoveAll(gcli::FGtblact& gtblact) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gtblactfld_Reserve(gcli::FGtblact& gtblact, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGtblact_Init(gcli::FGtblact& gtblact);
void                 gtblact_c_gtblactfld_curs_Reset(gtblact_c_gtblactfld_curs &curs, gcli::FGtblact &parent);
// cursor points to valid item
bool                 gtblact_c_gtblactfld_curs_ValidQ(gtblact_c_gtblactfld_curs &curs);
// proceed to next item
void                 gtblact_c_gtblactfld_curs_Next(gtblact_c_gtblactfld_curs &curs);
// item access
gcli::FGtblactfld&   gtblact_c_gtblactfld_curs_Access(gtblact_c_gtblactfld_curs &curs);
void                 FGtblact_Uninit(gcli::FGtblact& gtblact) __attribute__((nothrow));

// --- gcli.FGtblactfld
// create: gcli.FDb.gtblactfld (Lary)
// global access: ind_gtblactfld (Thash)
// access: gcli.FGfld.c_gtblactfld (Ptrary)
// access: gcli.FGtblact.c_gtblactfld (Ptrary)
struct FGtblactfld { // gcli.FGtblactfld
    gcli::FGtblactfld*   ind_gtblactfld_next;           // hash next
    algo::Smallstr50     gtblactfld;                    //
    algo::cstring        dflt;                          //
    bool                 field_name_dflt;               //   false
    bool                 optional;                      //   false
    bool                 regx;                          //   false
    algo::Comment        comment;                       //
    algo::cstring        uval;                          //
    algo::cstring        uval2;                         //
    bool                 select;                        //   false
    bool                 present;                       //   false
    bool                 update;                        //   false
    gcli::FGfld*         p_gfld;                        // reference to parent row
    bool                 gfld_c_gtblactfld_in_ary;      //   false  membership flag
    bool                 gtblact_c_gtblactfld_in_ary;   //   false  membership flag
private:
    friend gcli::FGtblactfld&   gtblactfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtblactfld*   gtblactfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtblactfld_RemoveAll() __attribute__((nothrow));
    friend void                 gtblactfld_RemoveLast() __attribute__((nothrow));
    FGtblactfld();
    ~FGtblactfld();
    FGtblactfld(const FGtblactfld&){ /*disallow copy constructor */}
    void operator =(const FGtblactfld&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gtblactfld_CopyOut(gcli::FGtblactfld &row, gclidb::Gtblactfld &out) __attribute__((nothrow));
// Copy fields in to row
void                 gtblactfld_CopyIn(gcli::FGtblactfld &row, gclidb::Gtblactfld &in) __attribute__((nothrow));

algo::Smallstr50     gtblact_Get(gcli::FGtblactfld& gtblactfld) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     field_Get(gcli::FGtblactfld& gtblactfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGtblactfld_Init(gcli::FGtblactfld& gtblactfld);
void                 FGtblactfld_Uninit(gcli::FGtblactfld& gtblactfld) __attribute__((nothrow));

// --- gcli.FGtype
// create: gcli.FDb.gtype (Lary)
// global access: p_gtype (Ptr)
// global access: ind_gtype (Thash)
// access: gcli.FGclicmdt.p_gtype (Upptr)
// access: gcli.FGtypeprefix.p_gtype (Upptr)
struct FGtype { // gcli.FGtype
    gcli::FGtype*          ind_gtype_next;        // hash next
    algo::Smallstr50       gtype;                 //
    algo::cstring          default_url;           //
    algo::Comment          comment;               //
    gcli::FGtypeh**        c_gtypeh_elems;        // array of pointers
    u32                    c_gtypeh_n;            // array of pointers
    u32                    c_gtypeh_max;          // capacity of allocated array
    gcli::FGtypeprefix**   c_gtypeprefix_elems;   // array of pointers
    u32                    c_gtypeprefix_n;       // array of pointers
    u32                    c_gtypeprefix_max;     // capacity of allocated array
private:
    friend gcli::FGtype&        gtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtype*        gtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtype_RemoveAll() __attribute__((nothrow));
    friend void                 gtype_RemoveLast() __attribute__((nothrow));
    FGtype();
    ~FGtype();
    FGtype(const FGtype&){ /*disallow copy constructor */}
    void operator =(const FGtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gtype_CopyOut(gcli::FGtype &row, gclidb::Gtype &out) __attribute__((nothrow));
// Copy fields in to row
void                 gtype_CopyIn(gcli::FGtype &row, gclidb::Gtype &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gtypeh_EmptyQ(gcli::FGtype& gtype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGtypeh*       c_gtypeh_Find(gcli::FGtype& gtype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGtypeh*> c_gtypeh_Getary(gcli::FGtype& gtype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gtypeh_Insert(gcli::FGtype& gtype, gcli::FGtypeh& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gtypeh_InsertMaybe(gcli::FGtype& gtype, gcli::FGtypeh& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gtypeh_N(const gcli::FGtype& gtype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gtypeh_Remove(gcli::FGtype& gtype, gcli::FGtypeh& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gtypeh_RemoveAll(gcli::FGtype& gtype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gtypeh_Reserve(gcli::FGtype& gtype, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gtypeprefix_EmptyQ(gcli::FGtype& gtype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FGtypeprefix*  c_gtypeprefix_Find(gcli::FGtype& gtype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FGtypeprefix*> c_gtypeprefix_Getary(gcli::FGtype& gtype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gtypeprefix_Insert(gcli::FGtype& gtype, gcli::FGtypeprefix& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gtypeprefix_InsertMaybe(gcli::FGtype& gtype, gcli::FGtypeprefix& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gtypeprefix_N(const gcli::FGtype& gtype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gtypeprefix_Remove(gcli::FGtype& gtype, gcli::FGtypeprefix& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gtypeprefix_RemoveAll(gcli::FGtype& gtype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gtypeprefix_Reserve(gcli::FGtype& gtype, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGtype_Init(gcli::FGtype& gtype);
void                 gtype_c_gtypeh_curs_Reset(gtype_c_gtypeh_curs &curs, gcli::FGtype &parent);
// cursor points to valid item
bool                 gtype_c_gtypeh_curs_ValidQ(gtype_c_gtypeh_curs &curs);
// proceed to next item
void                 gtype_c_gtypeh_curs_Next(gtype_c_gtypeh_curs &curs);
// item access
gcli::FGtypeh&       gtype_c_gtypeh_curs_Access(gtype_c_gtypeh_curs &curs);
void                 gtype_c_gtypeprefix_curs_Reset(gtype_c_gtypeprefix_curs &curs, gcli::FGtype &parent);
// cursor points to valid item
bool                 gtype_c_gtypeprefix_curs_ValidQ(gtype_c_gtypeprefix_curs &curs);
// proceed to next item
void                 gtype_c_gtypeprefix_curs_Next(gtype_c_gtypeprefix_curs &curs);
// item access
gcli::FGtypeprefix&  gtype_c_gtypeprefix_curs_Access(gtype_c_gtypeprefix_curs &curs);
void                 FGtype_Uninit(gcli::FGtype& gtype) __attribute__((nothrow));

// --- gcli.FGtypeh
// create: gcli.FDb.gtypeh (Lary)
// access: gcli.FGtype.c_gtypeh (Ptrary)
struct FGtypeh { // gcli.FGtypeh
    algo::Smallstr250   gtypeh;                  //
    algo::cstring       header;                  //
    bool                gtype_c_gtypeh_in_ary;   //   false  membership flag
private:
    friend gcli::FGtypeh&       gtypeh_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtypeh*       gtypeh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtypeh_RemoveAll() __attribute__((nothrow));
    friend void                 gtypeh_RemoveLast() __attribute__((nothrow));
    FGtypeh();
    ~FGtypeh();
    FGtypeh(const FGtypeh&){ /*disallow copy constructor */}
    void operator =(const FGtypeh&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gtypeh_CopyOut(gcli::FGtypeh &row, gclidb::Gtypeh &out) __attribute__((nothrow));
// Copy fields in to row
void                 gtypeh_CopyIn(gcli::FGtypeh &row, gclidb::Gtypeh &in) __attribute__((nothrow));

algo::Smallstr50     gtype_Get(gcli::FGtypeh& gtypeh) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        name_Get(gcli::FGtypeh& gtypeh) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGtypeh_Init(gcli::FGtypeh& gtypeh);
void                 FGtypeh_Uninit(gcli::FGtypeh& gtypeh) __attribute__((nothrow));

// --- gcli.FGtypeprefix
// create: gcli.FDb.gtypeprefix (Lary)
// access: gcli.FGtype.c_gtypeprefix (Ptrary)
struct FGtypeprefix { // gcli.FGtypeprefix
    algo::Smallstr50   gtypeprefix;                  //
    algo::Comment      comment;                      //
    gcli::FGtype*      p_gtype;                      // reference to parent row
    bool               gtype_c_gtypeprefix_in_ary;   //   false  membership flag
private:
    friend gcli::FGtypeprefix&  gtypeprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtypeprefix*  gtypeprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtypeprefix_RemoveAll() __attribute__((nothrow));
    friend void                 gtypeprefix_RemoveLast() __attribute__((nothrow));
    FGtypeprefix();
    ~FGtypeprefix();
    FGtypeprefix(const FGtypeprefix&){ /*disallow copy constructor */}
    void operator =(const FGtypeprefix&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gtypeprefix_CopyOut(gcli::FGtypeprefix &row, gclidb::Gtypeprefix &out) __attribute__((nothrow));
// Copy fields in to row
void                 gtypeprefix_CopyIn(gcli::FGtypeprefix &row, gclidb::Gtypeprefix &in) __attribute__((nothrow));

algo::Smallstr50     gtype_Get(gcli::FGtypeprefix& gtypeprefix) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        prefix_Get(gcli::FGtypeprefix& gtypeprefix) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGtypeprefix_Init(gcli::FGtypeprefix& gtypeprefix);
void                 FGtypeprefix_Uninit(gcli::FGtypeprefix& gtypeprefix) __attribute__((nothrow));

// --- gcli.FHttp
struct FHttp { // gcli.FHttp: HTTP request
    algo::cstring       request_uri;                  // URI of requested resource
    algo::cstring       request_content_type;         // Request content type
    algo::cstring       request_body;                 // Request body
    algo::cstring       response_status_line;         // Status line
    u32                 response_status_code;         //   0  Numeric status code
    u32                 request_method;               //   gcli_FHttp_request_method_GET  Request method
    algo::cstring       response_reason_phrase;       // Status message
    algo::cstring*      response_header_elems;        // pointer to elements
    u32                 response_header_n;            // number of elements in array
    u32                 response_header_max;          // max. capacity of array before realloc
    algo::cstring       response_content_type;        // Response content type
    algo::cstring       response_body;                // Response body
    bool                response_content_type_json;   //   false  Flag if response is JSON
    lib_json::FParser   response_json_parser;         // Json parser to parse response body on the fly
    u32                 request_body_sent_bytes;      //   0  Sent bytes in request body
    FHttp();
    ~FHttp();
private:
    // reftype Tary of gcli.FHttp.response_header prohibits copy
    // value field gcli.FHttp.response_json_parser is not copiable
    FHttp(const FHttp&){ /*disallow copy constructor */}
    void operator =(const FHttp&){ /*disallow direct assignment */}
};

// Get value of field as enum type
gcli_FHttp_request_method_Enum request_method_GetEnum(const gcli::FHttp& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 request_method_SetEnum(gcli::FHttp& parent, gcli_FHttp_request_method_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          request_method_ToCstr(const gcli::FHttp& parent) __attribute__((nothrow));
// Convert request_method to a string. First, attempt conversion to a known string.
// If no string matches, print request_method as a numeric value.
void                 request_method_Print(const gcli::FHttp& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 request_method_SetStrptrMaybe(gcli::FHttp& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 request_method_SetStrptr(gcli::FHttp& parent, algo::strptr rhs, gcli_FHttp_request_method_Enum dflt) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       response_header_Alloc(gcli::FHttp& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       response_header_AllocAt(gcli::FHttp& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> response_header_AllocN(gcli::FHttp& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 response_header_EmptyQ(gcli::FHttp& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       response_header_Find(gcli::FHttp& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> response_header_Getary(gcli::FHttp& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       response_header_Last(gcli::FHttp& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  response_header_Max(gcli::FHttp& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  response_header_N(const gcli::FHttp& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 response_header_Remove(gcli::FHttp& parent, u32 i) __attribute__((nothrow));
void                 response_header_RemoveAll(gcli::FHttp& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 response_header_RemoveLast(gcli::FHttp& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 response_header_Reserve(gcli::FHttp& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 response_header_AbsReserve(gcli::FHttp& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 response_header_Setary(gcli::FHttp& parent, gcli::FHttp &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       response_header_qFind(gcli::FHttp& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       response_header_qLast(gcli::FHttp& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  response_header_rowid_Get(gcli::FHttp& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> response_header_AllocNVal(gcli::FHttp& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));

// proceed to next item
void                 FHttp_response_header_curs_Next(FHttp_response_header_curs &curs);
void                 FHttp_response_header_curs_Reset(FHttp_response_header_curs &curs, gcli::FHttp &parent);
// cursor points to valid item
bool                 FHttp_response_header_curs_ValidQ(FHttp_response_header_curs &curs);
// item access
algo::cstring&       FHttp_response_header_curs_Access(FHttp_response_header_curs &curs);
// Set all fields to initial values.
void                 FHttp_Init(gcli::FHttp& parent);
void                 FHttp_Uninit(gcli::FHttp& parent) __attribute__((nothrow));
// print string representation of gcli::FHttp to string LHS, no header -- cprint:gcli.FHttp.String
void                 FHttp_Print(gcli::FHttp & row, algo::cstring &str) __attribute__((nothrow));

// --- gcli.FIssue
// create: gcli.FDb.issue (Lary)
// global access: ind_issue (Thash)
// access: gcli.FGclicmd.p_issue (Ptr)
struct FIssue { // gcli.FIssue
    gcli::FIssue*        ind_issue_next;      // hash next
    algo::Smallstr50     issue;               // Identifier. must be in form project.iid
    algo::Smallstr50     assignee;            // User the issue is assigned to
    algo::cstring        labels;              // issue labels - comma-separated list
    algo::cstring        milestone_iid;       // issue milestone, blank if none
    algo::cstring        milestone_num;       // issue milestone, blank if none
    algo::cstring        milestone;           // issue milestone name, blank if none
    algo::cstring        title;               // issue title
    algo::cstring        author;              // issue author
    algo::cstring        state;               // issue state
    algo::cstring        mr;                  // mr issue
    algo::cstring        description;         // issue description
    bool                 select;              //   false
    gcli::FMr*           p_mr_open;           // optional pointer
    gcli::FMrjob**       c_mrjob_elems;       // array of pointers
    u32                  c_mrjob_n;           // array of pointers
    u32                  c_mrjob_max;         // capacity of allocated array
    gcli::FIssuenote**   c_issuenote_elems;   // array of pointers
    u32                  c_issuenote_n;       // array of pointers
    u32                  c_issuenote_max;     // capacity of allocated array
private:
    friend gcli::FIssue&        issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FIssue*        issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issue_RemoveAll() __attribute__((nothrow));
    friend void                 issue_RemoveLast() __attribute__((nothrow));
    FIssue();
    ~FIssue();
    FIssue(const FIssue&){ /*disallow copy constructor */}
    void operator =(const FIssue&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 issue_CopyOut(gcli::FIssue &row, gclidb::Issue &out) __attribute__((nothrow));
// Copy fields in to row
void                 issue_CopyIn(gcli::FIssue &row, gclidb::Issue &in) __attribute__((nothrow));

algo::Smallstr50     project_Get(gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        iid_Get(gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_mrjob_EmptyQ(gcli::FIssue& issue) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FMrjob*        c_mrjob_Find(gcli::FIssue& issue, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FMrjob*> c_mrjob_Getary(gcli::FIssue& issue) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_mrjob_Insert(gcli::FIssue& issue, gcli::FMrjob& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_mrjob_InsertMaybe(gcli::FIssue& issue, gcli::FMrjob& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_mrjob_N(const gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_mrjob_Remove(gcli::FIssue& issue, gcli::FMrjob& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_mrjob_RemoveAll(gcli::FIssue& issue) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_mrjob_Reserve(gcli::FIssue& issue, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_issuenote_EmptyQ(gcli::FIssue& issue) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FIssuenote*    c_issuenote_Find(gcli::FIssue& issue, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FIssuenote*> c_issuenote_Getary(gcli::FIssue& issue) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_issuenote_Insert(gcli::FIssue& issue, gcli::FIssuenote& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_issuenote_InsertMaybe(gcli::FIssue& issue, gcli::FIssuenote& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_issuenote_N(const gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_issuenote_Remove(gcli::FIssue& issue, gcli::FIssuenote& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_issuenote_RemoveAll(gcli::FIssue& issue) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_issuenote_Reserve(gcli::FIssue& issue, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FIssue_Init(gcli::FIssue& issue);
void                 issue_c_mrjob_curs_Reset(issue_c_mrjob_curs &curs, gcli::FIssue &parent);
// cursor points to valid item
bool                 issue_c_mrjob_curs_ValidQ(issue_c_mrjob_curs &curs);
// proceed to next item
void                 issue_c_mrjob_curs_Next(issue_c_mrjob_curs &curs);
// item access
gcli::FMrjob&        issue_c_mrjob_curs_Access(issue_c_mrjob_curs &curs);
void                 issue_c_issuenote_curs_Reset(issue_c_issuenote_curs &curs, gcli::FIssue &parent);
// cursor points to valid item
bool                 issue_c_issuenote_curs_ValidQ(issue_c_issuenote_curs &curs);
// proceed to next item
void                 issue_c_issuenote_curs_Next(issue_c_issuenote_curs &curs);
// item access
gcli::FIssuenote&    issue_c_issuenote_curs_Access(issue_c_issuenote_curs &curs);
void                 FIssue_Uninit(gcli::FIssue& issue) __attribute__((nothrow));

// --- gcli.FIssuenote
// create: gcli.FDb.issuenote (Lary)
// global access: ind_issuenote (Thash)
// access: gcli.FIssue.c_issuenote (Ptrary)
struct FIssuenote { // gcli.FIssuenote
    gcli::FIssuenote*   ind_issuenote_next;         // hash next
    algo::Smallstr250   issuenote;                  // Identifier. must be in form issue.id
    algo::cstring       note;                       // Body of issue note
    algo::cstring       system;                     // System or user note (glab only)
    algo::cstring       author;                     // Authtor of issue note
    bool                select;                     //   false
    bool                issue_c_issuenote_in_ary;   //   false  membership flag
private:
    friend gcli::FIssuenote&    issuenote_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FIssuenote*    issuenote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issuenote_RemoveAll() __attribute__((nothrow));
    friend void                 issuenote_RemoveLast() __attribute__((nothrow));
    FIssuenote();
    ~FIssuenote();
    FIssuenote(const FIssuenote&){ /*disallow copy constructor */}
    void operator =(const FIssuenote&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 issuenote_CopyOut(gcli::FIssuenote &row, gclidb::Issuenote &out) __attribute__((nothrow));
// Copy fields in to row
void                 issuenote_CopyIn(gcli::FIssuenote &row, gclidb::Issuenote &in) __attribute__((nothrow));

algo::Smallstr50     issue_Get(gcli::FIssuenote& issuenote) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        nid_Get(gcli::FIssuenote& issuenote) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FIssuenote_Init(gcli::FIssuenote& issuenote);
void                 FIssuenote_Uninit(gcli::FIssuenote& issuenote) __attribute__((nothrow));

// --- gcli.FMilestone
// create: gcli.FDb.milestone (Lary)
// global access: ind_milestone (Thash)
struct FMilestone { // gcli.FMilestone
    gcli::FMilestone*   ind_milestone_next;   // hash next
    algo::Smallstr200   milestone;            // Milestone id
    algo::cstring       description;          // Milestone description
    algo::cstring       title;                // Milestone title
    bool                select;               //   false
private:
    friend gcli::FMilestone&    milestone_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMilestone*    milestone_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 milestone_RemoveAll() __attribute__((nothrow));
    friend void                 milestone_RemoveLast() __attribute__((nothrow));
    FMilestone();
    ~FMilestone();
    FMilestone(const FMilestone&){ /*disallow copy constructor */}
    void operator =(const FMilestone&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 milestone_CopyOut(gcli::FMilestone &row, gclidb::Milestone &out) __attribute__((nothrow));
// Copy fields in to row
void                 milestone_CopyIn(gcli::FMilestone &row, gclidb::Milestone &in) __attribute__((nothrow));

algo::Smallstr50     project_Get(gcli::FMilestone& milestone) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        iid_Get(gcli::FMilestone& milestone) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FMilestone_Init(gcli::FMilestone& milestone);
void                 FMilestone_Uninit(gcli::FMilestone& milestone) __attribute__((nothrow));
// print string representation of gcli::FMilestone to string LHS, no header -- cprint:gcli.FMilestone.String
void                 FMilestone_Print(gcli::FMilestone & row, algo::cstring &str) __attribute__((nothrow));

// --- gcli.FMr
// create: gcli.FDb.mr (Lary)
// global access: ind_mr (Thash)
// access: gcli.FGclicmd.p_mr (Ptr)
// access: gcli.FIssue.p_mr_open (Ptr)
struct FMr { // gcli.FMr
    gcli::FMr*          ind_mr_next;       // hash next
    algo::Smallstr150   mr;                // Identifier. must be in form project.iid
    algo::cstring       state;             // Mr state
    algo::cstring       title;             // Mr title
    algo::cstring       description;       // Mr description
    algo::cstring       source_branch;     // Source branch
    algo::cstring       source_repo;       // Source branch
    algo::cstring       reviewer;          // Reviewer username
    algo::cstring       author;            // Author username
    algo::Smallstr20    pipeline_status;   // Pipeline status
    algo::cstring       pipeline_id;       // Pipeline id
    algo::cstring       draft;             // Some draft status
    algo::cstring       node_id;           // Node id for graphQL
    gcli::FMrnote**     c_mrnote_elems;    // array of pointers
    u32                 c_mrnote_n;        // array of pointers
    u32                 c_mrnote_max;      // capacity of allocated array
    gcli::FMrjob**      c_mrjob_elems;     // array of pointers
    u32                 c_mrjob_n;         // array of pointers
    u32                 c_mrjob_max;       // capacity of allocated array
    bool                select;            //   false
private:
    friend gcli::FMr&           mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMr*           mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mr_RemoveAll() __attribute__((nothrow));
    friend void                 mr_RemoveLast() __attribute__((nothrow));
    FMr();
    ~FMr();
    FMr(const FMr&){ /*disallow copy constructor */}
    void operator =(const FMr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 mr_CopyOut(gcli::FMr &row, gclidb::Mr &out) __attribute__((nothrow));
// Copy fields in to row
void                 mr_CopyIn(gcli::FMr &row, gclidb::Mr &in) __attribute__((nothrow));

algo::Smallstr50     proj_Get(gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        iid_Get(gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_mrnote_EmptyQ(gcli::FMr& mr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FMrnote*       c_mrnote_Find(gcli::FMr& mr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FMrnote*> c_mrnote_Getary(gcli::FMr& mr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_mrnote_Insert(gcli::FMr& mr, gcli::FMrnote& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_mrnote_InsertMaybe(gcli::FMr& mr, gcli::FMrnote& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_mrnote_N(const gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_mrnote_Remove(gcli::FMr& mr, gcli::FMrnote& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_mrnote_RemoveAll(gcli::FMr& mr) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_mrnote_Reserve(gcli::FMr& mr, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_mrjob_EmptyQ(gcli::FMr& mr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gcli::FMrjob*        c_mrjob_Find(gcli::FMr& mr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gcli::FMrjob*> c_mrjob_Getary(gcli::FMr& mr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_mrjob_Insert(gcli::FMr& mr, gcli::FMrjob& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_mrjob_InsertMaybe(gcli::FMr& mr, gcli::FMrjob& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_mrjob_N(const gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_mrjob_Remove(gcli::FMr& mr, gcli::FMrjob& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_mrjob_RemoveAll(gcli::FMr& mr) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_mrjob_Reserve(gcli::FMr& mr, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FMr_Init(gcli::FMr& mr);
void                 mr_c_mrnote_curs_Reset(mr_c_mrnote_curs &curs, gcli::FMr &parent);
// cursor points to valid item
bool                 mr_c_mrnote_curs_ValidQ(mr_c_mrnote_curs &curs);
// proceed to next item
void                 mr_c_mrnote_curs_Next(mr_c_mrnote_curs &curs);
// item access
gcli::FMrnote&       mr_c_mrnote_curs_Access(mr_c_mrnote_curs &curs);
void                 mr_c_mrjob_curs_Reset(mr_c_mrjob_curs &curs, gcli::FMr &parent);
// cursor points to valid item
bool                 mr_c_mrjob_curs_ValidQ(mr_c_mrjob_curs &curs);
// proceed to next item
void                 mr_c_mrjob_curs_Next(mr_c_mrjob_curs &curs);
// item access
gcli::FMrjob&        mr_c_mrjob_curs_Access(mr_c_mrjob_curs &curs);
void                 FMr_Uninit(gcli::FMr& mr) __attribute__((nothrow));
// print string representation of gcli::FMr to string LHS, no header -- cprint:gcli.FMr.String
void                 FMr_Print(gcli::FMr & row, algo::cstring &str) __attribute__((nothrow));

// --- gcli.FMrjob
// create: gcli.FDb.mrjob (Lary)
// global access: ind_mrjob (Thash)
// access: gcli.FIssue.c_mrjob (Ptrary)
// access: gcli.FMr.c_mrjob (Ptrary)
struct FMrjob { // gcli.FMrjob
    gcli::FMrjob*       ind_mrjob_next;         // hash next
    algo::Smallstr250   mrjob;                  // Identifier. must be in form mr.id
    algo::Smallstr150   ref;                    // Mr portion of mr job
    algo::cstring       id;                     // Job ID
    algo::cstring       name;                   // Job name
    algo::cstring       pipeline_id;            // Pipeline id
    algo::cstring       status;                 //
    algo::cstring       runner;                 //
    bool                select;                 //   false
    bool                issue_c_mrjob_in_ary;   //   false  membership flag
    bool                mr_c_mrjob_in_ary;      //   false  membership flag
private:
    friend gcli::FMrjob&        mrjob_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMrjob*        mrjob_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mrjob_RemoveAll() __attribute__((nothrow));
    friend void                 mrjob_RemoveLast() __attribute__((nothrow));
    FMrjob();
    ~FMrjob();
    FMrjob(const FMrjob&){ /*disallow copy constructor */}
    void operator =(const FMrjob&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 mrjob_CopyOut(gcli::FMrjob &row, gclidb::Mrjob &out) __attribute__((nothrow));
// Copy fields in to row
void                 mrjob_CopyIn(gcli::FMrjob &row, gclidb::Mrjob &in) __attribute__((nothrow));

algo::Smallstr150    mr_Get(gcli::FMrjob& mrjob) __attribute__((__warn_unused_result__, nothrow));

algo::cstring        job_Get(gcli::FMrjob& mrjob) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FMrjob_Init(gcli::FMrjob& mrjob);
void                 FMrjob_Uninit(gcli::FMrjob& mrjob) __attribute__((nothrow));

// --- gcli.FMrnote
// create: gcli.FDb.mrnote (Lary)
// global access: ind_mrnote (Thash)
// access: gcli.FMr.c_mrnote (Ptrary)
struct FMrnote { // gcli.FMrnote
    gcli::FMrnote*      ind_mrnote_next;      // hash next
    algo::cstring       system;               // System or user note (glab only)
    algo::Smallstr250   mrnote;               // Identifier. must be in form issue.id
    algo::cstring       note;                 // Body of mr note
    algo::cstring       author;               // Authtor of mr note
    bool                select;               //   false
    bool                mr_c_mrnote_in_ary;   //   false  membership flag
private:
    friend gcli::FMrnote&       mrnote_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMrnote*       mrnote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mrnote_RemoveAll() __attribute__((nothrow));
    friend void                 mrnote_RemoveLast() __attribute__((nothrow));
    FMrnote();
    ~FMrnote();
    FMrnote(const FMrnote&){ /*disallow copy constructor */}
    void operator =(const FMrnote&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 mrnote_CopyOut(gcli::FMrnote &row, gclidb::Mrnote &out) __attribute__((nothrow));
// Copy fields in to row
void                 mrnote_CopyIn(gcli::FMrnote &row, gclidb::Mrnote &in) __attribute__((nothrow));

algo::cstring        nid_Get(gcli::FMrnote& mrnote) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr150    mr_Get(gcli::FMrnote& mrnote) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FMrnote_Init(gcli::FMrnote& mrnote);
void                 FMrnote_Uninit(gcli::FMrnote& mrnote) __attribute__((nothrow));

// --- gcli.FTuples
// create: gcli.FDb.tuples (Lary)
// access: gcli.FGclicmd.c_tuples (Ptrary)
struct FTuples { // gcli.FTuples
    algo::cstring   tuples;   //
private:
    friend gcli::FTuples&       tuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FTuples*       tuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tuples_RemoveAll() __attribute__((nothrow));
    friend void                 tuples_RemoveLast() __attribute__((nothrow));
    FTuples();
};


// --- gcli.FUser
// create: gcli.FDb.user (Lary)
// global access: ind_user (Thash)
struct FUser { // gcli.FUser
    gcli::FUser*       ind_user_next;   // hash next
    algo::Smallstr50   user;            //
    u32                id;              //   0
    algo::cstring      name;            //
    bool               select;          //   false
private:
    friend gcli::FUser&         user_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FUser*         user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 user_RemoveAll() __attribute__((nothrow));
    friend void                 user_RemoveLast() __attribute__((nothrow));
    FUser();
    ~FUser();
    FUser(const FUser&){ /*disallow copy constructor */}
    void operator =(const FUser&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 user_CopyOut(gcli::FUser &row, gclidb::User &out) __attribute__((nothrow));
// Copy fields in to row
void                 user_CopyIn(gcli::FUser &row, gclidb::User &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FUser_Init(gcli::FUser& user);
void                 FUser_Uninit(gcli::FUser& user) __attribute__((nothrow));

// --- gcli.FieldId
#pragma pack(push,1)
struct FieldId { // gcli.FieldId: Field read helper
    i32   value;   //   -1
    inline operator gcli_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(gcli_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
gcli_FieldIdEnum     value_GetEnum(const gcli::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(gcli::FieldId& parent, gcli_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const gcli::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const gcli::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(gcli::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(gcli::FieldId& parent, algo::strptr rhs, gcli_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(gcli::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of gcli::FieldId from an ascii string.
// The format of the string is the format of the gcli::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(gcli::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(gcli::FieldId& parent);
// print string representation of gcli::FieldId to string LHS, no header -- cprint:gcli.FieldId.String
void                 FieldId_Print(gcli::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- gcli.TableId
struct TableId { // gcli.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator gcli_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(gcli_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
gcli_TableIdEnum     value_GetEnum(const gcli::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(gcli::TableId& parent, gcli_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const gcli::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const gcli::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(gcli::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(gcli::TableId& parent, algo::strptr rhs, gcli_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(gcli::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of gcli::TableId from an ascii string.
// The format of the string is the format of the gcli::TableId's only field
bool                 TableId_ReadStrptrMaybe(gcli::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(gcli::TableId& parent);
// print string representation of gcli::TableId to string LHS, no header -- cprint:gcli.TableId.String
void                 TableId_Print(gcli::TableId & row, algo::cstring &str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace gcli { // gen:ns_curstext

struct _db_gtype_curs {// cursor
    typedef gcli::FGtype ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtype_curs(){ parent=NULL; index=0; }
};


struct _db_grepossh_curs {// cursor
    typedef gcli::FGrepossh ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_grepossh_curs(){ parent=NULL; index=0; }
};


struct _db_grepogitport_curs {// cursor
    typedef gcli::FGrepogitport ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_grepogitport_curs(){ parent=NULL; index=0; }
};


struct _db_githost_curs {// cursor
    typedef gcli::FGithost ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_githost_curs(){ parent=NULL; index=0; }
};


struct _db_gstatet_curs {// cursor
    typedef gcli::FGstatet ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gstatet_curs(){ parent=NULL; index=0; }
};


struct _db_gmethod_curs {// cursor
    typedef gcli::FGmethod ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gmethod_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdt_curs {// cursor
    typedef gcli::FGclicmdt ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdt_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdf_curs {// cursor
    typedef gcli::FGclicmdf ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdf_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdf2j_curs {// cursor
    typedef gcli::FGclicmdf2j ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdf2j_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmd_curs {// cursor
    typedef gcli::FGclicmd ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmd_curs(){ parent=NULL; index=0; }
};


struct _db_gtypeh_curs {// cursor
    typedef gcli::FGtypeh ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtypeh_curs(){ parent=NULL; index=0; }
};


struct _db_c_gclicmd_curs {// fcurs:gcli.FDb.c_gclicmd/curs
    typedef gcli::FGclicmd ChildType;
    gcli::FGclicmd** elems;
    u32 n_elems;
    u32 index;
    _db_c_gclicmd_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_gclicmdj2f_curs {// cursor
    typedef gcli::FGclicmdj2f ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdj2f_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdc_curs {// cursor
    typedef gcli::FGclicmdc ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdc_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdarg_curs {// cursor
    typedef gcli::FGclicmdarg ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdarg_curs(){ parent=NULL; index=0; }
};


struct _db_issue_curs {// cursor
    typedef gcli::FIssue ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_issue_curs(){ parent=NULL; index=0; }
};


struct _db_grepo_curs {// cursor
    typedef gcli::FGrepo ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_grepo_curs(){ parent=NULL; index=0; }
};


struct _db_tuples_curs {// cursor
    typedef gcli::FTuples ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_tuples_curs(){ parent=NULL; index=0; }
};


struct _db_issuenote_curs {// cursor
    typedef gcli::FIssuenote ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_issuenote_curs(){ parent=NULL; index=0; }
};


struct _db_mrjob_curs {// cursor
    typedef gcli::FMrjob ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_mrjob_curs(){ parent=NULL; index=0; }
};


struct _db_mrnote_curs {// cursor
    typedef gcli::FMrnote ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_mrnote_curs(){ parent=NULL; index=0; }
};


struct _db_user_curs {// cursor
    typedef gcli::FUser ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_user_curs(){ parent=NULL; index=0; }
};


struct _db_milestone_curs {// cursor
    typedef gcli::FMilestone ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_milestone_curs(){ parent=NULL; index=0; }
};


struct _db_mr_curs {// cursor
    typedef gcli::FMr ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_mr_curs(){ parent=NULL; index=0; }
};


struct _db_gtypeprefix_curs {// cursor
    typedef gcli::FGtypeprefix ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtypeprefix_curs(){ parent=NULL; index=0; }
};


struct _db_gtblact_curs {// cursor
    typedef gcli::FGtblact ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtblact_curs(){ parent=NULL; index=0; }
};


struct _db_gtblactfld_curs {// cursor
    typedef gcli::FGtblactfld ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtblactfld_curs(){ parent=NULL; index=0; }
};


struct _db_zd_gtblact_curs {// fcurs:gcli.FDb.zd_gtblact/curs
    typedef gcli::FGtblact ChildType;
    gcli::FGtblact* row;
    _db_zd_gtblact_curs() {
        row = NULL;
    }
};


struct _db_gfld_curs {// cursor
    typedef gcli::FGfld ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gfld_curs(){ parent=NULL; index=0; }
};


struct _db_c_gfld_curs {// fcurs:gcli.FDb.c_gfld/curs
    typedef gcli::FGfld ChildType;
    gcli::FGfld** elems;
    u32 n_elems;
    u32 index;
    _db_c_gfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_gtbl_curs {// cursor
    typedef gcli::FGtbl ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtbl_curs(){ parent=NULL; index=0; }
};


struct _db_gact_curs {// cursor
    typedef gcli::FGact ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gact_curs(){ parent=NULL; index=0; }
};


struct gclicmd_c_tuples_curs {// fcurs:gcli.FGclicmd.c_tuples/curs
    typedef gcli::FTuples ChildType;
    gcli::FTuples** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_tuples_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmd_c_gclicmdarg_curs {// fcurs:gcli.FGclicmd.c_gclicmdarg/curs
    typedef gcli::FGclicmdarg ChildType;
    gcli::FGclicmdarg** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_gclicmdarg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmd_c_gclicmdc_curs {// fcurs:gcli.FGclicmd.c_gclicmdc/curs
    typedef gcli::FGclicmdc ChildType;
    gcli::FGclicmdc** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_gclicmdc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmd_c_gclicmdf2j_curs {// fcurs:gcli.FGclicmd.c_gclicmdf2j/curs
    typedef gcli::FGclicmdf2j ChildType;
    gcli::FGclicmdf2j** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_gclicmdf2j_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmdc_c_gclicmdf_curs {// fcurs:gcli.FGclicmdc.c_gclicmdf/curs
    typedef gcli::FGclicmdf ChildType;
    gcli::FGclicmdf** elems;
    u32 n_elems;
    u32 index;
    gclicmdc_c_gclicmdf_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmdj2f_c_gclicmdf_curs {// fcurs:gcli.FGclicmdj2f.c_gclicmdf/curs
    typedef gcli::FGclicmdf ChildType;
    gcli::FGclicmdf** elems;
    u32 n_elems;
    u32 index;
    gclicmdj2f_c_gclicmdf_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gfld_c_gtblactfld_curs {// fcurs:gcli.FGfld.c_gtblactfld/curs
    typedef gcli::FGtblactfld ChildType;
    gcli::FGtblactfld** elems;
    u32 n_elems;
    u32 index;
    gfld_c_gtblactfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtbl_c_gtblact_curs {// fcurs:gcli.FGtbl.c_gtblact/curs
    typedef gcli::FGtblact ChildType;
    gcli::FGtblact** elems;
    u32 n_elems;
    u32 index;
    gtbl_c_gtblact_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtblact_c_gtblactfld_curs {// fcurs:gcli.FGtblact.c_gtblactfld/curs
    typedef gcli::FGtblactfld ChildType;
    gcli::FGtblactfld** elems;
    u32 n_elems;
    u32 index;
    gtblact_c_gtblactfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtype_c_gtypeh_curs {// fcurs:gcli.FGtype.c_gtypeh/curs
    typedef gcli::FGtypeh ChildType;
    gcli::FGtypeh** elems;
    u32 n_elems;
    u32 index;
    gtype_c_gtypeh_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtype_c_gtypeprefix_curs {// fcurs:gcli.FGtype.c_gtypeprefix/curs
    typedef gcli::FGtypeprefix ChildType;
    gcli::FGtypeprefix** elems;
    u32 n_elems;
    u32 index;
    gtype_c_gtypeprefix_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FHttp_response_header_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    FHttp_response_header_curs() { elems=NULL; n_elems=0; index=0; }
};


struct issue_c_mrjob_curs {// fcurs:gcli.FIssue.c_mrjob/curs
    typedef gcli::FMrjob ChildType;
    gcli::FMrjob** elems;
    u32 n_elems;
    u32 index;
    issue_c_mrjob_curs() { elems=NULL; n_elems=0; index=0; }
};


struct issue_c_issuenote_curs {// fcurs:gcli.FIssue.c_issuenote/curs
    typedef gcli::FIssuenote ChildType;
    gcli::FIssuenote** elems;
    u32 n_elems;
    u32 index;
    issue_c_issuenote_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mr_c_mrnote_curs {// fcurs:gcli.FMr.c_mrnote/curs
    typedef gcli::FMrnote ChildType;
    gcli::FMrnote** elems;
    u32 n_elems;
    u32 index;
    mr_c_mrnote_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mr_c_mrjob_curs {// fcurs:gcli.FMr.c_mrjob/curs
    typedef gcli::FMrjob ChildType;
    gcli::FMrjob** elems;
    u32 n_elems;
    u32 index;
    mr_c_mrjob_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace gcli { // gen:ns_func
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_graphql(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_issueadd(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_issuelist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_issuemod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_issuenote(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_issuesearch(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mraccept(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrlist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrlistdet(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrmod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrnote(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrnoteadd(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrnotemod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrreq(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrreview(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrreviewrm(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mrsearch(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_mslist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_noteadd(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_notemod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_repojob(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_repojobtrace(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_token2repos(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_user(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_userdet(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
void                 gclicmd_userlist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_help_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_repo_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_gitconfig_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_gitconfig_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_repo_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_reporemote_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_repo_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issue_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issue_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issue_start(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issue_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mrnote_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issuenote_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issuenote_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issuenote_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mrnote_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mrnote_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_milestone_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_user_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_start(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_approve(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_accept(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_needs_work(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mr_stop(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_mrjob_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issue_needs_work(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
void                 gtblact_issue_stop(gcli::FGtblact&);
} // gen:ns_func
int                  main(int argc, char **argv);
#if defined(WIN32)
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const gcli::trace &row);// cfmt:gcli.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FHttp &row);// cfmt:gcli.FHttp.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FMilestone &row);// cfmt:gcli.FMilestone.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FMr &row);// cfmt:gcli.FMr.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FieldId &row);// cfmt:gcli.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::TableId &row);// cfmt:gcli.TableId.String
}
