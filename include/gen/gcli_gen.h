//
// include/gen/gcli_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.h"
#include "include/gen/gclidb_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/lib_json_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- gcli_FHttp_request_method_Enum

enum gcli_FHttp_request_method_Enum {         // gcli.FHttp.request_method
     gcli_FHttp_request_method_GET      = 0   // GET
    ,gcli_FHttp_request_method_POST     = 1   // POST
    ,gcli_FHttp_request_method_PUT      = 2   // PUT
    ,gcli_FHttp_request_method_PATCH    = 3   // PATCH
    ,gcli_FHttp_request_method_DELETE   = 4   // DELETE
};

enum { gcli_FHttp_request_method_Enum_N = 5 };


// --- gcli_FieldIdEnum

enum gcli_FieldIdEnum {        // gcli.FieldId.value
     gcli_FieldId_value   = 0
};

enum { gcli_FieldIdEnum_N = 1 };


// --- gcli_TableIdEnum

enum gcli_TableIdEnum {                        // gcli.TableId.value
     gcli_TableId_gclidb_Gact           = 0    // gclidb.Gact -> gcli.FGact
    ,gcli_TableId_gclidb_gact           = 0    // gclidb.gact -> gcli.FGact
    ,gcli_TableId_gclidb_Gclicmdf2j     = 1    // gclidb.Gclicmdf2j -> gcli.FGclicmdf2j
    ,gcli_TableId_gclidb_gclicmdf2j     = 1    // gclidb.gclicmdf2j -> gcli.FGclicmdf2j
    ,gcli_TableId_gclidb_Gclicmdt       = 2    // gclidb.Gclicmdt -> gcli.FGclicmdt
    ,gcli_TableId_gclidb_gclicmdt       = 2    // gclidb.gclicmdt -> gcli.FGclicmdt
    ,gcli_TableId_gclidb_Gfld           = 3    // gclidb.Gfld -> gcli.FGfld
    ,gcli_TableId_gclidb_gfld           = 3    // gclidb.gfld -> gcli.FGfld
    ,gcli_TableId_gclidb_Gmethod        = 4    // gclidb.Gmethod -> gcli.FGmethod
    ,gcli_TableId_gclidb_gmethod        = 4    // gclidb.gmethod -> gcli.FGmethod
    ,gcli_TableId_gclidb_Grepo          = 5    // gclidb.Grepo -> gcli.FGrepo
    ,gcli_TableId_gclidb_grepo          = 5    // gclidb.grepo -> gcli.FGrepo
    ,gcli_TableId_gclidb_Grepogitport   = 6    // gclidb.Grepogitport -> gcli.FGrepogitport
    ,gcli_TableId_gclidb_grepogitport   = 6    // gclidb.grepogitport -> gcli.FGrepogitport
    ,gcli_TableId_gclidb_Grepossh       = 7    // gclidb.Grepossh -> gcli.FGrepossh
    ,gcli_TableId_gclidb_grepossh       = 7    // gclidb.grepossh -> gcli.FGrepossh
    ,gcli_TableId_gclidb_Gstatet        = 8    // gclidb.Gstatet -> gcli.FGstatet
    ,gcli_TableId_gclidb_gstatet        = 8    // gclidb.gstatet -> gcli.FGstatet
    ,gcli_TableId_gclidb_Gtbl           = 9    // gclidb.Gtbl -> gcli.FGtbl
    ,gcli_TableId_gclidb_gtbl           = 9    // gclidb.gtbl -> gcli.FGtbl
    ,gcli_TableId_gclidb_Gtblactfld     = 10   // gclidb.Gtblactfld -> gcli.FGtblactfld
    ,gcli_TableId_gclidb_gtblactfld     = 10   // gclidb.gtblactfld -> gcli.FGtblactfld
    ,gcli_TableId_gclidb_Gtype          = 11   // gclidb.Gtype -> gcli.FGtype
    ,gcli_TableId_gclidb_gtype          = 11   // gclidb.gtype -> gcli.FGtype
    ,gcli_TableId_gclidb_Gtypeh         = 12   // gclidb.Gtypeh -> gcli.FGtypeh
    ,gcli_TableId_gclidb_gtypeh         = 12   // gclidb.gtypeh -> gcli.FGtypeh
    ,gcli_TableId_gclidb_Gtypeprefix    = 13   // gclidb.Gtypeprefix -> gcli.FGtypeprefix
    ,gcli_TableId_gclidb_gtypeprefix    = 13   // gclidb.gtypeprefix -> gcli.FGtypeprefix
};

enum { gcli_TableIdEnum_N = 28 };

namespace gcli { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace gcli { // gen:ns_tclass_field
extern const char *gcli_help;
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace gclidb { struct Gact; }
namespace gclidb { struct Gclicmd; }
namespace gcli { struct FGclicmd; }
namespace gclidb { struct Gclicmdf2j; }
namespace gclidb { struct Gclicmdt; }
namespace gcli { struct FGtype; }
namespace gclidb { struct Gfld; }
namespace gclidb { struct Gmethod; }
namespace gclidb { struct Grepo; }
namespace gclidb { struct Grepogitport; }
namespace gclidb { struct Grepossh; }
namespace gclidb { struct Gstatet; }
namespace gclidb { struct Gtbl; }
namespace gclidb { struct Gtblact; }
namespace gclidb { struct Gtblactfld; }
namespace gcli { struct FGfld; }
namespace gclidb { struct Gtype; }
namespace gclidb { struct Gtypeh; }
namespace gclidb { struct Gtypeprefix; }
namespace gclidb { struct Issue; }
namespace gclidb { struct Issuenote; }
namespace gclidb { struct Milestone; }
namespace gclidb { struct Mr; }
namespace gclidb { struct Mrjob; }
namespace gclidb { struct Mrnote; }
namespace gclidb { struct User; }
namespace gcli { struct _db_gtype_curs; }
namespace gcli { struct _db_grepossh_curs; }
namespace gcli { struct _db_grepogitport_curs; }
namespace gcli { struct _db_githost_curs; }
namespace gcli { struct _db_gstatet_curs; }
namespace gcli { struct _db_gmethod_curs; }
namespace gcli { struct _db_gclicmdt_curs; }
namespace gcli { struct _db_gclicmdf_curs; }
namespace gcli { struct _db_gclicmdf2j_curs; }
namespace gcli { struct _db_gclicmd_curs; }
namespace gcli { struct _db_gtypeh_curs; }
namespace gcli { struct _db_c_gclicmd_curs; }
namespace gcli { struct _db_gclicmdj2f_curs; }
namespace gcli { struct _db_gclicmdc_curs; }
namespace gcli { struct _db_gclicmdarg_curs; }
namespace gcli { struct _db_issue_curs; }
namespace gcli { struct _db_grepo_curs; }
namespace gcli { struct _db_tuples_curs; }
namespace gcli { struct _db_issuenote_curs; }
namespace gcli { struct _db_mrjob_curs; }
namespace gcli { struct _db_mrnote_curs; }
namespace gcli { struct _db_user_curs; }
namespace gcli { struct _db_milestone_curs; }
namespace gcli { struct _db_mr_curs; }
namespace gcli { struct _db_gtypeprefix_curs; }
namespace gcli { struct _db_gtblact_curs; }
namespace gcli { struct _db_gtblactfld_curs; }
namespace gcli { struct _db_zd_gtblact_curs; }
namespace gcli { struct _db_gfld_curs; }
namespace gcli { struct _db_c_gfld_curs; }
namespace gcli { struct _db_gtbl_curs; }
namespace gcli { struct _db_gact_curs; }
namespace gcli { struct gclicmd_c_tuples_curs; }
namespace gcli { struct gclicmd_c_gclicmdarg_curs; }
namespace gcli { struct gclicmd_c_gclicmdc_curs; }
namespace gcli { struct gclicmd_c_gclicmdf2j_curs; }
namespace gcli { struct gclicmdc_c_gclicmdf_curs; }
namespace gcli { struct gclicmdj2f_c_gclicmdf_curs; }
namespace gcli { struct gfld_c_gtblactfld_curs; }
namespace gcli { struct gtbl_c_gtblact_curs; }
namespace gcli { struct gtblact_c_gtblactfld_curs; }
namespace gcli { struct gtype_c_gtypeh_curs; }
namespace gcli { struct gtype_c_gtypeprefix_curs; }
namespace gcli { struct FHttp_response_header_curs; }
namespace gcli { struct issue_c_mrjob_curs; }
namespace gcli { struct issue_c_issuenote_curs; }
namespace gcli { struct mr_c_mrnote_curs; }
namespace gcli { struct mr_c_mrjob_curs; }
namespace gcli { struct trace; }
namespace gcli { struct FDb; }
namespace gcli { struct FGact; }
namespace gcli { struct FGclicmdarg; }
namespace gcli { struct FGclicmdc; }
namespace gcli { struct FGclicmdf; }
namespace gcli { struct FGclicmdf2j; }
namespace gcli { struct FGclicmdj2f; }
namespace gcli { struct FGclicmdt; }
namespace gcli { struct FGithost; }
namespace gcli { struct FGmethod; }
namespace gcli { struct FGrepo; }
namespace gcli { struct FGrepogitport; }
namespace gcli { struct FGrepossh; }
namespace gcli { struct FGstatet; }
namespace gcli { struct FGtbl; }
namespace gcli { struct FGtblact; }
namespace gcli { struct FGtblactfld; }
namespace gcli { struct FGtypeh; }
namespace gcli { struct FGtypeprefix; }
namespace gcli { struct FHttp; }
namespace gcli { struct FIssue; }
namespace gcli { struct FIssuenote; }
namespace gcli { struct FMilestone; }
namespace gcli { struct FMr; }
namespace gcli { struct FMrjob; }
namespace gcli { struct FMrnote; }
namespace gcli { struct FTuples; }
namespace gcli { struct FUser; }
namespace gcli { struct FieldId; }
namespace gcli { struct TableId; }
namespace gcli { extern struct gcli::FDb _db; }
namespace gcli { // hook_fcn_typedef
    typedef void (*gclicmd_step_hook)(gcli::FGclicmd& arg); // hook:gcli.FGclicmd.step
    typedef void (*gtblact_step_hook)(gcli::FGtblact& arg); // hook:gcli.FGtblact.step
} // hook_decl
namespace gcli { // gen:ns_print_struct

// --- gcli.trace
#pragma pack(push,1)
struct trace { // gcli.trace
    // func:gcli.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)

// print string representation of ROW to string STR
// cfmt:gcli.trace.String  printfmt:Tuple
// func:gcli.trace..Print
void                 trace_Print(gcli::trace& row, algo::cstring& str) __attribute__((nothrow));

// --- gcli.FDb
// create: gcli.FDb._db (Global)
struct FDb { // gcli.FDb: In-memory database for gcli
    command::gcli           cmdline;                          //
    gcli::FGtype*           gtype_lary[32];                   // level array
    i32                     gtype_n;                          // number of elements in array
    gcli::FGrepossh*        grepossh_lary[32];                // level array
    i32                     grepossh_n;                       // number of elements in array
    gcli::FGrepogitport*    grepogitport_lary[32];            // level array
    i32                     grepogitport_n;                   // number of elements in array
    gcli::FGithost*         githost_lary[32];                 // level array
    i32                     githost_n;                        // number of elements in array
    bool                    need_auth;                        //   false
    gcli::FGstatet*         gstatet_lary[32];                 // level array
    i32                     gstatet_n;                        // number of elements in array
    gcli::FGmethod*         gmethod_lary[32];                 // level array
    i32                     gmethod_n;                        // number of elements in array
    gcli::FGclicmdt*        gclicmdt_lary[32];                // level array
    i32                     gclicmdt_n;                       // number of elements in array
    gcli::FGclicmdf*        gclicmdf_lary[32];                // level array
    i32                     gclicmdf_n;                       // number of elements in array
    gcli::FGclicmdf2j*      gclicmdf2j_lary[32];              // level array
    i32                     gclicmdf2j_n;                     // number of elements in array
    gcli::FGclicmd*         gclicmd_lary[32];                 // level array
    i32                     gclicmd_n;                        // number of elements in array
    gcli::FGtypeh*          gtypeh_lary[32];                  // level array
    i32                     gtypeh_n;                         // number of elements in array
    gcli::FGtype*           p_gtype;                          // optional pointer
    gcli::FGtbl*            p_gtbl;                           // optional pointer
    gclidb::Grepo           grepo_sel;                        //
    gcli::FGclicmd**        ind_gclicmd_buckets_elems;        // pointer to bucket array
    i32                     ind_gclicmd_buckets_n;            // number of elements in bucket array
    i32                     ind_gclicmd_n;                    // number of elements in the hash table
    gcli::FGclicmdf**       ind_gclicmdf_buckets_elems;       // pointer to bucket array
    i32                     ind_gclicmdf_buckets_n;           // number of elements in bucket array
    i32                     ind_gclicmdf_n;                   // number of elements in the hash table
    gcli::FGclicmdt**       ind_gclicmdt_buckets_elems;       // pointer to bucket array
    i32                     ind_gclicmdt_buckets_n;           // number of elements in bucket array
    i32                     ind_gclicmdt_n;                   // number of elements in the hash table
    gcli::FGmethod**        ind_gmethod_buckets_elems;        // pointer to bucket array
    i32                     ind_gmethod_buckets_n;            // number of elements in bucket array
    i32                     ind_gmethod_n;                    // number of elements in the hash table
    gcli::FGrepo**          ind_grepo_buckets_elems;          // pointer to bucket array
    i32                     ind_grepo_buckets_n;              // number of elements in bucket array
    i32                     ind_grepo_n;                      // number of elements in the hash table
    gcli::FIssue**          ind_issue_buckets_elems;          // pointer to bucket array
    i32                     ind_issue_buckets_n;              // number of elements in bucket array
    i32                     ind_issue_n;                      // number of elements in the hash table
    algo_lib::Regx          regx_repo;                        //   "%"  Sql Regx
    gcli::FGstatet**        ind_gstatet_buckets_elems;        // pointer to bucket array
    i32                     ind_gstatet_buckets_n;            // number of elements in bucket array
    i32                     ind_gstatet_n;                    // number of elements in the hash table
    gcli::FGithost**        ind_githost_buckets_elems;        // pointer to bucket array
    i32                     ind_githost_buckets_n;            // number of elements in bucket array
    i32                     ind_githost_n;                    // number of elements in the hash table
    gcli::FGrepogitport**   ind_grepogitport_buckets_elems;   // pointer to bucket array
    i32                     ind_grepogitport_buckets_n;       // number of elements in bucket array
    i32                     ind_grepogitport_n;               // number of elements in the hash table
    gcli::FGrepossh**       ind_grepossh_buckets_elems;       // pointer to bucket array
    i32                     ind_grepossh_buckets_n;           // number of elements in bucket array
    i32                     ind_grepossh_n;                   // number of elements in the hash table
    gcli::FGtype**          ind_gtype_buckets_elems;          // pointer to bucket array
    i32                     ind_gtype_buckets_n;              // number of elements in bucket array
    i32                     ind_gtype_n;                      // number of elements in the hash table
    algo::cstring           home;                             // User's HOME directory
    algo::cstring           auth_file;                        //
    algo::cstring           edit_file;                        //
    gcli::FGclicmd**        c_gclicmd_elems;                  // array of pointers
    u32                     c_gclicmd_n;                      // array of pointers
    u32                     c_gclicmd_max;                    // capacity of allocated array
    algo::cstring           unix_user;                        // UNIX user login name
    algo::cstring           editor;                           // Command line to invoke editor
    gcli::FGclicmdj2f*      gclicmdj2f_lary[32];              // level array
    i32                     gclicmdj2f_n;                     // number of elements in array
    gcli::FGclicmdc*        gclicmdc_lary[32];                // level array
    i32                     gclicmdc_n;                       // number of elements in array
    gcli::FGclicmdarg*      gclicmdarg_lary[32];              // level array
    i32                     gclicmdarg_n;                     // number of elements in array
    gcli::FGclicmdj2f**     ind_gclicmdj2f_buckets_elems;     // pointer to bucket array
    i32                     ind_gclicmdj2f_buckets_n;         // number of elements in bucket array
    i32                     ind_gclicmdj2f_n;                 // number of elements in the hash table
    gcli::FGclicmdarg**     ind_gclicmdarg_buckets_elems;     // pointer to bucket array
    i32                     ind_gclicmdarg_buckets_n;         // number of elements in bucket array
    i32                     ind_gclicmdarg_n;                 // number of elements in the hash table
    gcli::FGclicmdc**       ind_gclicmdc_buckets_elems;       // pointer to bucket array
    i32                     ind_gclicmdc_buckets_n;           // number of elements in bucket array
    i32                     ind_gclicmdc_n;                   // number of elements in the hash table
    gcli::FIssue*           issue_lary[32];                   // level array
    i32                     issue_n;                          // number of elements in array
    gcli::FGrepo*           grepo_lary[32];                   // level array
    i32                     grepo_n;                          // number of elements in array
    gcli::FTuples*          tuples_lary[32];                  // level array
    i32                     tuples_n;                         // number of elements in array
    gcli::FIssuenote*       issuenote_lary[32];               // level array
    i32                     issuenote_n;                      // number of elements in array
    gcli::FMrjob*           mrjob_lary[32];                   // level array
    i32                     mrjob_n;                          // number of elements in array
    gcli::FMrnote*          mrnote_lary[32];                  // level array
    i32                     mrnote_n;                         // number of elements in array
    gcli::FMrnote**         ind_mrnote_buckets_elems;         // pointer to bucket array
    i32                     ind_mrnote_buckets_n;             // number of elements in bucket array
    i32                     ind_mrnote_n;                     // number of elements in the hash table
    gcli::FIssuenote**      ind_issuenote_buckets_elems;      // pointer to bucket array
    i32                     ind_issuenote_buckets_n;          // number of elements in bucket array
    i32                     ind_issuenote_n;                  // number of elements in the hash table
    gcli::FMrjob**          ind_mrjob_buckets_elems;          // pointer to bucket array
    i32                     ind_mrjob_buckets_n;              // number of elements in bucket array
    i32                     ind_mrjob_n;                      // number of elements in the hash table
    gcli::FUser*            user_lary[32];                    // level array
    i32                     user_n;                           // number of elements in array
    gcli::FUser**           ind_user_buckets_elems;           // pointer to bucket array
    i32                     ind_user_buckets_n;               // number of elements in bucket array
    i32                     ind_user_n;                       // number of elements in the hash table
    gcli::FMr**             ind_mr_buckets_elems;             // pointer to bucket array
    i32                     ind_mr_buckets_n;                 // number of elements in bucket array
    i32                     ind_mr_n;                         // number of elements in the hash table
    gcli::FMilestone**      ind_milestone_buckets_elems;      // pointer to bucket array
    i32                     ind_milestone_buckets_n;          // number of elements in bucket array
    i32                     ind_milestone_n;                  // number of elements in the hash table
    gcli::FMilestone*       milestone_lary[32];               // level array
    i32                     milestone_n;                      // number of elements in array
    gcli::FMr*              mr_lary[32];                      // level array
    i32                     mr_n;                             // number of elements in array
    gcli::FGtypeprefix*     gtypeprefix_lary[32];             // level array
    i32                     gtypeprefix_n;                    // number of elements in array
    gcli::FGtblact*         gtblact_lary[32];                 // level array
    i32                     gtblact_n;                        // number of elements in array
    gcli::FGtblactfld*      gtblactfld_lary[32];              // level array
    i32                     gtblactfld_n;                     // number of elements in array
    gcli::FGtblact**        ind_gtblact_buckets_elems;        // pointer to bucket array
    i32                     ind_gtblact_buckets_n;            // number of elements in bucket array
    i32                     ind_gtblact_n;                    // number of elements in the hash table
    gcli::FGtblact*         zd_gtblact_head;                  // zero-terminated doubly linked list
    i32                     zd_gtblact_n;                     // zero-terminated doubly linked list
    gcli::FGtblact*         zd_gtblact_tail;                  // pointer to last element
    gcli::FGtblactfld**     ind_gtblactfld_buckets_elems;     // pointer to bucket array
    i32                     ind_gtblactfld_buckets_n;         // number of elements in bucket array
    i32                     ind_gtblactfld_n;                 // number of elements in the hash table
    gcli::FGfld*            gfld_lary[32];                    // level array
    i32                     gfld_n;                           // number of elements in array
    gcli::FGfld**           ind_gfld_buckets_elems;           // pointer to bucket array
    i32                     ind_gfld_buckets_n;               // number of elements in bucket array
    i32                     ind_gfld_n;                       // number of elements in the hash table
    gcli::FGfld**           c_gfld_elems;                     // array of pointers
    u32                     c_gfld_n;                         // array of pointers
    u32                     c_gfld_max;                       // capacity of allocated array
    gcli::FGtbl*            gtbl_lary[32];                    // level array
    i32                     gtbl_n;                           // number of elements in array
    gcli::FGtbl**           ind_gtbl_buckets_elems;           // pointer to bucket array
    i32                     ind_gtbl_buckets_n;               // number of elements in bucket array
    i32                     ind_gtbl_n;                       // number of elements in the hash table
    gcli::FGact*            gact_lary[32];                    // level array
    i32                     gact_n;                           // number of elements in array
    gcli::FGact**           ind_gact_buckets_elems;           // pointer to bucket array
    i32                     ind_gact_buckets_n;               // number of elements in bucket array
    i32                     ind_gact_n;                       // number of elements in the hash table
    gcli::trace             trace;                            //
};

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     gcli.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:gcli.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
// func:gcli.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:gcli.FDb._db.Step
void                 Step();
// Main function
// func:gcli.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:gcli.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:gcli.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:gcli.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:gcli.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load specified ssimfile.
// func:gcli.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:gcli.FDb._db.Steps
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gtype.Alloc
gcli::FGtype&        gtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gtype.AllocMaybe
gcli::FGtype*        gtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gtype.InsertMaybe
gcli::FGtype*        gtype_InsertMaybe(const gclidb::Gtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gtype.AllocMem
void*                gtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gtype.EmptyQ
inline bool          gtype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gtype.Find
inline gcli::FGtype* gtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gtype.Last
inline gcli::FGtype* gtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gtype.N
inline i32           gtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gtype.RemoveAll
void                 gtype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gtype.RemoveLast
void                 gtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gtype.qFind
inline gcli::FGtype& gtype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gtype.XrefMaybe
bool                 gtype_XrefMaybe(gcli::FGtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.grepossh.Alloc
gcli::FGrepossh&     grepossh_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.grepossh.AllocMaybe
gcli::FGrepossh*     grepossh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.grepossh.InsertMaybe
gcli::FGrepossh*     grepossh_InsertMaybe(const gclidb::Grepossh &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.grepossh.AllocMem
void*                grepossh_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.grepossh.EmptyQ
inline bool          grepossh_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.grepossh.Find
inline gcli::FGrepossh* grepossh_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.grepossh.Last
inline gcli::FGrepossh* grepossh_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.grepossh.N
inline i32           grepossh_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.grepossh.RemoveAll
void                 grepossh_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.grepossh.RemoveLast
void                 grepossh_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.grepossh.qFind
inline gcli::FGrepossh& grepossh_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.grepossh.XrefMaybe
bool                 grepossh_XrefMaybe(gcli::FGrepossh &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.grepogitport.Alloc
gcli::FGrepogitport& grepogitport_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.grepogitport.AllocMaybe
gcli::FGrepogitport* grepogitport_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.grepogitport.InsertMaybe
gcli::FGrepogitport* grepogitport_InsertMaybe(const gclidb::Grepogitport &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.grepogitport.AllocMem
void*                grepogitport_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.grepogitport.EmptyQ
inline bool          grepogitport_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.grepogitport.Find
inline gcli::FGrepogitport* grepogitport_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.grepogitport.Last
inline gcli::FGrepogitport* grepogitport_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.grepogitport.N
inline i32           grepogitport_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.grepogitport.RemoveAll
void                 grepogitport_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.grepogitport.RemoveLast
void                 grepogitport_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.grepogitport.qFind
inline gcli::FGrepogitport& grepogitport_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.grepogitport.XrefMaybe
bool                 grepogitport_XrefMaybe(gcli::FGrepogitport &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.githost.Alloc
gcli::FGithost&      githost_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.githost.AllocMaybe
gcli::FGithost*      githost_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.githost.AllocMem
void*                githost_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.githost.EmptyQ
inline bool          githost_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.githost.Find
inline gcli::FGithost* githost_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.githost.Last
inline gcli::FGithost* githost_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.githost.N
inline i32           githost_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.githost.RemoveAll
void                 githost_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.githost.RemoveLast
void                 githost_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.githost.qFind
inline gcli::FGithost& githost_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.githost.XrefMaybe
bool                 githost_XrefMaybe(gcli::FGithost &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gstatet.Alloc
gcli::FGstatet&      gstatet_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gstatet.AllocMaybe
gcli::FGstatet*      gstatet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gstatet.InsertMaybe
gcli::FGstatet*      gstatet_InsertMaybe(const gclidb::Gstatet &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gstatet.AllocMem
void*                gstatet_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gstatet.EmptyQ
inline bool          gstatet_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gstatet.Find
inline gcli::FGstatet* gstatet_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gstatet.Last
inline gcli::FGstatet* gstatet_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gstatet.N
inline i32           gstatet_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gstatet.RemoveAll
void                 gstatet_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gstatet.RemoveLast
void                 gstatet_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gstatet.qFind
inline gcli::FGstatet& gstatet_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gstatet.XrefMaybe
bool                 gstatet_XrefMaybe(gcli::FGstatet &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gmethod.Alloc
gcli::FGmethod&      gmethod_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gmethod.AllocMaybe
gcli::FGmethod*      gmethod_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gmethod.InsertMaybe
gcli::FGmethod*      gmethod_InsertMaybe(const gclidb::Gmethod &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gmethod.AllocMem
void*                gmethod_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gmethod.EmptyQ
inline bool          gmethod_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gmethod.Find
inline gcli::FGmethod* gmethod_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gmethod.Last
inline gcli::FGmethod* gmethod_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gmethod.N
inline i32           gmethod_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gmethod.RemoveAll
void                 gmethod_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gmethod.RemoveLast
void                 gmethod_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gmethod.qFind
inline gcli::FGmethod& gmethod_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gmethod.XrefMaybe
bool                 gmethod_XrefMaybe(gcli::FGmethod &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmdt.Alloc
gcli::FGclicmdt&     gclicmdt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmdt.AllocMaybe
gcli::FGclicmdt*     gclicmdt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gclicmdt.InsertMaybe
gcli::FGclicmdt*     gclicmdt_InsertMaybe(const gclidb::Gclicmdt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmdt.AllocMem
void*                gclicmdt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmdt.EmptyQ
inline bool          gclicmdt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmdt.Find
inline gcli::FGclicmdt* gclicmdt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmdt.Last
inline gcli::FGclicmdt* gclicmdt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmdt.N
inline i32           gclicmdt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmdt.RemoveAll
void                 gclicmdt_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmdt.RemoveLast
void                 gclicmdt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmdt.qFind
inline gcli::FGclicmdt& gclicmdt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmdt.XrefMaybe
bool                 gclicmdt_XrefMaybe(gcli::FGclicmdt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmdf.Alloc
gcli::FGclicmdf&     gclicmdf_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmdf.AllocMaybe
gcli::FGclicmdf*     gclicmdf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmdf.AllocMem
void*                gclicmdf_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmdf.EmptyQ
inline bool          gclicmdf_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmdf.Find
inline gcli::FGclicmdf* gclicmdf_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmdf.Last
inline gcli::FGclicmdf* gclicmdf_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmdf.N
inline i32           gclicmdf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmdf.RemoveAll
void                 gclicmdf_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmdf.RemoveLast
void                 gclicmdf_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmdf.qFind
inline gcli::FGclicmdf& gclicmdf_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmdf.XrefMaybe
bool                 gclicmdf_XrefMaybe(gcli::FGclicmdf &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmdf2j.Alloc
gcli::FGclicmdf2j&   gclicmdf2j_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmdf2j.AllocMaybe
gcli::FGclicmdf2j*   gclicmdf2j_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gclicmdf2j.InsertMaybe
gcli::FGclicmdf2j*   gclicmdf2j_InsertMaybe(const gclidb::Gclicmdf2j &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmdf2j.AllocMem
void*                gclicmdf2j_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmdf2j.EmptyQ
inline bool          gclicmdf2j_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmdf2j.Find
inline gcli::FGclicmdf2j* gclicmdf2j_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmdf2j.Last
inline gcli::FGclicmdf2j* gclicmdf2j_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmdf2j.N
inline i32           gclicmdf2j_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmdf2j.RemoveAll
void                 gclicmdf2j_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmdf2j.RemoveLast
void                 gclicmdf2j_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmdf2j.qFind
inline gcli::FGclicmdf2j& gclicmdf2j_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmdf2j.XrefMaybe
bool                 gclicmdf2j_XrefMaybe(gcli::FGclicmdf2j &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmd.Alloc
gcli::FGclicmd&      gclicmd_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmd.AllocMaybe
gcli::FGclicmd*      gclicmd_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gclicmd.InsertMaybe
gcli::FGclicmd*      gclicmd_InsertMaybe(const gclidb::Gclicmd &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmd.AllocMem
void*                gclicmd_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmd.EmptyQ
inline bool          gclicmd_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmd.Find
inline gcli::FGclicmd* gclicmd_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmd.Last
inline gcli::FGclicmd* gclicmd_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmd.N
inline i32           gclicmd_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmd.RemoveAll
void                 gclicmd_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmd.RemoveLast
void                 gclicmd_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmd.qFind
inline gcli::FGclicmd& gclicmd_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmd.XrefMaybe
bool                 gclicmd_XrefMaybe(gcli::FGclicmd &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gtypeh.Alloc
gcli::FGtypeh&       gtypeh_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gtypeh.AllocMaybe
gcli::FGtypeh*       gtypeh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gtypeh.InsertMaybe
gcli::FGtypeh*       gtypeh_InsertMaybe(const gclidb::Gtypeh &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gtypeh.AllocMem
void*                gtypeh_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gtypeh.EmptyQ
inline bool          gtypeh_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gtypeh.Find
inline gcli::FGtypeh* gtypeh_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gtypeh.Last
inline gcli::FGtypeh* gtypeh_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gtypeh.N
inline i32           gtypeh_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gtypeh.RemoveAll
void                 gtypeh_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gtypeh.RemoveLast
void                 gtypeh_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gtypeh.qFind
inline gcli::FGtypeh& gtypeh_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gtypeh.XrefMaybe
bool                 gtypeh_XrefMaybe(gcli::FGtypeh &row);

// Return true if hash is empty
// func:gcli.FDb.ind_gclicmd.EmptyQ
inline bool          ind_gclicmd_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gclicmd.Find
gcli::FGclicmd*      ind_gclicmd_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gclicmd.FindX
gcli::FGclicmd&      ind_gclicmd_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gclicmd.GetOrCreate
gcli::FGclicmd&      ind_gclicmd_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gclicmd.N
inline i32           ind_gclicmd_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gclicmd.InsertMaybe
bool                 ind_gclicmd_InsertMaybe(gcli::FGclicmd& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gclicmd.Remove
void                 ind_gclicmd_Remove(gcli::FGclicmd& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gclicmd.Reserve
void                 ind_gclicmd_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gclicmdf.EmptyQ
inline bool          ind_gclicmdf_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gclicmdf.Find
gcli::FGclicmdf*     ind_gclicmdf_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gclicmdf.FindX
gcli::FGclicmdf&     ind_gclicmdf_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gclicmdf.GetOrCreate
gcli::FGclicmdf&     ind_gclicmdf_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gclicmdf.N
inline i32           ind_gclicmdf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gclicmdf.InsertMaybe
bool                 ind_gclicmdf_InsertMaybe(gcli::FGclicmdf& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gclicmdf.Remove
void                 ind_gclicmdf_Remove(gcli::FGclicmdf& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gclicmdf.Reserve
void                 ind_gclicmdf_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gclicmdt.EmptyQ
inline bool          ind_gclicmdt_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gclicmdt.Find
gcli::FGclicmdt*     ind_gclicmdt_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gclicmdt.FindX
gcli::FGclicmdt&     ind_gclicmdt_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:gcli.FDb.ind_gclicmdt.N
inline i32           ind_gclicmdt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gclicmdt.InsertMaybe
bool                 ind_gclicmdt_InsertMaybe(gcli::FGclicmdt& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gclicmdt.Remove
void                 ind_gclicmdt_Remove(gcli::FGclicmdt& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gclicmdt.Reserve
void                 ind_gclicmdt_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gmethod.EmptyQ
inline bool          ind_gmethod_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gmethod.Find
gcli::FGmethod*      ind_gmethod_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gmethod.FindX
gcli::FGmethod&      ind_gmethod_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gmethod.GetOrCreate
gcli::FGmethod&      ind_gmethod_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gmethod.N
inline i32           ind_gmethod_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gmethod.InsertMaybe
bool                 ind_gmethod_InsertMaybe(gcli::FGmethod& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gmethod.Remove
void                 ind_gmethod_Remove(gcli::FGmethod& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gmethod.Reserve
void                 ind_gmethod_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_grepo.EmptyQ
inline bool          ind_grepo_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_grepo.Find
gcli::FGrepo*        ind_grepo_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_grepo.FindX
gcli::FGrepo&        ind_grepo_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_grepo.GetOrCreate
gcli::FGrepo&        ind_grepo_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_grepo.N
inline i32           ind_grepo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_grepo.InsertMaybe
bool                 ind_grepo_InsertMaybe(gcli::FGrepo& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_grepo.Remove
void                 ind_grepo_Remove(gcli::FGrepo& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_grepo.Reserve
void                 ind_grepo_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_issue.EmptyQ
inline bool          ind_issue_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_issue.Find
gcli::FIssue*        ind_issue_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_issue.FindX
gcli::FIssue&        ind_issue_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_issue.GetOrCreate
gcli::FIssue&        ind_issue_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_issue.N
inline i32           ind_issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_issue.InsertMaybe
bool                 ind_issue_InsertMaybe(gcli::FIssue& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_issue.Remove
void                 ind_issue_Remove(gcli::FIssue& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_issue.Reserve
void                 ind_issue_Reserve(int n) __attribute__((nothrow));

// Print back to string
// func:gcli.FDb.regx_repo.Print
void                 regx_repo_Print(algo::cstring &out) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gstatet.EmptyQ
inline bool          ind_gstatet_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gstatet.Find
gcli::FGstatet*      ind_gstatet_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gstatet.FindX
gcli::FGstatet&      ind_gstatet_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gstatet.GetOrCreate
gcli::FGstatet&      ind_gstatet_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gstatet.N
inline i32           ind_gstatet_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gstatet.InsertMaybe
bool                 ind_gstatet_InsertMaybe(gcli::FGstatet& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gstatet.Remove
void                 ind_gstatet_Remove(gcli::FGstatet& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gstatet.Reserve
void                 ind_gstatet_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_githost.EmptyQ
inline bool          ind_githost_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_githost.Find
gcli::FGithost*      ind_githost_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_githost.FindX
gcli::FGithost&      ind_githost_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_githost.GetOrCreate
gcli::FGithost&      ind_githost_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_githost.N
inline i32           ind_githost_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_githost.InsertMaybe
bool                 ind_githost_InsertMaybe(gcli::FGithost& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_githost.Remove
void                 ind_githost_Remove(gcli::FGithost& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_githost.Reserve
void                 ind_githost_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_grepogitport.EmptyQ
inline bool          ind_grepogitport_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_grepogitport.Find
gcli::FGrepogitport* ind_grepogitport_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_grepogitport.FindX
gcli::FGrepogitport& ind_grepogitport_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_grepogitport.GetOrCreate
gcli::FGrepogitport& ind_grepogitport_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_grepogitport.N
inline i32           ind_grepogitport_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_grepogitport.InsertMaybe
bool                 ind_grepogitport_InsertMaybe(gcli::FGrepogitport& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_grepogitport.Remove
void                 ind_grepogitport_Remove(gcli::FGrepogitport& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_grepogitport.Reserve
void                 ind_grepogitport_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_grepossh.EmptyQ
inline bool          ind_grepossh_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_grepossh.Find
gcli::FGrepossh*     ind_grepossh_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_grepossh.FindX
gcli::FGrepossh&     ind_grepossh_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_grepossh.GetOrCreate
gcli::FGrepossh&     ind_grepossh_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_grepossh.N
inline i32           ind_grepossh_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_grepossh.InsertMaybe
bool                 ind_grepossh_InsertMaybe(gcli::FGrepossh& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_grepossh.Remove
void                 ind_grepossh_Remove(gcli::FGrepossh& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_grepossh.Reserve
void                 ind_grepossh_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gtype.EmptyQ
inline bool          ind_gtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gtype.Find
gcli::FGtype*        ind_gtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gtype.FindX
gcli::FGtype&        ind_gtype_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gtype.GetOrCreate
gcli::FGtype&        ind_gtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gtype.N
inline i32           ind_gtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gtype.InsertMaybe
bool                 ind_gtype_InsertMaybe(gcli::FGtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gtype.Remove
void                 ind_gtype_Remove(gcli::FGtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gtype.Reserve
void                 ind_gtype_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FDb.c_gclicmd.EmptyQ
inline bool          c_gclicmd_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.c_gclicmd.Find
inline gcli::FGclicmd* c_gclicmd_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FDb.c_gclicmd.Getary
inline algo::aryptr<gcli::FGclicmd*> c_gclicmd_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FDb.c_gclicmd.Insert
void                 c_gclicmd_Insert(gcli::FGclicmd& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FDb.c_gclicmd.InsertMaybe
bool                 c_gclicmd_InsertMaybe(gcli::FGclicmd& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FDb.c_gclicmd.N
inline i32           c_gclicmd_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FDb.c_gclicmd.Remove
void                 c_gclicmd_Remove(gcli::FGclicmd& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FDb.c_gclicmd.RemoveAll
inline void          c_gclicmd_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FDb.c_gclicmd.Reserve
void                 c_gclicmd_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FDb.c_gclicmd.qFind
inline gcli::FGclicmd& c_gclicmd_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FDb.c_gclicmd.InAryQ
inline bool          c_gclicmd_InAryQ(gcli::FGclicmd& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FDb.c_gclicmd.qLast
inline gcli::FGclicmd& c_gclicmd_qLast() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmdj2f.Alloc
gcli::FGclicmdj2f&   gclicmdj2f_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmdj2f.AllocMaybe
gcli::FGclicmdj2f*   gclicmdj2f_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmdj2f.AllocMem
void*                gclicmdj2f_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmdj2f.EmptyQ
inline bool          gclicmdj2f_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmdj2f.Find
inline gcli::FGclicmdj2f* gclicmdj2f_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmdj2f.Last
inline gcli::FGclicmdj2f* gclicmdj2f_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmdj2f.N
inline i32           gclicmdj2f_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmdj2f.RemoveAll
void                 gclicmdj2f_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmdj2f.RemoveLast
void                 gclicmdj2f_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmdj2f.qFind
inline gcli::FGclicmdj2f& gclicmdj2f_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmdj2f.XrefMaybe
bool                 gclicmdj2f_XrefMaybe(gcli::FGclicmdj2f &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmdc.Alloc
gcli::FGclicmdc&     gclicmdc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmdc.AllocMaybe
gcli::FGclicmdc*     gclicmdc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmdc.AllocMem
void*                gclicmdc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmdc.EmptyQ
inline bool          gclicmdc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmdc.Find
inline gcli::FGclicmdc* gclicmdc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmdc.Last
inline gcli::FGclicmdc* gclicmdc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmdc.N
inline i32           gclicmdc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmdc.RemoveAll
void                 gclicmdc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmdc.RemoveLast
void                 gclicmdc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmdc.qFind
inline gcli::FGclicmdc& gclicmdc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmdc.XrefMaybe
bool                 gclicmdc_XrefMaybe(gcli::FGclicmdc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gclicmdarg.Alloc
gcli::FGclicmdarg&   gclicmdarg_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gclicmdarg.AllocMaybe
gcli::FGclicmdarg*   gclicmdarg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gclicmdarg.AllocMem
void*                gclicmdarg_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gclicmdarg.EmptyQ
inline bool          gclicmdarg_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gclicmdarg.Find
inline gcli::FGclicmdarg* gclicmdarg_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gclicmdarg.Last
inline gcli::FGclicmdarg* gclicmdarg_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gclicmdarg.N
inline i32           gclicmdarg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gclicmdarg.RemoveAll
void                 gclicmdarg_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gclicmdarg.RemoveLast
void                 gclicmdarg_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gclicmdarg.qFind
inline gcli::FGclicmdarg& gclicmdarg_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gclicmdarg.XrefMaybe
bool                 gclicmdarg_XrefMaybe(gcli::FGclicmdarg &row);

// Return true if hash is empty
// func:gcli.FDb.ind_gclicmdj2f.EmptyQ
inline bool          ind_gclicmdj2f_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gclicmdj2f.Find
gcli::FGclicmdj2f*   ind_gclicmdj2f_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gclicmdj2f.FindX
gcli::FGclicmdj2f&   ind_gclicmdj2f_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gclicmdj2f.GetOrCreate
gcli::FGclicmdj2f&   ind_gclicmdj2f_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gclicmdj2f.N
inline i32           ind_gclicmdj2f_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gclicmdj2f.InsertMaybe
bool                 ind_gclicmdj2f_InsertMaybe(gcli::FGclicmdj2f& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gclicmdj2f.Remove
void                 ind_gclicmdj2f_Remove(gcli::FGclicmdj2f& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gclicmdj2f.Reserve
void                 ind_gclicmdj2f_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gclicmdarg.EmptyQ
inline bool          ind_gclicmdarg_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gclicmdarg.Find
gcli::FGclicmdarg*   ind_gclicmdarg_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gclicmdarg.FindX
gcli::FGclicmdarg&   ind_gclicmdarg_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gclicmdarg.GetOrCreate
gcli::FGclicmdarg&   ind_gclicmdarg_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gclicmdarg.N
inline i32           ind_gclicmdarg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gclicmdarg.InsertMaybe
bool                 ind_gclicmdarg_InsertMaybe(gcli::FGclicmdarg& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gclicmdarg.Remove
void                 ind_gclicmdarg_Remove(gcli::FGclicmdarg& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gclicmdarg.Reserve
void                 ind_gclicmdarg_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gclicmdc.EmptyQ
inline bool          ind_gclicmdc_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gclicmdc.Find
gcli::FGclicmdc*     ind_gclicmdc_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gclicmdc.FindX
gcli::FGclicmdc&     ind_gclicmdc_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gclicmdc.GetOrCreate
gcli::FGclicmdc&     ind_gclicmdc_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gclicmdc.N
inline i32           ind_gclicmdc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gclicmdc.InsertMaybe
bool                 ind_gclicmdc_InsertMaybe(gcli::FGclicmdc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gclicmdc.Remove
void                 ind_gclicmdc_Remove(gcli::FGclicmdc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gclicmdc.Reserve
void                 ind_gclicmdc_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.issue.Alloc
gcli::FIssue&        issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.issue.AllocMaybe
gcli::FIssue*        issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.issue.InsertMaybe
gcli::FIssue*        issue_InsertMaybe(const gclidb::Issue &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.issue.AllocMem
void*                issue_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.issue.EmptyQ
inline bool          issue_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.issue.Find
inline gcli::FIssue* issue_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.issue.Last
inline gcli::FIssue* issue_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.issue.N
inline i32           issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.issue.RemoveAll
void                 issue_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.issue.RemoveLast
void                 issue_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.issue.qFind
inline gcli::FIssue& issue_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.issue.XrefMaybe
bool                 issue_XrefMaybe(gcli::FIssue &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.grepo.Alloc
gcli::FGrepo&        grepo_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.grepo.AllocMaybe
gcli::FGrepo*        grepo_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.grepo.InsertMaybe
gcli::FGrepo*        grepo_InsertMaybe(const gclidb::Grepo &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.grepo.AllocMem
void*                grepo_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.grepo.EmptyQ
inline bool          grepo_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.grepo.Find
inline gcli::FGrepo* grepo_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.grepo.Last
inline gcli::FGrepo* grepo_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.grepo.N
inline i32           grepo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.grepo.RemoveAll
void                 grepo_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.grepo.RemoveLast
void                 grepo_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.grepo.qFind
inline gcli::FGrepo& grepo_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.grepo.XrefMaybe
bool                 grepo_XrefMaybe(gcli::FGrepo &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.tuples.Alloc
gcli::FTuples&       tuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.tuples.AllocMaybe
gcli::FTuples*       tuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.tuples.AllocMem
void*                tuples_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.tuples.EmptyQ
inline bool          tuples_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.tuples.Find
inline gcli::FTuples* tuples_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.tuples.Last
inline gcli::FTuples* tuples_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.tuples.N
inline i32           tuples_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.tuples.RemoveAll
void                 tuples_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.tuples.RemoveLast
void                 tuples_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.tuples.qFind
inline gcli::FTuples& tuples_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.tuples.XrefMaybe
bool                 tuples_XrefMaybe(gcli::FTuples &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.issuenote.Alloc
gcli::FIssuenote&    issuenote_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.issuenote.AllocMaybe
gcli::FIssuenote*    issuenote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.issuenote.InsertMaybe
gcli::FIssuenote*    issuenote_InsertMaybe(const gclidb::Issuenote &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.issuenote.AllocMem
void*                issuenote_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.issuenote.EmptyQ
inline bool          issuenote_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.issuenote.Find
inline gcli::FIssuenote* issuenote_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.issuenote.Last
inline gcli::FIssuenote* issuenote_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.issuenote.N
inline i32           issuenote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.issuenote.RemoveAll
void                 issuenote_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.issuenote.RemoveLast
void                 issuenote_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.issuenote.qFind
inline gcli::FIssuenote& issuenote_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.issuenote.XrefMaybe
bool                 issuenote_XrefMaybe(gcli::FIssuenote &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.mrjob.Alloc
gcli::FMrjob&        mrjob_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.mrjob.AllocMaybe
gcli::FMrjob*        mrjob_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.mrjob.InsertMaybe
gcli::FMrjob*        mrjob_InsertMaybe(const gclidb::Mrjob &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.mrjob.AllocMem
void*                mrjob_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.mrjob.EmptyQ
inline bool          mrjob_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.mrjob.Find
inline gcli::FMrjob* mrjob_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.mrjob.Last
inline gcli::FMrjob* mrjob_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.mrjob.N
inline i32           mrjob_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.mrjob.RemoveAll
void                 mrjob_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.mrjob.RemoveLast
void                 mrjob_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.mrjob.qFind
inline gcli::FMrjob& mrjob_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.mrjob.XrefMaybe
bool                 mrjob_XrefMaybe(gcli::FMrjob &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.mrnote.Alloc
gcli::FMrnote&       mrnote_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.mrnote.AllocMaybe
gcli::FMrnote*       mrnote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.mrnote.InsertMaybe
gcli::FMrnote*       mrnote_InsertMaybe(const gclidb::Mrnote &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.mrnote.AllocMem
void*                mrnote_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.mrnote.EmptyQ
inline bool          mrnote_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.mrnote.Find
inline gcli::FMrnote* mrnote_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.mrnote.Last
inline gcli::FMrnote* mrnote_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.mrnote.N
inline i32           mrnote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.mrnote.RemoveAll
void                 mrnote_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.mrnote.RemoveLast
void                 mrnote_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.mrnote.qFind
inline gcli::FMrnote& mrnote_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.mrnote.XrefMaybe
bool                 mrnote_XrefMaybe(gcli::FMrnote &row);

// Return true if hash is empty
// func:gcli.FDb.ind_mrnote.EmptyQ
inline bool          ind_mrnote_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_mrnote.Find
gcli::FMrnote*       ind_mrnote_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_mrnote.FindX
gcli::FMrnote&       ind_mrnote_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:gcli.FDb.ind_mrnote.N
inline i32           ind_mrnote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_mrnote.InsertMaybe
bool                 ind_mrnote_InsertMaybe(gcli::FMrnote& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_mrnote.Remove
void                 ind_mrnote_Remove(gcli::FMrnote& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_mrnote.Reserve
void                 ind_mrnote_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_issuenote.EmptyQ
inline bool          ind_issuenote_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_issuenote.Find
gcli::FIssuenote*    ind_issuenote_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_issuenote.FindX
gcli::FIssuenote&    ind_issuenote_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:gcli.FDb.ind_issuenote.N
inline i32           ind_issuenote_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_issuenote.InsertMaybe
bool                 ind_issuenote_InsertMaybe(gcli::FIssuenote& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_issuenote.Remove
void                 ind_issuenote_Remove(gcli::FIssuenote& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_issuenote.Reserve
void                 ind_issuenote_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_mrjob.EmptyQ
inline bool          ind_mrjob_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_mrjob.Find
gcli::FMrjob*        ind_mrjob_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_mrjob.FindX
gcli::FMrjob&        ind_mrjob_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:gcli.FDb.ind_mrjob.N
inline i32           ind_mrjob_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_mrjob.InsertMaybe
bool                 ind_mrjob_InsertMaybe(gcli::FMrjob& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_mrjob.Remove
void                 ind_mrjob_Remove(gcli::FMrjob& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_mrjob.Reserve
void                 ind_mrjob_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.user.Alloc
gcli::FUser&         user_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.user.AllocMaybe
gcli::FUser*         user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.user.InsertMaybe
gcli::FUser*         user_InsertMaybe(const gclidb::User &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.user.AllocMem
void*                user_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.user.EmptyQ
inline bool          user_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.user.Find
inline gcli::FUser*  user_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.user.Last
inline gcli::FUser*  user_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.user.N
inline i32           user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.user.RemoveAll
void                 user_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.user.RemoveLast
void                 user_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.user.qFind
inline gcli::FUser&  user_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.user.XrefMaybe
bool                 user_XrefMaybe(gcli::FUser &row);

// Return true if hash is empty
// func:gcli.FDb.ind_user.EmptyQ
inline bool          ind_user_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_user.Find
gcli::FUser*         ind_user_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_user.FindX
gcli::FUser&         ind_user_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_user.GetOrCreate
gcli::FUser&         ind_user_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_user.N
inline i32           ind_user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_user.InsertMaybe
bool                 ind_user_InsertMaybe(gcli::FUser& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_user.Remove
void                 ind_user_Remove(gcli::FUser& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_user.Reserve
void                 ind_user_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_mr.EmptyQ
inline bool          ind_mr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_mr.Find
gcli::FMr*           ind_mr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_mr.FindX
gcli::FMr&           ind_mr_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_mr.GetOrCreate
gcli::FMr&           ind_mr_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_mr.N
inline i32           ind_mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_mr.InsertMaybe
bool                 ind_mr_InsertMaybe(gcli::FMr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_mr.Remove
void                 ind_mr_Remove(gcli::FMr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_mr.Reserve
void                 ind_mr_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_milestone.EmptyQ
inline bool          ind_milestone_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_milestone.Find
gcli::FMilestone*    ind_milestone_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_milestone.FindX
gcli::FMilestone&    ind_milestone_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_milestone.GetOrCreate
gcli::FMilestone&    ind_milestone_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_milestone.N
inline i32           ind_milestone_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_milestone.InsertMaybe
bool                 ind_milestone_InsertMaybe(gcli::FMilestone& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_milestone.Remove
void                 ind_milestone_Remove(gcli::FMilestone& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_milestone.Reserve
void                 ind_milestone_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.milestone.Alloc
gcli::FMilestone&    milestone_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.milestone.AllocMaybe
gcli::FMilestone*    milestone_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.milestone.InsertMaybe
gcli::FMilestone*    milestone_InsertMaybe(const gclidb::Milestone &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.milestone.AllocMem
void*                milestone_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.milestone.EmptyQ
inline bool          milestone_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.milestone.Find
inline gcli::FMilestone* milestone_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.milestone.Last
inline gcli::FMilestone* milestone_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.milestone.N
inline i32           milestone_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.milestone.RemoveAll
void                 milestone_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.milestone.RemoveLast
void                 milestone_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.milestone.qFind
inline gcli::FMilestone& milestone_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.milestone.XrefMaybe
bool                 milestone_XrefMaybe(gcli::FMilestone &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.mr.Alloc
gcli::FMr&           mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.mr.AllocMaybe
gcli::FMr*           mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.mr.InsertMaybe
gcli::FMr*           mr_InsertMaybe(const gclidb::Mr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.mr.AllocMem
void*                mr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.mr.EmptyQ
inline bool          mr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.mr.Find
inline gcli::FMr*    mr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.mr.Last
inline gcli::FMr*    mr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.mr.N
inline i32           mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.mr.RemoveAll
void                 mr_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.mr.RemoveLast
void                 mr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.mr.qFind
inline gcli::FMr&    mr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.mr.XrefMaybe
bool                 mr_XrefMaybe(gcli::FMr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gtypeprefix.Alloc
gcli::FGtypeprefix&  gtypeprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gtypeprefix.AllocMaybe
gcli::FGtypeprefix*  gtypeprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gtypeprefix.InsertMaybe
gcli::FGtypeprefix*  gtypeprefix_InsertMaybe(const gclidb::Gtypeprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gtypeprefix.AllocMem
void*                gtypeprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gtypeprefix.EmptyQ
inline bool          gtypeprefix_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gtypeprefix.Find
inline gcli::FGtypeprefix* gtypeprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gtypeprefix.Last
inline gcli::FGtypeprefix* gtypeprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gtypeprefix.N
inline i32           gtypeprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gtypeprefix.RemoveAll
void                 gtypeprefix_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gtypeprefix.RemoveLast
void                 gtypeprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gtypeprefix.qFind
inline gcli::FGtypeprefix& gtypeprefix_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gtypeprefix.XrefMaybe
bool                 gtypeprefix_XrefMaybe(gcli::FGtypeprefix &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gtblact.Alloc
gcli::FGtblact&      gtblact_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gtblact.AllocMaybe
gcli::FGtblact*      gtblact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gtblact.InsertMaybe
gcli::FGtblact*      gtblact_InsertMaybe(const gclidb::Gtblact &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gtblact.AllocMem
void*                gtblact_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gtblact.EmptyQ
inline bool          gtblact_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gtblact.Find
inline gcli::FGtblact* gtblact_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gtblact.Last
inline gcli::FGtblact* gtblact_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gtblact.N
inline i32           gtblact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gtblact.RemoveAll
void                 gtblact_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gtblact.RemoveLast
void                 gtblact_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gtblact.qFind
inline gcli::FGtblact& gtblact_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gtblact.XrefMaybe
bool                 gtblact_XrefMaybe(gcli::FGtblact &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gtblactfld.Alloc
gcli::FGtblactfld&   gtblactfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gtblactfld.AllocMaybe
gcli::FGtblactfld*   gtblactfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gtblactfld.InsertMaybe
gcli::FGtblactfld*   gtblactfld_InsertMaybe(const gclidb::Gtblactfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gtblactfld.AllocMem
void*                gtblactfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gtblactfld.EmptyQ
inline bool          gtblactfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gtblactfld.Find
inline gcli::FGtblactfld* gtblactfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gtblactfld.Last
inline gcli::FGtblactfld* gtblactfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gtblactfld.N
inline i32           gtblactfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gtblactfld.RemoveAll
void                 gtblactfld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gtblactfld.RemoveLast
void                 gtblactfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gtblactfld.qFind
inline gcli::FGtblactfld& gtblactfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gtblactfld.XrefMaybe
bool                 gtblactfld_XrefMaybe(gcli::FGtblactfld &row);

// Return true if hash is empty
// func:gcli.FDb.ind_gtblact.EmptyQ
inline bool          ind_gtblact_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gtblact.Find
gcli::FGtblact*      ind_gtblact_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gtblact.FindX
gcli::FGtblact&      ind_gtblact_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gtblact.GetOrCreate
gcli::FGtblact&      ind_gtblact_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gtblact.N
inline i32           ind_gtblact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gtblact.InsertMaybe
bool                 ind_gtblact_InsertMaybe(gcli::FGtblact& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gtblact.Remove
void                 ind_gtblact_Remove(gcli::FGtblact& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gtblact.Reserve
void                 ind_gtblact_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FDb.zd_gtblact.EmptyQ
inline bool          zd_gtblact_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:gcli.FDb.zd_gtblact.First
inline gcli::FGtblact* zd_gtblact_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:gcli.FDb.zd_gtblact.InLlistQ
inline bool          zd_gtblact_InLlistQ(gcli::FGtblact& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:gcli.FDb.zd_gtblact.Insert
void                 zd_gtblact_Insert(gcli::FGtblact& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:gcli.FDb.zd_gtblact.Last
inline gcli::FGtblact* zd_gtblact_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:gcli.FDb.zd_gtblact.N
inline i32           zd_gtblact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:gcli.FDb.zd_gtblact.Next
inline gcli::FGtblact* zd_gtblact_Next(gcli::FGtblact &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:gcli.FDb.zd_gtblact.Prev
inline gcli::FGtblact* zd_gtblact_Prev(gcli::FGtblact &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:gcli.FDb.zd_gtblact.Remove
void                 zd_gtblact_Remove(gcli::FGtblact& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FDb.zd_gtblact.RemoveAll
void                 zd_gtblact_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:gcli.FDb.zd_gtblact.RemoveFirst
gcli::FGtblact*      zd_gtblact_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:gcli.FDb.zd_gtblact.qLast
inline gcli::FGtblact& zd_gtblact_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if hash is empty
// func:gcli.FDb.ind_gtblactfld.EmptyQ
inline bool          ind_gtblactfld_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gtblactfld.Find
gcli::FGtblactfld*   ind_gtblactfld_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gtblactfld.FindX
gcli::FGtblactfld&   ind_gtblactfld_FindX(const algo::strptr& key);
// Return number of items in the hash
// func:gcli.FDb.ind_gtblactfld.N
inline i32           ind_gtblactfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gtblactfld.InsertMaybe
bool                 ind_gtblactfld_InsertMaybe(gcli::FGtblactfld& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gtblactfld.Remove
void                 ind_gtblactfld_Remove(gcli::FGtblactfld& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gtblactfld.Reserve
void                 ind_gtblactfld_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gfld.Alloc
gcli::FGfld&         gfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gfld.AllocMaybe
gcli::FGfld*         gfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gfld.InsertMaybe
gcli::FGfld*         gfld_InsertMaybe(const gclidb::Gfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gfld.AllocMem
void*                gfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gfld.EmptyQ
inline bool          gfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gfld.Find
inline gcli::FGfld*  gfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gfld.Last
inline gcli::FGfld*  gfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gfld.N
inline i32           gfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gfld.RemoveAll
void                 gfld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gfld.RemoveLast
void                 gfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gfld.qFind
inline gcli::FGfld&  gfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gfld.XrefMaybe
bool                 gfld_XrefMaybe(gcli::FGfld &row);

// Return true if hash is empty
// func:gcli.FDb.ind_gfld.EmptyQ
inline bool          ind_gfld_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gfld.Find
gcli::FGfld*         ind_gfld_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gfld.FindX
gcli::FGfld&         ind_gfld_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gfld.GetOrCreate
gcli::FGfld&         ind_gfld_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gfld.N
inline i32           ind_gfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gfld.InsertMaybe
bool                 ind_gfld_InsertMaybe(gcli::FGfld& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gfld.Remove
void                 ind_gfld_Remove(gcli::FGfld& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gfld.Reserve
void                 ind_gfld_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FDb.c_gfld.EmptyQ
inline bool          c_gfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.c_gfld.Find
inline gcli::FGfld*  c_gfld_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FDb.c_gfld.Getary
inline algo::aryptr<gcli::FGfld*> c_gfld_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FDb.c_gfld.Insert
void                 c_gfld_Insert(gcli::FGfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FDb.c_gfld.InsertMaybe
bool                 c_gfld_InsertMaybe(gcli::FGfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FDb.c_gfld.N
inline i32           c_gfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FDb.c_gfld.Remove
void                 c_gfld_Remove(gcli::FGfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FDb.c_gfld.RemoveAll
inline void          c_gfld_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FDb.c_gfld.Reserve
void                 c_gfld_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FDb.c_gfld.qFind
inline gcli::FGfld&  c_gfld_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FDb.c_gfld.InAryQ
inline bool          c_gfld_InAryQ(gcli::FGfld& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FDb.c_gfld.qLast
inline gcli::FGfld&  c_gfld_qLast() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gtbl.Alloc
gcli::FGtbl&         gtbl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gtbl.AllocMaybe
gcli::FGtbl*         gtbl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gtbl.InsertMaybe
gcli::FGtbl*         gtbl_InsertMaybe(const gclidb::Gtbl &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gtbl.AllocMem
void*                gtbl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gtbl.EmptyQ
inline bool          gtbl_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gtbl.Find
inline gcli::FGtbl*  gtbl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gtbl.Last
inline gcli::FGtbl*  gtbl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gtbl.N
inline i32           gtbl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gtbl.RemoveAll
void                 gtbl_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gtbl.RemoveLast
void                 gtbl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gtbl.qFind
inline gcli::FGtbl&  gtbl_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gtbl.XrefMaybe
bool                 gtbl_XrefMaybe(gcli::FGtbl &row);

// Return true if hash is empty
// func:gcli.FDb.ind_gtbl.EmptyQ
inline bool          ind_gtbl_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gtbl.Find
gcli::FGtbl*         ind_gtbl_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gtbl.FindX
gcli::FGtbl&         ind_gtbl_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gtbl.GetOrCreate
gcli::FGtbl&         ind_gtbl_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gtbl.N
inline i32           ind_gtbl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gtbl.InsertMaybe
bool                 ind_gtbl_InsertMaybe(gcli::FGtbl& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gtbl.Remove
void                 ind_gtbl_Remove(gcli::FGtbl& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gtbl.Reserve
void                 ind_gtbl_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:gcli.FDb.gact.Alloc
gcli::FGact&         gact_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:gcli.FDb.gact.AllocMaybe
gcli::FGact*         gact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:gcli.FDb.gact.InsertMaybe
gcli::FGact*         gact_InsertMaybe(const gclidb::Gact &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:gcli.FDb.gact.AllocMem
void*                gact_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FDb.gact.EmptyQ
inline bool          gact_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:gcli.FDb.gact.Find
inline gcli::FGact*  gact_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FDb.gact.Last
inline gcli::FGact*  gact_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:gcli.FDb.gact.N
inline i32           gact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:gcli.FDb.gact.RemoveAll
void                 gact_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FDb.gact.RemoveLast
void                 gact_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FDb.gact.qFind
inline gcli::FGact&  gact_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:gcli.FDb.gact.XrefMaybe
bool                 gact_XrefMaybe(gcli::FGact &row);

// Return true if hash is empty
// func:gcli.FDb.ind_gact.EmptyQ
inline bool          ind_gact_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:gcli.FDb.ind_gact.Find
gcli::FGact*         ind_gact_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:gcli.FDb.ind_gact.FindX
gcli::FGact&         ind_gact_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:gcli.FDb.ind_gact.GetOrCreate
gcli::FGact&         ind_gact_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:gcli.FDb.ind_gact.N
inline i32           ind_gact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:gcli.FDb.ind_gact.InsertMaybe
bool                 ind_gact_InsertMaybe(gcli::FGact& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:gcli.FDb.ind_gact.Remove
void                 ind_gact_Remove(gcli::FGact& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:gcli.FDb.ind_gact.Reserve
void                 ind_gact_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
// func:gcli.FDb.gtype_curs.Reset
inline void          _db_gtype_curs_Reset(_db_gtype_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtype_curs.ValidQ
inline bool          _db_gtype_curs_ValidQ(_db_gtype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gtype_curs.Next
inline void          _db_gtype_curs_Next(_db_gtype_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gtype_curs.Access
inline gcli::FGtype& _db_gtype_curs_Access(_db_gtype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.grepossh_curs.Reset
inline void          _db_grepossh_curs_Reset(_db_grepossh_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.grepossh_curs.ValidQ
inline bool          _db_grepossh_curs_ValidQ(_db_grepossh_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.grepossh_curs.Next
inline void          _db_grepossh_curs_Next(_db_grepossh_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.grepossh_curs.Access
inline gcli::FGrepossh& _db_grepossh_curs_Access(_db_grepossh_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.grepogitport_curs.Reset
inline void          _db_grepogitport_curs_Reset(_db_grepogitport_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.grepogitport_curs.ValidQ
inline bool          _db_grepogitport_curs_ValidQ(_db_grepogitport_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.grepogitport_curs.Next
inline void          _db_grepogitport_curs_Next(_db_grepogitport_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.grepogitport_curs.Access
inline gcli::FGrepogitport& _db_grepogitport_curs_Access(_db_grepogitport_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.githost_curs.Reset
inline void          _db_githost_curs_Reset(_db_githost_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.githost_curs.ValidQ
inline bool          _db_githost_curs_ValidQ(_db_githost_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.githost_curs.Next
inline void          _db_githost_curs_Next(_db_githost_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.githost_curs.Access
inline gcli::FGithost& _db_githost_curs_Access(_db_githost_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gstatet_curs.Reset
inline void          _db_gstatet_curs_Reset(_db_gstatet_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gstatet_curs.ValidQ
inline bool          _db_gstatet_curs_ValidQ(_db_gstatet_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gstatet_curs.Next
inline void          _db_gstatet_curs_Next(_db_gstatet_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gstatet_curs.Access
inline gcli::FGstatet& _db_gstatet_curs_Access(_db_gstatet_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gmethod_curs.Reset
inline void          _db_gmethod_curs_Reset(_db_gmethod_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gmethod_curs.ValidQ
inline bool          _db_gmethod_curs_ValidQ(_db_gmethod_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gmethod_curs.Next
inline void          _db_gmethod_curs_Next(_db_gmethod_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gmethod_curs.Access
inline gcli::FGmethod& _db_gmethod_curs_Access(_db_gmethod_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdt_curs.Reset
inline void          _db_gclicmdt_curs_Reset(_db_gclicmdt_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdt_curs.ValidQ
inline bool          _db_gclicmdt_curs_ValidQ(_db_gclicmdt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmdt_curs.Next
inline void          _db_gclicmdt_curs_Next(_db_gclicmdt_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmdt_curs.Access
inline gcli::FGclicmdt& _db_gclicmdt_curs_Access(_db_gclicmdt_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdf_curs.Reset
inline void          _db_gclicmdf_curs_Reset(_db_gclicmdf_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdf_curs.ValidQ
inline bool          _db_gclicmdf_curs_ValidQ(_db_gclicmdf_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmdf_curs.Next
inline void          _db_gclicmdf_curs_Next(_db_gclicmdf_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmdf_curs.Access
inline gcli::FGclicmdf& _db_gclicmdf_curs_Access(_db_gclicmdf_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdf2j_curs.Reset
inline void          _db_gclicmdf2j_curs_Reset(_db_gclicmdf2j_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdf2j_curs.ValidQ
inline bool          _db_gclicmdf2j_curs_ValidQ(_db_gclicmdf2j_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmdf2j_curs.Next
inline void          _db_gclicmdf2j_curs_Next(_db_gclicmdf2j_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmdf2j_curs.Access
inline gcli::FGclicmdf2j& _db_gclicmdf2j_curs_Access(_db_gclicmdf2j_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmd_curs.Reset
inline void          _db_gclicmd_curs_Reset(_db_gclicmd_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmd_curs.ValidQ
inline bool          _db_gclicmd_curs_ValidQ(_db_gclicmd_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmd_curs.Next
inline void          _db_gclicmd_curs_Next(_db_gclicmd_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmd_curs.Access
inline gcli::FGclicmd& _db_gclicmd_curs_Access(_db_gclicmd_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtypeh_curs.Reset
inline void          _db_gtypeh_curs_Reset(_db_gtypeh_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtypeh_curs.ValidQ
inline bool          _db_gtypeh_curs_ValidQ(_db_gtypeh_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gtypeh_curs.Next
inline void          _db_gtypeh_curs_Next(_db_gtypeh_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gtypeh_curs.Access
inline gcli::FGtypeh& _db_gtypeh_curs_Access(_db_gtypeh_curs &curs) __attribute__((nothrow));
// func:gcli.FDb.c_gclicmd_curs.Reset
inline void          _db_c_gclicmd_curs_Reset(_db_c_gclicmd_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.c_gclicmd_curs.ValidQ
inline bool          _db_c_gclicmd_curs_ValidQ(_db_c_gclicmd_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.c_gclicmd_curs.Next
inline void          _db_c_gclicmd_curs_Next(_db_c_gclicmd_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.c_gclicmd_curs.Access
inline gcli::FGclicmd& _db_c_gclicmd_curs_Access(_db_c_gclicmd_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdj2f_curs.Reset
inline void          _db_gclicmdj2f_curs_Reset(_db_gclicmdj2f_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdj2f_curs.ValidQ
inline bool          _db_gclicmdj2f_curs_ValidQ(_db_gclicmdj2f_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmdj2f_curs.Next
inline void          _db_gclicmdj2f_curs_Next(_db_gclicmdj2f_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmdj2f_curs.Access
inline gcli::FGclicmdj2f& _db_gclicmdj2f_curs_Access(_db_gclicmdj2f_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdc_curs.Reset
inline void          _db_gclicmdc_curs_Reset(_db_gclicmdc_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdc_curs.ValidQ
inline bool          _db_gclicmdc_curs_ValidQ(_db_gclicmdc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmdc_curs.Next
inline void          _db_gclicmdc_curs_Next(_db_gclicmdc_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmdc_curs.Access
inline gcli::FGclicmdc& _db_gclicmdc_curs_Access(_db_gclicmdc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdarg_curs.Reset
inline void          _db_gclicmdarg_curs_Reset(_db_gclicmdarg_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gclicmdarg_curs.ValidQ
inline bool          _db_gclicmdarg_curs_ValidQ(_db_gclicmdarg_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gclicmdarg_curs.Next
inline void          _db_gclicmdarg_curs_Next(_db_gclicmdarg_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gclicmdarg_curs.Access
inline gcli::FGclicmdarg& _db_gclicmdarg_curs_Access(_db_gclicmdarg_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.issue_curs.Reset
inline void          _db_issue_curs_Reset(_db_issue_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.issue_curs.ValidQ
inline bool          _db_issue_curs_ValidQ(_db_issue_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.issue_curs.Next
inline void          _db_issue_curs_Next(_db_issue_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.issue_curs.Access
inline gcli::FIssue& _db_issue_curs_Access(_db_issue_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.grepo_curs.Reset
inline void          _db_grepo_curs_Reset(_db_grepo_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.grepo_curs.ValidQ
inline bool          _db_grepo_curs_ValidQ(_db_grepo_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.grepo_curs.Next
inline void          _db_grepo_curs_Next(_db_grepo_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.grepo_curs.Access
inline gcli::FGrepo& _db_grepo_curs_Access(_db_grepo_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.tuples_curs.Reset
inline void          _db_tuples_curs_Reset(_db_tuples_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.tuples_curs.ValidQ
inline bool          _db_tuples_curs_ValidQ(_db_tuples_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.tuples_curs.Next
inline void          _db_tuples_curs_Next(_db_tuples_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.tuples_curs.Access
inline gcli::FTuples& _db_tuples_curs_Access(_db_tuples_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.issuenote_curs.Reset
inline void          _db_issuenote_curs_Reset(_db_issuenote_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.issuenote_curs.ValidQ
inline bool          _db_issuenote_curs_ValidQ(_db_issuenote_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.issuenote_curs.Next
inline void          _db_issuenote_curs_Next(_db_issuenote_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.issuenote_curs.Access
inline gcli::FIssuenote& _db_issuenote_curs_Access(_db_issuenote_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.mrjob_curs.Reset
inline void          _db_mrjob_curs_Reset(_db_mrjob_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.mrjob_curs.ValidQ
inline bool          _db_mrjob_curs_ValidQ(_db_mrjob_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.mrjob_curs.Next
inline void          _db_mrjob_curs_Next(_db_mrjob_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.mrjob_curs.Access
inline gcli::FMrjob& _db_mrjob_curs_Access(_db_mrjob_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.mrnote_curs.Reset
inline void          _db_mrnote_curs_Reset(_db_mrnote_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.mrnote_curs.ValidQ
inline bool          _db_mrnote_curs_ValidQ(_db_mrnote_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.mrnote_curs.Next
inline void          _db_mrnote_curs_Next(_db_mrnote_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.mrnote_curs.Access
inline gcli::FMrnote& _db_mrnote_curs_Access(_db_mrnote_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.user_curs.Reset
inline void          _db_user_curs_Reset(_db_user_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.user_curs.ValidQ
inline bool          _db_user_curs_ValidQ(_db_user_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.user_curs.Next
inline void          _db_user_curs_Next(_db_user_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.user_curs.Access
inline gcli::FUser&  _db_user_curs_Access(_db_user_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.milestone_curs.Reset
inline void          _db_milestone_curs_Reset(_db_milestone_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.milestone_curs.ValidQ
inline bool          _db_milestone_curs_ValidQ(_db_milestone_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.milestone_curs.Next
inline void          _db_milestone_curs_Next(_db_milestone_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.milestone_curs.Access
inline gcli::FMilestone& _db_milestone_curs_Access(_db_milestone_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.mr_curs.Reset
inline void          _db_mr_curs_Reset(_db_mr_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.mr_curs.ValidQ
inline bool          _db_mr_curs_ValidQ(_db_mr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.mr_curs.Next
inline void          _db_mr_curs_Next(_db_mr_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.mr_curs.Access
inline gcli::FMr&    _db_mr_curs_Access(_db_mr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtypeprefix_curs.Reset
inline void          _db_gtypeprefix_curs_Reset(_db_gtypeprefix_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtypeprefix_curs.ValidQ
inline bool          _db_gtypeprefix_curs_ValidQ(_db_gtypeprefix_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gtypeprefix_curs.Next
inline void          _db_gtypeprefix_curs_Next(_db_gtypeprefix_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gtypeprefix_curs.Access
inline gcli::FGtypeprefix& _db_gtypeprefix_curs_Access(_db_gtypeprefix_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtblact_curs.Reset
inline void          _db_gtblact_curs_Reset(_db_gtblact_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtblact_curs.ValidQ
inline bool          _db_gtblact_curs_ValidQ(_db_gtblact_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gtblact_curs.Next
inline void          _db_gtblact_curs_Next(_db_gtblact_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gtblact_curs.Access
inline gcli::FGtblact& _db_gtblact_curs_Access(_db_gtblact_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtblactfld_curs.Reset
inline void          _db_gtblactfld_curs_Reset(_db_gtblactfld_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtblactfld_curs.ValidQ
inline bool          _db_gtblactfld_curs_ValidQ(_db_gtblactfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gtblactfld_curs.Next
inline void          _db_gtblactfld_curs_Next(_db_gtblactfld_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gtblactfld_curs.Access
inline gcli::FGtblactfld& _db_gtblactfld_curs_Access(_db_gtblactfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.zd_gtblact_curs.Reset
inline void          _db_zd_gtblact_curs_Reset(_db_zd_gtblact_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.zd_gtblact_curs.ValidQ
inline bool          _db_zd_gtblact_curs_ValidQ(_db_zd_gtblact_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.zd_gtblact_curs.Next
inline void          _db_zd_gtblact_curs_Next(_db_zd_gtblact_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.zd_gtblact_curs.Access
inline gcli::FGtblact& _db_zd_gtblact_curs_Access(_db_zd_gtblact_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gfld_curs.Reset
inline void          _db_gfld_curs_Reset(_db_gfld_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gfld_curs.ValidQ
inline bool          _db_gfld_curs_ValidQ(_db_gfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gfld_curs.Next
inline void          _db_gfld_curs_Next(_db_gfld_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gfld_curs.Access
inline gcli::FGfld&  _db_gfld_curs_Access(_db_gfld_curs &curs) __attribute__((nothrow));
// func:gcli.FDb.c_gfld_curs.Reset
inline void          _db_c_gfld_curs_Reset(_db_c_gfld_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.c_gfld_curs.ValidQ
inline bool          _db_c_gfld_curs_ValidQ(_db_c_gfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.c_gfld_curs.Next
inline void          _db_c_gfld_curs_Next(_db_c_gfld_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.c_gfld_curs.Access
inline gcli::FGfld&  _db_c_gfld_curs_Access(_db_c_gfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtbl_curs.Reset
inline void          _db_gtbl_curs_Reset(_db_gtbl_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gtbl_curs.ValidQ
inline bool          _db_gtbl_curs_ValidQ(_db_gtbl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gtbl_curs.Next
inline void          _db_gtbl_curs_Next(_db_gtbl_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gtbl_curs.Access
inline gcli::FGtbl&  _db_gtbl_curs_Access(_db_gtbl_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gact_curs.Reset
inline void          _db_gact_curs_Reset(_db_gact_curs &curs, gcli::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FDb.gact_curs.ValidQ
inline bool          _db_gact_curs_ValidQ(_db_gact_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FDb.gact_curs.Next
inline void          _db_gact_curs_Next(_db_gact_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FDb.gact_curs.Access
inline gcli::FGact&  _db_gact_curs_Access(_db_gact_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:gcli.FDb..Init
void                 FDb_Init();
// func:gcli.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));

// --- gcli.FGact
// create: gcli.FDb.gact (Lary)
// global access: gact (Lary, by rowid)
// global access: ind_gact (Thash, hash field gact)
struct FGact { // gcli.FGact
    gcli::FGact*       ind_gact_next;   // hash next
    algo::Smallstr50   gact;            //
    algo::Comment      comment;         //
    // func:gcli.FGact..AssignOp
    inline gcli::FGact&  operator =(const gcli::FGact &rhs) = delete;
    // func:gcli.FGact..CopyCtor
    inline               FGact(const gcli::FGact &rhs) = delete;
private:
    // func:gcli.FGact..Ctor
    inline               FGact() __attribute__((nothrow));
    // func:gcli.FGact..Dtor
    inline               ~FGact() __attribute__((nothrow));
    friend gcli::FGact&         gact_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGact*         gact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gact_RemoveAll() __attribute__((nothrow));
    friend void                 gact_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGact.base.CopyOut
void                 gact_CopyOut(gcli::FGact &row, gclidb::Gact &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGact.base.CopyIn
void                 gact_CopyIn(gcli::FGact &row, gclidb::Gact &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGact..Init
inline void          FGact_Init(gcli::FGact& gact);
// func:gcli.FGact..Uninit
void                 FGact_Uninit(gcli::FGact& gact) __attribute__((nothrow));

// --- gcli.FGclicmd
// create: gcli.FDb.gclicmd (Lary)
// global access: gclicmd (Lary, by rowid)
// global access: ind_gclicmd (Thash, hash field gclicmd)
// global access: c_gclicmd (Ptrary)
// access: gcli.FGclicmd.step (Hook)
// access: gcli.FGclicmd.p_gclicmd (Upptr)
// access: gcli.FGclicmdf2j.p_gclicmd (Upptr)
// access: gcli.FGclicmdt.p_gclicmd (Upptr)
struct FGclicmd { // gcli.FGclicmd
    gcli::FGclicmd*           ind_gclicmd_next;       // hash next
    algo::Smallstr250         gclicmd;                //
    algo::Smallstr250         gclicmdf2j;             // Base for gclicmdf2j
    algo::Comment             comment;                //
    algo::cstring             url;                    //
    algo::cstring             sep;                    //
    algo::cstring             host;                   //
    algo::cstring             proj;                   //
    algo::cstring             token;                  //
    algo::cstring             body;                   //
    algo::cstring             note_id;                //
    algo::cstring             issue_id;               //
    algo::cstring             cond;                   //
    bool                      select;                 //   false
    bool                      write_auth;             //   false
    bool                      finish;                 //   false
    algo::cstring             gclicmdt_key;           //
    u32                       method;                 //   0
    gcli::FIssue*             p_issue;                // optional pointer
    gcli::FMr*                p_mr;                   // optional pointer
    gcli::FTuples**           c_tuples_elems;         // array of pointers
    u32                       c_tuples_n;             // array of pointers
    u32                       c_tuples_max;           // capacity of allocated array
    gcli::gclicmd_step_hook   step;                   //   NULL  Pointer to a function
    gcli::FGclicmdarg**       c_gclicmdarg_elems;     // array of pointers
    u32                       c_gclicmdarg_n;         // array of pointers
    u32                       c_gclicmdarg_max;       // capacity of allocated array
    gcli::FGclicmdc**         c_gclicmdc_elems;       // array of pointers
    u32                       c_gclicmdc_n;           // array of pointers
    u32                       c_gclicmdc_max;         // capacity of allocated array
    gcli::FGclicmdf2j**       c_gclicmdf2j_elems;     // array of pointers
    u32                       c_gclicmdf2j_n;         // array of pointers
    u32                       c_gclicmdf2j_max;       // capacity of allocated array
    gcli::FGclicmd*           p_gclicmd;              // reference to parent row
    bool                      _db_c_gclicmd_in_ary;   //   false  membership flag
    // reftype Ptrary of gcli.FGclicmd.c_tuples prohibits copy
    // reftype Hook of gcli.FGclicmd.step prohibits copy
    // reftype Ptrary of gcli.FGclicmd.c_gclicmdarg prohibits copy
    // reftype Ptrary of gcli.FGclicmd.c_gclicmdc prohibits copy
    // reftype Ptrary of gcli.FGclicmd.c_gclicmdf2j prohibits copy
    // func:gcli.FGclicmd..AssignOp
    gcli::FGclicmd&      operator =(const gcli::FGclicmd &rhs) = delete;
    // reftype Ptrary of gcli.FGclicmd.c_tuples prohibits copy
    // reftype Hook of gcli.FGclicmd.step prohibits copy
    // reftype Ptrary of gcli.FGclicmd.c_gclicmdarg prohibits copy
    // reftype Ptrary of gcli.FGclicmd.c_gclicmdc prohibits copy
    // reftype Ptrary of gcli.FGclicmd.c_gclicmdf2j prohibits copy
    // func:gcli.FGclicmd..CopyCtor
    FGclicmd(const gcli::FGclicmd &rhs) = delete;
private:
    // func:gcli.FGclicmd..Ctor
    inline               FGclicmd() __attribute__((nothrow));
    // func:gcli.FGclicmd..Dtor
    inline               ~FGclicmd() __attribute__((nothrow));
    friend gcli::FGclicmd&      gclicmd_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmd*      gclicmd_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmd_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmd_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGclicmd.base.CopyOut
void                 gclicmd_CopyOut(gcli::FGclicmd &row, gclidb::Gclicmd &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGclicmd.base.CopyIn
void                 gclicmd_CopyIn(gcli::FGclicmd &row, gclidb::Gclicmd &in) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGclicmd.c_tuples.EmptyQ
inline bool          c_tuples_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGclicmd.c_tuples.Find
inline gcli::FTuples* c_tuples_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGclicmd.c_tuples.Getary
inline algo::aryptr<gcli::FTuples*> c_tuples_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGclicmd.c_tuples.Insert
void                 c_tuples_Insert(gcli::FGclicmd& gclicmd, gcli::FTuples& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:gcli.FGclicmd.c_tuples.ScanInsertMaybe
bool                 c_tuples_ScanInsertMaybe(gcli::FGclicmd& gclicmd, gcli::FTuples& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGclicmd.c_tuples.N
inline i32           c_tuples_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGclicmd.c_tuples.Remove
void                 c_tuples_Remove(gcli::FGclicmd& gclicmd, gcli::FTuples& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGclicmd.c_tuples.RemoveAll
inline void          c_tuples_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGclicmd.c_tuples.Reserve
void                 c_tuples_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGclicmd.c_tuples.qFind
inline gcli::FTuples& c_tuples_qFind(gcli::FGclicmd& gclicmd, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGclicmd.c_tuples.qLast
inline gcli::FTuples& c_tuples_qLast(gcli::FGclicmd& gclicmd) __attribute__((nothrow));

// Invoke function by pointer
// func:gcli.FGclicmd.step.Call
inline void          step_Call(gcli::FGclicmd& gclicmd, gcli::FGclicmd& arg) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGclicmd.c_gclicmdarg.EmptyQ
inline bool          c_gclicmdarg_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGclicmd.c_gclicmdarg.Find
inline gcli::FGclicmdarg* c_gclicmdarg_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGclicmd.c_gclicmdarg.Getary
inline algo::aryptr<gcli::FGclicmdarg*> c_gclicmdarg_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGclicmd.c_gclicmdarg.Insert
void                 c_gclicmdarg_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGclicmd.c_gclicmdarg.InsertMaybe
bool                 c_gclicmdarg_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGclicmd.c_gclicmdarg.N
inline i32           c_gclicmdarg_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGclicmd.c_gclicmdarg.Remove
void                 c_gclicmdarg_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdarg& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGclicmd.c_gclicmdarg.RemoveAll
inline void          c_gclicmdarg_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGclicmd.c_gclicmdarg.Reserve
void                 c_gclicmdarg_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGclicmd.c_gclicmdarg.qFind
inline gcli::FGclicmdarg& c_gclicmdarg_qFind(gcli::FGclicmd& gclicmd, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGclicmd.c_gclicmdarg.InAryQ
inline bool          gclicmd_c_gclicmdarg_InAryQ(gcli::FGclicmdarg& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGclicmd.c_gclicmdarg.qLast
inline gcli::FGclicmdarg& c_gclicmdarg_qLast(gcli::FGclicmd& gclicmd) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGclicmd.c_gclicmdc.EmptyQ
inline bool          c_gclicmdc_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGclicmd.c_gclicmdc.Find
inline gcli::FGclicmdc* c_gclicmdc_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGclicmd.c_gclicmdc.Getary
inline algo::aryptr<gcli::FGclicmdc*> c_gclicmdc_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGclicmd.c_gclicmdc.Insert
void                 c_gclicmdc_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGclicmd.c_gclicmdc.InsertMaybe
bool                 c_gclicmdc_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGclicmd.c_gclicmdc.N
inline i32           c_gclicmdc_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGclicmd.c_gclicmdc.Remove
void                 c_gclicmdc_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGclicmd.c_gclicmdc.RemoveAll
inline void          c_gclicmdc_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGclicmd.c_gclicmdc.Reserve
void                 c_gclicmdc_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGclicmd.c_gclicmdc.qFind
inline gcli::FGclicmdc& c_gclicmdc_qFind(gcli::FGclicmd& gclicmd, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGclicmd.c_gclicmdc.InAryQ
inline bool          gclicmd_c_gclicmdc_InAryQ(gcli::FGclicmdc& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGclicmd.c_gclicmdc.qLast
inline gcli::FGclicmdc& c_gclicmdc_qLast(gcli::FGclicmd& gclicmd) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGclicmd.c_gclicmdf2j.EmptyQ
inline bool          c_gclicmdf2j_EmptyQ(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGclicmd.c_gclicmdf2j.Find
inline gcli::FGclicmdf2j* c_gclicmdf2j_Find(gcli::FGclicmd& gclicmd, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGclicmd.c_gclicmdf2j.Getary
inline algo::aryptr<gcli::FGclicmdf2j*> c_gclicmdf2j_Getary(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGclicmd.c_gclicmdf2j.Insert
void                 c_gclicmdf2j_Insert(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGclicmd.c_gclicmdf2j.InsertMaybe
bool                 c_gclicmdf2j_InsertMaybe(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGclicmd.c_gclicmdf2j.N
inline i32           c_gclicmdf2j_N(const gcli::FGclicmd& gclicmd) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGclicmd.c_gclicmdf2j.Remove
void                 c_gclicmdf2j_Remove(gcli::FGclicmd& gclicmd, gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGclicmd.c_gclicmdf2j.RemoveAll
inline void          c_gclicmdf2j_RemoveAll(gcli::FGclicmd& gclicmd) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGclicmd.c_gclicmdf2j.Reserve
void                 c_gclicmdf2j_Reserve(gcli::FGclicmd& gclicmd, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGclicmd.c_gclicmdf2j.qFind
inline gcli::FGclicmdf2j& c_gclicmdf2j_qFind(gcli::FGclicmd& gclicmd, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGclicmd.c_gclicmdf2j.InAryQ
inline bool          gclicmd_c_gclicmdf2j_InAryQ(gcli::FGclicmdf2j& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGclicmd.c_gclicmdf2j.qLast
inline gcli::FGclicmdf2j& c_gclicmdf2j_qLast(gcli::FGclicmd& gclicmd) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmd..Init
void                 FGclicmd_Init(gcli::FGclicmd& gclicmd);
// func:gcli.FGclicmd.c_tuples_curs.Reset
inline void          gclicmd_c_tuples_curs_Reset(gclicmd_c_tuples_curs &curs, gcli::FGclicmd &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGclicmd.c_tuples_curs.ValidQ
inline bool          gclicmd_c_tuples_curs_ValidQ(gclicmd_c_tuples_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGclicmd.c_tuples_curs.Next
inline void          gclicmd_c_tuples_curs_Next(gclicmd_c_tuples_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGclicmd.c_tuples_curs.Access
inline gcli::FTuples& gclicmd_c_tuples_curs_Access(gclicmd_c_tuples_curs &curs) __attribute__((nothrow));
// func:gcli.FGclicmd.c_gclicmdarg_curs.Reset
inline void          gclicmd_c_gclicmdarg_curs_Reset(gclicmd_c_gclicmdarg_curs &curs, gcli::FGclicmd &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGclicmd.c_gclicmdarg_curs.ValidQ
inline bool          gclicmd_c_gclicmdarg_curs_ValidQ(gclicmd_c_gclicmdarg_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGclicmd.c_gclicmdarg_curs.Next
inline void          gclicmd_c_gclicmdarg_curs_Next(gclicmd_c_gclicmdarg_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGclicmd.c_gclicmdarg_curs.Access
inline gcli::FGclicmdarg& gclicmd_c_gclicmdarg_curs_Access(gclicmd_c_gclicmdarg_curs &curs) __attribute__((nothrow));
// func:gcli.FGclicmd.c_gclicmdc_curs.Reset
inline void          gclicmd_c_gclicmdc_curs_Reset(gclicmd_c_gclicmdc_curs &curs, gcli::FGclicmd &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGclicmd.c_gclicmdc_curs.ValidQ
inline bool          gclicmd_c_gclicmdc_curs_ValidQ(gclicmd_c_gclicmdc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGclicmd.c_gclicmdc_curs.Next
inline void          gclicmd_c_gclicmdc_curs_Next(gclicmd_c_gclicmdc_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGclicmd.c_gclicmdc_curs.Access
inline gcli::FGclicmdc& gclicmd_c_gclicmdc_curs_Access(gclicmd_c_gclicmdc_curs &curs) __attribute__((nothrow));
// func:gcli.FGclicmd.c_gclicmdf2j_curs.Reset
inline void          gclicmd_c_gclicmdf2j_curs_Reset(gclicmd_c_gclicmdf2j_curs &curs, gcli::FGclicmd &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGclicmd.c_gclicmdf2j_curs.ValidQ
inline bool          gclicmd_c_gclicmdf2j_curs_ValidQ(gclicmd_c_gclicmdf2j_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGclicmd.c_gclicmdf2j_curs.Next
inline void          gclicmd_c_gclicmdf2j_curs_Next(gclicmd_c_gclicmdf2j_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGclicmd.c_gclicmdf2j_curs.Access
inline gcli::FGclicmdf2j& gclicmd_c_gclicmdf2j_curs_Access(gclicmd_c_gclicmdf2j_curs &curs) __attribute__((nothrow));
// func:gcli.FGclicmd..Uninit
void                 FGclicmd_Uninit(gcli::FGclicmd& gclicmd) __attribute__((nothrow));

// --- gcli.FGclicmdarg
// create: gcli.FDb.gclicmdarg (Lary)
// global access: gclicmdarg (Lary, by rowid)
// global access: ind_gclicmdarg (Thash, hash field gclicmdarg)
// access: gcli.FGclicmd.c_gclicmdarg (Ptrary)
struct FGclicmdarg { // gcli.FGclicmdarg
    gcli::FGclicmdarg*   ind_gclicmdarg_next;           // hash next
    algo::Smallstr250    gclicmdarg;                    //
    bool                 gclicmd_c_gclicmdarg_in_ary;   //   false  membership flag
    // func:gcli.FGclicmdarg..AssignOp
    inline gcli::FGclicmdarg& operator =(const gcli::FGclicmdarg &rhs) = delete;
    // func:gcli.FGclicmdarg..CopyCtor
    inline               FGclicmdarg(const gcli::FGclicmdarg &rhs) = delete;
private:
    // func:gcli.FGclicmdarg..Ctor
    inline               FGclicmdarg() __attribute__((nothrow));
    // func:gcli.FGclicmdarg..Dtor
    inline               ~FGclicmdarg() __attribute__((nothrow));
    friend gcli::FGclicmdarg&   gclicmdarg_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdarg*   gclicmdarg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdarg_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdarg_RemoveLast() __attribute__((nothrow));
};

// func:gcli.FGclicmdarg.gclicmd.Get
algo::Smallstr250    gclicmd_Get(gcli::FGclicmdarg& gclicmdarg) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdarg.arg.Get
algo::cstring        arg_Get(gcli::FGclicmdarg& gclicmdarg) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmdarg..Init
inline void          FGclicmdarg_Init(gcli::FGclicmdarg& gclicmdarg);
// func:gcli.FGclicmdarg..Concat_gclicmd_arg
tempstr              FGclicmdarg_Concat_gclicmd_arg( const algo::strptr& gclicmd ,const algo::strptr& arg );
// func:gcli.FGclicmdarg..Uninit
void                 FGclicmdarg_Uninit(gcli::FGclicmdarg& gclicmdarg) __attribute__((nothrow));

// --- gcli.FGclicmdc
// create: gcli.FDb.gclicmdc (Lary)
// global access: gclicmdc (Lary, by rowid)
// global access: ind_gclicmdc (Thash, hash field gclicmdc)
// access: gcli.FGclicmd.c_gclicmdc (Ptrary)
struct FGclicmdc { // gcli.FGclicmdc
    gcli::FGclicmdc*    ind_gclicmdc_next;           // hash next
    algo::Smallstr250   gclicmdc;                    //
    gcli::FGclicmdf**   c_gclicmdf_elems;            // array of pointers
    u32                 c_gclicmdf_n;                // array of pointers
    u32                 c_gclicmdf_max;              // capacity of allocated array
    bool                gclicmd_c_gclicmdc_in_ary;   //   false  membership flag
    // reftype Ptrary of gcli.FGclicmdc.c_gclicmdf prohibits copy
    // func:gcli.FGclicmdc..AssignOp
    inline gcli::FGclicmdc& operator =(const gcli::FGclicmdc &rhs) = delete;
    // reftype Ptrary of gcli.FGclicmdc.c_gclicmdf prohibits copy
    // func:gcli.FGclicmdc..CopyCtor
    inline               FGclicmdc(const gcli::FGclicmdc &rhs) = delete;
private:
    // func:gcli.FGclicmdc..Ctor
    inline               FGclicmdc() __attribute__((nothrow));
    // func:gcli.FGclicmdc..Dtor
    inline               ~FGclicmdc() __attribute__((nothrow));
    friend gcli::FGclicmdc&     gclicmdc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdc*     gclicmdc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdc_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdc_RemoveLast() __attribute__((nothrow));
};

// func:gcli.FGclicmdc.gclicmd.Get
algo::Smallstr250    gclicmd_Get(gcli::FGclicmdc& gclicmdc) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdc.ctype.Get
algo::cstring        ctype_Get(gcli::FGclicmdc& gclicmdc) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:gcli.FGclicmdc.c_gclicmdf.EmptyQ
inline bool          c_gclicmdf_EmptyQ(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGclicmdc.c_gclicmdf.Find
inline gcli::FGclicmdf* c_gclicmdf_Find(gcli::FGclicmdc& gclicmdc, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGclicmdc.c_gclicmdf.Getary
inline algo::aryptr<gcli::FGclicmdf*> c_gclicmdf_Getary(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGclicmdc.c_gclicmdf.Insert
void                 c_gclicmdf_Insert(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGclicmdc.c_gclicmdf.InsertMaybe
bool                 c_gclicmdf_InsertMaybe(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGclicmdc.c_gclicmdf.N
inline i32           c_gclicmdf_N(const gcli::FGclicmdc& gclicmdc) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGclicmdc.c_gclicmdf.Remove
void                 c_gclicmdf_Remove(gcli::FGclicmdc& gclicmdc, gcli::FGclicmdf& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGclicmdc.c_gclicmdf.RemoveAll
inline void          c_gclicmdf_RemoveAll(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGclicmdc.c_gclicmdf.Reserve
void                 c_gclicmdf_Reserve(gcli::FGclicmdc& gclicmdc, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGclicmdc.c_gclicmdf.qFind
inline gcli::FGclicmdf& c_gclicmdf_qFind(gcli::FGclicmdc& gclicmdc, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGclicmdc.c_gclicmdf.InAryQ
inline bool          gclicmdc_c_gclicmdf_InAryQ(gcli::FGclicmdf& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGclicmdc.c_gclicmdf.qLast
inline gcli::FGclicmdf& c_gclicmdf_qLast(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmdc..Init
inline void          FGclicmdc_Init(gcli::FGclicmdc& gclicmdc);
// func:gcli.FGclicmdc..Concat_gclicmd_ctype
tempstr              FGclicmdc_Concat_gclicmd_ctype( const algo::strptr& gclicmd ,const algo::strptr& ctype );
// func:gcli.FGclicmdc.c_gclicmdf_curs.Reset
inline void          gclicmdc_c_gclicmdf_curs_Reset(gclicmdc_c_gclicmdf_curs &curs, gcli::FGclicmdc &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGclicmdc.c_gclicmdf_curs.ValidQ
inline bool          gclicmdc_c_gclicmdf_curs_ValidQ(gclicmdc_c_gclicmdf_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGclicmdc.c_gclicmdf_curs.Next
inline void          gclicmdc_c_gclicmdf_curs_Next(gclicmdc_c_gclicmdf_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGclicmdc.c_gclicmdf_curs.Access
inline gcli::FGclicmdf& gclicmdc_c_gclicmdf_curs_Access(gclicmdc_c_gclicmdf_curs &curs) __attribute__((nothrow));
// func:gcli.FGclicmdc..Uninit
void                 FGclicmdc_Uninit(gcli::FGclicmdc& gclicmdc) __attribute__((nothrow));

// --- gcli.FGclicmdf
// create: gcli.FDb.gclicmdf (Lary)
// global access: gclicmdf (Lary, by rowid)
// global access: ind_gclicmdf (Thash, hash field gclicmdf)
// access: gcli.FGclicmdc.c_gclicmdf (Ptrary)
// access: gcli.FGclicmdj2f.c_gclicmdf (Ptrary)
struct FGclicmdf { // gcli.FGclicmdf: fields
    gcli::FGclicmdf*    ind_gclicmdf_next;            // hash next
    algo::Smallstr250   gclicmdf;                     //
    algo::cstring       uval;                         //
    bool                gclicmdc_c_gclicmdf_in_ary;   //   false  membership flag
    // func:gcli.FGclicmdf..AssignOp
    inline gcli::FGclicmdf& operator =(const gcli::FGclicmdf &rhs) = delete;
    // func:gcli.FGclicmdf..CopyCtor
    inline               FGclicmdf(const gcli::FGclicmdf &rhs) = delete;
private:
    // func:gcli.FGclicmdf..Ctor
    inline               FGclicmdf() __attribute__((nothrow));
    // func:gcli.FGclicmdf..Dtor
    inline               ~FGclicmdf() __attribute__((nothrow));
    friend gcli::FGclicmdf&     gclicmdf_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdf*     gclicmdf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdf_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdf_RemoveLast() __attribute__((nothrow));
};

// func:gcli.FGclicmdf.gclicmd.Get
algo::Smallstr250    gclicmd_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdf.field.Get
algo::Smallstr100    field_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdf.name.Get
algo::cstring        name_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdf.gclicmdc.Get
algo::cstring        gclicmdc_Get(gcli::FGclicmdf& gclicmdf) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmdf..Init
inline void          FGclicmdf_Init(gcli::FGclicmdf& gclicmdf);
// func:gcli.FGclicmdf..Concat_gclicmd_field
tempstr              FGclicmdf_Concat_gclicmd_field( const algo::strptr& gclicmd ,const algo::strptr& field );
// func:gcli.FGclicmdf..Concat_gclicmdc_name
tempstr              FGclicmdf_Concat_gclicmdc_name( const algo::strptr& gclicmdc ,const algo::strptr& name );
// func:gcli.FGclicmdf..Uninit
void                 FGclicmdf_Uninit(gcli::FGclicmdf& gclicmdf) __attribute__((nothrow));

// --- gcli.FGclicmdf2j
// create: gcli.FDb.gclicmdf2j (Lary)
// global access: gclicmdf2j (Lary, by rowid)
// access: gcli.FGclicmd.c_gclicmdf2j (Ptrary)
struct FGclicmdf2j { // gcli.FGclicmdf2j: mapping field to json key
    algo::Smallstr250   gclicmdf2j;                    //
    bool                dup;                           //   false
    algo::Comment       comment;                       //
    gcli::FGclicmd*     p_gclicmd;                     // reference to parent row
    bool                gclicmd_c_gclicmdf2j_in_ary;   //   false  membership flag
    // x-reference on gcli.FGclicmdf2j.p_gclicmd prevents copy
    // func:gcli.FGclicmdf2j..AssignOp
    gcli::FGclicmdf2j&   operator =(const gcli::FGclicmdf2j &rhs) = delete;
    // x-reference on gcli.FGclicmdf2j.p_gclicmd prevents copy
    // func:gcli.FGclicmdf2j..CopyCtor
    FGclicmdf2j(const gcli::FGclicmdf2j &rhs) = delete;
private:
    // func:gcli.FGclicmdf2j..Ctor
    inline               FGclicmdf2j() __attribute__((nothrow));
    // func:gcli.FGclicmdf2j..Dtor
    inline               ~FGclicmdf2j() __attribute__((nothrow));
    friend gcli::FGclicmdf2j&   gclicmdf2j_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdf2j*   gclicmdf2j_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdf2j_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdf2j_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGclicmdf2j.base.CopyOut
void                 gclicmdf2j_CopyOut(gcli::FGclicmdf2j &row, gclidb::Gclicmdf2j &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGclicmdf2j.base.CopyIn
void                 gclicmdf2j_CopyIn(gcli::FGclicmdf2j &row, gclidb::Gclicmdf2j &in) __attribute__((nothrow));

// func:gcli.FGclicmdf2j.gclicmdf.Get
algo::cstring        gclicmdf_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdf2j.gclicmd.Get
algo::Smallstr250    gclicmd_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdf2j.field.Get
algo::Smallstr100    field_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdf2j.jkey.Get
algo::cstring        jkey_Get(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmdf2j..Init
inline void          FGclicmdf2j_Init(gcli::FGclicmdf2j& gclicmdf2j);
// func:gcli.FGclicmdf2j..Uninit
void                 FGclicmdf2j_Uninit(gcli::FGclicmdf2j& gclicmdf2j) __attribute__((nothrow));

// --- gcli.FGclicmdj2f
// create: gcli.FDb.gclicmdj2f (Lary)
// global access: gclicmdj2f (Lary, by rowid)
// global access: ind_gclicmdj2f (Thash, hash field gclicmdj2f)
struct FGclicmdj2f { // gcli.FGclicmdj2f
    gcli::FGclicmdj2f*   ind_gclicmdj2f_next;   // hash next
    algo::Smallstr250    gclicmdj2f;            //
    bool                 select;                //   false
    bool                 dup;                   //   false
    gcli::FGclicmdf**    c_gclicmdf_elems;      // array of pointers
    u32                  c_gclicmdf_n;          // array of pointers
    u32                  c_gclicmdf_max;        // capacity of allocated array
    // reftype Ptrary of gcli.FGclicmdj2f.c_gclicmdf prohibits copy
    // func:gcli.FGclicmdj2f..AssignOp
    inline gcli::FGclicmdj2f& operator =(const gcli::FGclicmdj2f &rhs) = delete;
    // reftype Ptrary of gcli.FGclicmdj2f.c_gclicmdf prohibits copy
    // func:gcli.FGclicmdj2f..CopyCtor
    inline               FGclicmdj2f(const gcli::FGclicmdj2f &rhs) = delete;
private:
    // func:gcli.FGclicmdj2f..Ctor
    inline               FGclicmdj2f() __attribute__((nothrow));
    // func:gcli.FGclicmdj2f..Dtor
    inline               ~FGclicmdj2f() __attribute__((nothrow));
    friend gcli::FGclicmdj2f&   gclicmdj2f_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdj2f*   gclicmdj2f_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdj2f_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdj2f_RemoveLast() __attribute__((nothrow));
};

// func:gcli.FGclicmdj2f.gclicmd.Get
algo::Smallstr250    gclicmd_Get(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdj2f.jkey.Get
algo::cstring        jkey_Get(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:gcli.FGclicmdj2f.c_gclicmdf.EmptyQ
inline bool          c_gclicmdf_EmptyQ(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGclicmdj2f.c_gclicmdf.Find
inline gcli::FGclicmdf* c_gclicmdf_Find(gcli::FGclicmdj2f& gclicmdj2f, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGclicmdj2f.c_gclicmdf.Getary
inline algo::aryptr<gcli::FGclicmdf*> c_gclicmdf_Getary(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGclicmdj2f.c_gclicmdf.Insert
void                 c_gclicmdf_Insert(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:gcli.FGclicmdj2f.c_gclicmdf.ScanInsertMaybe
bool                 c_gclicmdf_ScanInsertMaybe(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGclicmdj2f.c_gclicmdf.N
inline i32           c_gclicmdf_N(const gcli::FGclicmdj2f& gclicmdj2f) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGclicmdj2f.c_gclicmdf.Remove
void                 c_gclicmdf_Remove(gcli::FGclicmdj2f& gclicmdj2f, gcli::FGclicmdf& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGclicmdj2f.c_gclicmdf.RemoveAll
inline void          c_gclicmdf_RemoveAll(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGclicmdj2f.c_gclicmdf.Reserve
void                 c_gclicmdf_Reserve(gcli::FGclicmdj2f& gclicmdj2f, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGclicmdj2f.c_gclicmdf.qFind
inline gcli::FGclicmdf& c_gclicmdf_qFind(gcli::FGclicmdj2f& gclicmdj2f, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGclicmdj2f.c_gclicmdf.qLast
inline gcli::FGclicmdf& c_gclicmdf_qLast(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmdj2f..Init
inline void          FGclicmdj2f_Init(gcli::FGclicmdj2f& gclicmdj2f);
// func:gcli.FGclicmdj2f..Concat_gclicmd_jkey
tempstr              FGclicmdj2f_Concat_gclicmd_jkey( const algo::strptr& gclicmd ,const algo::strptr& jkey );
// func:gcli.FGclicmdj2f.c_gclicmdf_curs.Reset
inline void          gclicmdj2f_c_gclicmdf_curs_Reset(gclicmdj2f_c_gclicmdf_curs &curs, gcli::FGclicmdj2f &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGclicmdj2f.c_gclicmdf_curs.ValidQ
inline bool          gclicmdj2f_c_gclicmdf_curs_ValidQ(gclicmdj2f_c_gclicmdf_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGclicmdj2f.c_gclicmdf_curs.Next
inline void          gclicmdj2f_c_gclicmdf_curs_Next(gclicmdj2f_c_gclicmdf_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGclicmdj2f.c_gclicmdf_curs.Access
inline gcli::FGclicmdf& gclicmdj2f_c_gclicmdf_curs_Access(gclicmdj2f_c_gclicmdf_curs &curs) __attribute__((nothrow));
// func:gcli.FGclicmdj2f..Uninit
void                 FGclicmdj2f_Uninit(gcli::FGclicmdj2f& gclicmdj2f) __attribute__((nothrow));

// --- gcli.FGclicmdt
// create: gcli.FDb.gclicmdt (Lary)
// global access: gclicmdt (Lary, by rowid)
// global access: ind_gclicmdt (Thash, hash field gclicmdt)
struct FGclicmdt { // gcli.FGclicmdt
    gcli::FGclicmdt*    ind_gclicmdt_next;   // hash next
    algo::Smallstr250   gclicmdt;            //
    algo::Smallstr50    gmethod;             //   "GET"
    algo::Comment       uri;                 //
    algo::Comment       comment;             //
    gcli::FGclicmd*     p_gclicmd;           // reference to parent row
    gcli::FGtype*       p_gtype;             // reference to parent row
    // x-reference on gcli.FGclicmdt.p_gclicmd prevents copy
    // x-reference on gcli.FGclicmdt.p_gtype prevents copy
    // func:gcli.FGclicmdt..AssignOp
    inline gcli::FGclicmdt& operator =(const gcli::FGclicmdt &rhs) = delete;
    // x-reference on gcli.FGclicmdt.p_gclicmd prevents copy
    // x-reference on gcli.FGclicmdt.p_gtype prevents copy
    // func:gcli.FGclicmdt..CopyCtor
    inline               FGclicmdt(const gcli::FGclicmdt &rhs) = delete;
private:
    // func:gcli.FGclicmdt..Ctor
    inline               FGclicmdt() __attribute__((nothrow));
    // func:gcli.FGclicmdt..Dtor
    inline               ~FGclicmdt() __attribute__((nothrow));
    friend gcli::FGclicmdt&     gclicmdt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGclicmdt*     gclicmdt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gclicmdt_RemoveAll() __attribute__((nothrow));
    friend void                 gclicmdt_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGclicmdt.base.CopyOut
void                 gclicmdt_CopyOut(gcli::FGclicmdt &row, gclidb::Gclicmdt &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGclicmdt.base.CopyIn
void                 gclicmdt_CopyIn(gcli::FGclicmdt &row, gclidb::Gclicmdt &in) __attribute__((nothrow));

// func:gcli.FGclicmdt.gclicmd.Get
algo::Smallstr250    gclicmd_Get(gcli::FGclicmdt& gclicmdt) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGclicmdt.gtype.Get
algo::Smallstr50     gtype_Get(gcli::FGclicmdt& gclicmdt) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGclicmdt..Init
inline void          FGclicmdt_Init(gcli::FGclicmdt& gclicmdt);
// func:gcli.FGclicmdt..Uninit
void                 FGclicmdt_Uninit(gcli::FGclicmdt& gclicmdt) __attribute__((nothrow));

// --- gcli.FGfld
// create: gcli.FDb.gfld (Lary)
// global access: gfld (Lary, by rowid)
// global access: ind_gfld (Thash, hash field gfld)
// global access: c_gfld (Ptrary)
// access: gcli.FGtblactfld.p_gfld (Upptr)
struct FGfld { // gcli.FGfld
    gcli::FGfld*          ind_gfld_next;        // hash next
    algo::Smallstr50      gfld;                 //
    algo::Comment         comment;              //
    gcli::FGtblactfld**   c_gtblactfld_elems;   // array of pointers
    u32                   c_gtblactfld_n;       // array of pointers
    u32                   c_gtblactfld_max;     // capacity of allocated array
    bool                  _db_c_gfld_in_ary;    //   false  membership flag
    // reftype Ptrary of gcli.FGfld.c_gtblactfld prohibits copy
    // func:gcli.FGfld..AssignOp
    inline gcli::FGfld&  operator =(const gcli::FGfld &rhs) = delete;
    // reftype Ptrary of gcli.FGfld.c_gtblactfld prohibits copy
    // func:gcli.FGfld..CopyCtor
    inline               FGfld(const gcli::FGfld &rhs) = delete;
private:
    // func:gcli.FGfld..Ctor
    inline               FGfld() __attribute__((nothrow));
    // func:gcli.FGfld..Dtor
    inline               ~FGfld() __attribute__((nothrow));
    friend gcli::FGfld&         gfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGfld*         gfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gfld_RemoveAll() __attribute__((nothrow));
    friend void                 gfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGfld.base.CopyOut
void                 gfld_CopyOut(gcli::FGfld &row, gclidb::Gfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGfld.base.CopyIn
void                 gfld_CopyIn(gcli::FGfld &row, gclidb::Gfld &in) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGfld.c_gtblactfld.EmptyQ
inline bool          c_gtblactfld_EmptyQ(gcli::FGfld& gfld) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGfld.c_gtblactfld.Find
inline gcli::FGtblactfld* c_gtblactfld_Find(gcli::FGfld& gfld, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGfld.c_gtblactfld.Getary
inline algo::aryptr<gcli::FGtblactfld*> c_gtblactfld_Getary(gcli::FGfld& gfld) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGfld.c_gtblactfld.Insert
void                 c_gtblactfld_Insert(gcli::FGfld& gfld, gcli::FGtblactfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGfld.c_gtblactfld.InsertMaybe
bool                 c_gtblactfld_InsertMaybe(gcli::FGfld& gfld, gcli::FGtblactfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGfld.c_gtblactfld.N
inline i32           c_gtblactfld_N(const gcli::FGfld& gfld) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGfld.c_gtblactfld.Remove
void                 c_gtblactfld_Remove(gcli::FGfld& gfld, gcli::FGtblactfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGfld.c_gtblactfld.RemoveAll
inline void          c_gtblactfld_RemoveAll(gcli::FGfld& gfld) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGfld.c_gtblactfld.Reserve
void                 c_gtblactfld_Reserve(gcli::FGfld& gfld, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGfld.c_gtblactfld.qFind
inline gcli::FGtblactfld& c_gtblactfld_qFind(gcli::FGfld& gfld, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGfld.c_gtblactfld.InAryQ
inline bool          gfld_c_gtblactfld_InAryQ(gcli::FGtblactfld& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGfld.c_gtblactfld.qLast
inline gcli::FGtblactfld& c_gtblactfld_qLast(gcli::FGfld& gfld) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGfld..Init
inline void          FGfld_Init(gcli::FGfld& gfld);
// func:gcli.FGfld.c_gtblactfld_curs.Reset
inline void          gfld_c_gtblactfld_curs_Reset(gfld_c_gtblactfld_curs &curs, gcli::FGfld &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGfld.c_gtblactfld_curs.ValidQ
inline bool          gfld_c_gtblactfld_curs_ValidQ(gfld_c_gtblactfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGfld.c_gtblactfld_curs.Next
inline void          gfld_c_gtblactfld_curs_Next(gfld_c_gtblactfld_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGfld.c_gtblactfld_curs.Access
inline gcli::FGtblactfld& gfld_c_gtblactfld_curs_Access(gfld_c_gtblactfld_curs &curs) __attribute__((nothrow));
// func:gcli.FGfld..Uninit
void                 FGfld_Uninit(gcli::FGfld& gfld) __attribute__((nothrow));

// --- gcli.FGithost
// create: gcli.FDb.githost (Lary)
// global access: githost (Lary, by rowid)
// global access: ind_githost (Thash, hash field githost)
struct FGithost { // gcli.FGithost
    gcli::FGithost*     ind_githost_next;   // hash next
    algo::Smallstr250   githost;            //
    algo::cstring       ip;                 //
    algo::cstring       id;                 //
    algo::cstring       id_file;            //
    algo::cstring       port;               //
    algo::cstring       user;               //
    algo::cstring       ssh_config;         //
    algo::cstring       ssh_cmd;            //
    // func:gcli.FGithost..AssignOp
    inline gcli::FGithost& operator =(const gcli::FGithost &rhs) = delete;
    // func:gcli.FGithost..CopyCtor
    inline               FGithost(const gcli::FGithost &rhs) = delete;
private:
    // func:gcli.FGithost..Ctor
    inline               FGithost() __attribute__((nothrow));
    // func:gcli.FGithost..Dtor
    inline               ~FGithost() __attribute__((nothrow));
    friend gcli::FGithost&      githost_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGithost*      githost_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 githost_RemoveAll() __attribute__((nothrow));
    friend void                 githost_RemoveLast() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:gcli.FGithost..Init
inline void          FGithost_Init(gcli::FGithost& githost);
// func:gcli.FGithost..Uninit
void                 FGithost_Uninit(gcli::FGithost& githost) __attribute__((nothrow));

// --- gcli.FGmethod
// create: gcli.FDb.gmethod (Lary)
// global access: gmethod (Lary, by rowid)
// global access: ind_gmethod (Thash, hash field gmethod)
struct FGmethod { // gcli.FGmethod
    gcli::FGmethod*    ind_gmethod_next;   // hash next
    algo::Smallstr50   gmethod;            //
    u32                val;                //   0
    algo::Comment      comment;            //
    // func:gcli.FGmethod..AssignOp
    inline gcli::FGmethod& operator =(const gcli::FGmethod &rhs) = delete;
    // func:gcli.FGmethod..CopyCtor
    inline               FGmethod(const gcli::FGmethod &rhs) = delete;
private:
    // func:gcli.FGmethod..Ctor
    inline               FGmethod() __attribute__((nothrow));
    // func:gcli.FGmethod..Dtor
    inline               ~FGmethod() __attribute__((nothrow));
    friend gcli::FGmethod&      gmethod_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGmethod*      gmethod_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gmethod_RemoveAll() __attribute__((nothrow));
    friend void                 gmethod_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGmethod.base.CopyOut
void                 gmethod_CopyOut(gcli::FGmethod &row, gclidb::Gmethod &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGmethod.base.CopyIn
void                 gmethod_CopyIn(gcli::FGmethod &row, gclidb::Gmethod &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGmethod..Init
inline void          FGmethod_Init(gcli::FGmethod& gmethod);
// func:gcli.FGmethod..Uninit
void                 FGmethod_Uninit(gcli::FGmethod& gmethod) __attribute__((nothrow));

// --- gcli.FGrepo
// create: gcli.FDb.grepo (Lary)
// global access: ind_grepo (Thash, hash field grepo)
// global access: grepo (Lary, by rowid)
struct FGrepo { // gcli.FGrepo
    gcli::FGrepo*       ind_grepo_next;   // hash next
    algo::Smallstr250   grepo;            // gcli host/full name
    algo::cstring       name;             // gcli full name
    algo::cstring       token;            // gitlab project or repo access token
    algo::cstring       default_branch;   //   "origin"  gcli remote used in the workflow
    algo::cstring       keyid;            // gcli project id or repo
    algo::cstring       ssh_repo;         //
    algo::cstring       web_url;          //
    algo::cstring       descr;            //
    bool                active;           //   true  set to false to ignore the line but keep it in the file
    algo::cstring       priv;             //
    bool                select;           //   false
    algo::cstring       gitremote_cmd;    //
    // func:gcli.FGrepo..AssignOp
    gcli::FGrepo&        operator =(const gcli::FGrepo &rhs) = delete;
    // func:gcli.FGrepo..CopyCtor
    FGrepo(const gcli::FGrepo &rhs) = delete;
private:
    // func:gcli.FGrepo..Ctor
    inline               FGrepo() __attribute__((nothrow));
    // func:gcli.FGrepo..Dtor
    inline               ~FGrepo() __attribute__((nothrow));
    friend gcli::FGrepo&        grepo_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGrepo*        grepo_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 grepo_RemoveAll() __attribute__((nothrow));
    friend void                 grepo_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGrepo.base.CopyOut
void                 grepo_CopyOut(gcli::FGrepo &row, gclidb::Grepo &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGrepo.base.CopyIn
void                 grepo_CopyIn(gcli::FGrepo &row, gclidb::Grepo &in) __attribute__((nothrow));

// func:gcli.FGrepo.host.Get
algo::cstring        host_Get(gcli::FGrepo& grepo) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGrepo.fname.Get
algo::cstring        fname_Get(gcli::FGrepo& grepo) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGrepo..Init
void                 FGrepo_Init(gcli::FGrepo& grepo);
// func:gcli.FGrepo..Uninit
void                 FGrepo_Uninit(gcli::FGrepo& grepo) __attribute__((nothrow));

// --- gcli.FGrepogitport
// create: gcli.FDb.grepogitport (Lary)
// global access: grepogitport (Lary, by rowid)
// global access: ind_grepogitport (Thash, hash field grepogitport)
struct FGrepogitport { // gcli.FGrepogitport
    gcli::FGrepogitport*   ind_grepogitport_next;   // hash next
    algo::Smallstr50       grepogitport;            // grepo git host
    algo::cstring          port;                    // ssh port for config
    algo::Comment          comment;                 //
    // func:gcli.FGrepogitport..AssignOp
    inline gcli::FGrepogitport& operator =(const gcli::FGrepogitport &rhs) = delete;
    // func:gcli.FGrepogitport..CopyCtor
    inline               FGrepogitport(const gcli::FGrepogitport &rhs) = delete;
private:
    // func:gcli.FGrepogitport..Ctor
    inline               FGrepogitport() __attribute__((nothrow));
    // func:gcli.FGrepogitport..Dtor
    inline               ~FGrepogitport() __attribute__((nothrow));
    friend gcli::FGrepogitport& grepogitport_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGrepogitport* grepogitport_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 grepogitport_RemoveAll() __attribute__((nothrow));
    friend void                 grepogitport_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGrepogitport.base.CopyOut
void                 grepogitport_CopyOut(gcli::FGrepogitport &row, gclidb::Grepogitport &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGrepogitport.base.CopyIn
void                 grepogitport_CopyIn(gcli::FGrepogitport &row, gclidb::Grepogitport &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGrepogitport..Init
inline void          FGrepogitport_Init(gcli::FGrepogitport& grepogitport);
// func:gcli.FGrepogitport..Uninit
void                 FGrepogitport_Uninit(gcli::FGrepogitport& grepogitport) __attribute__((nothrow));

// --- gcli.FGrepossh
// create: gcli.FDb.grepossh (Lary)
// global access: grepossh (Lary, by rowid)
// global access: ind_grepossh (Thash, hash field grepossh)
struct FGrepossh { // gcli.FGrepossh
    gcli::FGrepossh*    ind_grepossh_next;   // hash next
    algo::Smallstr50    grepossh;            // grepo project/repo name
    algo::Smallstr200   sshid;               // ssh id key name for ssh config
    algo::Comment       comment;             //
    // func:gcli.FGrepossh..AssignOp
    inline gcli::FGrepossh& operator =(const gcli::FGrepossh &rhs) = delete;
    // func:gcli.FGrepossh..CopyCtor
    inline               FGrepossh(const gcli::FGrepossh &rhs) = delete;
private:
    // func:gcli.FGrepossh..Ctor
    inline               FGrepossh() __attribute__((nothrow));
    // func:gcli.FGrepossh..Dtor
    inline               ~FGrepossh() __attribute__((nothrow));
    friend gcli::FGrepossh&     grepossh_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGrepossh*     grepossh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 grepossh_RemoveAll() __attribute__((nothrow));
    friend void                 grepossh_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGrepossh.base.CopyOut
void                 grepossh_CopyOut(gcli::FGrepossh &row, gclidb::Grepossh &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGrepossh.base.CopyIn
void                 grepossh_CopyIn(gcli::FGrepossh &row, gclidb::Grepossh &in) __attribute__((nothrow));

// func:gcli.FGrepossh.name.Get
algo::cstring        name_Get(gcli::FGrepossh& grepossh) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGrepossh..Init
inline void          FGrepossh_Init(gcli::FGrepossh& grepossh);
// func:gcli.FGrepossh..Uninit
void                 FGrepossh_Uninit(gcli::FGrepossh& grepossh) __attribute__((nothrow));

// --- gcli.FGstatet
// create: gcli.FDb.gstatet (Lary)
// global access: gstatet (Lary, by rowid)
// global access: ind_gstatet (Thash, hash field gstatet)
struct FGstatet { // gcli.FGstatet
    gcli::FGstatet*    ind_gstatet_next;   // hash next
    algo::Smallstr50   gstatet;            //
    algo::cstring      state;              //
    // func:gcli.FGstatet..AssignOp
    inline gcli::FGstatet& operator =(const gcli::FGstatet &rhs) = delete;
    // func:gcli.FGstatet..CopyCtor
    inline               FGstatet(const gcli::FGstatet &rhs) = delete;
private:
    // func:gcli.FGstatet..Ctor
    inline               FGstatet() __attribute__((nothrow));
    // func:gcli.FGstatet..Dtor
    inline               ~FGstatet() __attribute__((nothrow));
    friend gcli::FGstatet&      gstatet_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGstatet*      gstatet_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gstatet_RemoveAll() __attribute__((nothrow));
    friend void                 gstatet_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGstatet.base.CopyOut
void                 gstatet_CopyOut(gcli::FGstatet &row, gclidb::Gstatet &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGstatet.base.CopyIn
void                 gstatet_CopyIn(gcli::FGstatet &row, gclidb::Gstatet &in) __attribute__((nothrow));

// func:gcli.FGstatet.gtype.Get
algo::Smallstr50     gtype_Get(gcli::FGstatet& gstatet) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGstatet.gstate.Get
algo::Smallstr50     gstate_Get(gcli::FGstatet& gstatet) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGstatet..Init
inline void          FGstatet_Init(gcli::FGstatet& gstatet);
// func:gcli.FGstatet..Uninit
void                 FGstatet_Uninit(gcli::FGstatet& gstatet) __attribute__((nothrow));

// --- gcli.FGtbl
// create: gcli.FDb.gtbl (Lary)
// global access: p_gtbl (Ptr)
// global access: gtbl (Lary, by rowid)
// global access: ind_gtbl (Thash, hash field gtbl)
struct FGtbl { // gcli.FGtbl
    gcli::FGtbl*        ind_gtbl_next;     // hash next
    algo::Smallstr250   gtbl;              //
    algo::Comment       comment;           //
    algo::cstring       id;                //
    bool                set_as_dflt;       //   false
    bool                tail_dot;          //   false
    gcli::FGtblact**    c_gtblact_elems;   // array of pointers
    u32                 c_gtblact_n;       // array of pointers
    u32                 c_gtblact_max;     // capacity of allocated array
    // reftype Ptrary of gcli.FGtbl.c_gtblact prohibits copy
    // func:gcli.FGtbl..AssignOp
    inline gcli::FGtbl&  operator =(const gcli::FGtbl &rhs) = delete;
    // reftype Ptrary of gcli.FGtbl.c_gtblact prohibits copy
    // func:gcli.FGtbl..CopyCtor
    inline               FGtbl(const gcli::FGtbl &rhs) = delete;
private:
    // func:gcli.FGtbl..Ctor
    inline               FGtbl() __attribute__((nothrow));
    // func:gcli.FGtbl..Dtor
    inline               ~FGtbl() __attribute__((nothrow));
    friend gcli::FGtbl&         gtbl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtbl*         gtbl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtbl_RemoveAll() __attribute__((nothrow));
    friend void                 gtbl_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGtbl.base.CopyOut
void                 gtbl_CopyOut(gcli::FGtbl &row, gclidb::Gtbl &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGtbl.base.CopyIn
void                 gtbl_CopyIn(gcli::FGtbl &row, gclidb::Gtbl &in) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGtbl.c_gtblact.EmptyQ
inline bool          c_gtblact_EmptyQ(gcli::FGtbl& gtbl) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGtbl.c_gtblact.Find
inline gcli::FGtblact* c_gtblact_Find(gcli::FGtbl& gtbl, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGtbl.c_gtblact.Getary
inline algo::aryptr<gcli::FGtblact*> c_gtblact_Getary(gcli::FGtbl& gtbl) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGtbl.c_gtblact.Insert
void                 c_gtblact_Insert(gcli::FGtbl& gtbl, gcli::FGtblact& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGtbl.c_gtblact.InsertMaybe
bool                 c_gtblact_InsertMaybe(gcli::FGtbl& gtbl, gcli::FGtblact& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGtbl.c_gtblact.N
inline i32           c_gtblact_N(const gcli::FGtbl& gtbl) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGtbl.c_gtblact.Remove
void                 c_gtblact_Remove(gcli::FGtbl& gtbl, gcli::FGtblact& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGtbl.c_gtblact.RemoveAll
inline void          c_gtblact_RemoveAll(gcli::FGtbl& gtbl) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGtbl.c_gtblact.Reserve
void                 c_gtblact_Reserve(gcli::FGtbl& gtbl, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGtbl.c_gtblact.qFind
inline gcli::FGtblact& c_gtblact_qFind(gcli::FGtbl& gtbl, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGtbl.c_gtblact.InAryQ
inline bool          gtbl_c_gtblact_InAryQ(gcli::FGtblact& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGtbl.c_gtblact.qLast
inline gcli::FGtblact& c_gtblact_qLast(gcli::FGtbl& gtbl) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGtbl..Init
inline void          FGtbl_Init(gcli::FGtbl& gtbl);
// func:gcli.FGtbl.c_gtblact_curs.Reset
inline void          gtbl_c_gtblact_curs_Reset(gtbl_c_gtblact_curs &curs, gcli::FGtbl &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGtbl.c_gtblact_curs.ValidQ
inline bool          gtbl_c_gtblact_curs_ValidQ(gtbl_c_gtblact_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGtbl.c_gtblact_curs.Next
inline void          gtbl_c_gtblact_curs_Next(gtbl_c_gtblact_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGtbl.c_gtblact_curs.Access
inline gcli::FGtblact& gtbl_c_gtblact_curs_Access(gtbl_c_gtblact_curs &curs) __attribute__((nothrow));
// func:gcli.FGtbl..Uninit
void                 FGtbl_Uninit(gcli::FGtbl& gtbl) __attribute__((nothrow));

// --- gcli.FGtblact
// create: gcli.FDb.gtblact (Lary)
// global access: gtblact (Lary, by rowid)
// global access: ind_gtblact (Thash, hash field gtblact)
// global access: zd_gtblact (Llist)
// access: gcli.FGtbl.c_gtblact (Ptrary)
// access: gcli.FGtblact.step (Hook)
struct FGtblact { // gcli.FGtblact
    gcli::FGtblact*           ind_gtblact_next;        // hash next
    gcli::FGtblact*           zd_gtblact_next;         // zslist link; -1 means not-in-list
    gcli::FGtblact*           zd_gtblact_prev;         // previous element
    algo::Smallstr50          gtblact;                 //
    bool                      t;                       //   false
    bool                      e;                       //   false
    bool                      auth;                    //   false
    algo::cstring             id;                      //
    gcli::gtblact_step_hook   step;                    //   NULL  Pointer to a function
    gcli::FGtblactfld**       c_gtblactfld_elems;      // array of pointers
    u32                       c_gtblactfld_n;          // array of pointers
    u32                       c_gtblactfld_max;        // capacity of allocated array
    bool                      select;                  //   false
    algo::cstring             aliascmd;                //
    bool                      gtbl_c_gtblact_in_ary;   //   false  membership flag
    // reftype Hook of gcli.FGtblact.step prohibits copy
    // reftype Ptrary of gcli.FGtblact.c_gtblactfld prohibits copy
    // func:gcli.FGtblact..AssignOp
    gcli::FGtblact&      operator =(const gcli::FGtblact &rhs) = delete;
    // reftype Hook of gcli.FGtblact.step prohibits copy
    // reftype Ptrary of gcli.FGtblact.c_gtblactfld prohibits copy
    // func:gcli.FGtblact..CopyCtor
    FGtblact(const gcli::FGtblact &rhs) = delete;
private:
    // func:gcli.FGtblact..Ctor
    inline               FGtblact() __attribute__((nothrow));
    // func:gcli.FGtblact..Dtor
    inline               ~FGtblact() __attribute__((nothrow));
    friend gcli::FGtblact&      gtblact_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtblact*      gtblact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtblact_RemoveAll() __attribute__((nothrow));
    friend void                 gtblact_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGtblact.base.CopyOut
void                 gtblact_CopyOut(gcli::FGtblact &row, gclidb::Gtblact &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGtblact.base.CopyIn
void                 gtblact_CopyIn(gcli::FGtblact &row, gclidb::Gtblact &in) __attribute__((nothrow));

// func:gcli.FGtblact.gtbl.Get
algo::Smallstr250    gtbl_Get(gcli::FGtblact& gtblact) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGtblact.gact.Get
algo::Smallstr50     gact_Get(gcli::FGtblact& gtblact) __attribute__((__warn_unused_result__, nothrow));

// Invoke function by pointer
// func:gcli.FGtblact.step.Call
inline void          step_Call(gcli::FGtblact& gtblact, gcli::FGtblact& arg) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGtblact.c_gtblactfld.EmptyQ
inline bool          c_gtblactfld_EmptyQ(gcli::FGtblact& gtblact) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGtblact.c_gtblactfld.Find
inline gcli::FGtblactfld* c_gtblactfld_Find(gcli::FGtblact& gtblact, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGtblact.c_gtblactfld.Getary
inline algo::aryptr<gcli::FGtblactfld*> c_gtblactfld_Getary(gcli::FGtblact& gtblact) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGtblact.c_gtblactfld.Insert
void                 c_gtblactfld_Insert(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGtblact.c_gtblactfld.InsertMaybe
bool                 c_gtblactfld_InsertMaybe(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGtblact.c_gtblactfld.N
inline i32           c_gtblactfld_N(const gcli::FGtblact& gtblact) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGtblact.c_gtblactfld.Remove
void                 c_gtblactfld_Remove(gcli::FGtblact& gtblact, gcli::FGtblactfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGtblact.c_gtblactfld.RemoveAll
inline void          c_gtblactfld_RemoveAll(gcli::FGtblact& gtblact) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGtblact.c_gtblactfld.Reserve
void                 c_gtblactfld_Reserve(gcli::FGtblact& gtblact, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGtblact.c_gtblactfld.qFind
inline gcli::FGtblactfld& c_gtblactfld_qFind(gcli::FGtblact& gtblact, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGtblact.c_gtblactfld.InAryQ
inline bool          gtblact_c_gtblactfld_InAryQ(gcli::FGtblactfld& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGtblact.c_gtblactfld.qLast
inline gcli::FGtblactfld& c_gtblactfld_qLast(gcli::FGtblact& gtblact) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGtblact..Init
void                 FGtblact_Init(gcli::FGtblact& gtblact);
// func:gcli.FGtblact.c_gtblactfld_curs.Reset
inline void          gtblact_c_gtblactfld_curs_Reset(gtblact_c_gtblactfld_curs &curs, gcli::FGtblact &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGtblact.c_gtblactfld_curs.ValidQ
inline bool          gtblact_c_gtblactfld_curs_ValidQ(gtblact_c_gtblactfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGtblact.c_gtblactfld_curs.Next
inline void          gtblact_c_gtblactfld_curs_Next(gtblact_c_gtblactfld_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGtblact.c_gtblactfld_curs.Access
inline gcli::FGtblactfld& gtblact_c_gtblactfld_curs_Access(gtblact_c_gtblactfld_curs &curs) __attribute__((nothrow));
// func:gcli.FGtblact..Uninit
void                 FGtblact_Uninit(gcli::FGtblact& gtblact) __attribute__((nothrow));

// --- gcli.FGtblactfld
// create: gcli.FDb.gtblactfld (Lary)
// global access: gtblactfld (Lary, by rowid)
// global access: ind_gtblactfld (Thash, hash field gtblactfld)
// access: gcli.FGfld.c_gtblactfld (Ptrary)
// access: gcli.FGtblact.c_gtblactfld (Ptrary)
struct FGtblactfld { // gcli.FGtblactfld
    gcli::FGtblactfld*   ind_gtblactfld_next;           // hash next
    algo::Smallstr50     gtblactfld;                    //
    algo::cstring        dflt;                          //
    bool                 field_name_dflt;               //   false
    bool                 optional;                      //   false
    bool                 regx;                          //   false
    algo::Comment        comment;                       //
    algo::cstring        uval;                          //
    algo::cstring        uval2;                         //
    bool                 select;                        //   false
    bool                 present;                       //   false
    bool                 update;                        //   false
    gcli::FGfld*         p_gfld;                        // reference to parent row
    bool                 gfld_c_gtblactfld_in_ary;      //   false  membership flag
    bool                 gtblact_c_gtblactfld_in_ary;   //   false  membership flag
    // x-reference on gcli.FGtblactfld.p_gfld prevents copy
    // func:gcli.FGtblactfld..AssignOp
    gcli::FGtblactfld&   operator =(const gcli::FGtblactfld &rhs) = delete;
    // x-reference on gcli.FGtblactfld.p_gfld prevents copy
    // func:gcli.FGtblactfld..CopyCtor
    FGtblactfld(const gcli::FGtblactfld &rhs) = delete;
private:
    // func:gcli.FGtblactfld..Ctor
    inline               FGtblactfld() __attribute__((nothrow));
    // func:gcli.FGtblactfld..Dtor
    inline               ~FGtblactfld() __attribute__((nothrow));
    friend gcli::FGtblactfld&   gtblactfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtblactfld*   gtblactfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtblactfld_RemoveAll() __attribute__((nothrow));
    friend void                 gtblactfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGtblactfld.base.CopyOut
void                 gtblactfld_CopyOut(gcli::FGtblactfld &row, gclidb::Gtblactfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGtblactfld.base.CopyIn
void                 gtblactfld_CopyIn(gcli::FGtblactfld &row, gclidb::Gtblactfld &in) __attribute__((nothrow));

// func:gcli.FGtblactfld.gtblact.Get
algo::Smallstr50     gtblact_Get(gcli::FGtblactfld& gtblactfld) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGtblactfld.field.Get
algo::Smallstr50     field_Get(gcli::FGtblactfld& gtblactfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGtblactfld..Init
void                 FGtblactfld_Init(gcli::FGtblactfld& gtblactfld);
// func:gcli.FGtblactfld..Uninit
void                 FGtblactfld_Uninit(gcli::FGtblactfld& gtblactfld) __attribute__((nothrow));

// --- gcli.FGtype
// create: gcli.FDb.gtype (Lary)
// global access: gtype (Lary, by rowid)
// global access: p_gtype (Ptr)
// global access: ind_gtype (Thash, hash field gtype)
// access: gcli.FGclicmdt.p_gtype (Upptr)
// access: gcli.FGtypeprefix.p_gtype (Upptr)
struct FGtype { // gcli.FGtype
    gcli::FGtype*          ind_gtype_next;        // hash next
    algo::Smallstr50       gtype;                 //
    algo::cstring          default_url;           //
    algo::Comment          comment;               //
    gcli::FGtypeh**        c_gtypeh_elems;        // array of pointers
    u32                    c_gtypeh_n;            // array of pointers
    u32                    c_gtypeh_max;          // capacity of allocated array
    gcli::FGtypeprefix**   c_gtypeprefix_elems;   // array of pointers
    u32                    c_gtypeprefix_n;       // array of pointers
    u32                    c_gtypeprefix_max;     // capacity of allocated array
    // reftype Ptrary of gcli.FGtype.c_gtypeh prohibits copy
    // reftype Ptrary of gcli.FGtype.c_gtypeprefix prohibits copy
    // func:gcli.FGtype..AssignOp
    inline gcli::FGtype& operator =(const gcli::FGtype &rhs) = delete;
    // reftype Ptrary of gcli.FGtype.c_gtypeh prohibits copy
    // reftype Ptrary of gcli.FGtype.c_gtypeprefix prohibits copy
    // func:gcli.FGtype..CopyCtor
    inline               FGtype(const gcli::FGtype &rhs) = delete;
private:
    // func:gcli.FGtype..Ctor
    inline               FGtype() __attribute__((nothrow));
    // func:gcli.FGtype..Dtor
    inline               ~FGtype() __attribute__((nothrow));
    friend gcli::FGtype&        gtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtype*        gtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtype_RemoveAll() __attribute__((nothrow));
    friend void                 gtype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGtype.base.CopyOut
void                 gtype_CopyOut(gcli::FGtype &row, gclidb::Gtype &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGtype.base.CopyIn
void                 gtype_CopyIn(gcli::FGtype &row, gclidb::Gtype &in) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGtype.c_gtypeh.EmptyQ
inline bool          c_gtypeh_EmptyQ(gcli::FGtype& gtype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGtype.c_gtypeh.Find
inline gcli::FGtypeh* c_gtypeh_Find(gcli::FGtype& gtype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGtype.c_gtypeh.Getary
inline algo::aryptr<gcli::FGtypeh*> c_gtypeh_Getary(gcli::FGtype& gtype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGtype.c_gtypeh.Insert
void                 c_gtypeh_Insert(gcli::FGtype& gtype, gcli::FGtypeh& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGtype.c_gtypeh.InsertMaybe
bool                 c_gtypeh_InsertMaybe(gcli::FGtype& gtype, gcli::FGtypeh& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGtype.c_gtypeh.N
inline i32           c_gtypeh_N(const gcli::FGtype& gtype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGtype.c_gtypeh.Remove
void                 c_gtypeh_Remove(gcli::FGtype& gtype, gcli::FGtypeh& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGtype.c_gtypeh.RemoveAll
inline void          c_gtypeh_RemoveAll(gcli::FGtype& gtype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGtype.c_gtypeh.Reserve
void                 c_gtypeh_Reserve(gcli::FGtype& gtype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGtype.c_gtypeh.qFind
inline gcli::FGtypeh& c_gtypeh_qFind(gcli::FGtype& gtype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGtype.c_gtypeh.InAryQ
inline bool          gtype_c_gtypeh_InAryQ(gcli::FGtypeh& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGtype.c_gtypeh.qLast
inline gcli::FGtypeh& c_gtypeh_qLast(gcli::FGtype& gtype) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FGtype.c_gtypeprefix.EmptyQ
inline bool          c_gtypeprefix_EmptyQ(gcli::FGtype& gtype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FGtype.c_gtypeprefix.Find
inline gcli::FGtypeprefix* c_gtypeprefix_Find(gcli::FGtype& gtype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FGtype.c_gtypeprefix.Getary
inline algo::aryptr<gcli::FGtypeprefix*> c_gtypeprefix_Getary(gcli::FGtype& gtype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FGtype.c_gtypeprefix.Insert
void                 c_gtypeprefix_Insert(gcli::FGtype& gtype, gcli::FGtypeprefix& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FGtype.c_gtypeprefix.InsertMaybe
bool                 c_gtypeprefix_InsertMaybe(gcli::FGtype& gtype, gcli::FGtypeprefix& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FGtype.c_gtypeprefix.N
inline i32           c_gtypeprefix_N(const gcli::FGtype& gtype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FGtype.c_gtypeprefix.Remove
void                 c_gtypeprefix_Remove(gcli::FGtype& gtype, gcli::FGtypeprefix& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FGtype.c_gtypeprefix.RemoveAll
inline void          c_gtypeprefix_RemoveAll(gcli::FGtype& gtype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FGtype.c_gtypeprefix.Reserve
void                 c_gtypeprefix_Reserve(gcli::FGtype& gtype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FGtype.c_gtypeprefix.qFind
inline gcli::FGtypeprefix& c_gtypeprefix_qFind(gcli::FGtype& gtype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FGtype.c_gtypeprefix.InAryQ
inline bool          gtype_c_gtypeprefix_InAryQ(gcli::FGtypeprefix& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FGtype.c_gtypeprefix.qLast
inline gcli::FGtypeprefix& c_gtypeprefix_qLast(gcli::FGtype& gtype) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FGtype..Init
inline void          FGtype_Init(gcli::FGtype& gtype);
// func:gcli.FGtype.c_gtypeh_curs.Reset
inline void          gtype_c_gtypeh_curs_Reset(gtype_c_gtypeh_curs &curs, gcli::FGtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGtype.c_gtypeh_curs.ValidQ
inline bool          gtype_c_gtypeh_curs_ValidQ(gtype_c_gtypeh_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGtype.c_gtypeh_curs.Next
inline void          gtype_c_gtypeh_curs_Next(gtype_c_gtypeh_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGtype.c_gtypeh_curs.Access
inline gcli::FGtypeh& gtype_c_gtypeh_curs_Access(gtype_c_gtypeh_curs &curs) __attribute__((nothrow));
// func:gcli.FGtype.c_gtypeprefix_curs.Reset
inline void          gtype_c_gtypeprefix_curs_Reset(gtype_c_gtypeprefix_curs &curs, gcli::FGtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FGtype.c_gtypeprefix_curs.ValidQ
inline bool          gtype_c_gtypeprefix_curs_ValidQ(gtype_c_gtypeprefix_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FGtype.c_gtypeprefix_curs.Next
inline void          gtype_c_gtypeprefix_curs_Next(gtype_c_gtypeprefix_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FGtype.c_gtypeprefix_curs.Access
inline gcli::FGtypeprefix& gtype_c_gtypeprefix_curs_Access(gtype_c_gtypeprefix_curs &curs) __attribute__((nothrow));
// func:gcli.FGtype..Uninit
void                 FGtype_Uninit(gcli::FGtype& gtype) __attribute__((nothrow));

// --- gcli.FGtypeh
// create: gcli.FDb.gtypeh (Lary)
// global access: gtypeh (Lary, by rowid)
// access: gcli.FGtype.c_gtypeh (Ptrary)
struct FGtypeh { // gcli.FGtypeh
    algo::Smallstr250   gtypeh;                  //
    algo::cstring       header;                  //
    bool                gtype_c_gtypeh_in_ary;   //   false  membership flag
    // func:gcli.FGtypeh..AssignOp
    inline gcli::FGtypeh& operator =(const gcli::FGtypeh &rhs) = delete;
    // func:gcli.FGtypeh..CopyCtor
    inline               FGtypeh(const gcli::FGtypeh &rhs) = delete;
private:
    // func:gcli.FGtypeh..Ctor
    inline               FGtypeh() __attribute__((nothrow));
    // func:gcli.FGtypeh..Dtor
    inline               ~FGtypeh() __attribute__((nothrow));
    friend gcli::FGtypeh&       gtypeh_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtypeh*       gtypeh_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtypeh_RemoveAll() __attribute__((nothrow));
    friend void                 gtypeh_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGtypeh.base.CopyOut
void                 gtypeh_CopyOut(gcli::FGtypeh &row, gclidb::Gtypeh &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGtypeh.base.CopyIn
void                 gtypeh_CopyIn(gcli::FGtypeh &row, gclidb::Gtypeh &in) __attribute__((nothrow));

// func:gcli.FGtypeh.gtype.Get
algo::Smallstr50     gtype_Get(gcli::FGtypeh& gtypeh) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGtypeh.name.Get
algo::cstring        name_Get(gcli::FGtypeh& gtypeh) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGtypeh..Init
inline void          FGtypeh_Init(gcli::FGtypeh& gtypeh);
// func:gcli.FGtypeh..Uninit
void                 FGtypeh_Uninit(gcli::FGtypeh& gtypeh) __attribute__((nothrow));

// --- gcli.FGtypeprefix
// create: gcli.FDb.gtypeprefix (Lary)
// global access: gtypeprefix (Lary, by rowid)
// access: gcli.FGtype.c_gtypeprefix (Ptrary)
struct FGtypeprefix { // gcli.FGtypeprefix
    algo::Smallstr50   gtypeprefix;                  //
    algo::Comment      comment;                      //
    gcli::FGtype*      p_gtype;                      // reference to parent row
    bool               gtype_c_gtypeprefix_in_ary;   //   false  membership flag
    // x-reference on gcli.FGtypeprefix.p_gtype prevents copy
    // func:gcli.FGtypeprefix..AssignOp
    inline gcli::FGtypeprefix& operator =(const gcli::FGtypeprefix &rhs) = delete;
    // x-reference on gcli.FGtypeprefix.p_gtype prevents copy
    // func:gcli.FGtypeprefix..CopyCtor
    inline               FGtypeprefix(const gcli::FGtypeprefix &rhs) = delete;
private:
    // func:gcli.FGtypeprefix..Ctor
    inline               FGtypeprefix() __attribute__((nothrow));
    // func:gcli.FGtypeprefix..Dtor
    inline               ~FGtypeprefix() __attribute__((nothrow));
    friend gcli::FGtypeprefix&  gtypeprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FGtypeprefix*  gtypeprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gtypeprefix_RemoveAll() __attribute__((nothrow));
    friend void                 gtypeprefix_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FGtypeprefix.base.CopyOut
void                 gtypeprefix_CopyOut(gcli::FGtypeprefix &row, gclidb::Gtypeprefix &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FGtypeprefix.base.CopyIn
void                 gtypeprefix_CopyIn(gcli::FGtypeprefix &row, gclidb::Gtypeprefix &in) __attribute__((nothrow));

// func:gcli.FGtypeprefix.gtype.Get
algo::Smallstr50     gtype_Get(gcli::FGtypeprefix& gtypeprefix) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FGtypeprefix.prefix.Get
algo::cstring        prefix_Get(gcli::FGtypeprefix& gtypeprefix) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FGtypeprefix..Init
inline void          FGtypeprefix_Init(gcli::FGtypeprefix& gtypeprefix);
// func:gcli.FGtypeprefix..Uninit
void                 FGtypeprefix_Uninit(gcli::FGtypeprefix& gtypeprefix) __attribute__((nothrow));

// --- gcli.FHttp
struct FHttp { // gcli.FHttp: HTTP request
    algo::cstring       request_uri;                  // URI of requested resource
    algo::cstring       request_content_type;         // Request content type
    algo::cstring       request_body;                 // Request body
    algo::cstring       response_status_line;         // Status line
    u32                 response_status_code;         //   0  Numeric status code
    u32                 request_method;               //   gcli_FHttp_request_method_GET  Request method
    algo::cstring       response_reason_phrase;       // Status message
    algo::cstring*      response_header_elems;        // pointer to elements
    u32                 response_header_n;            // number of elements in array
    u32                 response_header_max;          // max. capacity of array before realloc
    algo::cstring       response_content_type;        // Response content type
    algo::cstring       response_body;                // Response body
    bool                response_content_type_json;   //   false  Flag if response is JSON
    lib_json::FParser   response_json_parser;         // Json parser to parse response body on the fly
    u32                 request_body_sent_bytes;      //   0  Sent bytes in request body
    // value field gcli.FHttp.response_json_parser is not copiable
    // func:gcli.FHttp..AssignOp
    gcli::FHttp&         operator =(const gcli::FHttp &rhs) = delete;
    // func:gcli.FHttp..Ctor
    inline               FHttp() __attribute__((nothrow));
    // func:gcli.FHttp..Dtor
    inline               ~FHttp() __attribute__((nothrow));
    // value field gcli.FHttp.response_json_parser is not copiable
    // func:gcli.FHttp..CopyCtor
    FHttp(const gcli::FHttp &rhs) = delete;
};

// Get value of field as enum type
// func:gcli.FHttp.request_method.GetEnum
inline gcli_FHttp_request_method_Enum request_method_GetEnum(const gcli::FHttp& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:gcli.FHttp.request_method.SetEnum
inline void          request_method_SetEnum(gcli::FHttp& parent, gcli_FHttp_request_method_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:gcli.FHttp.request_method.ToCstr
const char*          request_method_ToCstr(const gcli::FHttp& parent) __attribute__((nothrow));
// Convert request_method to a string. First, attempt conversion to a known string.
// If no string matches, print request_method as a numeric value.
// func:gcli.FHttp.request_method.Print
void                 request_method_Print(const gcli::FHttp& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:gcli.FHttp.request_method.SetStrptrMaybe
bool                 request_method_SetStrptrMaybe(gcli::FHttp& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:gcli.FHttp.request_method.SetStrptr
void                 request_method_SetStrptr(gcli::FHttp& parent, algo::strptr rhs, gcli_FHttp_request_method_Enum dflt) __attribute__((nothrow));

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:gcli.FHttp.response_header.Addary
algo::aryptr<algo::cstring> response_header_Addary(gcli::FHttp& parent, algo::aryptr<algo::cstring> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:gcli.FHttp.response_header.Alloc
algo::cstring&       response_header_Alloc(gcli::FHttp& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:gcli.FHttp.response_header.AllocAt
algo::cstring&       response_header_AllocAt(gcli::FHttp& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:gcli.FHttp.response_header.AllocN
algo::aryptr<algo::cstring> response_header_AllocN(gcli::FHttp& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:gcli.FHttp.response_header.EmptyQ
inline bool          response_header_EmptyQ(gcli::FHttp& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FHttp.response_header.Find
inline algo::cstring* response_header_Find(gcli::FHttp& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:gcli.FHttp.response_header.Getary
inline algo::aryptr<algo::cstring> response_header_Getary(const gcli::FHttp& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:gcli.FHttp.response_header.Last
inline algo::cstring* response_header_Last(gcli::FHttp& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:gcli.FHttp.response_header.Max
inline i32           response_header_Max(gcli::FHttp& parent) __attribute__((nothrow));
// Return number of items in the array
// func:gcli.FHttp.response_header.N
inline i32           response_header_N(const gcli::FHttp& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:gcli.FHttp.response_header.Remove
void                 response_header_Remove(gcli::FHttp& parent, u32 i) __attribute__((nothrow));
// func:gcli.FHttp.response_header.RemoveAll
void                 response_header_RemoveAll(gcli::FHttp& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:gcli.FHttp.response_header.RemoveLast
void                 response_header_RemoveLast(gcli::FHttp& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:gcli.FHttp.response_header.Reserve
inline void          response_header_Reserve(gcli::FHttp& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:gcli.FHttp.response_header.AbsReserve
void                 response_header_AbsReserve(gcli::FHttp& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:gcli.FHttp.response_header.Setary
void                 response_header_Setary(gcli::FHttp& parent, gcli::FHttp &rhs) __attribute__((nothrow));
// Copy specified array into response_header, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:gcli.FHttp.response_header.Setary2
void                 response_header_Setary(gcli::FHttp& parent, const algo::aryptr<algo::cstring> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:gcli.FHttp.response_header.qFind
inline algo::cstring& response_header_qFind(gcli::FHttp& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:gcli.FHttp.response_header.qLast
inline algo::cstring& response_header_qLast(gcli::FHttp& parent) __attribute__((nothrow));
// Return row id of specified element
// func:gcli.FHttp.response_header.rowid_Get
inline u64           response_header_rowid_Get(gcli::FHttp& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:gcli.FHttp.response_header.AllocNVal
algo::aryptr<algo::cstring> response_header_AllocNVal(gcli::FHttp& parent, int n_elems, const algo::cstring& val) __attribute__((nothrow));
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
// func:gcli.FHttp.response_header.ReadStrptrMaybe
bool                 response_header_ReadStrptrMaybe(gcli::FHttp& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
// func:gcli.FHttp.response_header_curs.Next
inline void          FHttp_response_header_curs_Next(FHttp_response_header_curs &curs) __attribute__((nothrow));
// func:gcli.FHttp.response_header_curs.Reset
inline void          FHttp_response_header_curs_Reset(FHttp_response_header_curs &curs, gcli::FHttp &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FHttp.response_header_curs.ValidQ
inline bool          FHttp_response_header_curs_ValidQ(FHttp_response_header_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FHttp.response_header_curs.Access
inline algo::cstring& FHttp_response_header_curs_Access(FHttp_response_header_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:gcli.FHttp..Init
void                 FHttp_Init(gcli::FHttp& parent);
// func:gcli.FHttp..Uninit
void                 FHttp_Uninit(gcli::FHttp& parent) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:gcli.FHttp.String  printfmt:Tuple
// func:gcli.FHttp..Print
void                 FHttp_Print(gcli::FHttp& row, algo::cstring& str) __attribute__((nothrow));

// --- gcli.FIssue
// create: gcli.FDb.issue (Lary)
// global access: ind_issue (Thash, hash field issue)
// global access: issue (Lary, by rowid)
// access: gcli.FGclicmd.p_issue (Ptr)
struct FIssue { // gcli.FIssue
    gcli::FIssue*        ind_issue_next;      // hash next
    algo::Smallstr50     issue;               // Identifier. must be in form project.iid
    algo::Smallstr50     assignee;            // User the issue is assigned to
    algo::cstring        labels;              // issue labels - comma-separated list
    algo::cstring        milestone_iid;       // issue milestone, blank if none
    algo::cstring        milestone_num;       // issue milestone, blank if none
    algo::cstring        milestone;           // issue milestone name, blank if none
    algo::cstring        title;               // issue title
    algo::cstring        author;              // issue author
    algo::cstring        state;               // issue state
    algo::cstring        mr;                  // mr issue
    algo::cstring        description;         // issue description
    bool                 select;              //   false
    gcli::FMr*           p_mr_open;           // optional pointer
    gcli::FMrjob**       c_mrjob_elems;       // array of pointers
    u32                  c_mrjob_n;           // array of pointers
    u32                  c_mrjob_max;         // capacity of allocated array
    gcli::FIssuenote**   c_issuenote_elems;   // array of pointers
    u32                  c_issuenote_n;       // array of pointers
    u32                  c_issuenote_max;     // capacity of allocated array
    // reftype Ptrary of gcli.FIssue.c_mrjob prohibits copy
    // reftype Ptrary of gcli.FIssue.c_issuenote prohibits copy
    // func:gcli.FIssue..AssignOp
    gcli::FIssue&        operator =(const gcli::FIssue &rhs) = delete;
    // reftype Ptrary of gcli.FIssue.c_mrjob prohibits copy
    // reftype Ptrary of gcli.FIssue.c_issuenote prohibits copy
    // func:gcli.FIssue..CopyCtor
    FIssue(const gcli::FIssue &rhs) = delete;
private:
    // func:gcli.FIssue..Ctor
    inline               FIssue() __attribute__((nothrow));
    // func:gcli.FIssue..Dtor
    inline               ~FIssue() __attribute__((nothrow));
    friend gcli::FIssue&        issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FIssue*        issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issue_RemoveAll() __attribute__((nothrow));
    friend void                 issue_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FIssue.base.CopyOut
void                 issue_CopyOut(gcli::FIssue &row, gclidb::Issue &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FIssue.base.CopyIn
void                 issue_CopyIn(gcli::FIssue &row, gclidb::Issue &in) __attribute__((nothrow));

// func:gcli.FIssue.project.Get
algo::Smallstr50     project_Get(gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FIssue.iid.Get
algo::cstring        iid_Get(gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:gcli.FIssue.c_mrjob.EmptyQ
inline bool          c_mrjob_EmptyQ(gcli::FIssue& issue) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FIssue.c_mrjob.Find
inline gcli::FMrjob* c_mrjob_Find(gcli::FIssue& issue, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FIssue.c_mrjob.Getary
inline algo::aryptr<gcli::FMrjob*> c_mrjob_Getary(gcli::FIssue& issue) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FIssue.c_mrjob.Insert
void                 c_mrjob_Insert(gcli::FIssue& issue, gcli::FMrjob& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FIssue.c_mrjob.InsertMaybe
bool                 c_mrjob_InsertMaybe(gcli::FIssue& issue, gcli::FMrjob& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FIssue.c_mrjob.N
inline i32           c_mrjob_N(const gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FIssue.c_mrjob.Remove
void                 c_mrjob_Remove(gcli::FIssue& issue, gcli::FMrjob& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FIssue.c_mrjob.RemoveAll
inline void          c_mrjob_RemoveAll(gcli::FIssue& issue) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FIssue.c_mrjob.Reserve
void                 c_mrjob_Reserve(gcli::FIssue& issue, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FIssue.c_mrjob.qFind
inline gcli::FMrjob& c_mrjob_qFind(gcli::FIssue& issue, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FIssue.c_mrjob.InAryQ
inline bool          issue_c_mrjob_InAryQ(gcli::FMrjob& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FIssue.c_mrjob.qLast
inline gcli::FMrjob& c_mrjob_qLast(gcli::FIssue& issue) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FIssue.c_issuenote.EmptyQ
inline bool          c_issuenote_EmptyQ(gcli::FIssue& issue) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FIssue.c_issuenote.Find
inline gcli::FIssuenote* c_issuenote_Find(gcli::FIssue& issue, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FIssue.c_issuenote.Getary
inline algo::aryptr<gcli::FIssuenote*> c_issuenote_Getary(gcli::FIssue& issue) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FIssue.c_issuenote.Insert
void                 c_issuenote_Insert(gcli::FIssue& issue, gcli::FIssuenote& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FIssue.c_issuenote.InsertMaybe
bool                 c_issuenote_InsertMaybe(gcli::FIssue& issue, gcli::FIssuenote& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FIssue.c_issuenote.N
inline i32           c_issuenote_N(const gcli::FIssue& issue) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FIssue.c_issuenote.Remove
void                 c_issuenote_Remove(gcli::FIssue& issue, gcli::FIssuenote& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FIssue.c_issuenote.RemoveAll
inline void          c_issuenote_RemoveAll(gcli::FIssue& issue) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FIssue.c_issuenote.Reserve
void                 c_issuenote_Reserve(gcli::FIssue& issue, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FIssue.c_issuenote.qFind
inline gcli::FIssuenote& c_issuenote_qFind(gcli::FIssue& issue, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FIssue.c_issuenote.InAryQ
inline bool          issue_c_issuenote_InAryQ(gcli::FIssuenote& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FIssue.c_issuenote.qLast
inline gcli::FIssuenote& c_issuenote_qLast(gcli::FIssue& issue) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FIssue..Init
void                 FIssue_Init(gcli::FIssue& issue);
// func:gcli.FIssue.c_mrjob_curs.Reset
inline void          issue_c_mrjob_curs_Reset(issue_c_mrjob_curs &curs, gcli::FIssue &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FIssue.c_mrjob_curs.ValidQ
inline bool          issue_c_mrjob_curs_ValidQ(issue_c_mrjob_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FIssue.c_mrjob_curs.Next
inline void          issue_c_mrjob_curs_Next(issue_c_mrjob_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FIssue.c_mrjob_curs.Access
inline gcli::FMrjob& issue_c_mrjob_curs_Access(issue_c_mrjob_curs &curs) __attribute__((nothrow));
// func:gcli.FIssue.c_issuenote_curs.Reset
inline void          issue_c_issuenote_curs_Reset(issue_c_issuenote_curs &curs, gcli::FIssue &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FIssue.c_issuenote_curs.ValidQ
inline bool          issue_c_issuenote_curs_ValidQ(issue_c_issuenote_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FIssue.c_issuenote_curs.Next
inline void          issue_c_issuenote_curs_Next(issue_c_issuenote_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FIssue.c_issuenote_curs.Access
inline gcli::FIssuenote& issue_c_issuenote_curs_Access(issue_c_issuenote_curs &curs) __attribute__((nothrow));
// func:gcli.FIssue..Uninit
void                 FIssue_Uninit(gcli::FIssue& issue) __attribute__((nothrow));

// --- gcli.FIssuenote
// create: gcli.FDb.issuenote (Lary)
// global access: issuenote (Lary, by rowid)
// global access: ind_issuenote (Thash, hash field issuenote)
// access: gcli.FIssue.c_issuenote (Ptrary)
struct FIssuenote { // gcli.FIssuenote
    gcli::FIssuenote*   ind_issuenote_next;         // hash next
    algo::Smallstr250   issuenote;                  // Identifier. must be in form issue.id
    algo::cstring       note;                       // Body of issue note
    algo::cstring       system;                     // System or user note (glab only)
    algo::cstring       author;                     // Authtor of issue note
    bool                select;                     //   false
    bool                issue_c_issuenote_in_ary;   //   false  membership flag
    // func:gcli.FIssuenote..AssignOp
    inline gcli::FIssuenote& operator =(const gcli::FIssuenote &rhs) = delete;
    // func:gcli.FIssuenote..CopyCtor
    inline               FIssuenote(const gcli::FIssuenote &rhs) = delete;
private:
    // func:gcli.FIssuenote..Ctor
    inline               FIssuenote() __attribute__((nothrow));
    // func:gcli.FIssuenote..Dtor
    inline               ~FIssuenote() __attribute__((nothrow));
    friend gcli::FIssuenote&    issuenote_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FIssuenote*    issuenote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issuenote_RemoveAll() __attribute__((nothrow));
    friend void                 issuenote_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FIssuenote.base.CopyOut
void                 issuenote_CopyOut(gcli::FIssuenote &row, gclidb::Issuenote &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FIssuenote.base.CopyIn
void                 issuenote_CopyIn(gcli::FIssuenote &row, gclidb::Issuenote &in) __attribute__((nothrow));

// func:gcli.FIssuenote.issue.Get
algo::Smallstr50     issue_Get(gcli::FIssuenote& issuenote) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FIssuenote.nid.Get
algo::cstring        nid_Get(gcli::FIssuenote& issuenote) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FIssuenote..Init
inline void          FIssuenote_Init(gcli::FIssuenote& issuenote);
// func:gcli.FIssuenote..Uninit
void                 FIssuenote_Uninit(gcli::FIssuenote& issuenote) __attribute__((nothrow));

// --- gcli.FMilestone
// create: gcli.FDb.milestone (Lary)
// global access: ind_milestone (Thash, hash field milestone)
// global access: milestone (Lary, by rowid)
struct FMilestone { // gcli.FMilestone
    gcli::FMilestone*   ind_milestone_next;   // hash next
    algo::Smallstr200   milestone;            // Milestone id
    algo::cstring       description;          // Milestone description
    algo::cstring       title;                // Milestone title
    bool                select;               //   false
    // func:gcli.FMilestone..AssignOp
    inline gcli::FMilestone& operator =(const gcli::FMilestone &rhs) = delete;
    // func:gcli.FMilestone..CopyCtor
    inline               FMilestone(const gcli::FMilestone &rhs) = delete;
private:
    // func:gcli.FMilestone..Ctor
    inline               FMilestone() __attribute__((nothrow));
    // func:gcli.FMilestone..Dtor
    inline               ~FMilestone() __attribute__((nothrow));
    friend gcli::FMilestone&    milestone_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMilestone*    milestone_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 milestone_RemoveAll() __attribute__((nothrow));
    friend void                 milestone_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FMilestone.base.CopyOut
void                 milestone_CopyOut(gcli::FMilestone &row, gclidb::Milestone &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FMilestone.base.CopyIn
void                 milestone_CopyIn(gcli::FMilestone &row, gclidb::Milestone &in) __attribute__((nothrow));

// func:gcli.FMilestone.project.Get
algo::Smallstr50     project_Get(gcli::FMilestone& milestone) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FMilestone.iid.Get
algo::cstring        iid_Get(gcli::FMilestone& milestone) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FMilestone..Init
inline void          FMilestone_Init(gcli::FMilestone& milestone);
// func:gcli.FMilestone..Uninit
void                 FMilestone_Uninit(gcli::FMilestone& milestone) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:gcli.FMilestone.String  printfmt:Tuple
// func:gcli.FMilestone..Print
void                 FMilestone_Print(gcli::FMilestone& row, algo::cstring& str) __attribute__((nothrow));

// --- gcli.FMr
// create: gcli.FDb.mr (Lary)
// global access: ind_mr (Thash, hash field mr)
// global access: mr (Lary, by rowid)
// access: gcli.FGclicmd.p_mr (Ptr)
// access: gcli.FIssue.p_mr_open (Ptr)
struct FMr { // gcli.FMr
    gcli::FMr*          ind_mr_next;       // hash next
    algo::Smallstr150   mr;                // Identifier. must be in form project.iid
    algo::cstring       state;             // Mr state
    algo::cstring       title;             // Mr title
    algo::cstring       description;       // Mr description
    algo::cstring       source_branch;     // Source branch
    algo::cstring       source_repo;       // Source branch
    algo::cstring       reviewer;          // Reviewer username
    algo::cstring       author;            // Author username
    algo::Smallstr20    pipeline_status;   // Pipeline status
    algo::cstring       pipeline_id;       // Pipeline id
    algo::cstring       draft;             // Some draft status
    algo::cstring       node_id;           // Node id for graphQL
    gcli::FMrnote**     c_mrnote_elems;    // array of pointers
    u32                 c_mrnote_n;        // array of pointers
    u32                 c_mrnote_max;      // capacity of allocated array
    gcli::FMrjob**      c_mrjob_elems;     // array of pointers
    u32                 c_mrjob_n;         // array of pointers
    u32                 c_mrjob_max;       // capacity of allocated array
    bool                select;            //   false
    // reftype Ptrary of gcli.FMr.c_mrnote prohibits copy
    // reftype Ptrary of gcli.FMr.c_mrjob prohibits copy
    // func:gcli.FMr..AssignOp
    gcli::FMr&           operator =(const gcli::FMr &rhs) = delete;
    // reftype Ptrary of gcli.FMr.c_mrnote prohibits copy
    // reftype Ptrary of gcli.FMr.c_mrjob prohibits copy
    // func:gcli.FMr..CopyCtor
    FMr(const gcli::FMr &rhs) = delete;
private:
    // func:gcli.FMr..Ctor
    inline               FMr() __attribute__((nothrow));
    // func:gcli.FMr..Dtor
    inline               ~FMr() __attribute__((nothrow));
    friend gcli::FMr&           mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMr*           mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mr_RemoveAll() __attribute__((nothrow));
    friend void                 mr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FMr.base.CopyOut
void                 mr_CopyOut(gcli::FMr &row, gclidb::Mr &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FMr.base.CopyIn
void                 mr_CopyIn(gcli::FMr &row, gclidb::Mr &in) __attribute__((nothrow));

// func:gcli.FMr.proj.Get
algo::Smallstr50     proj_Get(gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FMr.iid.Get
algo::cstring        iid_Get(gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:gcli.FMr.c_mrnote.EmptyQ
inline bool          c_mrnote_EmptyQ(gcli::FMr& mr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FMr.c_mrnote.Find
inline gcli::FMrnote* c_mrnote_Find(gcli::FMr& mr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FMr.c_mrnote.Getary
inline algo::aryptr<gcli::FMrnote*> c_mrnote_Getary(gcli::FMr& mr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FMr.c_mrnote.Insert
void                 c_mrnote_Insert(gcli::FMr& mr, gcli::FMrnote& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FMr.c_mrnote.InsertMaybe
bool                 c_mrnote_InsertMaybe(gcli::FMr& mr, gcli::FMrnote& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FMr.c_mrnote.N
inline i32           c_mrnote_N(const gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FMr.c_mrnote.Remove
void                 c_mrnote_Remove(gcli::FMr& mr, gcli::FMrnote& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FMr.c_mrnote.RemoveAll
inline void          c_mrnote_RemoveAll(gcli::FMr& mr) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FMr.c_mrnote.Reserve
void                 c_mrnote_Reserve(gcli::FMr& mr, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FMr.c_mrnote.qFind
inline gcli::FMrnote& c_mrnote_qFind(gcli::FMr& mr, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FMr.c_mrnote.InAryQ
inline bool          mr_c_mrnote_InAryQ(gcli::FMrnote& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FMr.c_mrnote.qLast
inline gcli::FMrnote& c_mrnote_qLast(gcli::FMr& mr) __attribute__((nothrow));

// Return true if index is empty
// func:gcli.FMr.c_mrjob.EmptyQ
inline bool          c_mrjob_EmptyQ(gcli::FMr& mr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:gcli.FMr.c_mrjob.Find
inline gcli::FMrjob* c_mrjob_Find(gcli::FMr& mr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:gcli.FMr.c_mrjob.Getary
inline algo::aryptr<gcli::FMrjob*> c_mrjob_Getary(gcli::FMr& mr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:gcli.FMr.c_mrjob.Insert
void                 c_mrjob_Insert(gcli::FMr& mr, gcli::FMrjob& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:gcli.FMr.c_mrjob.InsertMaybe
bool                 c_mrjob_InsertMaybe(gcli::FMr& mr, gcli::FMrjob& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:gcli.FMr.c_mrjob.N
inline i32           c_mrjob_N(const gcli::FMr& mr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:gcli.FMr.c_mrjob.Remove
void                 c_mrjob_Remove(gcli::FMr& mr, gcli::FMrjob& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:gcli.FMr.c_mrjob.RemoveAll
inline void          c_mrjob_RemoveAll(gcli::FMr& mr) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:gcli.FMr.c_mrjob.Reserve
void                 c_mrjob_Reserve(gcli::FMr& mr, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:gcli.FMr.c_mrjob.qFind
inline gcli::FMrjob& c_mrjob_qFind(gcli::FMr& mr, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:gcli.FMr.c_mrjob.InAryQ
inline bool          mr_c_mrjob_InAryQ(gcli::FMrjob& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:gcli.FMr.c_mrjob.qLast
inline gcli::FMrjob& c_mrjob_qLast(gcli::FMr& mr) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FMr..Init
void                 FMr_Init(gcli::FMr& mr);
// func:gcli.FMr.c_mrnote_curs.Reset
inline void          mr_c_mrnote_curs_Reset(mr_c_mrnote_curs &curs, gcli::FMr &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FMr.c_mrnote_curs.ValidQ
inline bool          mr_c_mrnote_curs_ValidQ(mr_c_mrnote_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FMr.c_mrnote_curs.Next
inline void          mr_c_mrnote_curs_Next(mr_c_mrnote_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FMr.c_mrnote_curs.Access
inline gcli::FMrnote& mr_c_mrnote_curs_Access(mr_c_mrnote_curs &curs) __attribute__((nothrow));
// func:gcli.FMr.c_mrjob_curs.Reset
inline void          mr_c_mrjob_curs_Reset(mr_c_mrjob_curs &curs, gcli::FMr &parent) __attribute__((nothrow));
// cursor points to valid item
// func:gcli.FMr.c_mrjob_curs.ValidQ
inline bool          mr_c_mrjob_curs_ValidQ(mr_c_mrjob_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:gcli.FMr.c_mrjob_curs.Next
inline void          mr_c_mrjob_curs_Next(mr_c_mrjob_curs &curs) __attribute__((nothrow));
// item access
// func:gcli.FMr.c_mrjob_curs.Access
inline gcli::FMrjob& mr_c_mrjob_curs_Access(mr_c_mrjob_curs &curs) __attribute__((nothrow));
// func:gcli.FMr..Uninit
void                 FMr_Uninit(gcli::FMr& mr) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:gcli.FMr.String  printfmt:Tuple
// func:gcli.FMr..Print
void                 FMr_Print(gcli::FMr& row, algo::cstring& str) __attribute__((nothrow));

// --- gcli.FMrjob
// create: gcli.FDb.mrjob (Lary)
// global access: mrjob (Lary, by rowid)
// global access: ind_mrjob (Thash, hash field mrjob)
// access: gcli.FIssue.c_mrjob (Ptrary)
// access: gcli.FMr.c_mrjob (Ptrary)
struct FMrjob { // gcli.FMrjob
    gcli::FMrjob*       ind_mrjob_next;         // hash next
    algo::Smallstr250   mrjob;                  // Identifier. must be in form mr.id
    algo::Smallstr150   ref;                    // Mr portion of mr job
    algo::cstring       id;                     // Job ID
    algo::cstring       name;                   // Job name
    algo::cstring       pipeline_id;            // Pipeline id
    algo::cstring       status;                 //
    algo::cstring       runner;                 //
    bool                select;                 //   false
    bool                issue_c_mrjob_in_ary;   //   false  membership flag
    bool                mr_c_mrjob_in_ary;      //   false  membership flag
    // func:gcli.FMrjob..AssignOp
    gcli::FMrjob&        operator =(const gcli::FMrjob &rhs) = delete;
    // func:gcli.FMrjob..CopyCtor
    FMrjob(const gcli::FMrjob &rhs) = delete;
private:
    // func:gcli.FMrjob..Ctor
    inline               FMrjob() __attribute__((nothrow));
    // func:gcli.FMrjob..Dtor
    inline               ~FMrjob() __attribute__((nothrow));
    friend gcli::FMrjob&        mrjob_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMrjob*        mrjob_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mrjob_RemoveAll() __attribute__((nothrow));
    friend void                 mrjob_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FMrjob.base.CopyOut
void                 mrjob_CopyOut(gcli::FMrjob &row, gclidb::Mrjob &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FMrjob.base.CopyIn
void                 mrjob_CopyIn(gcli::FMrjob &row, gclidb::Mrjob &in) __attribute__((nothrow));

// func:gcli.FMrjob.mr.Get
algo::Smallstr150    mr_Get(gcli::FMrjob& mrjob) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FMrjob.job.Get
algo::cstring        job_Get(gcli::FMrjob& mrjob) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FMrjob..Init
void                 FMrjob_Init(gcli::FMrjob& mrjob);
// func:gcli.FMrjob..Uninit
void                 FMrjob_Uninit(gcli::FMrjob& mrjob) __attribute__((nothrow));

// --- gcli.FMrnote
// create: gcli.FDb.mrnote (Lary)
// global access: mrnote (Lary, by rowid)
// global access: ind_mrnote (Thash, hash field mrnote)
// access: gcli.FMr.c_mrnote (Ptrary)
struct FMrnote { // gcli.FMrnote
    gcli::FMrnote*      ind_mrnote_next;      // hash next
    algo::cstring       system;               // System or user note (glab only)
    algo::Smallstr250   mrnote;               // Identifier. must be in form issue.id
    algo::cstring       note;                 // Body of mr note
    algo::cstring       author;               // Authtor of mr note
    bool                select;               //   false
    bool                mr_c_mrnote_in_ary;   //   false  membership flag
    // func:gcli.FMrnote..AssignOp
    inline gcli::FMrnote& operator =(const gcli::FMrnote &rhs) = delete;
    // func:gcli.FMrnote..CopyCtor
    inline               FMrnote(const gcli::FMrnote &rhs) = delete;
private:
    // func:gcli.FMrnote..Ctor
    inline               FMrnote() __attribute__((nothrow));
    // func:gcli.FMrnote..Dtor
    inline               ~FMrnote() __attribute__((nothrow));
    friend gcli::FMrnote&       mrnote_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FMrnote*       mrnote_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mrnote_RemoveAll() __attribute__((nothrow));
    friend void                 mrnote_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FMrnote.base.CopyOut
void                 mrnote_CopyOut(gcli::FMrnote &row, gclidb::Mrnote &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FMrnote.base.CopyIn
void                 mrnote_CopyIn(gcli::FMrnote &row, gclidb::Mrnote &in) __attribute__((nothrow));

// func:gcli.FMrnote.nid.Get
algo::cstring        nid_Get(gcli::FMrnote& mrnote) __attribute__((__warn_unused_result__, nothrow));

// func:gcli.FMrnote.mr.Get
algo::Smallstr150    mr_Get(gcli::FMrnote& mrnote) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:gcli.FMrnote..Init
inline void          FMrnote_Init(gcli::FMrnote& mrnote);
// func:gcli.FMrnote..Uninit
void                 FMrnote_Uninit(gcli::FMrnote& mrnote) __attribute__((nothrow));

// --- gcli.FTuples
// create: gcli.FDb.tuples (Lary)
// global access: tuples (Lary, by rowid)
// access: gcli.FGclicmd.c_tuples (Ptrary)
struct FTuples { // gcli.FTuples
    algo::cstring   tuples;   //
private:
    // func:gcli.FTuples..Ctor
    inline               FTuples() __attribute__((nothrow));
    friend gcli::FTuples&       tuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FTuples*       tuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tuples_RemoveAll() __attribute__((nothrow));
    friend void                 tuples_RemoveLast() __attribute__((nothrow));
};


// --- gcli.FUser
// create: gcli.FDb.user (Lary)
// global access: user (Lary, by rowid)
// global access: ind_user (Thash, hash field user)
struct FUser { // gcli.FUser
    gcli::FUser*       ind_user_next;   // hash next
    algo::Smallstr50   user;            //
    u32                id;              //   0
    algo::cstring      name;            //
    bool               select;          //   false
    // func:gcli.FUser..AssignOp
    inline gcli::FUser&  operator =(const gcli::FUser &rhs) = delete;
    // func:gcli.FUser..CopyCtor
    inline               FUser(const gcli::FUser &rhs) = delete;
private:
    // func:gcli.FUser..Ctor
    inline               FUser() __attribute__((nothrow));
    // func:gcli.FUser..Dtor
    inline               ~FUser() __attribute__((nothrow));
    friend gcli::FUser&         user_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gcli::FUser*         user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 user_RemoveAll() __attribute__((nothrow));
    friend void                 user_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:gcli.FUser.base.CopyOut
void                 user_CopyOut(gcli::FUser &row, gclidb::User &out) __attribute__((nothrow));
// Copy fields in to row
// func:gcli.FUser.base.CopyIn
void                 user_CopyIn(gcli::FUser &row, gclidb::User &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:gcli.FUser..Init
inline void          FUser_Init(gcli::FUser& user);
// func:gcli.FUser..Uninit
void                 FUser_Uninit(gcli::FUser& user) __attribute__((nothrow));

// --- gcli.FieldId
#pragma pack(push,1)
struct FieldId { // gcli.FieldId: Field read helper
    i32   value;   //   -1
    // func:gcli.FieldId.value.Cast
    inline               operator gcli_FieldIdEnum() const __attribute__((nothrow));
    // func:gcli.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:gcli.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:gcli.FieldId..EnumCtor
    inline               FieldId(gcli_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:gcli.FieldId.value.GetEnum
inline gcli_FieldIdEnum value_GetEnum(const gcli::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:gcli.FieldId.value.SetEnum
inline void          value_SetEnum(gcli::FieldId& parent, gcli_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:gcli.FieldId.value.ToCstr
const char*          value_ToCstr(const gcli::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:gcli.FieldId.value.Print
void                 value_Print(const gcli::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:gcli.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(gcli::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:gcli.FieldId.value.SetStrptr
void                 value_SetStrptr(gcli::FieldId& parent, algo::strptr rhs, gcli_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:gcli.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(gcli::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of gcli::FieldId from an ascii string.
// The format of the string is the format of the gcli::FieldId's only field
// func:gcli.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(gcli::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:gcli.FieldId..Init
inline void          FieldId_Init(gcli::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:gcli.FieldId.String  printfmt:Raw
// func:gcli.FieldId..Print
void                 FieldId_Print(gcli::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- gcli.TableId
struct TableId { // gcli.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    // func:gcli.TableId.value.Cast
    inline               operator gcli_TableIdEnum() const __attribute__((nothrow));
    // func:gcli.TableId..Ctor
    inline               TableId() __attribute__((nothrow));
    // func:gcli.TableId..FieldwiseCtor
    explicit inline               TableId(i32 in_value) __attribute__((nothrow));
    // func:gcli.TableId..EnumCtor
    inline               TableId(gcli_TableIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:gcli.TableId.value.GetEnum
inline gcli_TableIdEnum value_GetEnum(const gcli::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:gcli.TableId.value.SetEnum
inline void          value_SetEnum(gcli::TableId& parent, gcli_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:gcli.TableId.value.ToCstr
const char*          value_ToCstr(const gcli::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:gcli.TableId.value.Print
void                 value_Print(const gcli::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:gcli.TableId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(gcli::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:gcli.TableId.value.SetStrptr
void                 value_SetStrptr(gcli::TableId& parent, algo::strptr rhs, gcli_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:gcli.TableId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(gcli::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of gcli::TableId from an ascii string.
// The format of the string is the format of the gcli::TableId's only field
// func:gcli.TableId..ReadStrptrMaybe
bool                 TableId_ReadStrptrMaybe(gcli::TableId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:gcli.TableId..Init
inline void          TableId_Init(gcli::TableId& parent);
// print string representation of ROW to string STR
// cfmt:gcli.TableId.String  printfmt:Raw
// func:gcli.TableId..Print
void                 TableId_Print(gcli::TableId& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace gcli { // gen:ns_curstext

struct _db_gtype_curs {// cursor
    typedef gcli::FGtype ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtype_curs(){ parent=NULL; index=0; }
};


struct _db_grepossh_curs {// cursor
    typedef gcli::FGrepossh ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_grepossh_curs(){ parent=NULL; index=0; }
};


struct _db_grepogitport_curs {// cursor
    typedef gcli::FGrepogitport ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_grepogitport_curs(){ parent=NULL; index=0; }
};


struct _db_githost_curs {// cursor
    typedef gcli::FGithost ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_githost_curs(){ parent=NULL; index=0; }
};


struct _db_gstatet_curs {// cursor
    typedef gcli::FGstatet ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gstatet_curs(){ parent=NULL; index=0; }
};


struct _db_gmethod_curs {// cursor
    typedef gcli::FGmethod ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gmethod_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdt_curs {// cursor
    typedef gcli::FGclicmdt ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdt_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdf_curs {// cursor
    typedef gcli::FGclicmdf ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdf_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdf2j_curs {// cursor
    typedef gcli::FGclicmdf2j ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdf2j_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmd_curs {// cursor
    typedef gcli::FGclicmd ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmd_curs(){ parent=NULL; index=0; }
};


struct _db_gtypeh_curs {// cursor
    typedef gcli::FGtypeh ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtypeh_curs(){ parent=NULL; index=0; }
};


struct _db_c_gclicmd_curs {// fcurs:gcli.FDb.c_gclicmd/curs
    typedef gcli::FGclicmd ChildType;
    gcli::FGclicmd** elems;
    u32 n_elems;
    u32 index;
    _db_c_gclicmd_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_gclicmdj2f_curs {// cursor
    typedef gcli::FGclicmdj2f ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdj2f_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdc_curs {// cursor
    typedef gcli::FGclicmdc ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdc_curs(){ parent=NULL; index=0; }
};


struct _db_gclicmdarg_curs {// cursor
    typedef gcli::FGclicmdarg ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gclicmdarg_curs(){ parent=NULL; index=0; }
};


struct _db_issue_curs {// cursor
    typedef gcli::FIssue ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_issue_curs(){ parent=NULL; index=0; }
};


struct _db_grepo_curs {// cursor
    typedef gcli::FGrepo ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_grepo_curs(){ parent=NULL; index=0; }
};


struct _db_tuples_curs {// cursor
    typedef gcli::FTuples ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_tuples_curs(){ parent=NULL; index=0; }
};


struct _db_issuenote_curs {// cursor
    typedef gcli::FIssuenote ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_issuenote_curs(){ parent=NULL; index=0; }
};


struct _db_mrjob_curs {// cursor
    typedef gcli::FMrjob ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_mrjob_curs(){ parent=NULL; index=0; }
};


struct _db_mrnote_curs {// cursor
    typedef gcli::FMrnote ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_mrnote_curs(){ parent=NULL; index=0; }
};


struct _db_user_curs {// cursor
    typedef gcli::FUser ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_user_curs(){ parent=NULL; index=0; }
};


struct _db_milestone_curs {// cursor
    typedef gcli::FMilestone ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_milestone_curs(){ parent=NULL; index=0; }
};


struct _db_mr_curs {// cursor
    typedef gcli::FMr ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_mr_curs(){ parent=NULL; index=0; }
};


struct _db_gtypeprefix_curs {// cursor
    typedef gcli::FGtypeprefix ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtypeprefix_curs(){ parent=NULL; index=0; }
};


struct _db_gtblact_curs {// cursor
    typedef gcli::FGtblact ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtblact_curs(){ parent=NULL; index=0; }
};


struct _db_gtblactfld_curs {// cursor
    typedef gcli::FGtblactfld ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtblactfld_curs(){ parent=NULL; index=0; }
};


struct _db_zd_gtblact_curs {// fcurs:gcli.FDb.zd_gtblact/curs
    typedef gcli::FGtblact ChildType;
    gcli::FGtblact* row;
    _db_zd_gtblact_curs() {
        row = NULL;
    }
};


struct _db_gfld_curs {// cursor
    typedef gcli::FGfld ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gfld_curs(){ parent=NULL; index=0; }
};


struct _db_c_gfld_curs {// fcurs:gcli.FDb.c_gfld/curs
    typedef gcli::FGfld ChildType;
    gcli::FGfld** elems;
    u32 n_elems;
    u32 index;
    _db_c_gfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_gtbl_curs {// cursor
    typedef gcli::FGtbl ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gtbl_curs(){ parent=NULL; index=0; }
};


struct _db_gact_curs {// cursor
    typedef gcli::FGact ChildType;
    gcli::FDb *parent;
    i64 index;
    _db_gact_curs(){ parent=NULL; index=0; }
};


struct gclicmd_c_tuples_curs {// fcurs:gcli.FGclicmd.c_tuples/curs
    typedef gcli::FTuples ChildType;
    gcli::FTuples** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_tuples_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmd_c_gclicmdarg_curs {// fcurs:gcli.FGclicmd.c_gclicmdarg/curs
    typedef gcli::FGclicmdarg ChildType;
    gcli::FGclicmdarg** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_gclicmdarg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmd_c_gclicmdc_curs {// fcurs:gcli.FGclicmd.c_gclicmdc/curs
    typedef gcli::FGclicmdc ChildType;
    gcli::FGclicmdc** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_gclicmdc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmd_c_gclicmdf2j_curs {// fcurs:gcli.FGclicmd.c_gclicmdf2j/curs
    typedef gcli::FGclicmdf2j ChildType;
    gcli::FGclicmdf2j** elems;
    u32 n_elems;
    u32 index;
    gclicmd_c_gclicmdf2j_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmdc_c_gclicmdf_curs {// fcurs:gcli.FGclicmdc.c_gclicmdf/curs
    typedef gcli::FGclicmdf ChildType;
    gcli::FGclicmdf** elems;
    u32 n_elems;
    u32 index;
    gclicmdc_c_gclicmdf_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gclicmdj2f_c_gclicmdf_curs {// fcurs:gcli.FGclicmdj2f.c_gclicmdf/curs
    typedef gcli::FGclicmdf ChildType;
    gcli::FGclicmdf** elems;
    u32 n_elems;
    u32 index;
    gclicmdj2f_c_gclicmdf_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gfld_c_gtblactfld_curs {// fcurs:gcli.FGfld.c_gtblactfld/curs
    typedef gcli::FGtblactfld ChildType;
    gcli::FGtblactfld** elems;
    u32 n_elems;
    u32 index;
    gfld_c_gtblactfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtbl_c_gtblact_curs {// fcurs:gcli.FGtbl.c_gtblact/curs
    typedef gcli::FGtblact ChildType;
    gcli::FGtblact** elems;
    u32 n_elems;
    u32 index;
    gtbl_c_gtblact_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtblact_c_gtblactfld_curs {// fcurs:gcli.FGtblact.c_gtblactfld/curs
    typedef gcli::FGtblactfld ChildType;
    gcli::FGtblactfld** elems;
    u32 n_elems;
    u32 index;
    gtblact_c_gtblactfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtype_c_gtypeh_curs {// fcurs:gcli.FGtype.c_gtypeh/curs
    typedef gcli::FGtypeh ChildType;
    gcli::FGtypeh** elems;
    u32 n_elems;
    u32 index;
    gtype_c_gtypeh_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gtype_c_gtypeprefix_curs {// fcurs:gcli.FGtype.c_gtypeprefix/curs
    typedef gcli::FGtypeprefix ChildType;
    gcli::FGtypeprefix** elems;
    u32 n_elems;
    u32 index;
    gtype_c_gtypeprefix_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FHttp_response_header_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    FHttp_response_header_curs() { elems=NULL; n_elems=0; index=0; }
};


struct issue_c_mrjob_curs {// fcurs:gcli.FIssue.c_mrjob/curs
    typedef gcli::FMrjob ChildType;
    gcli::FMrjob** elems;
    u32 n_elems;
    u32 index;
    issue_c_mrjob_curs() { elems=NULL; n_elems=0; index=0; }
};


struct issue_c_issuenote_curs {// fcurs:gcli.FIssue.c_issuenote/curs
    typedef gcli::FIssuenote ChildType;
    gcli::FIssuenote** elems;
    u32 n_elems;
    u32 index;
    issue_c_issuenote_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mr_c_mrnote_curs {// fcurs:gcli.FMr.c_mrnote/curs
    typedef gcli::FMrnote ChildType;
    gcli::FMrnote** elems;
    u32 n_elems;
    u32 index;
    mr_c_mrnote_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mr_c_mrjob_curs {// fcurs:gcli.FMr.c_mrjob/curs
    typedef gcli::FMrjob ChildType;
    gcli::FMrjob** elems;
    u32 n_elems;
    u32 index;
    mr_c_mrjob_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace gcli { // gen:ns_func
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_graphql
// this function is 'extrn' and implemented by user
void                 gclicmd_graphql(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_issueadd
// this function is 'extrn' and implemented by user
void                 gclicmd_issueadd(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_issuelist
// this function is 'extrn' and implemented by user
void                 gclicmd_issuelist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_issuemod
// this function is 'extrn' and implemented by user
void                 gclicmd_issuemod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_issuenote
// this function is 'extrn' and implemented by user
void                 gclicmd_issuenote(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_issuesearch
// this function is 'extrn' and implemented by user
void                 gclicmd_issuesearch(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mraccept
// this function is 'extrn' and implemented by user
void                 gclicmd_mraccept(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrlist
// this function is 'extrn' and implemented by user
void                 gclicmd_mrlist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrlistdet
// this function is 'extrn' and implemented by user
void                 gclicmd_mrlistdet(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrmod
// this function is 'extrn' and implemented by user
void                 gclicmd_mrmod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrnote
// this function is 'extrn' and implemented by user
void                 gclicmd_mrnote(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrnoteadd
// this function is 'extrn' and implemented by user
void                 gclicmd_mrnoteadd(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrnotemod
// this function is 'extrn' and implemented by user
void                 gclicmd_mrnotemod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrreq
// this function is 'extrn' and implemented by user
void                 gclicmd_mrreq(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrreview
// this function is 'extrn' and implemented by user
void                 gclicmd_mrreview(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrreviewrm
// this function is 'extrn' and implemented by user
void                 gclicmd_mrreviewrm(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mrsearch
// this function is 'extrn' and implemented by user
void                 gclicmd_mrsearch(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_mslist
// this function is 'extrn' and implemented by user
void                 gclicmd_mslist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_noteadd
// this function is 'extrn' and implemented by user
void                 gclicmd_noteadd(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_notemod
// this function is 'extrn' and implemented by user
void                 gclicmd_notemod(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_repojob
// this function is 'extrn' and implemented by user
void                 gclicmd_repojob(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_repojobtrace
// this function is 'extrn' and implemented by user
void                 gclicmd_repojobtrace(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_token2repos
// this function is 'extrn' and implemented by user
void                 gclicmd_token2repos(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_user
// this function is 'extrn' and implemented by user
void                 gclicmd_user(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_userdet
// this function is 'extrn' and implemented by user
void                 gclicmd_userdet(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gclicmd
// func:gcli...gclicmd_userlist
// this function is 'extrn' and implemented by user
void                 gclicmd_userlist(gcli::FGclicmd&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_help_list
// this function is 'extrn' and implemented by user
void                 gtblact_help_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_repo_create
// this function is 'extrn' and implemented by user
void                 gtblact_repo_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_gitconfig_create
// this function is 'extrn' and implemented by user
void                 gtblact_gitconfig_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_gitconfig_list
// this function is 'extrn' and implemented by user
void                 gtblact_gitconfig_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_repo_update
// this function is 'extrn' and implemented by user
void                 gtblact_repo_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_reporemote_list
// this function is 'extrn' and implemented by user
void                 gtblact_reporemote_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_repo_list
// this function is 'extrn' and implemented by user
void                 gtblact_repo_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issue_create
// this function is 'extrn' and implemented by user
void                 gtblact_issue_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issue_update
// this function is 'extrn' and implemented by user
void                 gtblact_issue_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issue_start
// this function is 'extrn' and implemented by user
void                 gtblact_issue_start(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issue_list
// this function is 'extrn' and implemented by user
void                 gtblact_issue_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mrnote_create
// this function is 'extrn' and implemented by user
void                 gtblact_mrnote_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issuenote_create
// this function is 'extrn' and implemented by user
void                 gtblact_issuenote_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issuenote_list
// this function is 'extrn' and implemented by user
void                 gtblact_issuenote_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issuenote_update
// this function is 'extrn' and implemented by user
void                 gtblact_issuenote_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mrnote_update
// this function is 'extrn' and implemented by user
void                 gtblact_mrnote_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mrnote_list
// this function is 'extrn' and implemented by user
void                 gtblact_mrnote_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_list
// this function is 'extrn' and implemented by user
void                 gtblact_mr_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_milestone_list
// this function is 'extrn' and implemented by user
void                 gtblact_milestone_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_user_list
// this function is 'extrn' and implemented by user
void                 gtblact_user_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_create
// this function is 'extrn' and implemented by user
void                 gtblact_mr_create(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_start
// this function is 'extrn' and implemented by user
void                 gtblact_mr_start(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_approve
// this function is 'extrn' and implemented by user
void                 gtblact_mr_approve(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_accept
// this function is 'extrn' and implemented by user
void                 gtblact_mr_accept(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_update
// this function is 'extrn' and implemented by user
void                 gtblact_mr_update(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_needs_work
// this function is 'extrn' and implemented by user
void                 gtblact_mr_needs_work(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mr_stop
// this function is 'extrn' and implemented by user
void                 gtblact_mr_stop(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_mrjob_list
// this function is 'extrn' and implemented by user
void                 gtblact_mrjob_list(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issue_needs_work
// this function is 'extrn' and implemented by user
void                 gtblact_issue_needs_work(gcli::FGtblact&);
// User-implemented function from gstatic:gcli.FDb.gtblact
// func:gcli...gtblact_issue_stop
// this function is 'extrn' and implemented by user
void                 gtblact_issue_stop(gcli::FGtblact&);
// func:gcli...StaticCheck
void                 StaticCheck();
} // gen:ns_func
// func:gcli...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:gcli...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const gcli::trace &row);// cfmt:gcli.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FHttp &row);// cfmt:gcli.FHttp.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FMilestone &row);// cfmt:gcli.FMilestone.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FMr &row);// cfmt:gcli.FMr.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::FieldId &row);// cfmt:gcli.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const gcli::TableId &row);// cfmt:gcli.TableId.String
}
