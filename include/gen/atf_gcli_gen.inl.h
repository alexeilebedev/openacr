//
// include/gen/atf_gcli_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/gclidb_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
inline atf_gcli::trace::trace() {
}


// --- atf_gcli.FDb.gtblacttst.EmptyQ
// Return true if index is empty
inline bool atf_gcli::gtblacttst_EmptyQ() {
    return _db.gtblacttst_n == 0;
}

// --- atf_gcli.FDb.gtblacttst.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGtblacttst* atf_gcli::gtblacttst_Find(u64 t) {
    atf_gcli::FGtblacttst *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gtblacttst_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gtblacttst_lary[bsr][index];
    }
    return retval;
}

// --- atf_gcli.FDb.gtblacttst.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_gcli::FGtblacttst* atf_gcli::gtblacttst_Last() {
    return gtblacttst_Find(u64(_db.gtblacttst_n-1));
}

// --- atf_gcli.FDb.gtblacttst.N
// Return number of items in the pool
inline i32 atf_gcli::gtblacttst_N() {
    return _db.gtblacttst_n;
}

// --- atf_gcli.FDb.gtblacttst.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_gcli::FGtblacttst& atf_gcli::gtblacttst_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gtblacttst_lary[bsr][index];
}

// --- atf_gcli.FDb.gtblacttstout.EmptyQ
// Return true if index is empty
inline bool atf_gcli::gtblacttstout_EmptyQ() {
    return _db.gtblacttstout_n == 0;
}

// --- atf_gcli.FDb.gtblacttstout.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGtblacttstout* atf_gcli::gtblacttstout_Find(u64 t) {
    atf_gcli::FGtblacttstout *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gtblacttstout_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gtblacttstout_lary[bsr][index];
    }
    return retval;
}

// --- atf_gcli.FDb.gtblacttstout.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_gcli::FGtblacttstout* atf_gcli::gtblacttstout_Last() {
    return gtblacttstout_Find(u64(_db.gtblacttstout_n-1));
}

// --- atf_gcli.FDb.gtblacttstout.N
// Return number of items in the pool
inline i32 atf_gcli::gtblacttstout_N() {
    return _db.gtblacttstout_n;
}

// --- atf_gcli.FDb.gtblacttstout.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_gcli::FGtblacttstout& atf_gcli::gtblacttstout_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gtblacttstout_lary[bsr][index];
}

// --- atf_gcli.FDb.ind_gtblacttst.EmptyQ
// Return true if hash is empty
inline bool atf_gcli::ind_gtblacttst_EmptyQ() {
    return _db.ind_gtblacttst_n == 0;
}

// --- atf_gcli.FDb.ind_gtblacttst.N
// Return number of items in the hash
inline i32 atf_gcli::ind_gtblacttst_N() {
    return _db.ind_gtblacttst_n;
}

// --- atf_gcli.FDb.ind_gtblacttstout.EmptyQ
// Return true if hash is empty
inline bool atf_gcli::ind_gtblacttstout_EmptyQ() {
    return _db.ind_gtblacttstout_n == 0;
}

// --- atf_gcli.FDb.ind_gtblacttstout.N
// Return number of items in the hash
inline i32 atf_gcli::ind_gtblacttstout_N() {
    return _db.ind_gtblacttstout_n;
}

// --- atf_gcli.FDb.c_gtblacttst.EmptyQ
// Return true if index is empty
inline bool atf_gcli::c_gtblacttst_EmptyQ() {
    return _db.c_gtblacttst_n == 0;
}

// --- atf_gcli.FDb.c_gtblacttst.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGtblacttst* atf_gcli::c_gtblacttst_Find(u32 t) {
    atf_gcli::FGtblacttst *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_gtblacttst_n;
    if (idx < lim) {
        retval = _db.c_gtblacttst_elems[idx];
    }
    return retval;
}

// --- atf_gcli.FDb.c_gtblacttst.Getary
// Return array of pointers
inline algo::aryptr<atf_gcli::FGtblacttst*> atf_gcli::c_gtblacttst_Getary() {
    return algo::aryptr<atf_gcli::FGtblacttst*>(_db.c_gtblacttst_elems, _db.c_gtblacttst_n);
}

// --- atf_gcli.FDb.c_gtblacttst.N
// Return number of items in the pointer array
inline i32 atf_gcli::c_gtblacttst_N() {
    return _db.c_gtblacttst_n;
}

// --- atf_gcli.FDb.c_gtblacttst.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_gcli::c_gtblacttst_RemoveAll() {
    for (u32 i = 0; i < _db.c_gtblacttst_n; i++) {
        // mark all elements as not-in-array
        _db.c_gtblacttst_elems[i]->_db_c_gtblacttst_in_ary = false;
    }
    _db.c_gtblacttst_n = 0;
}

// --- atf_gcli.FDb.c_gtblacttst.qFind
// Return reference without bounds checking
inline atf_gcli::FGtblacttst& atf_gcli::c_gtblacttst_qFind(u32 idx) {
    return *_db.c_gtblacttst_elems[idx];
}

// --- atf_gcli.FDb.c_gtblacttst.InAryQ
// True if row is in any ptrary instance
inline bool atf_gcli::c_gtblacttst_InAryQ(atf_gcli::FGtblacttst& row) {
    return row._db_c_gtblacttst_in_ary;
}

// --- atf_gcli.FDb.c_gtblacttst.qLast
// Reference to last element without bounds checking
inline atf_gcli::FGtblacttst& atf_gcli::c_gtblacttst_qLast() {
    return *_db.c_gtblacttst_elems[_db.c_gtblacttst_n-1];
}

// --- atf_gcli.FDb.gclienvsub.EmptyQ
// Return true if index is empty
inline bool atf_gcli::gclienvsub_EmptyQ() {
    return _db.gclienvsub_n == 0;
}

// --- atf_gcli.FDb.gclienvsub.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGclienvsub* atf_gcli::gclienvsub_Find(u64 t) {
    atf_gcli::FGclienvsub *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gclienvsub_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gclienvsub_lary[bsr][index];
    }
    return retval;
}

// --- atf_gcli.FDb.gclienvsub.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_gcli::FGclienvsub* atf_gcli::gclienvsub_Last() {
    return gclienvsub_Find(u64(_db.gclienvsub_n-1));
}

// --- atf_gcli.FDb.gclienvsub.N
// Return number of items in the pool
inline i32 atf_gcli::gclienvsub_N() {
    return _db.gclienvsub_n;
}

// --- atf_gcli.FDb.gclienvsub.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_gcli::FGclienvsub& atf_gcli::gclienvsub_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gclienvsub_lary[bsr][index];
}

// --- atf_gcli.FDb.gclienv.EmptyQ
// Return true if index is empty
inline bool atf_gcli::gclienv_EmptyQ() {
    return _db.gclienv_n == 0;
}

// --- atf_gcli.FDb.gclienv.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGclienv* atf_gcli::gclienv_Find(u64 t) {
    atf_gcli::FGclienv *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gclienv_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gclienv_lary[bsr][index];
    }
    return retval;
}

// --- atf_gcli.FDb.gclienv.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_gcli::FGclienv* atf_gcli::gclienv_Last() {
    return gclienv_Find(u64(_db.gclienv_n-1));
}

// --- atf_gcli.FDb.gclienv.N
// Return number of items in the pool
inline i32 atf_gcli::gclienv_N() {
    return _db.gclienv_n;
}

// --- atf_gcli.FDb.gclienv.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_gcli::FGclienv& atf_gcli::gclienv_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gclienv_lary[bsr][index];
}

// --- atf_gcli.FDb.ind_gclienv.EmptyQ
// Return true if hash is empty
inline bool atf_gcli::ind_gclienv_EmptyQ() {
    return _db.ind_gclienv_n == 0;
}

// --- atf_gcli.FDb.ind_gclienv.N
// Return number of items in the hash
inline i32 atf_gcli::ind_gclienv_N() {
    return _db.ind_gclienv_n;
}

// --- atf_gcli.FDb.ind_gclienvsub.EmptyQ
// Return true if hash is empty
inline bool atf_gcli::ind_gclienvsub_EmptyQ() {
    return _db.ind_gclienvsub_n == 0;
}

// --- atf_gcli.FDb.ind_gclienvsub.N
// Return number of items in the hash
inline i32 atf_gcli::ind_gclienvsub_N() {
    return _db.ind_gclienvsub_n;
}

// --- atf_gcli.FDb.gtblact.EmptyQ
// Return true if index is empty
inline bool atf_gcli::gtblact_EmptyQ() {
    return _db.gtblact_n == 0;
}

// --- atf_gcli.FDb.gtblact.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGtblact* atf_gcli::gtblact_Find(u64 t) {
    atf_gcli::FGtblact *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.gtblact_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.gtblact_lary[bsr][index];
    }
    return retval;
}

// --- atf_gcli.FDb.gtblact.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_gcli::FGtblact* atf_gcli::gtblact_Last() {
    return gtblact_Find(u64(_db.gtblact_n-1));
}

// --- atf_gcli.FDb.gtblact.N
// Return number of items in the pool
inline i32 atf_gcli::gtblact_N() {
    return _db.gtblact_n;
}

// --- atf_gcli.FDb.gtblact.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_gcli::FGtblact& atf_gcli::gtblact_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.gtblact_lary[bsr][index];
}

// --- atf_gcli.FDb.ind_gtblact.EmptyQ
// Return true if hash is empty
inline bool atf_gcli::ind_gtblact_EmptyQ() {
    return _db.ind_gtblact_n == 0;
}

// --- atf_gcli.FDb.ind_gtblact.N
// Return number of items in the hash
inline i32 atf_gcli::ind_gtblact_N() {
    return _db.ind_gtblact_n;
}

// --- atf_gcli.FDb.gtblacttst_curs.Reset
// cursor points to valid item
inline void atf_gcli::_db_gtblacttst_curs_Reset(_db_gtblacttst_curs &curs, atf_gcli::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_gcli.FDb.gtblacttst_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::_db_gtblacttst_curs_ValidQ(_db_gtblacttst_curs &curs) {
    return curs.index < _db.gtblacttst_n;
}

// --- atf_gcli.FDb.gtblacttst_curs.Next
// proceed to next item
inline void atf_gcli::_db_gtblacttst_curs_Next(_db_gtblacttst_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FDb.gtblacttst_curs.Access
// item access
inline atf_gcli::FGtblacttst& atf_gcli::_db_gtblacttst_curs_Access(_db_gtblacttst_curs &curs) {
    return gtblacttst_qFind(u64(curs.index));
}

// --- atf_gcli.FDb.gtblacttstout_curs.Reset
// cursor points to valid item
inline void atf_gcli::_db_gtblacttstout_curs_Reset(_db_gtblacttstout_curs &curs, atf_gcli::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_gcli.FDb.gtblacttstout_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::_db_gtblacttstout_curs_ValidQ(_db_gtblacttstout_curs &curs) {
    return curs.index < _db.gtblacttstout_n;
}

// --- atf_gcli.FDb.gtblacttstout_curs.Next
// proceed to next item
inline void atf_gcli::_db_gtblacttstout_curs_Next(_db_gtblacttstout_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FDb.gtblacttstout_curs.Access
// item access
inline atf_gcli::FGtblacttstout& atf_gcli::_db_gtblacttstout_curs_Access(_db_gtblacttstout_curs &curs) {
    return gtblacttstout_qFind(u64(curs.index));
}

// --- atf_gcli.FDb.c_gtblacttst_curs.Reset
inline void atf_gcli::_db_c_gtblacttst_curs_Reset(_db_c_gtblacttst_curs &curs, atf_gcli::FDb &parent) {
    curs.elems = parent.c_gtblacttst_elems;
    curs.n_elems = parent.c_gtblacttst_n;
    curs.index = 0;
}

// --- atf_gcli.FDb.c_gtblacttst_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::_db_c_gtblacttst_curs_ValidQ(_db_c_gtblacttst_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_gcli.FDb.c_gtblacttst_curs.Next
// proceed to next item
inline void atf_gcli::_db_c_gtblacttst_curs_Next(_db_c_gtblacttst_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FDb.c_gtblacttst_curs.Access
// item access
inline atf_gcli::FGtblacttst& atf_gcli::_db_c_gtblacttst_curs_Access(_db_c_gtblacttst_curs &curs) {
    return *curs.elems[curs.index];
}

// --- atf_gcli.FDb.gclienvsub_curs.Reset
// cursor points to valid item
inline void atf_gcli::_db_gclienvsub_curs_Reset(_db_gclienvsub_curs &curs, atf_gcli::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_gcli.FDb.gclienvsub_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::_db_gclienvsub_curs_ValidQ(_db_gclienvsub_curs &curs) {
    return curs.index < _db.gclienvsub_n;
}

// --- atf_gcli.FDb.gclienvsub_curs.Next
// proceed to next item
inline void atf_gcli::_db_gclienvsub_curs_Next(_db_gclienvsub_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FDb.gclienvsub_curs.Access
// item access
inline atf_gcli::FGclienvsub& atf_gcli::_db_gclienvsub_curs_Access(_db_gclienvsub_curs &curs) {
    return gclienvsub_qFind(u64(curs.index));
}

// --- atf_gcli.FDb.gclienv_curs.Reset
// cursor points to valid item
inline void atf_gcli::_db_gclienv_curs_Reset(_db_gclienv_curs &curs, atf_gcli::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_gcli.FDb.gclienv_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::_db_gclienv_curs_ValidQ(_db_gclienv_curs &curs) {
    return curs.index < _db.gclienv_n;
}

// --- atf_gcli.FDb.gclienv_curs.Next
// proceed to next item
inline void atf_gcli::_db_gclienv_curs_Next(_db_gclienv_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FDb.gclienv_curs.Access
// item access
inline atf_gcli::FGclienv& atf_gcli::_db_gclienv_curs_Access(_db_gclienv_curs &curs) {
    return gclienv_qFind(u64(curs.index));
}

// --- atf_gcli.FDb.gtblact_curs.Reset
// cursor points to valid item
inline void atf_gcli::_db_gtblact_curs_Reset(_db_gtblact_curs &curs, atf_gcli::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_gcli.FDb.gtblact_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::_db_gtblact_curs_ValidQ(_db_gtblact_curs &curs) {
    return curs.index < _db.gtblact_n;
}

// --- atf_gcli.FDb.gtblact_curs.Next
// proceed to next item
inline void atf_gcli::_db_gtblact_curs_Next(_db_gtblact_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FDb.gtblact_curs.Access
// item access
inline atf_gcli::FGtblact& atf_gcli::_db_gtblact_curs_Access(_db_gtblact_curs &curs) {
    return gtblact_qFind(u64(curs.index));
}
inline atf_gcli::FGclienv::FGclienv() {
    atf_gcli::FGclienv_Init(*this);
}

inline atf_gcli::FGclienv::~FGclienv() {
    atf_gcli::FGclienv_Uninit(*this);
}


// --- atf_gcli.FGclienv.c_gclienvsub.EmptyQ
// Return true if index is empty
inline bool atf_gcli::c_gclienvsub_EmptyQ(atf_gcli::FGclienv& gclienv) {
    return gclienv.c_gclienvsub_n == 0;
}

// --- atf_gcli.FGclienv.c_gclienvsub.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGclienvsub* atf_gcli::c_gclienvsub_Find(atf_gcli::FGclienv& gclienv, u32 t) {
    atf_gcli::FGclienvsub *retval = NULL;
    u64 idx = t;
    u64 lim = gclienv.c_gclienvsub_n;
    if (idx < lim) {
        retval = gclienv.c_gclienvsub_elems[idx];
    }
    return retval;
}

// --- atf_gcli.FGclienv.c_gclienvsub.Getary
// Return array of pointers
inline algo::aryptr<atf_gcli::FGclienvsub*> atf_gcli::c_gclienvsub_Getary(atf_gcli::FGclienv& gclienv) {
    return algo::aryptr<atf_gcli::FGclienvsub*>(gclienv.c_gclienvsub_elems, gclienv.c_gclienvsub_n);
}

// --- atf_gcli.FGclienv.c_gclienvsub.N
// Return number of items in the pointer array
inline i32 atf_gcli::c_gclienvsub_N(const atf_gcli::FGclienv& gclienv) {
    return gclienv.c_gclienvsub_n;
}

// --- atf_gcli.FGclienv.c_gclienvsub.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_gcli::c_gclienvsub_RemoveAll(atf_gcli::FGclienv& gclienv) {
    for (u32 i = 0; i < gclienv.c_gclienvsub_n; i++) {
        // mark all elements as not-in-array
        gclienv.c_gclienvsub_elems[i]->gclienv_c_gclienvsub_in_ary = false;
    }
    gclienv.c_gclienvsub_n = 0;
}

// --- atf_gcli.FGclienv.c_gclienvsub.qFind
// Return reference without bounds checking
inline atf_gcli::FGclienvsub& atf_gcli::c_gclienvsub_qFind(atf_gcli::FGclienv& gclienv, u32 idx) {
    return *gclienv.c_gclienvsub_elems[idx];
}

// --- atf_gcli.FGclienv.c_gclienvsub.InAryQ
// True if row is in any ptrary instance
inline bool atf_gcli::gclienv_c_gclienvsub_InAryQ(atf_gcli::FGclienvsub& row) {
    return row.gclienv_c_gclienvsub_in_ary;
}

// --- atf_gcli.FGclienv.c_gclienvsub.qLast
// Reference to last element without bounds checking
inline atf_gcli::FGclienvsub& atf_gcli::c_gclienvsub_qLast(atf_gcli::FGclienv& gclienv) {
    return *gclienv.c_gclienvsub_elems[gclienv.c_gclienvsub_n-1];
}

// --- atf_gcli.FGclienv..Init
// Set all fields to initial values.
inline void atf_gcli::FGclienv_Init(atf_gcli::FGclienv& gclienv) {
    gclienv.c_gclienvsub_elems = NULL; // (atf_gcli.FGclienv.c_gclienvsub)
    gclienv.c_gclienvsub_n = 0; // (atf_gcli.FGclienv.c_gclienvsub)
    gclienv.c_gclienvsub_max = 0; // (atf_gcli.FGclienv.c_gclienvsub)
    gclienv.ind_gclienv_next = (atf_gcli::FGclienv*)-1; // (atf_gcli.FDb.ind_gclienv) not-in-hash
}

// --- atf_gcli.FGclienv.c_gclienvsub_curs.Reset
inline void atf_gcli::gclienv_c_gclienvsub_curs_Reset(gclienv_c_gclienvsub_curs &curs, atf_gcli::FGclienv &parent) {
    curs.elems = parent.c_gclienvsub_elems;
    curs.n_elems = parent.c_gclienvsub_n;
    curs.index = 0;
}

// --- atf_gcli.FGclienv.c_gclienvsub_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::gclienv_c_gclienvsub_curs_ValidQ(gclienv_c_gclienvsub_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_gcli.FGclienv.c_gclienvsub_curs.Next
// proceed to next item
inline void atf_gcli::gclienv_c_gclienvsub_curs_Next(gclienv_c_gclienvsub_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FGclienv.c_gclienvsub_curs.Access
// item access
inline atf_gcli::FGclienvsub& atf_gcli::gclienv_c_gclienvsub_curs_Access(gclienv_c_gclienvsub_curs &curs) {
    return *curs.elems[curs.index];
}
inline atf_gcli::FGclienvsub::FGclienvsub() {
    atf_gcli::FGclienvsub_Init(*this);
}

inline atf_gcli::FGclienvsub::~FGclienvsub() {
    atf_gcli::FGclienvsub_Uninit(*this);
}


// --- atf_gcli.FGclienvsub..Init
// Set all fields to initial values.
inline void atf_gcli::FGclienvsub_Init(atf_gcli::FGclienvsub& gclienvsub) {
    gclienvsub.fwd = bool(false);
    gclienvsub.rev = bool(false);
    gclienvsub.gclienv_c_gclienvsub_in_ary = bool(false);
    gclienvsub.ind_gclienvsub_next = (atf_gcli::FGclienvsub*)-1; // (atf_gcli.FDb.ind_gclienvsub) not-in-hash
}
inline atf_gcli::FGtblact::FGtblact() {
    atf_gcli::FGtblact_Init(*this);
}

inline atf_gcli::FGtblact::~FGtblact() {
    atf_gcli::FGtblact_Uninit(*this);
}

inline atf_gcli::FGtblacttst::FGtblacttst() {
    atf_gcli::FGtblacttst_Init(*this);
}

inline atf_gcli::FGtblacttst::~FGtblacttst() {
    atf_gcli::FGtblacttst_Uninit(*this);
}


// --- atf_gcli.FGtblacttst.c_gtblacttstout.EmptyQ
// Return true if index is empty
inline bool atf_gcli::c_gtblacttstout_EmptyQ(atf_gcli::FGtblacttst& gtblacttst) {
    return gtblacttst.c_gtblacttstout_n == 0;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.Find
// Look up row by row id. Return NULL if out of range
inline atf_gcli::FGtblacttstout* atf_gcli::c_gtblacttstout_Find(atf_gcli::FGtblacttst& gtblacttst, u32 t) {
    atf_gcli::FGtblacttstout *retval = NULL;
    u64 idx = t;
    u64 lim = gtblacttst.c_gtblacttstout_n;
    if (idx < lim) {
        retval = gtblacttst.c_gtblacttstout_elems[idx];
    }
    return retval;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.Getary
// Return array of pointers
inline algo::aryptr<atf_gcli::FGtblacttstout*> atf_gcli::c_gtblacttstout_Getary(atf_gcli::FGtblacttst& gtblacttst) {
    return algo::aryptr<atf_gcli::FGtblacttstout*>(gtblacttst.c_gtblacttstout_elems, gtblacttst.c_gtblacttstout_n);
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.N
// Return number of items in the pointer array
inline i32 atf_gcli::c_gtblacttstout_N(const atf_gcli::FGtblacttst& gtblacttst) {
    return gtblacttst.c_gtblacttstout_n;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_gcli::c_gtblacttstout_RemoveAll(atf_gcli::FGtblacttst& gtblacttst) {
    for (u32 i = 0; i < gtblacttst.c_gtblacttstout_n; i++) {
        // mark all elements as not-in-array
        gtblacttst.c_gtblacttstout_elems[i]->gtblacttst_c_gtblacttstout_in_ary = false;
    }
    gtblacttst.c_gtblacttstout_n = 0;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.qFind
// Return reference without bounds checking
inline atf_gcli::FGtblacttstout& atf_gcli::c_gtblacttstout_qFind(atf_gcli::FGtblacttst& gtblacttst, u32 idx) {
    return *gtblacttst.c_gtblacttstout_elems[idx];
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.InAryQ
// True if row is in any ptrary instance
inline bool atf_gcli::gtblacttst_c_gtblacttstout_InAryQ(atf_gcli::FGtblacttstout& row) {
    return row.gtblacttst_c_gtblacttstout_in_ary;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout.qLast
// Reference to last element without bounds checking
inline atf_gcli::FGtblacttstout& atf_gcli::c_gtblacttstout_qLast(atf_gcli::FGtblacttst& gtblacttst) {
    return *gtblacttst.c_gtblacttstout_elems[gtblacttst.c_gtblacttstout_n-1];
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout_curs.Reset
inline void atf_gcli::gtblacttst_c_gtblacttstout_curs_Reset(gtblacttst_c_gtblacttstout_curs &curs, atf_gcli::FGtblacttst &parent) {
    curs.elems = parent.c_gtblacttstout_elems;
    curs.n_elems = parent.c_gtblacttstout_n;
    curs.index = 0;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout_curs.ValidQ
// cursor points to valid item
inline bool atf_gcli::gtblacttst_c_gtblacttstout_curs_ValidQ(gtblacttst_c_gtblacttstout_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout_curs.Next
// proceed to next item
inline void atf_gcli::gtblacttst_c_gtblacttstout_curs_Next(gtblacttst_c_gtblacttstout_curs &curs) {
    curs.index++;
}

// --- atf_gcli.FGtblacttst.c_gtblacttstout_curs.Access
// item access
inline atf_gcli::FGtblacttstout& atf_gcli::gtblacttst_c_gtblacttstout_curs_Access(gtblacttst_c_gtblacttstout_curs &curs) {
    return *curs.elems[curs.index];
}
inline atf_gcli::FGtblacttstout::FGtblacttstout() {
    atf_gcli::FGtblacttstout_Init(*this);
}

inline atf_gcli::FGtblacttstout::~FGtblacttstout() {
    atf_gcli::FGtblacttstout_Uninit(*this);
}


// --- atf_gcli.FGtblacttstout..Init
// Set all fields to initial values.
inline void atf_gcli::FGtblacttstout_Init(atf_gcli::FGtblacttstout& gtblacttstout) {
    gtblacttstout.gtblacttst_c_gtblacttstout_in_ary = bool(false);
    gtblacttstout.ind_gtblacttstout_next = (atf_gcli::FGtblacttstout*)-1; // (atf_gcli.FDb.ind_gtblacttstout) not-in-hash
}
inline atf_gcli::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline atf_gcli::FieldId::FieldId(atf_gcli_FieldIdEnum arg) { this->value = i32(arg); }
inline atf_gcli::FieldId::FieldId() {
    atf_gcli::FieldId_Init(*this);
}


// --- atf_gcli.FieldId.value.GetEnum
// Get value of field as enum type
inline atf_gcli_FieldIdEnum atf_gcli::value_GetEnum(const atf_gcli::FieldId& parent) {
    return atf_gcli_FieldIdEnum(parent.value);
}

// --- atf_gcli.FieldId.value.SetEnum
// Set value of field from enum type.
inline void atf_gcli::value_SetEnum(atf_gcli::FieldId& parent, atf_gcli_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- atf_gcli.FieldId.value.Cast
inline atf_gcli::FieldId::operator atf_gcli_FieldIdEnum () const {
    return atf_gcli_FieldIdEnum((*this).value);
}

// --- atf_gcli.FieldId..Init
// Set all fields to initial values.
inline void atf_gcli::FieldId_Init(atf_gcli::FieldId& parent) {
    parent.value = i32(-1);
}
inline atf_gcli::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline atf_gcli::TableId::TableId(atf_gcli_TableIdEnum arg) { this->value = i32(arg); }
inline atf_gcli::TableId::TableId() {
    atf_gcli::TableId_Init(*this);
}


// --- atf_gcli.TableId.value.GetEnum
// Get value of field as enum type
inline atf_gcli_TableIdEnum atf_gcli::value_GetEnum(const atf_gcli::TableId& parent) {
    return atf_gcli_TableIdEnum(parent.value);
}

// --- atf_gcli.TableId.value.SetEnum
// Set value of field from enum type.
inline void atf_gcli::value_SetEnum(atf_gcli::TableId& parent, atf_gcli_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- atf_gcli.TableId.value.Cast
inline atf_gcli::TableId::operator atf_gcli_TableIdEnum () const {
    return atf_gcli_TableIdEnum((*this).value);
}

// --- atf_gcli.TableId..Init
// Set all fields to initial values.
inline void atf_gcli::TableId_Init(atf_gcli::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_gcli::trace &row) {// cfmt:atf_gcli.trace.String
    atf_gcli::trace_Print(const_cast<atf_gcli::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_gcli::FieldId &row) {// cfmt:atf_gcli.FieldId.String
    atf_gcli::FieldId_Print(const_cast<atf_gcli::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_gcli::TableId &row) {// cfmt:atf_gcli.TableId.String
    atf_gcli::TableId_Print(const_cast<atf_gcli::TableId&>(row), str);
    return str;
}
