//
// include/gen/command_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- command_FieldIdEnum

enum command_FieldIdEnum {                             // command.FieldId.value
     command_FieldId_target                     = 0
    ,command_FieldId_in                         = 1
    ,command_FieldId_out_dir                    = 2
    ,command_FieldId_cfg                        = 3
    ,command_FieldId_compiler                   = 4
    ,command_FieldId_uname                      = 5
    ,command_FieldId_arch                       = 6
    ,command_FieldId_ood                        = 7
    ,command_FieldId_list                       = 8
    ,command_FieldId_listincl                   = 9
    ,command_FieldId_build                      = 10
    ,command_FieldId_preproc                    = 11
    ,command_FieldId_clean                      = 12
    ,command_FieldId_dry_run                    = 13
    ,command_FieldId_maxjobs                    = 14
    ,command_FieldId_printcmd                   = 15
    ,command_FieldId_force                      = 16
    ,command_FieldId_install                    = 17
    ,command_FieldId_coverity                   = 18
    ,command_FieldId_package                    = 19
    ,command_FieldId_maxerr                     = 20
    ,command_FieldId_disas                      = 21
    ,command_FieldId_report                     = 22
    ,command_FieldId_jcdb                       = 23
    ,command_FieldId_readme                     = 24
    ,command_FieldId_ns                         = 25
    ,command_FieldId_section                    = 26
    ,command_FieldId_print                      = 27
    ,command_FieldId_query                      = 28
    ,command_FieldId_where                      = 29
    ,command_FieldId_select                     = 30
    ,command_FieldId_del                        = 31
    ,command_FieldId_insert                     = 32
    ,command_FieldId_replace                    = 33
    ,command_FieldId_update                     = 34
    ,command_FieldId_merge                      = 35
    ,command_FieldId_unused                     = 36
    ,command_FieldId_trunc                      = 37
    ,command_FieldId_check                      = 38
    ,command_FieldId_selerr                     = 39
    ,command_FieldId_maxshow                    = 40
    ,command_FieldId_write                      = 41
    ,command_FieldId_rename                     = 42
    ,command_FieldId_nup                        = 43
    ,command_FieldId_ndown                      = 44
    ,command_FieldId_xref                       = 45
    ,command_FieldId_fldfunc                    = 46
    ,command_FieldId_maxgroup                   = 47
    ,command_FieldId_pretty                     = 48
    ,command_FieldId_tree                       = 49
    ,command_FieldId_loose                      = 50
    ,command_FieldId_my                         = 51
    ,command_FieldId_schema                     = 52
    ,command_FieldId_e                          = 53
    ,command_FieldId_t                          = 54
    ,command_FieldId_rowid                      = 55
    ,command_FieldId_cmt                        = 56
    ,command_FieldId_cmd                        = 57
    ,command_FieldId_field                      = 58
    ,command_FieldId_regxof                     = 59
    ,command_FieldId_meta                       = 60
    ,command_FieldId_data                       = 61
    ,command_FieldId_line                       = 62
    ,command_FieldId_point                      = 63
    ,command_FieldId_type                       = 64
    ,command_FieldId_debug_log                  = 65
    ,command_FieldId_arg                        = 66
    ,command_FieldId_write_ours                 = 67
    ,command_FieldId_msize                      = 68
    ,command_FieldId_create                     = 69
    ,command_FieldId_finput                     = 70
    ,command_FieldId_foutput                    = 71
    ,command_FieldId_srcfile                    = 72
    ,command_FieldId_gstatic                    = 73
    ,command_FieldId_indexed                    = 74
    ,command_FieldId_nstype                     = 75
    ,command_FieldId_ctype                      = 76
    ,command_FieldId_pooltype                   = 77
    ,command_FieldId_ssimfile                   = 78
    ,command_FieldId_subset                     = 79
    ,command_FieldId_subset2                    = 80
    ,command_FieldId_separator                  = 81
    ,command_FieldId_dflt                       = 82
    ,command_FieldId_anon                       = 83
    ,command_FieldId_bigend                     = 84
    ,command_FieldId_cascdel                    = 85
    ,command_FieldId_before                     = 86
    ,command_FieldId_substr                     = 87
    ,command_FieldId_alias                      = 88
    ,command_FieldId_srcfield                   = 89
    ,command_FieldId_fstep                      = 90
    ,command_FieldId_inscond                    = 91
    ,command_FieldId_reftype                    = 92
    ,command_FieldId_hashfld                    = 93
    ,command_FieldId_sortfld                    = 94
    ,command_FieldId_unittest                   = 95
    ,command_FieldId_citest                     = 96
    ,command_FieldId_cppfunc                    = 97
    ,command_FieldId_via                        = 98
    ,command_FieldId_comment                    = 99
    ,command_FieldId_sandbox                    = 100
    ,command_FieldId_test                       = 101
    ,command_FieldId_showcpp                    = 102
    ,command_FieldId_msgtype                    = 103
    ,command_FieldId_anonfld                    = 104
    ,command_FieldId_sigcheck                   = 105
    ,command_FieldId_data_dir                   = 106
    ,command_FieldId_related                    = 107
    ,command_FieldId_notssimfile                = 108
    ,command_FieldId_checkable                  = 109
    ,command_FieldId_r                          = 110
    ,command_FieldId_nsdb                       = 111
    ,command_FieldId_fkey                       = 112
    ,command_FieldId_start                      = 113
    ,command_FieldId_stop                       = 114
    ,command_FieldId_abort                      = 115
    ,command_FieldId_shell                      = 116
    ,command_FieldId_serv                       = 117
    ,command_FieldId_in_dir                     = 118
    ,command_FieldId_proto                      = 119
    ,command_FieldId_trace                      = 120
    ,command_FieldId_fconst                     = 121
    ,command_FieldId_gconst                     = 122
    ,command_FieldId_key                        = 123
    ,command_FieldId_include                    = 124
    ,command_FieldId_dot                        = 125
    ,command_FieldId_xns                        = 126
    ,command_FieldId_noinput                    = 127
    ,command_FieldId_render                     = 128
    ,command_FieldId_id                         = 129
    ,command_FieldId_file_prefix                = 130
    ,command_FieldId_nchild                     = 131
    ,command_FieldId_blocking                   = 132
    ,command_FieldId_nmsg                       = 133
    ,command_FieldId_timeout                    = 134
    ,command_FieldId_recvdelay_ns               = 135
    ,command_FieldId_senddelay_ns               = 136
    ,command_FieldId_msgsize_min                = 137
    ,command_FieldId_msgsize_max                = 138
    ,command_FieldId_bufsize                    = 139
    ,command_FieldId_recvdelay                  = 140
    ,command_FieldId_amctest                    = 141
    ,command_FieldId_dofork                     = 142
    ,command_FieldId_q                          = 143
    ,command_FieldId_cijob                      = 144
    ,command_FieldId_capture                    = 145
    ,command_FieldId_exec                       = 146
    ,command_FieldId_astr                       = 147
    ,command_FieldId_anum                       = 148
    ,command_FieldId_adbl                       = 149
    ,command_FieldId_aflag                      = 150
    ,command_FieldId_str                        = 151
    ,command_FieldId_num                        = 152
    ,command_FieldId_dbl                        = 153
    ,command_FieldId_flag                       = 154
    ,command_FieldId_dstr                       = 155
    ,command_FieldId_dnum                       = 156
    ,command_FieldId_ddbl                       = 157
    ,command_FieldId_dflag                      = 158
    ,command_FieldId_mstr                       = 159
    ,command_FieldId_mnum                       = 160
    ,command_FieldId_mdbl                       = 161
    ,command_FieldId_amnum                      = 162
    ,command_FieldId_cconst                     = 163
    ,command_FieldId_dregx                      = 164
    ,command_FieldId_dpkey                      = 165
    ,command_FieldId_comptest                   = 166
    ,command_FieldId_mdbg                       = 167
    ,command_FieldId_run                        = 168
    ,command_FieldId_printinput                 = 169
    ,command_FieldId_normalize                  = 170
    ,command_FieldId_covcapture                 = 171
    ,command_FieldId_covcheck                   = 172
    ,command_FieldId_compdir                    = 173
    ,command_FieldId_check_untracked            = 174
    ,command_FieldId_memcheck                   = 175
    ,command_FieldId_callgrind                  = 176
    ,command_FieldId_stream                     = 177
    ,command_FieldId_i                          = 178
    ,command_FieldId_b                          = 179
    ,command_FieldId_covdir                     = 180
    ,command_FieldId_logfile                    = 181
    ,command_FieldId_runcmd                     = 182
    ,command_FieldId_exclude                    = 183
    ,command_FieldId_mergepath                  = 184
    ,command_FieldId_gcov                       = 185
    ,command_FieldId_ssim                       = 186
    ,command_FieldId_xmlpretty                  = 187
    ,command_FieldId_summary                    = 188
    ,command_FieldId_reprofile                  = 189
    ,command_FieldId_args                       = 190
    ,command_FieldId_inputfile                  = 191
    ,command_FieldId_fuzzstrat                  = 192
    ,command_FieldId_seed                       = 193
    ,command_FieldId_testprob                   = 194
    ,command_FieldId_gtblacttst                 = 195
    ,command_FieldId_mr                         = 196
    ,command_FieldId_note                       = 197
    ,command_FieldId_skip_init                  = 198
    ,command_FieldId_skip_git_init              = 199
    ,command_FieldId_ncmd                       = 200
    ,command_FieldId_nofork                     = 201
    ,command_FieldId_perf_secs                  = 202
    ,command_FieldId_pertest_timeout            = 203
    ,command_FieldId_stats                      = 204
    ,command_FieldId_enable                     = 205
    ,command_FieldId_disable                    = 206
    ,command_FieldId_gc                         = 207
    ,command_FieldId_dir                        = 208
    ,command_FieldId_hitrate                    = 209
    ,command_FieldId_after                      = 210
    ,command_FieldId_selector                   = 211
    ,command_FieldId_fields                     = 212
    ,command_FieldId_accept                     = 213
    ,command_FieldId_approve                    = 214
    ,command_FieldId_needs_work                 = 215
    ,command_FieldId_authdir                    = 216
    ,command_FieldId_gitdir                     = 217
    ,command_FieldId_show_gitlab_system_notes   = 218
    ,command_FieldId_complooo                   = 219
    ,command_FieldId_attach                     = 220
    ,command_FieldId_catchthrow                 = 221
    ,command_FieldId_tui                        = 222
    ,command_FieldId_bcmd                       = 223
    ,command_FieldId_emacs                      = 224
    ,command_FieldId_manywin                    = 225
    ,command_FieldId_follow_child               = 226
    ,command_FieldId_py                         = 227
    ,command_FieldId_writessimfile              = 228
    ,command_FieldId_url                        = 229
    ,command_FieldId_tables                     = 230
    ,command_FieldId_nologo                     = 231
    ,command_FieldId_baddbok                    = 232
    ,command_FieldId_move                       = 233
    ,command_FieldId_dedup                      = 234
    ,command_FieldId_commit                     = 235
    ,command_FieldId_undo                       = 236
    ,command_FieldId_hash                       = 237
    ,command_FieldId_expr                       = 238
    ,command_FieldId_style                      = 239
    ,command_FieldId_match                      = 240
    ,command_FieldId_string                     = 241
    ,command_FieldId_show                       = 242
    ,command_FieldId_name                       = 243
    ,command_FieldId_reset                      = 244
    ,command_FieldId_diff                       = 245
    ,command_FieldId_files                      = 246
    ,command_FieldId_body                       = 247
    ,command_FieldId_targsrc                    = 248
    ,command_FieldId_func                       = 249
    ,command_FieldId_nextfile                   = 250
    ,command_FieldId_other                      = 251
    ,command_FieldId_updateproto                = 252
    ,command_FieldId_listfunc                   = 253
    ,command_FieldId_iffy                       = 254
    ,command_FieldId_gen                        = 255
    ,command_FieldId_showloc                    = 256
    ,command_FieldId_showstatic                 = 257
    ,command_FieldId_showsortkey                = 258
    ,command_FieldId_sortname                   = 259
    ,command_FieldId_baddecl                    = 260
    ,command_FieldId_indent                     = 261
    ,command_FieldId_update_copyright           = 262
    ,command_FieldId_scriptfile                 = 263
    ,command_FieldId_linelim                    = 264
    ,command_FieldId_strayfile                  = 265
    ,command_FieldId_badchar                    = 266
    ,command_FieldId_badline                    = 267
    ,command_FieldId_expand                     = 268
    ,command_FieldId_ignoreQuote                = 269
    ,command_FieldId_maxpacket                  = 270
    ,command_FieldId_db                         = 271
    ,command_FieldId_createdb                   = 272
    ,command_FieldId_typetag                    = 273
    ,command_FieldId_format                     = 274
    ,command_FieldId_tocamelcase                = 275
    ,command_FieldId_tolowerunder               = 276
    ,command_FieldId_pathcomp                   = 277
    ,command_FieldId_fname                      = 278
    ,command_FieldId_outseparator               = 279
    ,command_FieldId_header                     = 280
    ,command_FieldId_prefer_signed              = 281
    ,command_FieldId_value                      = 282
};

enum { command_FieldIdEnum_N = 283 };


// --- command_atf_cmdline_fconst_Enum

enum command_atf_cmdline_fconst_Enum {         // command.atf_cmdline.fconst
     command_atf_cmdline_fconst_high     = 0   // Cool
    ,command_atf_cmdline_fconst_medium   = 1   // So-so
    ,command_atf_cmdline_fconst_low      = 2   // Bad
};

enum { command_atf_cmdline_fconst_Enum_N = 3 };


// --- command_samp_regx_style_Enum

enum command_samp_regx_style_Enum {          // command.samp_regx.style
     command_samp_regx_style_acr       = 0   // ACR-style regx
    ,command_samp_regx_style_shell     = 1   // Shell-style regx
    ,command_samp_regx_style_classic   = 2   // Classic regx
    ,command_samp_regx_style_literal   = 3   // Literal string
};

enum { command_samp_regx_style_Enum_N = 4 };


// --- command_ssimfilt_format_Enum

enum command_ssimfilt_format_Enum {        // command.ssimfilt.format
     command_ssimfilt_format_ssim    = 0   // Print selected/filtered tuples
    ,command_ssimfilt_format_csv     = 1   // First tuple determines header. CSV quoting is used. Newlines are removed
    ,command_ssimfilt_format_field   = 2   // Print selected fields, one per line
    ,command_ssimfilt_format_cmd     = 4   // Emit command for each tuple (implied if -cmd is set)
    ,command_ssimfilt_format_table   = 5   // ASCII table for each group of tuples
};

enum { command_ssimfilt_format_Enum_N = 5 };

namespace command { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace command { // gen:ns_field
} // gen:ns_field
// gen:ns_fwddecl2
namespace command { struct acr_where_curs; }
namespace command { struct acr_field_curs; }
namespace command { struct acr_dm_arg_curs; }
namespace command { struct atf_cmdline_mstr_curs; }
namespace command { struct atf_cmdline_mnum_curs; }
namespace command { struct atf_cmdline_mdbl_curs; }
namespace command { struct atf_cmdline_amnum_curs; }
namespace command { struct gcache_cmd_curs; }
namespace command { struct gcli_fields_curs; }
namespace command { struct mdbg_args_curs; }
namespace command { struct mdbg_b_curs; }
namespace command { struct sandbox_cmd_curs; }
namespace command { struct sandbox_files_curs; }
namespace command { struct ssimfilt_match_curs; }
namespace command { struct ssimfilt_field_curs; }
namespace command { struct FieldId; }
namespace command { struct Protocol; }
namespace command { struct abt; }
namespace command { struct abt_md; }
namespace command { struct abt_md_proc; }
namespace command { struct abt_proc; }
namespace command { struct acr; }
namespace command { struct acr_compl; }
namespace command { struct acr_compl_proc; }
namespace command { struct acr_dm; }
namespace command { struct acr_dm_proc; }
namespace command { struct acr_ed; }
namespace command { struct acr_ed_proc; }
namespace command { struct acr_in; }
namespace command { struct acr_in_proc; }
namespace command { struct acr_my; }
namespace command { struct acr_my_proc; }
namespace command { struct acr_proc; }
namespace command { struct amc; }
namespace command { struct amc_dml; }
namespace command { struct amc_gc; }
namespace command { struct amc_gc_proc; }
namespace command { struct amc_proc; }
namespace command { struct amc_vis; }
namespace command { struct amc_vis_proc; }
namespace command { struct ams_cat; }
namespace command { struct ams_cat_proc; }
namespace command { struct ams_sendtest; }
namespace command { struct ams_sendtest_proc; }
namespace command { struct atf_amc; }
namespace command { struct atf_amc_proc; }
namespace command { struct atf_ci; }
namespace command { struct atf_ci_proc; }
namespace command { struct atf_cmdline; }
namespace command { struct atf_cmdline_proc; }
namespace command { struct atf_comp; }
namespace command { struct atf_comp_proc; }
namespace command { struct atf_cov; }
namespace command { struct atf_cov_proc; }
namespace command { struct atf_fuzz; }
namespace command { struct atf_fuzz_proc; }
namespace command { struct atf_gcli; }
namespace command { struct atf_gcli_proc; }
namespace command { struct atf_nrun; }
namespace command { struct atf_nrun_proc; }
namespace command { struct atf_unit; }
namespace command { struct atf_unit_proc; }
namespace command { struct bash; }
namespace command { struct bash2html; }
namespace command { struct bash2html_proc; }
namespace command { struct bash_proc; }
namespace command { struct gcache; }
namespace command { struct gcache_proc; }
namespace command { struct gcli; }
namespace command { struct gcli_proc; }
namespace command { struct lib_ctype; }
namespace command { struct lib_exec; }
namespace command { struct mdbg; }
namespace command { struct mdbg_proc; }
namespace command { struct mysql2ssim; }
namespace command { struct mysql2ssim_proc; }
namespace command { struct orgfile; }
namespace command { struct orgfile_proc; }
namespace command { struct samp_regx; }
namespace command { struct samp_regx_proc; }
namespace command { struct sandbox; }
namespace command { struct sandbox_proc; }
namespace command { struct src_func; }
namespace command { struct src_func_proc; }
namespace command { struct src_hdr; }
namespace command { struct src_hdr_proc; }
namespace command { struct src_lim; }
namespace command { struct src_lim_proc; }
namespace command { struct ssim2csv; }
namespace command { struct ssim2csv_proc; }
namespace command { struct ssim2mysql; }
namespace command { struct ssim2mysql_proc; }
namespace command { struct ssimfilt; }
namespace command { struct ssimfilt_proc; }
namespace command { struct strconv; }
namespace command { struct strconv_proc; }
namespace command { struct sv2ssim; }
namespace command { struct sv2ssim_proc; }
namespace command { // gen:ns_print_struct

// --- command.FieldId
#pragma pack(push,1)
struct FieldId { // command.FieldId: Field read helper
    i32   value;   //   -1
    inline operator command_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(command_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
command_FieldIdEnum  value_GetEnum(const command::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(command::FieldId& parent, command_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const command::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const command::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(command::FieldId& parent, algo::strptr rhs, command_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(command::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of command::FieldId from an ascii string.
// The format of the string is the format of the command::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(command::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(command::FieldId& parent);
// print string representation of command::FieldId to string LHS, no header -- cprint:command.FieldId.String
void                 FieldId_Print(command::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- command.Protocol
// access: command.Protocol.proto (Protocol)
#pragma pack(push,1)
struct Protocol { // command.Protocol: amc-generated struct for internal purposes
    Protocol();
};
#pragma pack(pop)

void                 StaticCheck();


// --- command.abt
// access: command.abt_proc.abt (Exec)
struct abt { // command.abt
    algo_lib::Regx     target;     //   ""  Sql Regx of dev::Target
    algo::cstring      in;         //   "data"  Root of input ssim dir
    algo::cstring      out_dir;    //   ""  Output directory
    algo::Smallstr50   cfg;        //   ""  Set config
    algo::Smallstr50   compiler;   //   ""  Set compiler.
    algo::Smallstr50   uname;      //   ""  Set uname (default: guess)
    algo::Smallstr50   arch;       //   ""  Set architecture (default: guess)
    bool               ood;        //   false  List out-of-date source files
    bool               list;       //   false  List target files
    bool               listincl;   //   false  List includes
    bool               build;      //   false  If set, build specified target (all necessary steps)
    bool               preproc;    //   false  Preprocess file, produce .i file
    bool               clean;      //   false  Delete all output files
    bool               dry_run;    //   false  Print actions, do not perform
    i32                maxjobs;    //   0  Maximum number of child build processes. 0=pick good default
    bool               printcmd;   //   false  Print commands. Do not execute
    bool               force;      //   false  Assume all files are out-of-date
    bool               install;    //   false  Update soft-link under bin/
    bool               coverity;   //   false  Run abt in coverity mode
    algo::cstring      package;    //   ""  Package tag
    u32                maxerr;     //   100  Max failing commands before rest of pipeline is forced to fail
    algo_lib::Regx     disas;      //   ""  Sql Regx
    bool               report;     //   true  Print final report
    algo::cstring      jcdb;       //   ""  Create JSON compilation database in specified file
    abt();
private:
    // reftype Regx of command.abt.target prohibits copy
    // reftype Regx of command.abt.disas prohibits copy
    abt(const abt&){ /*disallow copy constructor */}
    void operator =(const abt&){ /*disallow direct assignment */}
};

// Print back to string
void                 target_Print(command::abt& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 target_ReadStrptrMaybe(command::abt& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 disas_Print(command::abt& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 disas_ReadStrptrMaybe(command::abt& parent, algo::strptr in) __attribute__((nothrow));

bool                 abt_ReadFieldMaybe(command::abt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::abt from attributes of ascii tuple TUPLE
bool                 abt_ReadTupleMaybe(command::abt &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 abt_Init(command::abt& parent);
// print command-line args of command::abt to string  -- cprint:command.abt.Argv
void                 abt_PrintArgv(command::abt & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              abt_ToCmdline(command::abt & row) __attribute__((nothrow));
algo::strptr         abt_GetAnon(command::abt &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  abt_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.abt_md
// access: command.abt_md_proc.abt_md (Exec)
struct abt_md { // command.abt_md
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   readme;    //   "%"  Sql Regx of dev::Readme
    algo_lib::Regx   ns;        //   ""  Sql Regx of dev::Readmens
    algo_lib::Regx   section;   //   "%"  Sql Regx
    bool             print;     //   false  Print output to screen
    bool             dry_run;   //   false  Do not write changes to disk
    abt_md();
private:
    // reftype Regx of command.abt_md.readme prohibits copy
    // reftype Regx of command.abt_md.ns prohibits copy
    // reftype Regx of command.abt_md.section prohibits copy
    // ... and several other reasons
    abt_md(const abt_md&){ /*disallow copy constructor */}
    void operator =(const abt_md&){ /*disallow direct assignment */}
};

// Print back to string
void                 readme_Print(command::abt_md& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 readme_ReadStrptrMaybe(command::abt_md& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 ns_Print(command::abt_md& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ns_ReadStrptrMaybe(command::abt_md& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 section_Print(command::abt_md& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 section_ReadStrptrMaybe(command::abt_md& parent, algo::strptr in) __attribute__((nothrow));

bool                 abt_md_ReadFieldMaybe(command::abt_md &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::abt_md from attributes of ascii tuple TUPLE
bool                 abt_md_ReadTupleMaybe(command::abt_md &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 abt_md_Init(command::abt_md& parent);
// print command-line args of command::abt_md to string  -- cprint:command.abt_md.Argv
void                 abt_md_PrintArgv(command::abt_md & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              abt_md_ToCmdline(command::abt_md & row) __attribute__((nothrow));
algo::strptr         abt_md_GetAnon(command::abt_md &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  abt_md_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.abt_md_proc
struct abt_md_proc { // command.abt_md_proc: Subprocess: Tool to generate markdown documentation
    algo::cstring     path;      //   "bin/abt_md"  path for executable
    command::abt_md   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    abt_md_proc();
    ~abt_md_proc();
private:
    // reftype Exec of command.abt_md_proc.abt_md prohibits copy
    // value field command.abt_md_proc.cmd is not copiable
    abt_md_proc(const abt_md_proc&){ /*disallow copy constructor */}
    void operator =(const abt_md_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  abt_md_Start(command::abt_md_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         abt_md_StartRead(command::abt_md_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 abt_md_Kill(command::abt_md_proc& parent);
// Wait for subprocess to return
void                 abt_md_Wait(command::abt_md_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  abt_md_Exec(command::abt_md_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 abt_md_ExecX(command::abt_md_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:abt_md.Argv
int                  abt_md_Execv(command::abt_md_proc& parent) __attribute__((nothrow));
algo::tempstr        abt_md_ToCmdline(command::abt_md_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 abt_md_proc_Init(command::abt_md_proc& parent);
void                 abt_md_proc_Uninit(command::abt_md_proc& parent) __attribute__((nothrow));

// --- command.abt_proc
struct abt_proc { // command.abt_proc: Subprocess: Algo Build Tool - build & link C++ targets
    algo::cstring   path;      //   "bin/abt"  path for executable
    command::abt    cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    abt_proc();
    ~abt_proc();
private:
    // reftype Exec of command.abt_proc.abt prohibits copy
    // value field command.abt_proc.cmd is not copiable
    abt_proc(const abt_proc&){ /*disallow copy constructor */}
    void operator =(const abt_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  abt_Start(command::abt_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         abt_StartRead(command::abt_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 abt_Kill(command::abt_proc& parent);
// Wait for subprocess to return
void                 abt_Wait(command::abt_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  abt_Exec(command::abt_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 abt_ExecX(command::abt_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int                  abt_Execv(command::abt_proc& parent) __attribute__((nothrow));
algo::tempstr        abt_ToCmdline(command::abt_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 abt_proc_Init(command::abt_proc& parent);
void                 abt_proc_Uninit(command::abt_proc& parent) __attribute__((nothrow));

// --- command.acr
// access: command.acr_proc.acr (Exec)
struct acr { // command.acr
    algo::cstring    query;         //   ""  Regx to match record
    algo::cstring*   where_elems;   // pointer to elements
    u32              where_n;       // number of elements in array
    u32              where_max;     // max. capacity of array before realloc
    bool             select;        //   true  Select records matching query (default)
    bool             del;           //   false  Delete found item
    bool             insert;        //   false  Read stdin and insert tuples
    bool             replace;       //   false  Read stdin and replace tuples
    bool             update;        //   false  Read stdin and update attributes of existing tuples
    bool             merge;         //   false  Combination of -update and -insert
    bool             unused;        //   false  Only select records which are not referenced.
    bool             trunc;         //   false  (with insert or rename): truncate table on first write
    bool             check;         //   false  Run cross-reference check on selection
    bool             selerr;        //   true  (with -check): Select error records
    i32              maxshow;       //   100  Limit number of errors per table
    bool             write;         //   false  Write data back to disk.
    algo::cstring    rename;        //   ""  Change value of found item
    i32              nup;           //   0  Number of levels to go up
    i32              ndown;         //   0  Number of levels to go down
    bool             xref;          //   false  Short for -nup 100 -ndown 100
    bool             fldfunc;       //   false  Evaluate fldfunc when printing tuple
    i32              maxgroup;      //   25  Max. items per group
    bool             pretty;        //   true  Align output in blocks
    bool             tree;          //   false  Print as tree
    bool             loose;         //   false  Allow printing a record before its references (used with -e)
    bool             my;            //   false  Invoke acr_my -e (using acr_my directly is faster)
    algo::cstring    schema;        //   "data"  Directory for initializing acr meta-data
    bool             e;             //   false  Open selection in editor, write back when done.
    bool             t;             //   false  Short for -tree -xref -loose
    bool             rowid;         //   false  Always print acr.rowid attribute
    algo::cstring    in;            //   "data"  Input directory or filename, - for stdin
    bool             cmt;           //   false  Print comments for all columns referenced in output
    bool             report;        //   true  Show final report
    bool             print;         //   true  Print selected records
    algo::cstring    cmd;           //   ""  Print script with command execution for each selected row
    algo::cstring*   field_elems;   // pointer to elements
    u32              field_n;       // number of elements in array
    u32              field_max;     // max. capacity of array before realloc
    algo::cstring    regxof;        //   ""  Single field: output regx of matching field values
    bool             meta;          //   false  Select meta-data for selected records
    acr();
    ~acr();
private:
    // reftype Tary of command.acr.where prohibits copy
    // reftype Tary of command.acr.field prohibits copy
    acr(const acr&){ /*disallow copy constructor */}
    void operator =(const acr&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       where_Alloc(command::acr& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       where_AllocAt(command::acr& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> where_AllocN(command::acr& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 where_EmptyQ(command::acr& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       where_Find(command::acr& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> where_Getary(command::acr& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       where_Last(command::acr& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  where_Max(command::acr& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  where_N(const command::acr& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 where_Remove(command::acr& parent, u32 i) __attribute__((nothrow));
void                 where_RemoveAll(command::acr& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 where_RemoveLast(command::acr& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 where_Reserve(command::acr& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 where_AbsReserve(command::acr& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 where_Setary(command::acr& parent, command::acr &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       where_qFind(command::acr& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       where_qLast(command::acr& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  where_rowid_Get(command::acr& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> where_AllocNVal(command::acr& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 where_ReadStrptrMaybe(command::acr& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       field_Alloc(command::acr& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       field_AllocAt(command::acr& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> field_AllocN(command::acr& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 field_EmptyQ(command::acr& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       field_Find(command::acr& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> field_Getary(command::acr& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       field_Last(command::acr& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  field_Max(command::acr& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  field_N(const command::acr& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 field_Remove(command::acr& parent, u32 i) __attribute__((nothrow));
void                 field_RemoveAll(command::acr& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 field_RemoveLast(command::acr& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 field_Reserve(command::acr& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 field_AbsReserve(command::acr& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 field_Setary(command::acr& parent, command::acr &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       field_qFind(command::acr& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       field_qLast(command::acr& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  field_rowid_Get(command::acr& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> field_AllocNVal(command::acr& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 field_ReadStrptrMaybe(command::acr& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 acr_where_curs_Next(acr_where_curs &curs);
void                 acr_where_curs_Reset(acr_where_curs &curs, command::acr &parent);
// cursor points to valid item
bool                 acr_where_curs_ValidQ(acr_where_curs &curs);
// item access
algo::cstring&       acr_where_curs_Access(acr_where_curs &curs);
// proceed to next item
void                 acr_field_curs_Next(acr_field_curs &curs);
void                 acr_field_curs_Reset(acr_field_curs &curs, command::acr &parent);
// cursor points to valid item
bool                 acr_field_curs_ValidQ(acr_field_curs &curs);
// item access
algo::cstring&       acr_field_curs_Access(acr_field_curs &curs);
bool                 acr_ReadFieldMaybe(command::acr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr from attributes of ascii tuple TUPLE
bool                 acr_ReadTupleMaybe(command::acr &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_Init(command::acr& parent);
void                 acr_Uninit(command::acr& parent) __attribute__((nothrow));
// print command-line args of command::acr to string  -- cprint:command.acr.Argv
void                 acr_PrintArgv(command::acr & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_ToCmdline(command::acr & row) __attribute__((nothrow));
algo::strptr         acr_GetAnon(command::acr &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  acr_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.acr_compl
// access: command.acr_compl_proc.acr_compl (Exec)
struct acr_compl { // command.acr_compl
    algo::cstring   data;        //   "data"  Source for completions (dir or file or -)
    algo::cstring   schema;      //   "data"  Source for schema information
    algo::cstring   line;        //   ""  Simulates COMP_LINE (debug)
    algo::cstring   point;       //   ""  Simulates COMP_POINT (debug). default: whole line
    algo::cstring   type;        //   "9"  Simulates COMP_TYPE (debug)
    bool            install;     //   false  Produce bash commands to install the handler
    algo::cstring   debug_log;   //   ""  Log file for debug information, overrides ACR_COMPL_DEBUG_LOG
    acr_compl();
};

bool                 acr_compl_ReadFieldMaybe(command::acr_compl &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_compl from an ascii string.
// The format of the string is an ssim Tuple
bool                 acr_compl_ReadStrptrMaybe(command::acr_compl &parent, algo::strptr in_str);
// Read fields of command::acr_compl from attributes of ascii tuple TUPLE
bool                 acr_compl_ReadTupleMaybe(command::acr_compl &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_compl_Init(command::acr_compl& parent);
// print command-line args of command::acr_compl to string  -- cprint:command.acr_compl.Argv
void                 acr_compl_PrintArgv(command::acr_compl & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_compl_ToCmdline(command::acr_compl & row) __attribute__((nothrow));
// print string representation of command::acr_compl to string LHS, no header -- cprint:command.acr_compl.String
void                 acr_compl_Print(command::acr_compl & row, algo::cstring &str) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  acr_compl_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.acr_compl_proc
struct acr_compl_proc { // command.acr_compl_proc: Subprocess: ACR shell auto-complete for all targets
    algo::cstring        path;      //   "bin/acr_compl"  path for executable
    command::acr_compl   cmd;       // command line for child process
    algo::cstring        fstdin;    // redirect for stdin
    algo::cstring        fstdout;   // redirect for stdout
    algo::cstring        fstderr;   // redirect for stderr
    pid_t                pid;       //   0  pid of running child process
    i32                  timeout;   //   0  optional timeout for child process
    i32                  status;    //   0  last exit status of child process
    acr_compl_proc();
    ~acr_compl_proc();
private:
    // reftype Exec of command.acr_compl_proc.acr_compl prohibits copy
    acr_compl_proc(const acr_compl_proc&){ /*disallow copy constructor */}
    void operator =(const acr_compl_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_compl_Start(command::acr_compl_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_compl_StartRead(command::acr_compl_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_compl_Kill(command::acr_compl_proc& parent);
// Wait for subprocess to return
void                 acr_compl_Wait(command::acr_compl_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_compl_Exec(command::acr_compl_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_compl_ExecX(command::acr_compl_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_compl.Argv
int                  acr_compl_Execv(command::acr_compl_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_compl_ToCmdline(command::acr_compl_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_compl_proc_Init(command::acr_compl_proc& parent);
void                 acr_compl_proc_Uninit(command::acr_compl_proc& parent) __attribute__((nothrow));

// --- command.acr_dm
// access: command.acr_dm_proc.acr_dm (Exec)
struct acr_dm { // command.acr_dm
    algo::cstring    in;           //   "data"  Input directory or filename, - for stdin
    algo::cstring*   arg_elems;    // pointer to elements
    u32              arg_n;        // number of elements in array
    u32              arg_max;      // max. capacity of array before realloc
    bool             write_ours;   //   false  Write result to ours file
    u8               msize;        //   7  Conflict marker size
    acr_dm();
    ~acr_dm();
private:
    // reftype Tary of command.acr_dm.arg prohibits copy
    acr_dm(const acr_dm&){ /*disallow copy constructor */}
    void operator =(const acr_dm&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       arg_Alloc(command::acr_dm& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       arg_AllocAt(command::acr_dm& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> arg_AllocN(command::acr_dm& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 arg_EmptyQ(command::acr_dm& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       arg_Find(command::acr_dm& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> arg_Getary(command::acr_dm& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       arg_Last(command::acr_dm& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  arg_Max(command::acr_dm& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  arg_N(const command::acr_dm& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 arg_Remove(command::acr_dm& parent, u32 i) __attribute__((nothrow));
void                 arg_RemoveAll(command::acr_dm& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 arg_RemoveLast(command::acr_dm& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 arg_Reserve(command::acr_dm& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 arg_AbsReserve(command::acr_dm& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 arg_Setary(command::acr_dm& parent, command::acr_dm &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       arg_qFind(command::acr_dm& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       arg_qLast(command::acr_dm& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  arg_rowid_Get(command::acr_dm& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> arg_AllocNVal(command::acr_dm& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 arg_ReadStrptrMaybe(command::acr_dm& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 acr_dm_arg_curs_Next(acr_dm_arg_curs &curs);
void                 acr_dm_arg_curs_Reset(acr_dm_arg_curs &curs, command::acr_dm &parent);
// cursor points to valid item
bool                 acr_dm_arg_curs_ValidQ(acr_dm_arg_curs &curs);
// item access
algo::cstring&       acr_dm_arg_curs_Access(acr_dm_arg_curs &curs);
bool                 acr_dm_ReadFieldMaybe(command::acr_dm &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_dm from attributes of ascii tuple TUPLE
bool                 acr_dm_ReadTupleMaybe(command::acr_dm &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_dm_Init(command::acr_dm& parent);
void                 acr_dm_Uninit(command::acr_dm& parent) __attribute__((nothrow));
// print command-line args of command::acr_dm to string  -- cprint:command.acr_dm.Argv
void                 acr_dm_PrintArgv(command::acr_dm & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_dm_ToCmdline(command::acr_dm & row) __attribute__((nothrow));
algo::strptr         acr_dm_GetAnon(command::acr_dm &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  acr_dm_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.acr_dm_proc
struct acr_dm_proc { // command.acr_dm_proc: Subprocess: ACR Diff/Merge
    algo::cstring     path;      //   "bin/acr_dm"  path for executable
    command::acr_dm   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_dm_proc();
    ~acr_dm_proc();
private:
    // reftype Exec of command.acr_dm_proc.acr_dm prohibits copy
    // value field command.acr_dm_proc.cmd is not copiable
    acr_dm_proc(const acr_dm_proc&){ /*disallow copy constructor */}
    void operator =(const acr_dm_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_dm_Start(command::acr_dm_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_dm_StartRead(command::acr_dm_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_dm_Kill(command::acr_dm_proc& parent);
// Wait for subprocess to return
void                 acr_dm_Wait(command::acr_dm_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_dm_Exec(command::acr_dm_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_dm_ExecX(command::acr_dm_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_dm.Argv
int                  acr_dm_Execv(command::acr_dm_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_dm_ToCmdline(command::acr_dm_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_dm_proc_Init(command::acr_dm_proc& parent);
void                 acr_dm_proc_Uninit(command::acr_dm_proc& parent) __attribute__((nothrow));

// --- command.acr_ed
// access: command.acr_ed_proc.acr_ed (Exec)
struct acr_ed { // command.acr_ed
    algo::cstring       in;          //   "data"  Input directory or filename, - for stdin
    bool                create;      //   false  Create new entity (-finput, -target, -ctype, -field)
    bool                del;         //   false  Delete mode
    algo::cstring       rename;      //   ""  Rename to something else
    bool                finput;      //   false  Create in-memory table based on ssimfile
    bool                foutput;     //   false  Declare field as an output
    algo::cstring       srcfile;     //   ""      Create source file
    bool                gstatic;     //   false  Like -finput, but data is loaded at compile time
    bool                indexed;     //   false  (with -finput) Add hash index
    algo::Smallstr16    target;      //   ""  Create new target
    algo::Smallstr50    nstype;      //   "exe"  (with -create -target): exe,lib,etc.
    algo::Smallstr50    ctype;       //   ""  Create new ctype
    algo::Smallstr50    pooltype;    //   ""   Pool reftype (Lary,Lpool etc) for finput/ctype
    algo::Smallstr50    ssimfile;    //   ""    Ssimfile for new ctype
    algo::Smallstr50    subset;      //   ""    Primary key is a subset of this ctype
    algo::Smallstr50    subset2;     //   ""    Primary key is also a subset of this ctype
    algo::cstring       separator;   //   "."      Key separator
    algo::Smallstr100   field;       //   ""  Create field
    algo::Smallstr50    arg;         //   ""    Field type (e.g. u32, etc), (with -ctype) add the base field
    algo::cstring       dflt;        //   ""    Field default value
    bool                anon;        //   false    Anonymous field (use with command lines)
    bool                bigend;      //   false    Big-endian field
    bool                cascdel;     //   false    Field is cascdel
    algo::Smallstr100   before;      //   ""    Place field before this one
    algo::Smallstr100   substr;      //   ""    New field is a substring
    bool                alias;       //   false  Create alias field (requires -srcfield)
    algo::Smallstr100   srcfield;    //   ""    Source field for bitfld/substr
    algo::Smallstr100   fstep;       //   ""    Add fstep record
    algo::cstring       inscond;     //   "true"    Insert condition (for xref)
    algo::Smallstr50    reftype;     //   ""    Reftype (e.g. Val, Thash, Llist, etc)
    algo::Smallstr100   hashfld;     //   ""      (-reftype:Thash) Hash field
    algo::Smallstr100   sortfld;     //   ""      (-reftype:Bheap) Sort field
    algo::cstring       unittest;    //   ""  Create unit test, <ns>.<functionname>
    algo::cstring       citest;      //   ""  Create CI test
    algo::cstring       cppfunc;     //   ""  Field is a cppfunc, pass c++ expression as argument
    bool                xref;        //   false      X-ref with field type
    algo::cstring       via;         //   ""        X-ref argument (index, pointer, or index/key)
    bool                write;       //   false  Commit output to disk
    bool                e;           //   false   (with -create -unittest) Edit new testcase
    algo::cstring       comment;     //   ""  Comment for new entity
    bool                sandbox;     //   false  Make changes in sandbox
    bool                test;        //   false  Build resulting changes, run tests
    bool                showcpp;     //   false  (With -sandbox), show resulting diff
    algo::cstring       msgtype;     //   ""  (with -ctype) use this msgtype as type
    bool                anonfld;     //   false  Create anonfld
    acr_ed();
};

bool                 acr_ed_ReadFieldMaybe(command::acr_ed &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_ed from attributes of ascii tuple TUPLE
bool                 acr_ed_ReadTupleMaybe(command::acr_ed &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_ed_Init(command::acr_ed& parent);
// print command-line args of command::acr_ed to string  -- cprint:command.acr_ed.Argv
void                 acr_ed_PrintArgv(command::acr_ed & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_ed_ToCmdline(command::acr_ed & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  acr_ed_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.acr_ed_proc
struct acr_ed_proc { // command.acr_ed_proc: Subprocess: ACR Editor Set of useful recipes, uses acr, abt, git, and other tools
    algo::cstring     path;      //   "bin/acr_ed"  path for executable
    command::acr_ed   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_ed_proc();
    ~acr_ed_proc();
private:
    // reftype Exec of command.acr_ed_proc.acr_ed prohibits copy
    acr_ed_proc(const acr_ed_proc&){ /*disallow copy constructor */}
    void operator =(const acr_ed_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_ed_Start(command::acr_ed_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_ed_StartRead(command::acr_ed_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_ed_Kill(command::acr_ed_proc& parent);
// Wait for subprocess to return
void                 acr_ed_Wait(command::acr_ed_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_ed_Exec(command::acr_ed_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_ed_ExecX(command::acr_ed_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_ed.Argv
int                  acr_ed_Execv(command::acr_ed_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_ed_ToCmdline(command::acr_ed_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_ed_proc_Init(command::acr_ed_proc& parent);
void                 acr_ed_proc_Uninit(command::acr_ed_proc& parent) __attribute__((nothrow));

// --- command.acr_in
// access: command.acr_in_proc.acr_in (Exec)
struct acr_in { // command.acr_in
    algo_lib::Regx   ns;            //   ""  Sql Regx of dmmeta::Ns
    bool             data;          //   false  List ssimfile contents
    bool             sigcheck;      //   true  Output sigcheck records for schema version mismatch detection
    bool             list;          //   false  List ssimfile names
    bool             t;             //   false  (with -list) Tree mode
    algo::cstring    data_dir;      //   "data"  Directory with ssimfiles
    algo::cstring    schema;        //   "data"
    algo::cstring    related;       //   ""  Select only tuples related to specified acr key
    algo_lib::Regx   notssimfile;   //   ""  Sql Regx of dmmeta::Ssimfile
    bool             checkable;     //   false  Ensure output passes acr -check
    algo_lib::Regx   r;             //   ""  Sql Regx of dmmeta::Ssimfile
    acr_in();
private:
    // reftype Regx of command.acr_in.ns prohibits copy
    // reftype Regx of command.acr_in.notssimfile prohibits copy
    // reftype Regx of command.acr_in.r prohibits copy
    // ... and several other reasons
    acr_in(const acr_in&){ /*disallow copy constructor */}
    void operator =(const acr_in&){ /*disallow direct assignment */}
};

// Print back to string
void                 ns_Print(command::acr_in& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ns_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 notssimfile_Print(command::acr_in& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 notssimfile_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 r_Print(command::acr_in& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 r_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) __attribute__((nothrow));

bool                 acr_in_ReadFieldMaybe(command::acr_in &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_in from attributes of ascii tuple TUPLE
bool                 acr_in_ReadTupleMaybe(command::acr_in &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_in_Init(command::acr_in& parent);
// print command-line args of command::acr_in to string  -- cprint:command.acr_in.Argv
void                 acr_in_PrintArgv(command::acr_in & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_in_ToCmdline(command::acr_in & row) __attribute__((nothrow));
algo::strptr         acr_in_GetAnon(command::acr_in &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  acr_in_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.acr_in_proc
struct acr_in_proc { // command.acr_in_proc: Subprocess: ACR Input - compute set of ssimfiles or tuples used by a specific target
    algo::cstring     path;      //   "bin/acr_in"  path for executable
    command::acr_in   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_in_proc();
    ~acr_in_proc();
private:
    // reftype Exec of command.acr_in_proc.acr_in prohibits copy
    // value field command.acr_in_proc.cmd is not copiable
    acr_in_proc(const acr_in_proc&){ /*disallow copy constructor */}
    void operator =(const acr_in_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_in_Start(command::acr_in_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_in_StartRead(command::acr_in_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_in_Kill(command::acr_in_proc& parent);
// Wait for subprocess to return
void                 acr_in_Wait(command::acr_in_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_in_Exec(command::acr_in_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_in_ExecX(command::acr_in_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_in.Argv
int                  acr_in_Execv(command::acr_in_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_in_ToCmdline(command::acr_in_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_in_proc_Init(command::acr_in_proc& parent);
void                 acr_in_proc_Uninit(command::acr_in_proc& parent) __attribute__((nothrow));

// --- command.acr_my
// access: command.acr_my_proc.acr_my (Exec)
struct acr_my { // command.acr_my
    algo_lib::Regx   nsdb;      //   ""  Sql Regx of dmmeta::Nsdb
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo::cstring    schema;    //   "data"  Input directory or filename, - for stdin
    bool             fldfunc;   //   false  Evaluate fldfunc when printing tuple
    bool             fkey;      //   false  Enable foreign key constraints
    bool             e;         //   false  Alias for -start -shell -stop
    bool             start;     //   false  Start local mysql server
    bool             stop;      //   false  Stop local mysql server, saving data
    bool             abort;     //   false  Abort local mysql server, losing data
    bool             shell;     //   false  Connect to local mysql server
    bool             serv;      //   false  Start mysql with TCP/IP service enabled
    acr_my();
private:
    // reftype Regx of command.acr_my.nsdb prohibits copy
    acr_my(const acr_my&){ /*disallow copy constructor */}
    void operator =(const acr_my&){ /*disallow direct assignment */}
};

// Print back to string
void                 nsdb_Print(command::acr_my& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 nsdb_ReadStrptrMaybe(command::acr_my& parent, algo::strptr in) __attribute__((nothrow));

bool                 acr_my_ReadFieldMaybe(command::acr_my &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_my from attributes of ascii tuple TUPLE
bool                 acr_my_ReadTupleMaybe(command::acr_my &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_my_Init(command::acr_my& parent);
// print command-line args of command::acr_my to string  -- cprint:command.acr_my.Argv
void                 acr_my_PrintArgv(command::acr_my & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_my_ToCmdline(command::acr_my & row) __attribute__((nothrow));
algo::strptr         acr_my_GetAnon(command::acr_my &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  acr_my_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.acr_my_proc
struct acr_my_proc { // command.acr_my_proc: Subprocess: ACR <-> MariaDB adaptor
    algo::cstring     path;      //   "bin/acr_my"  path for executable
    command::acr_my   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_my_proc();
    ~acr_my_proc();
private:
    // reftype Exec of command.acr_my_proc.acr_my prohibits copy
    // value field command.acr_my_proc.cmd is not copiable
    acr_my_proc(const acr_my_proc&){ /*disallow copy constructor */}
    void operator =(const acr_my_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_my_Start(command::acr_my_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_my_StartRead(command::acr_my_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_my_Kill(command::acr_my_proc& parent);
// Wait for subprocess to return
void                 acr_my_Wait(command::acr_my_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_my_Exec(command::acr_my_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_my_ExecX(command::acr_my_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_my.Argv
int                  acr_my_Execv(command::acr_my_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_my_ToCmdline(command::acr_my_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_my_proc_Init(command::acr_my_proc& parent);
void                 acr_my_proc_Uninit(command::acr_my_proc& parent) __attribute__((nothrow));

// --- command.acr_proc
struct acr_proc { // command.acr_proc: Subprocess: Algo Cross-Reference - ssimfile database & update tool
    algo::cstring   path;      //   "bin/acr"  path for executable
    command::acr    cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    acr_proc();
    ~acr_proc();
private:
    // reftype Exec of command.acr_proc.acr prohibits copy
    // value field command.acr_proc.cmd is not copiable
    acr_proc(const acr_proc&){ /*disallow copy constructor */}
    void operator =(const acr_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_Start(command::acr_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_StartRead(command::acr_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_Kill(command::acr_proc& parent);
// Wait for subprocess to return
void                 acr_Wait(command::acr_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_Exec(command::acr_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_ExecX(command::acr_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr.Argv
int                  acr_Execv(command::acr_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_ToCmdline(command::acr_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_proc_Init(command::acr_proc& parent);
void                 acr_proc_Uninit(command::acr_proc& parent) __attribute__((nothrow));

// --- command.amc
// access: command.amc_proc.amc (Exec)
struct amc { // command.amc
    algo::cstring    in_dir;    //   "data"  Root of input ssim dir
    algo::cstring    query;     //   ""  Query mode: generate code for specified object
    algo::cstring    out_dir;   //   "."  Root of output cpp dir
    bool             proto;     //   false  Print prototype
    bool             report;    //   true  Final report
    bool             e;         //   false  Open matching records in editor
    algo_lib::Regx   trace;     //   ""  Sql Regx
    amc();
private:
    // reftype Regx of command.amc.trace prohibits copy
    amc(const amc&){ /*disallow copy constructor */}
    void operator =(const amc&){ /*disallow direct assignment */}
};

// Print back to string
void                 trace_Print(command::amc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 trace_ReadStrptrMaybe(command::amc& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_ReadFieldMaybe(command::amc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc from attributes of ascii tuple TUPLE
bool                 amc_ReadTupleMaybe(command::amc &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_Init(command::amc& parent);
// print command-line args of command::amc to string  -- cprint:command.amc.Argv
void                 amc_PrintArgv(command::amc & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_ToCmdline(command::amc & row) __attribute__((nothrow));
algo::strptr         amc_GetAnon(command::amc &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  amc_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.amc_dml
struct amc_dml { // command.amc_dml
    algo_lib::Regx   ns;       //   "%"  Sql Regx
    bool             fconst;   //   true  append fconst list at the end
    bool             gconst;   //   true  append gconst list at the end
    algo::cstring    in;       //   "data"  Input directory or filename, - for stdin
    amc_dml();
private:
    // reftype Regx of command.amc_dml.ns prohibits copy
    amc_dml(const amc_dml&){ /*disallow copy constructor */}
    void operator =(const amc_dml&){ /*disallow direct assignment */}
};

// Print back to string
void                 ns_Print(command::amc_dml& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ns_ReadStrptrMaybe(command::amc_dml& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_dml_ReadFieldMaybe(command::amc_dml &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc_dml from attributes of ascii tuple TUPLE
bool                 amc_dml_ReadTupleMaybe(command::amc_dml &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_dml_Init(command::amc_dml& parent);
// print command-line args of command::amc_dml to string  -- cprint:command.amc_dml.Argv
void                 amc_dml_PrintArgv(command::amc_dml & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_dml_ToCmdline(command::amc_dml & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  amc_dml_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.amc_gc
// access: command.amc_gc_proc.amc_gc (Exec)
struct amc_gc { // command.amc_gc
    algo_lib::Regx   target;    //   "%"  Sql Regx of dev::Target
    algo_lib::Regx   key;       //   ""  Sql Regx
    bool             include;   //   false  Garbage collect includes for specified target
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    amc_gc();
private:
    // reftype Regx of command.amc_gc.target prohibits copy
    // reftype Regx of command.amc_gc.key prohibits copy
    amc_gc(const amc_gc&){ /*disallow copy constructor */}
    void operator =(const amc_gc&){ /*disallow direct assignment */}
};

// Print back to string
void                 target_Print(command::amc_gc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 target_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 key_Print(command::amc_gc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 key_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_gc_ReadFieldMaybe(command::amc_gc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc_gc from attributes of ascii tuple TUPLE
bool                 amc_gc_ReadTupleMaybe(command::amc_gc &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_gc_Init(command::amc_gc& parent);
// print command-line args of command::amc_gc to string  -- cprint:command.amc_gc.Argv
void                 amc_gc_PrintArgv(command::amc_gc & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_gc_ToCmdline(command::amc_gc & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  amc_gc_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.amc_gc_proc
struct amc_gc_proc { // command.amc_gc_proc: Subprocess: Empirically eliminate unused records
    algo::cstring     path;      //   "bin/amc_gc"  path for executable
    command::amc_gc   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    amc_gc_proc();
    ~amc_gc_proc();
private:
    // reftype Exec of command.amc_gc_proc.amc_gc prohibits copy
    // value field command.amc_gc_proc.cmd is not copiable
    amc_gc_proc(const amc_gc_proc&){ /*disallow copy constructor */}
    void operator =(const amc_gc_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  amc_gc_Start(command::amc_gc_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         amc_gc_StartRead(command::amc_gc_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 amc_gc_Kill(command::amc_gc_proc& parent);
// Wait for subprocess to return
void                 amc_gc_Wait(command::amc_gc_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  amc_gc_Exec(command::amc_gc_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 amc_gc_ExecX(command::amc_gc_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:amc_gc.Argv
int                  amc_gc_Execv(command::amc_gc_proc& parent) __attribute__((nothrow));
algo::tempstr        amc_gc_ToCmdline(command::amc_gc_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 amc_gc_proc_Init(command::amc_gc_proc& parent);
void                 amc_gc_proc_Uninit(command::amc_gc_proc& parent) __attribute__((nothrow));

// --- command.amc_proc
struct amc_proc { // command.amc_proc: Subprocess: Algo Model Compiler: generate code under include/gen and cpp/gen
    algo::cstring   path;      //   "bin/amc"  path for executable
    command::amc    cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    amc_proc();
    ~amc_proc();
private:
    // reftype Exec of command.amc_proc.amc prohibits copy
    // value field command.amc_proc.cmd is not copiable
    amc_proc(const amc_proc&){ /*disallow copy constructor */}
    void operator =(const amc_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  amc_Start(command::amc_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         amc_StartRead(command::amc_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 amc_Kill(command::amc_proc& parent);
// Wait for subprocess to return
void                 amc_Wait(command::amc_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  amc_Exec(command::amc_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 amc_ExecX(command::amc_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:amc.Argv
int                  amc_Execv(command::amc_proc& parent) __attribute__((nothrow));
algo::tempstr        amc_ToCmdline(command::amc_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 amc_proc_Init(command::amc_proc& parent);
void                 amc_proc_Uninit(command::amc_proc& parent) __attribute__((nothrow));

// --- command.amc_vis
// access: command.amc_vis_proc.amc_vis (Exec)
struct amc_vis { // command.amc_vis
    algo_lib::Regx   ctype;     //   "%"  Sql Regx of dmmeta::Ctype
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo::cstring    dot;       //   ""  Save dot file with specified filename
    bool             xref;      //   false  Include all ctypes referenced by selected ones
    bool             xns;       //   false  Cross namespace boundaries
    bool             noinput;   //   false  Deselect module inputs
    bool             check;     //   false  Check model for dependency problems
    bool             render;    //   true  Produce an ascii drawing
    amc_vis();
private:
    // reftype Regx of command.amc_vis.ctype prohibits copy
    amc_vis(const amc_vis&){ /*disallow copy constructor */}
    void operator =(const amc_vis&){ /*disallow direct assignment */}
};

// Print back to string
void                 ctype_Print(command::amc_vis& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ctype_ReadStrptrMaybe(command::amc_vis& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_vis_ReadFieldMaybe(command::amc_vis &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc_vis from attributes of ascii tuple TUPLE
bool                 amc_vis_ReadTupleMaybe(command::amc_vis &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_vis_Init(command::amc_vis& parent);
// print command-line args of command::amc_vis to string  -- cprint:command.amc_vis.Argv
void                 amc_vis_PrintArgv(command::amc_vis & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_vis_ToCmdline(command::amc_vis & row) __attribute__((nothrow));
algo::strptr         amc_vis_GetAnon(command::amc_vis &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  amc_vis_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.amc_vis_proc
struct amc_vis_proc { // command.amc_vis_proc: Subprocess: amc: draw access path diagrams
    algo::cstring      path;      //   "bin/amc_vis"  path for executable
    command::amc_vis   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    amc_vis_proc();
    ~amc_vis_proc();
private:
    // reftype Exec of command.amc_vis_proc.amc_vis prohibits copy
    // value field command.amc_vis_proc.cmd is not copiable
    amc_vis_proc(const amc_vis_proc&){ /*disallow copy constructor */}
    void operator =(const amc_vis_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  amc_vis_Start(command::amc_vis_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         amc_vis_StartRead(command::amc_vis_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 amc_vis_Kill(command::amc_vis_proc& parent);
// Wait for subprocess to return
void                 amc_vis_Wait(command::amc_vis_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  amc_vis_Exec(command::amc_vis_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 amc_vis_ExecX(command::amc_vis_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:amc_vis.Argv
int                  amc_vis_Execv(command::amc_vis_proc& parent) __attribute__((nothrow));
algo::tempstr        amc_vis_ToCmdline(command::amc_vis_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 amc_vis_proc_Init(command::amc_vis_proc& parent);
void                 amc_vis_proc_Uninit(command::amc_vis_proc& parent) __attribute__((nothrow));

// --- command.ams_cat
// access: command.ams_cat_proc.ams_cat (Exec)
struct ams_cat { // command.ams_cat
    algo::cstring   in;   //   "data"  Input directory or filename, - for stdin
    ams_cat();
};

bool                 ams_cat_ReadFieldMaybe(command::ams_cat &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ams_cat from attributes of ascii tuple TUPLE
bool                 ams_cat_ReadTupleMaybe(command::ams_cat &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ams_cat_Init(command::ams_cat& parent);
// print command-line args of command::ams_cat to string  -- cprint:command.ams_cat.Argv
void                 ams_cat_PrintArgv(command::ams_cat & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ams_cat_ToCmdline(command::ams_cat & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  ams_cat_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.ams_cat_proc
struct ams_cat_proc { // command.ams_cat_proc: Subprocess: Algo Messaging System sample tool
    algo::cstring      path;      //   "bin/ams_cat"  path for executable
    command::ams_cat   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    ams_cat_proc();
    ~ams_cat_proc();
private:
    // reftype Exec of command.ams_cat_proc.ams_cat prohibits copy
    ams_cat_proc(const ams_cat_proc&){ /*disallow copy constructor */}
    void operator =(const ams_cat_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ams_cat_Start(command::ams_cat_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ams_cat_StartRead(command::ams_cat_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ams_cat_Kill(command::ams_cat_proc& parent);
// Wait for subprocess to return
void                 ams_cat_Wait(command::ams_cat_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ams_cat_Exec(command::ams_cat_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ams_cat_ExecX(command::ams_cat_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ams_cat.Argv
int                  ams_cat_Execv(command::ams_cat_proc& parent) __attribute__((nothrow));
algo::tempstr        ams_cat_ToCmdline(command::ams_cat_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ams_cat_proc_Init(command::ams_cat_proc& parent);
void                 ams_cat_proc_Uninit(command::ams_cat_proc& parent) __attribute__((nothrow));

// --- command.ams_sendtest
// access: command.ams_sendtest_proc.ams_sendtest (Exec)
struct ams_sendtest { // command.ams_sendtest
    algo::cstring    in;             //   "data"  Input directory or filename, - for stdin
    i32              id;             //   0  Process index (0=parent)
    algo::cstring    file_prefix;    //   ""  Use file_prefix
    i32              nchild;         //   1  Number of stream readers
    bool             blocking;       //   false  Use blocking send mode
    i32              nmsg;           //   1000  Number of messages to send/receive
    algo_lib::Regx   trace;          //   ""  Sql Regx
    i32              timeout;        //   30  Time limit for the send
    i64              recvdelay_ns;   //   0  Pause nanoseconds between messages
    i64              senddelay_ns;   //   0  Pause nanoseconds between messages
    i32              msgsize_min;    //   64  Minimum message length
    i32              msgsize_max;    //   1024  Maximum message length
    i32              bufsize;        //   32768  Shared memory buffer size
    i64              recvdelay;      //   0  Pause nanoseconds between messages
    ams_sendtest();
private:
    // reftype Regx of command.ams_sendtest.trace prohibits copy
    ams_sendtest(const ams_sendtest&){ /*disallow copy constructor */}
    void operator =(const ams_sendtest&){ /*disallow direct assignment */}
};

// Print back to string
void                 trace_Print(command::ams_sendtest& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 trace_ReadStrptrMaybe(command::ams_sendtest& parent, algo::strptr in) __attribute__((nothrow));

bool                 ams_sendtest_ReadFieldMaybe(command::ams_sendtest &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ams_sendtest from attributes of ascii tuple TUPLE
bool                 ams_sendtest_ReadTupleMaybe(command::ams_sendtest &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ams_sendtest_Init(command::ams_sendtest& parent);
// print command-line args of command::ams_sendtest to string  -- cprint:command.ams_sendtest.Argv
void                 ams_sendtest_PrintArgv(command::ams_sendtest & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ams_sendtest_ToCmdline(command::ams_sendtest & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  ams_sendtest_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.ams_sendtest_proc
struct ams_sendtest_proc { // command.ams_sendtest_proc: Subprocess: Algo Messaging System test tool
    algo::cstring           path;      //   "bin/ams_sendtest"  path for executable
    command::ams_sendtest   cmd;       // command line for child process
    algo::cstring           fstdin;    // redirect for stdin
    algo::cstring           fstdout;   // redirect for stdout
    algo::cstring           fstderr;   // redirect for stderr
    pid_t                   pid;       //   0  pid of running child process
    i32                     timeout;   //   0  optional timeout for child process
    i32                     status;    //   0  last exit status of child process
    ams_sendtest_proc();
    ~ams_sendtest_proc();
private:
    // reftype Exec of command.ams_sendtest_proc.ams_sendtest prohibits copy
    // value field command.ams_sendtest_proc.cmd is not copiable
    ams_sendtest_proc(const ams_sendtest_proc&){ /*disallow copy constructor */}
    void operator =(const ams_sendtest_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ams_sendtest_Start(command::ams_sendtest_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ams_sendtest_StartRead(command::ams_sendtest_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ams_sendtest_Kill(command::ams_sendtest_proc& parent);
// Wait for subprocess to return
void                 ams_sendtest_Wait(command::ams_sendtest_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ams_sendtest_Exec(command::ams_sendtest_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ams_sendtest_ExecX(command::ams_sendtest_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ams_sendtest.Argv
int                  ams_sendtest_Execv(command::ams_sendtest_proc& parent) __attribute__((nothrow));
algo::tempstr        ams_sendtest_ToCmdline(command::ams_sendtest_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ams_sendtest_proc_Init(command::ams_sendtest_proc& parent);
void                 ams_sendtest_proc_Uninit(command::ams_sendtest_proc& parent) __attribute__((nothrow));

// --- command.atf_amc
// access: command.atf_amc_proc.atf_amc (Exec)
struct atf_amc { // command.atf_amc
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   amctest;   //   "%"  Sql Regx of atfdb::Amctest
    bool             dofork;    //   true  Use fork
    bool             q;         //   false  Quiet mode
    atf_amc();
private:
    // reftype Regx of command.atf_amc.amctest prohibits copy
    atf_amc(const atf_amc&){ /*disallow copy constructor */}
    void operator =(const atf_amc&){ /*disallow direct assignment */}
};

// Print back to string
void                 amctest_Print(command::atf_amc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 amctest_ReadStrptrMaybe(command::atf_amc& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_amc_ReadFieldMaybe(command::atf_amc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_amc from attributes of ascii tuple TUPLE
bool                 atf_amc_ReadTupleMaybe(command::atf_amc &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_amc_Init(command::atf_amc& parent);
// print command-line args of command::atf_amc to string  -- cprint:command.atf_amc.Argv
void                 atf_amc_PrintArgv(command::atf_amc & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_amc_ToCmdline(command::atf_amc & row) __attribute__((nothrow));
algo::strptr         atf_amc_GetAnon(command::atf_amc &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_amc_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_amc_proc
struct atf_amc_proc { // command.atf_amc_proc: Subprocess: Unit tests for amc (see amctest table)
    algo::cstring      path;      //   "bin/atf_amc"  path for executable
    command::atf_amc   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    atf_amc_proc();
    ~atf_amc_proc();
private:
    // reftype Exec of command.atf_amc_proc.atf_amc prohibits copy
    // value field command.atf_amc_proc.cmd is not copiable
    atf_amc_proc(const atf_amc_proc&){ /*disallow copy constructor */}
    void operator =(const atf_amc_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_amc_Start(command::atf_amc_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_amc_StartRead(command::atf_amc_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_amc_Kill(command::atf_amc_proc& parent);
// Wait for subprocess to return
void                 atf_amc_Wait(command::atf_amc_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_amc_Exec(command::atf_amc_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_amc_ExecX(command::atf_amc_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_amc.Argv
int                  atf_amc_Execv(command::atf_amc_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_amc_ToCmdline(command::atf_amc_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_amc_proc_Init(command::atf_amc_proc& parent);
void                 atf_amc_proc_Uninit(command::atf_amc_proc& parent) __attribute__((nothrow));

// --- command.atf_ci
// access: command.atf_ci_proc.atf_ci (Exec)
struct atf_ci { // command.atf_ci
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   citest;    //   "%"  Sql Regx of atfdb::Citest
    i32              maxerr;    //   0  Exit after this many errors
    algo_lib::Regx   cijob;     //   "%"  Sql Regx of atfdb::Cijob
    bool             capture;   //   false  Capture the output of the test
    atf_ci();
private:
    // reftype Regx of command.atf_ci.citest prohibits copy
    // reftype Regx of command.atf_ci.cijob prohibits copy
    atf_ci(const atf_ci&){ /*disallow copy constructor */}
    void operator =(const atf_ci&){ /*disallow direct assignment */}
};

// Print back to string
void                 citest_Print(command::atf_ci& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 citest_ReadStrptrMaybe(command::atf_ci& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 cijob_Print(command::atf_ci& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 cijob_ReadStrptrMaybe(command::atf_ci& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_ci_ReadFieldMaybe(command::atf_ci &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_ci from attributes of ascii tuple TUPLE
bool                 atf_ci_ReadTupleMaybe(command::atf_ci &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_ci_Init(command::atf_ci& parent);
// print command-line args of command::atf_ci to string  -- cprint:command.atf_ci.Argv
void                 atf_ci_PrintArgv(command::atf_ci & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_ci_ToCmdline(command::atf_ci & row) __attribute__((nothrow));
algo::strptr         atf_ci_GetAnon(command::atf_ci &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_ci_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_ci_proc
struct atf_ci_proc { // command.atf_ci_proc: Subprocess: Normalization tests (see citest table)
    algo::cstring     path;      //   "bin/atf_ci"  path for executable
    command::atf_ci   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    atf_ci_proc();
    ~atf_ci_proc();
private:
    // reftype Exec of command.atf_ci_proc.atf_ci prohibits copy
    // value field command.atf_ci_proc.cmd is not copiable
    atf_ci_proc(const atf_ci_proc&){ /*disallow copy constructor */}
    void operator =(const atf_ci_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_ci_Start(command::atf_ci_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_ci_StartRead(command::atf_ci_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_ci_Kill(command::atf_ci_proc& parent);
// Wait for subprocess to return
void                 atf_ci_Wait(command::atf_ci_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_ci_Exec(command::atf_ci_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_ci_ExecX(command::atf_ci_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_ci.Argv
int                  atf_ci_Execv(command::atf_ci_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_ci_ToCmdline(command::atf_ci_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_ci_proc_Init(command::atf_ci_proc& parent);
void                 atf_ci_proc_Uninit(command::atf_ci_proc& parent) __attribute__((nothrow));

// --- command.atf_cmdline
// access: command.atf_cmdline_proc.atf_cmdline (Exec)
struct atf_cmdline { // command.atf_cmdline: Command line for atf_amc_cmd
    algo::cstring      in;            //   "data"  Input directory or filename, - for stdin
    bool               exec;          //   false  Execv itself
    algo::cstring      astr;          // Required anon string
    i32                anum;          //   0  Anon number
    double             adbl;          //   0.0  Anon double
    bool               aflag;         //   false  Anon flag
    algo::cstring      str;           // Required string
    i32                num;           //   0  Required Number
    double             dbl;           //   0.0  Required double
    bool               flag;          //   false  Required flag
    algo::cstring      dstr;          //   "blah"  Predefined string
    i32                dnum;          //   -33  Predefined number
    double             ddbl;          //   0.0001  Predefined double
    bool               dflag;         //   true  Predefined flag
    algo::cstring*     mstr_elems;    // pointer to elements
    u32                mstr_n;        // number of elements in array
    u32                mstr_max;      // max. capacity of array before realloc
    i32*               mnum_elems;    // pointer to elements
    u32                mnum_n;        // number of elements in array
    u32                mnum_max;      // max. capacity of array before realloc
    double*            mdbl_elems;    // pointer to elements
    u32                mdbl_n;        // number of elements in array
    u32                mdbl_max;      // max. capacity of array before realloc
    i32*               amnum_elems;   // pointer to elements
    u32                amnum_n;       // number of elements in array
    u32                amnum_max;     // max. capacity of array before realloc
    u8                 fconst;        //   0  Fconst for field
    algo::Month        cconst;        // Fconst for arg ctype
    algo_lib::Regx     dregx;         //   "%"  Sql Regx of dmmeta::Ctype
    algo::Smallstr50   dpkey;         //   ""  Predefined pkey
    atf_cmdline();
    ~atf_cmdline();
private:
    // reftype Tary of command.atf_cmdline.mstr prohibits copy
    // reftype Tary of command.atf_cmdline.mnum prohibits copy
    // reftype Tary of command.atf_cmdline.mdbl prohibits copy
    // ... and several other reasons
    atf_cmdline(const atf_cmdline&){ /*disallow copy constructor */}
    void operator =(const atf_cmdline&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       mstr_Alloc(command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       mstr_AllocAt(command::atf_cmdline& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> mstr_AllocN(command::atf_cmdline& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mstr_EmptyQ(command::atf_cmdline& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       mstr_Find(command::atf_cmdline& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> mstr_Getary(command::atf_cmdline& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       mstr_Last(command::atf_cmdline& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  mstr_Max(command::atf_cmdline& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  mstr_N(const command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 mstr_Remove(command::atf_cmdline& parent, u32 i) __attribute__((nothrow));
void                 mstr_RemoveAll(command::atf_cmdline& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mstr_RemoveLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 mstr_Reserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 mstr_AbsReserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 mstr_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       mstr_qFind(command::atf_cmdline& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       mstr_qLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  mstr_rowid_Get(command::atf_cmdline& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> mstr_AllocNVal(command::atf_cmdline& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 mstr_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32&                 mnum_Alloc(command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32&                 mnum_AllocAt(command::atf_cmdline& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    mnum_AllocN(command::atf_cmdline& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mnum_EmptyQ(command::atf_cmdline& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
i32*                 mnum_Find(command::atf_cmdline& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<i32>    mnum_Getary(command::atf_cmdline& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
i32*                 mnum_Last(command::atf_cmdline& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  mnum_Max(command::atf_cmdline& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  mnum_N(const command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 mnum_Remove(command::atf_cmdline& parent, u32 i) __attribute__((nothrow));
void                 mnum_RemoveAll(command::atf_cmdline& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mnum_RemoveLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 mnum_Reserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 mnum_AbsReserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 mnum_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
i32&                 mnum_qFind(command::atf_cmdline& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
i32&                 mnum_qLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  mnum_rowid_Get(command::atf_cmdline& parent, i32 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    mnum_AllocNVal(command::atf_cmdline& parent, int n_elems, const i32& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 mnum_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
double&              mdbl_Alloc(command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
double&              mdbl_AllocAt(command::atf_cmdline& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<double> mdbl_AllocN(command::atf_cmdline& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mdbl_EmptyQ(command::atf_cmdline& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
double*              mdbl_Find(command::atf_cmdline& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<double> mdbl_Getary(command::atf_cmdline& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
double*              mdbl_Last(command::atf_cmdline& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  mdbl_Max(command::atf_cmdline& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  mdbl_N(const command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 mdbl_Remove(command::atf_cmdline& parent, u32 i) __attribute__((nothrow));
void                 mdbl_RemoveAll(command::atf_cmdline& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mdbl_RemoveLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 mdbl_Reserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 mdbl_AbsReserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 mdbl_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
double&              mdbl_qFind(command::atf_cmdline& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
double&              mdbl_qLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  mdbl_rowid_Get(command::atf_cmdline& parent, double &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<double> mdbl_AllocNVal(command::atf_cmdline& parent, int n_elems, const double& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 mdbl_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32&                 amnum_Alloc(command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32&                 amnum_AllocAt(command::atf_cmdline& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    amnum_AllocN(command::atf_cmdline& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 amnum_EmptyQ(command::atf_cmdline& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
i32*                 amnum_Find(command::atf_cmdline& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<i32>    amnum_Getary(command::atf_cmdline& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
i32*                 amnum_Last(command::atf_cmdline& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  amnum_Max(command::atf_cmdline& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  amnum_N(const command::atf_cmdline& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 amnum_Remove(command::atf_cmdline& parent, u32 i) __attribute__((nothrow));
void                 amnum_RemoveAll(command::atf_cmdline& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 amnum_RemoveLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 amnum_Reserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 amnum_AbsReserve(command::atf_cmdline& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 amnum_Setary(command::atf_cmdline& parent, command::atf_cmdline &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
i32&                 amnum_qFind(command::atf_cmdline& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
i32&                 amnum_qLast(command::atf_cmdline& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  amnum_rowid_Get(command::atf_cmdline& parent, i32 &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    amnum_AllocNVal(command::atf_cmdline& parent, int n_elems, const i32& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 amnum_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in_str) __attribute__((nothrow));

// Get value of field as enum type
command_atf_cmdline_fconst_Enum fconst_GetEnum(const command::atf_cmdline& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 fconst_SetEnum(command::atf_cmdline& parent, command_atf_cmdline_fconst_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          fconst_ToCstr(const command::atf_cmdline& parent) __attribute__((nothrow));
// Convert fconst to a string. First, attempt conversion to a known string.
// If no string matches, print fconst as a numeric value.
void                 fconst_Print(const command::atf_cmdline& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 fconst_SetStrptrMaybe(command::atf_cmdline& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 fconst_SetStrptr(command::atf_cmdline& parent, algo::strptr rhs, command_atf_cmdline_fconst_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 fconst_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr rhs) __attribute__((nothrow));

// Print back to string
void                 dregx_Print(command::atf_cmdline& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 dregx_ReadStrptrMaybe(command::atf_cmdline& parent, algo::strptr in) __attribute__((nothrow));

// proceed to next item
void                 atf_cmdline_mstr_curs_Next(atf_cmdline_mstr_curs &curs);
void                 atf_cmdline_mstr_curs_Reset(atf_cmdline_mstr_curs &curs, command::atf_cmdline &parent);
// cursor points to valid item
bool                 atf_cmdline_mstr_curs_ValidQ(atf_cmdline_mstr_curs &curs);
// item access
algo::cstring&       atf_cmdline_mstr_curs_Access(atf_cmdline_mstr_curs &curs);
// proceed to next item
void                 atf_cmdline_mnum_curs_Next(atf_cmdline_mnum_curs &curs);
void                 atf_cmdline_mnum_curs_Reset(atf_cmdline_mnum_curs &curs, command::atf_cmdline &parent);
// cursor points to valid item
bool                 atf_cmdline_mnum_curs_ValidQ(atf_cmdline_mnum_curs &curs);
// item access
i32&                 atf_cmdline_mnum_curs_Access(atf_cmdline_mnum_curs &curs);
// proceed to next item
void                 atf_cmdline_mdbl_curs_Next(atf_cmdline_mdbl_curs &curs);
void                 atf_cmdline_mdbl_curs_Reset(atf_cmdline_mdbl_curs &curs, command::atf_cmdline &parent);
// cursor points to valid item
bool                 atf_cmdline_mdbl_curs_ValidQ(atf_cmdline_mdbl_curs &curs);
// item access
double&              atf_cmdline_mdbl_curs_Access(atf_cmdline_mdbl_curs &curs);
// proceed to next item
void                 atf_cmdline_amnum_curs_Next(atf_cmdline_amnum_curs &curs);
void                 atf_cmdline_amnum_curs_Reset(atf_cmdline_amnum_curs &curs, command::atf_cmdline &parent);
// cursor points to valid item
bool                 atf_cmdline_amnum_curs_ValidQ(atf_cmdline_amnum_curs &curs);
// item access
i32&                 atf_cmdline_amnum_curs_Access(atf_cmdline_amnum_curs &curs);
bool                 atf_cmdline_ReadFieldMaybe(command::atf_cmdline &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_cmdline from attributes of ascii tuple TUPLE
bool                 atf_cmdline_ReadTupleMaybe(command::atf_cmdline &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_cmdline_Init(command::atf_cmdline& parent);
void                 atf_cmdline_Uninit(command::atf_cmdline& parent) __attribute__((nothrow));
// print command-line args of command::atf_cmdline to string  -- cprint:command.atf_cmdline.Argv
void                 atf_cmdline_PrintArgv(command::atf_cmdline & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_cmdline_ToCmdline(command::atf_cmdline & row) __attribute__((nothrow));
algo::strptr         atf_cmdline_GetAnon(command::atf_cmdline &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_cmdline_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_cmdline_proc
struct atf_cmdline_proc { // command.atf_cmdline_proc: Subprocess: Test tool for command line parsing
    algo::cstring          path;      //   "bin/atf_cmdline"  path for executable
    command::atf_cmdline   cmd;       // command line for child process
    algo::cstring          fstdin;    // redirect for stdin
    algo::cstring          fstdout;   // redirect for stdout
    algo::cstring          fstderr;   // redirect for stderr
    pid_t                  pid;       //   0  pid of running child process
    i32                    timeout;   //   0  optional timeout for child process
    i32                    status;    //   0  last exit status of child process
    atf_cmdline_proc();
    ~atf_cmdline_proc();
private:
    // reftype Exec of command.atf_cmdline_proc.atf_cmdline prohibits copy
    // value field command.atf_cmdline_proc.cmd is not copiable
    atf_cmdline_proc(const atf_cmdline_proc&){ /*disallow copy constructor */}
    void operator =(const atf_cmdline_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_cmdline_Start(command::atf_cmdline_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_cmdline_StartRead(command::atf_cmdline_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_cmdline_Kill(command::atf_cmdline_proc& parent);
// Wait for subprocess to return
void                 atf_cmdline_Wait(command::atf_cmdline_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_cmdline_Exec(command::atf_cmdline_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_cmdline_ExecX(command::atf_cmdline_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_cmdline.Argv
int                  atf_cmdline_Execv(command::atf_cmdline_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_cmdline_ToCmdline(command::atf_cmdline_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_cmdline_proc_Init(command::atf_cmdline_proc& parent);
void                 atf_cmdline_proc_Uninit(command::atf_cmdline_proc& parent) __attribute__((nothrow));

// --- command.atf_comp
// access: command.atf_comp_proc.atf_comp (Exec)
struct atf_comp { // command.atf_comp
    algo::cstring      in;                //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx     comptest;          //   "%"  Sql Regx of atfdb::Comptest
    bool               mdbg;              //   false  (action) Run component test under debugger
    bool               run;               //   true  (action) Run selected component tests
    bool               capture;           //   false  (action) Re-capture test results
    bool               print;             //   false  (action) Print testcase
    bool               printinput;        //   false  (action) Print input of test case
    bool               e;                 //   false  (action) Open selected testcases in an editor
    bool               normalize;         //   false  (action) Renumber and normalize tmsgs
    bool               covcapture;        //   false  (action) Capture new coverage percentages and save back
    bool               covcheck;          //   false  (action) Check coverage percentages against tgtcov table
    algo::cstring      compdir;           //   ""  Component image directory (exe)
    algo::Smallstr50   cfg;               //   "release"  Set config
    bool               check_untracked;   //   true  Check for untracked file before allowing test to run
    i32                maxerr;            //   1  Exit after this many errors
    bool               build;             //   false  Build given cfg before test
    bool               ood;               //   false  Check given cfg for ood before test
    bool               memcheck;          //   false  Run under memory checker (valgrind)
    bool               force;             //   false  (With -memcheck) run suppressed memcheck
    bool               callgrind;         //   false  Run under callgrind profiler (valgrind)
    i32                maxjobs;           //   1  Maximum number of tests run in parallel
    bool               stream;            //   false  prints component's output
    bool               i;                 //   false  Read and execute testcase from stdin
    bool               write;             //   true  (implied with -e) Write any changes back to ssim tables
    bool               report;            //   false  Print final report
    algo::cstring      b;                 //   ""  Breakpoint passed to mdbg as-is
    atf_comp();
private:
    // reftype Regx of command.atf_comp.comptest prohibits copy
    atf_comp(const atf_comp&){ /*disallow copy constructor */}
    void operator =(const atf_comp&){ /*disallow direct assignment */}
};

// Print back to string
void                 comptest_Print(command::atf_comp& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 comptest_ReadStrptrMaybe(command::atf_comp& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_comp_ReadFieldMaybe(command::atf_comp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_comp from attributes of ascii tuple TUPLE
bool                 atf_comp_ReadTupleMaybe(command::atf_comp &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_comp_Init(command::atf_comp& parent);
// print command-line args of command::atf_comp to string  -- cprint:command.atf_comp.Argv
void                 atf_comp_PrintArgv(command::atf_comp & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_comp_ToCmdline(command::atf_comp & row) __attribute__((nothrow));
algo::strptr         atf_comp_GetAnon(command::atf_comp &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_comp_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_comp_proc
struct atf_comp_proc { // command.atf_comp_proc: Subprocess: Algo Test Framework - Component test execution
    algo::cstring       path;      //   "bin/atf_comp"  path for executable
    command::atf_comp   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_comp_proc();
    ~atf_comp_proc();
private:
    // reftype Exec of command.atf_comp_proc.atf_comp prohibits copy
    // value field command.atf_comp_proc.cmd is not copiable
    atf_comp_proc(const atf_comp_proc&){ /*disallow copy constructor */}
    void operator =(const atf_comp_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_comp_Start(command::atf_comp_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_comp_StartRead(command::atf_comp_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_comp_Kill(command::atf_comp_proc& parent);
// Wait for subprocess to return
void                 atf_comp_Wait(command::atf_comp_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_comp_Exec(command::atf_comp_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_comp_ExecX(command::atf_comp_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_comp.Argv
int                  atf_comp_Execv(command::atf_comp_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_comp_ToCmdline(command::atf_comp_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_comp_proc_Init(command::atf_comp_proc& parent);
void                 atf_comp_proc_Uninit(command::atf_comp_proc& parent) __attribute__((nothrow));

// --- command.atf_cov
// access: command.atf_cov_proc.atf_cov (Exec)
struct atf_cov { // command.atf_cov
    algo::cstring    in;          //   "data"  Input directory or filename, - for stdin
    algo::cstring    covdir;      //   "temp/covdata"  Output directory to save coverage data
    algo::cstring    logfile;     //   ""  Log file
    algo::cstring    runcmd;      //   ""  command to run
    algo_lib::Regx   exclude;     //   "(extern|include/gen|cpp/gen)/%"  Sql Regx of dev::Gitfile
    algo::cstring    mergepath;   //   ""  colon-separated dir list to load .cov.ssim files from
    bool             gcov;        //   false  run gcov
    bool             ssim;        //   false  write out ssim files
    bool             report;      //   false  write out all reports
    bool             capture;     //   false  Write coverage information into tgtcov table
    bool             xmlpretty;   //   false  Generate pretty-formatted XML
    bool             summary;     //   true  Show summary figures
    bool             check;       //   false  Check coverage information against tgtcov table
    atf_cov();
private:
    // reftype Regx of command.atf_cov.exclude prohibits copy
    atf_cov(const atf_cov&){ /*disallow copy constructor */}
    void operator =(const atf_cov&){ /*disallow direct assignment */}
};

// Print back to string
void                 exclude_Print(command::atf_cov& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 exclude_ReadStrptrMaybe(command::atf_cov& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_cov_ReadFieldMaybe(command::atf_cov &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_cov from attributes of ascii tuple TUPLE
bool                 atf_cov_ReadTupleMaybe(command::atf_cov &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_cov_Init(command::atf_cov& parent);
// print command-line args of command::atf_cov to string  -- cprint:command.atf_cov.Argv
void                 atf_cov_PrintArgv(command::atf_cov & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_cov_ToCmdline(command::atf_cov & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_cov_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_cov_proc
struct atf_cov_proc { // command.atf_cov_proc: Subprocess: Line coverage
    algo::cstring      path;      //   "bin/atf_cov"  path for executable
    command::atf_cov   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    atf_cov_proc();
    ~atf_cov_proc();
private:
    // reftype Exec of command.atf_cov_proc.atf_cov prohibits copy
    // value field command.atf_cov_proc.cmd is not copiable
    atf_cov_proc(const atf_cov_proc&){ /*disallow copy constructor */}
    void operator =(const atf_cov_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_cov_Start(command::atf_cov_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_cov_StartRead(command::atf_cov_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_cov_Kill(command::atf_cov_proc& parent);
// Wait for subprocess to return
void                 atf_cov_Wait(command::atf_cov_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_cov_Exec(command::atf_cov_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_cov_ExecX(command::atf_cov_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_cov.Argv
int                  atf_cov_Execv(command::atf_cov_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_cov_ToCmdline(command::atf_cov_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_cov_proc_Init(command::atf_cov_proc& parent);
void                 atf_cov_proc_Uninit(command::atf_cov_proc& parent) __attribute__((nothrow));

// --- command.atf_fuzz
// access: command.atf_fuzz_proc.atf_fuzz (Exec)
struct atf_fuzz { // command.atf_fuzz
    algo::cstring      reprofile;   //   "temp/atf_fuzz.repro"  File where repros are stored
    algo::Smallstr16   target;      //   ""  Target to fuzz
    algo::cstring      args;        //   ""  Additional arguments to target
    algo::cstring      inputfile;   //   ""  File with input tuples.
    algo_lib::Regx     fuzzstrat;   //   "%"  Sql Regx of atfdb::Fuzzstrat
    algo::cstring      in;          //   "data"  Input directory or filename, - for stdin
    i32                seed;        //   0  Random seed
    double             testprob;    //   1  Run each case with this probability
    atf_fuzz();
private:
    // reftype Regx of command.atf_fuzz.fuzzstrat prohibits copy
    atf_fuzz(const atf_fuzz&){ /*disallow copy constructor */}
    void operator =(const atf_fuzz&){ /*disallow direct assignment */}
};

// Print back to string
void                 fuzzstrat_Print(command::atf_fuzz& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 fuzzstrat_ReadStrptrMaybe(command::atf_fuzz& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_fuzz_ReadFieldMaybe(command::atf_fuzz &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_fuzz from attributes of ascii tuple TUPLE
bool                 atf_fuzz_ReadTupleMaybe(command::atf_fuzz &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_fuzz_Init(command::atf_fuzz& parent);
// print command-line args of command::atf_fuzz to string  -- cprint:command.atf_fuzz.Argv
void                 atf_fuzz_PrintArgv(command::atf_fuzz & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_fuzz_ToCmdline(command::atf_fuzz & row) __attribute__((nothrow));
algo::strptr         atf_fuzz_GetAnon(command::atf_fuzz &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_fuzz_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_fuzz_proc
struct atf_fuzz_proc { // command.atf_fuzz_proc: Subprocess: Generator of bad inputs for targets
    algo::cstring       path;      //   "bin/atf_fuzz"  path for executable
    command::atf_fuzz   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_fuzz_proc();
    ~atf_fuzz_proc();
private:
    // reftype Exec of command.atf_fuzz_proc.atf_fuzz prohibits copy
    // value field command.atf_fuzz_proc.cmd is not copiable
    atf_fuzz_proc(const atf_fuzz_proc&){ /*disallow copy constructor */}
    void operator =(const atf_fuzz_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_fuzz_Start(command::atf_fuzz_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_fuzz_StartRead(command::atf_fuzz_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_fuzz_Kill(command::atf_fuzz_proc& parent);
// Wait for subprocess to return
void                 atf_fuzz_Wait(command::atf_fuzz_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_fuzz_Exec(command::atf_fuzz_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_fuzz_ExecX(command::atf_fuzz_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_fuzz.Argv
int                  atf_fuzz_Execv(command::atf_fuzz_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_fuzz_ToCmdline(command::atf_fuzz_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_fuzz_proc_Init(command::atf_fuzz_proc& parent);
void                 atf_fuzz_proc_Uninit(command::atf_fuzz_proc& parent) __attribute__((nothrow));

// --- command.atf_gcli
// access: command.atf_gcli_proc.atf_gcli (Exec)
struct atf_gcli { // command.atf_gcli
    algo::cstring    in;              //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   gtblacttst;      //   "%"  Sql Regx of gclidb::Gtblacttst
    algo::cstring    id;              //   ""  Use this issue for $ISSUE substitutions
    algo::cstring    mr;              //   ""  Use this issue for $MR substitutions
    algo::cstring    note;            //   ""  Use this issue for $NOTE substitutions
    bool             capture;         //   false  Capture test command output into gverbtout
    bool             skip_init;       //   false  Skip setting local files - already set
    bool             skip_git_init;   //   false  Skip setting local files - already set
    bool             dry_run;         //   false  Print actions, do not perform
    atf_gcli();
private:
    // reftype Regx of command.atf_gcli.gtblacttst prohibits copy
    atf_gcli(const atf_gcli&){ /*disallow copy constructor */}
    void operator =(const atf_gcli&){ /*disallow direct assignment */}
};

// Print back to string
void                 gtblacttst_Print(command::atf_gcli& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 gtblacttst_ReadStrptrMaybe(command::atf_gcli& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_gcli_ReadFieldMaybe(command::atf_gcli &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_gcli from attributes of ascii tuple TUPLE
bool                 atf_gcli_ReadTupleMaybe(command::atf_gcli &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_gcli_Init(command::atf_gcli& parent);
// print command-line args of command::atf_gcli to string  -- cprint:command.atf_gcli.Argv
void                 atf_gcli_PrintArgv(command::atf_gcli & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_gcli_ToCmdline(command::atf_gcli & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_gcli_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_gcli_proc
struct atf_gcli_proc { // command.atf_gcli_proc: Subprocess: test harness for gcli
    algo::cstring       path;      //   "bin/atf_gcli"  path for executable
    command::atf_gcli   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_gcli_proc();
    ~atf_gcli_proc();
private:
    // reftype Exec of command.atf_gcli_proc.atf_gcli prohibits copy
    // value field command.atf_gcli_proc.cmd is not copiable
    atf_gcli_proc(const atf_gcli_proc&){ /*disallow copy constructor */}
    void operator =(const atf_gcli_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_gcli_Start(command::atf_gcli_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_gcli_StartRead(command::atf_gcli_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_gcli_Kill(command::atf_gcli_proc& parent);
// Wait for subprocess to return
void                 atf_gcli_Wait(command::atf_gcli_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_gcli_Exec(command::atf_gcli_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_gcli_ExecX(command::atf_gcli_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_gcli.Argv
int                  atf_gcli_Execv(command::atf_gcli_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_gcli_ToCmdline(command::atf_gcli_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_gcli_proc_Init(command::atf_gcli_proc& parent);
void                 atf_gcli_proc_Uninit(command::atf_gcli_proc& parent) __attribute__((nothrow));

// --- command.atf_nrun
// access: command.atf_nrun_proc.atf_nrun (Exec)
struct atf_nrun { // command.atf_nrun
    algo::cstring   in;        //   "data"  Input directory or filename, - for stdin
    i32             maxjobs;   //   2  Number of simultaneous jobs
    i32             ncmd;      //   6
    atf_nrun();
};

bool                 atf_nrun_ReadFieldMaybe(command::atf_nrun &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_nrun from attributes of ascii tuple TUPLE
bool                 atf_nrun_ReadTupleMaybe(command::atf_nrun &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_nrun_Init(command::atf_nrun& parent);
// print command-line args of command::atf_nrun to string  -- cprint:command.atf_nrun.Argv
void                 atf_nrun_PrintArgv(command::atf_nrun & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_nrun_ToCmdline(command::atf_nrun & row) __attribute__((nothrow));
algo::strptr         atf_nrun_GetAnon(command::atf_nrun &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_nrun_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_nrun_proc
struct atf_nrun_proc { // command.atf_nrun_proc: Subprocess: Run N subprocesses in parallel
    algo::cstring       path;      //   "bin/atf_nrun"  path for executable
    command::atf_nrun   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_nrun_proc();
    ~atf_nrun_proc();
private:
    // reftype Exec of command.atf_nrun_proc.atf_nrun prohibits copy
    atf_nrun_proc(const atf_nrun_proc&){ /*disallow copy constructor */}
    void operator =(const atf_nrun_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_nrun_Start(command::atf_nrun_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_nrun_StartRead(command::atf_nrun_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_nrun_Kill(command::atf_nrun_proc& parent);
// Wait for subprocess to return
void                 atf_nrun_Wait(command::atf_nrun_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_nrun_Exec(command::atf_nrun_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_nrun_ExecX(command::atf_nrun_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_nrun.Argv
int                  atf_nrun_Execv(command::atf_nrun_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_nrun_ToCmdline(command::atf_nrun_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_nrun_proc_Init(command::atf_nrun_proc& parent);
void                 atf_nrun_proc_Uninit(command::atf_nrun_proc& parent) __attribute__((nothrow));

// --- command.atf_unit
// access: command.atf_unit_proc.atf_unit (Exec)
struct atf_unit { // command.atf_unit
    algo_lib::Regx   unittest;          //   "%"  Sql Regx of atfdb::Unittest
    bool             nofork;            //   false  Do not fork for destructive tests
    algo::cstring    arg;               //   ""  Argument to pass to tool
    algo::cstring    data_dir;          //   "data"  Data directory
    bool             mdbg;              //   0  Break at testcase in debugger
    double           perf_secs;         //   1.0  # Of seconds to run perf tests for
    u32              pertest_timeout;   //   900  Max runtime of any individual unit test
    bool             report;            //   true  Print final report
    bool             capture;           //   false  Re-capture test results
    bool             check_untracked;   //   true  Check for untracked file before allowing test to run
    atf_unit();
private:
    // reftype Regx of command.atf_unit.unittest prohibits copy
    atf_unit(const atf_unit&){ /*disallow copy constructor */}
    void operator =(const atf_unit&){ /*disallow direct assignment */}
};

// Print back to string
void                 unittest_Print(command::atf_unit& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 unittest_ReadStrptrMaybe(command::atf_unit& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_unit_ReadFieldMaybe(command::atf_unit &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_unit from attributes of ascii tuple TUPLE
bool                 atf_unit_ReadTupleMaybe(command::atf_unit &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_unit_Init(command::atf_unit& parent);
// print command-line args of command::atf_unit to string  -- cprint:command.atf_unit.Argv
void                 atf_unit_PrintArgv(command::atf_unit & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_unit_ToCmdline(command::atf_unit & row) __attribute__((nothrow));
algo::strptr         atf_unit_GetAnon(command::atf_unit &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  atf_unit_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.atf_unit_proc
struct atf_unit_proc { // command.atf_unit_proc: Subprocess: Unit tests (see unittest table)
    algo::cstring       path;      //   "bin/atf_unit"  path for executable
    command::atf_unit   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_unit_proc();
    ~atf_unit_proc();
private:
    // reftype Exec of command.atf_unit_proc.atf_unit prohibits copy
    // value field command.atf_unit_proc.cmd is not copiable
    atf_unit_proc(const atf_unit_proc&){ /*disallow copy constructor */}
    void operator =(const atf_unit_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_unit_Start(command::atf_unit_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_unit_StartRead(command::atf_unit_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_unit_Kill(command::atf_unit_proc& parent);
// Wait for subprocess to return
void                 atf_unit_Wait(command::atf_unit_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_unit_Exec(command::atf_unit_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_unit_ExecX(command::atf_unit_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_unit.Argv
int                  atf_unit_Execv(command::atf_unit_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_unit_ToCmdline(command::atf_unit_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_unit_proc_Init(command::atf_unit_proc& parent);
void                 atf_unit_proc_Uninit(command::atf_unit_proc& parent) __attribute__((nothrow));

// --- command.bash
// access: command.bash_proc.bash (Exec)
struct bash { // command.bash: One way of invoking the shell
    algo::cstring   c;   //   ""  Shell command to execute
    bash();
};

// Set all fields to initial values.
void                 bash_Init(command::bash& parent);
// print command-line args of command::bash to string  -- cprint:command.bash.Argv
void                 bash_PrintArgv(command::bash & row, algo::cstring &str) __attribute__((nothrow));

// --- command.bash2html
// access: command.bash2html_proc.bash2html (Exec)
struct bash2html { // command.bash2html
    algo::cstring   in;     //   "data"  Input directory or filename, - for stdin
    bool            test;   //   false  Produce Test Output
    bash2html();
};

bool                 bash2html_ReadFieldMaybe(command::bash2html &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::bash2html from attributes of ascii tuple TUPLE
bool                 bash2html_ReadTupleMaybe(command::bash2html &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 bash2html_Init(command::bash2html& parent);
// print command-line args of command::bash2html to string  -- cprint:command.bash2html.Argv
void                 bash2html_PrintArgv(command::bash2html & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              bash2html_ToCmdline(command::bash2html & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  bash2html_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.bash2html_proc
struct bash2html_proc { // command.bash2html_proc: Subprocess: Convert bash output and colours to html
    algo::cstring        path;      //   "bin/bash2html"  path for executable
    command::bash2html   cmd;       // command line for child process
    algo::cstring        fstdin;    // redirect for stdin
    algo::cstring        fstdout;   // redirect for stdout
    algo::cstring        fstderr;   // redirect for stderr
    pid_t                pid;       //   0  pid of running child process
    i32                  timeout;   //   0  optional timeout for child process
    i32                  status;    //   0  last exit status of child process
    bash2html_proc();
    ~bash2html_proc();
private:
    // reftype Exec of command.bash2html_proc.bash2html prohibits copy
    bash2html_proc(const bash2html_proc&){ /*disallow copy constructor */}
    void operator =(const bash2html_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  bash2html_Start(command::bash2html_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         bash2html_StartRead(command::bash2html_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 bash2html_Kill(command::bash2html_proc& parent);
// Wait for subprocess to return
void                 bash2html_Wait(command::bash2html_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  bash2html_Exec(command::bash2html_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 bash2html_ExecX(command::bash2html_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:bash2html.Argv
int                  bash2html_Execv(command::bash2html_proc& parent) __attribute__((nothrow));
algo::tempstr        bash2html_ToCmdline(command::bash2html_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 bash2html_proc_Init(command::bash2html_proc& parent);
void                 bash2html_proc_Uninit(command::bash2html_proc& parent) __attribute__((nothrow));

// --- command.bash_proc
struct bash_proc { // command.bash_proc: Shell subprocess
    algo::cstring   path;      //   "bash"  path for executable
    command::bash   cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    bash_proc();
    ~bash_proc();
private:
    // reftype Exec of command.bash_proc.bash prohibits copy
    bash_proc(const bash_proc&){ /*disallow copy constructor */}
    void operator =(const bash_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  bash_Start(command::bash_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         bash_StartRead(command::bash_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 bash_Kill(command::bash_proc& parent);
// Wait for subprocess to return
void                 bash_Wait(command::bash_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  bash_Exec(command::bash_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 bash_ExecX(command::bash_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:bash.Argv
int                  bash_Execv(command::bash_proc& parent) __attribute__((nothrow));
algo::tempstr        bash_ToCmdline(command::bash_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 bash_proc_Init(command::bash_proc& parent);
void                 bash_proc_Uninit(command::bash_proc& parent) __attribute__((nothrow));

// --- command.gcache
// access: command.gcache_proc.gcache (Exec)
struct gcache { // command.gcache
    algo::cstring    in;          //   "data"  Input directory or filename, - for stdin
    algo::cstring*   cmd_elems;   // pointer to elements
    u32              cmd_n;       // number of elements in array
    u32              cmd_max;     // max. capacity of array before realloc
    bool             install;     //   false  Create gcache directory and enable gcache
    bool             stats;       //   false  Show cache stats
    bool             enable;      //   false  Create .gcache link to enable gcache use
    bool             disable;     //   false  Remove .gcache link to disable gcache
    bool             gc;          //   false  Clean old files from .gcache
    bool             clean;       //   false  Clean the entire cache
    algo::cstring    dir;         //   "/tmp/gcache"  (With -install,-enable) cache directory
    bool             hitrate;     //   false  Report hit rate (specify start time with -after)
    algo::UnTime     after;       // Start time for reporting
    bool             report;      //   false  Show end-of-run report
    gcache();
    ~gcache();
private:
    // reftype Tary of command.gcache.cmd prohibits copy
    gcache(const gcache&){ /*disallow copy constructor */}
    void operator =(const gcache&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       cmd_Alloc(command::gcache& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       cmd_AllocAt(command::gcache& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> cmd_AllocN(command::gcache& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cmd_EmptyQ(command::gcache& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       cmd_Find(command::gcache& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> cmd_Getary(command::gcache& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       cmd_Last(command::gcache& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  cmd_Max(command::gcache& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  cmd_N(const command::gcache& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 cmd_Remove(command::gcache& parent, u32 i) __attribute__((nothrow));
void                 cmd_RemoveAll(command::gcache& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cmd_RemoveLast(command::gcache& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 cmd_Reserve(command::gcache& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 cmd_AbsReserve(command::gcache& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 cmd_Setary(command::gcache& parent, command::gcache &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       cmd_qFind(command::gcache& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       cmd_qLast(command::gcache& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  cmd_rowid_Get(command::gcache& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> cmd_AllocNVal(command::gcache& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 cmd_ReadStrptrMaybe(command::gcache& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 gcache_cmd_curs_Next(gcache_cmd_curs &curs);
void                 gcache_cmd_curs_Reset(gcache_cmd_curs &curs, command::gcache &parent);
// cursor points to valid item
bool                 gcache_cmd_curs_ValidQ(gcache_cmd_curs &curs);
// item access
algo::cstring&       gcache_cmd_curs_Access(gcache_cmd_curs &curs);
bool                 gcache_ReadFieldMaybe(command::gcache &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::gcache from attributes of ascii tuple TUPLE
bool                 gcache_ReadTupleMaybe(command::gcache &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 gcache_Init(command::gcache& parent);
void                 gcache_Uninit(command::gcache& parent) __attribute__((nothrow));
// print command-line args of command::gcache to string  -- cprint:command.gcache.Argv
void                 gcache_PrintArgv(command::gcache & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              gcache_ToCmdline(command::gcache & row) __attribute__((nothrow));
// print string representation of command::gcache to string LHS, no header -- cprint:command.gcache.String
void                 gcache_Print(command::gcache & row, algo::cstring &str) __attribute__((nothrow));
algo::strptr         gcache_GetAnon(command::gcache &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  gcache_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.gcache_proc
struct gcache_proc { // command.gcache_proc: Subprocess: Compiler cache
    algo::cstring     path;      //   "bin/gcache"  path for executable
    command::gcache   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    gcache_proc();
    ~gcache_proc();
private:
    // reftype Exec of command.gcache_proc.gcache prohibits copy
    // value field command.gcache_proc.cmd is not copiable
    gcache_proc(const gcache_proc&){ /*disallow copy constructor */}
    void operator =(const gcache_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  gcache_Start(command::gcache_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         gcache_StartRead(command::gcache_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 gcache_Kill(command::gcache_proc& parent);
// Wait for subprocess to return
void                 gcache_Wait(command::gcache_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  gcache_Exec(command::gcache_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 gcache_ExecX(command::gcache_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:gcache.Argv
int                  gcache_Execv(command::gcache_proc& parent) __attribute__((nothrow));
algo::tempstr        gcache_ToCmdline(command::gcache_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 gcache_proc_Init(command::gcache_proc& parent);
void                 gcache_proc_Uninit(command::gcache_proc& parent) __attribute__((nothrow));

// --- command.gcli
// access: command.gcli_proc.gcli (Exec)
struct gcli { // command.gcli
    algo::cstring       in;                         //   "data"  Input directory or filename, - for stdin
    algo::Smallstr250   selector;                   //   "issue:%"  table:key, where table is issue,repo,mr, etc. and key is a regex.
    algo::cstring*      fields_elems;               // pointer to elements
    u32                 fields_n;                   // number of elements in array
    u32                 fields_max;                 // max. capacity of array before realloc
    bool                accept;                     //   false  (action) accept a slected merge request
    bool                start;                      //   false  (action) start working on a selected issue
    bool                list;                       //   false  (action) show selected table
    bool                create;                     //   false  (action) create a table record(s)
    bool                update;                     //   false  (action) update fields of a selected issue or mergereq
    bool                approve;                    //   false  (action) remove draft desiognation from mergereq
    bool                needs_work;                 //   false  (action) reopen an issue or put a draft designation on mergereq
    bool                stop;                       //   false  (action) closes an issue, or remove mr branch after review
    bool                t;                          //   false  Tree view: expand issue description
    bool                e;                          //   false  edit the input
    algo::cstring       authdir;                    //   ".ssim"  (setup) Input directory for auth data
    bool                dry_run;                    //   false  Print actions, do not perform
    algo::cstring       gitdir;                     //   ""  (setup) Change directory of git repository
    bool                show_gitlab_system_notes;   //   false  (misc) Show issue and mr notes created by gitlab
    gcli();
    ~gcli();
private:
    // reftype Tary of command.gcli.fields prohibits copy
    gcli(const gcli&){ /*disallow copy constructor */}
    void operator =(const gcli&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       fields_Alloc(command::gcli& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       fields_AllocAt(command::gcli& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> fields_AllocN(command::gcli& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fields_EmptyQ(command::gcli& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       fields_Find(command::gcli& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> fields_Getary(command::gcli& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       fields_Last(command::gcli& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  fields_Max(command::gcli& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  fields_N(const command::gcli& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 fields_Remove(command::gcli& parent, u32 i) __attribute__((nothrow));
void                 fields_RemoveAll(command::gcli& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 fields_RemoveLast(command::gcli& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 fields_Reserve(command::gcli& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 fields_AbsReserve(command::gcli& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 fields_Setary(command::gcli& parent, command::gcli &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       fields_qFind(command::gcli& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       fields_qLast(command::gcli& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  fields_rowid_Get(command::gcli& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> fields_AllocNVal(command::gcli& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 fields_ReadStrptrMaybe(command::gcli& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 gcli_fields_curs_Next(gcli_fields_curs &curs);
void                 gcli_fields_curs_Reset(gcli_fields_curs &curs, command::gcli &parent);
// cursor points to valid item
bool                 gcli_fields_curs_ValidQ(gcli_fields_curs &curs);
// item access
algo::cstring&       gcli_fields_curs_Access(gcli_fields_curs &curs);
bool                 gcli_ReadFieldMaybe(command::gcli &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::gcli from attributes of ascii tuple TUPLE
bool                 gcli_ReadTupleMaybe(command::gcli &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 gcli_Init(command::gcli& parent);
void                 gcli_Uninit(command::gcli& parent) __attribute__((nothrow));
// print command-line args of command::gcli to string  -- cprint:command.gcli.Argv
void                 gcli_PrintArgv(command::gcli & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              gcli_ToCmdline(command::gcli & row) __attribute__((nothrow));
algo::strptr         gcli_GetAnon(command::gcli &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  gcli_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.gcli_proc
struct gcli_proc { // command.gcli_proc: Subprocess: Gcli - gitlab/github command-line client
    algo::cstring   path;      //   "bin/gcli"  path for executable
    command::gcli   cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    gcli_proc();
    ~gcli_proc();
private:
    // reftype Exec of command.gcli_proc.gcli prohibits copy
    // value field command.gcli_proc.cmd is not copiable
    gcli_proc(const gcli_proc&){ /*disallow copy constructor */}
    void operator =(const gcli_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  gcli_Start(command::gcli_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         gcli_StartRead(command::gcli_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 gcli_Kill(command::gcli_proc& parent);
// Wait for subprocess to return
void                 gcli_Wait(command::gcli_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  gcli_Exec(command::gcli_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 gcli_ExecX(command::gcli_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:gcli.Argv
int                  gcli_Execv(command::gcli_proc& parent) __attribute__((nothrow));
algo::tempstr        gcli_ToCmdline(command::gcli_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 gcli_proc_Init(command::gcli_proc& parent);
void                 gcli_proc_Uninit(command::gcli_proc& parent) __attribute__((nothrow));

// --- command.lib_ctype
struct lib_ctype { // command.lib_ctype
    algo::cstring   in;   //   "data"  Input directory or filename, - for stdin
    lib_ctype();
};

bool                 lib_ctype_ReadFieldMaybe(command::lib_ctype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::lib_ctype from attributes of ascii tuple TUPLE
bool                 lib_ctype_ReadTupleMaybe(command::lib_ctype &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 lib_ctype_Init(command::lib_ctype& parent);
// print command-line args of command::lib_ctype to string  -- cprint:command.lib_ctype.Argv
void                 lib_ctype_PrintArgv(command::lib_ctype & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              lib_ctype_ToCmdline(command::lib_ctype & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  lib_ctype_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.lib_exec
struct lib_exec { // command.lib_exec
    bool   dry_run;    //   false
    bool   q;          //   true  Do not print node name
    i32    maxjobs;    //   8  Maximum number of parallel jobs
    bool   complooo;   //   false
    lib_exec();
};

bool                 lib_exec_ReadFieldMaybe(command::lib_exec &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::lib_exec from attributes of ascii tuple TUPLE
bool                 lib_exec_ReadTupleMaybe(command::lib_exec &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 lib_exec_Init(command::lib_exec& parent);
// print command-line args of command::lib_exec to string  -- cprint:command.lib_exec.Argv
void                 lib_exec_PrintArgv(command::lib_exec & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              lib_exec_ToCmdline(command::lib_exec & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  lib_exec_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.mdbg
// access: command.mdbg_proc.mdbg (Exec)
struct mdbg { // command.mdbg
    algo::Smallstr16   target;         // Executable name
    algo::cstring      in;             //   "data"  Input directory or filename, - for stdin
    algo::cstring*     args_elems;     // pointer to elements
    u32                args_n;         // number of elements in array
    u32                args_max;       // max. capacity of array before realloc
    algo::Smallstr50   cfg;            //   "debug"  Configuration to use
    bool               disas;          //   false  Show disassembly (use F12)
    bool               attach;         //   false  Attach to a running process
    algo::cstring*     b_elems;        // pointer to elements
    u32                b_n;            // number of elements in array
    u32                b_max;          // max. capacity of array before realloc
    bool               catchthrow;     //   true  Stop on exceptions
    bool               tui;            //   false  Use gdb -tui as the debugger
    algo::cstring      bcmd;           //   ""  Evaluate command at breakpoint
    bool               emacs;          //   true  Use emacs environment as the debugger
    bool               manywin;        //   false  Use gdb-many-windows emacs mode
    bool               follow_child;   //   false
    bool               py;             //   false  Enable python scripting
    bool               dry_run;        //   false  Print commands but don't execute
    mdbg();
    ~mdbg();
private:
    // reftype Tary of command.mdbg.args prohibits copy
    // reftype Tary of command.mdbg.b prohibits copy
    mdbg(const mdbg&){ /*disallow copy constructor */}
    void operator =(const mdbg&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       args_Alloc(command::mdbg& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       args_AllocAt(command::mdbg& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> args_AllocN(command::mdbg& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 args_EmptyQ(command::mdbg& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       args_Find(command::mdbg& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> args_Getary(command::mdbg& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       args_Last(command::mdbg& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  args_Max(command::mdbg& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  args_N(const command::mdbg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 args_Remove(command::mdbg& parent, u32 i) __attribute__((nothrow));
void                 args_RemoveAll(command::mdbg& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 args_RemoveLast(command::mdbg& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 args_Reserve(command::mdbg& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 args_AbsReserve(command::mdbg& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 args_Setary(command::mdbg& parent, command::mdbg &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       args_qFind(command::mdbg& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       args_qLast(command::mdbg& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  args_rowid_Get(command::mdbg& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> args_AllocNVal(command::mdbg& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 args_ReadStrptrMaybe(command::mdbg& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       b_Alloc(command::mdbg& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       b_AllocAt(command::mdbg& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> b_AllocN(command::mdbg& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 b_EmptyQ(command::mdbg& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       b_Find(command::mdbg& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> b_Getary(command::mdbg& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       b_Last(command::mdbg& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  b_Max(command::mdbg& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  b_N(const command::mdbg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 b_Remove(command::mdbg& parent, u32 i) __attribute__((nothrow));
void                 b_RemoveAll(command::mdbg& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 b_RemoveLast(command::mdbg& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 b_Reserve(command::mdbg& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 b_AbsReserve(command::mdbg& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 b_Setary(command::mdbg& parent, command::mdbg &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       b_qFind(command::mdbg& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       b_qLast(command::mdbg& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  b_rowid_Get(command::mdbg& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> b_AllocNVal(command::mdbg& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 b_ReadStrptrMaybe(command::mdbg& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 mdbg_args_curs_Next(mdbg_args_curs &curs);
void                 mdbg_args_curs_Reset(mdbg_args_curs &curs, command::mdbg &parent);
// cursor points to valid item
bool                 mdbg_args_curs_ValidQ(mdbg_args_curs &curs);
// item access
algo::cstring&       mdbg_args_curs_Access(mdbg_args_curs &curs);
// proceed to next item
void                 mdbg_b_curs_Next(mdbg_b_curs &curs);
void                 mdbg_b_curs_Reset(mdbg_b_curs &curs, command::mdbg &parent);
// cursor points to valid item
bool                 mdbg_b_curs_ValidQ(mdbg_b_curs &curs);
// item access
algo::cstring&       mdbg_b_curs_Access(mdbg_b_curs &curs);
bool                 mdbg_ReadFieldMaybe(command::mdbg &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::mdbg from attributes of ascii tuple TUPLE
bool                 mdbg_ReadTupleMaybe(command::mdbg &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 mdbg_Init(command::mdbg& parent);
void                 mdbg_Uninit(command::mdbg& parent) __attribute__((nothrow));
// print command-line args of command::mdbg to string  -- cprint:command.mdbg.Argv
void                 mdbg_PrintArgv(command::mdbg & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              mdbg_ToCmdline(command::mdbg & row) __attribute__((nothrow));
algo::strptr         mdbg_GetAnon(command::mdbg &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  mdbg_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.mdbg_proc
struct mdbg_proc { // command.mdbg_proc: Subprocess: Gdb front-end
    algo::cstring   path;      //   "bin/mdbg"  path for executable
    command::mdbg   cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    mdbg_proc();
    ~mdbg_proc();
private:
    // reftype Exec of command.mdbg_proc.mdbg prohibits copy
    // value field command.mdbg_proc.cmd is not copiable
    mdbg_proc(const mdbg_proc&){ /*disallow copy constructor */}
    void operator =(const mdbg_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  mdbg_Start(command::mdbg_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         mdbg_StartRead(command::mdbg_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 mdbg_Kill(command::mdbg_proc& parent);
// Wait for subprocess to return
void                 mdbg_Wait(command::mdbg_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  mdbg_Exec(command::mdbg_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 mdbg_ExecX(command::mdbg_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:mdbg.Argv
int                  mdbg_Execv(command::mdbg_proc& parent) __attribute__((nothrow));
algo::tempstr        mdbg_ToCmdline(command::mdbg_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 mdbg_proc_Init(command::mdbg_proc& parent);
void                 mdbg_proc_Uninit(command::mdbg_proc& parent) __attribute__((nothrow));

// --- command.mysql2ssim
// access: command.mysql2ssim_proc.mysql2ssim (Exec)
struct mysql2ssim { // command.mysql2ssim
    bool            writessimfile;   //   false  Write to ssimfile directly
    algo::cstring   url;             // user:pass@host/db or sock:///filename/db
    algo::cstring   tables;          //   ""  comma-separated list of tables. Default is all tables
    bool            schema;          //   false  Generate ssim type definition
    algo::cstring   in;              //   "data"  Input directory or filename, - for stdin
    bool            pretty;          //   false  Format output for the screen
    bool            nologo;          //   false  Don't show copyright notice
    bool            baddbok;         //   false  Don't claim if bad database
    mysql2ssim();
};

bool                 mysql2ssim_ReadFieldMaybe(command::mysql2ssim &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::mysql2ssim from attributes of ascii tuple TUPLE
bool                 mysql2ssim_ReadTupleMaybe(command::mysql2ssim &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 mysql2ssim_Init(command::mysql2ssim& parent);
// print command-line args of command::mysql2ssim to string  -- cprint:command.mysql2ssim.Argv
void                 mysql2ssim_PrintArgv(command::mysql2ssim & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              mysql2ssim_ToCmdline(command::mysql2ssim & row) __attribute__((nothrow));
algo::strptr         mysql2ssim_GetAnon(command::mysql2ssim &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  mysql2ssim_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.mysql2ssim_proc
struct mysql2ssim_proc { // command.mysql2ssim_proc: Subprocess: mysql -> ssim conversion tool
    algo::cstring         path;      //   "bin/mysql2ssim"  path for executable
    command::mysql2ssim   cmd;       // command line for child process
    algo::cstring         fstdin;    // redirect for stdin
    algo::cstring         fstdout;   // redirect for stdout
    algo::cstring         fstderr;   // redirect for stderr
    pid_t                 pid;       //   0  pid of running child process
    i32                   timeout;   //   0  optional timeout for child process
    i32                   status;    //   0  last exit status of child process
    mysql2ssim_proc();
    ~mysql2ssim_proc();
private:
    // reftype Exec of command.mysql2ssim_proc.mysql2ssim prohibits copy
    mysql2ssim_proc(const mysql2ssim_proc&){ /*disallow copy constructor */}
    void operator =(const mysql2ssim_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  mysql2ssim_Start(command::mysql2ssim_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         mysql2ssim_StartRead(command::mysql2ssim_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 mysql2ssim_Kill(command::mysql2ssim_proc& parent);
// Wait for subprocess to return
void                 mysql2ssim_Wait(command::mysql2ssim_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  mysql2ssim_Exec(command::mysql2ssim_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 mysql2ssim_ExecX(command::mysql2ssim_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:mysql2ssim.Argv
int                  mysql2ssim_Execv(command::mysql2ssim_proc& parent) __attribute__((nothrow));
algo::tempstr        mysql2ssim_ToCmdline(command::mysql2ssim_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 mysql2ssim_proc_Init(command::mysql2ssim_proc& parent);
void                 mysql2ssim_proc_Uninit(command::mysql2ssim_proc& parent) __attribute__((nothrow));

// --- command.orgfile
// access: command.orgfile_proc.orgfile (Exec)
struct orgfile { // command.orgfile
    algo::cstring    in;       //   "data"  Input directory or filename, - for stdin
    algo::cstring    move;     //   ""  Read stdin, rename files based on pattern
    algo_lib::Regx   dedup;    //   ""  Sql Regx
    bool             commit;   //   false  Apply changes
    bool             undo;     //   false  Read previous orgfile output, undoing movement
    algo::cstring    hash;     //   "sha1"  Hash command to use for deduplication
    orgfile();
private:
    // reftype Regx of command.orgfile.dedup prohibits copy
    orgfile(const orgfile&){ /*disallow copy constructor */}
    void operator =(const orgfile&){ /*disallow direct assignment */}
};

// Print back to string
void                 dedup_Print(command::orgfile& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 dedup_ReadStrptrMaybe(command::orgfile& parent, algo::strptr in) __attribute__((nothrow));

bool                 orgfile_ReadFieldMaybe(command::orgfile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::orgfile from attributes of ascii tuple TUPLE
bool                 orgfile_ReadTupleMaybe(command::orgfile &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 orgfile_Init(command::orgfile& parent);
// print command-line args of command::orgfile to string  -- cprint:command.orgfile.Argv
void                 orgfile_PrintArgv(command::orgfile & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              orgfile_ToCmdline(command::orgfile & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  orgfile_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.orgfile_proc
struct orgfile_proc { // command.orgfile_proc: Subprocess: organize and deduplicate files by timestamp and by contents
    algo::cstring      path;      //   "bin/orgfile"  path for executable
    command::orgfile   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    orgfile_proc();
    ~orgfile_proc();
private:
    // reftype Exec of command.orgfile_proc.orgfile prohibits copy
    // value field command.orgfile_proc.cmd is not copiable
    orgfile_proc(const orgfile_proc&){ /*disallow copy constructor */}
    void operator =(const orgfile_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  orgfile_Start(command::orgfile_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         orgfile_StartRead(command::orgfile_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 orgfile_Kill(command::orgfile_proc& parent);
// Wait for subprocess to return
void                 orgfile_Wait(command::orgfile_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  orgfile_Exec(command::orgfile_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 orgfile_ExecX(command::orgfile_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:orgfile.Argv
int                  orgfile_Execv(command::orgfile_proc& parent) __attribute__((nothrow));
algo::tempstr        orgfile_ToCmdline(command::orgfile_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 orgfile_proc_Init(command::orgfile_proc& parent);
void                 orgfile_proc_Uninit(command::orgfile_proc& parent) __attribute__((nothrow));

// --- command.samp_regx
// access: command.samp_regx_proc.samp_regx (Exec)
struct samp_regx { // command.samp_regx
    algo::cstring   in;       //   "data"  Input directory or filename, - for stdin
    algo::cstring   expr;     // Expression
    u8              style;    //   0  Regx style
    bool            match;    //   false  Match a string
    algo::cstring   string;   //   ""  String to match
    bool            show;     //   false  Show regx innards
    samp_regx();
};

// Get value of field as enum type
command_samp_regx_style_Enum style_GetEnum(const command::samp_regx& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 style_SetEnum(command::samp_regx& parent, command_samp_regx_style_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          style_ToCstr(const command::samp_regx& parent) __attribute__((nothrow));
// Convert style to a string. First, attempt conversion to a known string.
// If no string matches, print style as a numeric value.
void                 style_Print(const command::samp_regx& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 style_SetStrptrMaybe(command::samp_regx& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 style_SetStrptr(command::samp_regx& parent, algo::strptr rhs, command_samp_regx_style_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 style_ReadStrptrMaybe(command::samp_regx& parent, algo::strptr rhs) __attribute__((nothrow));

bool                 samp_regx_ReadFieldMaybe(command::samp_regx &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::samp_regx from attributes of ascii tuple TUPLE
bool                 samp_regx_ReadTupleMaybe(command::samp_regx &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 samp_regx_Init(command::samp_regx& parent);
// print command-line args of command::samp_regx to string  -- cprint:command.samp_regx.Argv
void                 samp_regx_PrintArgv(command::samp_regx & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              samp_regx_ToCmdline(command::samp_regx & row) __attribute__((nothrow));
algo::strptr         samp_regx_GetAnon(command::samp_regx &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  samp_regx_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.samp_regx_proc
struct samp_regx_proc { // command.samp_regx_proc: Subprocess: 
    algo::cstring        path;      //   "bin/samp_regx"  path for executable
    command::samp_regx   cmd;       // command line for child process
    algo::cstring        fstdin;    // redirect for stdin
    algo::cstring        fstdout;   // redirect for stdout
    algo::cstring        fstderr;   // redirect for stderr
    pid_t                pid;       //   0  pid of running child process
    i32                  timeout;   //   0  optional timeout for child process
    i32                  status;    //   0  last exit status of child process
    samp_regx_proc();
    ~samp_regx_proc();
private:
    // reftype Exec of command.samp_regx_proc.samp_regx prohibits copy
    samp_regx_proc(const samp_regx_proc&){ /*disallow copy constructor */}
    void operator =(const samp_regx_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  samp_regx_Start(command::samp_regx_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         samp_regx_StartRead(command::samp_regx_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 samp_regx_Kill(command::samp_regx_proc& parent);
// Wait for subprocess to return
void                 samp_regx_Wait(command::samp_regx_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  samp_regx_Exec(command::samp_regx_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 samp_regx_ExecX(command::samp_regx_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:samp_regx.Argv
int                  samp_regx_Execv(command::samp_regx_proc& parent) __attribute__((nothrow));
algo::tempstr        samp_regx_ToCmdline(command::samp_regx_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 samp_regx_proc_Init(command::samp_regx_proc& parent);
void                 samp_regx_proc_Uninit(command::samp_regx_proc& parent) __attribute__((nothrow));

// --- command.sandbox
// access: command.sandbox_proc.sandbox (Exec)
struct sandbox { // command.sandbox
    algo::cstring    in;            //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   name;          // Sql Regx of dev::Sandbox
    bool             create;        //   false  Create new sandbox and register in dev.sandbox
    bool             list;          //   false  List existing sandboxes
    bool             reset;         //   false  Reset sandbox to match current directory
    bool             clean;         //   false  Remove sandbox contents to save space
    bool             del;           //   false  Permanently delete sandbox
    bool             gc;            //   false  Run git gc in target dir
    algo::cstring*   cmd_elems;     // pointer to elements
    u32              cmd_n;         // number of elements in array
    u32              cmd_max;       // max. capacity of array before realloc
    bool             diff;          //   false  Show diff after running command
    algo::cstring*   files_elems;   // pointer to elements
    u32              files_n;       // number of elements in array
    u32              files_max;     // max. capacity of array before realloc
    sandbox();
    ~sandbox();
private:
    // reftype Regx of command.sandbox.name prohibits copy
    // reftype Tary of command.sandbox.cmd prohibits copy
    // reftype Tary of command.sandbox.files prohibits copy
    // ... and several other reasons
    sandbox(const sandbox&){ /*disallow copy constructor */}
    void operator =(const sandbox&){ /*disallow direct assignment */}
};

// Print back to string
void                 name_Print(command::sandbox& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 name_ReadStrptrMaybe(command::sandbox& parent, algo::strptr in) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       cmd_Alloc(command::sandbox& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       cmd_AllocAt(command::sandbox& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> cmd_AllocN(command::sandbox& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cmd_EmptyQ(command::sandbox& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       cmd_Find(command::sandbox& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> cmd_Getary(command::sandbox& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       cmd_Last(command::sandbox& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  cmd_Max(command::sandbox& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  cmd_N(const command::sandbox& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 cmd_Remove(command::sandbox& parent, u32 i) __attribute__((nothrow));
void                 cmd_RemoveAll(command::sandbox& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cmd_RemoveLast(command::sandbox& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 cmd_Reserve(command::sandbox& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 cmd_AbsReserve(command::sandbox& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 cmd_Setary(command::sandbox& parent, command::sandbox &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       cmd_qFind(command::sandbox& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       cmd_qLast(command::sandbox& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  cmd_rowid_Get(command::sandbox& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> cmd_AllocNVal(command::sandbox& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 cmd_ReadStrptrMaybe(command::sandbox& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       files_Alloc(command::sandbox& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       files_AllocAt(command::sandbox& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> files_AllocN(command::sandbox& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 files_EmptyQ(command::sandbox& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       files_Find(command::sandbox& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> files_Getary(command::sandbox& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       files_Last(command::sandbox& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  files_Max(command::sandbox& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  files_N(const command::sandbox& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 files_Remove(command::sandbox& parent, u32 i) __attribute__((nothrow));
void                 files_RemoveAll(command::sandbox& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 files_RemoveLast(command::sandbox& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 files_Reserve(command::sandbox& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 files_AbsReserve(command::sandbox& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 files_Setary(command::sandbox& parent, command::sandbox &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       files_qFind(command::sandbox& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       files_qLast(command::sandbox& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  files_rowid_Get(command::sandbox& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> files_AllocNVal(command::sandbox& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 files_ReadStrptrMaybe(command::sandbox& parent, algo::strptr in_str) __attribute__((nothrow));

// proceed to next item
void                 sandbox_cmd_curs_Next(sandbox_cmd_curs &curs);
void                 sandbox_cmd_curs_Reset(sandbox_cmd_curs &curs, command::sandbox &parent);
// cursor points to valid item
bool                 sandbox_cmd_curs_ValidQ(sandbox_cmd_curs &curs);
// item access
algo::cstring&       sandbox_cmd_curs_Access(sandbox_cmd_curs &curs);
// proceed to next item
void                 sandbox_files_curs_Next(sandbox_files_curs &curs);
void                 sandbox_files_curs_Reset(sandbox_files_curs &curs, command::sandbox &parent);
// cursor points to valid item
bool                 sandbox_files_curs_ValidQ(sandbox_files_curs &curs);
// item access
algo::cstring&       sandbox_files_curs_Access(sandbox_files_curs &curs);
bool                 sandbox_ReadFieldMaybe(command::sandbox &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::sandbox from attributes of ascii tuple TUPLE
bool                 sandbox_ReadTupleMaybe(command::sandbox &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 sandbox_Init(command::sandbox& parent);
void                 sandbox_Uninit(command::sandbox& parent) __attribute__((nothrow));
// print command-line args of command::sandbox to string  -- cprint:command.sandbox.Argv
void                 sandbox_PrintArgv(command::sandbox & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              sandbox_ToCmdline(command::sandbox & row) __attribute__((nothrow));
algo::strptr         sandbox_GetAnon(command::sandbox &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  sandbox_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.sandbox_proc
struct sandbox_proc { // command.sandbox_proc: Subprocess: Sandbox - sandbox management tool
    algo::cstring      path;      //   "bin/sandbox"  path for executable
    command::sandbox   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    sandbox_proc();
    ~sandbox_proc();
private:
    // reftype Exec of command.sandbox_proc.sandbox prohibits copy
    // value field command.sandbox_proc.cmd is not copiable
    sandbox_proc(const sandbox_proc&){ /*disallow copy constructor */}
    void operator =(const sandbox_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  sandbox_Start(command::sandbox_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         sandbox_StartRead(command::sandbox_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 sandbox_Kill(command::sandbox_proc& parent);
// Wait for subprocess to return
void                 sandbox_Wait(command::sandbox_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  sandbox_Exec(command::sandbox_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 sandbox_ExecX(command::sandbox_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:sandbox.Argv
int                  sandbox_Execv(command::sandbox_proc& parent) __attribute__((nothrow));
algo::tempstr        sandbox_ToCmdline(command::sandbox_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 sandbox_proc_Init(command::sandbox_proc& parent);
void                 sandbox_proc_Uninit(command::sandbox_proc& parent) __attribute__((nothrow));

// --- command.src_func
// access: command.src_func_proc.src_func (Exec)
struct src_func { // command.src_func
    algo::cstring       in;            //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx      target;        //   "%"  Sql Regx of dev::Target
    algo_lib::Regx      name;          //   "%"  Sql Regx
    algo_lib::Regx      body;          //   "%"  Sql Regx
    algo_lib::Regx      targsrc;       //   ""  Sql Regx of dev::Targsrc
    algo_lib::Regx      func;          //   "%"  Sql Regx
    algo_lib::Regx      comment;       //   "%"  Sql Regx
    algo::Smallstr200   nextfile;      //   ""  Print name of next srcfile in targsrc list
    bool                other;         //   false  (with -nextfile), name of previous file
    bool                updateproto;   //   false  Update prototypes in headers
    bool                listfunc;      //   false  Show functions in target
    bool                iffy;          //   false  Select functions that may contain errors
    bool                proto;         //   false  (with -listfunc) List prototypes only
    bool                gen;           //   false  (with -listfunc) Visit generated files
    bool                showloc;       //   true  (with -listfunc) Show file location
    bool                showstatic;    //   true  (with -listfunc) Show static functions
    bool                showsortkey;   //   false  (with -listfunc) Display function sortkey
    bool                sortname;      //   false  (with -listfunc) Sort functions by name
    bool                e;             //   false  (with -listfunc) Edit found functions
    bool                baddecl;       //   false  Report and fail on bad declarations
    bool                report;        //   false
    src_func();
private:
    // reftype Regx of command.src_func.target prohibits copy
    // reftype Regx of command.src_func.name prohibits copy
    // reftype Regx of command.src_func.body prohibits copy
    // ... and several other reasons
    src_func(const src_func&){ /*disallow copy constructor */}
    void operator =(const src_func&){ /*disallow direct assignment */}
};

// Print back to string
void                 target_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 target_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 name_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 name_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 body_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 body_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 targsrc_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 targsrc_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 func_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 func_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 comment_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 comment_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

bool                 src_func_ReadFieldMaybe(command::src_func &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::src_func from attributes of ascii tuple TUPLE
bool                 src_func_ReadTupleMaybe(command::src_func &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 src_func_Init(command::src_func& parent);
// print command-line args of command::src_func to string  -- cprint:command.src_func.Argv
void                 src_func_PrintArgv(command::src_func & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              src_func_ToCmdline(command::src_func & row) __attribute__((nothrow));
algo::strptr         src_func_GetAnon(command::src_func &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  src_func_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.src_func_proc
struct src_func_proc { // command.src_func_proc: Subprocess: Access / edit functions
    algo::cstring       path;      //   "bin/src_func"  path for executable
    command::src_func   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    src_func_proc();
    ~src_func_proc();
private:
    // reftype Exec of command.src_func_proc.src_func prohibits copy
    // value field command.src_func_proc.cmd is not copiable
    src_func_proc(const src_func_proc&){ /*disallow copy constructor */}
    void operator =(const src_func_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  src_func_Start(command::src_func_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         src_func_StartRead(command::src_func_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 src_func_Kill(command::src_func_proc& parent);
// Wait for subprocess to return
void                 src_func_Wait(command::src_func_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  src_func_Exec(command::src_func_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 src_func_ExecX(command::src_func_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:src_func.Argv
int                  src_func_Execv(command::src_func_proc& parent) __attribute__((nothrow));
algo::tempstr        src_func_ToCmdline(command::src_func_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 src_func_proc_Init(command::src_func_proc& parent);
void                 src_func_proc_Uninit(command::src_func_proc& parent) __attribute__((nothrow));

// --- command.src_hdr
// access: command.src_hdr_proc.src_hdr (Exec)
struct src_hdr { // command.src_hdr
    algo::cstring    in;                 //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   targsrc;            //   ""  Sql Regx of dev::Targsrc
    bool             write;              //   false  Update files in-place
    bool             indent;             //   false  Indent source files
    algo::cstring    update_copyright;   //   ""  Update copyright notice for specified company with current year
    algo_lib::Regx   scriptfile;         //   ""  Sql Regx of dev::Scriptfile
    src_hdr();
private:
    // reftype Regx of command.src_hdr.targsrc prohibits copy
    // reftype Regx of command.src_hdr.scriptfile prohibits copy
    src_hdr(const src_hdr&){ /*disallow copy constructor */}
    void operator =(const src_hdr&){ /*disallow direct assignment */}
};

// Print back to string
void                 targsrc_Print(command::src_hdr& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 targsrc_ReadStrptrMaybe(command::src_hdr& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 scriptfile_Print(command::src_hdr& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 scriptfile_ReadStrptrMaybe(command::src_hdr& parent, algo::strptr in) __attribute__((nothrow));

bool                 src_hdr_ReadFieldMaybe(command::src_hdr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::src_hdr from attributes of ascii tuple TUPLE
bool                 src_hdr_ReadTupleMaybe(command::src_hdr &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 src_hdr_Init(command::src_hdr& parent);
// print command-line args of command::src_hdr to string  -- cprint:command.src_hdr.Argv
void                 src_hdr_PrintArgv(command::src_hdr & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              src_hdr_ToCmdline(command::src_hdr & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  src_hdr_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.src_hdr_proc
struct src_hdr_proc { // command.src_hdr_proc: Subprocess: Update source file / copyright header
    algo::cstring      path;      //   "bin/src_hdr"  path for executable
    command::src_hdr   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    src_hdr_proc();
    ~src_hdr_proc();
private:
    // reftype Exec of command.src_hdr_proc.src_hdr prohibits copy
    // value field command.src_hdr_proc.cmd is not copiable
    src_hdr_proc(const src_hdr_proc&){ /*disallow copy constructor */}
    void operator =(const src_hdr_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  src_hdr_Start(command::src_hdr_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         src_hdr_StartRead(command::src_hdr_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 src_hdr_Kill(command::src_hdr_proc& parent);
// Wait for subprocess to return
void                 src_hdr_Wait(command::src_hdr_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  src_hdr_Exec(command::src_hdr_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 src_hdr_ExecX(command::src_hdr_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:src_hdr.Argv
int                  src_hdr_Execv(command::src_hdr_proc& parent) __attribute__((nothrow));
algo::tempstr        src_hdr_ToCmdline(command::src_hdr_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 src_hdr_proc_Init(command::src_hdr_proc& parent);
void                 src_hdr_proc_Uninit(command::src_hdr_proc& parent) __attribute__((nothrow));

// --- command.src_lim
// access: command.src_lim_proc.src_lim (Exec)
struct src_lim { // command.src_lim
    algo::cstring    in;          //   "data"  Input directory or filename, - for stdin
    bool             linelim;     //   false  Check various file limits (line length, function length, etc)
    algo_lib::Regx   srcfile;     //   "%"  Sql Regx of dev::Gitfile
    bool             strayfile;   //   false  Check for unregistered source files
    bool             capture;     //   false  Generate new dev.linelim records
    bool             write;       //   false  Update ssim database (with -capture)
    bool             badchar;     //   false  Check for bad chars in source files
    algo_lib::Regx   badline;     //   ""  Sql Regx of dev::Badline
    src_lim();
private:
    // reftype Regx of command.src_lim.srcfile prohibits copy
    // reftype Regx of command.src_lim.badline prohibits copy
    src_lim(const src_lim&){ /*disallow copy constructor */}
    void operator =(const src_lim&){ /*disallow direct assignment */}
};

// Print back to string
void                 srcfile_Print(command::src_lim& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 srcfile_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 badline_Print(command::src_lim& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 badline_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) __attribute__((nothrow));

bool                 src_lim_ReadFieldMaybe(command::src_lim &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::src_lim from attributes of ascii tuple TUPLE
bool                 src_lim_ReadTupleMaybe(command::src_lim &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 src_lim_Init(command::src_lim& parent);
// print command-line args of command::src_lim to string  -- cprint:command.src_lim.Argv
void                 src_lim_PrintArgv(command::src_lim & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              src_lim_ToCmdline(command::src_lim & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  src_lim_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.src_lim_proc
struct src_lim_proc { // command.src_lim_proc: Subprocess: Enforce line length, function length, and indentation limits
    algo::cstring      path;      //   "bin/src_lim"  path for executable
    command::src_lim   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    src_lim_proc();
    ~src_lim_proc();
private:
    // reftype Exec of command.src_lim_proc.src_lim prohibits copy
    // value field command.src_lim_proc.cmd is not copiable
    src_lim_proc(const src_lim_proc&){ /*disallow copy constructor */}
    void operator =(const src_lim_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  src_lim_Start(command::src_lim_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         src_lim_StartRead(command::src_lim_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 src_lim_Kill(command::src_lim_proc& parent);
// Wait for subprocess to return
void                 src_lim_Wait(command::src_lim_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  src_lim_Exec(command::src_lim_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 src_lim_ExecX(command::src_lim_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:src_lim.Argv
int                  src_lim_Execv(command::src_lim_proc& parent) __attribute__((nothrow));
algo::tempstr        src_lim_ToCmdline(command::src_lim_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 src_lim_proc_Init(command::src_lim_proc& parent);
void                 src_lim_proc_Uninit(command::src_lim_proc& parent) __attribute__((nothrow));

// --- command.ssim2csv
// access: command.ssim2csv_proc.ssim2csv (Exec)
struct ssim2csv { // command.ssim2csv
    algo::cstring   expand;        //   ""
    bool            ignoreQuote;   //   false
    ssim2csv();
};

bool                 ssim2csv_ReadFieldMaybe(command::ssim2csv &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ssim2csv from attributes of ascii tuple TUPLE
bool                 ssim2csv_ReadTupleMaybe(command::ssim2csv &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ssim2csv_Init(command::ssim2csv& parent);
// print command-line args of command::ssim2csv to string  -- cprint:command.ssim2csv.Argv
void                 ssim2csv_PrintArgv(command::ssim2csv & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ssim2csv_ToCmdline(command::ssim2csv & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  ssim2csv_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.ssim2csv_proc
struct ssim2csv_proc { // command.ssim2csv_proc: Subprocess: Ssim -> csv conversion tool
    algo::cstring       path;      //   "bin/ssim2csv"  path for executable
    command::ssim2csv   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    ssim2csv_proc();
    ~ssim2csv_proc();
private:
    // reftype Exec of command.ssim2csv_proc.ssim2csv prohibits copy
    ssim2csv_proc(const ssim2csv_proc&){ /*disallow copy constructor */}
    void operator =(const ssim2csv_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ssim2csv_Start(command::ssim2csv_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ssim2csv_StartRead(command::ssim2csv_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ssim2csv_Kill(command::ssim2csv_proc& parent);
// Wait for subprocess to return
void                 ssim2csv_Wait(command::ssim2csv_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ssim2csv_Exec(command::ssim2csv_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ssim2csv_ExecX(command::ssim2csv_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ssim2csv.Argv
int                  ssim2csv_Execv(command::ssim2csv_proc& parent) __attribute__((nothrow));
algo::tempstr        ssim2csv_ToCmdline(command::ssim2csv_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ssim2csv_proc_Init(command::ssim2csv_proc& parent);
void                 ssim2csv_proc_Uninit(command::ssim2csv_proc& parent) __attribute__((nothrow));

// --- command.ssim2mysql
// access: command.ssim2mysql_proc.ssim2mysql (Exec)
struct ssim2mysql { // command.ssim2mysql
    algo::cstring   url;         //   ""  URL of mysql server. user:pass@hostb or sock://filename; Empty -> stdout
    algo::cstring   data_dir;    //   "data"  Load dmmeta info from this directory
    i32             maxpacket;   //   100000  Max Mysql packet size
    bool            replace;     //   true  use REPLACE INTO instead of INSERT INTO
    bool            trunc;       //   false  Truncate target table
    bool            dry_run;     //   false  Print SQL commands to the stdout
    bool            fldfunc;     //   false  create columns for fldfuncs
    algo::cstring   in;          //   "-"  Input directory or filename, - for stdin
    algo::cstring   db;          //   ""  Optional database name
    bool            createdb;    //   false  Emit CREATE DATABASE code for namespace specified with <db>
    bool            fkey;        //   false  Enable foreign key constraints (uses InnoDB storage engine)
    ssim2mysql();
};

bool                 ssim2mysql_ReadFieldMaybe(command::ssim2mysql &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ssim2mysql from attributes of ascii tuple TUPLE
bool                 ssim2mysql_ReadTupleMaybe(command::ssim2mysql &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ssim2mysql_Init(command::ssim2mysql& parent);
// print command-line args of command::ssim2mysql to string  -- cprint:command.ssim2mysql.Argv
void                 ssim2mysql_PrintArgv(command::ssim2mysql & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ssim2mysql_ToCmdline(command::ssim2mysql & row) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  ssim2mysql_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.ssim2mysql_proc
struct ssim2mysql_proc { // command.ssim2mysql_proc: Subprocess: Ssim -> mysql
    algo::cstring         path;      //   "bin/ssim2mysql"  path for executable
    command::ssim2mysql   cmd;       // command line for child process
    algo::cstring         fstdin;    // redirect for stdin
    algo::cstring         fstdout;   // redirect for stdout
    algo::cstring         fstderr;   // redirect for stderr
    pid_t                 pid;       //   0  pid of running child process
    i32                   timeout;   //   0  optional timeout for child process
    i32                   status;    //   0  last exit status of child process
    ssim2mysql_proc();
    ~ssim2mysql_proc();
private:
    // reftype Exec of command.ssim2mysql_proc.ssim2mysql prohibits copy
    ssim2mysql_proc(const ssim2mysql_proc&){ /*disallow copy constructor */}
    void operator =(const ssim2mysql_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ssim2mysql_Start(command::ssim2mysql_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ssim2mysql_StartRead(command::ssim2mysql_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ssim2mysql_Kill(command::ssim2mysql_proc& parent);
// Wait for subprocess to return
void                 ssim2mysql_Wait(command::ssim2mysql_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ssim2mysql_Exec(command::ssim2mysql_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ssim2mysql_ExecX(command::ssim2mysql_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ssim2mysql.Argv
int                  ssim2mysql_Execv(command::ssim2mysql_proc& parent) __attribute__((nothrow));
algo::tempstr        ssim2mysql_ToCmdline(command::ssim2mysql_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ssim2mysql_proc_Init(command::ssim2mysql_proc& parent);
void                 ssim2mysql_proc_Uninit(command::ssim2mysql_proc& parent) __attribute__((nothrow));

// --- command.ssimfilt
// access: command.ssimfilt_proc.ssimfilt (Exec)
struct ssimfilt { // command.ssimfilt
    algo::cstring    in;            //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   typetag;       //   "%"  Sql Regx
    algo::cstring*   match_elems;   // pointer to elements
    u32              match_n;       // number of elements in array
    u32              match_max;     // max. capacity of array before realloc
    algo::cstring*   field_elems;   // pointer to elements
    u32              field_n;       // number of elements in array
    u32              field_max;     // max. capacity of array before realloc
    u8               format;        //   0  Output format for selected tuples
    bool             t;             //   false  Alias for -format:table
    algo::cstring    cmd;           //   ""  Command to output
    ssimfilt();
    ~ssimfilt();
private:
    // reftype Regx of command.ssimfilt.typetag prohibits copy
    // reftype Tary of command.ssimfilt.match prohibits copy
    // reftype Tary of command.ssimfilt.field prohibits copy
    // ... and several other reasons
    ssimfilt(const ssimfilt&){ /*disallow copy constructor */}
    void operator =(const ssimfilt&){ /*disallow direct assignment */}
};

// Print back to string
void                 typetag_Print(command::ssimfilt& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 typetag_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr in) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       match_Alloc(command::ssimfilt& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       match_AllocAt(command::ssimfilt& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> match_AllocN(command::ssimfilt& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 match_EmptyQ(command::ssimfilt& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       match_Find(command::ssimfilt& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> match_Getary(command::ssimfilt& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       match_Last(command::ssimfilt& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  match_Max(command::ssimfilt& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  match_N(const command::ssimfilt& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 match_Remove(command::ssimfilt& parent, u32 i) __attribute__((nothrow));
void                 match_RemoveAll(command::ssimfilt& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 match_RemoveLast(command::ssimfilt& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 match_Reserve(command::ssimfilt& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 match_AbsReserve(command::ssimfilt& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 match_Setary(command::ssimfilt& parent, command::ssimfilt &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       match_qFind(command::ssimfilt& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       match_qLast(command::ssimfilt& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  match_rowid_Get(command::ssimfilt& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> match_AllocNVal(command::ssimfilt& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 match_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr in_str) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       field_Alloc(command::ssimfilt& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       field_AllocAt(command::ssimfilt& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> field_AllocN(command::ssimfilt& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 field_EmptyQ(command::ssimfilt& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       field_Find(command::ssimfilt& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> field_Getary(command::ssimfilt& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       field_Last(command::ssimfilt& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  field_Max(command::ssimfilt& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  field_N(const command::ssimfilt& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 field_Remove(command::ssimfilt& parent, u32 i) __attribute__((nothrow));
void                 field_RemoveAll(command::ssimfilt& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 field_RemoveLast(command::ssimfilt& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 field_Reserve(command::ssimfilt& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 field_AbsReserve(command::ssimfilt& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 field_Setary(command::ssimfilt& parent, command::ssimfilt &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       field_qFind(command::ssimfilt& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       field_qLast(command::ssimfilt& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  field_rowid_Get(command::ssimfilt& parent, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> field_AllocNVal(command::ssimfilt& parent, int n_elems, const algo::cstring& val) __attribute__((__warn_unused_result__, nothrow));
// Convert string to field. Return success value
bool                 field_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr in_str) __attribute__((nothrow));

// Get value of field as enum type
command_ssimfilt_format_Enum format_GetEnum(const command::ssimfilt& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 format_SetEnum(command::ssimfilt& parent, command_ssimfilt_format_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          format_ToCstr(const command::ssimfilt& parent) __attribute__((nothrow));
// Convert format to a string. First, attempt conversion to a known string.
// If no string matches, print format as a numeric value.
void                 format_Print(const command::ssimfilt& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 format_SetStrptrMaybe(command::ssimfilt& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 format_SetStrptr(command::ssimfilt& parent, algo::strptr rhs, command_ssimfilt_format_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 format_ReadStrptrMaybe(command::ssimfilt& parent, algo::strptr rhs) __attribute__((nothrow));

// proceed to next item
void                 ssimfilt_match_curs_Next(ssimfilt_match_curs &curs);
void                 ssimfilt_match_curs_Reset(ssimfilt_match_curs &curs, command::ssimfilt &parent);
// cursor points to valid item
bool                 ssimfilt_match_curs_ValidQ(ssimfilt_match_curs &curs);
// item access
algo::cstring&       ssimfilt_match_curs_Access(ssimfilt_match_curs &curs);
// proceed to next item
void                 ssimfilt_field_curs_Next(ssimfilt_field_curs &curs);
void                 ssimfilt_field_curs_Reset(ssimfilt_field_curs &curs, command::ssimfilt &parent);
// cursor points to valid item
bool                 ssimfilt_field_curs_ValidQ(ssimfilt_field_curs &curs);
// item access
algo::cstring&       ssimfilt_field_curs_Access(ssimfilt_field_curs &curs);
bool                 ssimfilt_ReadFieldMaybe(command::ssimfilt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ssimfilt from attributes of ascii tuple TUPLE
bool                 ssimfilt_ReadTupleMaybe(command::ssimfilt &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ssimfilt_Init(command::ssimfilt& parent);
void                 ssimfilt_Uninit(command::ssimfilt& parent) __attribute__((nothrow));
// print command-line args of command::ssimfilt to string  -- cprint:command.ssimfilt.Argv
void                 ssimfilt_PrintArgv(command::ssimfilt & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ssimfilt_ToCmdline(command::ssimfilt & row) __attribute__((nothrow));
algo::strptr         ssimfilt_GetAnon(command::ssimfilt &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  ssimfilt_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.ssimfilt_proc
struct ssimfilt_proc { // command.ssimfilt_proc: Subprocess: Tuple utility
    algo::cstring       path;      //   "bin/ssimfilt"  path for executable
    command::ssimfilt   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    ssimfilt_proc();
    ~ssimfilt_proc();
private:
    // reftype Exec of command.ssimfilt_proc.ssimfilt prohibits copy
    // value field command.ssimfilt_proc.cmd is not copiable
    ssimfilt_proc(const ssimfilt_proc&){ /*disallow copy constructor */}
    void operator =(const ssimfilt_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ssimfilt_Start(command::ssimfilt_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ssimfilt_StartRead(command::ssimfilt_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ssimfilt_Kill(command::ssimfilt_proc& parent);
// Wait for subprocess to return
void                 ssimfilt_Wait(command::ssimfilt_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ssimfilt_Exec(command::ssimfilt_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ssimfilt_ExecX(command::ssimfilt_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ssimfilt.Argv
int                  ssimfilt_Execv(command::ssimfilt_proc& parent) __attribute__((nothrow));
algo::tempstr        ssimfilt_ToCmdline(command::ssimfilt_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ssimfilt_proc_Init(command::ssimfilt_proc& parent);
void                 ssimfilt_proc_Uninit(command::ssimfilt_proc& parent) __attribute__((nothrow));

// --- command.strconv
// access: command.strconv_proc.strconv (Exec)
struct strconv { // command.strconv
    algo::cstring       str;            // String parameter
    bool                tocamelcase;    //   false  Convert string to camel case
    bool                tolowerunder;   //   false  Convert string to lower-under
    algo::cstring       in;             //   "data"  Input directory or filename, - for stdin
    algo::Smallstr100   pathcomp;       //   ""  Extract path component from string
    strconv();
};

bool                 strconv_ReadFieldMaybe(command::strconv &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::strconv from attributes of ascii tuple TUPLE
bool                 strconv_ReadTupleMaybe(command::strconv &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 strconv_Init(command::strconv& parent);
// print command-line args of command::strconv to string  -- cprint:command.strconv.Argv
void                 strconv_PrintArgv(command::strconv & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              strconv_ToCmdline(command::strconv & row) __attribute__((nothrow));
algo::strptr         strconv_GetAnon(command::strconv &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  strconv_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.strconv_proc
struct strconv_proc { // command.strconv_proc: Subprocess: A simple string utility
    algo::cstring      path;      //   "bin/strconv"  path for executable
    command::strconv   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    strconv_proc();
    ~strconv_proc();
private:
    // reftype Exec of command.strconv_proc.strconv prohibits copy
    strconv_proc(const strconv_proc&){ /*disallow copy constructor */}
    void operator =(const strconv_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  strconv_Start(command::strconv_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         strconv_StartRead(command::strconv_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 strconv_Kill(command::strconv_proc& parent);
// Wait for subprocess to return
void                 strconv_Wait(command::strconv_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  strconv_Exec(command::strconv_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 strconv_ExecX(command::strconv_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:strconv.Argv
int                  strconv_Execv(command::strconv_proc& parent) __attribute__((nothrow));
algo::tempstr        strconv_ToCmdline(command::strconv_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 strconv_proc_Init(command::strconv_proc& parent);
void                 strconv_proc_Uninit(command::strconv_proc& parent) __attribute__((nothrow));

// --- command.sv2ssim
// access: command.sv2ssim_proc.sv2ssim (Exec)
struct sv2ssim { // command.sv2ssim
    algo::cstring    in;              //   "data"  Input directory or filename, - for stdin
    algo::cstring    fname;           // Input file, use - for stdin
    char             separator;       //   ','  Input field separator
    algo::cstring    outseparator;    //   ""  Output separator. Default: ssim
    bool             header;          //   true  File has header line
    algo::cstring    ctype;           //   ""  Type tag for output tuples
    algo::cstring    ssimfile;        //   ""  (with -schema) Create ssimfile definition
    bool             schema;          //   false  (output)Generate schema from input file
    algo_lib::Regx   field;           //   "%"  Sql Regx
    bool             data;            //   false  (output) Convert input file to ssim tuples
    bool             report;          //   true  Print final report
    bool             prefer_signed;   //   false  Prefer signed types when given a choice
    sv2ssim();
private:
    // reftype Regx of command.sv2ssim.field prohibits copy
    sv2ssim(const sv2ssim&){ /*disallow copy constructor */}
    void operator =(const sv2ssim&){ /*disallow direct assignment */}
};

// Print back to string
void                 field_Print(command::sv2ssim& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 field_ReadStrptrMaybe(command::sv2ssim& parent, algo::strptr in) __attribute__((nothrow));

bool                 sv2ssim_ReadFieldMaybe(command::sv2ssim &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::sv2ssim from attributes of ascii tuple TUPLE
bool                 sv2ssim_ReadTupleMaybe(command::sv2ssim &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 sv2ssim_Init(command::sv2ssim& parent);
// print command-line args of command::sv2ssim to string  -- cprint:command.sv2ssim.Argv
void                 sv2ssim_PrintArgv(command::sv2ssim & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              sv2ssim_ToCmdline(command::sv2ssim & row) __attribute__((nothrow));
algo::strptr         sv2ssim_GetAnon(command::sv2ssim &parent, i32 idx) __attribute__((nothrow));
// Used with command lines
// Return # of command-line arguments that must follow this argument
// If FIELD is invalid, return -1
i32                  sv2ssim_NArgs(command::FieldId field, algo::strptr& out_dflt, bool* out_anon) __attribute__((nothrow));

// --- command.sv2ssim_proc
struct sv2ssim_proc { // command.sv2ssim_proc: Subprocess: sv2ssim - Separated Value file processor
    algo::cstring      path;      //   "bin/sv2ssim"  path for executable
    command::sv2ssim   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    sv2ssim_proc();
    ~sv2ssim_proc();
private:
    // reftype Exec of command.sv2ssim_proc.sv2ssim prohibits copy
    // value field command.sv2ssim_proc.cmd is not copiable
    sv2ssim_proc(const sv2ssim_proc&){ /*disallow copy constructor */}
    void operator =(const sv2ssim_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  sv2ssim_Start(command::sv2ssim_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         sv2ssim_StartRead(command::sv2ssim_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 sv2ssim_Kill(command::sv2ssim_proc& parent);
// Wait for subprocess to return
void                 sv2ssim_Wait(command::sv2ssim_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  sv2ssim_Exec(command::sv2ssim_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 sv2ssim_ExecX(command::sv2ssim_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:sv2ssim.Argv
int                  sv2ssim_Execv(command::sv2ssim_proc& parent) __attribute__((nothrow));
algo::tempstr        sv2ssim_ToCmdline(command::sv2ssim_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 sv2ssim_proc_Init(command::sv2ssim_proc& parent);
void                 sv2ssim_proc_Uninit(command::sv2ssim_proc& parent) __attribute__((nothrow));
} // gen:ns_print_struct
namespace command { // gen:ns_curstext

struct acr_where_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    acr_where_curs() { elems=NULL; n_elems=0; index=0; }
};


struct acr_field_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    acr_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct acr_dm_arg_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    acr_dm_arg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct atf_cmdline_mstr_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    atf_cmdline_mstr_curs() { elems=NULL; n_elems=0; index=0; }
};


struct atf_cmdline_mnum_curs {// cursor
    typedef i32 ChildType;
    i32* elems;
    int n_elems;
    int index;
    atf_cmdline_mnum_curs() { elems=NULL; n_elems=0; index=0; }
};


struct atf_cmdline_mdbl_curs {// cursor
    typedef double ChildType;
    double* elems;
    int n_elems;
    int index;
    atf_cmdline_mdbl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct atf_cmdline_amnum_curs {// cursor
    typedef i32 ChildType;
    i32* elems;
    int n_elems;
    int index;
    atf_cmdline_amnum_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gcache_cmd_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    gcache_cmd_curs() { elems=NULL; n_elems=0; index=0; }
};


struct gcli_fields_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    gcli_fields_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mdbg_args_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    mdbg_args_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mdbg_b_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    mdbg_b_curs() { elems=NULL; n_elems=0; index=0; }
};


struct sandbox_cmd_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    sandbox_cmd_curs() { elems=NULL; n_elems=0; index=0; }
};


struct sandbox_files_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    sandbox_files_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ssimfilt_match_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    ssimfilt_match_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ssimfilt_field_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    ssimfilt_field_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace command { // gen:ns_func
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const command::FieldId &row);// cfmt:command.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const command::acr_compl &row);// cfmt:command.acr_compl.String
inline algo::cstring &operator <<(algo::cstring &str, const command::gcache &row);// cfmt:command.gcache.String
}
