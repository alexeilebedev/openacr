//
// include/gen/command_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- command_FieldIdEnum

enum command_FieldIdEnum {                    // command.FieldId.value
     command_FieldId_target            = 0
    ,command_FieldId_in                = 1
    ,command_FieldId_out_dir           = 2
    ,command_FieldId_cfg               = 3
    ,command_FieldId_compiler          = 4
    ,command_FieldId_uname             = 5
    ,command_FieldId_arch              = 6
    ,command_FieldId_ood               = 7
    ,command_FieldId_list              = 8
    ,command_FieldId_listincl          = 9
    ,command_FieldId_build             = 10
    ,command_FieldId_preproc           = 11
    ,command_FieldId_clean             = 12
    ,command_FieldId_dry_run           = 13
    ,command_FieldId_maxjobs           = 14
    ,command_FieldId_printcmd          = 15
    ,command_FieldId_force             = 16
    ,command_FieldId_install           = 17
    ,command_FieldId_coverity          = 18
    ,command_FieldId_package           = 19
    ,command_FieldId_maxerr            = 20
    ,command_FieldId_disas             = 21
    ,command_FieldId_report            = 22
    ,command_FieldId_jcdb              = 23
    ,command_FieldId_query             = 24
    ,command_FieldId_select            = 25
    ,command_FieldId_del               = 26
    ,command_FieldId_insert            = 27
    ,command_FieldId_replace           = 28
    ,command_FieldId_merge             = 29
    ,command_FieldId_unused            = 30
    ,command_FieldId_trunc             = 31
    ,command_FieldId_check             = 32
    ,command_FieldId_maxshow           = 33
    ,command_FieldId_write             = 34
    ,command_FieldId_rename            = 35
    ,command_FieldId_nup               = 36
    ,command_FieldId_ndown             = 37
    ,command_FieldId_xref              = 38
    ,command_FieldId_fldfunc           = 39
    ,command_FieldId_maxgroup          = 40
    ,command_FieldId_pretty            = 41
    ,command_FieldId_tree              = 42
    ,command_FieldId_loose             = 43
    ,command_FieldId_my                = 44
    ,command_FieldId_schema            = 45
    ,command_FieldId_e                 = 46
    ,command_FieldId_b                 = 47
    ,command_FieldId_t                 = 48
    ,command_FieldId_rowid             = 49
    ,command_FieldId_cmt               = 50
    ,command_FieldId_print             = 51
    ,command_FieldId_cmd               = 52
    ,command_FieldId_field             = 53
    ,command_FieldId_regxof            = 54
    ,command_FieldId_meta              = 55
    ,command_FieldId_line              = 56
    ,command_FieldId_point             = 57
    ,command_FieldId_type              = 58
    ,command_FieldId_debug_log         = 59
    ,command_FieldId_create            = 60
    ,command_FieldId_finput            = 61
    ,command_FieldId_foutput           = 62
    ,command_FieldId_srcfile           = 63
    ,command_FieldId_gstatic           = 64
    ,command_FieldId_indexed           = 65
    ,command_FieldId_nstype            = 66
    ,command_FieldId_ctype             = 67
    ,command_FieldId_pooltype          = 68
    ,command_FieldId_ssimfile          = 69
    ,command_FieldId_subset            = 70
    ,command_FieldId_subset2           = 71
    ,command_FieldId_separator         = 72
    ,command_FieldId_arg               = 73
    ,command_FieldId_dflt              = 74
    ,command_FieldId_anon              = 75
    ,command_FieldId_bigend            = 76
    ,command_FieldId_cascdel           = 77
    ,command_FieldId_before            = 78
    ,command_FieldId_substr            = 79
    ,command_FieldId_srcfield          = 80
    ,command_FieldId_fstep             = 81
    ,command_FieldId_inscond           = 82
    ,command_FieldId_reftype           = 83
    ,command_FieldId_hashfld           = 84
    ,command_FieldId_sortfld           = 85
    ,command_FieldId_unittest          = 86
    ,command_FieldId_citest            = 87
    ,command_FieldId_cppfunc           = 88
    ,command_FieldId_via               = 89
    ,command_FieldId_comment           = 90
    ,command_FieldId_sandbox           = 91
    ,command_FieldId_test              = 92
    ,command_FieldId_showcpp           = 93
    ,command_FieldId_msgtype           = 94
    ,command_FieldId_anonfld           = 95
    ,command_FieldId_ns                = 96
    ,command_FieldId_data              = 97
    ,command_FieldId_sigcheck          = 98
    ,command_FieldId_data_dir          = 99
    ,command_FieldId_related           = 100
    ,command_FieldId_notssimfile       = 101
    ,command_FieldId_checkable         = 102
    ,command_FieldId_nsdb              = 103
    ,command_FieldId_fkey              = 104
    ,command_FieldId_start             = 105
    ,command_FieldId_stop              = 106
    ,command_FieldId_abort             = 107
    ,command_FieldId_shell             = 108
    ,command_FieldId_serv              = 109
    ,command_FieldId_in_dir            = 110
    ,command_FieldId_proto             = 111
    ,command_FieldId_trace             = 112
    ,command_FieldId_fconst            = 113
    ,command_FieldId_gconst            = 114
    ,command_FieldId_key               = 115
    ,command_FieldId_include           = 116
    ,command_FieldId_dot               = 117
    ,command_FieldId_xns               = 118
    ,command_FieldId_noinput           = 119
    ,command_FieldId_render            = 120
    ,command_FieldId_id                = 121
    ,command_FieldId_file_prefix       = 122
    ,command_FieldId_nchild            = 123
    ,command_FieldId_blocking          = 124
    ,command_FieldId_nmsg              = 125
    ,command_FieldId_timeout           = 126
    ,command_FieldId_recvdelay_ns      = 127
    ,command_FieldId_senddelay_ns      = 128
    ,command_FieldId_msgsize_min       = 129
    ,command_FieldId_msgsize_max       = 130
    ,command_FieldId_bufsize           = 131
    ,command_FieldId_recvdelay         = 132
    ,command_FieldId_amctest           = 133
    ,command_FieldId_dofork            = 134
    ,command_FieldId_q                 = 135
    ,command_FieldId_cijob             = 136
    ,command_FieldId_capture           = 137
    ,command_FieldId_skipenv           = 138
    ,command_FieldId_comptest          = 139
    ,command_FieldId_mdbg              = 140
    ,command_FieldId_run               = 141
    ,command_FieldId_normalize         = 142
    ,command_FieldId_covcapture        = 143
    ,command_FieldId_covcheck          = 144
    ,command_FieldId_compdir           = 145
    ,command_FieldId_check_untracked   = 146
    ,command_FieldId_memcheck          = 147
    ,command_FieldId_callgrind         = 148
    ,command_FieldId_stream            = 149
    ,command_FieldId_i                 = 150
    ,command_FieldId_covdir            = 151
    ,command_FieldId_logfile           = 152
    ,command_FieldId_runcmd            = 153
    ,command_FieldId_exclude           = 154
    ,command_FieldId_mergepath         = 155
    ,command_FieldId_gcov              = 156
    ,command_FieldId_ssim              = 157
    ,command_FieldId_xmlpretty         = 158
    ,command_FieldId_summary           = 159
    ,command_FieldId_ncmd              = 160
    ,command_FieldId_nofork            = 161
    ,command_FieldId_debug             = 162
    ,command_FieldId_perf_secs         = 163
    ,command_FieldId_pertest_timeout   = 164
    ,command_FieldId_issue             = 165
    ,command_FieldId_server            = 166
    ,command_FieldId_project           = 167
    ,command_FieldId_auth_token        = 168
    ,command_FieldId_mrlist            = 169
    ,command_FieldId_mergereq          = 170
    ,command_FieldId_ilist             = 171
    ,command_FieldId_istart            = 172
    ,command_FieldId_iadd              = 173
    ,command_FieldId_ic                = 174
    ,command_FieldId_iclose            = 175
    ,command_FieldId_iassignto         = 176
    ,command_FieldId_title             = 177
    ,command_FieldId_description       = 178
    ,command_FieldId_gitdir            = 179
    ,command_FieldId_assignee          = 180
    ,command_FieldId_ulist             = 181
    ,command_FieldId_mraccept          = 182
    ,command_FieldId_mslist            = 183
    ,command_FieldId_milestone         = 184
    ,command_FieldId_imilestone        = 185
    ,command_FieldId_track             = 186
    ,command_FieldId_complooo          = 187
    ,command_FieldId_args              = 188
    ,command_FieldId_manywin           = 189
    ,command_FieldId_attach            = 190
    ,command_FieldId_catchthrow        = 191
    ,command_FieldId_tui               = 192
    ,command_FieldId_bcmd              = 193
    ,command_FieldId_emacs             = 194
    ,command_FieldId_follow_child      = 195
    ,command_FieldId_py                = 196
    ,command_FieldId_writessimfile     = 197
    ,command_FieldId_url               = 198
    ,command_FieldId_tables            = 199
    ,command_FieldId_nologo            = 200
    ,command_FieldId_baddbok           = 201
    ,command_FieldId_typetag           = 202
    ,command_FieldId_move              = 203
    ,command_FieldId_dedup             = 204
    ,command_FieldId_commit            = 205
    ,command_FieldId_undo              = 206
    ,command_FieldId_hash              = 207
    ,command_FieldId_targsrc           = 208
    ,command_FieldId_name              = 209
    ,command_FieldId_body              = 210
    ,command_FieldId_func              = 211
    ,command_FieldId_nextfile          = 212
    ,command_FieldId_other             = 213
    ,command_FieldId_updateproto       = 214
    ,command_FieldId_listfunc          = 215
    ,command_FieldId_iffy              = 216
    ,command_FieldId_gen               = 217
    ,command_FieldId_showloc           = 218
    ,command_FieldId_showstatic        = 219
    ,command_FieldId_showsortkey       = 220
    ,command_FieldId_sortname          = 221
    ,command_FieldId_baddecl           = 222
    ,command_FieldId_update_authors    = 223
    ,command_FieldId_indent            = 224
    ,command_FieldId_linelim           = 225
    ,command_FieldId_strayfile         = 226
    ,command_FieldId_badchar           = 227
    ,command_FieldId_badline           = 228
    ,command_FieldId_expand            = 229
    ,command_FieldId_ignoreQuote       = 230
    ,command_FieldId_maxpacket         = 231
    ,command_FieldId_db                = 232
    ,command_FieldId_createdb          = 233
    ,command_FieldId_str               = 234
    ,command_FieldId_tocamelcase       = 235
    ,command_FieldId_tolowerunder      = 236
    ,command_FieldId_pathcomp          = 237
    ,command_FieldId_value             = 238
};

enum { command_FieldIdEnum_N = 239 };

namespace command { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace command { // gen:ns_field
} // gen:ns_field
// gen:ns_fwddecl2
namespace command { struct FieldId; }
namespace command { struct Protocol; }
namespace command { struct abt; }
namespace command { struct abt_proc; }
namespace command { struct acr; }
namespace command { struct acr_compl; }
namespace command { struct acr_compl_proc; }
namespace command { struct acr_ed; }
namespace command { struct acr_ed_proc; }
namespace command { struct acr_in; }
namespace command { struct acr_in_proc; }
namespace command { struct acr_my; }
namespace command { struct acr_my_proc; }
namespace command { struct acr_proc; }
namespace command { struct amc; }
namespace command { struct amc_dml; }
namespace command { struct amc_gc; }
namespace command { struct amc_gc_proc; }
namespace command { struct amc_proc; }
namespace command { struct amc_vis; }
namespace command { struct amc_vis_proc; }
namespace command { struct ams_cat; }
namespace command { struct ams_cat_proc; }
namespace command { struct ams_sendtest; }
namespace command { struct ams_sendtest_proc; }
namespace command { struct atf_amc; }
namespace command { struct atf_amc_proc; }
namespace command { struct atf_ci; }
namespace command { struct atf_ci_proc; }
namespace command { struct atf_comp; }
namespace command { struct atf_comp_proc; }
namespace command { struct atf_cov; }
namespace command { struct atf_cov_proc; }
namespace command { struct atf_nrun; }
namespace command { struct atf_nrun_proc; }
namespace command { struct atf_unit; }
namespace command { struct atf_unit_proc; }
namespace command { struct bash; }
namespace command { struct bash2html; }
namespace command { struct bash2html_proc; }
namespace command { struct bash_proc; }
namespace command { struct gitlab; }
namespace command { struct gitlab_proc; }
namespace command { struct lib_ctype; }
namespace command { struct lib_exec; }
namespace command { struct mdbg; }
namespace command { struct mdbg_proc; }
namespace command { struct mysql2ssim; }
namespace command { struct mysql2ssim_proc; }
namespace command { struct ntup; }
namespace command { struct ntup_proc; }
namespace command { struct orgfile; }
namespace command { struct orgfile_proc; }
namespace command { struct src_func; }
namespace command { struct src_func_proc; }
namespace command { struct src_hdr; }
namespace command { struct src_hdr_proc; }
namespace command { struct src_lim; }
namespace command { struct src_lim_proc; }
namespace command { struct ssim2csv; }
namespace command { struct ssim2csv_proc; }
namespace command { struct ssim2mysql; }
namespace command { struct ssim2mysql_proc; }
namespace command { struct strconv; }
namespace command { struct strconv_proc; }
namespace command { // gen:ns_print_struct

// --- command.FieldId
#pragma pack(push,1)
struct FieldId { // command.FieldId: Field read helper
    i32   value;   //   -1
    inline operator command_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(command_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
command_FieldIdEnum  value_GetEnum(const command::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(command::FieldId& parent, command_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const command::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const command::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(command::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(command::FieldId& parent, algo::strptr rhs, command_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(command::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of command::FieldId from an ascii string.
// The format of the string is the format of the command::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(command::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(command::FieldId& parent);
// print string representation of command::FieldId to string LHS, no header -- cprint:command.FieldId.String
void                 FieldId_Print(command::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- command.Protocol
// access: command.Protocol.proto (Protocol)
#pragma pack(push,1)
struct Protocol { // command.Protocol: amc-generated struct for internal purposes
    Protocol();
};
#pragma pack(pop)

void                 StaticCheck();


// --- command.abt
// access: command.abt_proc.abt (Exec)
struct abt { // command.abt
    algo_lib::Regx     target;     //   ""  Regx of dev::Target
    algo::cstring      in;         //   "data"  Root of input ssim dir
    algo::cstring      out_dir;    //   ""  Output directory
    algo::Smallstr50   cfg;        //   ""  Set config
    algo::Smallstr50   compiler;   //   ""  Set compiler.
    algo::Smallstr50   uname;      //   ""  Set uname (default: guess)
    algo::Smallstr50   arch;       //   ""  Set architecture (default: guess)
    bool               ood;        //   false  List out-of-date source files
    bool               list;       //   false  List target files
    bool               listincl;   //   false  List includes
    bool               build;      //   false  If set, build specified target (all necessary steps)
    bool               preproc;    //   false  Preprocess file, produce .i file
    bool               clean;      //   false  Delete all output files
    bool               dry_run;    //   false  Print actions, do not perform
    i32                maxjobs;    //   0  Maximum number of child build processes. 0=pick good default
    bool               printcmd;   //   false  Print commands. Do not execute
    bool               force;      //   false  Assume all files are out-of-date
    bool               install;    //   false  Update soft-link under bin/
    bool               coverity;   //   false  Run abt in coverity mode
    algo::cstring      package;    //   ""  Package tag
    u32                maxerr;     //   100  Max failing commands before rest of pipeline is forced to fail
    algo_lib::Regx     disas;      //   ""  Regx of algo::cstring
    bool               report;     //   true  Print final report
    algo::cstring      jcdb;       //   ""  Create JSON compilation database in specified file
    abt();
};

// Print back to string
void                 target_Print(command::abt& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 target_ReadStrptrMaybe(command::abt& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 disas_Print(command::abt& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 disas_ReadStrptrMaybe(command::abt& parent, algo::strptr in) __attribute__((nothrow));

bool                 abt_ReadFieldMaybe(command::abt &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::abt from attributes of ascii tuple TUPLE
bool                 abt_ReadTupleMaybe(command::abt &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 abt_Init(command::abt& parent);
// print command-line args of command::abt to string  -- cprint:command.abt.Argv
void                 abt_PrintArgv(command::abt & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              abt_ToCmdline(command::abt & row) __attribute__((nothrow));
algo::strptr         abt_GetAnon(command::abt &parent, i32 idx) __attribute__((nothrow));

// --- command.abt_proc
struct abt_proc { // command.abt_proc: Subprocess: Algo Build Tool (build system)
    algo::cstring   path;      //   "bin/abt"  path for executable
    command::abt    cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    abt_proc();
    ~abt_proc();
private:
    // reftype of command.abt_proc.abt prohibits copy
    abt_proc(const abt_proc&){ /*disallow copy constructor */}
    void operator =(const abt_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  abt_Start(command::abt_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         abt_StartRead(command::abt_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 abt_Kill(command::abt_proc& parent);
// Wait for subprocess to return
void                 abt_Wait(command::abt_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  abt_Exec(command::abt_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 abt_ExecX(command::abt_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:abt.Argv
int                  abt_Execv(command::abt_proc& parent) __attribute__((nothrow));
algo::tempstr        abt_ToCmdline(command::abt_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 abt_proc_Init(command::abt_proc& parent);
void                 abt_proc_Uninit(command::abt_proc& parent) __attribute__((nothrow));

// --- command.acr
// access: command.acr_proc.acr (Exec)
struct acr { // command.acr
    algo::cstring   query;      //   ""  Regx to match record
    bool            select;     //   true  Select records matching query (default)
    bool            del;        //   false  Delete found item
    bool            insert;     //   false  Read input and insert tuples
    bool            replace;    //   false  Read stdin and replace tuples
    bool            merge;      //   false  Like replace, but merge tuple attributes
    bool            unused;     //   false  Only select records which are not referenced.
    bool            trunc;      //   false  (with insert or rename): truncate table on first write
    bool            check;      //   false  Run cross-reference check on selection
    i32             maxshow;    //   100  Limit number of errors per table
    bool            write;      //   false  Write data back to disk.
    algo::cstring   rename;     //   ""  Change value of found item
    i32             nup;        //   0  Number of levels to go up
    i32             ndown;      //   0  Number of levels to go down
    bool            xref;       //   false  Short for -nup 100 -ndown 100
    bool            fldfunc;    //   false  Evaluate fldfunc when printing tuple
    i32             maxgroup;   //   25  Max. items per group
    bool            pretty;     //   true  Align output in blocks
    bool            tree;       //   false  Print as tree
    bool            loose;      //   false  Allow printing a record before its references (used with -e)
    bool            my;         //   false  Invoke acr_my -e (using acr_my directly is faster)
    algo::cstring   schema;     //   "data"  Directory for initializing acr meta-data
    bool            e;          //   false  Open selection in editor, write back when done.
    bool            b;          //   false  Short for -serve 0.0.0.0:6769; start browser.
    bool            t;          //   false  Short for -tree -xref -loose
    bool            rowid;      //   false  Print/respect acr.rowid attribute
    algo::cstring   in;         //   "data"  Input directory or filename, - for stdin
    bool            cmt;        //   false  Print comments for all columns referenced in output
    bool            report;     //   true  Show final report
    bool            print;      //   true  Print selected records
    algo::cstring   cmd;        //   ""  Print script with command execution for each selected row
    algo::cstring   field;      //   ""  Comma-separated list of fields to select
    algo::cstring   regxof;     //   ""  Single field: output regx of matching field values
    bool            meta;       //   false  Select meta-data for selected records
    acr();
};

bool                 acr_ReadFieldMaybe(command::acr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr from attributes of ascii tuple TUPLE
bool                 acr_ReadTupleMaybe(command::acr &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_Init(command::acr& parent);
// print command-line args of command::acr to string  -- cprint:command.acr.Argv
void                 acr_PrintArgv(command::acr & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_ToCmdline(command::acr & row) __attribute__((nothrow));
algo::strptr         acr_GetAnon(command::acr &parent, i32 idx) __attribute__((nothrow));

// --- command.acr_compl
// access: command.acr_compl_proc.acr_compl (Exec)
struct acr_compl { // command.acr_compl
    algo::cstring   line;        //   ""  Simulates COMP_LINE (debug)
    algo::cstring   point;       //   ""  Simulates COMP_POINT (debug). default: whole line
    algo::cstring   type;        //   "9"  Simulates COMP_TYPE (debug)
    bool            install;     //   false  Produce bash commands to install the handler
    algo::cstring   debug_log;   //   ""  Log file for debug information, overrides ACR_COMPL_DEBUG_LOG
    acr_compl();
};

bool                 acr_compl_ReadFieldMaybe(command::acr_compl &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_compl from attributes of ascii tuple TUPLE
bool                 acr_compl_ReadTupleMaybe(command::acr_compl &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_compl_Init(command::acr_compl& parent);
// print command-line args of command::acr_compl to string  -- cprint:command.acr_compl.Argv
void                 acr_compl_PrintArgv(command::acr_compl & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_compl_ToCmdline(command::acr_compl & row) __attribute__((nothrow));

// --- command.acr_compl_proc
struct acr_compl_proc { // command.acr_compl_proc: Subprocess: ACR shell auto-complete for all targets
    algo::cstring        path;      //   "bin/acr_compl"  path for executable
    command::acr_compl   cmd;       // command line for child process
    algo::cstring        fstdin;    // redirect for stdin
    algo::cstring        fstdout;   // redirect for stdout
    algo::cstring        fstderr;   // redirect for stderr
    pid_t                pid;       //   0  pid of running child process
    i32                  timeout;   //   0  optional timeout for child process
    i32                  status;    //   0  last exit status of child process
    acr_compl_proc();
    ~acr_compl_proc();
private:
    // reftype of command.acr_compl_proc.acr_compl prohibits copy
    acr_compl_proc(const acr_compl_proc&){ /*disallow copy constructor */}
    void operator =(const acr_compl_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_compl_Start(command::acr_compl_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_compl_StartRead(command::acr_compl_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_compl_Kill(command::acr_compl_proc& parent);
// Wait for subprocess to return
void                 acr_compl_Wait(command::acr_compl_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_compl_Exec(command::acr_compl_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_compl_ExecX(command::acr_compl_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_compl.Argv
int                  acr_compl_Execv(command::acr_compl_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_compl_ToCmdline(command::acr_compl_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_compl_proc_Init(command::acr_compl_proc& parent);
void                 acr_compl_proc_Uninit(command::acr_compl_proc& parent) __attribute__((nothrow));

// --- command.acr_ed
// access: command.acr_ed_proc.acr_ed (Exec)
struct acr_ed { // command.acr_ed
    algo::cstring       in;          //   "data"  Input directory or filename, - for stdin
    bool                create;      //   false  Create new entity (-finput, -target, -ctype, -field)
    bool                del;         //   false  Delete mode
    algo::cstring       rename;      //   ""  Rename to something else
    bool                replace;     //   false  Use acr -replace (default is -insert, fails on duplicate)
    bool                finput;      //   false  Create in-memory table based on ssimfile
    bool                foutput;     //   false  Declare field as an output
    algo::cstring       srcfile;     //   ""      Create source file
    bool                gstatic;     //   false  Like -finput, but data is loaded at compile time
    bool                indexed;     //   false  (with -finput) Add hash index
    algo::Smallstr16    target;      //   ""  Create new target
    algo::Smallstr50    nstype;      //   "exe"  (with -create -target): exe,lib,etc.
    algo::Smallstr50    ctype;       //   ""  Create new ctype
    algo::Smallstr50    pooltype;    //   ""   Pool reftype (Lary,Lpool etc) for finput/ctype
    algo::Smallstr50    ssimfile;    //   ""    Ssimfile for new ctype
    algo::Smallstr50    subset;      //   ""    Primary key is a subset of this ctype
    algo::Smallstr50    subset2;     //   ""    Primary key is also a subset of this ctype
    algo::cstring       separator;   //   "."      Key separator
    algo::Smallstr100   field;       //   ""  Create field
    algo::Smallstr50    arg;         //   ""    Field type (e.g. u32, etc), (with -ctype) add the base field
    algo::cstring       dflt;        //   ""    Field default value
    bool                anon;        //   false    Anonymous field (use with command lines)
    bool                bigend;      //   false    Big-endian field
    bool                cascdel;     //   false    Field is cascdel
    algo::Smallstr100   before;      //   ""    Place field before this one
    algo::Smallstr100   substr;      //   ""    New field is a substring
    algo::Smallstr100   srcfield;    //   ""    Source field for bitfld/substr
    algo::Smallstr100   fstep;       //   ""    Add fstep record
    algo::cstring       inscond;     //   "true"    Insert condition (for xref)
    algo::Smallstr50    reftype;     //   ""    Reftype (e.g. Val, Thash, Llist, etc)
    algo::Smallstr100   hashfld;     //   ""      (-reftype:Thash) Hash field
    algo::Smallstr100   sortfld;     //   ""      (-reftype:Bheap) Sort field
    algo::cstring       unittest;    //   ""  Create unit test, <ns>.<functionname>
    algo::cstring       citest;      //   ""  Create CI test
    algo::cstring       cppfunc;     //   ""  Field is a cppfunc, pass c++ expression as argument
    bool                xref;        //   false      X-ref with field type
    algo::cstring       via;         //   ""        X-ref argument (index, pointer, or index/key)
    bool                write;       //   false  Commit output to disk
    bool                e;           //   false   (with -create -unittest) Edit new testcase
    algo::cstring       comment;     //   ""  Comment for new entity
    bool                sandbox;     //   false  Make changes in sandbox
    bool                test;        //   false  Build resulting changes, run tests
    bool                showcpp;     //   false  (With -sandbox), show resulting diff
    algo::cstring       msgtype;     //   ""  (with -ctype) use this msgtype as type
    bool                anonfld;     //   false  Create anonfld
    acr_ed();
};

bool                 acr_ed_ReadFieldMaybe(command::acr_ed &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_ed from attributes of ascii tuple TUPLE
bool                 acr_ed_ReadTupleMaybe(command::acr_ed &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_ed_Init(command::acr_ed& parent);
// print command-line args of command::acr_ed to string  -- cprint:command.acr_ed.Argv
void                 acr_ed_PrintArgv(command::acr_ed & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_ed_ToCmdline(command::acr_ed & row) __attribute__((nothrow));

// --- command.acr_ed_proc
struct acr_ed_proc { // command.acr_ed_proc: Subprocess: ACR Editor Set of useful recipes, uses acr, abt, git, and other tools
    algo::cstring     path;      //   "bin/acr_ed"  path for executable
    command::acr_ed   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_ed_proc();
    ~acr_ed_proc();
private:
    // reftype of command.acr_ed_proc.acr_ed prohibits copy
    acr_ed_proc(const acr_ed_proc&){ /*disallow copy constructor */}
    void operator =(const acr_ed_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_ed_Start(command::acr_ed_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_ed_StartRead(command::acr_ed_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_ed_Kill(command::acr_ed_proc& parent);
// Wait for subprocess to return
void                 acr_ed_Wait(command::acr_ed_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_ed_Exec(command::acr_ed_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_ed_ExecX(command::acr_ed_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_ed.Argv
int                  acr_ed_Execv(command::acr_ed_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_ed_ToCmdline(command::acr_ed_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_ed_proc_Init(command::acr_ed_proc& parent);
void                 acr_ed_proc_Uninit(command::acr_ed_proc& parent) __attribute__((nothrow));

// --- command.acr_in
// access: command.acr_in_proc.acr_in (Exec)
struct acr_in { // command.acr_in
    algo_lib::Regx   ns;            // Regx of dmmeta::Ns
    bool             data;          //   false  List ssimfile contents
    bool             sigcheck;      //   true  Output sigcheck records for schema version mismatch detection
    bool             list;          //   false  List ssimfile names
    algo::cstring    data_dir;      //   "data"  Directory with ssimfiles
    algo::cstring    schema;        //   "data"
    algo::cstring    related;       //   ""  Select only tuples related to specified acr key
    algo_lib::Regx   notssimfile;   //   ""  Regx of dmmeta::Ssimfile
    bool             checkable;     //   false  Ensure output passes acr -check
    acr_in();
};

// Print back to string
void                 ns_Print(command::acr_in& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ns_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 notssimfile_Print(command::acr_in& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 notssimfile_ReadStrptrMaybe(command::acr_in& parent, algo::strptr in) __attribute__((nothrow));

bool                 acr_in_ReadFieldMaybe(command::acr_in &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_in from attributes of ascii tuple TUPLE
bool                 acr_in_ReadTupleMaybe(command::acr_in &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_in_Init(command::acr_in& parent);
// print command-line args of command::acr_in to string  -- cprint:command.acr_in.Argv
void                 acr_in_PrintArgv(command::acr_in & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_in_ToCmdline(command::acr_in & row) __attribute__((nothrow));
algo::strptr         acr_in_GetAnon(command::acr_in &parent, i32 idx) __attribute__((nothrow));

// --- command.acr_in_proc
struct acr_in_proc { // command.acr_in_proc: Subprocess: ACR Input - compute set of ssimfiles or tuples used by a specific target
    algo::cstring     path;      //   "bin/acr_in"  path for executable
    command::acr_in   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_in_proc();
    ~acr_in_proc();
private:
    // reftype of command.acr_in_proc.acr_in prohibits copy
    acr_in_proc(const acr_in_proc&){ /*disallow copy constructor */}
    void operator =(const acr_in_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_in_Start(command::acr_in_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_in_StartRead(command::acr_in_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_in_Kill(command::acr_in_proc& parent);
// Wait for subprocess to return
void                 acr_in_Wait(command::acr_in_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_in_Exec(command::acr_in_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_in_ExecX(command::acr_in_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_in.Argv
int                  acr_in_Execv(command::acr_in_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_in_ToCmdline(command::acr_in_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_in_proc_Init(command::acr_in_proc& parent);
void                 acr_in_proc_Uninit(command::acr_in_proc& parent) __attribute__((nothrow));

// --- command.acr_my
// access: command.acr_my_proc.acr_my (Exec)
struct acr_my { // command.acr_my
    algo_lib::Regx   nsdb;      //   ""  Regx of dmmeta::Nsdb
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo::cstring    schema;    //   "data"  Input directory or filename, - for stdin
    bool             fldfunc;   //   false  Evaluate fldfunc when printing tuple
    bool             fkey;      //   false  Enable foreign key constraints
    bool             e;         //   false  Alias for -start -shell -stop
    bool             start;     //   false  Start local mysql server
    bool             stop;      //   false  Stop local mysql server, saving data
    bool             abort;     //   false  Abort local mysql server, losing data
    bool             shell;     //   false  Connect to local mysql server
    bool             serv;      //   false  Start mysql with TCP/IP service enabled
    acr_my();
};

// Print back to string
void                 nsdb_Print(command::acr_my& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 nsdb_ReadStrptrMaybe(command::acr_my& parent, algo::strptr in) __attribute__((nothrow));

bool                 acr_my_ReadFieldMaybe(command::acr_my &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::acr_my from attributes of ascii tuple TUPLE
bool                 acr_my_ReadTupleMaybe(command::acr_my &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 acr_my_Init(command::acr_my& parent);
// print command-line args of command::acr_my to string  -- cprint:command.acr_my.Argv
void                 acr_my_PrintArgv(command::acr_my & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              acr_my_ToCmdline(command::acr_my & row) __attribute__((nothrow));
algo::strptr         acr_my_GetAnon(command::acr_my &parent, i32 idx) __attribute__((nothrow));

// --- command.acr_my_proc
struct acr_my_proc { // command.acr_my_proc: Subprocess: ACR <-> MariaDB adaptor
    algo::cstring     path;      //   "bin/acr_my"  path for executable
    command::acr_my   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    acr_my_proc();
    ~acr_my_proc();
private:
    // reftype of command.acr_my_proc.acr_my prohibits copy
    acr_my_proc(const acr_my_proc&){ /*disallow copy constructor */}
    void operator =(const acr_my_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_my_Start(command::acr_my_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_my_StartRead(command::acr_my_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_my_Kill(command::acr_my_proc& parent);
// Wait for subprocess to return
void                 acr_my_Wait(command::acr_my_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_my_Exec(command::acr_my_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_my_ExecX(command::acr_my_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr_my.Argv
int                  acr_my_Execv(command::acr_my_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_my_ToCmdline(command::acr_my_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_my_proc_Init(command::acr_my_proc& parent);
void                 acr_my_proc_Uninit(command::acr_my_proc& parent) __attribute__((nothrow));

// --- command.acr_proc
struct acr_proc { // command.acr_proc: Subprocess: Algo Cross-Reference - ssimfile database & update tool
    algo::cstring   path;      //   "bin/acr"  path for executable
    command::acr    cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    acr_proc();
    ~acr_proc();
private:
    // reftype of command.acr_proc.acr prohibits copy
    acr_proc(const acr_proc&){ /*disallow copy constructor */}
    void operator =(const acr_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_Start(command::acr_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         acr_StartRead(command::acr_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_Kill(command::acr_proc& parent);
// Wait for subprocess to return
void                 acr_Wait(command::acr_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_Exec(command::acr_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_ExecX(command::acr_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:acr.Argv
int                  acr_Execv(command::acr_proc& parent) __attribute__((nothrow));
algo::tempstr        acr_ToCmdline(command::acr_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 acr_proc_Init(command::acr_proc& parent);
void                 acr_proc_Uninit(command::acr_proc& parent) __attribute__((nothrow));

// --- command.amc
// access: command.amc_proc.amc (Exec)
struct amc { // command.amc
    algo::cstring    in_dir;    //   "data"  Root of input ssim dir
    algo::cstring    query;     //   ""  Query mode: generate code for specified object
    algo::cstring    out_dir;   //   "."  Root of output cpp dir
    bool             proto;     //   false  Print prototype
    bool             report;    //   true  Final report
    bool             e;         //   false  Open matching records in editor
    algo_lib::Regx   trace;     //   ""  Regx of algo::cstring
    amc();
};

// Print back to string
void                 trace_Print(command::amc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 trace_ReadStrptrMaybe(command::amc& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_ReadFieldMaybe(command::amc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc from attributes of ascii tuple TUPLE
bool                 amc_ReadTupleMaybe(command::amc &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_Init(command::amc& parent);
// print command-line args of command::amc to string  -- cprint:command.amc.Argv
void                 amc_PrintArgv(command::amc & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_ToCmdline(command::amc & row) __attribute__((nothrow));
algo::strptr         amc_GetAnon(command::amc &parent, i32 idx) __attribute__((nothrow));

// --- command.amc_dml
struct amc_dml { // command.amc_dml
    algo_lib::Regx   ns;       //   "%"  Regx of algo::cstring
    bool             fconst;   //   true  append fconst list at the end
    bool             gconst;   //   true  append gconst list at the end
    algo::cstring    in;       //   "data"  Input directory or filename, - for stdin
    amc_dml();
};

// Print back to string
void                 ns_Print(command::amc_dml& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ns_ReadStrptrMaybe(command::amc_dml& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_dml_ReadFieldMaybe(command::amc_dml &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc_dml from attributes of ascii tuple TUPLE
bool                 amc_dml_ReadTupleMaybe(command::amc_dml &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_dml_Init(command::amc_dml& parent);
// print command-line args of command::amc_dml to string  -- cprint:command.amc_dml.Argv
void                 amc_dml_PrintArgv(command::amc_dml & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_dml_ToCmdline(command::amc_dml & row) __attribute__((nothrow));

// --- command.amc_gc
// access: command.amc_gc_proc.amc_gc (Exec)
struct amc_gc { // command.amc_gc
    algo_lib::Regx   target;    //   "%"  Regx of dev::Target
    algo_lib::Regx   key;       //   ""  Regx of algo::cstring
    bool             include;   //   false  Garbage collect includes for specified target
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    amc_gc();
};

// Print back to string
void                 target_Print(command::amc_gc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 target_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 key_Print(command::amc_gc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 key_ReadStrptrMaybe(command::amc_gc& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_gc_ReadFieldMaybe(command::amc_gc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc_gc from attributes of ascii tuple TUPLE
bool                 amc_gc_ReadTupleMaybe(command::amc_gc &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_gc_Init(command::amc_gc& parent);
// print command-line args of command::amc_gc to string  -- cprint:command.amc_gc.Argv
void                 amc_gc_PrintArgv(command::amc_gc & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_gc_ToCmdline(command::amc_gc & row) __attribute__((nothrow));

// --- command.amc_gc_proc
struct amc_gc_proc { // command.amc_gc_proc: Subprocess: Empirically eliminate unused records
    algo::cstring     path;      //   "bin/amc_gc"  path for executable
    command::amc_gc   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    amc_gc_proc();
    ~amc_gc_proc();
private:
    // reftype of command.amc_gc_proc.amc_gc prohibits copy
    amc_gc_proc(const amc_gc_proc&){ /*disallow copy constructor */}
    void operator =(const amc_gc_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  amc_gc_Start(command::amc_gc_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         amc_gc_StartRead(command::amc_gc_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 amc_gc_Kill(command::amc_gc_proc& parent);
// Wait for subprocess to return
void                 amc_gc_Wait(command::amc_gc_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  amc_gc_Exec(command::amc_gc_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 amc_gc_ExecX(command::amc_gc_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:amc_gc.Argv
int                  amc_gc_Execv(command::amc_gc_proc& parent) __attribute__((nothrow));
algo::tempstr        amc_gc_ToCmdline(command::amc_gc_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 amc_gc_proc_Init(command::amc_gc_proc& parent);
void                 amc_gc_proc_Uninit(command::amc_gc_proc& parent) __attribute__((nothrow));

// --- command.amc_proc
struct amc_proc { // command.amc_proc: Subprocess: Algo Model Compiler: generate code under include/gen and cpp/gen
    algo::cstring   path;      //   "bin/amc"  path for executable
    command::amc    cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    amc_proc();
    ~amc_proc();
private:
    // reftype of command.amc_proc.amc prohibits copy
    amc_proc(const amc_proc&){ /*disallow copy constructor */}
    void operator =(const amc_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  amc_Start(command::amc_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         amc_StartRead(command::amc_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 amc_Kill(command::amc_proc& parent);
// Wait for subprocess to return
void                 amc_Wait(command::amc_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  amc_Exec(command::amc_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 amc_ExecX(command::amc_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:amc.Argv
int                  amc_Execv(command::amc_proc& parent) __attribute__((nothrow));
algo::tempstr        amc_ToCmdline(command::amc_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 amc_proc_Init(command::amc_proc& parent);
void                 amc_proc_Uninit(command::amc_proc& parent) __attribute__((nothrow));

// --- command.amc_vis
// access: command.amc_vis_proc.amc_vis (Exec)
struct amc_vis { // command.amc_vis
    algo_lib::Regx   ctype;     //   "%"  Regx of dmmeta::Ctype
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo::cstring    dot;       //   ""  Save dot file with specified filename
    bool             xref;      //   false  Include all ctypes referenced by selected ones
    bool             xns;       //   false  Cross namespace boundaries
    bool             noinput;   //   false  Deselect module inputs
    bool             check;     //   false  Check model for dependency problems
    bool             render;    //   true  Produce an ascii drawing
    amc_vis();
};

// Print back to string
void                 ctype_Print(command::amc_vis& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 ctype_ReadStrptrMaybe(command::amc_vis& parent, algo::strptr in) __attribute__((nothrow));

bool                 amc_vis_ReadFieldMaybe(command::amc_vis &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::amc_vis from attributes of ascii tuple TUPLE
bool                 amc_vis_ReadTupleMaybe(command::amc_vis &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 amc_vis_Init(command::amc_vis& parent);
// print command-line args of command::amc_vis to string  -- cprint:command.amc_vis.Argv
void                 amc_vis_PrintArgv(command::amc_vis & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              amc_vis_ToCmdline(command::amc_vis & row) __attribute__((nothrow));
algo::strptr         amc_vis_GetAnon(command::amc_vis &parent, i32 idx) __attribute__((nothrow));

// --- command.amc_vis_proc
struct amc_vis_proc { // command.amc_vis_proc: Subprocess: amc: draw access path diagrams
    algo::cstring      path;      //   "bin/amc_vis"  path for executable
    command::amc_vis   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    amc_vis_proc();
    ~amc_vis_proc();
private:
    // reftype of command.amc_vis_proc.amc_vis prohibits copy
    amc_vis_proc(const amc_vis_proc&){ /*disallow copy constructor */}
    void operator =(const amc_vis_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  amc_vis_Start(command::amc_vis_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         amc_vis_StartRead(command::amc_vis_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 amc_vis_Kill(command::amc_vis_proc& parent);
// Wait for subprocess to return
void                 amc_vis_Wait(command::amc_vis_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  amc_vis_Exec(command::amc_vis_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 amc_vis_ExecX(command::amc_vis_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:amc_vis.Argv
int                  amc_vis_Execv(command::amc_vis_proc& parent) __attribute__((nothrow));
algo::tempstr        amc_vis_ToCmdline(command::amc_vis_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 amc_vis_proc_Init(command::amc_vis_proc& parent);
void                 amc_vis_proc_Uninit(command::amc_vis_proc& parent) __attribute__((nothrow));

// --- command.ams_cat
// access: command.ams_cat_proc.ams_cat (Exec)
struct ams_cat { // command.ams_cat
    algo::cstring   in;   //   "data"  Input directory or filename, - for stdin
    ams_cat();
};

bool                 ams_cat_ReadFieldMaybe(command::ams_cat &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ams_cat from attributes of ascii tuple TUPLE
bool                 ams_cat_ReadTupleMaybe(command::ams_cat &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ams_cat_Init(command::ams_cat& parent);
// print command-line args of command::ams_cat to string  -- cprint:command.ams_cat.Argv
void                 ams_cat_PrintArgv(command::ams_cat & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ams_cat_ToCmdline(command::ams_cat & row) __attribute__((nothrow));

// --- command.ams_cat_proc
struct ams_cat_proc { // command.ams_cat_proc: Subprocess: 
    algo::cstring      path;      //   "bin/ams_cat"  path for executable
    command::ams_cat   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    ams_cat_proc();
    ~ams_cat_proc();
private:
    // reftype of command.ams_cat_proc.ams_cat prohibits copy
    ams_cat_proc(const ams_cat_proc&){ /*disallow copy constructor */}
    void operator =(const ams_cat_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ams_cat_Start(command::ams_cat_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ams_cat_StartRead(command::ams_cat_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ams_cat_Kill(command::ams_cat_proc& parent);
// Wait for subprocess to return
void                 ams_cat_Wait(command::ams_cat_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ams_cat_Exec(command::ams_cat_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ams_cat_ExecX(command::ams_cat_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ams_cat.Argv
int                  ams_cat_Execv(command::ams_cat_proc& parent) __attribute__((nothrow));
algo::tempstr        ams_cat_ToCmdline(command::ams_cat_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ams_cat_proc_Init(command::ams_cat_proc& parent);
void                 ams_cat_proc_Uninit(command::ams_cat_proc& parent) __attribute__((nothrow));

// --- command.ams_sendtest
// access: command.ams_sendtest_proc.ams_sendtest (Exec)
struct ams_sendtest { // command.ams_sendtest
    algo::cstring    in;             //   "data"  Input directory or filename, - for stdin
    i32              id;             //   0  Process index (0=parent)
    algo::cstring    file_prefix;    //   ""  Use file_prefix
    i32              nchild;         //   1  Number of stream readers
    bool             blocking;       //   false  Use blocking send mode
    i32              nmsg;           //   1000  Number of messages to send/receive
    algo_lib::Regx   trace;          //   ""  Regx of algo::cstring
    i32              timeout;        //   30  Time limit for the send
    i64              recvdelay_ns;   //   0  Pause nanoseconds between messages
    i64              senddelay_ns;   //   0  Pause nanoseconds between messages
    i32              msgsize_min;    //   64  Minimum message length
    i32              msgsize_max;    //   1024  Maximum message length
    i32              bufsize;        //   32768  Shared memory buffer size
    i64              recvdelay;      //   0  Pause nanoseconds between messages
    ams_sendtest();
};

// Print back to string
void                 trace_Print(command::ams_sendtest& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 trace_ReadStrptrMaybe(command::ams_sendtest& parent, algo::strptr in) __attribute__((nothrow));

bool                 ams_sendtest_ReadFieldMaybe(command::ams_sendtest &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ams_sendtest from attributes of ascii tuple TUPLE
bool                 ams_sendtest_ReadTupleMaybe(command::ams_sendtest &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ams_sendtest_Init(command::ams_sendtest& parent);
// print command-line args of command::ams_sendtest to string  -- cprint:command.ams_sendtest.Argv
void                 ams_sendtest_PrintArgv(command::ams_sendtest & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ams_sendtest_ToCmdline(command::ams_sendtest & row) __attribute__((nothrow));

// --- command.ams_sendtest_proc
struct ams_sendtest_proc { // command.ams_sendtest_proc: Subprocess: 
    algo::cstring           path;      //   "bin/ams_sendtest"  path for executable
    command::ams_sendtest   cmd;       // command line for child process
    algo::cstring           fstdin;    // redirect for stdin
    algo::cstring           fstdout;   // redirect for stdout
    algo::cstring           fstderr;   // redirect for stderr
    pid_t                   pid;       //   0  pid of running child process
    i32                     timeout;   //   0  optional timeout for child process
    i32                     status;    //   0  last exit status of child process
    ams_sendtest_proc();
    ~ams_sendtest_proc();
private:
    // reftype of command.ams_sendtest_proc.ams_sendtest prohibits copy
    ams_sendtest_proc(const ams_sendtest_proc&){ /*disallow copy constructor */}
    void operator =(const ams_sendtest_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ams_sendtest_Start(command::ams_sendtest_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ams_sendtest_StartRead(command::ams_sendtest_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ams_sendtest_Kill(command::ams_sendtest_proc& parent);
// Wait for subprocess to return
void                 ams_sendtest_Wait(command::ams_sendtest_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ams_sendtest_Exec(command::ams_sendtest_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ams_sendtest_ExecX(command::ams_sendtest_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ams_sendtest.Argv
int                  ams_sendtest_Execv(command::ams_sendtest_proc& parent) __attribute__((nothrow));
algo::tempstr        ams_sendtest_ToCmdline(command::ams_sendtest_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ams_sendtest_proc_Init(command::ams_sendtest_proc& parent);
void                 ams_sendtest_proc_Uninit(command::ams_sendtest_proc& parent) __attribute__((nothrow));

// --- command.atf_amc
// access: command.atf_amc_proc.atf_amc (Exec)
struct atf_amc { // command.atf_amc
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   amctest;   //   "%"  Regx of atfdb::Amctest
    bool             dofork;    //   true  Use fork
    bool             q;         //   false  Quiet mode
    atf_amc();
};

// Print back to string
void                 amctest_Print(command::atf_amc& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 amctest_ReadStrptrMaybe(command::atf_amc& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_amc_ReadFieldMaybe(command::atf_amc &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_amc from attributes of ascii tuple TUPLE
bool                 atf_amc_ReadTupleMaybe(command::atf_amc &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_amc_Init(command::atf_amc& parent);
// print command-line args of command::atf_amc to string  -- cprint:command.atf_amc.Argv
void                 atf_amc_PrintArgv(command::atf_amc & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_amc_ToCmdline(command::atf_amc & row) __attribute__((nothrow));
algo::strptr         atf_amc_GetAnon(command::atf_amc &parent, i32 idx) __attribute__((nothrow));

// --- command.atf_amc_proc
struct atf_amc_proc { // command.atf_amc_proc: Subprocess: Unit tests for amc (see amctest table)
    algo::cstring      path;      //   "bin/atf_amc"  path for executable
    command::atf_amc   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    atf_amc_proc();
    ~atf_amc_proc();
private:
    // reftype of command.atf_amc_proc.atf_amc prohibits copy
    atf_amc_proc(const atf_amc_proc&){ /*disallow copy constructor */}
    void operator =(const atf_amc_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_amc_Start(command::atf_amc_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_amc_StartRead(command::atf_amc_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_amc_Kill(command::atf_amc_proc& parent);
// Wait for subprocess to return
void                 atf_amc_Wait(command::atf_amc_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_amc_Exec(command::atf_amc_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_amc_ExecX(command::atf_amc_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_amc.Argv
int                  atf_amc_Execv(command::atf_amc_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_amc_ToCmdline(command::atf_amc_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_amc_proc_Init(command::atf_amc_proc& parent);
void                 atf_amc_proc_Uninit(command::atf_amc_proc& parent) __attribute__((nothrow));

// --- command.atf_ci
// access: command.atf_ci_proc.atf_ci (Exec)
struct atf_ci { // command.atf_ci
    algo::cstring    in;        //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   citest;    //   "%"  Regx of atfdb::Citest
    i32              maxerr;    //   0  Exit after this many errors
    algo_lib::Regx   cijob;     //   "%"  Regx of atfdb::Cijob
    bool             capture;   //   false  Capture the output of the test
    bool             skipenv;   //   false  Do not run prepenv for any test
    atf_ci();
};

// Print back to string
void                 citest_Print(command::atf_ci& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 citest_ReadStrptrMaybe(command::atf_ci& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 cijob_Print(command::atf_ci& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 cijob_ReadStrptrMaybe(command::atf_ci& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_ci_ReadFieldMaybe(command::atf_ci &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_ci from attributes of ascii tuple TUPLE
bool                 atf_ci_ReadTupleMaybe(command::atf_ci &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_ci_Init(command::atf_ci& parent);
// print command-line args of command::atf_ci to string  -- cprint:command.atf_ci.Argv
void                 atf_ci_PrintArgv(command::atf_ci & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_ci_ToCmdline(command::atf_ci & row) __attribute__((nothrow));
algo::strptr         atf_ci_GetAnon(command::atf_ci &parent, i32 idx) __attribute__((nothrow));

// --- command.atf_ci_proc
struct atf_ci_proc { // command.atf_ci_proc: Subprocess: Normalization tests (see citest table)
    algo::cstring     path;      //   "bin/atf_ci"  path for executable
    command::atf_ci   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    atf_ci_proc();
    ~atf_ci_proc();
private:
    // reftype of command.atf_ci_proc.atf_ci prohibits copy
    atf_ci_proc(const atf_ci_proc&){ /*disallow copy constructor */}
    void operator =(const atf_ci_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_ci_Start(command::atf_ci_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_ci_StartRead(command::atf_ci_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_ci_Kill(command::atf_ci_proc& parent);
// Wait for subprocess to return
void                 atf_ci_Wait(command::atf_ci_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_ci_Exec(command::atf_ci_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_ci_ExecX(command::atf_ci_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_ci.Argv
int                  atf_ci_Execv(command::atf_ci_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_ci_ToCmdline(command::atf_ci_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_ci_proc_Init(command::atf_ci_proc& parent);
void                 atf_ci_proc_Uninit(command::atf_ci_proc& parent) __attribute__((nothrow));

// --- command.atf_comp
// access: command.atf_comp_proc.atf_comp (Exec)
struct atf_comp { // command.atf_comp
    algo::cstring      in;                //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx     comptest;          //   "%"  Regx of atfdb::Comptest
    bool               mdbg;              //   false  (action) Run component test under debugger
    bool               run;               //   true  (action) Run selected component tests
    bool               capture;           //   false  (action) Re-capture test results
    bool               print;             //   false  (action) Print testcase
    bool               e;                 //   false  (action) Open selected testcases in an editor
    bool               normalize;         //   false  (action) Renumber and normalize tmsgs
    bool               covcapture;        //   false  (action) Capture new coverage percentages and save back
    bool               covcheck;          //   false  (action) Check coverage percentages against tgtcov table
    algo::cstring      compdir;           //   ""  Component image directory (exe)
    algo::Smallstr50   cfg;               //   "release"  Set config
    bool               check_untracked;   //   true  Check for untracked file before allowing test to run
    i32                maxerr;            //   1  Exit after this many errors
    bool               build;             //   false  Build given cfg before test
    bool               ood;               //   false  Check given cfg for ood before test
    bool               memcheck;          //   false  Run under memory checker (valgrind)
    bool               force;             //   false  (With -memcheck) run suppressed memcheck
    bool               callgrind;         //   false  Run under callgrind profiler (valgrind)
    i32                maxjobs;           //   1  Maximum number of tests run in parallel
    bool               stream;            //   false  prints component's output
    bool               i;                 //   false  Read and execute testcase from stdin
    bool               write;             //   true  (implied with -e) Write any changes back to ssim tables
    bool               report;            //   false  Print final report
    algo::cstring      b;                 //   ""  Breakpoint passed to mdbg as-is
    atf_comp();
};

// Print back to string
void                 comptest_Print(command::atf_comp& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 comptest_ReadStrptrMaybe(command::atf_comp& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_comp_ReadFieldMaybe(command::atf_comp &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_comp from attributes of ascii tuple TUPLE
bool                 atf_comp_ReadTupleMaybe(command::atf_comp &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_comp_Init(command::atf_comp& parent);
// print command-line args of command::atf_comp to string  -- cprint:command.atf_comp.Argv
void                 atf_comp_PrintArgv(command::atf_comp & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_comp_ToCmdline(command::atf_comp & row) __attribute__((nothrow));
algo::strptr         atf_comp_GetAnon(command::atf_comp &parent, i32 idx) __attribute__((nothrow));

// --- command.atf_comp_proc
struct atf_comp_proc { // command.atf_comp_proc: Subprocess: 
    algo::cstring       path;      //   "bin/atf_comp"  path for executable
    command::atf_comp   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_comp_proc();
    ~atf_comp_proc();
private:
    // reftype of command.atf_comp_proc.atf_comp prohibits copy
    atf_comp_proc(const atf_comp_proc&){ /*disallow copy constructor */}
    void operator =(const atf_comp_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_comp_Start(command::atf_comp_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_comp_StartRead(command::atf_comp_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_comp_Kill(command::atf_comp_proc& parent);
// Wait for subprocess to return
void                 atf_comp_Wait(command::atf_comp_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_comp_Exec(command::atf_comp_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_comp_ExecX(command::atf_comp_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_comp.Argv
int                  atf_comp_Execv(command::atf_comp_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_comp_ToCmdline(command::atf_comp_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_comp_proc_Init(command::atf_comp_proc& parent);
void                 atf_comp_proc_Uninit(command::atf_comp_proc& parent) __attribute__((nothrow));

// --- command.atf_cov
// access: command.atf_cov_proc.atf_cov (Exec)
struct atf_cov { // command.atf_cov
    algo::cstring    in;          //   "data"  Input directory or filename, - for stdin
    algo::cstring    covdir;      //   "temp/covdata"  Output directory to save coverage data
    algo::cstring    logfile;     //   ""  Log file
    algo::cstring    runcmd;      //   ""  command to run
    algo_lib::Regx   exclude;     //   "(extern|include/gen|cpp/gen)/%"  Regx of dev::Gitfile
    algo::cstring    mergepath;   //   ""  colon-separated dir list to load .cov.ssim files from
    bool             gcov;        //   false  run gcov
    bool             ssim;        //   false  write out ssim files
    bool             report;      //   false  write out all reports
    bool             capture;     //   false  Write coverage information into tgtcov table
    bool             xmlpretty;   //   false  Generate pretty-formatted XML
    bool             summary;     //   true  Show summary figures
    bool             check;       //   false  Check coverage information against tgtcov table
    atf_cov();
};

// Print back to string
void                 exclude_Print(command::atf_cov& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 exclude_ReadStrptrMaybe(command::atf_cov& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_cov_ReadFieldMaybe(command::atf_cov &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_cov from attributes of ascii tuple TUPLE
bool                 atf_cov_ReadTupleMaybe(command::atf_cov &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_cov_Init(command::atf_cov& parent);
// print command-line args of command::atf_cov to string  -- cprint:command.atf_cov.Argv
void                 atf_cov_PrintArgv(command::atf_cov & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_cov_ToCmdline(command::atf_cov & row) __attribute__((nothrow));

// --- command.atf_cov_proc
struct atf_cov_proc { // command.atf_cov_proc: Subprocess: 
    algo::cstring      path;      //   "bin/atf_cov"  path for executable
    command::atf_cov   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    atf_cov_proc();
    ~atf_cov_proc();
private:
    // reftype of command.atf_cov_proc.atf_cov prohibits copy
    atf_cov_proc(const atf_cov_proc&){ /*disallow copy constructor */}
    void operator =(const atf_cov_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_cov_Start(command::atf_cov_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_cov_StartRead(command::atf_cov_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_cov_Kill(command::atf_cov_proc& parent);
// Wait for subprocess to return
void                 atf_cov_Wait(command::atf_cov_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_cov_Exec(command::atf_cov_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_cov_ExecX(command::atf_cov_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_cov.Argv
int                  atf_cov_Execv(command::atf_cov_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_cov_ToCmdline(command::atf_cov_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_cov_proc_Init(command::atf_cov_proc& parent);
void                 atf_cov_proc_Uninit(command::atf_cov_proc& parent) __attribute__((nothrow));

// --- command.atf_nrun
// access: command.atf_nrun_proc.atf_nrun (Exec)
struct atf_nrun { // command.atf_nrun
    algo::cstring   in;        //   "data"  Input directory or filename, - for stdin
    i32             maxjobs;   //   2  Number of simultaneous jobs
    i32             ncmd;      //   6
    atf_nrun();
};

bool                 atf_nrun_ReadFieldMaybe(command::atf_nrun &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_nrun from attributes of ascii tuple TUPLE
bool                 atf_nrun_ReadTupleMaybe(command::atf_nrun &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_nrun_Init(command::atf_nrun& parent);
// print command-line args of command::atf_nrun to string  -- cprint:command.atf_nrun.Argv
void                 atf_nrun_PrintArgv(command::atf_nrun & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_nrun_ToCmdline(command::atf_nrun & row) __attribute__((nothrow));
algo::strptr         atf_nrun_GetAnon(command::atf_nrun &parent, i32 idx) __attribute__((nothrow));

// --- command.atf_nrun_proc
struct atf_nrun_proc { // command.atf_nrun_proc: Subprocess: 
    algo::cstring       path;      //   "bin/atf_nrun"  path for executable
    command::atf_nrun   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_nrun_proc();
    ~atf_nrun_proc();
private:
    // reftype of command.atf_nrun_proc.atf_nrun prohibits copy
    atf_nrun_proc(const atf_nrun_proc&){ /*disallow copy constructor */}
    void operator =(const atf_nrun_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_nrun_Start(command::atf_nrun_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_nrun_StartRead(command::atf_nrun_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_nrun_Kill(command::atf_nrun_proc& parent);
// Wait for subprocess to return
void                 atf_nrun_Wait(command::atf_nrun_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_nrun_Exec(command::atf_nrun_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_nrun_ExecX(command::atf_nrun_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_nrun.Argv
int                  atf_nrun_Execv(command::atf_nrun_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_nrun_ToCmdline(command::atf_nrun_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_nrun_proc_Init(command::atf_nrun_proc& parent);
void                 atf_nrun_proc_Uninit(command::atf_nrun_proc& parent) __attribute__((nothrow));

// --- command.atf_unit
// access: command.atf_unit_proc.atf_unit (Exec)
struct atf_unit { // command.atf_unit
    algo_lib::Regx   unittest;          //   "%"  Regx of atfdb::Unittest
    bool             nofork;            //   false  Do not fork for destructive tests
    algo::cstring    arg;               //   ""  Argument to pass to tool
    algo::cstring    data_dir;          //   "data"  Data directory
    bool             debug;             //   0  Break at testcase in debugger
    double           perf_secs;         //   1.0  # Of seconds to run perf tests for
    u32              pertest_timeout;   //   900  Max runtime of any individual unit test
    bool             report;            //   true  Print final report
    bool             capture;           //   false  Re-capture test results
    bool             check_untracked;   //   true  Check for untracked file before allowing test to run
    atf_unit();
};

// Print back to string
void                 unittest_Print(command::atf_unit& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 unittest_ReadStrptrMaybe(command::atf_unit& parent, algo::strptr in) __attribute__((nothrow));

bool                 atf_unit_ReadFieldMaybe(command::atf_unit &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::atf_unit from attributes of ascii tuple TUPLE
bool                 atf_unit_ReadTupleMaybe(command::atf_unit &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 atf_unit_Init(command::atf_unit& parent);
// print command-line args of command::atf_unit to string  -- cprint:command.atf_unit.Argv
void                 atf_unit_PrintArgv(command::atf_unit & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              atf_unit_ToCmdline(command::atf_unit & row) __attribute__((nothrow));
algo::strptr         atf_unit_GetAnon(command::atf_unit &parent, i32 idx) __attribute__((nothrow));

// --- command.atf_unit_proc
struct atf_unit_proc { // command.atf_unit_proc: Subprocess: Unit tests (see unittest table)
    algo::cstring       path;      //   "bin/atf_unit"  path for executable
    command::atf_unit   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    atf_unit_proc();
    ~atf_unit_proc();
private:
    // reftype of command.atf_unit_proc.atf_unit prohibits copy
    atf_unit_proc(const atf_unit_proc&){ /*disallow copy constructor */}
    void operator =(const atf_unit_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  atf_unit_Start(command::atf_unit_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         atf_unit_StartRead(command::atf_unit_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 atf_unit_Kill(command::atf_unit_proc& parent);
// Wait for subprocess to return
void                 atf_unit_Wait(command::atf_unit_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  atf_unit_Exec(command::atf_unit_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 atf_unit_ExecX(command::atf_unit_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:atf_unit.Argv
int                  atf_unit_Execv(command::atf_unit_proc& parent) __attribute__((nothrow));
algo::tempstr        atf_unit_ToCmdline(command::atf_unit_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 atf_unit_proc_Init(command::atf_unit_proc& parent);
void                 atf_unit_proc_Uninit(command::atf_unit_proc& parent) __attribute__((nothrow));

// --- command.bash
// access: command.bash_proc.bash (Exec)
struct bash { // command.bash: One way of invoking the shell
    algo::cstring   c;   //   ""  Shell command to execute
    bash();
};

// Set all fields to initial values.
void                 bash_Init(command::bash& parent);
// print command-line args of command::bash to string  -- cprint:command.bash.Argv
void                 bash_PrintArgv(command::bash & row, algo::cstring &str) __attribute__((nothrow));

// --- command.bash2html
// access: command.bash2html_proc.bash2html (Exec)
struct bash2html { // command.bash2html
    algo::cstring   in;     //   "data"  Input directory or filename, - for stdin
    bool            test;   //   false  Produce Test Output
    bash2html();
};

bool                 bash2html_ReadFieldMaybe(command::bash2html &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::bash2html from attributes of ascii tuple TUPLE
bool                 bash2html_ReadTupleMaybe(command::bash2html &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 bash2html_Init(command::bash2html& parent);
// print command-line args of command::bash2html to string  -- cprint:command.bash2html.Argv
void                 bash2html_PrintArgv(command::bash2html & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              bash2html_ToCmdline(command::bash2html & row) __attribute__((nothrow));

// --- command.bash2html_proc
struct bash2html_proc { // command.bash2html_proc: Subprocess: Convert bash output and colours to html
    algo::cstring        path;      //   "bin/bash2html"  path for executable
    command::bash2html   cmd;       // command line for child process
    algo::cstring        fstdin;    // redirect for stdin
    algo::cstring        fstdout;   // redirect for stdout
    algo::cstring        fstderr;   // redirect for stderr
    pid_t                pid;       //   0  pid of running child process
    i32                  timeout;   //   0  optional timeout for child process
    i32                  status;    //   0  last exit status of child process
    bash2html_proc();
    ~bash2html_proc();
private:
    // reftype of command.bash2html_proc.bash2html prohibits copy
    bash2html_proc(const bash2html_proc&){ /*disallow copy constructor */}
    void operator =(const bash2html_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  bash2html_Start(command::bash2html_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         bash2html_StartRead(command::bash2html_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 bash2html_Kill(command::bash2html_proc& parent);
// Wait for subprocess to return
void                 bash2html_Wait(command::bash2html_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  bash2html_Exec(command::bash2html_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 bash2html_ExecX(command::bash2html_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:bash2html.Argv
int                  bash2html_Execv(command::bash2html_proc& parent) __attribute__((nothrow));
algo::tempstr        bash2html_ToCmdline(command::bash2html_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 bash2html_proc_Init(command::bash2html_proc& parent);
void                 bash2html_proc_Uninit(command::bash2html_proc& parent) __attribute__((nothrow));

// --- command.bash_proc
struct bash_proc { // command.bash_proc: Shell subprocess
    algo::cstring   path;      //   "bash"  path for executable
    command::bash   cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    bash_proc();
    ~bash_proc();
private:
    // reftype of command.bash_proc.bash prohibits copy
    bash_proc(const bash_proc&){ /*disallow copy constructor */}
    void operator =(const bash_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  bash_Start(command::bash_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         bash_StartRead(command::bash_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 bash_Kill(command::bash_proc& parent);
// Wait for subprocess to return
void                 bash_Wait(command::bash_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  bash_Exec(command::bash_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 bash_ExecX(command::bash_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:bash.Argv
int                  bash_Execv(command::bash_proc& parent) __attribute__((nothrow));
algo::tempstr        bash_ToCmdline(command::bash_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 bash_proc_Init(command::bash_proc& parent);
void                 bash_proc_Uninit(command::bash_proc& parent) __attribute__((nothrow));

// --- command.gitlab
// access: command.gitlab_proc.gitlab (Exec)
struct gitlab { // command.gitlab
    algo::cstring       in;            //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx      issue;         //   ""  Regx of algo::cstring
    algo::cstring       server;        //   "gitlab.lon.algo"  (config) GitLab server host
    algo::cstring       project;       //   "algouk"  (config) Project to use
    algo::cstring       auth_token;    //   ""  (config) GitLab auth token
    bool                mrlist;        //   false  (action) Show list of merge requests
    bool                mergereq;      //   false  (action) Push current branch to origin, create merge request
    bool                ilist;         //   false  (action) Show list of issues matching regx
    bool                istart;        //   false  (action) Start working on the specified issue
    bool                t;             //   false  Tree view: expand issue description
    bool                iadd;          //   false  (action) Add new issue
    bool                ic;            //   false  (action) Add issue comment
    bool                iclose;        //   false  (action) Close issue
    algo::Smallstr50    iassignto;     //   ""  (action) Assign issue to user
    algo::cstring       title;         //   ""  (with -iadd), skip editor and use argument as title
    algo::cstring       description;   //   ""  (with -iadd -title), use argument as description
    algo::cstring       comment;       //   ""  (with -ic), skip editor and use argument as comment
    algo::cstring       gitdir;        //   ""  (setup) Change directory of dit repository
    algo_lib::Regx      assignee;      //   ""  Regx of algo::cstring
    bool                ulist;         //   false  (action) List users
    algo::cstring       mraccept;      //   ""  (action) Accept merge request
    bool                mslist;        //   false  (action) List milestones
    algo_lib::Regx      milestone;     //   "%"  Regx of algo::cstring
    algo::Smallstr200   imilestone;    //   ""  (action) Assign issue to milestone
    algo::cstring       track;         //   "origin/master"
    gitlab();
};

// Print back to string
void                 issue_Print(command::gitlab& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 issue_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 assignee_Print(command::gitlab& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 assignee_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 milestone_Print(command::gitlab& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 milestone_ReadStrptrMaybe(command::gitlab& parent, algo::strptr in) __attribute__((nothrow));

bool                 gitlab_ReadFieldMaybe(command::gitlab &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::gitlab from attributes of ascii tuple TUPLE
bool                 gitlab_ReadTupleMaybe(command::gitlab &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 gitlab_Init(command::gitlab& parent);
// print command-line args of command::gitlab to string  -- cprint:command.gitlab.Argv
void                 gitlab_PrintArgv(command::gitlab & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              gitlab_ToCmdline(command::gitlab & row) __attribute__((nothrow));
algo::strptr         gitlab_GetAnon(command::gitlab &parent, i32 idx) __attribute__((nothrow));

// --- command.gitlab_proc
struct gitlab_proc { // command.gitlab_proc: Subprocess: Gitlab command line interface
    algo::cstring     path;      //   "bin/gitlab"  path for executable
    command::gitlab   cmd;       // command line for child process
    algo::cstring     fstdin;    // redirect for stdin
    algo::cstring     fstdout;   // redirect for stdout
    algo::cstring     fstderr;   // redirect for stderr
    pid_t             pid;       //   0  pid of running child process
    i32               timeout;   //   0  optional timeout for child process
    i32               status;    //   0  last exit status of child process
    gitlab_proc();
    ~gitlab_proc();
private:
    // reftype of command.gitlab_proc.gitlab prohibits copy
    gitlab_proc(const gitlab_proc&){ /*disallow copy constructor */}
    void operator =(const gitlab_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  gitlab_Start(command::gitlab_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         gitlab_StartRead(command::gitlab_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 gitlab_Kill(command::gitlab_proc& parent);
// Wait for subprocess to return
void                 gitlab_Wait(command::gitlab_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  gitlab_Exec(command::gitlab_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 gitlab_ExecX(command::gitlab_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:gitlab.Argv
int                  gitlab_Execv(command::gitlab_proc& parent) __attribute__((nothrow));
algo::tempstr        gitlab_ToCmdline(command::gitlab_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 gitlab_proc_Init(command::gitlab_proc& parent);
void                 gitlab_proc_Uninit(command::gitlab_proc& parent) __attribute__((nothrow));

// --- command.lib_ctype
struct lib_ctype { // command.lib_ctype
    algo::cstring   in;   //   "data"  Input directory or filename, - for stdin
    lib_ctype();
};

bool                 lib_ctype_ReadFieldMaybe(command::lib_ctype &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::lib_ctype from attributes of ascii tuple TUPLE
bool                 lib_ctype_ReadTupleMaybe(command::lib_ctype &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 lib_ctype_Init(command::lib_ctype& parent);
// print command-line args of command::lib_ctype to string  -- cprint:command.lib_ctype.Argv
void                 lib_ctype_PrintArgv(command::lib_ctype & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              lib_ctype_ToCmdline(command::lib_ctype & row) __attribute__((nothrow));

// --- command.lib_exec
struct lib_exec { // command.lib_exec
    bool   dry_run;    //   false
    bool   q;          //   true  Do not print node name
    i32    maxjobs;    //   8  Maximum number of parallel jobs
    bool   complooo;   //   false
    lib_exec();
};

bool                 lib_exec_ReadFieldMaybe(command::lib_exec &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::lib_exec from attributes of ascii tuple TUPLE
bool                 lib_exec_ReadTupleMaybe(command::lib_exec &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 lib_exec_Init(command::lib_exec& parent);
// print command-line args of command::lib_exec to string  -- cprint:command.lib_exec.Argv
void                 lib_exec_PrintArgv(command::lib_exec & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              lib_exec_ToCmdline(command::lib_exec & row) __attribute__((nothrow));

// --- command.mdbg
// access: command.mdbg_proc.mdbg (Exec)
struct mdbg { // command.mdbg
    algo::cstring      target;         //   ""  Executable name
    algo::cstring      args;           //   ""  Additional module args
    algo::Smallstr50   cfg;            //   "debug"  Configuration to use
    bool               manywin;        //   false  gdb-many-windows
    bool               disas;          //   false  Show disassembly (use F12)
    bool               attach;         //   false  Attach to a running process
    algo::cstring      b;              //   "main"  List of breakpoints, e.g. 'a.cpp:123 if cond1, func2'
    bool               catchthrow;     //   true  Stop on exceptions
    bool               tui;            //   false  Use gdb -tui as the debugger
    algo::cstring      bcmd;           //   ""  Evaluate command at breakpoint
    bool               emacs;          //   true  Use emacs environment as the debugger
    bool               follow_child;   //   false
    bool               py;             //   false  Enable python scripting
    algo::cstring      in;             //   "data"  Input directory or filename, - for stdin
    mdbg();
};

bool                 mdbg_ReadFieldMaybe(command::mdbg &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::mdbg from attributes of ascii tuple TUPLE
bool                 mdbg_ReadTupleMaybe(command::mdbg &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 mdbg_Init(command::mdbg& parent);
// print command-line args of command::mdbg to string  -- cprint:command.mdbg.Argv
void                 mdbg_PrintArgv(command::mdbg & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              mdbg_ToCmdline(command::mdbg & row) __attribute__((nothrow));
algo::strptr         mdbg_GetAnon(command::mdbg &parent, i32 idx) __attribute__((nothrow));

// --- command.mdbg_proc
struct mdbg_proc { // command.mdbg_proc: Subprocess: My debugger
    algo::cstring   path;      //   "bin/mdbg"  path for executable
    command::mdbg   cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    mdbg_proc();
    ~mdbg_proc();
private:
    // reftype of command.mdbg_proc.mdbg prohibits copy
    mdbg_proc(const mdbg_proc&){ /*disallow copy constructor */}
    void operator =(const mdbg_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  mdbg_Start(command::mdbg_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         mdbg_StartRead(command::mdbg_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 mdbg_Kill(command::mdbg_proc& parent);
// Wait for subprocess to return
void                 mdbg_Wait(command::mdbg_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  mdbg_Exec(command::mdbg_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 mdbg_ExecX(command::mdbg_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:mdbg.Argv
int                  mdbg_Execv(command::mdbg_proc& parent) __attribute__((nothrow));
algo::tempstr        mdbg_ToCmdline(command::mdbg_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 mdbg_proc_Init(command::mdbg_proc& parent);
void                 mdbg_proc_Uninit(command::mdbg_proc& parent) __attribute__((nothrow));

// --- command.mysql2ssim
// access: command.mysql2ssim_proc.mysql2ssim (Exec)
struct mysql2ssim { // command.mysql2ssim
    bool            writessimfile;   //   false  Write to ssimfile directly
    algo::cstring   url;             // user:pass@host/db or sock:///filename/db
    algo::cstring   tables;          //   ""  comma-separated list of tables. Default is all tables
    bool            schema;          //   false  Generate ssim type definition
    algo::cstring   in;              //   "data"  Input directory or filename, - for stdin
    bool            pretty;          //   false  Format output for the screen
    bool            nologo;          //   false  Don't show copyright notice
    bool            baddbok;         //   false  Don't claim if bad database
    mysql2ssim();
};

bool                 mysql2ssim_ReadFieldMaybe(command::mysql2ssim &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::mysql2ssim from attributes of ascii tuple TUPLE
bool                 mysql2ssim_ReadTupleMaybe(command::mysql2ssim &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 mysql2ssim_Init(command::mysql2ssim& parent);
// print command-line args of command::mysql2ssim to string  -- cprint:command.mysql2ssim.Argv
void                 mysql2ssim_PrintArgv(command::mysql2ssim & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              mysql2ssim_ToCmdline(command::mysql2ssim & row) __attribute__((nothrow));
algo::strptr         mysql2ssim_GetAnon(command::mysql2ssim &parent, i32 idx) __attribute__((nothrow));

// --- command.mysql2ssim_proc
struct mysql2ssim_proc { // command.mysql2ssim_proc: Subprocess: mysql -> ssim conversion tool
    algo::cstring         path;      //   "bin/mysql2ssim"  path for executable
    command::mysql2ssim   cmd;       // command line for child process
    algo::cstring         fstdin;    // redirect for stdin
    algo::cstring         fstdout;   // redirect for stdout
    algo::cstring         fstderr;   // redirect for stderr
    pid_t                 pid;       //   0  pid of running child process
    i32                   timeout;   //   0  optional timeout for child process
    i32                   status;    //   0  last exit status of child process
    mysql2ssim_proc();
    ~mysql2ssim_proc();
private:
    // reftype of command.mysql2ssim_proc.mysql2ssim prohibits copy
    mysql2ssim_proc(const mysql2ssim_proc&){ /*disallow copy constructor */}
    void operator =(const mysql2ssim_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  mysql2ssim_Start(command::mysql2ssim_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         mysql2ssim_StartRead(command::mysql2ssim_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 mysql2ssim_Kill(command::mysql2ssim_proc& parent);
// Wait for subprocess to return
void                 mysql2ssim_Wait(command::mysql2ssim_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  mysql2ssim_Exec(command::mysql2ssim_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 mysql2ssim_ExecX(command::mysql2ssim_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:mysql2ssim.Argv
int                  mysql2ssim_Execv(command::mysql2ssim_proc& parent) __attribute__((nothrow));
algo::tempstr        mysql2ssim_ToCmdline(command::mysql2ssim_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 mysql2ssim_proc_Init(command::mysql2ssim_proc& parent);
void                 mysql2ssim_proc_Uninit(command::mysql2ssim_proc& parent) __attribute__((nothrow));

// --- command.ntup
// access: command.ntup_proc.ntup (Exec)
struct ntup { // command.ntup
    algo::cstring      in;        //   "data"  Input directory or filename, - for stdin
    algo::cstring      cmd;       //   ""  Emit command for each tuple
    algo::Smallstr50   field;     // Select and print attribute from incoming tuple
    algo_lib::Regx     typetag;   //   "%"  Regx of algo::cstring
    ntup();
};

// Print back to string
void                 typetag_Print(command::ntup& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 typetag_ReadStrptrMaybe(command::ntup& parent, algo::strptr in) __attribute__((nothrow));

bool                 ntup_ReadFieldMaybe(command::ntup &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ntup from attributes of ascii tuple TUPLE
bool                 ntup_ReadTupleMaybe(command::ntup &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ntup_Init(command::ntup& parent);
// print command-line args of command::ntup to string  -- cprint:command.ntup.Argv
void                 ntup_PrintArgv(command::ntup & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ntup_ToCmdline(command::ntup & row) __attribute__((nothrow));

// --- command.ntup_proc
struct ntup_proc { // command.ntup_proc: Subprocess: Tuple utility
    algo::cstring   path;      //   "bin/ntup"  path for executable
    command::ntup   cmd;       // command line for child process
    algo::cstring   fstdin;    // redirect for stdin
    algo::cstring   fstdout;   // redirect for stdout
    algo::cstring   fstderr;   // redirect for stderr
    pid_t           pid;       //   0  pid of running child process
    i32             timeout;   //   0  optional timeout for child process
    i32             status;    //   0  last exit status of child process
    ntup_proc();
    ~ntup_proc();
private:
    // reftype of command.ntup_proc.ntup prohibits copy
    ntup_proc(const ntup_proc&){ /*disallow copy constructor */}
    void operator =(const ntup_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ntup_Start(command::ntup_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ntup_StartRead(command::ntup_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ntup_Kill(command::ntup_proc& parent);
// Wait for subprocess to return
void                 ntup_Wait(command::ntup_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ntup_Exec(command::ntup_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ntup_ExecX(command::ntup_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ntup.Argv
int                  ntup_Execv(command::ntup_proc& parent) __attribute__((nothrow));
algo::tempstr        ntup_ToCmdline(command::ntup_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ntup_proc_Init(command::ntup_proc& parent);
void                 ntup_proc_Uninit(command::ntup_proc& parent) __attribute__((nothrow));

// --- command.orgfile
// access: command.orgfile_proc.orgfile (Exec)
struct orgfile { // command.orgfile
    algo::cstring    in;       //   "data"  Input directory or filename, - for stdin
    algo::cstring    move;     //   ""  Read stdin, rename files based on pattern
    algo_lib::Regx   dedup;    //   ""  Regx of algo::cstring
    bool             commit;   //   false  Apply changes
    bool             undo;     //   false  Read previous orgfile output, undoing movement
    algo::cstring    hash;     //   "sha1"  Hash command to use for deduplication
    orgfile();
};

// Print back to string
void                 dedup_Print(command::orgfile& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 dedup_ReadStrptrMaybe(command::orgfile& parent, algo::strptr in) __attribute__((nothrow));

bool                 orgfile_ReadFieldMaybe(command::orgfile &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::orgfile from attributes of ascii tuple TUPLE
bool                 orgfile_ReadTupleMaybe(command::orgfile &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 orgfile_Init(command::orgfile& parent);
// print command-line args of command::orgfile to string  -- cprint:command.orgfile.Argv
void                 orgfile_PrintArgv(command::orgfile & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              orgfile_ToCmdline(command::orgfile & row) __attribute__((nothrow));

// --- command.orgfile_proc
struct orgfile_proc { // command.orgfile_proc: Subprocess: OpenACR File deduplicator tool
    algo::cstring      path;      //   "bin/orgfile"  path for executable
    command::orgfile   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    orgfile_proc();
    ~orgfile_proc();
private:
    // reftype of command.orgfile_proc.orgfile prohibits copy
    orgfile_proc(const orgfile_proc&){ /*disallow copy constructor */}
    void operator =(const orgfile_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  orgfile_Start(command::orgfile_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         orgfile_StartRead(command::orgfile_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 orgfile_Kill(command::orgfile_proc& parent);
// Wait for subprocess to return
void                 orgfile_Wait(command::orgfile_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  orgfile_Exec(command::orgfile_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 orgfile_ExecX(command::orgfile_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:orgfile.Argv
int                  orgfile_Execv(command::orgfile_proc& parent) __attribute__((nothrow));
algo::tempstr        orgfile_ToCmdline(command::orgfile_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 orgfile_proc_Init(command::orgfile_proc& parent);
void                 orgfile_proc_Uninit(command::orgfile_proc& parent) __attribute__((nothrow));

// --- command.src_func
// access: command.src_func_proc.src_func (Exec)
struct src_func { // command.src_func
    algo::cstring       in;            //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx      targsrc;       //   "%"  Regx of dev::Targsrc
    algo_lib::Regx      name;          //   "%"  Regx of algo::cstring
    algo_lib::Regx      body;          //   "%"  Regx of algo::cstring
    algo_lib::Regx      func;          //   "%"  Regx of algo::cstring
    algo_lib::Regx      comment;       //   "%"  Regx of algo::cstring
    algo::Smallstr200   nextfile;      //   ""  Print name of next srcfile in targsrc list
    bool                other;         //   false  (with -nextfile), name of previous file
    bool                updateproto;   //   false  Update prototypes in headers
    bool                listfunc;      //   false  Show functions in target
    bool                iffy;          //   false  Select functions that may contain errors
    bool                proto;         //   false  (with -listfunc) List prototypes only
    bool                gen;           //   false  (with -listfunc) Visit generated files
    bool                showloc;       //   true  (with -listfunc) Show file location
    bool                showstatic;    //   true  (with -listfunc) Show static functions
    bool                showsortkey;   //   false  (with -listfunc) Display function sortkey
    bool                sortname;      //   false  (with -listfunc) Sort functions by name
    bool                e;             //   false  (with -listfunc) Edit found functions
    bool                baddecl;       //   false  Report and fail on bad declarations
    bool                report;        //   false
    src_func();
};

// Print back to string
void                 targsrc_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 targsrc_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 name_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 name_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 body_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 body_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 func_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 func_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 comment_Print(command::src_func& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 comment_ReadStrptrMaybe(command::src_func& parent, algo::strptr in) __attribute__((nothrow));

bool                 src_func_ReadFieldMaybe(command::src_func &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::src_func from attributes of ascii tuple TUPLE
bool                 src_func_ReadTupleMaybe(command::src_func &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 src_func_Init(command::src_func& parent);
// print command-line args of command::src_func to string  -- cprint:command.src_func.Argv
void                 src_func_PrintArgv(command::src_func & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              src_func_ToCmdline(command::src_func & row) __attribute__((nothrow));
algo::strptr         src_func_GetAnon(command::src_func &parent, i32 idx) __attribute__((nothrow));

// --- command.src_func_proc
struct src_func_proc { // command.src_func_proc: Subprocess: Access / edit functions
    algo::cstring       path;      //   "bin/src_func"  path for executable
    command::src_func   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    src_func_proc();
    ~src_func_proc();
private:
    // reftype of command.src_func_proc.src_func prohibits copy
    src_func_proc(const src_func_proc&){ /*disallow copy constructor */}
    void operator =(const src_func_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  src_func_Start(command::src_func_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         src_func_StartRead(command::src_func_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 src_func_Kill(command::src_func_proc& parent);
// Wait for subprocess to return
void                 src_func_Wait(command::src_func_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  src_func_Exec(command::src_func_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 src_func_ExecX(command::src_func_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:src_func.Argv
int                  src_func_Execv(command::src_func_proc& parent) __attribute__((nothrow));
algo::tempstr        src_func_ToCmdline(command::src_func_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 src_func_proc_Init(command::src_func_proc& parent);
void                 src_func_proc_Uninit(command::src_func_proc& parent) __attribute__((nothrow));

// --- command.src_hdr
// access: command.src_hdr_proc.src_hdr (Exec)
struct src_hdr { // command.src_hdr
    algo::cstring    in;               //   "data"  Input directory or filename, - for stdin
    algo_lib::Regx   targsrc;          //   "%"  Regx of dev::Targsrc
    bool             write;            //   false  Update files in-place
    bool             update_authors;   //   false  Update authors from git history
    bool             indent;           //   false  Indent source files
    src_hdr();
};

// Print back to string
void                 targsrc_Print(command::src_hdr& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 targsrc_ReadStrptrMaybe(command::src_hdr& parent, algo::strptr in) __attribute__((nothrow));

bool                 src_hdr_ReadFieldMaybe(command::src_hdr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::src_hdr from attributes of ascii tuple TUPLE
bool                 src_hdr_ReadTupleMaybe(command::src_hdr &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 src_hdr_Init(command::src_hdr& parent);
// print command-line args of command::src_hdr to string  -- cprint:command.src_hdr.Argv
void                 src_hdr_PrintArgv(command::src_hdr & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              src_hdr_ToCmdline(command::src_hdr & row) __attribute__((nothrow));

// --- command.src_hdr_proc
struct src_hdr_proc { // command.src_hdr_proc: Subprocess: Update source file / copyright header
    algo::cstring      path;      //   "bin/src_hdr"  path for executable
    command::src_hdr   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    src_hdr_proc();
    ~src_hdr_proc();
private:
    // reftype of command.src_hdr_proc.src_hdr prohibits copy
    src_hdr_proc(const src_hdr_proc&){ /*disallow copy constructor */}
    void operator =(const src_hdr_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  src_hdr_Start(command::src_hdr_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         src_hdr_StartRead(command::src_hdr_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 src_hdr_Kill(command::src_hdr_proc& parent);
// Wait for subprocess to return
void                 src_hdr_Wait(command::src_hdr_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  src_hdr_Exec(command::src_hdr_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 src_hdr_ExecX(command::src_hdr_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:src_hdr.Argv
int                  src_hdr_Execv(command::src_hdr_proc& parent) __attribute__((nothrow));
algo::tempstr        src_hdr_ToCmdline(command::src_hdr_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 src_hdr_proc_Init(command::src_hdr_proc& parent);
void                 src_hdr_proc_Uninit(command::src_hdr_proc& parent) __attribute__((nothrow));

// --- command.src_lim
// access: command.src_lim_proc.src_lim (Exec)
struct src_lim { // command.src_lim
    algo::cstring    in;          //   "data"  Input directory or filename, - for stdin
    bool             linelim;     //   false  Check various file limits (line length, function length, etc)
    algo_lib::Regx   srcfile;     //   "%"  Regx of dev::Gitfile
    bool             strayfile;   //   false  Check for unregistered source files
    bool             capture;     //   false  Generate new dev.linelim records
    bool             write;       //   false  Update ssim database (with -capture)
    bool             badchar;     //   false  Check for bad chars in source files
    algo_lib::Regx   badline;     //   ""  Regx of dev::Badline
    src_lim();
};

// Print back to string
void                 srcfile_Print(command::src_lim& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 srcfile_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) __attribute__((nothrow));

// Print back to string
void                 badline_Print(command::src_lim& parent, algo::cstring &out) __attribute__((nothrow));
// Read Regx from string
// Convert string to field. Return success value
bool                 badline_ReadStrptrMaybe(command::src_lim& parent, algo::strptr in) __attribute__((nothrow));

bool                 src_lim_ReadFieldMaybe(command::src_lim &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::src_lim from attributes of ascii tuple TUPLE
bool                 src_lim_ReadTupleMaybe(command::src_lim &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 src_lim_Init(command::src_lim& parent);
// print command-line args of command::src_lim to string  -- cprint:command.src_lim.Argv
void                 src_lim_PrintArgv(command::src_lim & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              src_lim_ToCmdline(command::src_lim & row) __attribute__((nothrow));

// --- command.src_lim_proc
struct src_lim_proc { // command.src_lim_proc: Subprocess: Enforce line length, function length, and indentation limits
    algo::cstring      path;      //   "bin/src_lim"  path for executable
    command::src_lim   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    src_lim_proc();
    ~src_lim_proc();
private:
    // reftype of command.src_lim_proc.src_lim prohibits copy
    src_lim_proc(const src_lim_proc&){ /*disallow copy constructor */}
    void operator =(const src_lim_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  src_lim_Start(command::src_lim_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         src_lim_StartRead(command::src_lim_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 src_lim_Kill(command::src_lim_proc& parent);
// Wait for subprocess to return
void                 src_lim_Wait(command::src_lim_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  src_lim_Exec(command::src_lim_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 src_lim_ExecX(command::src_lim_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:src_lim.Argv
int                  src_lim_Execv(command::src_lim_proc& parent) __attribute__((nothrow));
algo::tempstr        src_lim_ToCmdline(command::src_lim_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 src_lim_proc_Init(command::src_lim_proc& parent);
void                 src_lim_proc_Uninit(command::src_lim_proc& parent) __attribute__((nothrow));

// --- command.ssim2csv
// access: command.ssim2csv_proc.ssim2csv (Exec)
struct ssim2csv { // command.ssim2csv
    algo::cstring   expand;        //   ""
    bool            ignoreQuote;   //   false
    ssim2csv();
};

bool                 ssim2csv_ReadFieldMaybe(command::ssim2csv &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ssim2csv from attributes of ascii tuple TUPLE
bool                 ssim2csv_ReadTupleMaybe(command::ssim2csv &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ssim2csv_Init(command::ssim2csv& parent);
// print command-line args of command::ssim2csv to string  -- cprint:command.ssim2csv.Argv
void                 ssim2csv_PrintArgv(command::ssim2csv & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ssim2csv_ToCmdline(command::ssim2csv & row) __attribute__((nothrow));

// --- command.ssim2csv_proc
struct ssim2csv_proc { // command.ssim2csv_proc: Subprocess: Ssim -> csv conversion tool
    algo::cstring       path;      //   "bin/ssim2csv"  path for executable
    command::ssim2csv   cmd;       // command line for child process
    algo::cstring       fstdin;    // redirect for stdin
    algo::cstring       fstdout;   // redirect for stdout
    algo::cstring       fstderr;   // redirect for stderr
    pid_t               pid;       //   0  pid of running child process
    i32                 timeout;   //   0  optional timeout for child process
    i32                 status;    //   0  last exit status of child process
    ssim2csv_proc();
    ~ssim2csv_proc();
private:
    // reftype of command.ssim2csv_proc.ssim2csv prohibits copy
    ssim2csv_proc(const ssim2csv_proc&){ /*disallow copy constructor */}
    void operator =(const ssim2csv_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ssim2csv_Start(command::ssim2csv_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ssim2csv_StartRead(command::ssim2csv_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ssim2csv_Kill(command::ssim2csv_proc& parent);
// Wait for subprocess to return
void                 ssim2csv_Wait(command::ssim2csv_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ssim2csv_Exec(command::ssim2csv_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ssim2csv_ExecX(command::ssim2csv_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ssim2csv.Argv
int                  ssim2csv_Execv(command::ssim2csv_proc& parent) __attribute__((nothrow));
algo::tempstr        ssim2csv_ToCmdline(command::ssim2csv_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ssim2csv_proc_Init(command::ssim2csv_proc& parent);
void                 ssim2csv_proc_Uninit(command::ssim2csv_proc& parent) __attribute__((nothrow));

// --- command.ssim2mysql
// access: command.ssim2mysql_proc.ssim2mysql (Exec)
struct ssim2mysql { // command.ssim2mysql
    algo::cstring   url;         //   ""  URL of mysql server. user:pass@hostb or sock://filename; Empty -> stdout
    algo::cstring   data_dir;    //   "data"  Load dmmeta info from this directory
    i32             maxpacket;   //   100000  Max Mysql packet size
    bool            replace;     //   true  use REPLACE INTO instead of INSERT INTO
    bool            trunc;       //   false  Truncate target table
    bool            dry_run;     //   false  Print SQL commands to the stdout
    bool            fldfunc;     //   false  create columns for fldfuncs
    algo::cstring   in;          //   "-"  Input directory or filename, - for stdin
    algo::cstring   db;          //   ""  Optional database name
    bool            createdb;    //   false  Emit CREATE DATABASE code for namespace specified with <db>
    bool            fkey;        //   false  Enable foreign key constraints (uses InnoDB storage engine)
    ssim2mysql();
};

bool                 ssim2mysql_ReadFieldMaybe(command::ssim2mysql &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::ssim2mysql from attributes of ascii tuple TUPLE
bool                 ssim2mysql_ReadTupleMaybe(command::ssim2mysql &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 ssim2mysql_Init(command::ssim2mysql& parent);
// print command-line args of command::ssim2mysql to string  -- cprint:command.ssim2mysql.Argv
void                 ssim2mysql_PrintArgv(command::ssim2mysql & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              ssim2mysql_ToCmdline(command::ssim2mysql & row) __attribute__((nothrow));

// --- command.ssim2mysql_proc
struct ssim2mysql_proc { // command.ssim2mysql_proc: Subprocess: Ssim -> mysql
    algo::cstring         path;      //   "bin/ssim2mysql"  path for executable
    command::ssim2mysql   cmd;       // command line for child process
    algo::cstring         fstdin;    // redirect for stdin
    algo::cstring         fstdout;   // redirect for stdout
    algo::cstring         fstderr;   // redirect for stderr
    pid_t                 pid;       //   0  pid of running child process
    i32                   timeout;   //   0  optional timeout for child process
    i32                   status;    //   0  last exit status of child process
    ssim2mysql_proc();
    ~ssim2mysql_proc();
private:
    // reftype of command.ssim2mysql_proc.ssim2mysql prohibits copy
    ssim2mysql_proc(const ssim2mysql_proc&){ /*disallow copy constructor */}
    void operator =(const ssim2mysql_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  ssim2mysql_Start(command::ssim2mysql_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         ssim2mysql_StartRead(command::ssim2mysql_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 ssim2mysql_Kill(command::ssim2mysql_proc& parent);
// Wait for subprocess to return
void                 ssim2mysql_Wait(command::ssim2mysql_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  ssim2mysql_Exec(command::ssim2mysql_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 ssim2mysql_ExecX(command::ssim2mysql_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:ssim2mysql.Argv
int                  ssim2mysql_Execv(command::ssim2mysql_proc& parent) __attribute__((nothrow));
algo::tempstr        ssim2mysql_ToCmdline(command::ssim2mysql_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 ssim2mysql_proc_Init(command::ssim2mysql_proc& parent);
void                 ssim2mysql_proc_Uninit(command::ssim2mysql_proc& parent) __attribute__((nothrow));

// --- command.strconv
// access: command.strconv_proc.strconv (Exec)
struct strconv { // command.strconv
    algo::cstring       str;            // String parameter
    bool                tocamelcase;    //   false  Convert string to camel case
    bool                tolowerunder;   //   false  Convert string to lower-under
    algo::cstring       in;             //   "data"  Input directory or filename, - for stdin
    algo::Smallstr100   pathcomp;       //   ""  Extract path component from string
    strconv();
};

bool                 strconv_ReadFieldMaybe(command::strconv &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of command::strconv from attributes of ascii tuple TUPLE
bool                 strconv_ReadTupleMaybe(command::strconv &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 strconv_Init(command::strconv& parent);
// print command-line args of command::strconv to string  -- cprint:command.strconv.Argv
void                 strconv_PrintArgv(command::strconv & row, algo::cstring &str) __attribute__((nothrow));
// Convenience function that returns a full command line
// Assume command is in a directory called bin
tempstr              strconv_ToCmdline(command::strconv & row) __attribute__((nothrow));
algo::strptr         strconv_GetAnon(command::strconv &parent, i32 idx) __attribute__((nothrow));

// --- command.strconv_proc
struct strconv_proc { // command.strconv_proc: Subprocess: A simple string utility
    algo::cstring      path;      //   "bin/strconv"  path for executable
    command::strconv   cmd;       // command line for child process
    algo::cstring      fstdin;    // redirect for stdin
    algo::cstring      fstdout;   // redirect for stdout
    algo::cstring      fstderr;   // redirect for stderr
    pid_t              pid;       //   0  pid of running child process
    i32                timeout;   //   0  optional timeout for child process
    i32                status;    //   0  last exit status of child process
    strconv_proc();
    ~strconv_proc();
private:
    // reftype of command.strconv_proc.strconv prohibits copy
    strconv_proc(const strconv_proc&){ /*disallow copy constructor */}
    void operator =(const strconv_proc&){ /*disallow direct assignment */}
};

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  strconv_Start(command::strconv_proc& parent) __attribute__((nothrow));
// Start subprocess & Read output
algo::Fildes         strconv_StartRead(command::strconv_proc& parent, algo_lib::FFildes &read) __attribute__((nothrow));
// Kill subprocess and wait
void                 strconv_Kill(command::strconv_proc& parent);
// Wait for subprocess to return
void                 strconv_Wait(command::strconv_proc& parent) __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  strconv_Exec(command::strconv_proc& parent) __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 strconv_ExecX(command::strconv_proc& parent);
// Call execv()
// Call execv with specified parameters -- cprint:strconv.Argv
int                  strconv_Execv(command::strconv_proc& parent) __attribute__((nothrow));
algo::tempstr        strconv_ToCmdline(command::strconv_proc& parent) __attribute__((nothrow));

// Set all fields to initial values.
void                 strconv_proc_Init(command::strconv_proc& parent);
void                 strconv_proc_Uninit(command::strconv_proc& parent) __attribute__((nothrow));
} // gen:ns_print_struct
namespace command { // gen:ns_func
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const command::FieldId &row);// cfmt:command.FieldId.String
}
