//
// include/gen/ssim2csv_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude

// --- ssim2csv.trace..Ctor
inline  ssim2csv::trace::trace() throw() {
}

// --- ssim2csv.FDb.expand.EmptyQ
// Return true if index is empty
inline bool ssim2csv::expand_EmptyQ() throw() {
    return _db.expand_n == 0;
}

// --- ssim2csv.FDb.expand.Find
// Look up row by row id. Return NULL if out of range
inline ssim2csv::FExpand* ssim2csv::expand_Find(u64 t) throw() {
    ssim2csv::FExpand *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.expand_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.expand_lary[bsr][index];
    }
    return retval;
}

// --- ssim2csv.FDb.expand.Last
// Return pointer to last element of array, or NULL if array is empty
inline ssim2csv::FExpand* ssim2csv::expand_Last() throw() {
    return expand_Find(u64(_db.expand_n-1));
}

// --- ssim2csv.FDb.expand.N
// Return number of items in the pool
inline i32 ssim2csv::expand_N() throw() {
    return _db.expand_n;
}

// --- ssim2csv.FDb.expand.qFind
// 'quick' Access row by row id. No bounds checking.
inline ssim2csv::FExpand& ssim2csv::expand_qFind(u64 t) throw() {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.expand_lary[bsr][index];
}

// --- ssim2csv.FDb.ind_expand.EmptyQ
// Return true if hash is empty
inline bool ssim2csv::ind_expand_EmptyQ() throw() {
    return _db.ind_expand_n == 0;
}

// --- ssim2csv.FDb.ind_expand.N
// Return number of items in the hash
inline i32 ssim2csv::ind_expand_N() throw() {
    return _db.ind_expand_n;
}

// --- ssim2csv.FDb.outfile.EmptyQ
// Return true if index is empty
inline bool ssim2csv::outfile_EmptyQ() throw() {
    return _db.outfile_n == 0;
}

// --- ssim2csv.FDb.outfile.Find
// Look up row by row id. Return NULL if out of range
inline ssim2csv::FOutfile* ssim2csv::outfile_Find(u64 t) throw() {
    ssim2csv::FOutfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.outfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.outfile_lary[bsr][index];
    }
    return retval;
}

// --- ssim2csv.FDb.outfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline ssim2csv::FOutfile* ssim2csv::outfile_Last() throw() {
    return outfile_Find(u64(_db.outfile_n-1));
}

// --- ssim2csv.FDb.outfile.N
// Return number of items in the pool
inline i32 ssim2csv::outfile_N() throw() {
    return _db.outfile_n;
}

// --- ssim2csv.FDb.outfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline ssim2csv::FOutfile& ssim2csv::outfile_qFind(u64 t) throw() {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.outfile_lary[bsr][index];
}

// --- ssim2csv.FDb.ind_outfile.EmptyQ
// Return true if hash is empty
inline bool ssim2csv::ind_outfile_EmptyQ() throw() {
    return _db.ind_outfile_n == 0;
}

// --- ssim2csv.FDb.ind_outfile.N
// Return number of items in the hash
inline i32 ssim2csv::ind_outfile_N() throw() {
    return _db.ind_outfile_n;
}

// --- ssim2csv.FDb.name.EmptyQ
// Return true if index is empty
inline bool ssim2csv::name_EmptyQ() throw() {
    return _db.name_n == 0;
}

// --- ssim2csv.FDb.name.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* ssim2csv::name_Find(u64 t) throw() {
    u64 idx = t;
    u64 lim = _db.name_n;
    if (idx >= lim) return NULL;
    return _db.name_elems + idx;
}

// --- ssim2csv.FDb.name.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> ssim2csv::name_Getary() throw() {
    return algo::aryptr<algo::cstring>(_db.name_elems, _db.name_n);
}

// --- ssim2csv.FDb.name.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* ssim2csv::name_Last() throw() {
    return name_Find(u64(_db.name_n-1));
}

// --- ssim2csv.FDb.name.Max
// Return max. number of items in the array
inline i32 ssim2csv::name_Max() throw() {
    return _db.name_max;
}

// --- ssim2csv.FDb.name.N
// Return number of items in the array
inline i32 ssim2csv::name_N() throw() {
    return _db.name_n;
}

// --- ssim2csv.FDb.name.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void ssim2csv::name_Reserve(int n) throw() {
    u32 new_n = _db.name_n + n;
    if (UNLIKELY(new_n > _db.name_max)) {
        name_AbsReserve(new_n);
    }
}

// --- ssim2csv.FDb.name.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& ssim2csv::name_qFind(u64 t) throw() {
    return _db.name_elems[t];
}

// --- ssim2csv.FDb.name.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& ssim2csv::name_qLast() throw() {
    return name_qFind(u64(_db.name_n-1));
}

// --- ssim2csv.FDb.name.rowid_Get
// Return row id of specified element
inline u64 ssim2csv::name_rowid_Get(algo::cstring &elem) throw() {
    u64 id = &elem - _db.name_elems;
    return u64(id);
}

// --- ssim2csv.FDb.value.EmptyQ
// Return true if index is empty
inline bool ssim2csv::value_EmptyQ() throw() {
    return _db.value_n == 0;
}

// --- ssim2csv.FDb.value.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* ssim2csv::value_Find(u64 t) throw() {
    u64 idx = t;
    u64 lim = _db.value_n;
    if (idx >= lim) return NULL;
    return _db.value_elems + idx;
}

// --- ssim2csv.FDb.value.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> ssim2csv::value_Getary() throw() {
    return algo::aryptr<algo::cstring>(_db.value_elems, _db.value_n);
}

// --- ssim2csv.FDb.value.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* ssim2csv::value_Last() throw() {
    return value_Find(u64(_db.value_n-1));
}

// --- ssim2csv.FDb.value.Max
// Return max. number of items in the array
inline i32 ssim2csv::value_Max() throw() {
    return _db.value_max;
}

// --- ssim2csv.FDb.value.N
// Return number of items in the array
inline i32 ssim2csv::value_N() throw() {
    return _db.value_n;
}

// --- ssim2csv.FDb.value.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void ssim2csv::value_Reserve(int n) throw() {
    u32 new_n = _db.value_n + n;
    if (UNLIKELY(new_n > _db.value_max)) {
        value_AbsReserve(new_n);
    }
}

// --- ssim2csv.FDb.value.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& ssim2csv::value_qFind(u64 t) throw() {
    return _db.value_elems[t];
}

// --- ssim2csv.FDb.value.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& ssim2csv::value_qLast() throw() {
    return value_qFind(u64(_db.value_n-1));
}

// --- ssim2csv.FDb.value.rowid_Get
// Return row id of specified element
inline u64 ssim2csv::value_rowid_Get(algo::cstring &elem) throw() {
    u64 id = &elem - _db.value_elems;
    return u64(id);
}

// --- ssim2csv.FDb.flatten.EmptyQ
// Return true if index is empty
inline bool ssim2csv::flatten_EmptyQ() throw() {
    return _db.flatten_n == 0;
}

// --- ssim2csv.FDb.flatten.Find
// Look up row by row id. Return NULL if out of range
inline ssim2csv::FFlatten* ssim2csv::flatten_Find(u64 t) throw() {
    u64 idx = t;
    u64 lim = _db.flatten_n;
    if (idx >= lim) return NULL;
    return _db.flatten_elems + idx;
}

// --- ssim2csv.FDb.flatten.Getary
// Return array pointer by value
inline algo::aryptr<ssim2csv::FFlatten> ssim2csv::flatten_Getary() throw() {
    return algo::aryptr<ssim2csv::FFlatten>(_db.flatten_elems, _db.flatten_n);
}

// --- ssim2csv.FDb.flatten.Last
// Return pointer to last element of array, or NULL if array is empty
inline ssim2csv::FFlatten* ssim2csv::flatten_Last() throw() {
    return flatten_Find(u64(_db.flatten_n-1));
}

// --- ssim2csv.FDb.flatten.Max
// Return max. number of items in the array
inline i32 ssim2csv::flatten_Max() throw() {
    return _db.flatten_max;
}

// --- ssim2csv.FDb.flatten.N
// Return number of items in the array
inline i32 ssim2csv::flatten_N() throw() {
    return _db.flatten_n;
}

// --- ssim2csv.FDb.flatten.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void ssim2csv::flatten_Reserve(int n) throw() {
    u32 new_n = _db.flatten_n + n;
    if (UNLIKELY(new_n > _db.flatten_max)) {
        flatten_AbsReserve(new_n);
    }
}

// --- ssim2csv.FDb.flatten.qFind
// 'quick' Access row by row id. No bounds checking.
inline ssim2csv::FFlatten& ssim2csv::flatten_qFind(u64 t) throw() {
    return _db.flatten_elems[t];
}

// --- ssim2csv.FDb.flatten.qLast
// Return reference to last element of array. No bounds checking
inline ssim2csv::FFlatten& ssim2csv::flatten_qLast() throw() {
    return flatten_qFind(u64(_db.flatten_n-1));
}

// --- ssim2csv.FDb.flatten.rowid_Get
// Return row id of specified element
inline u64 ssim2csv::flatten_rowid_Get(ssim2csv::FFlatten &elem) throw() {
    u64 id = &elem - _db.flatten_elems;
    return u64(id);
}

// --- ssim2csv.FDb.expand_curs.Reset
// cursor points to valid item
inline void ssim2csv::_db_expand_curs_Reset(_db_expand_curs &curs, ssim2csv::FDb &parent) throw() {
    curs.parent = &parent;
    curs.index = 0;
}

// --- ssim2csv.FDb.expand_curs.ValidQ
// cursor points to valid item
inline bool ssim2csv::_db_expand_curs_ValidQ(_db_expand_curs &curs) throw() {
    return curs.index < _db.expand_n;
}

// --- ssim2csv.FDb.expand_curs.Next
// proceed to next item
inline void ssim2csv::_db_expand_curs_Next(_db_expand_curs &curs) throw() {
    curs.index++;
}

// --- ssim2csv.FDb.expand_curs.Access
// item access
inline ssim2csv::FExpand& ssim2csv::_db_expand_curs_Access(_db_expand_curs &curs) throw() {
    return expand_qFind(u64(curs.index));
}

// --- ssim2csv.FDb.outfile_curs.Reset
// cursor points to valid item
inline void ssim2csv::_db_outfile_curs_Reset(_db_outfile_curs &curs, ssim2csv::FDb &parent) throw() {
    curs.parent = &parent;
    curs.index = 0;
}

// --- ssim2csv.FDb.outfile_curs.ValidQ
// cursor points to valid item
inline bool ssim2csv::_db_outfile_curs_ValidQ(_db_outfile_curs &curs) throw() {
    return curs.index < _db.outfile_n;
}

// --- ssim2csv.FDb.outfile_curs.Next
// proceed to next item
inline void ssim2csv::_db_outfile_curs_Next(_db_outfile_curs &curs) throw() {
    curs.index++;
}

// --- ssim2csv.FDb.outfile_curs.Access
// item access
inline ssim2csv::FOutfile& ssim2csv::_db_outfile_curs_Access(_db_outfile_curs &curs) throw() {
    return outfile_qFind(u64(curs.index));
}

// --- ssim2csv.FDb.name_curs.Next
// proceed to next item
inline void ssim2csv::_db_name_curs_Next(_db_name_curs &curs) throw() {
    curs.index++;
}

// --- ssim2csv.FDb.name_curs.Reset
inline void ssim2csv::_db_name_curs_Reset(_db_name_curs &curs, ssim2csv::FDb &parent) throw() {
    curs.elems = parent.name_elems;
    curs.n_elems = parent.name_n;
    curs.index = 0;
}

// --- ssim2csv.FDb.name_curs.ValidQ
// cursor points to valid item
inline bool ssim2csv::_db_name_curs_ValidQ(_db_name_curs &curs) throw() {
    return curs.index < curs.n_elems;
}

// --- ssim2csv.FDb.name_curs.Access
// item access
inline algo::cstring& ssim2csv::_db_name_curs_Access(_db_name_curs &curs) throw() {
    return curs.elems[curs.index];
}

// --- ssim2csv.FDb.value_curs.Next
// proceed to next item
inline void ssim2csv::_db_value_curs_Next(_db_value_curs &curs) throw() {
    curs.index++;
}

// --- ssim2csv.FDb.value_curs.Reset
inline void ssim2csv::_db_value_curs_Reset(_db_value_curs &curs, ssim2csv::FDb &parent) throw() {
    curs.elems = parent.value_elems;
    curs.n_elems = parent.value_n;
    curs.index = 0;
}

// --- ssim2csv.FDb.value_curs.ValidQ
// cursor points to valid item
inline bool ssim2csv::_db_value_curs_ValidQ(_db_value_curs &curs) throw() {
    return curs.index < curs.n_elems;
}

// --- ssim2csv.FDb.value_curs.Access
// item access
inline algo::cstring& ssim2csv::_db_value_curs_Access(_db_value_curs &curs) throw() {
    return curs.elems[curs.index];
}

// --- ssim2csv.FDb.flatten_curs.Next
// proceed to next item
inline void ssim2csv::_db_flatten_curs_Next(_db_flatten_curs &curs) throw() {
    curs.index++;
}

// --- ssim2csv.FDb.flatten_curs.Reset
inline void ssim2csv::_db_flatten_curs_Reset(_db_flatten_curs &curs, ssim2csv::FDb &parent) throw() {
    curs.elems = parent.flatten_elems;
    curs.n_elems = parent.flatten_n;
    curs.index = 0;
}

// --- ssim2csv.FDb.flatten_curs.ValidQ
// cursor points to valid item
inline bool ssim2csv::_db_flatten_curs_ValidQ(_db_flatten_curs &curs) throw() {
    return curs.index < curs.n_elems;
}

// --- ssim2csv.FDb.flatten_curs.Access
// item access
inline ssim2csv::FFlatten& ssim2csv::_db_flatten_curs_Access(_db_flatten_curs &curs) throw() {
    return curs.elems[curs.index];
}

// --- ssim2csv.FExpand..Init
// Set all fields to initial values.
inline void ssim2csv::FExpand_Init(ssim2csv::FExpand& expand) {
    expand.ind_expand_next = (ssim2csv::FExpand*)-1; // (ssim2csv.FDb.ind_expand) not-in-hash
}

// --- ssim2csv.FExpand..Ctor
inline  ssim2csv::FExpand::FExpand() throw() {
    ssim2csv::FExpand_Init(*this);
}

// --- ssim2csv.FExpand..Dtor
inline  ssim2csv::FExpand::~FExpand() throw() {
    ssim2csv::FExpand_Uninit(*this);
}

// --- ssim2csv.FFlatten..Ctor
inline  ssim2csv::FFlatten::FFlatten() throw() {
}

// --- ssim2csv.FOutfile..Init
// Set all fields to initial values.
inline void ssim2csv::FOutfile_Init(ssim2csv::FOutfile& outfile) {
    outfile.ind_outfile_next = (ssim2csv::FOutfile*)-1; // (ssim2csv.FDb.ind_outfile) not-in-hash
}

// --- ssim2csv.FOutfile..Ctor
inline  ssim2csv::FOutfile::FOutfile() throw() {
    ssim2csv::FOutfile_Init(*this);
}

// --- ssim2csv.FOutfile..Dtor
inline  ssim2csv::FOutfile::~FOutfile() throw() {
    ssim2csv::FOutfile_Uninit(*this);
}

// --- ssim2csv.FieldId.value.GetEnum
// Get value of field as enum type
inline ssim2csv_FieldIdEnum ssim2csv::value_GetEnum(const ssim2csv::FieldId& parent) throw() {
    return ssim2csv_FieldIdEnum(parent.value);
}

// --- ssim2csv.FieldId.value.SetEnum
// Set value of field from enum type.
inline void ssim2csv::value_SetEnum(ssim2csv::FieldId& parent, ssim2csv_FieldIdEnum rhs) throw() {
    parent.value = i32(rhs);
}

// --- ssim2csv.FieldId.value.Cast
inline  ssim2csv::FieldId::operator ssim2csv_FieldIdEnum() const throw() {
    return ssim2csv_FieldIdEnum((*this).value);
}

// --- ssim2csv.FieldId..Init
// Set all fields to initial values.
inline void ssim2csv::FieldId_Init(ssim2csv::FieldId& parent) {
    parent.value = i32(-1);
}

// --- ssim2csv.FieldId..Ctor
inline  ssim2csv::FieldId::FieldId() throw() {
    ssim2csv::FieldId_Init(*this);
}

// --- ssim2csv.FieldId..FieldwiseCtor
inline  ssim2csv::FieldId::FieldId(i32 in_value) throw()
    : value(in_value)
 {
}

// --- ssim2csv.FieldId..EnumCtor
inline  ssim2csv::FieldId::FieldId(ssim2csv_FieldIdEnum arg) throw() {
    this->value = i32(arg);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ssim2csv::trace &row) {// cfmt:ssim2csv.trace.String
    ssim2csv::trace_Print(const_cast<ssim2csv::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ssim2csv::FExpand &row) {// cfmt:ssim2csv.FExpand.String
    ssim2csv::FExpand_Print(const_cast<ssim2csv::FExpand&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ssim2csv::FFlatten &row) {// cfmt:ssim2csv.FFlatten.String
    ssim2csv::FFlatten_Print(const_cast<ssim2csv::FFlatten&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ssim2csv::FOutfile &row) {// cfmt:ssim2csv.FOutfile.String
    ssim2csv::FOutfile_Print(const_cast<ssim2csv::FOutfile&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ssim2csv::FieldId &row) {// cfmt:ssim2csv.FieldId.String
    ssim2csv::FieldId_Print(const_cast<ssim2csv::FieldId&>(row), str);
    return str;
}
