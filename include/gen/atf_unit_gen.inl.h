//
// include/gen/atf_unit_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/report_gen.inl.h"
#include "include/gen/atfdb_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude
inline atf_unit::Bitset::Bitset() {
    atf_unit::Bitset_Init(*this);
}


// --- atf_unit.Bitset.fld1.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_unit::fld1_Nbits(atf_unit::Bitset& parent) {
    return fld1_N(parent) * 16;
}

// --- atf_unit.Bitset.fld1.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_unit::fld1_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u16 &elem = fld1_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_unit.Bitset.fld1.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_unit::fld1_GetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    bool ret = false;
    u64 lim = fld1_N(parent);
    if (elem_idx < lim) {
        u16 &elem = fld1_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_unit.Bitset.fld1.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_unit::fld1_BitsEmptyQ(atf_unit::Bitset& parent) {
    bool retval = true;
    u64 n = fld1_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (fld1_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_unit.Bitset.fld1.Sum1s
inline u64 atf_unit::fld1_Sum1s(atf_unit::Bitset& parent) {
    u64 sum = 0;
    u64 n = fld1_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u16_Count1s(fld1_qFind(parent, i));
    }
    return sum;
}

// --- atf_unit.Bitset.fld1.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld1_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u16 &elem = fld1_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u16(1) << shift); // clear bit
}

// --- atf_unit.Bitset.fld1.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_unit::fld1_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u64 lim = fld1_N(parent);
    if (elem_idx < lim) {
        u16 &elem = fld1_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u16(1) << shift); // clear bit
    }
}

// --- atf_unit.Bitset.fld1.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld1_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u16 &elem = fld1_qFind(parent, elem_idx); // fetch
    elem = elem | (u16(1) << shift); // set bit
}

// --- atf_unit.Bitset.fld1.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_unit::fld1_SetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u64 lim = fld1_N(parent);
    if (elem_idx < lim) {
        u16 &elem = fld1_qFind(parent, elem_idx); // fetch
        elem = elem | (u16(1) << shift); // set bit
    }
}

// --- atf_unit.Bitset.fld1.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld1_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u16 &elem = fld1_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u16(1) << shift)) | (u16(val) << shift); // insert new value
}

// --- atf_unit.Bitset.fld1.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld1_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 4;
    u64 shift = bit_idx & 15;
    u16 &elem = fld1_qFind(parent, elem_idx); // fetch
    elem = elem | (u16(val) << shift); // Or in val into elem
}

// --- atf_unit.Bitset.fld1.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_unit::fld1_ClearBitsAll(atf_unit::Bitset& parent) {
    u64 n = fld1_N(parent);
    for (u64 i = 0; i < n; i++) {
        fld1_qFind(parent, i) = 0;
    }
}

// --- atf_unit.Bitset.fld1.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_unit::fld1_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld1_N(parent), fld1_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld1_qFind(parent, i) &= ~fld1_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld1.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_unit::fld1_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld1_N(parent), fld1_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld1_qFind(parent, i) |= fld1_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld1.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 atf_unit::fld1_Sup(atf_unit::Bitset& parent) {
    u64 lim = fld1_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u16 &val = fld1_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 16 + bitidx;
            break;
        }
    }
    return ret;
}

// --- atf_unit.Bitset.fld1.Fill
// Set all elements of fixed array to value RHS
inline void atf_unit::fld1_Fill(atf_unit::Bitset& parent, const u16 &rhs) {
    for (int i = 0; i < 4; i++) {
        parent.fld1_elems[i] = rhs;
    }
}

// --- atf_unit.Bitset.fld1.Find
// Look up row by row id. Return NULL if out of range
inline u16* atf_unit::fld1_Find(atf_unit::Bitset& parent, u64 t) {
    u64 idx = t;
    u64 lim = 4;
    return idx < lim ? parent.fld1_elems + idx : NULL; // unsigned comparison with limit
}

// --- atf_unit.Bitset.fld1.Getary
// Access fixed array fld1 as aryptr.
inline algo::aryptr<u16> atf_unit::fld1_Getary(atf_unit::Bitset& parent) {
    return algo::aryptr<u16>(parent.fld1_elems, 4);
}

// --- atf_unit.Bitset.fld1.Max
// Return max number of items in the array
inline i32 atf_unit::fld1_Max(atf_unit::Bitset& parent) {
    (void)parent;
    return 4;
}

// --- atf_unit.Bitset.fld1.N
// Return number of items in the array
inline i32 atf_unit::fld1_N(const atf_unit::Bitset& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 4;
}

// --- atf_unit.Bitset.fld1.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void atf_unit::fld1_Setary(atf_unit::Bitset& parent, const algo::aryptr<u16> &rhs) {
    int n = 4 < rhs.n_elems ? 4 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.fld1_elems[i] = rhs[i];
    }
}

// --- atf_unit.Bitset.fld1.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u16& atf_unit::fld1_qFind(atf_unit::Bitset& parent, u64 t) {
    return parent.fld1_elems[t];
}

// --- atf_unit.Bitset.fld8.N
// Return constant 1
inline int atf_unit::fld8_N(atf_unit::Bitset& parent) {
    (void)parent;
    return 1;
}

// --- atf_unit.Bitset.fld8.qFind
// Access value
inline u8& atf_unit::fld8_qFind(atf_unit::Bitset& parent, int) {
    return parent.fld8;
}

// --- atf_unit.Bitset.fld8.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_unit::fld8_Nbits(atf_unit::Bitset& parent) {
    return fld8_N(parent) * 8;
}

// --- atf_unit.Bitset.fld8.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_unit::fld8_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = fld8_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_unit.Bitset.fld8.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_unit::fld8_GetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    bool ret = false;
    u64 lim = fld8_N(parent);
    if (elem_idx < lim) {
        u8 &elem = fld8_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_unit.Bitset.fld8.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_unit::fld8_BitsEmptyQ(atf_unit::Bitset& parent) {
    bool retval = true;
    u64 n = fld8_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (fld8_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_unit.Bitset.fld8.Sum1s
inline u64 atf_unit::fld8_Sum1s(atf_unit::Bitset& parent) {
    u64 sum = 0;
    u64 n = fld8_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u8_Count1s(fld8_qFind(parent, i));
    }
    return sum;
}

// --- atf_unit.Bitset.fld8.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld8_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = fld8_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u8(1) << shift); // clear bit
}

// --- atf_unit.Bitset.fld8.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_unit::fld8_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u64 lim = fld8_N(parent);
    if (elem_idx < lim) {
        u8 &elem = fld8_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u8(1) << shift); // clear bit
    }
}

// --- atf_unit.Bitset.fld8.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld8_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = fld8_qFind(parent, elem_idx); // fetch
    elem = elem | (u8(1) << shift); // set bit
}

// --- atf_unit.Bitset.fld8.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_unit::fld8_SetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u64 lim = fld8_N(parent);
    if (elem_idx < lim) {
        u8 &elem = fld8_qFind(parent, elem_idx); // fetch
        elem = elem | (u8(1) << shift); // set bit
    }
}

// --- atf_unit.Bitset.fld8.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld8_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = fld8_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u8(1) << shift)) | (u8(val) << shift); // insert new value
}

// --- atf_unit.Bitset.fld8.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld8_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 3;
    u64 shift = bit_idx & 7;
    u8 &elem = fld8_qFind(parent, elem_idx); // fetch
    elem = elem | (u8(val) << shift); // Or in val into elem
}

// --- atf_unit.Bitset.fld8.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_unit::fld8_ClearBitsAll(atf_unit::Bitset& parent) {
    u64 n = fld8_N(parent);
    for (u64 i = 0; i < n; i++) {
        fld8_qFind(parent, i) = 0;
    }
}

// --- atf_unit.Bitset.fld8.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_unit::fld8_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld8_N(parent), fld8_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld8_qFind(parent, i) &= ~fld8_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld8.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_unit::fld8_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld8_N(parent), fld8_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld8_qFind(parent, i) |= fld8_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld8.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 atf_unit::fld8_Sup(atf_unit::Bitset& parent) {
    u64 lim = fld8_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u8 &val = fld8_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 8 + bitidx;
            break;
        }
    }
    return ret;
}

// --- atf_unit.Bitset.fld64.N
// Return constant 1
inline int atf_unit::fld64_N(atf_unit::Bitset& parent) {
    (void)parent;
    return 1;
}

// --- atf_unit.Bitset.fld64.qFind
// Access value
inline u64& atf_unit::fld64_qFind(atf_unit::Bitset& parent, int) {
    return parent.fld64;
}

// --- atf_unit.Bitset.fld64.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_unit::fld64_Nbits(atf_unit::Bitset& parent) {
    return fld64_N(parent) * 64;
}

// --- atf_unit.Bitset.fld64.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_unit::fld64_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = fld64_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_unit.Bitset.fld64.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_unit::fld64_GetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    bool ret = false;
    u64 lim = fld64_N(parent);
    if (elem_idx < lim) {
        u64 &elem = fld64_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_unit.Bitset.fld64.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_unit::fld64_BitsEmptyQ(atf_unit::Bitset& parent) {
    bool retval = true;
    u64 n = fld64_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (fld64_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_unit.Bitset.fld64.Sum1s
inline u64 atf_unit::fld64_Sum1s(atf_unit::Bitset& parent) {
    u64 sum = 0;
    u64 n = fld64_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u64_Count1s(fld64_qFind(parent, i));
    }
    return sum;
}

// --- atf_unit.Bitset.fld64.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld64_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = fld64_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u64(1) << shift); // clear bit
}

// --- atf_unit.Bitset.fld64.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_unit::fld64_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = fld64_N(parent);
    if (elem_idx < lim) {
        u64 &elem = fld64_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u64(1) << shift); // clear bit
    }
}

// --- atf_unit.Bitset.fld64.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld64_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = fld64_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(1) << shift); // set bit
}

// --- atf_unit.Bitset.fld64.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_unit::fld64_SetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = fld64_N(parent);
    if (elem_idx < lim) {
        u64 &elem = fld64_qFind(parent, elem_idx); // fetch
        elem = elem | (u64(1) << shift); // set bit
    }
}

// --- atf_unit.Bitset.fld64.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld64_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = fld64_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u64(1) << shift)) | (u64(val) << shift); // insert new value
}

// --- atf_unit.Bitset.fld64.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld64_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = fld64_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(val) << shift); // Or in val into elem
}

// --- atf_unit.Bitset.fld64.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_unit::fld64_ClearBitsAll(atf_unit::Bitset& parent) {
    u64 n = fld64_N(parent);
    for (u64 i = 0; i < n; i++) {
        fld64_qFind(parent, i) = 0;
    }
}

// --- atf_unit.Bitset.fld64.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_unit::fld64_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld64_N(parent), fld64_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld64_qFind(parent, i) &= ~fld64_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld64.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_unit::fld64_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld64_N(parent), fld64_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld64_qFind(parent, i) |= fld64_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld64.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 atf_unit::fld64_Sup(atf_unit::Bitset& parent) {
    u64 lim = fld64_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u64 &val = fld64_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 64 + bitidx;
            break;
        }
    }
    return ret;
}

// --- atf_unit.Bitset.fld128.N
// Return constant 1
inline int atf_unit::fld128_N(atf_unit::Bitset& parent) {
    (void)parent;
    return 1;
}

// --- atf_unit.Bitset.fld128.qFind
// Access value
inline u128& atf_unit::fld128_qFind(atf_unit::Bitset& parent, int) {
    return parent.fld128;
}

// --- atf_unit.Bitset.fld128.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int atf_unit::fld128_Nbits(atf_unit::Bitset& parent) {
    return fld128_N(parent) * 128;
}

// --- atf_unit.Bitset.fld128.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool atf_unit::fld128_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = fld128_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- atf_unit.Bitset.fld128.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool atf_unit::fld128_GetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    bool ret = false;
    u64 lim = fld128_N(parent);
    if (elem_idx < lim) {
        u128 &elem = fld128_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- atf_unit.Bitset.fld128.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool atf_unit::fld128_BitsEmptyQ(atf_unit::Bitset& parent) {
    bool retval = true;
    u64 n = fld128_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (fld128_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- atf_unit.Bitset.fld128.Sum1s
inline u64 atf_unit::fld128_Sum1s(atf_unit::Bitset& parent) {
    u64 sum = 0;
    u64 n = fld128_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u128_Count1s(fld128_qFind(parent, i));
    }
    return sum;
}

// --- atf_unit.Bitset.fld128.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld128_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = fld128_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u128(1) << shift); // clear bit
}

// --- atf_unit.Bitset.fld128.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void atf_unit::fld128_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u64 lim = fld128_N(parent);
    if (elem_idx < lim) {
        u128 &elem = fld128_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u128(1) << shift); // clear bit
    }
}

// --- atf_unit.Bitset.fld128.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld128_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = fld128_qFind(parent, elem_idx); // fetch
    elem = elem | (u128(1) << shift); // set bit
}

// --- atf_unit.Bitset.fld128.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void atf_unit::fld128_SetBit(atf_unit::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u64 lim = fld128_N(parent);
    if (elem_idx < lim) {
        u128 &elem = fld128_qFind(parent, elem_idx); // fetch
        elem = elem | (u128(1) << shift); // set bit
    }
}

// --- atf_unit.Bitset.fld128.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld128_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = fld128_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u128(1) << shift)) | (u128(val) << shift); // insert new value
}

// --- atf_unit.Bitset.fld128.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void atf_unit::fld128_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 7;
    u64 shift = bit_idx & 127;
    u128 &elem = fld128_qFind(parent, elem_idx); // fetch
    elem = elem | (u128(val) << shift); // Or in val into elem
}

// --- atf_unit.Bitset.fld128.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void atf_unit::fld128_ClearBitsAll(atf_unit::Bitset& parent) {
    u64 n = fld128_N(parent);
    for (u64 i = 0; i < n; i++) {
        fld128_qFind(parent, i) = 0;
    }
}

// --- atf_unit.Bitset.fld128.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void atf_unit::fld128_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld128_N(parent), fld128_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld128_qFind(parent, i) &= ~fld128_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld128.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void atf_unit::fld128_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) {
    u64 n = u64_Min(fld128_N(parent), fld128_N(rhs));
    for (u64 i = 0; i < n; i++) {
        fld128_qFind(parent, i) |= fld128_qFind(rhs, i);
    }
}

// --- atf_unit.Bitset.fld1_curs.Reset
// cursor points to valid item
inline void atf_unit::Bitset_fld1_curs_Reset(Bitset_fld1_curs &curs, atf_unit::Bitset &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_unit.Bitset.fld1_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::Bitset_fld1_curs_ValidQ(Bitset_fld1_curs &curs) {
    return u64(curs.index) < u64(4);
}

// --- atf_unit.Bitset.fld1_curs.Next
// proceed to next item
inline void atf_unit::Bitset_fld1_curs_Next(Bitset_fld1_curs &curs) {
    curs.index++;
}

// --- atf_unit.Bitset.fld1_curs.Access
// item access
inline u16& atf_unit::Bitset_fld1_curs_Access(Bitset_fld1_curs &curs) {
    return fld1_qFind((*curs.parent), u64(curs.index));
}

// --- atf_unit.Bitset..Init
// Set all fields to initial values.
inline void atf_unit::Bitset_Init(atf_unit::Bitset& parent) {
    for (int i = 0; i < 4; i++) {
        parent.fld1_elems[i] = 0;
    }
    parent.fld8 = u8(0);
    parent.fld64 = u64(0);
    parent.fld128 = u128(0);
}
inline atf_unit::Cstr::Cstr(const algo::strptr&            in_val)
    : val(in_val)
{
}
inline atf_unit::Cstr::Cstr() {
}


// --- atf_unit.Cstr.val.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool atf_unit::val_Lt(atf_unit::Cstr& parent, atf_unit::Cstr &rhs) {
    return algo::cstring_Lt(parent.val,rhs.val);
}

// --- atf_unit.Cstr.val.Cmp
// Compare two fields.
inline i32 atf_unit::val_Cmp(atf_unit::Cstr& parent, atf_unit::Cstr &rhs) {
    i32 retval = 0;
    retval = algo::cstring_Cmp(parent.val, rhs.val);
    return retval;
}

// --- atf_unit.Cstr.val.Cast
inline atf_unit::Cstr::operator algo::strptr () const {
    return algo::strptr((*this).val);
}

// --- atf_unit.Cstr..Hash
inline u32 atf_unit::Cstr_Hash(u32 prev, const atf_unit::Cstr & rhs) {
    prev = cstring_Hash(prev, rhs.val);
    return prev;
}

// --- atf_unit.Cstr..Lt
inline bool atf_unit::Cstr_Lt(atf_unit::Cstr & lhs, atf_unit::Cstr & rhs) {
    return val_Lt(lhs,rhs);
}

// --- atf_unit.Cstr..Cmp
inline i32 atf_unit::Cstr_Cmp(atf_unit::Cstr & lhs, atf_unit::Cstr & rhs) {
    i32 retval = 0;
    retval = val_Cmp(lhs,rhs);
    return retval;
}

// --- atf_unit.Cstr..Eq
inline bool atf_unit::Cstr_Eq(const atf_unit::Cstr & lhs,const atf_unit::Cstr & rhs) {
    bool retval = true;
    retval = algo::cstring_Eq(lhs.val, rhs.val);
    return retval;
}

// --- atf_unit.Cstr..Update
// Set value. Return true if new value is different from old value.
inline bool atf_unit::Cstr_Update(atf_unit::Cstr &lhs, atf_unit::Cstr & rhs) {
    bool ret = !Cstr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_unit::Dbl::Dbl(double                         in_val)
    : val(in_val)
{
}

inline bool atf_unit::Dbl::operator ==(const atf_unit::Dbl &rhs) const {
    return atf_unit::Dbl_Eq(const_cast<atf_unit::Dbl&>(*this),const_cast<atf_unit::Dbl&>(rhs));
}

inline bool atf_unit::Dbl::operator !=(const atf_unit::Dbl &rhs) const {
    return !atf_unit::Dbl_Eq(const_cast<atf_unit::Dbl&>(*this),const_cast<atf_unit::Dbl&>(rhs));
}

inline bool atf_unit::Dbl::operator <(const atf_unit::Dbl &rhs) const {
    return atf_unit::Dbl_Lt(const_cast<atf_unit::Dbl&>(*this),const_cast<atf_unit::Dbl&>(rhs));
}
inline atf_unit::Dbl::Dbl() {
    atf_unit::Dbl_Init(*this);
}


// --- atf_unit.Dbl.val.Cast
inline atf_unit::Dbl::operator double () const {
    return double((*this).val);
}

// --- atf_unit.Dbl..Hash
inline u32 atf_unit::Dbl_Hash(u32 prev, atf_unit::Dbl rhs) {
    prev = double_Hash(prev, rhs.val);
    return prev;
}

// --- atf_unit.Dbl..Lt
inline bool atf_unit::Dbl_Lt(atf_unit::Dbl lhs, atf_unit::Dbl rhs) {
    return double_Lt(lhs.val, rhs.val);
}

// --- atf_unit.Dbl..Cmp
inline i32 atf_unit::Dbl_Cmp(atf_unit::Dbl lhs, atf_unit::Dbl rhs) {
    i32 retval = 0;
    retval = double_Cmp(lhs.val, rhs.val);
    return retval;
}

// --- atf_unit.Dbl..Init
// Set all fields to initial values.
inline void atf_unit::Dbl_Init(atf_unit::Dbl& orig) {
    orig.val = double(0.0);
}

// --- atf_unit.Dbl..Eq
inline bool atf_unit::Dbl_Eq(atf_unit::Dbl lhs, atf_unit::Dbl rhs) {
    bool retval = true;
    retval = double_Eq(lhs.val, rhs.val);
    return retval;
}

// --- atf_unit.Dbl..Update
// Set value. Return true if new value is different from old value.
inline bool atf_unit::Dbl_Update(atf_unit::Dbl &lhs, atf_unit::Dbl rhs) {
    bool ret = !Dbl_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_unit::TestArgtuple1::TestArgtuple1() {
    atf_unit::TestArgtuple1_Init(*this);
}

inline atf_unit::trace::trace() {
}


// --- atf_unit.FDb.tr_number.EmptyQ
// Return true if index is empty
inline bool atf_unit::tr_number_EmptyQ() {
    return _db.tr_number_root == NULL;
}

// --- atf_unit.FDb.tr_number.InTreeQ
// Return true if row is in the tree, false otherwise
inline bool atf_unit::tr_number_InTreeQ(atf_unit::FNumber& row) {
    return row.tr_number_up != (atf_unit::FNumber*)-1;
}

// --- atf_unit.FDb.tr_number.RemoveAll
// Empty the index. (The rows are not deleted)
inline void atf_unit::tr_number_RemoveAll() {
    tr_number_RemoveAllImpl(_db.tr_number_root, false);
    _db.tr_number_root = NULL;
    _db.tr_number_n = 0;
}

// --- atf_unit.FDb.unittest.EmptyQ
// Return true if index is empty
inline bool atf_unit::unittest_EmptyQ() {
    return _db.unittest_n == 0;
}

// --- atf_unit.FDb.unittest.Find
// Look up row by row id. Return NULL if out of range
inline atf_unit::FUnittest* atf_unit::unittest_Find(u64 t) {
    atf_unit::FUnittest *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.unittest_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.unittest_lary[bsr][index];
    }
    return retval;
}

// --- atf_unit.FDb.unittest.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_unit::FUnittest* atf_unit::unittest_Last() {
    return unittest_Find(u64(_db.unittest_n-1));
}

// --- atf_unit.FDb.unittest.N
// Return number of items in the pool
inline i32 atf_unit::unittest_N() {
    return _db.unittest_n;
}

// --- atf_unit.FDb.unittest.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_unit::FUnittest& atf_unit::unittest_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.unittest_lary[bsr][index];
}

// --- atf_unit.FDb.ind_unittest.EmptyQ
// Return true if hash is empty
inline bool atf_unit::ind_unittest_EmptyQ() {
    return _db.ind_unittest_n == 0;
}

// --- atf_unit.FDb.ind_unittest.N
// Return number of items in the hash
inline i32 atf_unit::ind_unittest_N() {
    return _db.ind_unittest_n;
}

// --- atf_unit.FDb.tr_number_curs.Reset
// cursor points to valid item
inline void atf_unit::_db_tr_number_curs_Reset(_db_tr_number_curs &curs, atf_unit::FDb& ) {
    curs.row = tr_number_First();
}

// --- atf_unit.FDb.tr_number_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::_db_tr_number_curs_ValidQ(_db_tr_number_curs &curs) {
    return curs.row != NULL;
}

// --- atf_unit.FDb.tr_number_curs.Next
// proceed to next item
inline void atf_unit::_db_tr_number_curs_Next(_db_tr_number_curs &curs) {
    curs.row = tr_number_Next(*curs.row);
}

// --- atf_unit.FDb.tr_number_curs.Access
// item access
inline atf_unit::FNumber& atf_unit::_db_tr_number_curs_Access(_db_tr_number_curs &curs) {
    return *curs.row;
}

// --- atf_unit.FDb.unittest_curs.Reset
// cursor points to valid item
inline void atf_unit::_db_unittest_curs_Reset(_db_unittest_curs &curs, atf_unit::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- atf_unit.FDb.unittest_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::_db_unittest_curs_ValidQ(_db_unittest_curs &curs) {
    return curs.index < _db.unittest_n;
}

// --- atf_unit.FDb.unittest_curs.Next
// proceed to next item
inline void atf_unit::_db_unittest_curs_Next(_db_unittest_curs &curs) {
    curs.index++;
}

// --- atf_unit.FDb.unittest_curs.Access
// item access
inline atf_unit::FUnittest& atf_unit::_db_unittest_curs_Access(_db_unittest_curs &curs) {
    return unittest_qFind(u64(curs.index));
}
inline atf_unit::FNumber::FNumber() {
    atf_unit::FNumber_Init(*this);
}

inline atf_unit::FNumber::~FNumber() {
    atf_unit::FNumber_Uninit(*this);
}


// --- atf_unit.FNumber..Init
// Set all fields to initial values.
inline void atf_unit::FNumber_Init(atf_unit::FNumber& number) {
    number.num = i32(0);
    number.number_next = (atf_unit::FNumber*)-1; // (atf_unit.FDb.number) not-in-tpool's freelist
    number.tr_number_up = (atf_unit::FNumber*)-1; // (atf_unit.FDb.tr_number) not in tree
    number.tr_number_left = NULL;
    number.tr_number_right = NULL;
    number.tr_number_depth = 0;
}
inline atf_unit::FPerfSort::FPerfSort() {
    atf_unit::FPerfSort_Init(*this);
}

inline atf_unit::FPerfSort::~FPerfSort() {
    atf_unit::FPerfSort_Uninit(*this);
}


// --- atf_unit.FPerfSort.orig.EmptyQ
// Return true if index is empty
inline bool atf_unit::orig_EmptyQ(atf_unit::FPerfSort& parent) {
    return parent.orig_n == 0;
}

// --- atf_unit.FPerfSort.orig.Find
// Look up row by row id. Return NULL if out of range
inline atf_unit::Dbl* atf_unit::orig_Find(atf_unit::FPerfSort& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.orig_n;
    if (idx >= lim) return NULL;
    return parent.orig_elems + idx;
}

// --- atf_unit.FPerfSort.orig.Getary
// Return array pointer by value
inline algo::aryptr<atf_unit::Dbl> atf_unit::orig_Getary(atf_unit::FPerfSort& parent) {
    return algo::aryptr<atf_unit::Dbl>(parent.orig_elems, parent.orig_n);
}

// --- atf_unit.FPerfSort.orig.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_unit::Dbl* atf_unit::orig_Last(atf_unit::FPerfSort& parent) {
    return orig_Find(parent, u64(parent.orig_n-1));
}

// --- atf_unit.FPerfSort.orig.Max
// Return max. number of items in the array
inline i32 atf_unit::orig_Max(atf_unit::FPerfSort& parent) {
    (void)parent;
    return parent.orig_max;
}

// --- atf_unit.FPerfSort.orig.N
// Return number of items in the array
inline i32 atf_unit::orig_N(const atf_unit::FPerfSort& parent) {
    return parent.orig_n;
}

// --- atf_unit.FPerfSort.orig.RemoveAll
inline void atf_unit::orig_RemoveAll(atf_unit::FPerfSort& parent) {
    parent.orig_n = 0;
}

// --- atf_unit.FPerfSort.orig.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_unit::orig_Reserve(atf_unit::FPerfSort& parent, int n) {
    u32 new_n = parent.orig_n + n;
    if (UNLIKELY(new_n > parent.orig_max)) {
        orig_AbsReserve(parent, new_n);
    }
}

// --- atf_unit.FPerfSort.orig.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_unit::Dbl& atf_unit::orig_qFind(atf_unit::FPerfSort& parent, u64 t) {
    return parent.orig_elems[t];
}

// --- atf_unit.FPerfSort.orig.qLast
// Return reference to last element of array. No bounds checking
inline atf_unit::Dbl& atf_unit::orig_qLast(atf_unit::FPerfSort& parent) {
    return orig_qFind(parent, u64(parent.orig_n-1));
}

// --- atf_unit.FPerfSort.orig.rowid_Get
// Return row id of specified element
inline u64 atf_unit::orig_rowid_Get(atf_unit::FPerfSort& parent, atf_unit::Dbl &elem) {
    u64 id = &elem - parent.orig_elems;
    return u64(id);
}

// --- atf_unit.FPerfSort.sorted.EmptyQ
// Return true if index is empty
inline bool atf_unit::sorted_EmptyQ(atf_unit::FPerfSort& parent) {
    return parent.sorted_n == 0;
}

// --- atf_unit.FPerfSort.sorted.Find
// Look up row by row id. Return NULL if out of range
inline atf_unit::Dbl* atf_unit::sorted_Find(atf_unit::FPerfSort& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.sorted_n;
    if (idx >= lim) return NULL;
    return parent.sorted_elems + idx;
}

// --- atf_unit.FPerfSort.sorted.Getary
// Return array pointer by value
inline algo::aryptr<atf_unit::Dbl> atf_unit::sorted_Getary(atf_unit::FPerfSort& parent) {
    return algo::aryptr<atf_unit::Dbl>(parent.sorted_elems, parent.sorted_n);
}

// --- atf_unit.FPerfSort.sorted.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_unit::Dbl* atf_unit::sorted_Last(atf_unit::FPerfSort& parent) {
    return sorted_Find(parent, u64(parent.sorted_n-1));
}

// --- atf_unit.FPerfSort.sorted.Max
// Return max. number of items in the array
inline i32 atf_unit::sorted_Max(atf_unit::FPerfSort& parent) {
    (void)parent;
    return parent.sorted_max;
}

// --- atf_unit.FPerfSort.sorted.N
// Return number of items in the array
inline i32 atf_unit::sorted_N(const atf_unit::FPerfSort& parent) {
    return parent.sorted_n;
}

// --- atf_unit.FPerfSort.sorted.RemoveAll
inline void atf_unit::sorted_RemoveAll(atf_unit::FPerfSort& parent) {
    parent.sorted_n = 0;
}

// --- atf_unit.FPerfSort.sorted.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_unit::sorted_Reserve(atf_unit::FPerfSort& parent, int n) {
    u32 new_n = parent.sorted_n + n;
    if (UNLIKELY(new_n > parent.sorted_max)) {
        sorted_AbsReserve(parent, new_n);
    }
}

// --- atf_unit.FPerfSort.sorted.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_unit::Dbl& atf_unit::sorted_qFind(atf_unit::FPerfSort& parent, u64 t) {
    return parent.sorted_elems[t];
}

// --- atf_unit.FPerfSort.sorted.qLast
// Return reference to last element of array. No bounds checking
inline atf_unit::Dbl& atf_unit::sorted_qLast(atf_unit::FPerfSort& parent) {
    return sorted_qFind(parent, u64(parent.sorted_n-1));
}

// --- atf_unit.FPerfSort.sorted.rowid_Get
// Return row id of specified element
inline u64 atf_unit::sorted_rowid_Get(atf_unit::FPerfSort& parent, atf_unit::Dbl &elem) {
    u64 id = &elem - parent.sorted_elems;
    return u64(id);
}

// --- atf_unit.FPerfSort.index.EmptyQ
// Return true if index is empty
inline bool atf_unit::index_EmptyQ(atf_unit::FPerfSort& parent) {
    return parent.index_n == 0;
}

// --- atf_unit.FPerfSort.index.Find
// Look up row by row id. Return NULL if out of range
inline i32* atf_unit::index_Find(atf_unit::FPerfSort& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.index_n;
    if (idx >= lim) return NULL;
    return parent.index_elems + idx;
}

// --- atf_unit.FPerfSort.index.Getary
// Return array pointer by value
inline algo::aryptr<i32> atf_unit::index_Getary(atf_unit::FPerfSort& parent) {
    return algo::aryptr<i32>(parent.index_elems, parent.index_n);
}

// --- atf_unit.FPerfSort.index.Last
// Return pointer to last element of array, or NULL if array is empty
inline i32* atf_unit::index_Last(atf_unit::FPerfSort& parent) {
    return index_Find(parent, u64(parent.index_n-1));
}

// --- atf_unit.FPerfSort.index.Max
// Return max. number of items in the array
inline i32 atf_unit::index_Max(atf_unit::FPerfSort& parent) {
    (void)parent;
    return parent.index_max;
}

// --- atf_unit.FPerfSort.index.N
// Return number of items in the array
inline i32 atf_unit::index_N(const atf_unit::FPerfSort& parent) {
    return parent.index_n;
}

// --- atf_unit.FPerfSort.index.RemoveAll
inline void atf_unit::index_RemoveAll(atf_unit::FPerfSort& parent) {
    parent.index_n = 0;
}

// --- atf_unit.FPerfSort.index.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_unit::index_Reserve(atf_unit::FPerfSort& parent, int n) {
    u32 new_n = parent.index_n + n;
    if (UNLIKELY(new_n > parent.index_max)) {
        index_AbsReserve(parent, new_n);
    }
}

// --- atf_unit.FPerfSort.index.qFind
// 'quick' Access row by row id. No bounds checking.
inline i32& atf_unit::index_qFind(atf_unit::FPerfSort& parent, u64 t) {
    return parent.index_elems[t];
}

// --- atf_unit.FPerfSort.index.qLast
// Return reference to last element of array. No bounds checking
inline i32& atf_unit::index_qLast(atf_unit::FPerfSort& parent) {
    return index_qFind(parent, u64(parent.index_n-1));
}

// --- atf_unit.FPerfSort.index.rowid_Get
// Return row id of specified element
inline u64 atf_unit::index_rowid_Get(atf_unit::FPerfSort& parent, i32 &elem) {
    u64 id = &elem - parent.index_elems;
    return u64(id);
}

// --- atf_unit.FPerfSort.orig_curs.Next
// proceed to next item
inline void atf_unit::FPerfSort_orig_curs_Next(FPerfSort_orig_curs &curs) {
    curs.index++;
}

// --- atf_unit.FPerfSort.orig_curs.Reset
inline void atf_unit::FPerfSort_orig_curs_Reset(FPerfSort_orig_curs &curs, atf_unit::FPerfSort &parent) {
    curs.elems = parent.orig_elems;
    curs.n_elems = parent.orig_n;
    curs.index = 0;
}

// --- atf_unit.FPerfSort.orig_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::FPerfSort_orig_curs_ValidQ(FPerfSort_orig_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_unit.FPerfSort.orig_curs.Access
// item access
inline atf_unit::Dbl& atf_unit::FPerfSort_orig_curs_Access(FPerfSort_orig_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_unit.FPerfSort.sorted_curs.Next
// proceed to next item
inline void atf_unit::FPerfSort_sorted_curs_Next(FPerfSort_sorted_curs &curs) {
    curs.index++;
}

// --- atf_unit.FPerfSort.sorted_curs.Reset
inline void atf_unit::FPerfSort_sorted_curs_Reset(FPerfSort_sorted_curs &curs, atf_unit::FPerfSort &parent) {
    curs.elems = parent.sorted_elems;
    curs.n_elems = parent.sorted_n;
    curs.index = 0;
}

// --- atf_unit.FPerfSort.sorted_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::FPerfSort_sorted_curs_ValidQ(FPerfSort_sorted_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_unit.FPerfSort.sorted_curs.Access
// item access
inline atf_unit::Dbl& atf_unit::FPerfSort_sorted_curs_Access(FPerfSort_sorted_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_unit.FPerfSort.index_curs.Next
// proceed to next item
inline void atf_unit::FPerfSort_index_curs_Next(FPerfSort_index_curs &curs) {
    curs.index++;
}

// --- atf_unit.FPerfSort.index_curs.Reset
inline void atf_unit::FPerfSort_index_curs_Reset(FPerfSort_index_curs &curs, atf_unit::FPerfSort &parent) {
    curs.elems = parent.index_elems;
    curs.n_elems = parent.index_n;
    curs.index = 0;
}

// --- atf_unit.FPerfSort.index_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::FPerfSort_index_curs_ValidQ(FPerfSort_index_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_unit.FPerfSort.index_curs.Access
// item access
inline i32& atf_unit::FPerfSort_index_curs_Access(FPerfSort_index_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_unit.FPerfSort..Init
// Set all fields to initial values.
inline void atf_unit::FPerfSort_Init(atf_unit::FPerfSort& parent) {
    parent.orig_elems 	= 0; // (atf_unit.FPerfSort.orig)
    parent.orig_n     	= 0; // (atf_unit.FPerfSort.orig)
    parent.orig_max   	= 0; // (atf_unit.FPerfSort.orig)
    parent.sorted_elems 	= 0; // (atf_unit.FPerfSort.sorted)
    parent.sorted_n     	= 0; // (atf_unit.FPerfSort.sorted)
    parent.sorted_max   	= 0; // (atf_unit.FPerfSort.sorted)
    parent.index_elems 	= 0; // (atf_unit.FPerfSort.index)
    parent.index_n     	= 0; // (atf_unit.FPerfSort.index)
    parent.index_max   	= 0; // (atf_unit.FPerfSort.index)
}
inline atf_unit::FUnittest::FUnittest() {
    atf_unit::FUnittest_Init(*this);
}

inline atf_unit::FUnittest::~FUnittest() {
    atf_unit::FUnittest_Uninit(*this);
}


// --- atf_unit.FUnittest.step.Call
// Invoke function by pointer
inline void atf_unit::step_Call(atf_unit::FUnittest& unittest) {
    if (unittest.step) {
        unittest.step();
    }
}

// --- atf_unit.FUnittest..Init
// Set all fields to initial values.
inline void atf_unit::FUnittest_Init(atf_unit::FUnittest& unittest) {
    unittest.select = bool(false);
    unittest.success = bool(false);
    unittest.ind_unittest_next = (atf_unit::FUnittest*)-1; // (atf_unit.FDb.ind_unittest) not-in-hash
    unittest.step = NULL;
}
inline atf_unit::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline atf_unit::FieldId::FieldId(atf_unit_FieldIdEnum arg) { this->value = i32(arg); }
inline atf_unit::FieldId::FieldId() {
    atf_unit::FieldId_Init(*this);
}


// --- atf_unit.FieldId.value.GetEnum
// Get value of field as enum type
inline atf_unit_FieldIdEnum atf_unit::value_GetEnum(const atf_unit::FieldId& parent) {
    return atf_unit_FieldIdEnum(parent.value);
}

// --- atf_unit.FieldId.value.SetEnum
// Set value of field from enum type.
inline void atf_unit::value_SetEnum(atf_unit::FieldId& parent, atf_unit_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- atf_unit.FieldId.value.Cast
inline atf_unit::FieldId::operator atf_unit_FieldIdEnum () const {
    return atf_unit_FieldIdEnum((*this).value);
}

// --- atf_unit.FieldId..Init
// Set all fields to initial values.
inline void atf_unit::FieldId_Init(atf_unit::FieldId& parent) {
    parent.value = i32(-1);
}
inline atf_unit::ShStream::ShStream() {
}

inline atf_unit::ShStreamAry::ShStreamAry() {
    atf_unit::ShStreamAry_Init(*this);
}

inline atf_unit::ShStreamAry::~ShStreamAry() {
    atf_unit::ShStreamAry_Uninit(*this);
}


// --- atf_unit.ShStreamAry.shstream.EmptyQ
// Return true if index is empty
inline bool atf_unit::shstream_EmptyQ(atf_unit::ShStreamAry& parent) {
    return parent.shstream_n == 0;
}

// --- atf_unit.ShStreamAry.shstream.Find
// Look up row by row id. Return NULL if out of range
inline atf_unit::ShStream* atf_unit::shstream_Find(atf_unit::ShStreamAry& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.shstream_n;
    if (idx >= lim) return NULL;
    return parent.shstream_elems + idx;
}

// --- atf_unit.ShStreamAry.shstream.Getary
// Return array pointer by value
inline algo::aryptr<atf_unit::ShStream> atf_unit::shstream_Getary(atf_unit::ShStreamAry& parent) {
    return algo::aryptr<atf_unit::ShStream>(parent.shstream_elems, parent.shstream_n);
}

// --- atf_unit.ShStreamAry.shstream.Last
// Return pointer to last element of array, or NULL if array is empty
inline atf_unit::ShStream* atf_unit::shstream_Last(atf_unit::ShStreamAry& parent) {
    return shstream_Find(parent, u64(parent.shstream_n-1));
}

// --- atf_unit.ShStreamAry.shstream.Max
// Return max. number of items in the array
inline i32 atf_unit::shstream_Max(atf_unit::ShStreamAry& parent) {
    (void)parent;
    return parent.shstream_max;
}

// --- atf_unit.ShStreamAry.shstream.N
// Return number of items in the array
inline i32 atf_unit::shstream_N(const atf_unit::ShStreamAry& parent) {
    return parent.shstream_n;
}

// --- atf_unit.ShStreamAry.shstream.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void atf_unit::shstream_Reserve(atf_unit::ShStreamAry& parent, int n) {
    u32 new_n = parent.shstream_n + n;
    if (UNLIKELY(new_n > parent.shstream_max)) {
        shstream_AbsReserve(parent, new_n);
    }
}

// --- atf_unit.ShStreamAry.shstream.qFind
// 'quick' Access row by row id. No bounds checking.
inline atf_unit::ShStream& atf_unit::shstream_qFind(atf_unit::ShStreamAry& parent, u64 t) {
    return parent.shstream_elems[t];
}

// --- atf_unit.ShStreamAry.shstream.qLast
// Return reference to last element of array. No bounds checking
inline atf_unit::ShStream& atf_unit::shstream_qLast(atf_unit::ShStreamAry& parent) {
    return shstream_qFind(parent, u64(parent.shstream_n-1));
}

// --- atf_unit.ShStreamAry.shstream.rowid_Get
// Return row id of specified element
inline u64 atf_unit::shstream_rowid_Get(atf_unit::ShStreamAry& parent, atf_unit::ShStream &elem) {
    u64 id = &elem - parent.shstream_elems;
    return u64(id);
}

// --- atf_unit.ShStreamAry.shstream_curs.Next
// proceed to next item
inline void atf_unit::ShStreamAry_shstream_curs_Next(ShStreamAry_shstream_curs &curs) {
    curs.index++;
}

// --- atf_unit.ShStreamAry.shstream_curs.Reset
inline void atf_unit::ShStreamAry_shstream_curs_Reset(ShStreamAry_shstream_curs &curs, atf_unit::ShStreamAry &parent) {
    curs.elems = parent.shstream_elems;
    curs.n_elems = parent.shstream_n;
    curs.index = 0;
}

// --- atf_unit.ShStreamAry.shstream_curs.ValidQ
// cursor points to valid item
inline bool atf_unit::ShStreamAry_shstream_curs_ValidQ(ShStreamAry_shstream_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- atf_unit.ShStreamAry.shstream_curs.Access
// item access
inline atf_unit::ShStream& atf_unit::ShStreamAry_shstream_curs_Access(ShStreamAry_shstream_curs &curs) {
    return curs.elems[curs.index];
}

// --- atf_unit.ShStreamAry..Init
// Set all fields to initial values.
inline void atf_unit::ShStreamAry_Init(atf_unit::ShStreamAry& parent) {
    parent.shstream_elems 	= 0; // (atf_unit.ShStreamAry.shstream)
    parent.shstream_n     	= 0; // (atf_unit.ShStreamAry.shstream)
    parent.shstream_max   	= 0; // (atf_unit.ShStreamAry.shstream)
}

inline bool atf_unit::TypeA::operator ==(const atf_unit::TypeA &rhs) const {
    return atf_unit::TypeA_Eq(const_cast<atf_unit::TypeA&>(*this),const_cast<atf_unit::TypeA&>(rhs));
}

inline bool atf_unit::TypeA::operator !=(const atf_unit::TypeA &rhs) const {
    return !atf_unit::TypeA_Eq(const_cast<atf_unit::TypeA&>(*this),const_cast<atf_unit::TypeA&>(rhs));
}

inline bool atf_unit::TypeA::operator <(const atf_unit::TypeA &rhs) const {
    return atf_unit::TypeA_Lt(const_cast<atf_unit::TypeA&>(*this),const_cast<atf_unit::TypeA&>(rhs));
}
inline atf_unit::TypeA::TypeA() {
    atf_unit::TypeA_Init(*this);
}


// --- atf_unit.TypeA..Hash
inline u32 atf_unit::TypeA_Hash(u32 prev, const atf_unit::TypeA & rhs) {
    prev = i32_Hash(prev, rhs.typea);
    return prev;
}

// --- atf_unit.TypeA..Lt
inline bool atf_unit::TypeA_Lt(atf_unit::TypeA & lhs, atf_unit::TypeA & rhs) {
    return i32_Lt(lhs.typea, rhs.typea);
}

// --- atf_unit.TypeA..Cmp
inline i32 atf_unit::TypeA_Cmp(atf_unit::TypeA & lhs, atf_unit::TypeA & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typea, rhs.typea);
    return retval;
}

// --- atf_unit.TypeA..Init
// Set all fields to initial values.
inline void atf_unit::TypeA_Init(atf_unit::TypeA& parent) {
    parent.typea = i32(0);
}

// --- atf_unit.TypeA..Eq
inline bool atf_unit::TypeA_Eq(const atf_unit::TypeA & lhs,const atf_unit::TypeA & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typea, rhs.typea);
    return retval;
}

// --- atf_unit.TypeA..Update
// Set value. Return true if new value is different from old value.
inline bool atf_unit::TypeA_Update(atf_unit::TypeA &lhs, atf_unit::TypeA & rhs) {
    bool ret = !TypeA_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline bool atf_unit::TypeB::operator ==(const atf_unit::TypeB &rhs) const {
    return atf_unit::TypeB_Eq(const_cast<atf_unit::TypeB&>(*this),const_cast<atf_unit::TypeB&>(rhs));
}

inline bool atf_unit::TypeB::operator !=(const atf_unit::TypeB &rhs) const {
    return !atf_unit::TypeB_Eq(const_cast<atf_unit::TypeB&>(*this),const_cast<atf_unit::TypeB&>(rhs));
}

inline bool atf_unit::TypeB::operator <(const atf_unit::TypeB &rhs) const {
    return atf_unit::TypeB_Lt(const_cast<atf_unit::TypeB&>(*this),const_cast<atf_unit::TypeB&>(rhs));
}
inline atf_unit::TypeB::TypeB() {
    atf_unit::TypeB_Init(*this);
}


// --- atf_unit.TypeB..Hash
inline u32 atf_unit::TypeB_Hash(u32 prev, const atf_unit::TypeB & rhs) {
    prev = i32_Hash(prev, rhs.typea);
    prev = i32_Hash(prev, rhs.j);
    return prev;
}

// --- atf_unit.TypeB..Lt
inline bool atf_unit::TypeB_Lt(atf_unit::TypeB & lhs, atf_unit::TypeB & rhs) {
    return TypeB_Cmp(lhs,rhs) < 0;
}

// --- atf_unit.TypeB..Cmp
inline i32 atf_unit::TypeB_Cmp(atf_unit::TypeB & lhs, atf_unit::TypeB & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.typea, rhs.typea);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.j, rhs.j);
    return retval;
}

// --- atf_unit.TypeB..Init
// Set all fields to initial values.
inline void atf_unit::TypeB_Init(atf_unit::TypeB& parent) {
    parent.typea = i32(0);
    parent.j = i32(0);
}

// --- atf_unit.TypeB..Eq
inline bool atf_unit::TypeB_Eq(const atf_unit::TypeB & lhs,const atf_unit::TypeB & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.typea, rhs.typea);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.j, rhs.j);
    return retval;
}

// --- atf_unit.TypeB..Update
// Set value. Return true if new value is different from old value.
inline bool atf_unit::TypeB_Update(atf_unit::TypeB &lhs, atf_unit::TypeB & rhs) {
    bool ret = !TypeB_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline atf_unit::TestJson::TestJson() {
    atf_unit::TestJson_Init(*this);
}


inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::Dbl &row) {// cfmt:atf_unit.Dbl.String
    atf_unit::Dbl_Print(const_cast<atf_unit::Dbl&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::TestArgtuple1 &row) {// cfmt:atf_unit.TestArgtuple1.String
    atf_unit::TestArgtuple1_Print(const_cast<atf_unit::TestArgtuple1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::trace &row) {// cfmt:atf_unit.trace.String
    atf_unit::trace_Print(const_cast<atf_unit::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::FUnittest &row) {// cfmt:atf_unit.FUnittest.String
    atf_unit::FUnittest_Print(const_cast<atf_unit::FUnittest&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::FieldId &row) {// cfmt:atf_unit.FieldId.String
    atf_unit::FieldId_Print(const_cast<atf_unit::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::TypeA &row) {// cfmt:atf_unit.TypeA.String
    atf_unit::TypeA_Print(const_cast<atf_unit::TypeA&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::TypeB &row) {// cfmt:atf_unit.TypeB.String
    atf_unit::TypeB_Print(const_cast<atf_unit::TypeB&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const atf_unit::TestJson &row) {// cfmt:atf_unit.TestJson.String
    atf_unit::TestJson_Print(const_cast<atf_unit::TestJson&>(row), str);
    return str;
}
