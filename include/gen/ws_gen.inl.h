//
// include/gen/ws_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/ams_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude

// --- ws.Side.value.GetEnum
// Get value of field as enum type
inline ws_SideEnum ws::value_GetEnum(const ws::Side& parent) {
    return ws_SideEnum(parent.value);
}

// --- ws.Side.value.SetEnum
// Set value of field from enum type.
inline void ws::value_SetEnum(ws::Side& parent, ws_SideEnum rhs) {
    parent.value = char(rhs);
}

// --- ws.Side.value.Cast
inline  ws::Side::operator ws_SideEnum() const {
    return ws_SideEnum((*this).value);
}

// --- ws.Side..Init
// Set all fields to initial values.
inline void ws::Side_Init(ws::Side& parent) {
    parent.value = char(0);
}

// --- ws.Side..Ctor
inline  ws::Side::Side() {
    ws::Side_Init(*this);
}

// --- ws.Side..FieldwiseCtor
inline  ws::Side::Side(char in_value)
    : value(in_value)
 {
}

// --- ws.Side..EnumCtor
inline  ws::Side::Side(ws_SideEnum arg) {
    this->value = char(arg);
}

// --- ws.StatusCode.value.GetEnum
// Get value of field as enum type
inline ws_StatusCodeEnum ws::value_GetEnum(const ws::StatusCode& parent) {
    return ws_StatusCodeEnum(parent.value);
}

// --- ws.StatusCode.value.SetEnum
// Set value of field from enum type.
inline void ws::value_SetEnum(ws::StatusCode& parent, ws_StatusCodeEnum rhs) {
    parent.value = u16(rhs);
}

// --- ws.StatusCode.value.Cast
inline  ws::StatusCode::operator ws_StatusCodeEnum() const {
    return ws_StatusCodeEnum((*this).value);
}

// --- ws.StatusCode..Init
// Set all fields to initial values.
inline void ws::StatusCode_Init(ws::StatusCode& parent) {
    parent.value = u16(0);
}

// --- ws.StatusCode..Ctor
inline  ws::StatusCode::StatusCode() {
    ws::StatusCode_Init(*this);
}

// --- ws.StatusCode..FieldwiseCtor
inline  ws::StatusCode::StatusCode(u16 in_value)
    : value(in_value)
 {
}

// --- ws.StatusCode..EnumCtor
inline  ws::StatusCode::StatusCode(ws_StatusCodeEnum arg) {
    this->value = u16(arg);
}

// --- ws.CloseMsg.base.Castdown
// Check if ams::MsgHeader is an instance of CloseMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of CloseMsg.
// If not successful, quietly return NULL.
inline ws::CloseMsg* ws::CloseMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (504);
    cond &= i32(hdr.length) >= ssizeof(ws::CloseMsg);
    return cond ? reinterpret_cast<ws::CloseMsg*>(&hdr) : NULL;
}

// --- ws.CloseMsg.base.Castbase
inline ams::MsgHeader& ws::Castbase(ws::CloseMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ws.CloseMsg.reason.N
// Return number of elements in varlen field
inline u32 ws::reason_N(const ws::CloseMsg& parent) {
    u32 length = i32(((ws::CloseMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ws::CloseMsg)) - sizeof(ws::CloseMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ws.CloseMsg.reason_curs.Reset
inline void ws::CloseMsg_reason_curs_Reset(CloseMsg_reason_curs &curs, ws::CloseMsg &parent) {
    curs.ptr = (u8*)reason_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ws::CloseMsg);
    curs.index = 0;
}

// --- ws.CloseMsg.reason_curs.ValidQ
// cursor points to valid item
inline bool ws::CloseMsg_reason_curs_ValidQ(CloseMsg_reason_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ws.CloseMsg.reason_curs.Next
// proceed to next item
inline void ws::CloseMsg_reason_curs_Next(CloseMsg_reason_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ws.CloseMsg.reason_curs.Access
// item access
inline char& ws::CloseMsg_reason_curs_Access(CloseMsg_reason_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ws.CloseMsg..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::CloseMsg& parent) {
    return i32(const_cast<ws::CloseMsg&>(parent).length);
}

// --- ws.CloseMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::CloseMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ws::CloseMsg&>(row).length));
}

// --- ws.CloseMsg..Init
// Set all fields to initial values.
inline void ws::CloseMsg_Init(ws::CloseMsg& parent) {
    parent.type = u32(504);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ws.CloseMsg..Ctor
inline  ws::CloseMsg::CloseMsg() {
    ws::CloseMsg_Init(*this);
}

// --- ws.ConnectMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ConnectMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ConnectMsg.
// If not successful, quietly return NULL.
inline ws::ConnectMsg* ws::ConnectMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (502);
    cond &= i32(hdr.length) >= ssizeof(ws::ConnectMsg);
    return cond ? reinterpret_cast<ws::ConnectMsg*>(&hdr) : NULL;
}

// --- ws.ConnectMsg.base.Castbase
inline ams::MsgHeader& ws::Castbase(ws::ConnectMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ws.ConnectMsg..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::ConnectMsg& parent) {
    return i32(const_cast<ws::ConnectMsg&>(parent).length);
}

// --- ws.ConnectMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::ConnectMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ws::ConnectMsg&>(row).length));
}

// --- ws.ConnectMsg..Init
// Set all fields to initial values.
inline void ws::ConnectMsg_Init(ws::ConnectMsg& parent) {
    parent.type = u32(502);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ws.ConnectMsg..Ctor
inline  ws::ConnectMsg::ConnectMsg() {
    ws::ConnectMsg_Init(*this);
}

// --- ws.Opcode.value.GetEnum
// Get value of field as enum type
inline ws_OpcodeEnum ws::value_GetEnum(const ws::Opcode& parent) {
    return ws_OpcodeEnum(parent.value);
}

// --- ws.Opcode.value.SetEnum
// Set value of field from enum type.
inline void ws::value_SetEnum(ws::Opcode& parent, ws_OpcodeEnum rhs) {
    parent.value = u8(rhs);
}

// --- ws.Opcode..Init
// Set all fields to initial values.
inline void ws::Opcode_Init(ws::Opcode& parent) {
    parent.value = u8(0);
}

// --- ws.Opcode..Ctor
inline  ws::Opcode::Opcode() {
    ws::Opcode_Init(*this);
}

// --- ws.Opcode..FieldwiseCtor
inline  ws::Opcode::Opcode(u8 in_value)
    : value(in_value)
 {
}

// --- ws.Opcode..EnumCtor
inline  ws::Opcode::Opcode(ws_OpcodeEnum arg) {
    this->value = u8(arg);
}

// --- ws.DataMsg.base.Castdown
// Check if ams::MsgHeader is an instance of DataMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of DataMsg.
// If not successful, quietly return NULL.
inline ws::DataMsg* ws::DataMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (503);
    cond &= i32(hdr.length) >= ssizeof(ws::DataMsg);
    return cond ? reinterpret_cast<ws::DataMsg*>(&hdr) : NULL;
}

// --- ws.DataMsg.base.Castbase
inline ams::MsgHeader& ws::Castbase(ws::DataMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ws.DataMsg.data.N
// Return number of elements in varlen field
inline u32 ws::data_N(const ws::DataMsg& parent) {
    u32 length = i32(((ws::DataMsg&)parent).length);
    u32 extra_bytes = u32_Max(length,sizeof(ws::DataMsg)) - sizeof(ws::DataMsg); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ws.DataMsg.data_curs.Reset
inline void ws::DataMsg_data_curs_Reset(DataMsg_data_curs &curs, ws::DataMsg &parent) {
    curs.ptr = (u8*)data_Addr(parent);
    curs.length = i32(parent.length) - sizeof(ws::DataMsg);
    curs.index = 0;
}

// --- ws.DataMsg.data_curs.ValidQ
// cursor points to valid item
inline bool ws::DataMsg_data_curs_ValidQ(DataMsg_data_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ws.DataMsg.data_curs.Next
// proceed to next item
inline void ws::DataMsg_data_curs_Next(DataMsg_data_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ws.DataMsg.data_curs.Access
// item access
inline char& ws::DataMsg_data_curs_Access(DataMsg_data_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ws.DataMsg..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::DataMsg& parent) {
    return i32(const_cast<ws::DataMsg&>(parent).length);
}

// --- ws.DataMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::DataMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ws::DataMsg&>(row).length));
}

// --- ws.DataMsg..Init
// Set all fields to initial values.
inline void ws::DataMsg_Init(ws::DataMsg& parent) {
    parent.type = u32(503);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ws.DataMsg..Ctor
inline  ws::DataMsg::DataMsg() {
    ws::DataMsg_Init(*this);
}

// --- ws.FieldId.value.GetEnum
// Get value of field as enum type
inline ws_FieldIdEnum ws::value_GetEnum(const ws::FieldId& parent) {
    return ws_FieldIdEnum(parent.value);
}

// --- ws.FieldId.value.SetEnum
// Set value of field from enum type.
inline void ws::value_SetEnum(ws::FieldId& parent, ws_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- ws.FieldId.value.Cast
inline  ws::FieldId::operator ws_FieldIdEnum() const {
    return ws_FieldIdEnum((*this).value);
}

// --- ws.FieldId..Init
// Set all fields to initial values.
inline void ws::FieldId_Init(ws::FieldId& parent) {
    parent.value = i32(-1);
}

// --- ws.FieldId..Ctor
inline  ws::FieldId::FieldId() {
    ws::FieldId_Init(*this);
}

// --- ws.FieldId..FieldwiseCtor
inline  ws::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- ws.FieldId..EnumCtor
inline  ws::FieldId::FieldId(ws_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- ws.Frame.base.Castbase
inline ws::FrameHeader& ws::Castbase(ws::Frame& parent) {
    return reinterpret_cast<ws::FrameHeader&>(parent);
}

// --- ws.Frame.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::Frame& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.Frame.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::Frame& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::Frame& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.Frame.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::Frame& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::Frame& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.Frame.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::Frame& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::Frame& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.Frame.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::Frame& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::Frame& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.Frame.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::Frame& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::Frame& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.Frame.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::Frame& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.Frame.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::Frame& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.Frame.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::Frame& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.Frame..Ctor
inline  ws::Frame::Frame() {
    ws::Frame_Init(*this);
}

// --- ws.Frame16.base.Castdown
// Check if ws::FrameHeader is an instance of Frame16 by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Frame16.
// If not successful, quietly return NULL.
inline ws::Frame16* ws::Frame16_Castdown(ws::FrameHeader &hdr) {
    bool cond = hdr.byte1 == (126);
    cond &= i32(sizeof(ws::FrameHeader)) >= ssizeof(ws::Frame16);
    return cond ? reinterpret_cast<ws::Frame16*>(&hdr) : NULL;
}

// --- ws.Frame16.base.Castbase
inline ws::FrameHeader& ws::Castbase(ws::Frame16& parent) {
    return reinterpret_cast<ws::FrameHeader&>(parent);
}

// --- ws.Frame16.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::Frame16& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.Frame16.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::Frame16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame16.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::Frame16& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.Frame16.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::Frame16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame16.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::Frame16& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.Frame16.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::Frame16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame16.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::Frame16& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.Frame16.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::Frame16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame16.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::Frame16& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.Frame16.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::Frame16& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame16.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::Frame16& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.Frame16.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::Frame16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.Frame16.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::Frame16& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.Frame16.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::Frame16& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.Frame16.ext_payload_len.Get
inline u16 ws::ext_payload_len_Get(const ws::Frame16& parent) {
    return be16toh(parent.ext_payload_len_be); // read big-endian value from memory
}

// --- ws.Frame16.ext_payload_len.Set
inline void ws::ext_payload_len_Set(ws::Frame16& parent, u16 rhs) {
    parent.ext_payload_len_be = htobe16(rhs); // write big-endian value to memory
}

// --- ws.Frame16.payload.N
// Return number of elements in varlen field
inline u32 ws::payload_N(const ws::Frame16& parent) {
    u32 length = i32(ext_payload_len_Get(((ws::Frame16&)parent)) + 4);
    u32 extra_bytes = u32_Max(length,sizeof(ws::Frame16)) - sizeof(ws::Frame16); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ws.Frame16.payload_curs.Reset
inline void ws::Frame16_payload_curs_Reset(Frame16_payload_curs &curs, ws::Frame16 &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(ext_payload_len_Get(parent) + 4) - sizeof(ws::Frame16);
    curs.index = 0;
}

// --- ws.Frame16.payload_curs.ValidQ
// cursor points to valid item
inline bool ws::Frame16_payload_curs_ValidQ(Frame16_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ws.Frame16.payload_curs.Next
// proceed to next item
inline void ws::Frame16_payload_curs_Next(Frame16_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ws.Frame16.payload_curs.Access
// item access
inline char& ws::Frame16_payload_curs_Access(Frame16_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ws.Frame16..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::Frame16& parent) {
    return i32(ext_payload_len_Get(const_cast<ws::Frame16&>(parent)) + 4);
}

// --- ws.Frame16..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::Frame16& row) {
    return algo::memptr((u8*)&row, i32(ext_payload_len_Get(const_cast<ws::Frame16&>(row)) + 4));
}

// --- ws.Frame16..Ctor
inline  ws::Frame16::Frame16() {
    ws::Frame16_Init(*this);
}

// --- ws.Frame16_curs..ValidQ
inline bool ws::Frame16_curs_ValidQ(ws::Frame16_curs& curs) {
    return curs.msg != NULL;
}

// --- ws.Frame16_curs..Reset
inline void ws::Frame16_curs_Reset(ws::Frame16_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    ws::Frame16 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::Frame16)) {
        ws::Frame16 *ptr = (ws::Frame16*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 4);
        if (msglen >= ssizeof(ws::Frame16) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.Frame16_curs..Access
inline ws::Frame16*& ws::Frame16_curs_Access(ws::Frame16_curs& curs) {
    return curs.msg;
}

// --- ws.Frame16_curs..Next
inline void ws::Frame16_curs_Next(ws::Frame16_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    ws::Frame16 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::Frame16)) {
        ws::Frame16 *ptr = (ws::Frame16*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 4);
        if (msglen >= ssizeof(ws::Frame16) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.Frame16_curs..Init
// Set all fields to initial values.
inline void ws::Frame16_curs_Init(ws::Frame16_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- ws.Frame16_curs..Ctor
inline  ws::Frame16_curs::Frame16_curs() {
    ws::Frame16_curs_Init(*this);
}

// --- ws.Frame64.base.Castdown
// Check if ws::FrameHeader is an instance of Frame64 by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Frame64.
// If not successful, quietly return NULL.
inline ws::Frame64* ws::Frame64_Castdown(ws::FrameHeader &hdr) {
    bool cond = hdr.byte1 == (127);
    cond &= i32(sizeof(ws::FrameHeader)) >= ssizeof(ws::Frame64);
    return cond ? reinterpret_cast<ws::Frame64*>(&hdr) : NULL;
}

// --- ws.Frame64.base.Castbase
inline ws::FrameHeader& ws::Castbase(ws::Frame64& parent) {
    return reinterpret_cast<ws::FrameHeader&>(parent);
}

// --- ws.Frame64.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::Frame64& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.Frame64.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::Frame64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame64.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::Frame64& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.Frame64.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::Frame64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame64.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::Frame64& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.Frame64.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::Frame64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame64.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::Frame64& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.Frame64.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::Frame64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame64.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::Frame64& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.Frame64.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::Frame64& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.Frame64.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::Frame64& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.Frame64.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::Frame64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.Frame64.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::Frame64& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.Frame64.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::Frame64& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.Frame64.ext_payload_len.Get
inline u64 ws::ext_payload_len_Get(const ws::Frame64& parent) {
    return be64toh(parent.ext_payload_len_be); // read big-endian value from memory
}

// --- ws.Frame64.ext_payload_len.Set
inline void ws::ext_payload_len_Set(ws::Frame64& parent, u64 rhs) {
    parent.ext_payload_len_be = htobe64(rhs); // write big-endian value to memory
}

// --- ws.Frame64.payload.N
// Return number of elements in varlen field
inline u32 ws::payload_N(const ws::Frame64& parent) {
    u32 length = i32(ext_payload_len_Get(((ws::Frame64&)parent)) + 10);
    u32 extra_bytes = u32_Max(length,sizeof(ws::Frame64)) - sizeof(ws::Frame64); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ws.Frame64.payload_curs.Reset
inline void ws::Frame64_payload_curs_Reset(Frame64_payload_curs &curs, ws::Frame64 &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(ext_payload_len_Get(parent) + 10) - sizeof(ws::Frame64);
    curs.index = 0;
}

// --- ws.Frame64.payload_curs.ValidQ
// cursor points to valid item
inline bool ws::Frame64_payload_curs_ValidQ(Frame64_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ws.Frame64.payload_curs.Next
// proceed to next item
inline void ws::Frame64_payload_curs_Next(Frame64_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ws.Frame64.payload_curs.Access
// item access
inline char& ws::Frame64_payload_curs_Access(Frame64_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ws.Frame64..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::Frame64& parent) {
    return i32(ext_payload_len_Get(const_cast<ws::Frame64&>(parent)) + 10);
}

// --- ws.Frame64..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::Frame64& row) {
    return algo::memptr((u8*)&row, i32(ext_payload_len_Get(const_cast<ws::Frame64&>(row)) + 10));
}

// --- ws.Frame64..Ctor
inline  ws::Frame64::Frame64() {
    ws::Frame64_Init(*this);
}

// --- ws.Frame64_curs..ValidQ
inline bool ws::Frame64_curs_ValidQ(ws::Frame64_curs& curs) {
    return curs.msg != NULL;
}

// --- ws.Frame64_curs..Reset
inline void ws::Frame64_curs_Reset(ws::Frame64_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    ws::Frame64 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::Frame64)) {
        ws::Frame64 *ptr = (ws::Frame64*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 10);
        if (msglen >= ssizeof(ws::Frame64) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.Frame64_curs..Access
inline ws::Frame64*& ws::Frame64_curs_Access(ws::Frame64_curs& curs) {
    return curs.msg;
}

// --- ws.Frame64_curs..Next
inline void ws::Frame64_curs_Next(ws::Frame64_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    ws::Frame64 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::Frame64)) {
        ws::Frame64 *ptr = (ws::Frame64*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 10);
        if (msglen >= ssizeof(ws::Frame64) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.Frame64_curs..Init
// Set all fields to initial values.
inline void ws::Frame64_curs_Init(ws::Frame64_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- ws.Frame64_curs..Ctor
inline  ws::Frame64_curs::Frame64_curs() {
    ws::Frame64_curs_Init(*this);
}

// --- ws.FrameHeader.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::FrameHeader& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.FrameHeader.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::FrameHeader& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameHeader.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::FrameHeader& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.FrameHeader.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::FrameHeader& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameHeader.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::FrameHeader& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.FrameHeader.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::FrameHeader& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameHeader.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::FrameHeader& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.FrameHeader.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::FrameHeader& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameHeader.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::FrameHeader& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.FrameHeader.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::FrameHeader& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameHeader.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::FrameHeader& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.FrameHeader.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::FrameHeader& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameHeader.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::FrameHeader& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.FrameHeader.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::FrameHeader& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameHeader..Init
// Set all fields to initial values.
inline void ws::FrameHeader_Init(ws::FrameHeader& parent) {
    parent.byte0 = u8(0);
    parent.byte1 = u8(0);
}

// --- ws.FrameHeader..Ctor
inline  ws::FrameHeader::FrameHeader() {
    ws::FrameHeader_Init(*this);
}

// --- ws.FrameHeaderMsgsCase.value.GetEnum
// Get value of field as enum type
inline ws_FrameHeaderMsgsCaseEnum ws::value_GetEnum(const ws::FrameHeaderMsgsCase& parent) {
    return ws_FrameHeaderMsgsCaseEnum(parent.value);
}

// --- ws.FrameHeaderMsgsCase.value.SetEnum
// Set value of field from enum type.
inline void ws::value_SetEnum(ws::FrameHeaderMsgsCase& parent, ws_FrameHeaderMsgsCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- ws.FrameHeaderMsgsCase.value.Cast
inline  ws::FrameHeaderMsgsCase::operator ws_FrameHeaderMsgsCaseEnum() const {
    return ws_FrameHeaderMsgsCaseEnum((*this).value);
}

// --- ws.FrameHeaderMsgsCase..Init
// Set all fields to initial values.
inline void ws::FrameHeaderMsgsCase_Init(ws::FrameHeaderMsgsCase& parent) {
    parent.value = u32(0);
}

// --- ws.FrameHeaderMsgsCase..Ctor
inline  ws::FrameHeaderMsgsCase::FrameHeaderMsgsCase() {
    ws::FrameHeaderMsgsCase_Init(*this);
}

// --- ws.FrameHeaderMsgsCase..FieldwiseCtor
inline  ws::FrameHeaderMsgsCase::FrameHeaderMsgsCase(u32 in_value)
    : value(in_value)
 {
}

// --- ws.FrameHeaderMsgsCase..EnumCtor
inline  ws::FrameHeaderMsgsCase::FrameHeaderMsgsCase(ws_FrameHeaderMsgsCaseEnum arg) {
    this->value = u32(arg);
}

// --- ws.FrameMasked.base.Castbase
inline ws::FrameHeader& ws::Castbase(ws::FrameMasked& parent) {
    return reinterpret_cast<ws::FrameHeader&>(parent);
}

// --- ws.FrameMasked.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::FrameMasked& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.FrameMasked.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::FrameMasked& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::FrameMasked& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.FrameMasked.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::FrameMasked& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::FrameMasked& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.FrameMasked.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::FrameMasked& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::FrameMasked& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.FrameMasked.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::FrameMasked& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::FrameMasked& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.FrameMasked.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::FrameMasked& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::FrameMasked& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.FrameMasked.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::FrameMasked& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameMasked.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::FrameMasked& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.FrameMasked.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::FrameMasked& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameMasked..Ctor
inline  ws::FrameMasked::FrameMasked() {
    ws::FrameMasked_Init(*this);
}

// --- ws.FrameMasked16.base.Castdown
// Check if ws::FrameHeader is an instance of FrameMasked16 by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of FrameMasked16.
// If not successful, quietly return NULL.
inline ws::FrameMasked16* ws::FrameMasked16_Castdown(ws::FrameHeader &hdr) {
    bool cond = hdr.byte1 == (254);
    cond &= i32(sizeof(ws::FrameHeader)) >= ssizeof(ws::FrameMasked16);
    return cond ? reinterpret_cast<ws::FrameMasked16*>(&hdr) : NULL;
}

// --- ws.FrameMasked16.base.Castbase
inline ws::FrameHeader& ws::Castbase(ws::FrameMasked16& parent) {
    return reinterpret_cast<ws::FrameHeader&>(parent);
}

// --- ws.FrameMasked16.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::FrameMasked16& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.FrameMasked16.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::FrameMasked16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked16.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::FrameMasked16& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.FrameMasked16.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::FrameMasked16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked16.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::FrameMasked16& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.FrameMasked16.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::FrameMasked16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked16.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::FrameMasked16& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.FrameMasked16.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::FrameMasked16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked16.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::FrameMasked16& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.FrameMasked16.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::FrameMasked16& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked16.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::FrameMasked16& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.FrameMasked16.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::FrameMasked16& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameMasked16.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::FrameMasked16& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.FrameMasked16.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::FrameMasked16& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameMasked16.ext_payload_len.Get
inline u16 ws::ext_payload_len_Get(const ws::FrameMasked16& parent) {
    return be16toh(parent.ext_payload_len_be); // read big-endian value from memory
}

// --- ws.FrameMasked16.ext_payload_len.Set
inline void ws::ext_payload_len_Set(ws::FrameMasked16& parent, u16 rhs) {
    parent.ext_payload_len_be = htobe16(rhs); // write big-endian value to memory
}

// --- ws.FrameMasked16.payload.N
// Return number of elements in varlen field
inline u32 ws::payload_N(const ws::FrameMasked16& parent) {
    u32 length = i32(ext_payload_len_Get(((ws::FrameMasked16&)parent)) + 8);
    u32 extra_bytes = u32_Max(length,sizeof(ws::FrameMasked16)) - sizeof(ws::FrameMasked16); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ws.FrameMasked16.payload_curs.Reset
inline void ws::FrameMasked16_payload_curs_Reset(FrameMasked16_payload_curs &curs, ws::FrameMasked16 &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(ext_payload_len_Get(parent) + 8) - sizeof(ws::FrameMasked16);
    curs.index = 0;
}

// --- ws.FrameMasked16.payload_curs.ValidQ
// cursor points to valid item
inline bool ws::FrameMasked16_payload_curs_ValidQ(FrameMasked16_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ws.FrameMasked16.payload_curs.Next
// proceed to next item
inline void ws::FrameMasked16_payload_curs_Next(FrameMasked16_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ws.FrameMasked16.payload_curs.Access
// item access
inline char& ws::FrameMasked16_payload_curs_Access(FrameMasked16_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ws.FrameMasked16..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::FrameMasked16& parent) {
    return i32(ext_payload_len_Get(const_cast<ws::FrameMasked16&>(parent)) + 8);
}

// --- ws.FrameMasked16..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::FrameMasked16& row) {
    return algo::memptr((u8*)&row, i32(ext_payload_len_Get(const_cast<ws::FrameMasked16&>(row)) + 8));
}

// --- ws.FrameMasked16..Ctor
inline  ws::FrameMasked16::FrameMasked16() {
    ws::FrameMasked16_Init(*this);
}

// --- ws.FrameMasked16_curs..ValidQ
inline bool ws::FrameMasked16_curs_ValidQ(ws::FrameMasked16_curs& curs) {
    return curs.msg != NULL;
}

// --- ws.FrameMasked16_curs..Reset
inline void ws::FrameMasked16_curs_Reset(ws::FrameMasked16_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    ws::FrameMasked16 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::FrameMasked16)) {
        ws::FrameMasked16 *ptr = (ws::FrameMasked16*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 8);
        if (msglen >= ssizeof(ws::FrameMasked16) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.FrameMasked16_curs..Access
inline ws::FrameMasked16*& ws::FrameMasked16_curs_Access(ws::FrameMasked16_curs& curs) {
    return curs.msg;
}

// --- ws.FrameMasked16_curs..Next
inline void ws::FrameMasked16_curs_Next(ws::FrameMasked16_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    ws::FrameMasked16 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::FrameMasked16)) {
        ws::FrameMasked16 *ptr = (ws::FrameMasked16*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 8);
        if (msglen >= ssizeof(ws::FrameMasked16) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.FrameMasked16_curs..Init
// Set all fields to initial values.
inline void ws::FrameMasked16_curs_Init(ws::FrameMasked16_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- ws.FrameMasked16_curs..Ctor
inline  ws::FrameMasked16_curs::FrameMasked16_curs() {
    ws::FrameMasked16_curs_Init(*this);
}

// --- ws.FrameMasked64.base.Castdown
// Check if ws::FrameHeader is an instance of FrameMasked64 by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of FrameMasked64.
// If not successful, quietly return NULL.
inline ws::FrameMasked64* ws::FrameMasked64_Castdown(ws::FrameHeader &hdr) {
    bool cond = hdr.byte1 == (255);
    cond &= i32(sizeof(ws::FrameHeader)) >= ssizeof(ws::FrameMasked64);
    return cond ? reinterpret_cast<ws::FrameMasked64*>(&hdr) : NULL;
}

// --- ws.FrameMasked64.base.Castbase
inline ws::FrameHeader& ws::Castbase(ws::FrameMasked64& parent) {
    return reinterpret_cast<ws::FrameHeader&>(parent);
}

// --- ws.FrameMasked64.fin.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 7.
inline bool ws::fin_Get(const ws::FrameMasked64& parent) {
    return bool((parent.byte0 >> 7) & 0x01);
}

// --- ws.FrameMasked64.fin.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 7.
inline void ws::fin_Set(ws::FrameMasked64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked64.rsv1.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 6.
inline bool ws::rsv1_Get(const ws::FrameMasked64& parent) {
    return bool((parent.byte0 >> 6) & 0x01);
}

// --- ws.FrameMasked64.rsv1.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 6.
inline void ws::rsv1_Set(ws::FrameMasked64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 6;
    u8 t2    = (u8(rhs) & 0x01) << 6;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked64.rsv2.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 5.
inline bool ws::rsv2_Get(const ws::FrameMasked64& parent) {
    return bool((parent.byte0 >> 5) & 0x01);
}

// --- ws.FrameMasked64.rsv2.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 5.
inline void ws::rsv2_Set(ws::FrameMasked64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 5;
    u8 t2    = (u8(rhs) & 0x01) << 5;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked64.rsv3.Get
// Retrieve bitfield from value of field byte0
//    1 bits starting at bit 4.
inline bool ws::rsv3_Get(const ws::FrameMasked64& parent) {
    return bool((parent.byte0 >> 4) & 0x01);
}

// --- ws.FrameMasked64.rsv3.Set
// Set bitfield in value of field 'byte0'
//    1 bits starting at bit 4.
inline void ws::rsv3_Set(ws::FrameMasked64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 4;
    u8 t2    = (u8(rhs) & 0x01) << 4;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked64.opcode.Get
// Retrieve bitfield from value of field byte0
//    4 bits starting at bit 0.
inline ws::Opcode ws::opcode_Get(const ws::FrameMasked64& parent) {
    return ws::Opcode((parent.byte0 >> 0) & 0x0f);
}

// --- ws.FrameMasked64.opcode.Set
// Set bitfield in value of field 'byte0'
//    4 bits starting at bit 0.
inline void ws::opcode_Set(ws::FrameMasked64& parent, ws::Opcode rhs) {
    u8 t1    = u8(0x0f) << 0;
    u8 t2    = (u8(rhs.value) & 0x0f) << 0;
    parent.byte0 = u8((parent.byte0 & ~t1) | t2);
}

// --- ws.FrameMasked64.mask.Get
// Retrieve bitfield from value of field byte1
//    1 bits starting at bit 7.
inline bool ws::mask_Get(const ws::FrameMasked64& parent) {
    return bool((parent.byte1 >> 7) & 0x01);
}

// --- ws.FrameMasked64.mask.Set
// Set bitfield in value of field 'byte1'
//    1 bits starting at bit 7.
inline void ws::mask_Set(ws::FrameMasked64& parent, bool rhs) {
    u8 t1    = u8(0x01) << 7;
    u8 t2    = (u8(rhs) & 0x01) << 7;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameMasked64.payload_len.Get
// Retrieve bitfield from value of field byte1
//    7 bits starting at bit 0.
inline u8 ws::payload_len_Get(const ws::FrameMasked64& parent) {
    return u8((parent.byte1 >> 0) & 0x7f);
}

// --- ws.FrameMasked64.payload_len.Set
// Set bitfield in value of field 'byte1'
//    7 bits starting at bit 0.
inline void ws::payload_len_Set(ws::FrameMasked64& parent, u8 rhs) {
    u8 t1    = u8(0x7f) << 0;
    u8 t2    = (u8(rhs) & 0x7f) << 0;
    parent.byte1 = u8((parent.byte1 & ~t1) | t2);
}

// --- ws.FrameMasked64.ext_payload_len.Get
inline u64 ws::ext_payload_len_Get(const ws::FrameMasked64& parent) {
    return be64toh(parent.ext_payload_len_be); // read big-endian value from memory
}

// --- ws.FrameMasked64.ext_payload_len.Set
inline void ws::ext_payload_len_Set(ws::FrameMasked64& parent, u64 rhs) {
    parent.ext_payload_len_be = htobe64(rhs); // write big-endian value to memory
}

// --- ws.FrameMasked64.payload.N
// Return number of elements in varlen field
inline u32 ws::payload_N(const ws::FrameMasked64& parent) {
    u32 length = i32(ext_payload_len_Get(((ws::FrameMasked64&)parent)) + 14);
    u32 extra_bytes = u32_Max(length,sizeof(ws::FrameMasked64)) - sizeof(ws::FrameMasked64); // avoid unsigned subtraction underflow
    return u32(extra_bytes / sizeof(char));
}

// --- ws.FrameMasked64.payload_curs.Reset
inline void ws::FrameMasked64_payload_curs_Reset(FrameMasked64_payload_curs &curs, ws::FrameMasked64 &parent) {
    curs.ptr = (u8*)payload_Addr(parent);
    curs.length = i32(ext_payload_len_Get(parent) + 14) - sizeof(ws::FrameMasked64);
    curs.index = 0;
}

// --- ws.FrameMasked64.payload_curs.ValidQ
// cursor points to valid item
inline bool ws::FrameMasked64_payload_curs_ValidQ(FrameMasked64_payload_curs &curs) {
    bool valid = ssizeof(char) <= curs.length;
    return valid;
}

// --- ws.FrameMasked64.payload_curs.Next
// proceed to next item
inline void ws::FrameMasked64_payload_curs_Next(FrameMasked64_payload_curs &curs) {
    i32 len = i32(sizeof(char));
    curs.ptr += len;
    curs.length -= len;
    ++curs.index;
}

// --- ws.FrameMasked64.payload_curs.Access
// item access
inline char& ws::FrameMasked64_payload_curs_Access(FrameMasked64_payload_curs &curs) {
    return *(char*)curs.ptr;
}

// --- ws.FrameMasked64..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::FrameMasked64& parent) {
    return i32(ext_payload_len_Get(const_cast<ws::FrameMasked64&>(parent)) + 14);
}

// --- ws.FrameMasked64..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::FrameMasked64& row) {
    return algo::memptr((u8*)&row, i32(ext_payload_len_Get(const_cast<ws::FrameMasked64&>(row)) + 14));
}

// --- ws.FrameMasked64..Ctor
inline  ws::FrameMasked64::FrameMasked64() {
    ws::FrameMasked64_Init(*this);
}

// --- ws.FrameMasked64_curs..ValidQ
inline bool ws::FrameMasked64_curs_ValidQ(ws::FrameMasked64_curs& curs) {
    return curs.msg != NULL;
}

// --- ws.FrameMasked64_curs..Reset
inline void ws::FrameMasked64_curs_Reset(ws::FrameMasked64_curs& curs, algo::memptr buf) {
    curs.bytes = buf.elems;
    curs.limit = buf.n_elems;
    ws::FrameMasked64 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::FrameMasked64)) {
        ws::FrameMasked64 *ptr = (ws::FrameMasked64*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 14);
        if (msglen >= ssizeof(ws::FrameMasked64) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.FrameMasked64_curs..Access
inline ws::FrameMasked64*& ws::FrameMasked64_curs_Access(ws::FrameMasked64_curs& curs) {
    return curs.msg;
}

// --- ws.FrameMasked64_curs..Next
inline void ws::FrameMasked64_curs_Next(ws::FrameMasked64_curs& curs) {
    curs.bytes += curs.msglen;
    curs.limit -= curs.msglen;
    ws::FrameMasked64 *msg = NULL;
    int msglen = 0;
    if (curs.limit >= ssizeof(ws::FrameMasked64)) {
        ws::FrameMasked64 *ptr = (ws::FrameMasked64*)curs.bytes;
        msglen = i32(ext_payload_len_Get((*ptr)) + 14);
        if (msglen >= ssizeof(ws::FrameMasked64) && curs.limit >= msglen) {
            msg = ptr;
        }
    }
    curs.msg = msg;
    curs.msglen = msglen;
}

// --- ws.FrameMasked64_curs..Init
// Set all fields to initial values.
inline void ws::FrameMasked64_curs_Init(ws::FrameMasked64_curs& parent) {
    parent.msg = NULL;
    parent.bytes = NULL;
    parent.limit = i32(0);
    parent.msglen = i32(0);
}

// --- ws.FrameMasked64_curs..Ctor
inline  ws::FrameMasked64_curs::FrameMasked64_curs() {
    ws::FrameMasked64_curs_Init(*this);
}

// --- ws.HttpState.value.GetEnum
// Get value of field as enum type
inline ws_HttpStateEnum ws::value_GetEnum(const ws::HttpState& parent) {
    return ws_HttpStateEnum(parent.value);
}

// --- ws.HttpState.value.SetEnum
// Set value of field from enum type.
inline void ws::value_SetEnum(ws::HttpState& parent, ws_HttpStateEnum rhs) {
    parent.value = u8(rhs);
}

// --- ws.HttpState..Init
// Set all fields to initial values.
inline void ws::HttpState_Init(ws::HttpState& parent) {
    parent.value = u8(0);
}

// --- ws.HttpState..Ctor
inline  ws::HttpState::HttpState() {
    ws::HttpState_Init(*this);
}

// --- ws.HttpState..FieldwiseCtor
inline  ws::HttpState::HttpState(u8 in_value)
    : value(in_value)
 {
}

// --- ws.HttpState..EnumCtor
inline  ws::HttpState::HttpState(ws_HttpStateEnum arg) {
    this->value = u8(arg);
}

// --- ws.ServerStartMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ServerStartMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ServerStartMsg.
// If not successful, quietly return NULL.
inline ws::ServerStartMsg* ws::ServerStartMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (500);
    cond &= i32(hdr.length) >= ssizeof(ws::ServerStartMsg);
    return cond ? reinterpret_cast<ws::ServerStartMsg*>(&hdr) : NULL;
}

// --- ws.ServerStartMsg.base.Castbase
inline ams::MsgHeader& ws::Castbase(ws::ServerStartMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ws.ServerStartMsg..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::ServerStartMsg& parent) {
    return i32(const_cast<ws::ServerStartMsg&>(parent).length);
}

// --- ws.ServerStartMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::ServerStartMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ws::ServerStartMsg&>(row).length));
}

// --- ws.ServerStartMsg..Init
// Set all fields to initial values.
inline void ws::ServerStartMsg_Init(ws::ServerStartMsg& parent) {
    parent.type = u32(500);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ws.ServerStartMsg..Ctor
inline  ws::ServerStartMsg::ServerStartMsg() {
    ws::ServerStartMsg_Init(*this);
}

// --- ws.ServerStopMsg.base.Castdown
// Check if ams::MsgHeader is an instance of ServerStopMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ServerStopMsg.
// If not successful, quietly return NULL.
inline ws::ServerStopMsg* ws::ServerStopMsg_Castdown(ams::MsgHeader &hdr) {
    bool cond = hdr.type == (501);
    cond &= i32(hdr.length) >= ssizeof(ws::ServerStopMsg);
    return cond ? reinterpret_cast<ws::ServerStopMsg*>(&hdr) : NULL;
}

// --- ws.ServerStopMsg.base.Castbase
inline ams::MsgHeader& ws::Castbase(ws::ServerStopMsg& parent) {
    return reinterpret_cast<ams::MsgHeader&>(parent);
}

// --- ws.ServerStopMsg..GetMsgLength
// Message length (uses length field)
inline i32 ws::GetMsgLength(const ws::ServerStopMsg& parent) {
    return i32(const_cast<ws::ServerStopMsg&>(parent).length);
}

// --- ws.ServerStopMsg..GetMsgMemptr
// Memptr encompassing the message (uses length field)
inline algo::memptr ws::GetMsgMemptr(const ws::ServerStopMsg& row) {
    return algo::memptr((u8*)&row, i32(const_cast<ws::ServerStopMsg&>(row).length));
}

// --- ws.ServerStopMsg..Init
// Set all fields to initial values.
inline void ws::ServerStopMsg_Init(ws::ServerStopMsg& parent) {
    parent.type = u32(501);
    parent.length = u32(ssizeof(parent) + (0));
}

// --- ws.ServerStopMsg..Ctor
inline  ws::ServerStopMsg::ServerStopMsg() {
    ws::ServerStopMsg_Init(*this);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::Side &row) {// cfmt:ws.Side.String
    ws::Side_Print(const_cast<ws::Side&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::StatusCode &row) {// cfmt:ws.StatusCode.String
    ws::StatusCode_Print(const_cast<ws::StatusCode&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::CloseMsg &row) {// cfmt:ws.CloseMsg.String
    ws::CloseMsg_Print(const_cast<ws::CloseMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::ConnectMsg &row) {// cfmt:ws.ConnectMsg.String
    ws::ConnectMsg_Print(const_cast<ws::ConnectMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::Opcode &row) {// cfmt:ws.Opcode.String
    ws::Opcode_Print(const_cast<ws::Opcode&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::DataMsg &row) {// cfmt:ws.DataMsg.String
    ws::DataMsg_Print(const_cast<ws::DataMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::FieldId &row) {// cfmt:ws.FieldId.String
    ws::FieldId_Print(const_cast<ws::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::Frame &row) {// cfmt:ws.Frame.String
    ws::Frame_Print(const_cast<ws::Frame&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::Frame16 &row) {// cfmt:ws.Frame16.String
    ws::Frame16_Print(const_cast<ws::Frame16&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::Frame64 &row) {// cfmt:ws.Frame64.String
    ws::Frame64_Print(const_cast<ws::Frame64&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::FrameMasked &row) {// cfmt:ws.FrameMasked.String
    ws::FrameMasked_Print(const_cast<ws::FrameMasked&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::FrameMasked16 &row) {// cfmt:ws.FrameMasked16.String
    ws::FrameMasked16_Print(const_cast<ws::FrameMasked16&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::FrameMasked64 &row) {// cfmt:ws.FrameMasked64.String
    ws::FrameMasked64_Print(const_cast<ws::FrameMasked64&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::HttpState &row) {// cfmt:ws.HttpState.String
    ws::HttpState_Print(const_cast<ws::HttpState&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::ServerStartMsg &row) {// cfmt:ws.ServerStartMsg.String
    ws::ServerStartMsg_Print(const_cast<ws::ServerStartMsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const ws::ServerStopMsg &row) {// cfmt:ws.ServerStopMsg.String
    ws::ServerStopMsg_Print(const_cast<ws::ServerStopMsg&>(row), str);
    return str;
}
