//
// include/gen/algo_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
//#pragma endinclude
inline void algo::Smallstr150::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr50::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr10_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr11_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr12_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr13_U64_Base36::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr16_U64_Base16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr1_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr20_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr22_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr2_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr3_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr4_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr5_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr5_U32_Base36::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr6_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr7_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr7_U32_Base36::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr8_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr8_U32_Base16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr8_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr9_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LnumStr9_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr200::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr10::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr12::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr14::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr15::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr20_I64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr20_U64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr3::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr3_I16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr4::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr5::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr5_I16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr6::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr6_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr7_I32_Base36::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr8::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::LspaceStr9::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr1::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr10::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr100::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr1000::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr11::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr12::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr129::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr13::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr14::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr15::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr151::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr17::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr18::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr19::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr2::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr20::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr21::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr24::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr25::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr28::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr3::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr30::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr33::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr35::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr36::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr4::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr40::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr41::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr43::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr44::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr48::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr5::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr50::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr54::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr55::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr6::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr60::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr62::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr66::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr6_U32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr7::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr8::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr80::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RnullStr9::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr10::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr100::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr11::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr2::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr20::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr200::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr21::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr24::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr240::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr26::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr3::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr31::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr32::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr4::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr40::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr5::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr50::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr6::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr64::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr7::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr8::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::RspaceStr9::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr1::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr10::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr100::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr16::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr2::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr20::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr25::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr250::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr30::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr4::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr40::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline void algo::Smallstr5::operator =(const algo::strptr & str) { ch_Set(*this, str); }
inline cstring& cstring::operator =(const cstring &rhs) {
    algo::ch_Setary(*this, (algo::cstring&)rhs);
    return *this;
}

inline  cstring::cstring(const strptr &rhs) {
    algo::cstring_Init(*this);
    algo::ch_Addary(*this, aryptr<char>((char*)rhs.elems, rhs.n_elems));
}

inline cstring::cstring(const tempstr &rhs) {
    ch_elems = rhs.ch_elems;
    ch_n     = rhs.ch_n;
    ch_max   = rhs.ch_max;
    cstring &r  = (cstring&) rhs;
    r.ch_elems     = 0;
    r.ch_n   = 0;
    r.ch_max = 0;
}


inline bool algo::cstring::operator ==(const algo::cstring &rhs) const {
    return algo::cstring_Eq(const_cast<algo::cstring&>(*this),const_cast<algo::cstring&>(rhs));
}

inline bool algo::cstring::operator <(const algo::cstring &rhs) const {
    return algo::cstring_Lt(const_cast<algo::cstring&>(*this),const_cast<algo::cstring&>(rhs));
}
inline algo::cstring::cstring() {
    algo::cstring_Init(*this);
}

inline algo::cstring::~cstring() {
    algo::cstring_Uninit(*this);
}


// --- algo.cstring.ch.EmptyQ
// Return true if index is empty
inline bool algo::ch_EmptyQ(algo::cstring& error) {
    return error.ch_n == 0;
}

// --- algo.cstring.ch.Find
// Look up row by row id. Return NULL if out of range
inline char* algo::ch_Find(algo::cstring& error, u64 t) {
    u64 idx = t;
    u64 lim = error.ch_n;
    if (idx >= lim) return NULL;
    return error.ch_elems + idx;
}

// --- algo.cstring.ch.Getary
// Return array pointer by value
inline algo::aryptr<char> algo::ch_Getary(algo::cstring& error) {
    return algo::aryptr<char>(error.ch_elems, error.ch_n);
}

// --- algo.cstring.ch.Last
// Return pointer to last element of array, or NULL if array is empty
inline char* algo::ch_Last(algo::cstring& error) {
    return ch_Find(error, u64(error.ch_n-1));
}

// --- algo.cstring.ch.Max
// Return max. number of items in the array
inline i32 algo::ch_Max(algo::cstring& error) {
    (void)error;
    return error.ch_max;
}

// --- algo.cstring.ch.N
// Return number of items in the array
inline i32 algo::ch_N(const algo::cstring& error) {
    return error.ch_n;
}

// --- algo.cstring.ch.RemoveAll
inline void algo::ch_RemoveAll(algo::cstring& error) {
    error.ch_n = 0;
}

// --- algo.cstring.ch.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ch_Reserve(algo::cstring& error, int n) {
    u32 new_n = error.ch_n + n;
    if (UNLIKELY(new_n > error.ch_max)) {
        ch_AbsReserve(error, new_n);
    }
}

// --- algo.cstring.ch.qFind
// 'quick' Access row by row id. No bounds checking.
inline char& algo::ch_qFind(algo::cstring& error, u64 t) {
    return error.ch_elems[t];
}

// --- algo.cstring.ch.qLast
// Return reference to last element of array. No bounds checking
inline char& algo::ch_qLast(algo::cstring& error) {
    return ch_qFind(error, u64(error.ch_n-1));
}

// --- algo.cstring.ch.rowid_Get
// Return row id of specified element
inline u64 algo::ch_rowid_Get(algo::cstring& error, char &elem) {
    u64 id = &elem - error.ch_elems;
    return u64(id);
}

// --- algo.cstring.ch_curs.Next
// proceed to next item
inline void algo::error_ch_curs_Next(error_ch_curs &curs) {
    curs.index++;
}

// --- algo.cstring.ch_curs.Reset
inline void algo::error_ch_curs_Reset(error_ch_curs &curs, algo::cstring &parent) {
    curs.elems = parent.ch_elems;
    curs.n_elems = parent.ch_n;
    curs.index = 0;
}

// --- algo.cstring.ch_curs.ValidQ
// cursor points to valid item
inline bool algo::error_ch_curs_ValidQ(error_ch_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.cstring.ch_curs.Access
// item access
inline char& algo::error_ch_curs_Access(error_ch_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.cstring..Lt
inline bool algo::cstring_Lt(algo::cstring & lhs, algo::cstring & rhs) {
    return ch_Cmp(lhs,rhs) < 0;
}

// --- algo.cstring..Cmp
inline i32 algo::cstring_Cmp(algo::cstring & lhs, algo::cstring & rhs) {
    i32 retval = 0;
    retval = ch_Cmp(lhs,rhs);
    return retval;
}

// --- algo.cstring..Init
// Set all fields to initial values.
inline void algo::cstring_Init(algo::cstring& error) {
    error.ch_elems 	= 0; // (algo.cstring.ch)
    error.ch_n     	= 0; // (algo.cstring.ch)
    error.ch_max   	= 0; // (algo.cstring.ch)
}

// --- algo.cstring..Eq
inline bool algo::cstring_Eq(const algo::cstring & lhs,const algo::cstring & rhs) {
    bool retval = true;
    retval = ch_Eq(lhs,rhs);
    return retval;
}

// --- algo.cstring..Update
// Set value. Return true if new value is different from old value.
inline bool algo::cstring_Update(algo::cstring &lhs, algo::cstring & rhs) {
    bool ret = !cstring_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::ArgProto::ArgProto(const algo::strptr&            in_name
        ,const algo::strptr&            in_type
        ,const algo::strptr&            in_value
        ,bool                           in_optional
        ,bool                           in_anon)
    : name(in_name)
    , type(in_type)
    , value(in_value)
    , optional(in_optional)
    , anon(in_anon)
{
}
inline algo::ArgProto::ArgProto() {
    algo::ArgProto_Init(*this);
}


// --- algo.ArgProto..Init
// Set all fields to initial values.
inline void algo::ArgProto_Init(algo::ArgProto& proto) {
    proto.optional = bool(false);
    proto.anon = bool(false);
}
inline algo::Attr::Attr(const algo::strptr&            in_name
        ,const algo::strptr&            in_value)
    : name(in_name)
    , value(in_value)
{
}

inline bool algo::Attr::operator ==(const algo::Attr &rhs) const {
    return algo::Attr_Eq(const_cast<algo::Attr&>(*this),const_cast<algo::Attr&>(rhs));
}
inline algo::Attr::Attr() {
}


// --- algo.Attr..Cmp
inline i32 algo::Attr_Cmp(algo::Attr & lhs, algo::Attr & rhs) {
    i32 retval = 0;
    retval = algo::cstring_Cmp(lhs.name, rhs.name);
    if (retval != 0) {
        return retval;
    }
    retval = algo::cstring_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.Attr..Eq
inline bool algo::Attr_Eq(const algo::Attr & lhs,const algo::Attr & rhs) {
    bool retval = true;
    retval = algo::cstring_Eq(lhs.name, rhs.name);
    if (!retval) {
        return false;
    }
    retval = algo::cstring_Eq(lhs.value, rhs.value);
    return retval;
}
inline algo::Tuple::Tuple() {
    algo::Tuple_Init(*this);
}

inline algo::Tuple::~Tuple() {
    algo::Tuple_Uninit(*this);
}


// --- algo.Tuple.attrs.EmptyQ
// Return true if index is empty
inline bool algo::attrs_EmptyQ(algo::Tuple& parent) {
    return parent.attrs_n == 0;
}

// --- algo.Tuple.attrs.Find
// Look up row by row id. Return NULL if out of range
inline algo::Attr* algo::attrs_Find(algo::Tuple& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.attrs_n;
    if (idx >= lim) return NULL;
    return parent.attrs_elems + idx;
}

// --- algo.Tuple.attrs.Getary
// Return array pointer by value
inline algo::aryptr<algo::Attr> algo::attrs_Getary(algo::Tuple& parent) {
    return algo::aryptr<algo::Attr>(parent.attrs_elems, parent.attrs_n);
}

// --- algo.Tuple.attrs.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::Attr* algo::attrs_Last(algo::Tuple& parent) {
    return attrs_Find(parent, u64(parent.attrs_n-1));
}

// --- algo.Tuple.attrs.Max
// Return max. number of items in the array
inline i32 algo::attrs_Max(algo::Tuple& parent) {
    (void)parent;
    return parent.attrs_max;
}

// --- algo.Tuple.attrs.N
// Return number of items in the array
inline i32 algo::attrs_N(const algo::Tuple& parent) {
    return parent.attrs_n;
}

// --- algo.Tuple.attrs.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::attrs_Reserve(algo::Tuple& parent, int n) {
    u32 new_n = parent.attrs_n + n;
    if (UNLIKELY(new_n > parent.attrs_max)) {
        attrs_AbsReserve(parent, new_n);
    }
}

// --- algo.Tuple.attrs.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::Attr& algo::attrs_qFind(algo::Tuple& parent, u64 t) {
    return parent.attrs_elems[t];
}

// --- algo.Tuple.attrs.qLast
// Return reference to last element of array. No bounds checking
inline algo::Attr& algo::attrs_qLast(algo::Tuple& parent) {
    return attrs_qFind(parent, u64(parent.attrs_n-1));
}

// --- algo.Tuple.attrs.rowid_Get
// Return row id of specified element
inline u64 algo::attrs_rowid_Get(algo::Tuple& parent, algo::Attr &elem) {
    u64 id = &elem - parent.attrs_elems;
    return u64(id);
}

// --- algo.Tuple.attrs_curs.Next
// proceed to next item
inline void algo::Tuple_attrs_curs_Next(Tuple_attrs_curs &curs) {
    curs.index++;
}

// --- algo.Tuple.attrs_curs.Reset
inline void algo::Tuple_attrs_curs_Reset(Tuple_attrs_curs &curs, algo::Tuple &parent) {
    curs.elems = parent.attrs_elems;
    curs.n_elems = parent.attrs_n;
    curs.index = 0;
}

// --- algo.Tuple.attrs_curs.ValidQ
// cursor points to valid item
inline bool algo::Tuple_attrs_curs_ValidQ(Tuple_attrs_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.Tuple.attrs_curs.Access
// item access
inline algo::Attr& algo::Tuple_attrs_curs_Access(Tuple_attrs_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.Tuple..Init
// Set all fields to initial values.
inline void algo::Tuple_Init(algo::Tuple& parent) {
    parent.attrs_elems 	= 0; // (algo.Tuple.attrs)
    parent.attrs_n     	= 0; // (algo.Tuple.attrs)
    parent.attrs_max   	= 0; // (algo.Tuple.attrs)
}
inline algo::Argtuple::Argtuple() {
    algo::Argtuple_Init(*this);
}

inline algo::Argtuple::~Argtuple() {
    algo::Argtuple_Uninit(*this);
}


// --- algo.Argtuple.proto.EmptyQ
// Return true if index is empty
inline bool algo::proto_EmptyQ(algo::Argtuple& parent) {
    return parent.proto_n == 0;
}

// --- algo.Argtuple.proto.Find
// Look up row by row id. Return NULL if out of range
inline algo::ArgProto* algo::proto_Find(algo::Argtuple& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.proto_n;
    if (idx >= lim) return NULL;
    return parent.proto_elems + idx;
}

// --- algo.Argtuple.proto.Getary
// Return array pointer by value
inline algo::aryptr<algo::ArgProto> algo::proto_Getary(algo::Argtuple& parent) {
    return algo::aryptr<algo::ArgProto>(parent.proto_elems, parent.proto_n);
}

// --- algo.Argtuple.proto.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::ArgProto* algo::proto_Last(algo::Argtuple& parent) {
    return proto_Find(parent, u64(parent.proto_n-1));
}

// --- algo.Argtuple.proto.Max
// Return max. number of items in the array
inline i32 algo::proto_Max(algo::Argtuple& parent) {
    (void)parent;
    return parent.proto_max;
}

// --- algo.Argtuple.proto.N
// Return number of items in the array
inline i32 algo::proto_N(const algo::Argtuple& parent) {
    return parent.proto_n;
}

// --- algo.Argtuple.proto.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::proto_Reserve(algo::Argtuple& parent, int n) {
    u32 new_n = parent.proto_n + n;
    if (UNLIKELY(new_n > parent.proto_max)) {
        proto_AbsReserve(parent, new_n);
    }
}

// --- algo.Argtuple.proto.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::ArgProto& algo::proto_qFind(algo::Argtuple& parent, u64 t) {
    return parent.proto_elems[t];
}

// --- algo.Argtuple.proto.qLast
// Return reference to last element of array. No bounds checking
inline algo::ArgProto& algo::proto_qLast(algo::Argtuple& parent) {
    return proto_qFind(parent, u64(parent.proto_n-1));
}

// --- algo.Argtuple.proto.rowid_Get
// Return row id of specified element
inline u64 algo::proto_rowid_Get(algo::Argtuple& parent, algo::ArgProto &elem) {
    u64 id = &elem - parent.proto_elems;
    return u64(id);
}

// --- algo.Argtuple.error.EmptyQ
// Return true if index is empty
inline bool algo::error_EmptyQ(algo::Argtuple& parent) {
    return parent.error_n == 0;
}

// --- algo.Argtuple.error.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* algo::error_Find(algo::Argtuple& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.error_n;
    if (idx >= lim) return NULL;
    return parent.error_elems + idx;
}

// --- algo.Argtuple.error.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> algo::error_Getary(algo::Argtuple& parent) {
    return algo::aryptr<algo::cstring>(parent.error_elems, parent.error_n);
}

// --- algo.Argtuple.error.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* algo::error_Last(algo::Argtuple& parent) {
    return error_Find(parent, u64(parent.error_n-1));
}

// --- algo.Argtuple.error.Max
// Return max. number of items in the array
inline i32 algo::error_Max(algo::Argtuple& parent) {
    (void)parent;
    return parent.error_max;
}

// --- algo.Argtuple.error.N
// Return number of items in the array
inline i32 algo::error_N(const algo::Argtuple& parent) {
    return parent.error_n;
}

// --- algo.Argtuple.error.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::error_Reserve(algo::Argtuple& parent, int n) {
    u32 new_n = parent.error_n + n;
    if (UNLIKELY(new_n > parent.error_max)) {
        error_AbsReserve(parent, new_n);
    }
}

// --- algo.Argtuple.error.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& algo::error_qFind(algo::Argtuple& parent, u64 t) {
    return parent.error_elems[t];
}

// --- algo.Argtuple.error.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& algo::error_qLast(algo::Argtuple& parent) {
    return error_qFind(parent, u64(parent.error_n-1));
}

// --- algo.Argtuple.error.rowid_Get
// Return row id of specified element
inline u64 algo::error_rowid_Get(algo::Argtuple& parent, algo::cstring &elem) {
    u64 id = &elem - parent.error_elems;
    return u64(id);
}

// --- algo.Argtuple.proto_curs.Next
// proceed to next item
inline void algo::Argtuple_proto_curs_Next(Argtuple_proto_curs &curs) {
    curs.index++;
}

// --- algo.Argtuple.proto_curs.Reset
inline void algo::Argtuple_proto_curs_Reset(Argtuple_proto_curs &curs, algo::Argtuple &parent) {
    curs.elems = parent.proto_elems;
    curs.n_elems = parent.proto_n;
    curs.index = 0;
}

// --- algo.Argtuple.proto_curs.ValidQ
// cursor points to valid item
inline bool algo::Argtuple_proto_curs_ValidQ(Argtuple_proto_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.Argtuple.proto_curs.Access
// item access
inline algo::ArgProto& algo::Argtuple_proto_curs_Access(Argtuple_proto_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.Argtuple.error_curs.Next
// proceed to next item
inline void algo::Argtuple_error_curs_Next(Argtuple_error_curs &curs) {
    curs.index++;
}

// --- algo.Argtuple.error_curs.Reset
inline void algo::Argtuple_error_curs_Reset(Argtuple_error_curs &curs, algo::Argtuple &parent) {
    curs.elems = parent.error_elems;
    curs.n_elems = parent.error_n;
    curs.index = 0;
}

// --- algo.Argtuple.error_curs.ValidQ
// cursor points to valid item
inline bool algo::Argtuple_error_curs_ValidQ(Argtuple_error_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.Argtuple.error_curs.Access
// item access
inline algo::cstring& algo::Argtuple_error_curs_Access(Argtuple_error_curs &curs) {
    return curs.elems[curs.index];
}
inline algo::Arrsimp::Arrsimp() {
    algo::Arrsimp_Init(*this);
}

inline algo::Arrsimp::~Arrsimp() {
    algo::Arrsimp_Uninit(*this);
}


// --- algo.Arrsimp.out.EmptyQ
// Return true if index is empty
inline bool algo::out_EmptyQ(algo::Arrsimp& parent) {
    return parent.out_n == 0;
}

// --- algo.Arrsimp.out.Find
// Look up row by row id. Return NULL if out of range
inline i32* algo::out_Find(algo::Arrsimp& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.out_n;
    if (idx >= lim) return NULL;
    return parent.out_elems + idx;
}

// --- algo.Arrsimp.out.Getary
// Return array pointer by value
inline algo::aryptr<i32> algo::out_Getary(algo::Arrsimp& parent) {
    return algo::aryptr<i32>(parent.out_elems, parent.out_n);
}

// --- algo.Arrsimp.out.Last
// Return pointer to last element of array, or NULL if array is empty
inline i32* algo::out_Last(algo::Arrsimp& parent) {
    return out_Find(parent, u64(parent.out_n-1));
}

// --- algo.Arrsimp.out.Max
// Return max. number of items in the array
inline i32 algo::out_Max(algo::Arrsimp& parent) {
    (void)parent;
    return parent.out_max;
}

// --- algo.Arrsimp.out.N
// Return number of items in the array
inline i32 algo::out_N(const algo::Arrsimp& parent) {
    return parent.out_n;
}

// --- algo.Arrsimp.out.RemoveAll
inline void algo::out_RemoveAll(algo::Arrsimp& parent) {
    parent.out_n = 0;
}

// --- algo.Arrsimp.out.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::out_Reserve(algo::Arrsimp& parent, int n) {
    u32 new_n = parent.out_n + n;
    if (UNLIKELY(new_n > parent.out_max)) {
        out_AbsReserve(parent, new_n);
    }
}

// --- algo.Arrsimp.out.qFind
// 'quick' Access row by row id. No bounds checking.
inline i32& algo::out_qFind(algo::Arrsimp& parent, u64 t) {
    return parent.out_elems[t];
}

// --- algo.Arrsimp.out.qLast
// Return reference to last element of array. No bounds checking
inline i32& algo::out_qLast(algo::Arrsimp& parent) {
    return out_qFind(parent, u64(parent.out_n-1));
}

// --- algo.Arrsimp.out.rowid_Get
// Return row id of specified element
inline u64 algo::out_rowid_Get(algo::Arrsimp& parent, i32 &elem) {
    u64 id = &elem - parent.out_elems;
    return u64(id);
}

// --- algo.Arrsimp.stack.EmptyQ
// Return true if index is empty
inline bool algo::stack_EmptyQ(algo::Arrsimp& parent) {
    return parent.stack_n == 0;
}

// --- algo.Arrsimp.stack.Find
// Look up row by row id. Return NULL if out of range
inline algo::i32_Range* algo::stack_Find(algo::Arrsimp& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.stack_n;
    if (idx >= lim) return NULL;
    return parent.stack_elems + idx;
}

// --- algo.Arrsimp.stack.Getary
// Return array pointer by value
inline algo::aryptr<algo::i32_Range> algo::stack_Getary(algo::Arrsimp& parent) {
    return algo::aryptr<algo::i32_Range>(parent.stack_elems, parent.stack_n);
}

// --- algo.Arrsimp.stack.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::i32_Range* algo::stack_Last(algo::Arrsimp& parent) {
    return stack_Find(parent, u64(parent.stack_n-1));
}

// --- algo.Arrsimp.stack.Max
// Return max. number of items in the array
inline i32 algo::stack_Max(algo::Arrsimp& parent) {
    (void)parent;
    return parent.stack_max;
}

// --- algo.Arrsimp.stack.N
// Return number of items in the array
inline i32 algo::stack_N(const algo::Arrsimp& parent) {
    return parent.stack_n;
}

// --- algo.Arrsimp.stack.RemoveAll
inline void algo::stack_RemoveAll(algo::Arrsimp& parent) {
    parent.stack_n = 0;
}

// --- algo.Arrsimp.stack.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::stack_Reserve(algo::Arrsimp& parent, int n) {
    u32 new_n = parent.stack_n + n;
    if (UNLIKELY(new_n > parent.stack_max)) {
        stack_AbsReserve(parent, new_n);
    }
}

// --- algo.Arrsimp.stack.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::i32_Range& algo::stack_qFind(algo::Arrsimp& parent, u64 t) {
    return parent.stack_elems[t];
}

// --- algo.Arrsimp.stack.qLast
// Return reference to last element of array. No bounds checking
inline algo::i32_Range& algo::stack_qLast(algo::Arrsimp& parent) {
    return stack_qFind(parent, u64(parent.stack_n-1));
}

// --- algo.Arrsimp.stack.rowid_Get
// Return row id of specified element
inline u64 algo::stack_rowid_Get(algo::Arrsimp& parent, algo::i32_Range &elem) {
    u64 id = &elem - parent.stack_elems;
    return u64(id);
}

// --- algo.Arrsimp.out_curs.Next
// proceed to next item
inline void algo::Arrsimp_out_curs_Next(Arrsimp_out_curs &curs) {
    curs.index++;
}

// --- algo.Arrsimp.out_curs.Reset
inline void algo::Arrsimp_out_curs_Reset(Arrsimp_out_curs &curs, algo::Arrsimp &parent) {
    curs.elems = parent.out_elems;
    curs.n_elems = parent.out_n;
    curs.index = 0;
}

// --- algo.Arrsimp.out_curs.ValidQ
// cursor points to valid item
inline bool algo::Arrsimp_out_curs_ValidQ(Arrsimp_out_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.Arrsimp.out_curs.Access
// item access
inline i32& algo::Arrsimp_out_curs_Access(Arrsimp_out_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.Arrsimp.stack_curs.Next
// proceed to next item
inline void algo::Arrsimp_stack_curs_Next(Arrsimp_stack_curs &curs) {
    curs.index++;
}

// --- algo.Arrsimp.stack_curs.Reset
inline void algo::Arrsimp_stack_curs_Reset(Arrsimp_stack_curs &curs, algo::Arrsimp &parent) {
    curs.elems = parent.stack_elems;
    curs.n_elems = parent.stack_n;
    curs.index = 0;
}

// --- algo.Arrsimp.stack_curs.ValidQ
// cursor points to valid item
inline bool algo::Arrsimp_stack_curs_ValidQ(Arrsimp_stack_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.Arrsimp.stack_curs.Access
// item access
inline algo::i32_Range& algo::Arrsimp_stack_curs_Access(Arrsimp_stack_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.Arrsimp..Init
// Set all fields to initial values.
inline void algo::Arrsimp_Init(algo::Arrsimp& parent) {
    parent.out_elems 	= 0; // (algo.Arrsimp.out)
    parent.out_n     	= 0; // (algo.Arrsimp.out)
    parent.out_max   	= 0; // (algo.Arrsimp.out)
    parent.stack_elems 	= 0; // (algo.Arrsimp.stack)
    parent.stack_n     	= 0; // (algo.Arrsimp.stack)
    parent.stack_max   	= 0; // (algo.Arrsimp.stack)
    parent.tol = double(0.0);
}
inline algo::Bool::Bool(u8                             in_value)
    : value(in_value)
{
}
inline algo::Bool::Bool(algo_BoolEnum arg) { this->value = u8(arg); }
inline algo::Bool::Bool() {
    algo::Bool_Init(*this);
}


// --- algo.Bool.value.GetEnum
// Get value of field as enum type
inline algo_BoolEnum algo::value_GetEnum(const algo::Bool& parent) {
    return algo_BoolEnum(parent.value);
}

// --- algo.Bool.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::Bool& parent, algo_BoolEnum rhs) {
    parent.value = u8(rhs);
}

// --- algo.Bool.value.Cast
inline algo::Bool::operator algo_BoolEnum () const {
    return algo_BoolEnum((*this).value);
}

// --- algo.Bool..Init
// Set all fields to initial values.
inline void algo::Bool_Init(algo::Bool& parent) {
    parent.value = u8(false);
}
inline algo::ByteAry::ByteAry() {
    algo::ByteAry_Init(*this);
}

inline algo::ByteAry::~ByteAry() {
    algo::ByteAry_Uninit(*this);
}


// --- algo.ByteAry.ary.EmptyQ
// Return true if index is empty
inline bool algo::ary_EmptyQ(algo::ByteAry& parent) {
    return parent.ary_n == 0;
}

// --- algo.ByteAry.ary.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::ary_Find(algo::ByteAry& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- algo.ByteAry.ary.Getary
// Return array pointer by value
inline algo::aryptr<u8> algo::ary_Getary(algo::ByteAry& parent) {
    return algo::aryptr<u8>(parent.ary_elems, parent.ary_n);
}

// --- algo.ByteAry.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* algo::ary_Last(algo::ByteAry& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- algo.ByteAry.ary.Max
// Return max. number of items in the array
inline i32 algo::ary_Max(algo::ByteAry& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- algo.ByteAry.ary.N
// Return number of items in the array
inline i32 algo::ary_N(const algo::ByteAry& parent) {
    return parent.ary_n;
}

// --- algo.ByteAry.ary.RemoveAll
inline void algo::ary_RemoveAll(algo::ByteAry& parent) {
    parent.ary_n = 0;
}

// --- algo.ByteAry.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ary_Reserve(algo::ByteAry& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- algo.ByteAry.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& algo::ary_qFind(algo::ByteAry& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- algo.ByteAry.ary.qLast
// Return reference to last element of array. No bounds checking
inline u8& algo::ary_qLast(algo::ByteAry& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- algo.ByteAry.ary.rowid_Get
// Return row id of specified element
inline u64 algo::ary_rowid_Get(algo::ByteAry& parent, u8 &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- algo.ByteAry.ary_curs.Next
// proceed to next item
inline void algo::ByteAry_ary_curs_Next(ByteAry_ary_curs &curs) {
    curs.index++;
}

// --- algo.ByteAry.ary_curs.Reset
inline void algo::ByteAry_ary_curs_Reset(ByteAry_ary_curs &curs, algo::ByteAry &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- algo.ByteAry.ary_curs.ValidQ
// cursor points to valid item
inline bool algo::ByteAry_ary_curs_ValidQ(ByteAry_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.ByteAry.ary_curs.Access
// item access
inline u8& algo::ByteAry_ary_curs_Access(ByteAry_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.ByteAry..Init
// Set all fields to initial values.
inline void algo::ByteAry_Init(algo::ByteAry& parent) {
    parent.ary_elems 	= 0; // (algo.ByteAry.ary)
    parent.ary_n     	= 0; // (algo.ByteAry.ary)
    parent.ary_max   	= 0; // (algo.ByteAry.ary)
}
inline algo::Charset::Charset() {
    algo::Charset_Init(*this);
}


// --- algo.Charset.ch.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int algo::ch_Nbits(algo::Charset& parent) {
    return ch_N(parent) * 64;
}

// --- algo.Charset.ch.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool algo::ch_qGetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- algo.Charset.ch.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool algo::ch_GetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    bool ret = false;
    u64 lim = ch_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ch_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- algo.Charset.ch.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool algo::ch_BitsEmptyQ(algo::Charset& parent) {
    bool retval = true;
    u64 n = ch_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (ch_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- algo.Charset.ch.Sum1s
inline u64 algo::ch_Sum1s(algo::Charset& parent) {
    u64 sum = 0;
    u64 n = ch_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u64_Count1s(ch_qFind(parent, i));
    }
    return sum;
}

// --- algo.Charset.ch.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qClearBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u64(1) << shift); // clear bit
}

// --- algo.Charset.ch.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void algo::ch_ClearBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = ch_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ch_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u64(1) << shift); // clear bit
    }
}

// --- algo.Charset.ch.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qSetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(1) << shift); // set bit
}

// --- algo.Charset.ch.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void algo::ch_SetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = ch_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ch_qFind(parent, elem_idx); // fetch
        elem = elem | (u64(1) << shift); // set bit
    }
}

// --- algo.Charset.ch.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qSetBitVal(algo::Charset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u64(1) << shift)) | (u64(val) << shift); // insert new value
}

// --- algo.Charset.ch.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qOrBitVal(algo::Charset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(val) << shift); // Or in val into elem
}

// --- algo.Charset.ch.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void algo::ch_ClearBitsAll(algo::Charset& parent) {
    u64 n = ch_N(parent);
    for (u64 i = 0; i < n; i++) {
        ch_qFind(parent, i) = 0;
    }
}

// --- algo.Charset.ch.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void algo::ch_ClearBits(algo::Charset& parent, algo::Charset &rhs) {
    u64 n = u64_Min(ch_N(parent), ch_N(rhs));
    for (u64 i = 0; i < n; i++) {
        ch_qFind(parent, i) &= ~ch_qFind(rhs, i);
    }
}

// --- algo.Charset.ch.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void algo::ch_OrBits(algo::Charset& parent, algo::Charset &rhs) {
    u64 n = u64_Min(ch_N(parent), ch_N(rhs));
    for (u64 i = 0; i < n; i++) {
        ch_qFind(parent, i) |= ch_qFind(rhs, i);
    }
}

// --- algo.Charset.ch.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 algo::ch_Sup(algo::Charset& parent) {
    u64 lim = ch_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u64 &val = ch_qFind(parent, i);
        if (val) {
            u32 bitidx = u64_BitScanReverse(val) + 1;
            ret = i * 64 + bitidx;
            break;
        }
    }
    return ret;
}

// --- algo.Charset.ch.Fill
// Set all elements of fixed array to value RHS
inline void algo::ch_Fill(algo::Charset& parent, const u64 &rhs) {
    for (int i = 0; i < 8; i++) {
        parent.ch_elems[i] = rhs;
    }
}

// --- algo.Charset.ch.Find
// Look up row by row id. Return NULL if out of range
inline u64* algo::ch_Find(algo::Charset& parent, u64 t) {
    u64 idx = t;
    u64 lim = 8;
    return idx < lim ? parent.ch_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Charset.ch.Getary
// Access fixed array ch as aryptr.
inline algo::aryptr<u64> algo::ch_Getary(algo::Charset& parent) {
    return algo::aryptr<u64>(parent.ch_elems, 8);
}

// --- algo.Charset.ch.Max
// Return max number of items in the array
inline i32 algo::ch_Max(algo::Charset& parent) {
    (void)parent;
    return 8;
}

// --- algo.Charset.ch.N
// Return number of items in the array
inline i32 algo::ch_N(const algo::Charset& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 8;
}

// --- algo.Charset.ch.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::ch_Setary(algo::Charset& parent, const algo::aryptr<u64> &rhs) {
    int n = 8 < rhs.n_elems ? 8 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.ch_elems[i] = rhs[i];
    }
}

// --- algo.Charset.ch.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u64& algo::ch_qFind(algo::Charset& parent, u64 t) {
    return parent.ch_elems[t];
}

// --- algo.Charset.ch_curs.Reset
// cursor points to valid item
inline void algo::Charset_ch_curs_Reset(Charset_ch_curs &curs, algo::Charset &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Charset.ch_curs.ValidQ
// cursor points to valid item
inline bool algo::Charset_ch_curs_ValidQ(Charset_ch_curs &curs) {
    return u64(curs.index) < u64(8);
}

// --- algo.Charset.ch_curs.Next
// proceed to next item
inline void algo::Charset_ch_curs_Next(Charset_ch_curs &curs) {
    curs.index++;
}

// --- algo.Charset.ch_curs.Access
// item access
inline u64& algo::Charset_ch_curs_Access(Charset_ch_curs &curs) {
    return ch_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Charset..Init
// Set all fields to initial values.
inline void algo::Charset_Init(algo::Charset& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch_elems[i] = 0;
    }
}

inline bool algo::Smallstr150::operator ==(const algo::Smallstr150 &rhs) const {
    return algo::Smallstr150_Eq(const_cast<algo::Smallstr150&>(*this),const_cast<algo::Smallstr150&>(rhs));
}

inline bool algo::Smallstr150::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr150_EqStrptr(const_cast<algo::Smallstr150&>(*this),rhs);
}
inline algo::Smallstr150::Smallstr150() {
    algo::Smallstr150_Init(*this);
}


// --- algo.Smallstr150.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr150& parent, char c) {
    if (parent.n_ch < 150) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr150.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr150& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 150) {
        n_new = 150 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr150.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr150& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr150.ch.HashStrptr
inline u32 algo::Smallstr150_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr150.ch.Init
inline void algo::ch_Init(algo::Smallstr150 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr150.ch.Max
// always return constant 150
inline int algo::ch_Max(algo::Smallstr150& parent) {
    (void)parent;
    return 150;
}

// --- algo.Smallstr150.ch.N
inline int algo::ch_N(const algo::Smallstr150& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr150.ch.Cast
inline algo::Smallstr150::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr150..Cmp
inline i32 algo::Smallstr150_Cmp(algo::Smallstr150 & lhs, algo::Smallstr150 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr150..Init
// Set all fields to initial values.
inline void algo::Smallstr150_Init(algo::Smallstr150& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr150..Eq
inline bool algo::Smallstr150_Eq(const algo::Smallstr150 & lhs,const algo::Smallstr150 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr150..EqStrptr
inline bool algo::Smallstr150_EqStrptr(algo::Smallstr150 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::Comment::Comment(const algo::strptr&            in_value)
    : value(in_value)
{
}
inline algo::Comment::Comment() {
}


// --- algo.Comment.value.Cast
inline algo::Comment::operator algo::strptr () const {
    return algo::strptr((*this).value);
}

// --- algo.Comment..Cmp
inline i32 algo::Comment_Cmp(algo::Comment & lhs, algo::Comment & rhs) {
    i32 retval = 0;
    retval = algo::Smallstr150_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.Comment..Eq
inline bool algo::Comment_Eq(const algo::Comment & lhs,const algo::Comment & rhs) {
    bool retval = true;
    retval = algo::Smallstr150_Eq(lhs.value, rhs.value);
    return retval;
}
inline algo::UnTime::UnTime(i64                            in_value)
    : value(in_value)
{
}

inline bool algo::UnTime::operator ==(const algo::UnTime &rhs) const {
    return algo::UnTime_Eq(const_cast<algo::UnTime&>(*this),const_cast<algo::UnTime&>(rhs));
}

inline bool algo::UnTime::operator <(const algo::UnTime &rhs) const {
    return algo::UnTime_Lt(const_cast<algo::UnTime&>(*this),const_cast<algo::UnTime&>(rhs));
}
inline algo::UnTime::UnTime() {
    algo::UnTime_Init(*this);
}


// --- algo.UnTime..Hash
inline u32 algo::UnTime_Hash(u32 prev, algo::UnTime rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnTime..Lt
inline bool algo::UnTime_Lt(algo::UnTime lhs, algo::UnTime rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnTime..Cmp
inline i32 algo::UnTime_Cmp(algo::UnTime lhs, algo::UnTime rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnTime..Init
// Set all fields to initial values.
inline void algo::UnTime_Init(algo::UnTime& parent) {
    parent.value = i64(0);
}

// --- algo.UnTime..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnTime_UpdateMax(algo::UnTime &lhs, algo::UnTime rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnTime..Min
// Return the lesser of two values
inline algo::UnTime algo::UnTime_Min(algo::UnTime lhs, algo::UnTime rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnTime..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnTime_UpdateMin(algo::UnTime &lhs, algo::UnTime rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnTime..Max
// Return the greater of two values
inline algo::UnTime algo::UnTime_Max(algo::UnTime lhs, algo::UnTime rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnTime..Eq
inline bool algo::UnTime_Eq(algo::UnTime lhs, algo::UnTime rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnTime_Update(algo::UnTime &lhs, algo::UnTime rhs) {
    bool ret = !UnTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::DateCache::DateCache() {
}

inline algo::Dbbox::Dbbox(double                         in_min
        ,double                         in_max)
    : min(in_min)
    , max(in_max)
{
}
inline algo::Dbbox::Dbbox() {
    algo::Dbbox_Init(*this);
}


// --- algo.Dbbox..Init
// Set all fields to initial values.
inline void algo::Dbbox_Init(algo::Dbbox& parent) {
    parent.min = double(1e38);
    parent.max = double(-1e38);
}
inline algo::DirEntry::DirEntry() {
    algo::DirEntry_Init(*this);
}

inline algo::DirEntry::~DirEntry() {
    algo::DirEntry_Uninit(*this);
}

inline algo::DryrunQ::DryrunQ(bool                           in_value)
    : value(in_value)
{
}
inline algo::DryrunQ::DryrunQ() {
    algo::DryrunQ_Init(*this);
}


// --- algo.DryrunQ.value.Cast
inline algo::DryrunQ::operator bool () const {
    return bool((*this).value);
}

// --- algo.DryrunQ..Init
// Set all fields to initial values.
inline void algo::DryrunQ_Init(algo::DryrunQ& parent) {
    parent.value = bool(false);
}
inline algo::EchoQ::EchoQ(bool                           in_value)
    : value(in_value)
{
}
inline algo::EchoQ::EchoQ(algo_EchoQEnum arg) { this->value = bool(arg); }
inline algo::EchoQ::EchoQ() {
    algo::EchoQ_Init(*this);
}


// --- algo.EchoQ.value.GetEnum
// Get value of field as enum type
inline algo_EchoQEnum algo::value_GetEnum(const algo::EchoQ& parent) {
    return algo_EchoQEnum(parent.value);
}

// --- algo.EchoQ.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::EchoQ& parent, algo_EchoQEnum rhs) {
    parent.value = bool(rhs);
}

// --- algo.EchoQ.value.Cast
inline algo::EchoQ::operator algo_EchoQEnum () const {
    return algo_EchoQEnum((*this).value);
}

// --- algo.EchoQ..Init
// Set all fields to initial values.
inline void algo::EchoQ_Init(algo::EchoQ& parent) {
    parent.value = bool(false);
}
inline algo::Errns::Errns(u8                             in_value)
    : value(in_value)
{
}
inline algo::Errns::Errns(algo_ErrnsEnum arg) { this->value = u8(arg); }
inline algo::Errns::Errns() {
    algo::Errns_Init(*this);
}


// --- algo.Errns.value.GetEnum
// Get value of field as enum type
inline algo_ErrnsEnum algo::value_GetEnum(const algo::Errns& parent) {
    return algo_ErrnsEnum(parent.value);
}

// --- algo.Errns.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::Errns& parent, algo_ErrnsEnum rhs) {
    parent.value = u8(rhs);
}

// --- algo.Errns.value.Cast
inline algo::Errns::operator algo_ErrnsEnum () const {
    return algo_ErrnsEnum((*this).value);
}

// --- algo.Errns..Init
// Set all fields to initial values.
inline void algo::Errns_Init(algo::Errns& parent) {
    parent.value = u8(0);
}
inline algo::Errcode::Errcode() {
    algo::Errcode_Init(*this);
}


// --- algo.Errcode.code.Get
// Retrieve bitfield from value of field value
//    32 bits starting at bit 0.
inline i32 algo::code_Get(const algo::Errcode& parent) {
    return i32((parent.value >> 0) & 0xffffffff);
}

// --- algo.Errcode.code.Set
// Set bitfield in value of field 'value'
//    32 bits starting at bit 0.
inline void algo::code_Set(algo::Errcode& parent, i32 rhs) {
    u64 t1    = u64(0xffffffff) << 0;
    u64 t2    = (u64(rhs) & 0xffffffff) << 0;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- algo.Errcode.type.Get
// Retrieve bitfield from value of field value
//    8 bits starting at bit 32.
inline algo::Errns algo::type_Get(const algo::Errcode& parent) {
    return algo::Errns((parent.value >> 32) & 0xff);
}

// --- algo.Errcode.type.Set
// Set bitfield in value of field 'value'
//    8 bits starting at bit 32.
inline void algo::type_Set(algo::Errcode& parent, algo::Errns rhs) {
    u64 t1    = u64(0xff) << 32;
    u64 t2    = (u64(rhs.value) & 0xff) << 32;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- algo.Errcode..Init
// Set all fields to initial values.
inline void algo::Errcode_Init(algo::Errcode& parent) {
    parent.value = u64(0);
}
inline algo::FailokQ::FailokQ(bool                           in_value)
    : value(in_value)
{
}
inline algo::FailokQ::FailokQ(algo_FailokQEnum arg) { this->value = bool(arg); }
inline algo::FailokQ::FailokQ() {
    algo::FailokQ_Init(*this);
}


// --- algo.FailokQ.value.GetEnum
// Get value of field as enum type
inline algo_FailokQEnum algo::value_GetEnum(const algo::FailokQ& parent) {
    return algo_FailokQEnum(parent.value);
}

// --- algo.FailokQ.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::FailokQ& parent, algo_FailokQEnum rhs) {
    parent.value = bool(rhs);
}

// --- algo.FailokQ.value.Cast
inline algo::FailokQ::operator algo_FailokQEnum () const {
    return algo_FailokQEnum((*this).value);
}

// --- algo.FailokQ..Init
// Set all fields to initial values.
inline void algo::FailokQ_Init(algo::FailokQ& parent) {
    parent.value = bool(false);
}
inline algo::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline algo::FieldId::FieldId(algo_FieldIdEnum arg) { this->value = i32(arg); }
inline algo::FieldId::FieldId() {
    algo::FieldId_Init(*this);
}


// --- algo.FieldId.value.GetEnum
// Get value of field as enum type
inline algo_FieldIdEnum algo::value_GetEnum(const algo::FieldId& parent) {
    return algo_FieldIdEnum(parent.value);
}

// --- algo.FieldId.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::FieldId& parent, algo_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- algo.FieldId.value.Cast
inline algo::FieldId::operator algo_FieldIdEnum () const {
    return algo_FieldIdEnum((*this).value);
}

// --- algo.FieldId..Init
// Set all fields to initial values.
inline void algo::FieldId_Init(algo::FieldId& parent) {
    parent.value = i32(-1);
}
inline algo::Fildes::Fildes(i32                            in_value)
    : value(in_value)
{
}

inline bool algo::Fildes::operator ==(const algo::Fildes &rhs) const {
    return algo::Fildes_Eq(const_cast<algo::Fildes&>(*this),const_cast<algo::Fildes&>(rhs));
}

inline bool algo::Fildes::operator <(const algo::Fildes &rhs) const {
    return algo::Fildes_Lt(const_cast<algo::Fildes&>(*this),const_cast<algo::Fildes&>(rhs));
}
inline algo::Fildes::Fildes() {
    algo::Fildes_Init(*this);
}


// --- algo.Fildes..Hash
inline u32 algo::Fildes_Hash(u32 prev, const algo::Fildes & rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.Fildes..Lt
inline bool algo::Fildes_Lt(algo::Fildes & lhs, algo::Fildes & rhs) {
    return i32_Lt(lhs.value, rhs.value);
}

// --- algo.Fildes..Cmp
inline i32 algo::Fildes_Cmp(algo::Fildes & lhs, algo::Fildes & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.Fildes..Init
// Set all fields to initial values.
inline void algo::Fildes_Init(algo::Fildes& parent) {
    parent.value = i32(-1);
}

// --- algo.Fildes..Eq
inline bool algo::Fildes_Eq(const algo::Fildes & lhs,const algo::Fildes & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.Fildes..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Fildes_Update(algo::Fildes &lhs, algo::Fildes & rhs) {
    bool ret = !Fildes_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::FileFlags::FileFlags(u32                            in_value)
    : value(in_value)
{
}
inline algo::FileFlags::FileFlags(algo_FileFlagsEnum arg) { this->value = u32(arg); }
inline algo::FileFlags::FileFlags() {
    algo::FileFlags_Init(*this);
}


// --- algo.FileFlags.value.GetEnum
// Get value of field as enum type
inline algo_FileFlagsEnum algo::value_GetEnum(const algo::FileFlags& parent) {
    return algo_FileFlagsEnum(parent.value);
}

// --- algo.FileFlags.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::FileFlags& parent, algo_FileFlagsEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.FileFlags.value.Cast
inline algo::FileFlags::operator algo_FileFlagsEnum () const {
    return algo_FileFlagsEnum((*this).value);
}

// --- algo.FileFlags.append.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
inline bool algo::append_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 4) & 0x01);
}

// --- algo.FileFlags.append.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
inline void algo::append_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 4;
    u32 t2    = (u32(rhs) & 0x01) << 4;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool algo::read_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- algo.FileFlags.read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void algo::read_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 0;
    u32 t2    = (u32(rhs) & 0x01) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool algo::write_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- algo.FileFlags.write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void algo::write_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 1;
    u32 t2    = (u32(rhs) & 0x01) << 1;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags._throw.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 5.
inline bool algo::_throw_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 5) & 0x01);
}

// --- algo.FileFlags._throw.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 5.
inline void algo::_throw_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 5;
    u32 t2    = (u32(rhs) & 0x01) << 5;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags..Init
// Set all fields to initial values.
inline void algo::FileFlags_Init(algo::FileFlags& parent) {
    parent.value = u32(0);
}
inline algo::I32Dec1::I32Dec1(i32                            in_value)
    : value(in_value)
{
}
inline algo::I32Dec1::I32Dec1() {
    algo::I32Dec1_Init(*this);
}


// --- algo.I32Dec1.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec1& parent, double val) {
    double intval = val * 10 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec1.value.GetDouble
inline double algo::value_GetDouble(algo::I32Dec1& parent) {
    double ret;
    ret = parent.value * 0.1;
    return ret;
}

// --- algo.I32Dec1.value.GetInt
// Return integer portion (divide number by 10)
inline i32 algo::value_GetInt(algo::I32Dec1& parent) {
    i32 ret;
    ret = parent.value / 10;
    return ret;
}

// --- algo.I32Dec1.value.GetScale
// Return constant 10
inline i32 algo::I32Dec1_GetScale() {
    return 10;
}

// --- algo.I32Dec1.value.Cast
inline algo::I32Dec1::operator i32 () const {
    return i32((*this).value);
}

// --- algo.I32Dec1..Hash
inline u32 algo::I32Dec1_Hash(u32 prev, algo::I32Dec1 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec1..Init
// Set all fields to initial values.
inline void algo::I32Dec1_Init(algo::I32Dec1& parent) {
    parent.value = i32(0);
}
inline algo::I32Dec2::I32Dec2(i32                            in_value)
    : value(in_value)
{
}
inline algo::I32Dec2::I32Dec2() {
    algo::I32Dec2_Init(*this);
}


// --- algo.I32Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec2.value.GetDouble
inline double algo::value_GetDouble(algo::I32Dec2& parent) {
    double ret;
    ret = parent.value * 0.01;
    return ret;
}

// --- algo.I32Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline i32 algo::value_GetInt(algo::I32Dec2& parent) {
    i32 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.I32Dec2.value.GetScale
// Return constant 100
inline i32 algo::I32Dec2_GetScale() {
    return 100;
}

// --- algo.I32Dec2.value.Cast
inline algo::I32Dec2::operator i32 () const {
    return i32((*this).value);
}

// --- algo.I32Dec2..Hash
inline u32 algo::I32Dec2_Hash(u32 prev, algo::I32Dec2 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec2..Init
// Set all fields to initial values.
inline void algo::I32Dec2_Init(algo::I32Dec2& parent) {
    parent.value = i32(0);
}
inline algo::I32Dec3::I32Dec3(i32                            in_value)
    : value(in_value)
{
}
inline algo::I32Dec3::I32Dec3() {
    algo::I32Dec3_Init(*this);
}


// --- algo.I32Dec3.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec3& parent, double val) {
    double intval = val * 1000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec3.value.GetDouble
inline double algo::value_GetDouble(algo::I32Dec3& parent) {
    double ret;
    ret = parent.value * 0.001;
    return ret;
}

// --- algo.I32Dec3.value.GetInt
// Return integer portion (divide number by 1000)
inline i32 algo::value_GetInt(algo::I32Dec3& parent) {
    i32 ret;
    ret = parent.value / 1000;
    return ret;
}

// --- algo.I32Dec3.value.GetScale
// Return constant 1000
inline i32 algo::I32Dec3_GetScale() {
    return 1000;
}

// --- algo.I32Dec3.value.Cast
inline algo::I32Dec3::operator i32 () const {
    return i32((*this).value);
}

// --- algo.I32Dec3..Hash
inline u32 algo::I32Dec3_Hash(u32 prev, algo::I32Dec3 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec3..Init
// Set all fields to initial values.
inline void algo::I32Dec3_Init(algo::I32Dec3& parent) {
    parent.value = i32(0);
}
inline algo::I32Dec4::I32Dec4(i32                            in_value)
    : value(in_value)
{
}
inline algo::I32Dec4::I32Dec4() {
    algo::I32Dec4_Init(*this);
}


// --- algo.I32Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec4.value.GetDouble
inline double algo::value_GetDouble(algo::I32Dec4& parent) {
    double ret;
    ret = parent.value * 0.0001;
    return ret;
}

// --- algo.I32Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline i32 algo::value_GetInt(algo::I32Dec4& parent) {
    i32 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.I32Dec4.value.GetScale
// Return constant 10000
inline i32 algo::I32Dec4_GetScale() {
    return 10000;
}

// --- algo.I32Dec4.value.Cast
inline algo::I32Dec4::operator i32 () const {
    return i32((*this).value);
}

// --- algo.I32Dec4..Hash
inline u32 algo::I32Dec4_Hash(u32 prev, algo::I32Dec4 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec4..Init
// Set all fields to initial values.
inline void algo::I32Dec4_Init(algo::I32Dec4& parent) {
    parent.value = i32(0);
}
inline algo::I32Dec5::I32Dec5(i32                            in_value)
    : value(in_value)
{
}
inline algo::I32Dec5::I32Dec5() {
    algo::I32Dec5_Init(*this);
}


// --- algo.I32Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec5.value.GetDouble
inline double algo::value_GetDouble(algo::I32Dec5& parent) {
    double ret;
    ret = parent.value * 0.00001;
    return ret;
}

// --- algo.I32Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline i32 algo::value_GetInt(algo::I32Dec5& parent) {
    i32 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.I32Dec5.value.GetScale
// Return constant 100000
inline i32 algo::I32Dec5_GetScale() {
    return 100000;
}

// --- algo.I32Dec5.value.Cast
inline algo::I32Dec5::operator i32 () const {
    return i32((*this).value);
}

// --- algo.I32Dec5..Hash
inline u32 algo::I32Dec5_Hash(u32 prev, algo::I32Dec5 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec5..Init
// Set all fields to initial values.
inline void algo::I32Dec5_Init(algo::I32Dec5& parent) {
    parent.value = i32(0);
}
inline algo::I64Dec1::I64Dec1(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec1::I64Dec1() {
    algo::I64Dec1_Init(*this);
}


// --- algo.I64Dec1.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec1& parent, double val) {
    double intval = val * 10 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec1.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec1& parent) {
    double ret;
    ret = parent.value * 0.1;
    return ret;
}

// --- algo.I64Dec1.value.GetInt
// Return integer portion (divide number by 10)
inline i64 algo::value_GetInt(algo::I64Dec1& parent) {
    i64 ret;
    ret = parent.value / 10;
    return ret;
}

// --- algo.I64Dec1.value.GetScale
// Return constant 10
inline i64 algo::I64Dec1_GetScale() {
    return 10;
}

// --- algo.I64Dec1.value.Cast
inline algo::I64Dec1::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec1..Hash
inline u32 algo::I64Dec1_Hash(u32 prev, algo::I64Dec1 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec1..Init
// Set all fields to initial values.
inline void algo::I64Dec1_Init(algo::I64Dec1& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec10::I64Dec10(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec10::I64Dec10() {
    algo::I64Dec10_Init(*this);
}


// --- algo.I64Dec10.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec10& parent, double val) {
    double intval = val * 10000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec10.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec10& parent) {
    double ret;
    ret = parent.value * 0.0000000001;
    return ret;
}

// --- algo.I64Dec10.value.GetInt
// Return integer portion (divide number by 10000000000)
inline i64 algo::value_GetInt(algo::I64Dec10& parent) {
    i64 ret;
    ret = parent.value / 10000000000;
    return ret;
}

// --- algo.I64Dec10.value.GetScale
// Return constant 10000000000
inline i64 algo::I64Dec10_GetScale() {
    return 10000000000;
}

// --- algo.I64Dec10.value.Cast
inline algo::I64Dec10::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec10..Hash
inline u32 algo::I64Dec10_Hash(u32 prev, algo::I64Dec10 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec10..Init
// Set all fields to initial values.
inline void algo::I64Dec10_Init(algo::I64Dec10& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec2::I64Dec2(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec2::I64Dec2() {
    algo::I64Dec2_Init(*this);
}


// --- algo.I64Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec2.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec2& parent) {
    double ret;
    ret = parent.value * 0.01;
    return ret;
}

// --- algo.I64Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline i64 algo::value_GetInt(algo::I64Dec2& parent) {
    i64 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.I64Dec2.value.GetScale
// Return constant 100
inline i64 algo::I64Dec2_GetScale() {
    return 100;
}

// --- algo.I64Dec2.value.Cast
inline algo::I64Dec2::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec2..Hash
inline u32 algo::I64Dec2_Hash(u32 prev, algo::I64Dec2 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec2..Init
// Set all fields to initial values.
inline void algo::I64Dec2_Init(algo::I64Dec2& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec3::I64Dec3(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec3::I64Dec3() {
    algo::I64Dec3_Init(*this);
}


// --- algo.I64Dec3.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec3& parent, double val) {
    double intval = val * 1000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec3.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec3& parent) {
    double ret;
    ret = parent.value * 0.001;
    return ret;
}

// --- algo.I64Dec3.value.GetInt
// Return integer portion (divide number by 1000)
inline i64 algo::value_GetInt(algo::I64Dec3& parent) {
    i64 ret;
    ret = parent.value / 1000;
    return ret;
}

// --- algo.I64Dec3.value.GetScale
// Return constant 1000
inline i64 algo::I64Dec3_GetScale() {
    return 1000;
}

// --- algo.I64Dec3.value.Cast
inline algo::I64Dec3::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec3..Hash
inline u32 algo::I64Dec3_Hash(u32 prev, algo::I64Dec3 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec3..Init
// Set all fields to initial values.
inline void algo::I64Dec3_Init(algo::I64Dec3& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec4::I64Dec4(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec4::I64Dec4() {
    algo::I64Dec4_Init(*this);
}


// --- algo.I64Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec4.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec4& parent) {
    double ret;
    ret = parent.value * 0.0001;
    return ret;
}

// --- algo.I64Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline i64 algo::value_GetInt(algo::I64Dec4& parent) {
    i64 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.I64Dec4.value.GetScale
// Return constant 10000
inline i64 algo::I64Dec4_GetScale() {
    return 10000;
}

// --- algo.I64Dec4.value.Cast
inline algo::I64Dec4::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec4..Hash
inline u32 algo::I64Dec4_Hash(u32 prev, algo::I64Dec4 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec4..Init
// Set all fields to initial values.
inline void algo::I64Dec4_Init(algo::I64Dec4& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec5::I64Dec5(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec5::I64Dec5() {
    algo::I64Dec5_Init(*this);
}


// --- algo.I64Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec5.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec5& parent) {
    double ret;
    ret = parent.value * 0.00001;
    return ret;
}

// --- algo.I64Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline i64 algo::value_GetInt(algo::I64Dec5& parent) {
    i64 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.I64Dec5.value.GetScale
// Return constant 100000
inline i64 algo::I64Dec5_GetScale() {
    return 100000;
}

// --- algo.I64Dec5.value.Cast
inline algo::I64Dec5::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec5..Hash
inline u32 algo::I64Dec5_Hash(u32 prev, algo::I64Dec5 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec5..Init
// Set all fields to initial values.
inline void algo::I64Dec5_Init(algo::I64Dec5& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec6::I64Dec6(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec6::I64Dec6() {
    algo::I64Dec6_Init(*this);
}


// --- algo.I64Dec6.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec6& parent, double val) {
    double intval = val * 1000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec6.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec6& parent) {
    double ret;
    ret = parent.value * 0.000001;
    return ret;
}

// --- algo.I64Dec6.value.GetInt
// Return integer portion (divide number by 1000000)
inline i64 algo::value_GetInt(algo::I64Dec6& parent) {
    i64 ret;
    ret = parent.value / 1000000;
    return ret;
}

// --- algo.I64Dec6.value.GetScale
// Return constant 1000000
inline i64 algo::I64Dec6_GetScale() {
    return 1000000;
}

// --- algo.I64Dec6.value.Cast
inline algo::I64Dec6::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec6..Hash
inline u32 algo::I64Dec6_Hash(u32 prev, algo::I64Dec6 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec6..Init
// Set all fields to initial values.
inline void algo::I64Dec6_Init(algo::I64Dec6& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec7::I64Dec7(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec7::I64Dec7() {
    algo::I64Dec7_Init(*this);
}


// --- algo.I64Dec7.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec7& parent, double val) {
    double intval = val * 10000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec7.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec7& parent) {
    double ret;
    ret = parent.value * 0.0000001;
    return ret;
}

// --- algo.I64Dec7.value.GetInt
// Return integer portion (divide number by 10000000)
inline i64 algo::value_GetInt(algo::I64Dec7& parent) {
    i64 ret;
    ret = parent.value / 10000000;
    return ret;
}

// --- algo.I64Dec7.value.GetScale
// Return constant 10000000
inline i64 algo::I64Dec7_GetScale() {
    return 10000000;
}

// --- algo.I64Dec7.value.Cast
inline algo::I64Dec7::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec7..Hash
inline u32 algo::I64Dec7_Hash(u32 prev, algo::I64Dec7 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec7..Init
// Set all fields to initial values.
inline void algo::I64Dec7_Init(algo::I64Dec7& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec8::I64Dec8(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec8::I64Dec8() {
    algo::I64Dec8_Init(*this);
}


// --- algo.I64Dec8.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec8& parent, double val) {
    double intval = val * 100000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec8.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec8& parent) {
    double ret;
    ret = parent.value * 0.00000001;
    return ret;
}

// --- algo.I64Dec8.value.GetInt
// Return integer portion (divide number by 100000000)
inline i64 algo::value_GetInt(algo::I64Dec8& parent) {
    i64 ret;
    ret = parent.value / 100000000;
    return ret;
}

// --- algo.I64Dec8.value.GetScale
// Return constant 100000000
inline i64 algo::I64Dec8_GetScale() {
    return 100000000;
}

// --- algo.I64Dec8.value.Cast
inline algo::I64Dec8::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec8..Hash
inline u32 algo::I64Dec8_Hash(u32 prev, algo::I64Dec8 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec8..Init
// Set all fields to initial values.
inline void algo::I64Dec8_Init(algo::I64Dec8& parent) {
    parent.value = i64(0);
}
inline algo::I64Dec9::I64Dec9(i64                            in_value)
    : value(in_value)
{
}
inline algo::I64Dec9::I64Dec9() {
    algo::I64Dec9_Init(*this);
}


// --- algo.I64Dec9.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec9& parent, double val) {
    double intval = val * 1000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec9.value.GetDouble
inline double algo::value_GetDouble(algo::I64Dec9& parent) {
    double ret;
    ret = parent.value * 0.000000001;
    return ret;
}

// --- algo.I64Dec9.value.GetInt
// Return integer portion (divide number by 1000000000)
inline i64 algo::value_GetInt(algo::I64Dec9& parent) {
    i64 ret;
    ret = parent.value / 1000000000;
    return ret;
}

// --- algo.I64Dec9.value.GetScale
// Return constant 1000000000
inline i64 algo::I64Dec9_GetScale() {
    return 1000000000;
}

// --- algo.I64Dec9.value.Cast
inline algo::I64Dec9::operator i64 () const {
    return i64((*this).value);
}

// --- algo.I64Dec9..Hash
inline u32 algo::I64Dec9_Hash(u32 prev, algo::I64Dec9 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec9..Init
// Set all fields to initial values.
inline void algo::I64Dec9_Init(algo::I64Dec9& parent) {
    parent.value = i64(0);
}
inline algo::IOEvtFlags::IOEvtFlags(u32                            in_value)
    : value(in_value)
{
}
inline algo::IOEvtFlags::IOEvtFlags() {
    algo::IOEvtFlags_Init(*this);
}


// --- algo.IOEvtFlags.value.Cast
inline algo::IOEvtFlags::operator u32 () const {
    return u32((*this).value);
}

// --- algo.IOEvtFlags.read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool algo::read_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- algo.IOEvtFlags.read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void algo::read_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 0;
    u32 t2    = (u32(rhs) & 0x01) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags.write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool algo::write_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- algo.IOEvtFlags.write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void algo::write_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 1;
    u32 t2    = (u32(rhs) & 0x01) << 1;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags.eof.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool algo::eof_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- algo.IOEvtFlags.eof.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void algo::eof_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 2;
    u32 t2    = (u32(rhs) & 0x01) << 2;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags.err.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool algo::err_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- algo.IOEvtFlags.err.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void algo::err_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 3;
    u32 t2    = (u32(rhs) & 0x01) << 3;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags..Init
// Set all fields to initial values.
inline void algo::IOEvtFlags_Init(algo::IOEvtFlags& parent) {
    parent.value = u32(0);
}
inline algo::IPoint::IPoint() {
    algo::IPoint_Init(*this);
}


// --- algo.IPoint..Init
// Set all fields to initial values.
inline void algo::IPoint_Init(algo::IPoint& parent) {
    parent.x = i32(0);
    parent.y = i32(0);
}
inline algo::Smallstr50::Smallstr50() {
    algo::Smallstr50_Init(*this);
}


// --- algo.Smallstr50.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr50& parent, char c) {
    if (parent.n_ch < 50) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr50.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr50& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 50) {
        n_new = 50 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr50.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr50& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr50.ch.HashStrptr
inline u32 algo::Smallstr50_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr50.ch.Init
inline void algo::ch_Init(algo::Smallstr50 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr50.ch.Max
// always return constant 50
inline int algo::ch_Max(algo::Smallstr50& parent) {
    (void)parent;
    return 50;
}

// --- algo.Smallstr50.ch.N
inline int algo::ch_N(const algo::Smallstr50& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr50.ch.Cast
inline algo::Smallstr50::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr50..Lt
inline bool algo::Smallstr50_Lt(algo::Smallstr50 & lhs, algo::Smallstr50 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.Smallstr50..Cmp
inline i32 algo::Smallstr50_Cmp(algo::Smallstr50 & lhs, algo::Smallstr50 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr50..Init
// Set all fields to initial values.
inline void algo::Smallstr50_Init(algo::Smallstr50& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr50..Eq
inline bool algo::Smallstr50_Eq(const algo::Smallstr50 & lhs,const algo::Smallstr50 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr50..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Smallstr50_Update(algo::Smallstr50 &lhs, algo::Smallstr50 & rhs) {
    bool ret = !Smallstr50_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Smallstr50..EqStrptr
inline bool algo::Smallstr50_EqStrptr(algo::Smallstr50 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::Imdb::Imdb(const algo::strptr&            in_imdb
        ,const algo::ImdbInsertStrptrMaybeFcn& in_InsertStrptrMaybe
        ,const algo::ImdbStepFcn&       in_Step
        ,const algo::ImdbMainLoopFcn&   in_MainLoop
        ,const algo::ImdbGetTraceFcn&   in_GetTrace
        ,const algo::Comment&           in_comment)
    : imdb(in_imdb)
    , InsertStrptrMaybe(in_InsertStrptrMaybe)
    , Step(in_Step)
    , MainLoop(in_MainLoop)
    , GetTrace(in_GetTrace)
    , comment(in_comment)
{
}
inline algo::Imdb::Imdb() {
    algo::Imdb_Init(*this);
}


// --- algo.Imdb..Init
// Set all fields to initial values.
inline void algo::Imdb_Init(algo::Imdb& parent) {
    memset(&parent.InsertStrptrMaybe, 0, sizeof(parent.InsertStrptrMaybe));
    memset(&parent.Step, 0, sizeof(parent.Step));
    memset(&parent.MainLoop, 0, sizeof(parent.MainLoop));
    memset(&parent.GetTrace, 0, sizeof(parent.GetTrace));
}
inline algo::ImrowPtr::ImrowPtr(u64                            in_value)
    : value(in_value)
{
}
inline algo::ImrowPtr::ImrowPtr() {
    algo::ImrowPtr_Init(*this);
}


// --- algo.ImrowPtr.value.Cast
inline algo::ImrowPtr::operator u64 () const {
    return u64((*this).value);
}

// --- algo.ImrowPtr..Init
// Set all fields to initial values.
inline void algo::ImrowPtr_Init(algo::ImrowPtr& parent) {
    parent.value = u64(0);
}
inline algo::Imtable::Imtable(const algo::strptr&            in_imtable
        ,const algo::strptr&            in_elem_type
        ,const algo::ImrowRowidFindFcn& in_c_RowidFind
        ,const algo::ImrowXrefXFcn&     in_XrefX
        ,const algo::ImrowNItemsFcn&    in_NItems
        ,const algo::ImrowPrintFcn&     in_Print
        ,i32                            in_size
        ,const algo::strptr&            in_ssimfile
        ,const algo::Comment&           in_comment)
    : imtable(in_imtable)
    , elem_type(in_elem_type)
    , c_RowidFind(in_c_RowidFind)
    , XrefX(in_XrefX)
    , NItems(in_NItems)
    , Print(in_Print)
    , size(in_size)
    , ssimfile(in_ssimfile)
    , comment(in_comment)
{
}
inline algo::Imtable::Imtable() {
    algo::Imtable_Init(*this);
}


// --- algo.Imtable..Init
// Set all fields to initial values.
inline void algo::Imtable_Init(algo::Imtable& parent) {
    memset(&parent.c_RowidFind, 0, sizeof(parent.c_RowidFind));
    memset(&parent.XrefX, 0, sizeof(parent.XrefX));
    memset(&parent.NItems, 0, sizeof(parent.NItems));
    memset(&parent.Print, 0, sizeof(parent.Print));
    parent.size = i32(0);
}
inline algo::Ipmask::Ipmask() {
    algo::Ipmask_Init(*this);
}


// --- algo.Ipmask..Init
// Set all fields to initial values.
inline void algo::Ipmask_Init(algo::Ipmask& parent) {
    parent.ip_host = u32(0);
    parent.mask = u32(0);
}

// --- algo.strptr..Update
// Set value. Return true if new value is different from old value.
inline bool algo::strptr_Update(algo::strptr &lhs, algo::strptr rhs) {
    bool ret = !strptr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::LineBuf::LineBuf() {
    algo::LineBuf_Init(*this);
}

inline algo::LineBuf::~LineBuf() {
    algo::LineBuf_Uninit(*this);
}


// --- algo.LineBuf.buf.EmptyQ
// Return true if index is empty
inline bool algo::buf_EmptyQ(algo::LineBuf& parent) {
    return parent.buf_n == 0;
}

// --- algo.LineBuf.buf.Find
// Look up row by row id. Return NULL if out of range
inline char* algo::buf_Find(algo::LineBuf& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.buf_n;
    if (idx >= lim) return NULL;
    return parent.buf_elems + idx;
}

// --- algo.LineBuf.buf.Getary
// Return array pointer by value
inline algo::aryptr<char> algo::buf_Getary(algo::LineBuf& parent) {
    return algo::aryptr<char>(parent.buf_elems, parent.buf_n);
}

// --- algo.LineBuf.buf.Last
// Return pointer to last element of array, or NULL if array is empty
inline char* algo::buf_Last(algo::LineBuf& parent) {
    return buf_Find(parent, u64(parent.buf_n-1));
}

// --- algo.LineBuf.buf.Max
// Return max. number of items in the array
inline i32 algo::buf_Max(algo::LineBuf& parent) {
    (void)parent;
    return parent.buf_max;
}

// --- algo.LineBuf.buf.N
// Return number of items in the array
inline i32 algo::buf_N(const algo::LineBuf& parent) {
    return parent.buf_n;
}

// --- algo.LineBuf.buf.RemoveAll
inline void algo::buf_RemoveAll(algo::LineBuf& parent) {
    parent.buf_n = 0;
}

// --- algo.LineBuf.buf.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::buf_Reserve(algo::LineBuf& parent, int n) {
    u32 new_n = parent.buf_n + n;
    if (UNLIKELY(new_n > parent.buf_max)) {
        buf_AbsReserve(parent, new_n);
    }
}

// --- algo.LineBuf.buf.qFind
// 'quick' Access row by row id. No bounds checking.
inline char& algo::buf_qFind(algo::LineBuf& parent, u64 t) {
    return parent.buf_elems[t];
}

// --- algo.LineBuf.buf.qLast
// Return reference to last element of array. No bounds checking
inline char& algo::buf_qLast(algo::LineBuf& parent) {
    return buf_qFind(parent, u64(parent.buf_n-1));
}

// --- algo.LineBuf.buf.rowid_Get
// Return row id of specified element
inline u64 algo::buf_rowid_Get(algo::LineBuf& parent, char &elem) {
    u64 id = &elem - parent.buf_elems;
    return u64(id);
}

// --- algo.LineBuf.buf_curs.Next
// proceed to next item
inline void algo::LineBuf_buf_curs_Next(LineBuf_buf_curs &curs) {
    curs.index++;
}

// --- algo.LineBuf.buf_curs.Reset
inline void algo::LineBuf_buf_curs_Reset(LineBuf_buf_curs &curs, algo::LineBuf &parent) {
    curs.elems = parent.buf_elems;
    curs.n_elems = parent.buf_n;
    curs.index = 0;
}

// --- algo.LineBuf.buf_curs.ValidQ
// cursor points to valid item
inline bool algo::LineBuf_buf_curs_ValidQ(LineBuf_buf_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.LineBuf.buf_curs.Access
// item access
inline char& algo::LineBuf_buf_curs_Access(LineBuf_buf_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.LineBuf..Init
// Set all fields to initial values.
inline void algo::LineBuf_Init(algo::LineBuf& parent) {
    parent.buf_elems 	= 0; // (algo.LineBuf.buf)
    parent.buf_n     	= 0; // (algo.LineBuf.buf)
    parent.buf_max   	= 0; // (algo.LineBuf.buf)
    parent.implied_eof = bool(false);
    parent.eof = bool(false);
}

inline bool algo::LnumStr10_U64::operator ==(const algo::LnumStr10_U64 &rhs) const {
    return algo::LnumStr10_U64_Eq(const_cast<algo::LnumStr10_U64&>(*this),const_cast<algo::LnumStr10_U64&>(rhs));
}

inline bool algo::LnumStr10_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr10_U64_EqStrptr(const_cast<algo::LnumStr10_U64&>(*this),rhs);
}
inline algo::LnumStr10_U64::LnumStr10_U64() {
    algo::LnumStr10_U64_Init(*this);
}


// --- algo.LnumStr10_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr10_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 10 - len;
    return ret;
}

// --- algo.LnumStr10_U64.ch.HashStrptr
inline u32 algo::LnumStr10_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr10_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr10_U64 &parent) {
    for (int i = 0; i < 10; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr10_U64.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::LnumStr10_U64& parent) {
    (void)parent;
    return 10;
}

// --- algo.LnumStr10_U64.ch.N
inline int algo::ch_N(const algo::LnumStr10_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<10 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 10 - ret;
    return int(ret);
}

// --- algo.LnumStr10_U64.ch.Cast
inline algo::LnumStr10_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr10_U64..Cmp
inline i32 algo::LnumStr10_U64_Cmp(algo::LnumStr10_U64 & lhs, algo::LnumStr10_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr10_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr10_U64_Init(algo::LnumStr10_U64& parent) {
    for (int i = 0; i < 10; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr10_U64..Eq
inline bool algo::LnumStr10_U64_Eq(const algo::LnumStr10_U64 & lhs,const algo::LnumStr10_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr10_U64..EqStrptr
inline bool algo::LnumStr10_U64_EqStrptr(algo::LnumStr10_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr11_U64::operator ==(const algo::LnumStr11_U64 &rhs) const {
    return algo::LnumStr11_U64_Eq(const_cast<algo::LnumStr11_U64&>(*this),const_cast<algo::LnumStr11_U64&>(rhs));
}

inline bool algo::LnumStr11_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr11_U64_EqStrptr(const_cast<algo::LnumStr11_U64&>(*this),rhs);
}
inline algo::LnumStr11_U64::LnumStr11_U64() {
    algo::LnumStr11_U64_Init(*this);
}


// --- algo.LnumStr11_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr11_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 11 - len;
    return ret;
}

// --- algo.LnumStr11_U64.ch.HashStrptr
inline u32 algo::LnumStr11_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr11_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr11_U64 &parent) {
    for (int i = 0; i < 11; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr11_U64.ch.Max
// always return constant 11
inline int algo::ch_Max(algo::LnumStr11_U64& parent) {
    (void)parent;
    return 11;
}

// --- algo.LnumStr11_U64.ch.N
inline int algo::ch_N(const algo::LnumStr11_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<11 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 11 - ret;
    return int(ret);
}

// --- algo.LnumStr11_U64.ch.Cast
inline algo::LnumStr11_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr11_U64..Cmp
inline i32 algo::LnumStr11_U64_Cmp(algo::LnumStr11_U64 & lhs, algo::LnumStr11_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr11_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr11_U64_Init(algo::LnumStr11_U64& parent) {
    for (int i = 0; i < 11; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr11_U64..Eq
inline bool algo::LnumStr11_U64_Eq(const algo::LnumStr11_U64 & lhs,const algo::LnumStr11_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr11_U64..EqStrptr
inline bool algo::LnumStr11_U64_EqStrptr(algo::LnumStr11_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr12_U64::operator ==(const algo::LnumStr12_U64 &rhs) const {
    return algo::LnumStr12_U64_Eq(const_cast<algo::LnumStr12_U64&>(*this),const_cast<algo::LnumStr12_U64&>(rhs));
}

inline bool algo::LnumStr12_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr12_U64_EqStrptr(const_cast<algo::LnumStr12_U64&>(*this),rhs);
}
inline algo::LnumStr12_U64::LnumStr12_U64() {
    algo::LnumStr12_U64_Init(*this);
}


// --- algo.LnumStr12_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr12_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 12 - len;
    return ret;
}

// --- algo.LnumStr12_U64.ch.HashStrptr
inline u32 algo::LnumStr12_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr12_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr12_U64 &parent) {
    for (int i = 0; i < 12; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr12_U64.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::LnumStr12_U64& parent) {
    (void)parent;
    return 12;
}

// --- algo.LnumStr12_U64.ch.N
inline int algo::ch_N(const algo::LnumStr12_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<12 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 12 - ret;
    return int(ret);
}

// --- algo.LnumStr12_U64.ch.Cast
inline algo::LnumStr12_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr12_U64..Cmp
inline i32 algo::LnumStr12_U64_Cmp(algo::LnumStr12_U64 & lhs, algo::LnumStr12_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr12_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr12_U64_Init(algo::LnumStr12_U64& parent) {
    for (int i = 0; i < 12; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr12_U64..Eq
inline bool algo::LnumStr12_U64_Eq(const algo::LnumStr12_U64 & lhs,const algo::LnumStr12_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr12_U64..EqStrptr
inline bool algo::LnumStr12_U64_EqStrptr(algo::LnumStr12_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr13_U64_Base36::operator ==(const algo::LnumStr13_U64_Base36 &rhs) const {
    return algo::LnumStr13_U64_Base36_Eq(const_cast<algo::LnumStr13_U64_Base36&>(*this),const_cast<algo::LnumStr13_U64_Base36&>(rhs));
}

inline bool algo::LnumStr13_U64_Base36::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr13_U64_Base36_EqStrptr(const_cast<algo::LnumStr13_U64_Base36&>(*this),rhs);
}
inline algo::LnumStr13_U64_Base36::LnumStr13_U64_Base36() {
    algo::LnumStr13_U64_Base36_Init(*this);
}


// --- algo.LnumStr13_U64_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr13_U64_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 13 - len;
    return ret;
}

// --- algo.LnumStr13_U64_Base36.ch.HashStrptr
inline u32 algo::LnumStr13_U64_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr13_U64_Base36.ch.Init
inline void algo::ch_Init(algo::LnumStr13_U64_Base36 &parent) {
    for (int i = 0; i < 13; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr13_U64_Base36.ch.Max
// always return constant 13
inline int algo::ch_Max(algo::LnumStr13_U64_Base36& parent) {
    (void)parent;
    return 13;
}

// --- algo.LnumStr13_U64_Base36.ch.N
inline int algo::ch_N(const algo::LnumStr13_U64_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<13 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 13 - ret;
    return int(ret);
}

// --- algo.LnumStr13_U64_Base36.ch.Cast
inline algo::LnumStr13_U64_Base36::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr13_U64_Base36..Cmp
inline i32 algo::LnumStr13_U64_Base36_Cmp(algo::LnumStr13_U64_Base36 & lhs, algo::LnumStr13_U64_Base36 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr13_U64_Base36..Init
// Set all fields to initial values.
inline void algo::LnumStr13_U64_Base36_Init(algo::LnumStr13_U64_Base36& parent) {
    for (int i = 0; i < 13; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr13_U64_Base36..Eq
inline bool algo::LnumStr13_U64_Base36_Eq(const algo::LnumStr13_U64_Base36 & lhs,const algo::LnumStr13_U64_Base36 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr13_U64_Base36..EqStrptr
inline bool algo::LnumStr13_U64_Base36_EqStrptr(algo::LnumStr13_U64_Base36 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr16_U64_Base16::operator ==(const algo::LnumStr16_U64_Base16 &rhs) const {
    return algo::LnumStr16_U64_Base16_Eq(const_cast<algo::LnumStr16_U64_Base16&>(*this),const_cast<algo::LnumStr16_U64_Base16&>(rhs));
}

inline bool algo::LnumStr16_U64_Base16::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr16_U64_Base16_EqStrptr(const_cast<algo::LnumStr16_U64_Base16&>(*this),rhs);
}
inline algo::LnumStr16_U64_Base16::LnumStr16_U64_Base16() {
    algo::LnumStr16_U64_Base16_Init(*this);
}


// --- algo.LnumStr16_U64_Base16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr16_U64_Base16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 16 - len;
    return ret;
}

// --- algo.LnumStr16_U64_Base16.ch.HashStrptr
inline u32 algo::LnumStr16_U64_Base16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr16_U64_Base16.ch.Init
inline void algo::ch_Init(algo::LnumStr16_U64_Base16 &parent) {
    for (int i = 0; i < 16; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr16_U64_Base16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::LnumStr16_U64_Base16& parent) {
    (void)parent;
    return 16;
}

// --- algo.LnumStr16_U64_Base16.ch.N
inline int algo::ch_N(const algo::LnumStr16_U64_Base16& parent) {
    u64 ret;
    ret = 0;
    while (ret<16 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 16 - ret;
    return int(ret);
}

// --- algo.LnumStr16_U64_Base16.ch.Cast
inline algo::LnumStr16_U64_Base16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr16_U64_Base16..Cmp
inline i32 algo::LnumStr16_U64_Base16_Cmp(algo::LnumStr16_U64_Base16 & lhs, algo::LnumStr16_U64_Base16 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr16_U64_Base16..Init
// Set all fields to initial values.
inline void algo::LnumStr16_U64_Base16_Init(algo::LnumStr16_U64_Base16& parent) {
    for (int i = 0; i < 16; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr16_U64_Base16..Eq
inline bool algo::LnumStr16_U64_Base16_Eq(const algo::LnumStr16_U64_Base16 & lhs,const algo::LnumStr16_U64_Base16 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr16_U64_Base16..EqStrptr
inline bool algo::LnumStr16_U64_Base16_EqStrptr(algo::LnumStr16_U64_Base16 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr1_U32::operator ==(const algo::LnumStr1_U32 &rhs) const {
    return algo::LnumStr1_U32_Eq(const_cast<algo::LnumStr1_U32&>(*this),const_cast<algo::LnumStr1_U32&>(rhs));
}

inline bool algo::LnumStr1_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr1_U32_EqStrptr(const_cast<algo::LnumStr1_U32&>(*this),rhs);
}
inline algo::LnumStr1_U32::LnumStr1_U32() {
    algo::LnumStr1_U32_Init(*this);
}


// --- algo.LnumStr1_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr1_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 1 - len;
    return ret;
}

// --- algo.LnumStr1_U32.ch.HashStrptr
inline u32 algo::LnumStr1_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr1_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr1_U32 &parent) {
    for (int i = 0; i < 1; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr1_U32.ch.Max
// always return constant 1
inline int algo::ch_Max(algo::LnumStr1_U32& parent) {
    (void)parent;
    return 1;
}

// --- algo.LnumStr1_U32.ch.N
inline int algo::ch_N(const algo::LnumStr1_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<1 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 1 - ret;
    return int(ret);
}

// --- algo.LnumStr1_U32.ch.Cast
inline algo::LnumStr1_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr1_U32..Cmp
inline i32 algo::LnumStr1_U32_Cmp(algo::LnumStr1_U32 & lhs, algo::LnumStr1_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr1_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr1_U32_Init(algo::LnumStr1_U32& parent) {
    for (int i = 0; i < 1; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr1_U32..Eq
inline bool algo::LnumStr1_U32_Eq(const algo::LnumStr1_U32 & lhs,const algo::LnumStr1_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr1_U32..EqStrptr
inline bool algo::LnumStr1_U32_EqStrptr(algo::LnumStr1_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr20_U64::operator ==(const algo::LnumStr20_U64 &rhs) const {
    return algo::LnumStr20_U64_Eq(const_cast<algo::LnumStr20_U64&>(*this),const_cast<algo::LnumStr20_U64&>(rhs));
}

inline bool algo::LnumStr20_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr20_U64_EqStrptr(const_cast<algo::LnumStr20_U64&>(*this),rhs);
}
inline algo::LnumStr20_U64::LnumStr20_U64() {
    algo::LnumStr20_U64_Init(*this);
}


// --- algo.LnumStr20_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr20_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 20 - len;
    return ret;
}

// --- algo.LnumStr20_U64.ch.HashStrptr
inline u32 algo::LnumStr20_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr20_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr20_U64 &parent) {
    for (int i = 0; i < 20; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr20_U64.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::LnumStr20_U64& parent) {
    (void)parent;
    return 20;
}

// --- algo.LnumStr20_U64.ch.N
inline int algo::ch_N(const algo::LnumStr20_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<20 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 20 - ret;
    return int(ret);
}

// --- algo.LnumStr20_U64.ch.Cast
inline algo::LnumStr20_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr20_U64..Cmp
inline i32 algo::LnumStr20_U64_Cmp(algo::LnumStr20_U64 & lhs, algo::LnumStr20_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr20_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr20_U64_Init(algo::LnumStr20_U64& parent) {
    for (int i = 0; i < 20; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr20_U64..Eq
inline bool algo::LnumStr20_U64_Eq(const algo::LnumStr20_U64 & lhs,const algo::LnumStr20_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr20_U64..EqStrptr
inline bool algo::LnumStr20_U64_EqStrptr(algo::LnumStr20_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr22_U64::operator ==(const algo::LnumStr22_U64 &rhs) const {
    return algo::LnumStr22_U64_Eq(const_cast<algo::LnumStr22_U64&>(*this),const_cast<algo::LnumStr22_U64&>(rhs));
}

inline bool algo::LnumStr22_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr22_U64_EqStrptr(const_cast<algo::LnumStr22_U64&>(*this),rhs);
}
inline algo::LnumStr22_U64::LnumStr22_U64() {
    algo::LnumStr22_U64_Init(*this);
}


// --- algo.LnumStr22_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr22_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 22 - len;
    return ret;
}

// --- algo.LnumStr22_U64.ch.HashStrptr
inline u32 algo::LnumStr22_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr22_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr22_U64 &parent) {
    for (int i = 0; i < 22; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr22_U64.ch.Max
// always return constant 22
inline int algo::ch_Max(algo::LnumStr22_U64& parent) {
    (void)parent;
    return 22;
}

// --- algo.LnumStr22_U64.ch.N
inline int algo::ch_N(const algo::LnumStr22_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<22 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 22 - ret;
    return int(ret);
}

// --- algo.LnumStr22_U64.ch.Cast
inline algo::LnumStr22_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr22_U64..Cmp
inline i32 algo::LnumStr22_U64_Cmp(algo::LnumStr22_U64 & lhs, algo::LnumStr22_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr22_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr22_U64_Init(algo::LnumStr22_U64& parent) {
    for (int i = 0; i < 22; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr22_U64..Eq
inline bool algo::LnumStr22_U64_Eq(const algo::LnumStr22_U64 & lhs,const algo::LnumStr22_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr22_U64..EqStrptr
inline bool algo::LnumStr22_U64_EqStrptr(algo::LnumStr22_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr2_U32::operator ==(const algo::LnumStr2_U32 &rhs) const {
    return algo::LnumStr2_U32_Eq(const_cast<algo::LnumStr2_U32&>(*this),const_cast<algo::LnumStr2_U32&>(rhs));
}

inline bool algo::LnumStr2_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr2_U32_EqStrptr(const_cast<algo::LnumStr2_U32&>(*this),rhs);
}
inline algo::LnumStr2_U32::LnumStr2_U32() {
    algo::LnumStr2_U32_Init(*this);
}


// --- algo.LnumStr2_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr2_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 2 - len;
    return ret;
}

// --- algo.LnumStr2_U32.ch.HashStrptr
inline u32 algo::LnumStr2_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr2_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr2_U32 &parent) {
    for (int i = 0; i < 2; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr2_U32.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::LnumStr2_U32& parent) {
    (void)parent;
    return 2;
}

// --- algo.LnumStr2_U32.ch.N
inline int algo::ch_N(const algo::LnumStr2_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<2 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 2 - ret;
    return int(ret);
}

// --- algo.LnumStr2_U32.ch.Cast
inline algo::LnumStr2_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr2_U32..Cmp
inline i32 algo::LnumStr2_U32_Cmp(algo::LnumStr2_U32 & lhs, algo::LnumStr2_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr2_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr2_U32_Init(algo::LnumStr2_U32& parent) {
    for (int i = 0; i < 2; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr2_U32..Eq
inline bool algo::LnumStr2_U32_Eq(const algo::LnumStr2_U32 & lhs,const algo::LnumStr2_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr2_U32..EqStrptr
inline bool algo::LnumStr2_U32_EqStrptr(algo::LnumStr2_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr3_U32::operator ==(const algo::LnumStr3_U32 &rhs) const {
    return algo::LnumStr3_U32_Eq(const_cast<algo::LnumStr3_U32&>(*this),const_cast<algo::LnumStr3_U32&>(rhs));
}

inline bool algo::LnumStr3_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr3_U32_EqStrptr(const_cast<algo::LnumStr3_U32&>(*this),rhs);
}
inline algo::LnumStr3_U32::LnumStr3_U32() {
    algo::LnumStr3_U32_Init(*this);
}


// --- algo.LnumStr3_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr3_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 3 - len;
    return ret;
}

// --- algo.LnumStr3_U32.ch.HashStrptr
inline u32 algo::LnumStr3_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr3_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr3_U32 &parent) {
    for (int i = 0; i < 3; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr3_U32.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::LnumStr3_U32& parent) {
    (void)parent;
    return 3;
}

// --- algo.LnumStr3_U32.ch.N
inline int algo::ch_N(const algo::LnumStr3_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<3 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 3 - ret;
    return int(ret);
}

// --- algo.LnumStr3_U32.ch.Cast
inline algo::LnumStr3_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr3_U32..Cmp
inline i32 algo::LnumStr3_U32_Cmp(algo::LnumStr3_U32 & lhs, algo::LnumStr3_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr3_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr3_U32_Init(algo::LnumStr3_U32& parent) {
    for (int i = 0; i < 3; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr3_U32..Eq
inline bool algo::LnumStr3_U32_Eq(const algo::LnumStr3_U32 & lhs,const algo::LnumStr3_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr3_U32..EqStrptr
inline bool algo::LnumStr3_U32_EqStrptr(algo::LnumStr3_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr4_U32::operator ==(const algo::LnumStr4_U32 &rhs) const {
    return algo::LnumStr4_U32_Eq(const_cast<algo::LnumStr4_U32&>(*this),const_cast<algo::LnumStr4_U32&>(rhs));
}

inline bool algo::LnumStr4_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr4_U32_EqStrptr(const_cast<algo::LnumStr4_U32&>(*this),rhs);
}
inline algo::LnumStr4_U32::LnumStr4_U32() {
    algo::LnumStr4_U32_Init(*this);
}


// --- algo.LnumStr4_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr4_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 4 - len;
    return ret;
}

// --- algo.LnumStr4_U32.ch.HashStrptr
inline u32 algo::LnumStr4_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr4_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr4_U32 &parent) {
    for (int i = 0; i < 4; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr4_U32.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::LnumStr4_U32& parent) {
    (void)parent;
    return 4;
}

// --- algo.LnumStr4_U32.ch.N
inline int algo::ch_N(const algo::LnumStr4_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<4 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 4 - ret;
    return int(ret);
}

// --- algo.LnumStr4_U32.ch.Cast
inline algo::LnumStr4_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr4_U32..Cmp
inline i32 algo::LnumStr4_U32_Cmp(algo::LnumStr4_U32 & lhs, algo::LnumStr4_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr4_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr4_U32_Init(algo::LnumStr4_U32& parent) {
    for (int i = 0; i < 4; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr4_U32..Eq
inline bool algo::LnumStr4_U32_Eq(const algo::LnumStr4_U32 & lhs,const algo::LnumStr4_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr4_U32..EqStrptr
inline bool algo::LnumStr4_U32_EqStrptr(algo::LnumStr4_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr5_U32::operator ==(const algo::LnumStr5_U32 &rhs) const {
    return algo::LnumStr5_U32_Eq(const_cast<algo::LnumStr5_U32&>(*this),const_cast<algo::LnumStr5_U32&>(rhs));
}

inline bool algo::LnumStr5_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr5_U32_EqStrptr(const_cast<algo::LnumStr5_U32&>(*this),rhs);
}
inline algo::LnumStr5_U32::LnumStr5_U32() {
    algo::LnumStr5_U32_Init(*this);
}


// --- algo.LnumStr5_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr5_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LnumStr5_U32.ch.HashStrptr
inline u32 algo::LnumStr5_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr5_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr5_U32 &parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LnumStr5_U32& parent) {
    (void)parent;
    return 5;
}

// --- algo.LnumStr5_U32.ch.N
inline int algo::ch_N(const algo::LnumStr5_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LnumStr5_U32.ch.Cast
inline algo::LnumStr5_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr5_U32..Cmp
inline i32 algo::LnumStr5_U32_Cmp(algo::LnumStr5_U32 & lhs, algo::LnumStr5_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr5_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr5_U32_Init(algo::LnumStr5_U32& parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32..Eq
inline bool algo::LnumStr5_U32_Eq(const algo::LnumStr5_U32 & lhs,const algo::LnumStr5_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr5_U32..EqStrptr
inline bool algo::LnumStr5_U32_EqStrptr(algo::LnumStr5_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr5_U32_Base36::operator ==(const algo::LnumStr5_U32_Base36 &rhs) const {
    return algo::LnumStr5_U32_Base36_Eq(const_cast<algo::LnumStr5_U32_Base36&>(*this),const_cast<algo::LnumStr5_U32_Base36&>(rhs));
}

inline bool algo::LnumStr5_U32_Base36::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr5_U32_Base36_EqStrptr(const_cast<algo::LnumStr5_U32_Base36&>(*this),rhs);
}
inline algo::LnumStr5_U32_Base36::LnumStr5_U32_Base36() {
    algo::LnumStr5_U32_Base36_Init(*this);
}


// --- algo.LnumStr5_U32_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr5_U32_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LnumStr5_U32_Base36.ch.HashStrptr
inline u32 algo::LnumStr5_U32_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr5_U32_Base36.ch.Init
inline void algo::ch_Init(algo::LnumStr5_U32_Base36 &parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32_Base36.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LnumStr5_U32_Base36& parent) {
    (void)parent;
    return 5;
}

// --- algo.LnumStr5_U32_Base36.ch.N
inline int algo::ch_N(const algo::LnumStr5_U32_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LnumStr5_U32_Base36.ch.Cast
inline algo::LnumStr5_U32_Base36::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr5_U32_Base36..Cmp
inline i32 algo::LnumStr5_U32_Base36_Cmp(algo::LnumStr5_U32_Base36 & lhs, algo::LnumStr5_U32_Base36 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr5_U32_Base36..Init
// Set all fields to initial values.
inline void algo::LnumStr5_U32_Base36_Init(algo::LnumStr5_U32_Base36& parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32_Base36..Eq
inline bool algo::LnumStr5_U32_Base36_Eq(const algo::LnumStr5_U32_Base36 & lhs,const algo::LnumStr5_U32_Base36 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr5_U32_Base36..EqStrptr
inline bool algo::LnumStr5_U32_Base36_EqStrptr(algo::LnumStr5_U32_Base36 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr6_U32::operator ==(const algo::LnumStr6_U32 &rhs) const {
    return algo::LnumStr6_U32_Eq(const_cast<algo::LnumStr6_U32&>(*this),const_cast<algo::LnumStr6_U32&>(rhs));
}

inline bool algo::LnumStr6_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr6_U32_EqStrptr(const_cast<algo::LnumStr6_U32&>(*this),rhs);
}
inline algo::LnumStr6_U32::LnumStr6_U32() {
    algo::LnumStr6_U32_Init(*this);
}


// --- algo.LnumStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 6 - len;
    return ret;
}

// --- algo.LnumStr6_U32.ch.HashStrptr
inline u32 algo::LnumStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr6_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr6_U32 &parent) {
    for (int i = 0; i < 6; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr6_U32.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::LnumStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- algo.LnumStr6_U32.ch.N
inline int algo::ch_N(const algo::LnumStr6_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<6 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 6 - ret;
    return int(ret);
}

// --- algo.LnumStr6_U32.ch.Cast
inline algo::LnumStr6_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr6_U32..Cmp
inline i32 algo::LnumStr6_U32_Cmp(algo::LnumStr6_U32 & lhs, algo::LnumStr6_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr6_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr6_U32_Init(algo::LnumStr6_U32& parent) {
    for (int i = 0; i < 6; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr6_U32..Eq
inline bool algo::LnumStr6_U32_Eq(const algo::LnumStr6_U32 & lhs,const algo::LnumStr6_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr6_U32..EqStrptr
inline bool algo::LnumStr6_U32_EqStrptr(algo::LnumStr6_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr7_U32::operator ==(const algo::LnumStr7_U32 &rhs) const {
    return algo::LnumStr7_U32_Eq(const_cast<algo::LnumStr7_U32&>(*this),const_cast<algo::LnumStr7_U32&>(rhs));
}

inline bool algo::LnumStr7_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr7_U32_EqStrptr(const_cast<algo::LnumStr7_U32&>(*this),rhs);
}
inline algo::LnumStr7_U32::LnumStr7_U32() {
    algo::LnumStr7_U32_Init(*this);
}


// --- algo.LnumStr7_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr7_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 7 - len;
    return ret;
}

// --- algo.LnumStr7_U32.ch.HashStrptr
inline u32 algo::LnumStr7_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr7_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr7_U32 &parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::LnumStr7_U32& parent) {
    (void)parent;
    return 7;
}

// --- algo.LnumStr7_U32.ch.N
inline int algo::ch_N(const algo::LnumStr7_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<7 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 7 - ret;
    return int(ret);
}

// --- algo.LnumStr7_U32.ch.Cast
inline algo::LnumStr7_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr7_U32..Cmp
inline i32 algo::LnumStr7_U32_Cmp(algo::LnumStr7_U32 & lhs, algo::LnumStr7_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr7_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr7_U32_Init(algo::LnumStr7_U32& parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32..Eq
inline bool algo::LnumStr7_U32_Eq(const algo::LnumStr7_U32 & lhs,const algo::LnumStr7_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr7_U32..EqStrptr
inline bool algo::LnumStr7_U32_EqStrptr(algo::LnumStr7_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr7_U32_Base36::operator ==(const algo::LnumStr7_U32_Base36 &rhs) const {
    return algo::LnumStr7_U32_Base36_Eq(const_cast<algo::LnumStr7_U32_Base36&>(*this),const_cast<algo::LnumStr7_U32_Base36&>(rhs));
}

inline bool algo::LnumStr7_U32_Base36::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr7_U32_Base36_EqStrptr(const_cast<algo::LnumStr7_U32_Base36&>(*this),rhs);
}
inline algo::LnumStr7_U32_Base36::LnumStr7_U32_Base36() {
    algo::LnumStr7_U32_Base36_Init(*this);
}


// --- algo.LnumStr7_U32_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr7_U32_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 7 - len;
    return ret;
}

// --- algo.LnumStr7_U32_Base36.ch.HashStrptr
inline u32 algo::LnumStr7_U32_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr7_U32_Base36.ch.Init
inline void algo::ch_Init(algo::LnumStr7_U32_Base36 &parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32_Base36.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::LnumStr7_U32_Base36& parent) {
    (void)parent;
    return 7;
}

// --- algo.LnumStr7_U32_Base36.ch.N
inline int algo::ch_N(const algo::LnumStr7_U32_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<7 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 7 - ret;
    return int(ret);
}

// --- algo.LnumStr7_U32_Base36.ch.Cast
inline algo::LnumStr7_U32_Base36::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr7_U32_Base36..Cmp
inline i32 algo::LnumStr7_U32_Base36_Cmp(algo::LnumStr7_U32_Base36 & lhs, algo::LnumStr7_U32_Base36 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr7_U32_Base36..Init
// Set all fields to initial values.
inline void algo::LnumStr7_U32_Base36_Init(algo::LnumStr7_U32_Base36& parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32_Base36..Eq
inline bool algo::LnumStr7_U32_Base36_Eq(const algo::LnumStr7_U32_Base36 & lhs,const algo::LnumStr7_U32_Base36 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr7_U32_Base36..EqStrptr
inline bool algo::LnumStr7_U32_Base36_EqStrptr(algo::LnumStr7_U32_Base36 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr8_U32::operator ==(const algo::LnumStr8_U32 &rhs) const {
    return algo::LnumStr8_U32_Eq(const_cast<algo::LnumStr8_U32&>(*this),const_cast<algo::LnumStr8_U32&>(rhs));
}

inline bool algo::LnumStr8_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr8_U32_EqStrptr(const_cast<algo::LnumStr8_U32&>(*this),rhs);
}
inline algo::LnumStr8_U32::LnumStr8_U32() {
    algo::LnumStr8_U32_Init(*this);
}


// --- algo.LnumStr8_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr8_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LnumStr8_U32.ch.HashStrptr
inline u32 algo::LnumStr8_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr8_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr8_U32 &parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LnumStr8_U32& parent) {
    (void)parent;
    return 8;
}

// --- algo.LnumStr8_U32.ch.N
inline int algo::ch_N(const algo::LnumStr8_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LnumStr8_U32.ch.Cast
inline algo::LnumStr8_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr8_U32..Cmp
inline i32 algo::LnumStr8_U32_Cmp(algo::LnumStr8_U32 & lhs, algo::LnumStr8_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr8_U32_Init(algo::LnumStr8_U32& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32..Eq
inline bool algo::LnumStr8_U32_Eq(const algo::LnumStr8_U32 & lhs,const algo::LnumStr8_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U32..EqStrptr
inline bool algo::LnumStr8_U32_EqStrptr(algo::LnumStr8_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr8_U32_Base16::operator ==(const algo::LnumStr8_U32_Base16 &rhs) const {
    return algo::LnumStr8_U32_Base16_Eq(const_cast<algo::LnumStr8_U32_Base16&>(*this),const_cast<algo::LnumStr8_U32_Base16&>(rhs));
}

inline bool algo::LnumStr8_U32_Base16::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr8_U32_Base16_EqStrptr(const_cast<algo::LnumStr8_U32_Base16&>(*this),rhs);
}
inline algo::LnumStr8_U32_Base16::LnumStr8_U32_Base16() {
    algo::LnumStr8_U32_Base16_Init(*this);
}


// --- algo.LnumStr8_U32_Base16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr8_U32_Base16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LnumStr8_U32_Base16.ch.HashStrptr
inline u32 algo::LnumStr8_U32_Base16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr8_U32_Base16.ch.Init
inline void algo::ch_Init(algo::LnumStr8_U32_Base16 &parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32_Base16.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LnumStr8_U32_Base16& parent) {
    (void)parent;
    return 8;
}

// --- algo.LnumStr8_U32_Base16.ch.N
inline int algo::ch_N(const algo::LnumStr8_U32_Base16& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LnumStr8_U32_Base16.ch.Cast
inline algo::LnumStr8_U32_Base16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr8_U32_Base16..Cmp
inline i32 algo::LnumStr8_U32_Base16_Cmp(algo::LnumStr8_U32_Base16 & lhs, algo::LnumStr8_U32_Base16 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U32_Base16..Init
// Set all fields to initial values.
inline void algo::LnumStr8_U32_Base16_Init(algo::LnumStr8_U32_Base16& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32_Base16..Eq
inline bool algo::LnumStr8_U32_Base16_Eq(const algo::LnumStr8_U32_Base16 & lhs,const algo::LnumStr8_U32_Base16 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U32_Base16..EqStrptr
inline bool algo::LnumStr8_U32_Base16_EqStrptr(algo::LnumStr8_U32_Base16 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr8_U64::operator ==(const algo::LnumStr8_U64 &rhs) const {
    return algo::LnumStr8_U64_Eq(const_cast<algo::LnumStr8_U64&>(*this),const_cast<algo::LnumStr8_U64&>(rhs));
}

inline bool algo::LnumStr8_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr8_U64_EqStrptr(const_cast<algo::LnumStr8_U64&>(*this),rhs);
}
inline algo::LnumStr8_U64::LnumStr8_U64() {
    algo::LnumStr8_U64_Init(*this);
}


// --- algo.LnumStr8_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr8_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LnumStr8_U64.ch.HashStrptr
inline u32 algo::LnumStr8_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr8_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr8_U64 &parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U64.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LnumStr8_U64& parent) {
    (void)parent;
    return 8;
}

// --- algo.LnumStr8_U64.ch.N
inline int algo::ch_N(const algo::LnumStr8_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LnumStr8_U64.ch.Cast
inline algo::LnumStr8_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr8_U64..Cmp
inline i32 algo::LnumStr8_U64_Cmp(algo::LnumStr8_U64 & lhs, algo::LnumStr8_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr8_U64_Init(algo::LnumStr8_U64& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U64..Eq
inline bool algo::LnumStr8_U64_Eq(const algo::LnumStr8_U64 & lhs,const algo::LnumStr8_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U64..EqStrptr
inline bool algo::LnumStr8_U64_EqStrptr(algo::LnumStr8_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr9_U32::operator ==(const algo::LnumStr9_U32 &rhs) const {
    return algo::LnumStr9_U32_Eq(const_cast<algo::LnumStr9_U32&>(*this),const_cast<algo::LnumStr9_U32&>(rhs));
}

inline bool algo::LnumStr9_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr9_U32_EqStrptr(const_cast<algo::LnumStr9_U32&>(*this),rhs);
}
inline algo::LnumStr9_U32::LnumStr9_U32() {
    algo::LnumStr9_U32_Init(*this);
}


// --- algo.LnumStr9_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr9_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 9 - len;
    return ret;
}

// --- algo.LnumStr9_U32.ch.HashStrptr
inline u32 algo::LnumStr9_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr9_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr9_U32 &parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U32.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::LnumStr9_U32& parent) {
    (void)parent;
    return 9;
}

// --- algo.LnumStr9_U32.ch.N
inline int algo::ch_N(const algo::LnumStr9_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<9 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 9 - ret;
    return int(ret);
}

// --- algo.LnumStr9_U32.ch.Cast
inline algo::LnumStr9_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr9_U32..Cmp
inline i32 algo::LnumStr9_U32_Cmp(algo::LnumStr9_U32 & lhs, algo::LnumStr9_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr9_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr9_U32_Init(algo::LnumStr9_U32& parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U32..Eq
inline bool algo::LnumStr9_U32_Eq(const algo::LnumStr9_U32 & lhs,const algo::LnumStr9_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr9_U32..EqStrptr
inline bool algo::LnumStr9_U32_EqStrptr(algo::LnumStr9_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LnumStr9_U64::operator ==(const algo::LnumStr9_U64 &rhs) const {
    return algo::LnumStr9_U64_Eq(const_cast<algo::LnumStr9_U64&>(*this),const_cast<algo::LnumStr9_U64&>(rhs));
}

inline bool algo::LnumStr9_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LnumStr9_U64_EqStrptr(const_cast<algo::LnumStr9_U64&>(*this),rhs);
}
inline algo::LnumStr9_U64::LnumStr9_U64() {
    algo::LnumStr9_U64_Init(*this);
}


// --- algo.LnumStr9_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr9_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 9 - len;
    return ret;
}

// --- algo.LnumStr9_U64.ch.HashStrptr
inline u32 algo::LnumStr9_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr9_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr9_U64 &parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U64.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::LnumStr9_U64& parent) {
    (void)parent;
    return 9;
}

// --- algo.LnumStr9_U64.ch.N
inline int algo::ch_N(const algo::LnumStr9_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<9 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 9 - ret;
    return int(ret);
}

// --- algo.LnumStr9_U64.ch.Cast
inline algo::LnumStr9_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LnumStr9_U64..Cmp
inline i32 algo::LnumStr9_U64_Cmp(algo::LnumStr9_U64 & lhs, algo::LnumStr9_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr9_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr9_U64_Init(algo::LnumStr9_U64& parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U64..Eq
inline bool algo::LnumStr9_U64_Eq(const algo::LnumStr9_U64 & lhs,const algo::LnumStr9_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr9_U64..EqStrptr
inline bool algo::LnumStr9_U64_EqStrptr(algo::LnumStr9_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::LogcatId::LogcatId(i32                            in_value)
    : value(in_value)
{
}
inline algo::LogcatId::LogcatId() {
    algo::LogcatId_Init(*this);
}


// --- algo.LogcatId.value.Cast
inline algo::LogcatId::operator i32 () const {
    return i32((*this).value);
}

// --- algo.LogcatId..Init
// Set all fields to initial values.
inline void algo::LogcatId_Init(algo::LogcatId& parent) {
    parent.value = i32(0);
}
inline algo::LogcatKey::LogcatKey(const algo::strptr&            in_value)
    : value(in_value)
{
}
inline algo::LogcatKey::LogcatKey() {
}


// --- algo.LogcatKey.value.Cast
inline algo::LogcatKey::operator algo::strptr () const {
    return algo::strptr((*this).value);
}
inline algo::SchedTime::SchedTime(u64                            in_value)
    : value(in_value)
{
}
inline algo::SchedTime::SchedTime() {
    algo::SchedTime_Init(*this);
}


// --- algo.SchedTime.value.Cast
inline algo::SchedTime::operator u64 () const {
    return u64((*this).value);
}

// --- algo.SchedTime..Lt
inline bool algo::SchedTime_Lt(algo::SchedTime lhs, algo::SchedTime rhs) {
    return u64_Lt(lhs.value, rhs.value);
}

// --- algo.SchedTime..Cmp
inline i32 algo::SchedTime_Cmp(algo::SchedTime lhs, algo::SchedTime rhs) {
    i32 retval = 0;
    retval = u64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.SchedTime..Init
// Set all fields to initial values.
inline void algo::SchedTime_Init(algo::SchedTime& parent) {
    parent.value = u64(0);
}

// --- algo.SchedTime..Eq
inline bool algo::SchedTime_Eq(algo::SchedTime lhs, algo::SchedTime rhs) {
    bool retval = true;
    retval = u64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.SchedTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::SchedTime_Update(algo::SchedTime &lhs, algo::SchedTime rhs) {
    bool ret = !SchedTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline bool algo::Smallstr200::operator ==(const algo::Smallstr200 &rhs) const {
    return algo::Smallstr200_Eq(const_cast<algo::Smallstr200&>(*this),const_cast<algo::Smallstr200&>(rhs));
}

inline bool algo::Smallstr200::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr200_EqStrptr(const_cast<algo::Smallstr200&>(*this),rhs);
}
inline algo::Smallstr200::Smallstr200() {
    algo::Smallstr200_Init(*this);
}


// --- algo.Smallstr200.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr200& parent, char c) {
    if (parent.n_ch < 200) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr200.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr200& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 200) {
        n_new = 200 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr200.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr200& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr200.ch.HashStrptr
inline u32 algo::Smallstr200_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr200.ch.Init
inline void algo::ch_Init(algo::Smallstr200 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr200.ch.Max
// always return constant 200
inline int algo::ch_Max(algo::Smallstr200& parent) {
    (void)parent;
    return 200;
}

// --- algo.Smallstr200.ch.N
inline int algo::ch_N(const algo::Smallstr200& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr200.ch.Cast
inline algo::Smallstr200::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr200..Cmp
inline i32 algo::Smallstr200_Cmp(algo::Smallstr200 & lhs, algo::Smallstr200 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr200..Init
// Set all fields to initial values.
inline void algo::Smallstr200_Init(algo::Smallstr200& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr200..Eq
inline bool algo::Smallstr200_Eq(const algo::Smallstr200 & lhs,const algo::Smallstr200 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr200..EqStrptr
inline bool algo::Smallstr200_EqStrptr(algo::Smallstr200 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::Logmsg::Logmsg() {
    algo::Logmsg_Init(*this);
}


// --- algo.Logmsg..Init
// Set all fields to initial values.
inline void algo::Logmsg_Init(algo::Logmsg& parent) {
    parent.logmsg = u64(0);
    parent.err = bool(false);
    parent.part = bool(false);
}

inline bool algo::LspaceStr10::operator ==(const algo::LspaceStr10 &rhs) const {
    return algo::LspaceStr10_Eq(const_cast<algo::LspaceStr10&>(*this),const_cast<algo::LspaceStr10&>(rhs));
}

inline bool algo::LspaceStr10::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr10_EqStrptr(const_cast<algo::LspaceStr10&>(*this),rhs);
}
inline algo::LspaceStr10::LspaceStr10() {
    algo::LspaceStr10_Init(*this);
}


// --- algo.LspaceStr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 10 - len;
    return ret;
}

// --- algo.LspaceStr10.ch.HashStrptr
inline u32 algo::LspaceStr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr10.ch.Init
inline void algo::ch_Init(algo::LspaceStr10 &parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.LspaceStr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::LspaceStr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.LspaceStr10.ch.N
inline int algo::ch_N(const algo::LspaceStr10& parent) {
    u64 ret;
    ret = 0;
    while (ret<10 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 10 - ret;
    return int(ret);
}

// --- algo.LspaceStr10.ch.Cast
inline algo::LspaceStr10::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr10..Cmp
inline i32 algo::LspaceStr10_Cmp(algo::LspaceStr10 & lhs, algo::LspaceStr10 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr10..Init
// Set all fields to initial values.
inline void algo::LspaceStr10_Init(algo::LspaceStr10& parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.LspaceStr10..Eq
inline bool algo::LspaceStr10_Eq(const algo::LspaceStr10 & lhs,const algo::LspaceStr10 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr10..EqStrptr
inline bool algo::LspaceStr10_EqStrptr(algo::LspaceStr10 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr12::operator ==(const algo::LspaceStr12 &rhs) const {
    return algo::LspaceStr12_Eq(const_cast<algo::LspaceStr12&>(*this),const_cast<algo::LspaceStr12&>(rhs));
}

inline bool algo::LspaceStr12::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr12_EqStrptr(const_cast<algo::LspaceStr12&>(*this),rhs);
}
inline algo::LspaceStr12::LspaceStr12() {
    algo::LspaceStr12_Init(*this);
}


// --- algo.LspaceStr12.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr12& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 12 - len;
    return ret;
}

// --- algo.LspaceStr12.ch.HashStrptr
inline u32 algo::LspaceStr12_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr12.ch.Init
inline void algo::ch_Init(algo::LspaceStr12 &parent) {
    memset(parent.ch, ' ', 12);
}

// --- algo.LspaceStr12.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::LspaceStr12& parent) {
    (void)parent;
    return 12;
}

// --- algo.LspaceStr12.ch.N
inline int algo::ch_N(const algo::LspaceStr12& parent) {
    u64 ret;
    ret = 0;
    while (ret<12 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 12 - ret;
    return int(ret);
}

// --- algo.LspaceStr12.ch.Cast
inline algo::LspaceStr12::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr12..Cmp
inline i32 algo::LspaceStr12_Cmp(algo::LspaceStr12 & lhs, algo::LspaceStr12 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr12..Init
// Set all fields to initial values.
inline void algo::LspaceStr12_Init(algo::LspaceStr12& parent) {
    memset(parent.ch, ' ', 12);
}

// --- algo.LspaceStr12..Eq
inline bool algo::LspaceStr12_Eq(const algo::LspaceStr12 & lhs,const algo::LspaceStr12 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr12..EqStrptr
inline bool algo::LspaceStr12_EqStrptr(algo::LspaceStr12 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr14::operator ==(const algo::LspaceStr14 &rhs) const {
    return algo::LspaceStr14_Eq(const_cast<algo::LspaceStr14&>(*this),const_cast<algo::LspaceStr14&>(rhs));
}

inline bool algo::LspaceStr14::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr14_EqStrptr(const_cast<algo::LspaceStr14&>(*this),rhs);
}
inline algo::LspaceStr14::LspaceStr14() {
    algo::LspaceStr14_Init(*this);
}


// --- algo.LspaceStr14.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr14& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 14 - len;
    return ret;
}

// --- algo.LspaceStr14.ch.HashStrptr
inline u32 algo::LspaceStr14_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr14.ch.Init
inline void algo::ch_Init(algo::LspaceStr14 &parent) {
    memset(parent.ch, ' ', 14);
}

// --- algo.LspaceStr14.ch.Max
// always return constant 14
inline int algo::ch_Max(algo::LspaceStr14& parent) {
    (void)parent;
    return 14;
}

// --- algo.LspaceStr14.ch.N
inline int algo::ch_N(const algo::LspaceStr14& parent) {
    u64 ret;
    ret = 0;
    while (ret<14 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 14 - ret;
    return int(ret);
}

// --- algo.LspaceStr14.ch.Cast
inline algo::LspaceStr14::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr14..Cmp
inline i32 algo::LspaceStr14_Cmp(algo::LspaceStr14 & lhs, algo::LspaceStr14 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr14..Init
// Set all fields to initial values.
inline void algo::LspaceStr14_Init(algo::LspaceStr14& parent) {
    memset(parent.ch, ' ', 14);
}

// --- algo.LspaceStr14..Eq
inline bool algo::LspaceStr14_Eq(const algo::LspaceStr14 & lhs,const algo::LspaceStr14 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr14..EqStrptr
inline bool algo::LspaceStr14_EqStrptr(algo::LspaceStr14 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr15::operator ==(const algo::LspaceStr15 &rhs) const {
    return algo::LspaceStr15_Eq(const_cast<algo::LspaceStr15&>(*this),const_cast<algo::LspaceStr15&>(rhs));
}

inline bool algo::LspaceStr15::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr15_EqStrptr(const_cast<algo::LspaceStr15&>(*this),rhs);
}
inline algo::LspaceStr15::LspaceStr15() {
    algo::LspaceStr15_Init(*this);
}


// --- algo.LspaceStr15.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr15& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 15 - len;
    return ret;
}

// --- algo.LspaceStr15.ch.HashStrptr
inline u32 algo::LspaceStr15_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr15.ch.Init
inline void algo::ch_Init(algo::LspaceStr15 &parent) {
    memset(parent.ch, ' ', 15);
}

// --- algo.LspaceStr15.ch.Max
// always return constant 15
inline int algo::ch_Max(algo::LspaceStr15& parent) {
    (void)parent;
    return 15;
}

// --- algo.LspaceStr15.ch.N
inline int algo::ch_N(const algo::LspaceStr15& parent) {
    u64 ret;
    ret = 0;
    while (ret<15 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 15 - ret;
    return int(ret);
}

// --- algo.LspaceStr15.ch.Cast
inline algo::LspaceStr15::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr15..Cmp
inline i32 algo::LspaceStr15_Cmp(algo::LspaceStr15 & lhs, algo::LspaceStr15 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr15..Init
// Set all fields to initial values.
inline void algo::LspaceStr15_Init(algo::LspaceStr15& parent) {
    memset(parent.ch, ' ', 15);
}

// --- algo.LspaceStr15..Eq
inline bool algo::LspaceStr15_Eq(const algo::LspaceStr15 & lhs,const algo::LspaceStr15 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr15..EqStrptr
inline bool algo::LspaceStr15_EqStrptr(algo::LspaceStr15 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr20_I64::operator ==(const algo::LspaceStr20_I64 &rhs) const {
    return algo::LspaceStr20_I64_Eq(const_cast<algo::LspaceStr20_I64&>(*this),const_cast<algo::LspaceStr20_I64&>(rhs));
}

inline bool algo::LspaceStr20_I64::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr20_I64_EqStrptr(const_cast<algo::LspaceStr20_I64&>(*this),rhs);
}
inline algo::LspaceStr20_I64::LspaceStr20_I64() {
    algo::LspaceStr20_I64_Init(*this);
}


// --- algo.LspaceStr20_I64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr20_I64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 20 - len;
    return ret;
}

// --- algo.LspaceStr20_I64.ch.HashStrptr
inline u32 algo::LspaceStr20_I64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr20_I64.ch.Init
inline void algo::ch_Init(algo::LspaceStr20_I64 &parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_I64.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::LspaceStr20_I64& parent) {
    (void)parent;
    return 20;
}

// --- algo.LspaceStr20_I64.ch.N
inline int algo::ch_N(const algo::LspaceStr20_I64& parent) {
    u64 ret;
    ret = 0;
    while (ret<20 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 20 - ret;
    return int(ret);
}

// --- algo.LspaceStr20_I64.ch.Cast
inline algo::LspaceStr20_I64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr20_I64..Cmp
inline i32 algo::LspaceStr20_I64_Cmp(algo::LspaceStr20_I64 & lhs, algo::LspaceStr20_I64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr20_I64..Init
// Set all fields to initial values.
inline void algo::LspaceStr20_I64_Init(algo::LspaceStr20_I64& parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_I64..Eq
inline bool algo::LspaceStr20_I64_Eq(const algo::LspaceStr20_I64 & lhs,const algo::LspaceStr20_I64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr20_I64..EqStrptr
inline bool algo::LspaceStr20_I64_EqStrptr(algo::LspaceStr20_I64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr20_U64::operator ==(const algo::LspaceStr20_U64 &rhs) const {
    return algo::LspaceStr20_U64_Eq(const_cast<algo::LspaceStr20_U64&>(*this),const_cast<algo::LspaceStr20_U64&>(rhs));
}

inline bool algo::LspaceStr20_U64::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr20_U64_EqStrptr(const_cast<algo::LspaceStr20_U64&>(*this),rhs);
}
inline algo::LspaceStr20_U64::LspaceStr20_U64() {
    algo::LspaceStr20_U64_Init(*this);
}


// --- algo.LspaceStr20_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr20_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 20 - len;
    return ret;
}

// --- algo.LspaceStr20_U64.ch.HashStrptr
inline u32 algo::LspaceStr20_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr20_U64.ch.Init
inline void algo::ch_Init(algo::LspaceStr20_U64 &parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_U64.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::LspaceStr20_U64& parent) {
    (void)parent;
    return 20;
}

// --- algo.LspaceStr20_U64.ch.N
inline int algo::ch_N(const algo::LspaceStr20_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<20 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 20 - ret;
    return int(ret);
}

// --- algo.LspaceStr20_U64.ch.Cast
inline algo::LspaceStr20_U64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr20_U64..Cmp
inline i32 algo::LspaceStr20_U64_Cmp(algo::LspaceStr20_U64 & lhs, algo::LspaceStr20_U64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr20_U64..Init
// Set all fields to initial values.
inline void algo::LspaceStr20_U64_Init(algo::LspaceStr20_U64& parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_U64..Eq
inline bool algo::LspaceStr20_U64_Eq(const algo::LspaceStr20_U64 & lhs,const algo::LspaceStr20_U64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr20_U64..EqStrptr
inline bool algo::LspaceStr20_U64_EqStrptr(algo::LspaceStr20_U64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr3::operator ==(const algo::LspaceStr3 &rhs) const {
    return algo::LspaceStr3_Eq(const_cast<algo::LspaceStr3&>(*this),const_cast<algo::LspaceStr3&>(rhs));
}

inline bool algo::LspaceStr3::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr3_EqStrptr(const_cast<algo::LspaceStr3&>(*this),rhs);
}
inline algo::LspaceStr3::LspaceStr3() {
    algo::LspaceStr3_Init(*this);
}


// --- algo.LspaceStr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 3 - len;
    return ret;
}

// --- algo.LspaceStr3.ch.HashStrptr
inline u32 algo::LspaceStr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr3.ch.Init
inline void algo::ch_Init(algo::LspaceStr3 &parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::LspaceStr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.LspaceStr3.ch.N
inline int algo::ch_N(const algo::LspaceStr3& parent) {
    u64 ret;
    ret = 0;
    while (ret<3 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 3 - ret;
    return int(ret);
}

// --- algo.LspaceStr3.ch.Cast
inline algo::LspaceStr3::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr3..Cmp
inline i32 algo::LspaceStr3_Cmp(algo::LspaceStr3 & lhs, algo::LspaceStr3 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr3..Init
// Set all fields to initial values.
inline void algo::LspaceStr3_Init(algo::LspaceStr3& parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3..Eq
inline bool algo::LspaceStr3_Eq(const algo::LspaceStr3 & lhs,const algo::LspaceStr3 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr3..EqStrptr
inline bool algo::LspaceStr3_EqStrptr(algo::LspaceStr3 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr3_I16::operator ==(const algo::LspaceStr3_I16 &rhs) const {
    return algo::LspaceStr3_I16_Eq(const_cast<algo::LspaceStr3_I16&>(*this),const_cast<algo::LspaceStr3_I16&>(rhs));
}

inline bool algo::LspaceStr3_I16::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr3_I16_EqStrptr(const_cast<algo::LspaceStr3_I16&>(*this),rhs);
}
inline algo::LspaceStr3_I16::LspaceStr3_I16() {
    algo::LspaceStr3_I16_Init(*this);
}


// --- algo.LspaceStr3_I16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr3_I16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 3 - len;
    return ret;
}

// --- algo.LspaceStr3_I16.ch.HashStrptr
inline u32 algo::LspaceStr3_I16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr3_I16.ch.Init
inline void algo::ch_Init(algo::LspaceStr3_I16 &parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3_I16.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::LspaceStr3_I16& parent) {
    (void)parent;
    return 3;
}

// --- algo.LspaceStr3_I16.ch.N
inline int algo::ch_N(const algo::LspaceStr3_I16& parent) {
    u64 ret;
    ret = 0;
    while (ret<3 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 3 - ret;
    return int(ret);
}

// --- algo.LspaceStr3_I16.ch.Cast
inline algo::LspaceStr3_I16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr3_I16..Cmp
inline i32 algo::LspaceStr3_I16_Cmp(algo::LspaceStr3_I16 & lhs, algo::LspaceStr3_I16 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr3_I16..Init
// Set all fields to initial values.
inline void algo::LspaceStr3_I16_Init(algo::LspaceStr3_I16& parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3_I16..Eq
inline bool algo::LspaceStr3_I16_Eq(const algo::LspaceStr3_I16 & lhs,const algo::LspaceStr3_I16 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr3_I16..EqStrptr
inline bool algo::LspaceStr3_I16_EqStrptr(algo::LspaceStr3_I16 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr4::operator ==(const algo::LspaceStr4 &rhs) const {
    return algo::LspaceStr4_Eq(const_cast<algo::LspaceStr4&>(*this),const_cast<algo::LspaceStr4&>(rhs));
}

inline bool algo::LspaceStr4::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr4_EqStrptr(const_cast<algo::LspaceStr4&>(*this),rhs);
}
inline algo::LspaceStr4::LspaceStr4() {
    algo::LspaceStr4_Init(*this);
}


// --- algo.LspaceStr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 4 - len;
    return ret;
}

// --- algo.LspaceStr4.ch.HashStrptr
inline u32 algo::LspaceStr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr4.ch.Init
inline void algo::ch_Init(algo::LspaceStr4 &parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.LspaceStr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::LspaceStr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.LspaceStr4.ch.N
inline int algo::ch_N(const algo::LspaceStr4& parent) {
    u64 ret;
    ret = 0;
    while (ret<4 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 4 - ret;
    return int(ret);
}

// --- algo.LspaceStr4.ch.Cast
inline algo::LspaceStr4::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr4..Cmp
inline i32 algo::LspaceStr4_Cmp(algo::LspaceStr4 & lhs, algo::LspaceStr4 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr4..Init
// Set all fields to initial values.
inline void algo::LspaceStr4_Init(algo::LspaceStr4& parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.LspaceStr4..Eq
inline bool algo::LspaceStr4_Eq(const algo::LspaceStr4 & lhs,const algo::LspaceStr4 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr4..EqStrptr
inline bool algo::LspaceStr4_EqStrptr(algo::LspaceStr4 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr5::operator ==(const algo::LspaceStr5 &rhs) const {
    return algo::LspaceStr5_Eq(const_cast<algo::LspaceStr5&>(*this),const_cast<algo::LspaceStr5&>(rhs));
}

inline bool algo::LspaceStr5::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr5_EqStrptr(const_cast<algo::LspaceStr5&>(*this),rhs);
}
inline algo::LspaceStr5::LspaceStr5() {
    algo::LspaceStr5_Init(*this);
}


// --- algo.LspaceStr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LspaceStr5.ch.HashStrptr
inline u32 algo::LspaceStr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr5.ch.Init
inline void algo::ch_Init(algo::LspaceStr5 &parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LspaceStr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.LspaceStr5.ch.N
inline int algo::ch_N(const algo::LspaceStr5& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LspaceStr5.ch.Cast
inline algo::LspaceStr5::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr5..Cmp
inline i32 algo::LspaceStr5_Cmp(algo::LspaceStr5 & lhs, algo::LspaceStr5 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr5..Init
// Set all fields to initial values.
inline void algo::LspaceStr5_Init(algo::LspaceStr5& parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5..Eq
inline bool algo::LspaceStr5_Eq(const algo::LspaceStr5 & lhs,const algo::LspaceStr5 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr5..EqStrptr
inline bool algo::LspaceStr5_EqStrptr(algo::LspaceStr5 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr5_I16::operator ==(const algo::LspaceStr5_I16 &rhs) const {
    return algo::LspaceStr5_I16_Eq(const_cast<algo::LspaceStr5_I16&>(*this),const_cast<algo::LspaceStr5_I16&>(rhs));
}

inline bool algo::LspaceStr5_I16::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr5_I16_EqStrptr(const_cast<algo::LspaceStr5_I16&>(*this),rhs);
}
inline algo::LspaceStr5_I16::LspaceStr5_I16() {
    algo::LspaceStr5_I16_Init(*this);
}


// --- algo.LspaceStr5_I16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr5_I16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LspaceStr5_I16.ch.HashStrptr
inline u32 algo::LspaceStr5_I16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr5_I16.ch.Init
inline void algo::ch_Init(algo::LspaceStr5_I16 &parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5_I16.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LspaceStr5_I16& parent) {
    (void)parent;
    return 5;
}

// --- algo.LspaceStr5_I16.ch.N
inline int algo::ch_N(const algo::LspaceStr5_I16& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LspaceStr5_I16.ch.Cast
inline algo::LspaceStr5_I16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr5_I16..Cmp
inline i32 algo::LspaceStr5_I16_Cmp(algo::LspaceStr5_I16 & lhs, algo::LspaceStr5_I16 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr5_I16..Init
// Set all fields to initial values.
inline void algo::LspaceStr5_I16_Init(algo::LspaceStr5_I16& parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5_I16..Eq
inline bool algo::LspaceStr5_I16_Eq(const algo::LspaceStr5_I16 & lhs,const algo::LspaceStr5_I16 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr5_I16..EqStrptr
inline bool algo::LspaceStr5_I16_EqStrptr(algo::LspaceStr5_I16 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr6::operator ==(const algo::LspaceStr6 &rhs) const {
    return algo::LspaceStr6_Eq(const_cast<algo::LspaceStr6&>(*this),const_cast<algo::LspaceStr6&>(rhs));
}

inline bool algo::LspaceStr6::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr6_EqStrptr(const_cast<algo::LspaceStr6&>(*this),rhs);
}
inline algo::LspaceStr6::LspaceStr6() {
    algo::LspaceStr6_Init(*this);
}


// --- algo.LspaceStr6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 6 - len;
    return ret;
}

// --- algo.LspaceStr6.ch.HashStrptr
inline u32 algo::LspaceStr6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr6.ch.Init
inline void algo::ch_Init(algo::LspaceStr6 &parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::LspaceStr6& parent) {
    (void)parent;
    return 6;
}

// --- algo.LspaceStr6.ch.N
inline int algo::ch_N(const algo::LspaceStr6& parent) {
    u64 ret;
    ret = 0;
    while (ret<6 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 6 - ret;
    return int(ret);
}

// --- algo.LspaceStr6.ch.Cast
inline algo::LspaceStr6::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr6..Cmp
inline i32 algo::LspaceStr6_Cmp(algo::LspaceStr6 & lhs, algo::LspaceStr6 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr6..Init
// Set all fields to initial values.
inline void algo::LspaceStr6_Init(algo::LspaceStr6& parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6..Eq
inline bool algo::LspaceStr6_Eq(const algo::LspaceStr6 & lhs,const algo::LspaceStr6 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr6..EqStrptr
inline bool algo::LspaceStr6_EqStrptr(algo::LspaceStr6 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr6_U32::operator ==(const algo::LspaceStr6_U32 &rhs) const {
    return algo::LspaceStr6_U32_Eq(const_cast<algo::LspaceStr6_U32&>(*this),const_cast<algo::LspaceStr6_U32&>(rhs));
}

inline bool algo::LspaceStr6_U32::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr6_U32_EqStrptr(const_cast<algo::LspaceStr6_U32&>(*this),rhs);
}
inline algo::LspaceStr6_U32::LspaceStr6_U32() {
    algo::LspaceStr6_U32_Init(*this);
}


// --- algo.LspaceStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 6 - len;
    return ret;
}

// --- algo.LspaceStr6_U32.ch.HashStrptr
inline u32 algo::LspaceStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr6_U32.ch.Init
inline void algo::ch_Init(algo::LspaceStr6_U32 &parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6_U32.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::LspaceStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- algo.LspaceStr6_U32.ch.N
inline int algo::ch_N(const algo::LspaceStr6_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<6 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 6 - ret;
    return int(ret);
}

// --- algo.LspaceStr6_U32.ch.Cast
inline algo::LspaceStr6_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr6_U32..Cmp
inline i32 algo::LspaceStr6_U32_Cmp(algo::LspaceStr6_U32 & lhs, algo::LspaceStr6_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr6_U32..Init
// Set all fields to initial values.
inline void algo::LspaceStr6_U32_Init(algo::LspaceStr6_U32& parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6_U32..Eq
inline bool algo::LspaceStr6_U32_Eq(const algo::LspaceStr6_U32 & lhs,const algo::LspaceStr6_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr6_U32..EqStrptr
inline bool algo::LspaceStr6_U32_EqStrptr(algo::LspaceStr6_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr7_I32_Base36::operator ==(const algo::LspaceStr7_I32_Base36 &rhs) const {
    return algo::LspaceStr7_I32_Base36_Eq(const_cast<algo::LspaceStr7_I32_Base36&>(*this),const_cast<algo::LspaceStr7_I32_Base36&>(rhs));
}

inline bool algo::LspaceStr7_I32_Base36::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr7_I32_Base36_EqStrptr(const_cast<algo::LspaceStr7_I32_Base36&>(*this),rhs);
}
inline algo::LspaceStr7_I32_Base36::LspaceStr7_I32_Base36() {
    algo::LspaceStr7_I32_Base36_Init(*this);
}


// --- algo.LspaceStr7_I32_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr7_I32_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 7 - len;
    return ret;
}

// --- algo.LspaceStr7_I32_Base36.ch.HashStrptr
inline u32 algo::LspaceStr7_I32_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr7_I32_Base36.ch.Init
inline void algo::ch_Init(algo::LspaceStr7_I32_Base36 &parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.LspaceStr7_I32_Base36.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::LspaceStr7_I32_Base36& parent) {
    (void)parent;
    return 7;
}

// --- algo.LspaceStr7_I32_Base36.ch.N
inline int algo::ch_N(const algo::LspaceStr7_I32_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<7 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 7 - ret;
    return int(ret);
}

// --- algo.LspaceStr7_I32_Base36.ch.Cast
inline algo::LspaceStr7_I32_Base36::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr7_I32_Base36..Cmp
inline i32 algo::LspaceStr7_I32_Base36_Cmp(algo::LspaceStr7_I32_Base36 & lhs, algo::LspaceStr7_I32_Base36 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..Init
// Set all fields to initial values.
inline void algo::LspaceStr7_I32_Base36_Init(algo::LspaceStr7_I32_Base36& parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.LspaceStr7_I32_Base36..Eq
inline bool algo::LspaceStr7_I32_Base36_Eq(const algo::LspaceStr7_I32_Base36 & lhs,const algo::LspaceStr7_I32_Base36 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..EqStrptr
inline bool algo::LspaceStr7_I32_Base36_EqStrptr(algo::LspaceStr7_I32_Base36 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr8::operator ==(const algo::LspaceStr8 &rhs) const {
    return algo::LspaceStr8_Eq(const_cast<algo::LspaceStr8&>(*this),const_cast<algo::LspaceStr8&>(rhs));
}

inline bool algo::LspaceStr8::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr8_EqStrptr(const_cast<algo::LspaceStr8&>(*this),rhs);
}
inline algo::LspaceStr8::LspaceStr8() {
    algo::LspaceStr8_Init(*this);
}


// --- algo.LspaceStr8.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr8& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LspaceStr8.ch.HashStrptr
inline u32 algo::LspaceStr8_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr8.ch.Init
inline void algo::ch_Init(algo::LspaceStr8 &parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.LspaceStr8.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LspaceStr8& parent) {
    (void)parent;
    return 8;
}

// --- algo.LspaceStr8.ch.N
inline int algo::ch_N(const algo::LspaceStr8& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LspaceStr8.ch.Cast
inline algo::LspaceStr8::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr8..Cmp
inline i32 algo::LspaceStr8_Cmp(algo::LspaceStr8 & lhs, algo::LspaceStr8 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr8..Init
// Set all fields to initial values.
inline void algo::LspaceStr8_Init(algo::LspaceStr8& parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.LspaceStr8..Eq
inline bool algo::LspaceStr8_Eq(const algo::LspaceStr8 & lhs,const algo::LspaceStr8 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr8..EqStrptr
inline bool algo::LspaceStr8_EqStrptr(algo::LspaceStr8 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::LspaceStr9::operator ==(const algo::LspaceStr9 &rhs) const {
    return algo::LspaceStr9_Eq(const_cast<algo::LspaceStr9&>(*this),const_cast<algo::LspaceStr9&>(rhs));
}

inline bool algo::LspaceStr9::operator ==(const algo::strptr &rhs) const {
    return algo::LspaceStr9_EqStrptr(const_cast<algo::LspaceStr9&>(*this),rhs);
}
inline algo::LspaceStr9::LspaceStr9() {
    algo::LspaceStr9_Init(*this);
}


// --- algo.LspaceStr9.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr9& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 9 - len;
    return ret;
}

// --- algo.LspaceStr9.ch.HashStrptr
inline u32 algo::LspaceStr9_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr9.ch.Init
inline void algo::ch_Init(algo::LspaceStr9 &parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.LspaceStr9.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::LspaceStr9& parent) {
    (void)parent;
    return 9;
}

// --- algo.LspaceStr9.ch.N
inline int algo::ch_N(const algo::LspaceStr9& parent) {
    u64 ret;
    ret = 0;
    while (ret<9 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 9 - ret;
    return int(ret);
}

// --- algo.LspaceStr9.ch.Cast
inline algo::LspaceStr9::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr9..Cmp
inline i32 algo::LspaceStr9_Cmp(algo::LspaceStr9 & lhs, algo::LspaceStr9 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr9..Init
// Set all fields to initial values.
inline void algo::LspaceStr9_Init(algo::LspaceStr9& parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.LspaceStr9..Eq
inline bool algo::LspaceStr9_Eq(const algo::LspaceStr9 & lhs,const algo::LspaceStr9 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr9..EqStrptr
inline bool algo::LspaceStr9_EqStrptr(algo::LspaceStr9 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::Md5Digest::Md5Digest(algo::aryptr<u8 >              in_value)
{
    value_Setary(*this, in_value);
}
inline algo::Md5Digest::Md5Digest() {
    algo::Md5Digest_Init(*this);
}


// --- algo.Md5Digest.value.Fill
// Set all elements of fixed array to value RHS
inline void algo::value_Fill(algo::Md5Digest& parent, const u8 &rhs) {
    for (int i = 0; i < 16; i++) {
        parent.value_elems[i] = rhs;
    }
}

// --- algo.Md5Digest.value.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::value_Find(algo::Md5Digest& parent, u64 t) {
    u64 idx = t;
    u64 lim = 16;
    return idx < lim ? parent.value_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Md5Digest.value.Getary
// Access fixed array value as aryptr.
inline algo::aryptr<u8> algo::value_Getary(algo::Md5Digest& parent) {
    return algo::aryptr<u8>(parent.value_elems, 16);
}

// --- algo.Md5Digest.value.Max
// Return max number of items in the array
inline i32 algo::value_Max(algo::Md5Digest& parent) {
    (void)parent;
    return 16;
}

// --- algo.Md5Digest.value.N
// Return number of items in the array
inline i32 algo::value_N(const algo::Md5Digest& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 16;
}

// --- algo.Md5Digest.value.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::value_Setary(algo::Md5Digest& parent, const algo::aryptr<u8> &rhs) {
    int n = 16 < rhs.n_elems ? 16 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.value_elems[i] = rhs[i];
    }
}

// --- algo.Md5Digest.value.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u8& algo::value_qFind(algo::Md5Digest& parent, u64 t) {
    return parent.value_elems[t];
}

// --- algo.Md5Digest.value_curs.Reset
// cursor points to valid item
inline void algo::Md5Digest_value_curs_Reset(Md5Digest_value_curs &curs, algo::Md5Digest &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Md5Digest.value_curs.ValidQ
// cursor points to valid item
inline bool algo::Md5Digest_value_curs_ValidQ(Md5Digest_value_curs &curs) {
    return u64(curs.index) < u64(16);
}

// --- algo.Md5Digest.value_curs.Next
// proceed to next item
inline void algo::Md5Digest_value_curs_Next(Md5Digest_value_curs &curs) {
    curs.index++;
}

// --- algo.Md5Digest.value_curs.Access
// item access
inline u8& algo::Md5Digest_value_curs_Access(Md5Digest_value_curs &curs) {
    return value_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Md5Digest..Init
// Set all fields to initial values.
inline void algo::Md5Digest_Init(algo::Md5Digest& parent) {
    for (int i = 0; i < 16; i++) {
        parent.value_elems[i] = 0;
    }
}
inline algo::Month::Month(u32                            in_value)
    : value(in_value)
{
}
inline algo::Month::Month(algo_MonthEnum arg) { this->value = u32(arg); }
inline algo::Month::Month() {
    algo::Month_Init(*this);
}


// --- algo.Month.value.GetEnum
// Get value of field as enum type
inline algo_MonthEnum algo::value_GetEnum(const algo::Month& parent) {
    return algo_MonthEnum(parent.value);
}

// --- algo.Month.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::Month& parent, algo_MonthEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.Month.value.Cast
inline algo::Month::operator algo_MonthEnum () const {
    return algo_MonthEnum((*this).value);
}

// --- algo.Month..Init
// Set all fields to initial values.
inline void algo::Month_Init(algo::Month& parent) {
    parent.value = u32(0);
}
inline algo::NormTxttbl::NormTxttbl() {
    algo::NormTxttbl_Init(*this);
}

inline algo::NormTxttbl::~NormTxttbl() {
    algo::NormTxttbl_Uninit(*this);
}


// --- algo.NormTxttbl.start.EmptyQ
// Return true if index is empty
inline bool algo::start_EmptyQ(algo::NormTxttbl& parent) {
    return parent.start_n == 0;
}

// --- algo.NormTxttbl.start.Find
// Look up row by row id. Return NULL if out of range
inline i32* algo::start_Find(algo::NormTxttbl& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.start_n;
    if (idx >= lim) return NULL;
    return parent.start_elems + idx;
}

// --- algo.NormTxttbl.start.Getary
// Return array pointer by value
inline algo::aryptr<i32> algo::start_Getary(algo::NormTxttbl& parent) {
    return algo::aryptr<i32>(parent.start_elems, parent.start_n);
}

// --- algo.NormTxttbl.start.Last
// Return pointer to last element of array, or NULL if array is empty
inline i32* algo::start_Last(algo::NormTxttbl& parent) {
    return start_Find(parent, u64(parent.start_n-1));
}

// --- algo.NormTxttbl.start.Max
// Return max. number of items in the array
inline i32 algo::start_Max(algo::NormTxttbl& parent) {
    (void)parent;
    return parent.start_max;
}

// --- algo.NormTxttbl.start.N
// Return number of items in the array
inline i32 algo::start_N(const algo::NormTxttbl& parent) {
    return parent.start_n;
}

// --- algo.NormTxttbl.start.RemoveAll
inline void algo::start_RemoveAll(algo::NormTxttbl& parent) {
    parent.start_n = 0;
}

// --- algo.NormTxttbl.start.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::start_Reserve(algo::NormTxttbl& parent, int n) {
    u32 new_n = parent.start_n + n;
    if (UNLIKELY(new_n > parent.start_max)) {
        start_AbsReserve(parent, new_n);
    }
}

// --- algo.NormTxttbl.start.qFind
// 'quick' Access row by row id. No bounds checking.
inline i32& algo::start_qFind(algo::NormTxttbl& parent, u64 t) {
    return parent.start_elems[t];
}

// --- algo.NormTxttbl.start.qLast
// Return reference to last element of array. No bounds checking
inline i32& algo::start_qLast(algo::NormTxttbl& parent) {
    return start_qFind(parent, u64(parent.start_n-1));
}

// --- algo.NormTxttbl.start.rowid_Get
// Return row id of specified element
inline u64 algo::start_rowid_Get(algo::NormTxttbl& parent, i32 &elem) {
    u64 id = &elem - parent.start_elems;
    return u64(id);
}

// --- algo.NormTxttbl.start_curs.Next
// proceed to next item
inline void algo::NormTxttbl_start_curs_Next(NormTxttbl_start_curs &curs) {
    curs.index++;
}

// --- algo.NormTxttbl.start_curs.Reset
inline void algo::NormTxttbl_start_curs_Reset(NormTxttbl_start_curs &curs, algo::NormTxttbl &parent) {
    curs.elems = parent.start_elems;
    curs.n_elems = parent.start_n;
    curs.index = 0;
}

// --- algo.NormTxttbl.start_curs.ValidQ
// cursor points to valid item
inline bool algo::NormTxttbl_start_curs_ValidQ(NormTxttbl_start_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.NormTxttbl.start_curs.Access
// item access
inline i32& algo::NormTxttbl_start_curs_Access(NormTxttbl_start_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.NormTxttbl..Init
// Set all fields to initial values.
inline void algo::NormTxttbl_Init(algo::NormTxttbl& parent) {
    parent.start_elems 	= 0; // (algo.NormTxttbl.start)
    parent.start_n     	= 0; // (algo.NormTxttbl.start)
    parent.start_max   	= 0; // (algo.NormTxttbl.start)
    parent.maxspan = i32(0);
}
inline algo::NumParseFlags::NumParseFlags(u32                            in_value)
    : value(in_value)
{
}
inline algo::NumParseFlags::NumParseFlags(algo_NumParseFlagsEnum arg) { this->value = u32(arg); }
inline algo::NumParseFlags::NumParseFlags() {
    algo::NumParseFlags_Init(*this);
}


// --- algo.NumParseFlags.value.GetEnum
// Get value of field as enum type
inline algo_NumParseFlagsEnum algo::value_GetEnum(const algo::NumParseFlags& parent) {
    return algo_NumParseFlagsEnum(parent.value);
}

// --- algo.NumParseFlags.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::NumParseFlags& parent, algo_NumParseFlagsEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.NumParseFlags.value.Cast
inline algo::NumParseFlags::operator algo_NumParseFlagsEnum () const {
    return algo_NumParseFlagsEnum((*this).value);
}

// --- algo.NumParseFlags.err.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool algo::err_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- algo.NumParseFlags.err.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void algo::err_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 0;
    u32 t2    = (u32(rhs) & 0x01) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.ok.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool algo::ok_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- algo.NumParseFlags.ok.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void algo::ok_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 1;
    u32 t2    = (u32(rhs) & 0x01) << 1;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.neg.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool algo::neg_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- algo.NumParseFlags.neg.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void algo::neg_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 2;
    u32 t2    = (u32(rhs) & 0x01) << 2;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.overflow.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool algo::overflow_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- algo.NumParseFlags.overflow.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void algo::overflow_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 3;
    u32 t2    = (u32(rhs) & 0x01) << 3;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.hex.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
inline bool algo::hex_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 4) & 0x01);
}

// --- algo.NumParseFlags.hex.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
inline void algo::hex_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 4;
    u32 t2    = (u32(rhs) & 0x01) << 4;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags..Init
// Set all fields to initial values.
inline void algo::NumParseFlags_Init(algo::NumParseFlags& parent) {
    parent.value = u32(0);
}
inline algo::PrintDouble::PrintDouble(double                         in_dbl
        ,i32                            in_prec)
    : dbl(in_dbl)
    , prec(in_prec)
{
}
inline algo::PrintDouble::PrintDouble() {
    algo::PrintDouble_Init(*this);
}


// --- algo.PrintDouble..Init
// Set all fields to initial values.
inline void algo::PrintDouble_Init(algo::PrintDouble& parent) {
    parent.dbl = double(0.0);
    parent.prec = i32(0);
}
inline algo::Protocol::Protocol() {
}


inline bool algo::RnullStr1::operator ==(const algo::RnullStr1 &rhs) const {
    return algo::RnullStr1_Eq(const_cast<algo::RnullStr1&>(*this),const_cast<algo::RnullStr1&>(rhs));
}

inline bool algo::RnullStr1::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr1_EqStrptr(const_cast<algo::RnullStr1&>(*this),rhs);
}

inline bool algo::RnullStr1::operator <(const algo::RnullStr1 &rhs) const {
    return algo::RnullStr1_Lt(const_cast<algo::RnullStr1&>(*this),const_cast<algo::RnullStr1&>(rhs));
}
inline algo::RnullStr1::RnullStr1() {
    algo::RnullStr1_Init(*this);
}


// --- algo.RnullStr1.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr1& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr1.ch.HashStrptr
inline u32 algo::RnullStr1_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr1.ch.Init
inline void algo::ch_Init(algo::RnullStr1 &parent) {
    memset(parent.ch, 0, 1);
}

// --- algo.RnullStr1.ch.Max
// always return constant 1
inline int algo::ch_Max(algo::RnullStr1& parent) {
    (void)parent;
    return 1;
}

// --- algo.RnullStr1.ch.N
inline int algo::ch_N(const algo::RnullStr1& parent) {
    u64 ret;
    ret = 1;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr1.ch.Cast
inline algo::RnullStr1::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr1..Lt
inline bool algo::RnullStr1_Lt(algo::RnullStr1 lhs, algo::RnullStr1 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr1..Cmp
inline i32 algo::RnullStr1_Cmp(algo::RnullStr1 lhs, algo::RnullStr1 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr1..Init
// Set all fields to initial values.
inline void algo::RnullStr1_Init(algo::RnullStr1& parent) {
    memset(parent.ch, 0, 1);
}

// --- algo.RnullStr1..Eq
inline bool algo::RnullStr1_Eq(algo::RnullStr1 lhs, algo::RnullStr1 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr1..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr1_Update(algo::RnullStr1 &lhs, algo::RnullStr1 rhs) {
    bool ret = !RnullStr1_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr1..EqStrptr
inline bool algo::RnullStr1_EqStrptr(algo::RnullStr1 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr10::operator ==(const algo::RnullStr10 &rhs) const {
    return algo::RnullStr10_Eq(const_cast<algo::RnullStr10&>(*this),const_cast<algo::RnullStr10&>(rhs));
}

inline bool algo::RnullStr10::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr10_EqStrptr(const_cast<algo::RnullStr10&>(*this),rhs);
}

inline bool algo::RnullStr10::operator <(const algo::RnullStr10 &rhs) const {
    return algo::RnullStr10_Lt(const_cast<algo::RnullStr10&>(*this),const_cast<algo::RnullStr10&>(rhs));
}
inline algo::RnullStr10::RnullStr10() {
    algo::RnullStr10_Init(*this);
}


// --- algo.RnullStr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr10.ch.HashStrptr
inline u32 algo::RnullStr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr10.ch.Init
inline void algo::ch_Init(algo::RnullStr10 &parent) {
    memset(parent.ch, 0, 10);
}

// --- algo.RnullStr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::RnullStr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.RnullStr10.ch.N
inline int algo::ch_N(const algo::RnullStr10& parent) {
    u64 ret;
    ret = 10;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr10.ch.Cast
inline algo::RnullStr10::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr10..Lt
inline bool algo::RnullStr10_Lt(algo::RnullStr10 lhs, algo::RnullStr10 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr10..Cmp
inline i32 algo::RnullStr10_Cmp(algo::RnullStr10 lhs, algo::RnullStr10 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr10..Init
// Set all fields to initial values.
inline void algo::RnullStr10_Init(algo::RnullStr10& parent) {
    memset(parent.ch, 0, 10);
}

// --- algo.RnullStr10..Eq
inline bool algo::RnullStr10_Eq(algo::RnullStr10 lhs, algo::RnullStr10 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr10..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr10_Update(algo::RnullStr10 &lhs, algo::RnullStr10 rhs) {
    bool ret = !RnullStr10_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr10..EqStrptr
inline bool algo::RnullStr10_EqStrptr(algo::RnullStr10 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr100::RnullStr100() {
    algo::RnullStr100_Init(*this);
}


// --- algo.RnullStr100.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr100& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr100.ch.HashStrptr
inline u32 algo::RnullStr100_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr100.ch.Init
inline void algo::ch_Init(algo::RnullStr100 &parent) {
    memset(parent.ch, 0, 100);
}

// --- algo.RnullStr100.ch.Max
// always return constant 100
inline int algo::ch_Max(algo::RnullStr100& parent) {
    (void)parent;
    return 100;
}

// --- algo.RnullStr100.ch.N
inline int algo::ch_N(const algo::RnullStr100& parent) {
    u64 ret;
    ret = 100;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr100.ch.Cast
inline algo::RnullStr100::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr100..Lt
inline bool algo::RnullStr100_Lt(algo::RnullStr100 & lhs, algo::RnullStr100 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr100..Cmp
inline i32 algo::RnullStr100_Cmp(algo::RnullStr100 & lhs, algo::RnullStr100 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr100..Init
// Set all fields to initial values.
inline void algo::RnullStr100_Init(algo::RnullStr100& parent) {
    memset(parent.ch, 0, 100);
}

// --- algo.RnullStr100..Eq
inline bool algo::RnullStr100_Eq(const algo::RnullStr100 & lhs,const algo::RnullStr100 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr100..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr100_Update(algo::RnullStr100 &lhs, algo::RnullStr100 & rhs) {
    bool ret = !RnullStr100_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr100..EqStrptr
inline bool algo::RnullStr100_EqStrptr(algo::RnullStr100 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr1000::operator ==(const algo::RnullStr1000 &rhs) const {
    return algo::RnullStr1000_Eq(const_cast<algo::RnullStr1000&>(*this),const_cast<algo::RnullStr1000&>(rhs));
}

inline bool algo::RnullStr1000::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr1000_EqStrptr(const_cast<algo::RnullStr1000&>(*this),rhs);
}

inline bool algo::RnullStr1000::operator <(const algo::RnullStr1000 &rhs) const {
    return algo::RnullStr1000_Lt(const_cast<algo::RnullStr1000&>(*this),const_cast<algo::RnullStr1000&>(rhs));
}
inline algo::RnullStr1000::RnullStr1000() {
    algo::RnullStr1000_Init(*this);
}


// --- algo.RnullStr1000.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr1000& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr1000.ch.HashStrptr
inline u32 algo::RnullStr1000_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr1000.ch.Init
inline void algo::ch_Init(algo::RnullStr1000 &parent) {
    memset(parent.ch, 0, 1000);
}

// --- algo.RnullStr1000.ch.Max
// always return constant 1000
inline int algo::ch_Max(algo::RnullStr1000& parent) {
    (void)parent;
    return 1000;
}

// --- algo.RnullStr1000.ch.N
inline int algo::ch_N(const algo::RnullStr1000& parent) {
    u64 ret;
    ret = 1000;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr1000.ch.Cast
inline algo::RnullStr1000::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr1000..Lt
inline bool algo::RnullStr1000_Lt(algo::RnullStr1000 & lhs, algo::RnullStr1000 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr1000..Cmp
inline i32 algo::RnullStr1000_Cmp(algo::RnullStr1000 & lhs, algo::RnullStr1000 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr1000..Init
// Set all fields to initial values.
inline void algo::RnullStr1000_Init(algo::RnullStr1000& parent) {
    memset(parent.ch, 0, 1000);
}

// --- algo.RnullStr1000..Eq
inline bool algo::RnullStr1000_Eq(const algo::RnullStr1000 & lhs,const algo::RnullStr1000 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr1000..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr1000_Update(algo::RnullStr1000 &lhs, algo::RnullStr1000 & rhs) {
    bool ret = !RnullStr1000_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr1000..EqStrptr
inline bool algo::RnullStr1000_EqStrptr(algo::RnullStr1000 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr11::operator ==(const algo::RnullStr11 &rhs) const {
    return algo::RnullStr11_Eq(const_cast<algo::RnullStr11&>(*this),const_cast<algo::RnullStr11&>(rhs));
}

inline bool algo::RnullStr11::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr11_EqStrptr(const_cast<algo::RnullStr11&>(*this),rhs);
}

inline bool algo::RnullStr11::operator <(const algo::RnullStr11 &rhs) const {
    return algo::RnullStr11_Lt(const_cast<algo::RnullStr11&>(*this),const_cast<algo::RnullStr11&>(rhs));
}
inline algo::RnullStr11::RnullStr11() {
    algo::RnullStr11_Init(*this);
}


// --- algo.RnullStr11.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr11& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr11.ch.HashStrptr
inline u32 algo::RnullStr11_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr11.ch.Init
inline void algo::ch_Init(algo::RnullStr11 &parent) {
    memset(parent.ch, 0, 11);
}

// --- algo.RnullStr11.ch.Max
// always return constant 11
inline int algo::ch_Max(algo::RnullStr11& parent) {
    (void)parent;
    return 11;
}

// --- algo.RnullStr11.ch.N
inline int algo::ch_N(const algo::RnullStr11& parent) {
    u64 ret;
    ret = 11;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr11.ch.Cast
inline algo::RnullStr11::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr11..Lt
inline bool algo::RnullStr11_Lt(algo::RnullStr11 & lhs, algo::RnullStr11 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr11..Cmp
inline i32 algo::RnullStr11_Cmp(algo::RnullStr11 & lhs, algo::RnullStr11 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr11..Init
// Set all fields to initial values.
inline void algo::RnullStr11_Init(algo::RnullStr11& parent) {
    memset(parent.ch, 0, 11);
}

// --- algo.RnullStr11..Eq
inline bool algo::RnullStr11_Eq(const algo::RnullStr11 & lhs,const algo::RnullStr11 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr11..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr11_Update(algo::RnullStr11 &lhs, algo::RnullStr11 & rhs) {
    bool ret = !RnullStr11_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr11..EqStrptr
inline bool algo::RnullStr11_EqStrptr(algo::RnullStr11 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr12::operator ==(const algo::RnullStr12 &rhs) const {
    return algo::RnullStr12_Eq(const_cast<algo::RnullStr12&>(*this),const_cast<algo::RnullStr12&>(rhs));
}

inline bool algo::RnullStr12::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr12_EqStrptr(const_cast<algo::RnullStr12&>(*this),rhs);
}

inline bool algo::RnullStr12::operator <(const algo::RnullStr12 &rhs) const {
    return algo::RnullStr12_Lt(const_cast<algo::RnullStr12&>(*this),const_cast<algo::RnullStr12&>(rhs));
}
inline algo::RnullStr12::RnullStr12() {
    algo::RnullStr12_Init(*this);
}


// --- algo.RnullStr12.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr12& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr12.ch.HashStrptr
inline u32 algo::RnullStr12_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr12.ch.Init
inline void algo::ch_Init(algo::RnullStr12 &parent) {
    memset(parent.ch, 0, 12);
}

// --- algo.RnullStr12.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::RnullStr12& parent) {
    (void)parent;
    return 12;
}

// --- algo.RnullStr12.ch.N
inline int algo::ch_N(const algo::RnullStr12& parent) {
    u64 ret;
    ret = 12;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr12.ch.Cast
inline algo::RnullStr12::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr12..Lt
inline bool algo::RnullStr12_Lt(algo::RnullStr12 & lhs, algo::RnullStr12 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr12..Cmp
inline i32 algo::RnullStr12_Cmp(algo::RnullStr12 & lhs, algo::RnullStr12 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr12..Init
// Set all fields to initial values.
inline void algo::RnullStr12_Init(algo::RnullStr12& parent) {
    memset(parent.ch, 0, 12);
}

// --- algo.RnullStr12..Eq
inline bool algo::RnullStr12_Eq(const algo::RnullStr12 & lhs,const algo::RnullStr12 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr12..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr12_Update(algo::RnullStr12 &lhs, algo::RnullStr12 & rhs) {
    bool ret = !RnullStr12_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr12..EqStrptr
inline bool algo::RnullStr12_EqStrptr(algo::RnullStr12 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr129::operator ==(const algo::RnullStr129 &rhs) const {
    return algo::RnullStr129_Eq(const_cast<algo::RnullStr129&>(*this),const_cast<algo::RnullStr129&>(rhs));
}

inline bool algo::RnullStr129::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr129_EqStrptr(const_cast<algo::RnullStr129&>(*this),rhs);
}

inline bool algo::RnullStr129::operator <(const algo::RnullStr129 &rhs) const {
    return algo::RnullStr129_Lt(const_cast<algo::RnullStr129&>(*this),const_cast<algo::RnullStr129&>(rhs));
}
inline algo::RnullStr129::RnullStr129() {
    algo::RnullStr129_Init(*this);
}


// --- algo.RnullStr129.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr129& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr129.ch.HashStrptr
inline u32 algo::RnullStr129_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr129.ch.Init
inline void algo::ch_Init(algo::RnullStr129 &parent) {
    memset(parent.ch, 0, 129);
}

// --- algo.RnullStr129.ch.Max
// always return constant 129
inline int algo::ch_Max(algo::RnullStr129& parent) {
    (void)parent;
    return 129;
}

// --- algo.RnullStr129.ch.N
inline int algo::ch_N(const algo::RnullStr129& parent) {
    u64 ret;
    ret = 129;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr129.ch.Cast
inline algo::RnullStr129::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr129..Lt
inline bool algo::RnullStr129_Lt(algo::RnullStr129 & lhs, algo::RnullStr129 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr129..Cmp
inline i32 algo::RnullStr129_Cmp(algo::RnullStr129 & lhs, algo::RnullStr129 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr129..Init
// Set all fields to initial values.
inline void algo::RnullStr129_Init(algo::RnullStr129& parent) {
    memset(parent.ch, 0, 129);
}

// --- algo.RnullStr129..Eq
inline bool algo::RnullStr129_Eq(const algo::RnullStr129 & lhs,const algo::RnullStr129 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr129..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr129_Update(algo::RnullStr129 &lhs, algo::RnullStr129 & rhs) {
    bool ret = !RnullStr129_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr129..EqStrptr
inline bool algo::RnullStr129_EqStrptr(algo::RnullStr129 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr13::operator ==(const algo::RnullStr13 &rhs) const {
    return algo::RnullStr13_Eq(const_cast<algo::RnullStr13&>(*this),const_cast<algo::RnullStr13&>(rhs));
}

inline bool algo::RnullStr13::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr13_EqStrptr(const_cast<algo::RnullStr13&>(*this),rhs);
}

inline bool algo::RnullStr13::operator <(const algo::RnullStr13 &rhs) const {
    return algo::RnullStr13_Lt(const_cast<algo::RnullStr13&>(*this),const_cast<algo::RnullStr13&>(rhs));
}
inline algo::RnullStr13::RnullStr13() {
    algo::RnullStr13_Init(*this);
}


// --- algo.RnullStr13.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr13& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr13.ch.HashStrptr
inline u32 algo::RnullStr13_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr13.ch.Init
inline void algo::ch_Init(algo::RnullStr13 &parent) {
    memset(parent.ch, 0, 13);
}

// --- algo.RnullStr13.ch.Max
// always return constant 13
inline int algo::ch_Max(algo::RnullStr13& parent) {
    (void)parent;
    return 13;
}

// --- algo.RnullStr13.ch.N
inline int algo::ch_N(const algo::RnullStr13& parent) {
    u64 ret;
    ret = 13;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr13.ch.Cast
inline algo::RnullStr13::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr13..Lt
inline bool algo::RnullStr13_Lt(algo::RnullStr13 & lhs, algo::RnullStr13 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr13..Cmp
inline i32 algo::RnullStr13_Cmp(algo::RnullStr13 & lhs, algo::RnullStr13 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr13..Init
// Set all fields to initial values.
inline void algo::RnullStr13_Init(algo::RnullStr13& parent) {
    memset(parent.ch, 0, 13);
}

// --- algo.RnullStr13..Eq
inline bool algo::RnullStr13_Eq(const algo::RnullStr13 & lhs,const algo::RnullStr13 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr13..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr13_Update(algo::RnullStr13 &lhs, algo::RnullStr13 & rhs) {
    bool ret = !RnullStr13_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr13..EqStrptr
inline bool algo::RnullStr13_EqStrptr(algo::RnullStr13 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr14::operator ==(const algo::RnullStr14 &rhs) const {
    return algo::RnullStr14_Eq(const_cast<algo::RnullStr14&>(*this),const_cast<algo::RnullStr14&>(rhs));
}

inline bool algo::RnullStr14::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr14_EqStrptr(const_cast<algo::RnullStr14&>(*this),rhs);
}

inline bool algo::RnullStr14::operator <(const algo::RnullStr14 &rhs) const {
    return algo::RnullStr14_Lt(const_cast<algo::RnullStr14&>(*this),const_cast<algo::RnullStr14&>(rhs));
}
inline algo::RnullStr14::RnullStr14() {
    algo::RnullStr14_Init(*this);
}


// --- algo.RnullStr14.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr14& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr14.ch.HashStrptr
inline u32 algo::RnullStr14_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr14.ch.Init
inline void algo::ch_Init(algo::RnullStr14 &parent) {
    memset(parent.ch, 0, 14);
}

// --- algo.RnullStr14.ch.Max
// always return constant 14
inline int algo::ch_Max(algo::RnullStr14& parent) {
    (void)parent;
    return 14;
}

// --- algo.RnullStr14.ch.N
inline int algo::ch_N(const algo::RnullStr14& parent) {
    u64 ret;
    ret = 14;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr14.ch.Cast
inline algo::RnullStr14::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr14..Lt
inline bool algo::RnullStr14_Lt(algo::RnullStr14 & lhs, algo::RnullStr14 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr14..Cmp
inline i32 algo::RnullStr14_Cmp(algo::RnullStr14 & lhs, algo::RnullStr14 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr14..Init
// Set all fields to initial values.
inline void algo::RnullStr14_Init(algo::RnullStr14& parent) {
    memset(parent.ch, 0, 14);
}

// --- algo.RnullStr14..Eq
inline bool algo::RnullStr14_Eq(const algo::RnullStr14 & lhs,const algo::RnullStr14 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr14..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr14_Update(algo::RnullStr14 &lhs, algo::RnullStr14 & rhs) {
    bool ret = !RnullStr14_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr14..EqStrptr
inline bool algo::RnullStr14_EqStrptr(algo::RnullStr14 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr15::operator ==(const algo::RnullStr15 &rhs) const {
    return algo::RnullStr15_Eq(const_cast<algo::RnullStr15&>(*this),const_cast<algo::RnullStr15&>(rhs));
}

inline bool algo::RnullStr15::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr15_EqStrptr(const_cast<algo::RnullStr15&>(*this),rhs);
}

inline bool algo::RnullStr15::operator <(const algo::RnullStr15 &rhs) const {
    return algo::RnullStr15_Lt(const_cast<algo::RnullStr15&>(*this),const_cast<algo::RnullStr15&>(rhs));
}
inline algo::RnullStr15::RnullStr15() {
    algo::RnullStr15_Init(*this);
}


// --- algo.RnullStr15.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr15& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr15.ch.HashStrptr
inline u32 algo::RnullStr15_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr15.ch.Init
inline void algo::ch_Init(algo::RnullStr15 &parent) {
    memset(parent.ch, 0, 15);
}

// --- algo.RnullStr15.ch.Max
// always return constant 15
inline int algo::ch_Max(algo::RnullStr15& parent) {
    (void)parent;
    return 15;
}

// --- algo.RnullStr15.ch.N
inline int algo::ch_N(const algo::RnullStr15& parent) {
    u64 ret;
    ret = 15;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr15.ch.Cast
inline algo::RnullStr15::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr15..Lt
inline bool algo::RnullStr15_Lt(algo::RnullStr15 & lhs, algo::RnullStr15 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr15..Cmp
inline i32 algo::RnullStr15_Cmp(algo::RnullStr15 & lhs, algo::RnullStr15 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr15..Init
// Set all fields to initial values.
inline void algo::RnullStr15_Init(algo::RnullStr15& parent) {
    memset(parent.ch, 0, 15);
}

// --- algo.RnullStr15..Eq
inline bool algo::RnullStr15_Eq(const algo::RnullStr15 & lhs,const algo::RnullStr15 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr15..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr15_Update(algo::RnullStr15 &lhs, algo::RnullStr15 & rhs) {
    bool ret = !RnullStr15_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr15..EqStrptr
inline bool algo::RnullStr15_EqStrptr(algo::RnullStr15 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr151::operator ==(const algo::RnullStr151 &rhs) const {
    return algo::RnullStr151_Eq(const_cast<algo::RnullStr151&>(*this),const_cast<algo::RnullStr151&>(rhs));
}

inline bool algo::RnullStr151::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr151_EqStrptr(const_cast<algo::RnullStr151&>(*this),rhs);
}

inline bool algo::RnullStr151::operator <(const algo::RnullStr151 &rhs) const {
    return algo::RnullStr151_Lt(const_cast<algo::RnullStr151&>(*this),const_cast<algo::RnullStr151&>(rhs));
}
inline algo::RnullStr151::RnullStr151() {
    algo::RnullStr151_Init(*this);
}


// --- algo.RnullStr151.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr151& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr151.ch.HashStrptr
inline u32 algo::RnullStr151_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr151.ch.Init
inline void algo::ch_Init(algo::RnullStr151 &parent) {
    memset(parent.ch, 0, 151);
}

// --- algo.RnullStr151.ch.Max
// always return constant 151
inline int algo::ch_Max(algo::RnullStr151& parent) {
    (void)parent;
    return 151;
}

// --- algo.RnullStr151.ch.N
inline int algo::ch_N(const algo::RnullStr151& parent) {
    u64 ret;
    ret = 151;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr151.ch.Cast
inline algo::RnullStr151::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr151..Lt
inline bool algo::RnullStr151_Lt(algo::RnullStr151 & lhs, algo::RnullStr151 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr151..Cmp
inline i32 algo::RnullStr151_Cmp(algo::RnullStr151 & lhs, algo::RnullStr151 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr151..Init
// Set all fields to initial values.
inline void algo::RnullStr151_Init(algo::RnullStr151& parent) {
    memset(parent.ch, 0, 151);
}

// --- algo.RnullStr151..Eq
inline bool algo::RnullStr151_Eq(const algo::RnullStr151 & lhs,const algo::RnullStr151 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr151..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr151_Update(algo::RnullStr151 &lhs, algo::RnullStr151 & rhs) {
    bool ret = !RnullStr151_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr151..EqStrptr
inline bool algo::RnullStr151_EqStrptr(algo::RnullStr151 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr16::RnullStr16() {
    algo::RnullStr16_Init(*this);
}


// --- algo.RnullStr16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr16.ch.HashStrptr
inline u32 algo::RnullStr16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr16.ch.Init
inline void algo::ch_Init(algo::RnullStr16 &parent) {
    memset(parent.ch, 0, 16);
}

// --- algo.RnullStr16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::RnullStr16& parent) {
    (void)parent;
    return 16;
}

// --- algo.RnullStr16.ch.N
inline int algo::ch_N(const algo::RnullStr16& parent) {
    u64 ret;
    ret = 16;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr16.ch.Cast
inline algo::RnullStr16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr16..Lt
inline bool algo::RnullStr16_Lt(algo::RnullStr16 lhs, algo::RnullStr16 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr16..Cmp
inline i32 algo::RnullStr16_Cmp(algo::RnullStr16 lhs, algo::RnullStr16 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr16..Init
// Set all fields to initial values.
inline void algo::RnullStr16_Init(algo::RnullStr16& parent) {
    memset(parent.ch, 0, 16);
}

// --- algo.RnullStr16..Eq
inline bool algo::RnullStr16_Eq(algo::RnullStr16 lhs, algo::RnullStr16 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr16..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr16_Update(algo::RnullStr16 &lhs, algo::RnullStr16 rhs) {
    bool ret = !RnullStr16_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr16..EqStrptr
inline bool algo::RnullStr16_EqStrptr(algo::RnullStr16 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr17::operator ==(const algo::RnullStr17 &rhs) const {
    return algo::RnullStr17_Eq(const_cast<algo::RnullStr17&>(*this),const_cast<algo::RnullStr17&>(rhs));
}

inline bool algo::RnullStr17::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr17_EqStrptr(const_cast<algo::RnullStr17&>(*this),rhs);
}

inline bool algo::RnullStr17::operator <(const algo::RnullStr17 &rhs) const {
    return algo::RnullStr17_Lt(const_cast<algo::RnullStr17&>(*this),const_cast<algo::RnullStr17&>(rhs));
}
inline algo::RnullStr17::RnullStr17() {
    algo::RnullStr17_Init(*this);
}


// --- algo.RnullStr17.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr17& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr17.ch.HashStrptr
inline u32 algo::RnullStr17_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr17.ch.Init
inline void algo::ch_Init(algo::RnullStr17 &parent) {
    memset(parent.ch, 0, 17);
}

// --- algo.RnullStr17.ch.Max
// always return constant 17
inline int algo::ch_Max(algo::RnullStr17& parent) {
    (void)parent;
    return 17;
}

// --- algo.RnullStr17.ch.N
inline int algo::ch_N(const algo::RnullStr17& parent) {
    u64 ret;
    ret = 17;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr17.ch.Cast
inline algo::RnullStr17::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr17..Lt
inline bool algo::RnullStr17_Lt(algo::RnullStr17 & lhs, algo::RnullStr17 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr17..Cmp
inline i32 algo::RnullStr17_Cmp(algo::RnullStr17 & lhs, algo::RnullStr17 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr17..Init
// Set all fields to initial values.
inline void algo::RnullStr17_Init(algo::RnullStr17& parent) {
    memset(parent.ch, 0, 17);
}

// --- algo.RnullStr17..Eq
inline bool algo::RnullStr17_Eq(const algo::RnullStr17 & lhs,const algo::RnullStr17 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr17..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr17_Update(algo::RnullStr17 &lhs, algo::RnullStr17 & rhs) {
    bool ret = !RnullStr17_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr17..EqStrptr
inline bool algo::RnullStr17_EqStrptr(algo::RnullStr17 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr18::operator ==(const algo::RnullStr18 &rhs) const {
    return algo::RnullStr18_Eq(const_cast<algo::RnullStr18&>(*this),const_cast<algo::RnullStr18&>(rhs));
}

inline bool algo::RnullStr18::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr18_EqStrptr(const_cast<algo::RnullStr18&>(*this),rhs);
}

inline bool algo::RnullStr18::operator <(const algo::RnullStr18 &rhs) const {
    return algo::RnullStr18_Lt(const_cast<algo::RnullStr18&>(*this),const_cast<algo::RnullStr18&>(rhs));
}
inline algo::RnullStr18::RnullStr18() {
    algo::RnullStr18_Init(*this);
}


// --- algo.RnullStr18.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr18& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr18.ch.HashStrptr
inline u32 algo::RnullStr18_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr18.ch.Init
inline void algo::ch_Init(algo::RnullStr18 &parent) {
    memset(parent.ch, 0, 18);
}

// --- algo.RnullStr18.ch.Max
// always return constant 18
inline int algo::ch_Max(algo::RnullStr18& parent) {
    (void)parent;
    return 18;
}

// --- algo.RnullStr18.ch.N
inline int algo::ch_N(const algo::RnullStr18& parent) {
    u64 ret;
    ret = 18;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr18.ch.Cast
inline algo::RnullStr18::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr18..Lt
inline bool algo::RnullStr18_Lt(algo::RnullStr18 lhs, algo::RnullStr18 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr18..Cmp
inline i32 algo::RnullStr18_Cmp(algo::RnullStr18 lhs, algo::RnullStr18 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr18..Init
// Set all fields to initial values.
inline void algo::RnullStr18_Init(algo::RnullStr18& parent) {
    memset(parent.ch, 0, 18);
}

// --- algo.RnullStr18..Eq
inline bool algo::RnullStr18_Eq(algo::RnullStr18 lhs, algo::RnullStr18 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr18..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr18_Update(algo::RnullStr18 &lhs, algo::RnullStr18 rhs) {
    bool ret = !RnullStr18_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr18..EqStrptr
inline bool algo::RnullStr18_EqStrptr(algo::RnullStr18 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr19::RnullStr19() {
    algo::RnullStr19_Init(*this);
}


// --- algo.RnullStr19.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr19& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr19.ch.HashStrptr
inline u32 algo::RnullStr19_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr19.ch.Init
inline void algo::ch_Init(algo::RnullStr19 &parent) {
    memset(parent.ch, 0, 19);
}

// --- algo.RnullStr19.ch.Max
// always return constant 19
inline int algo::ch_Max(algo::RnullStr19& parent) {
    (void)parent;
    return 19;
}

// --- algo.RnullStr19.ch.N
inline int algo::ch_N(const algo::RnullStr19& parent) {
    u64 ret;
    ret = 19;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr19.ch.Cast
inline algo::RnullStr19::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr19..Lt
inline bool algo::RnullStr19_Lt(algo::RnullStr19 & lhs, algo::RnullStr19 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr19..Cmp
inline i32 algo::RnullStr19_Cmp(algo::RnullStr19 & lhs, algo::RnullStr19 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr19..Init
// Set all fields to initial values.
inline void algo::RnullStr19_Init(algo::RnullStr19& parent) {
    memset(parent.ch, 0, 19);
}

// --- algo.RnullStr19..Eq
inline bool algo::RnullStr19_Eq(const algo::RnullStr19 & lhs,const algo::RnullStr19 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr19..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr19_Update(algo::RnullStr19 &lhs, algo::RnullStr19 & rhs) {
    bool ret = !RnullStr19_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr19..EqStrptr
inline bool algo::RnullStr19_EqStrptr(algo::RnullStr19 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr2::operator ==(const algo::RnullStr2 &rhs) const {
    return algo::RnullStr2_Eq(const_cast<algo::RnullStr2&>(*this),const_cast<algo::RnullStr2&>(rhs));
}

inline bool algo::RnullStr2::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr2_EqStrptr(const_cast<algo::RnullStr2&>(*this),rhs);
}

inline bool algo::RnullStr2::operator <(const algo::RnullStr2 &rhs) const {
    return algo::RnullStr2_Lt(const_cast<algo::RnullStr2&>(*this),const_cast<algo::RnullStr2&>(rhs));
}
inline algo::RnullStr2::RnullStr2() {
    algo::RnullStr2_Init(*this);
}


// --- algo.RnullStr2.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr2& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr2.ch.HashStrptr
inline u32 algo::RnullStr2_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr2.ch.Init
inline void algo::ch_Init(algo::RnullStr2 &parent) {
    memset(parent.ch, 0, 2);
}

// --- algo.RnullStr2.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::RnullStr2& parent) {
    (void)parent;
    return 2;
}

// --- algo.RnullStr2.ch.N
inline int algo::ch_N(const algo::RnullStr2& parent) {
    u64 ret;
    ret = 2;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr2.ch.Cast
inline algo::RnullStr2::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr2..Lt
inline bool algo::RnullStr2_Lt(algo::RnullStr2 lhs, algo::RnullStr2 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr2..Cmp
inline i32 algo::RnullStr2_Cmp(algo::RnullStr2 lhs, algo::RnullStr2 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr2..Init
// Set all fields to initial values.
inline void algo::RnullStr2_Init(algo::RnullStr2& parent) {
    memset(parent.ch, 0, 2);
}

// --- algo.RnullStr2..Eq
inline bool algo::RnullStr2_Eq(algo::RnullStr2 lhs, algo::RnullStr2 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr2..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr2_Update(algo::RnullStr2 &lhs, algo::RnullStr2 rhs) {
    bool ret = !RnullStr2_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr2..EqStrptr
inline bool algo::RnullStr2_EqStrptr(algo::RnullStr2 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr20::operator ==(const algo::RnullStr20 &rhs) const {
    return algo::RnullStr20_Eq(const_cast<algo::RnullStr20&>(*this),const_cast<algo::RnullStr20&>(rhs));
}

inline bool algo::RnullStr20::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr20_EqStrptr(const_cast<algo::RnullStr20&>(*this),rhs);
}

inline bool algo::RnullStr20::operator <(const algo::RnullStr20 &rhs) const {
    return algo::RnullStr20_Lt(const_cast<algo::RnullStr20&>(*this),const_cast<algo::RnullStr20&>(rhs));
}
inline algo::RnullStr20::RnullStr20() {
    algo::RnullStr20_Init(*this);
}


// --- algo.RnullStr20.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr20& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr20.ch.HashStrptr
inline u32 algo::RnullStr20_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr20.ch.Init
inline void algo::ch_Init(algo::RnullStr20 &parent) {
    memset(parent.ch, 0, 20);
}

// --- algo.RnullStr20.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::RnullStr20& parent) {
    (void)parent;
    return 20;
}

// --- algo.RnullStr20.ch.N
inline int algo::ch_N(const algo::RnullStr20& parent) {
    u64 ret;
    ret = 20;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr20.ch.Cast
inline algo::RnullStr20::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr20..Lt
inline bool algo::RnullStr20_Lt(algo::RnullStr20 lhs, algo::RnullStr20 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr20..Cmp
inline i32 algo::RnullStr20_Cmp(algo::RnullStr20 lhs, algo::RnullStr20 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr20..Init
// Set all fields to initial values.
inline void algo::RnullStr20_Init(algo::RnullStr20& parent) {
    memset(parent.ch, 0, 20);
}

// --- algo.RnullStr20..Eq
inline bool algo::RnullStr20_Eq(algo::RnullStr20 lhs, algo::RnullStr20 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr20..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr20_Update(algo::RnullStr20 &lhs, algo::RnullStr20 rhs) {
    bool ret = !RnullStr20_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr20..EqStrptr
inline bool algo::RnullStr20_EqStrptr(algo::RnullStr20 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr21::RnullStr21() {
    algo::RnullStr21_Init(*this);
}


// --- algo.RnullStr21.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr21& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr21.ch.HashStrptr
inline u32 algo::RnullStr21_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr21.ch.Init
inline void algo::ch_Init(algo::RnullStr21 &parent) {
    memset(parent.ch, 0, 21);
}

// --- algo.RnullStr21.ch.Max
// always return constant 21
inline int algo::ch_Max(algo::RnullStr21& parent) {
    (void)parent;
    return 21;
}

// --- algo.RnullStr21.ch.N
inline int algo::ch_N(const algo::RnullStr21& parent) {
    u64 ret;
    ret = 21;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr21.ch.Cast
inline algo::RnullStr21::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr21..Lt
inline bool algo::RnullStr21_Lt(algo::RnullStr21 & lhs, algo::RnullStr21 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr21..Cmp
inline i32 algo::RnullStr21_Cmp(algo::RnullStr21 & lhs, algo::RnullStr21 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr21..Init
// Set all fields to initial values.
inline void algo::RnullStr21_Init(algo::RnullStr21& parent) {
    memset(parent.ch, 0, 21);
}

// --- algo.RnullStr21..Eq
inline bool algo::RnullStr21_Eq(const algo::RnullStr21 & lhs,const algo::RnullStr21 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr21..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr21_Update(algo::RnullStr21 &lhs, algo::RnullStr21 & rhs) {
    bool ret = !RnullStr21_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr21..EqStrptr
inline bool algo::RnullStr21_EqStrptr(algo::RnullStr21 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr24::operator ==(const algo::RnullStr24 &rhs) const {
    return algo::RnullStr24_Eq(const_cast<algo::RnullStr24&>(*this),const_cast<algo::RnullStr24&>(rhs));
}

inline bool algo::RnullStr24::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr24_EqStrptr(const_cast<algo::RnullStr24&>(*this),rhs);
}

inline bool algo::RnullStr24::operator <(const algo::RnullStr24 &rhs) const {
    return algo::RnullStr24_Lt(const_cast<algo::RnullStr24&>(*this),const_cast<algo::RnullStr24&>(rhs));
}
inline algo::RnullStr24::RnullStr24() {
    algo::RnullStr24_Init(*this);
}


// --- algo.RnullStr24.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr24& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr24.ch.HashStrptr
inline u32 algo::RnullStr24_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr24.ch.Init
inline void algo::ch_Init(algo::RnullStr24 &parent) {
    memset(parent.ch, 0, 24);
}

// --- algo.RnullStr24.ch.Max
// always return constant 24
inline int algo::ch_Max(algo::RnullStr24& parent) {
    (void)parent;
    return 24;
}

// --- algo.RnullStr24.ch.N
inline int algo::ch_N(const algo::RnullStr24& parent) {
    u64 ret;
    ret = 24;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr24.ch.Cast
inline algo::RnullStr24::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr24..Lt
inline bool algo::RnullStr24_Lt(algo::RnullStr24 & lhs, algo::RnullStr24 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr24..Cmp
inline i32 algo::RnullStr24_Cmp(algo::RnullStr24 & lhs, algo::RnullStr24 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr24..Init
// Set all fields to initial values.
inline void algo::RnullStr24_Init(algo::RnullStr24& parent) {
    memset(parent.ch, 0, 24);
}

// --- algo.RnullStr24..Eq
inline bool algo::RnullStr24_Eq(const algo::RnullStr24 & lhs,const algo::RnullStr24 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr24..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr24_Update(algo::RnullStr24 &lhs, algo::RnullStr24 & rhs) {
    bool ret = !RnullStr24_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr24..EqStrptr
inline bool algo::RnullStr24_EqStrptr(algo::RnullStr24 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr25::operator ==(const algo::RnullStr25 &rhs) const {
    return algo::RnullStr25_Eq(const_cast<algo::RnullStr25&>(*this),const_cast<algo::RnullStr25&>(rhs));
}

inline bool algo::RnullStr25::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr25_EqStrptr(const_cast<algo::RnullStr25&>(*this),rhs);
}

inline bool algo::RnullStr25::operator <(const algo::RnullStr25 &rhs) const {
    return algo::RnullStr25_Lt(const_cast<algo::RnullStr25&>(*this),const_cast<algo::RnullStr25&>(rhs));
}
inline algo::RnullStr25::RnullStr25() {
    algo::RnullStr25_Init(*this);
}


// --- algo.RnullStr25.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr25& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr25.ch.HashStrptr
inline u32 algo::RnullStr25_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr25.ch.Init
inline void algo::ch_Init(algo::RnullStr25 &parent) {
    memset(parent.ch, 0, 25);
}

// --- algo.RnullStr25.ch.Max
// always return constant 25
inline int algo::ch_Max(algo::RnullStr25& parent) {
    (void)parent;
    return 25;
}

// --- algo.RnullStr25.ch.N
inline int algo::ch_N(const algo::RnullStr25& parent) {
    u64 ret;
    ret = 25;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr25.ch.Cast
inline algo::RnullStr25::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr25..Lt
inline bool algo::RnullStr25_Lt(algo::RnullStr25 & lhs, algo::RnullStr25 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr25..Cmp
inline i32 algo::RnullStr25_Cmp(algo::RnullStr25 & lhs, algo::RnullStr25 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr25..Init
// Set all fields to initial values.
inline void algo::RnullStr25_Init(algo::RnullStr25& parent) {
    memset(parent.ch, 0, 25);
}

// --- algo.RnullStr25..Eq
inline bool algo::RnullStr25_Eq(const algo::RnullStr25 & lhs,const algo::RnullStr25 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr25..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr25_Update(algo::RnullStr25 &lhs, algo::RnullStr25 & rhs) {
    bool ret = !RnullStr25_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr25..EqStrptr
inline bool algo::RnullStr25_EqStrptr(algo::RnullStr25 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr28::operator ==(const algo::RnullStr28 &rhs) const {
    return algo::RnullStr28_Eq(const_cast<algo::RnullStr28&>(*this),const_cast<algo::RnullStr28&>(rhs));
}

inline bool algo::RnullStr28::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr28_EqStrptr(const_cast<algo::RnullStr28&>(*this),rhs);
}

inline bool algo::RnullStr28::operator <(const algo::RnullStr28 &rhs) const {
    return algo::RnullStr28_Lt(const_cast<algo::RnullStr28&>(*this),const_cast<algo::RnullStr28&>(rhs));
}
inline algo::RnullStr28::RnullStr28() {
    algo::RnullStr28_Init(*this);
}


// --- algo.RnullStr28.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr28& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr28.ch.HashStrptr
inline u32 algo::RnullStr28_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr28.ch.Init
inline void algo::ch_Init(algo::RnullStr28 &parent) {
    memset(parent.ch, 0, 28);
}

// --- algo.RnullStr28.ch.Max
// always return constant 28
inline int algo::ch_Max(algo::RnullStr28& parent) {
    (void)parent;
    return 28;
}

// --- algo.RnullStr28.ch.N
inline int algo::ch_N(const algo::RnullStr28& parent) {
    u64 ret;
    ret = 28;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr28.ch.Cast
inline algo::RnullStr28::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr28..Lt
inline bool algo::RnullStr28_Lt(algo::RnullStr28 & lhs, algo::RnullStr28 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr28..Cmp
inline i32 algo::RnullStr28_Cmp(algo::RnullStr28 & lhs, algo::RnullStr28 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr28..Init
// Set all fields to initial values.
inline void algo::RnullStr28_Init(algo::RnullStr28& parent) {
    memset(parent.ch, 0, 28);
}

// --- algo.RnullStr28..Eq
inline bool algo::RnullStr28_Eq(const algo::RnullStr28 & lhs,const algo::RnullStr28 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr28..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr28_Update(algo::RnullStr28 &lhs, algo::RnullStr28 & rhs) {
    bool ret = !RnullStr28_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr28..EqStrptr
inline bool algo::RnullStr28_EqStrptr(algo::RnullStr28 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr3::operator ==(const algo::RnullStr3 &rhs) const {
    return algo::RnullStr3_Eq(const_cast<algo::RnullStr3&>(*this),const_cast<algo::RnullStr3&>(rhs));
}

inline bool algo::RnullStr3::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr3_EqStrptr(const_cast<algo::RnullStr3&>(*this),rhs);
}

inline bool algo::RnullStr3::operator <(const algo::RnullStr3 &rhs) const {
    return algo::RnullStr3_Lt(const_cast<algo::RnullStr3&>(*this),const_cast<algo::RnullStr3&>(rhs));
}
inline algo::RnullStr3::RnullStr3() {
    algo::RnullStr3_Init(*this);
}


// --- algo.RnullStr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr3.ch.HashStrptr
inline u32 algo::RnullStr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr3.ch.Init
inline void algo::ch_Init(algo::RnullStr3 &parent) {
    memset(parent.ch, 0, 3);
}

// --- algo.RnullStr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::RnullStr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.RnullStr3.ch.N
inline int algo::ch_N(const algo::RnullStr3& parent) {
    u64 ret;
    ret = 3;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr3.ch.Cast
inline algo::RnullStr3::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr3..Lt
inline bool algo::RnullStr3_Lt(algo::RnullStr3 lhs, algo::RnullStr3 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr3..Cmp
inline i32 algo::RnullStr3_Cmp(algo::RnullStr3 lhs, algo::RnullStr3 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr3..Init
// Set all fields to initial values.
inline void algo::RnullStr3_Init(algo::RnullStr3& parent) {
    memset(parent.ch, 0, 3);
}

// --- algo.RnullStr3..Eq
inline bool algo::RnullStr3_Eq(algo::RnullStr3 lhs, algo::RnullStr3 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr3..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr3_Update(algo::RnullStr3 &lhs, algo::RnullStr3 rhs) {
    bool ret = !RnullStr3_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr3..EqStrptr
inline bool algo::RnullStr3_EqStrptr(algo::RnullStr3 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr30::RnullStr30() {
    algo::RnullStr30_Init(*this);
}


// --- algo.RnullStr30.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr30& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr30.ch.HashStrptr
inline u32 algo::RnullStr30_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr30.ch.Init
inline void algo::ch_Init(algo::RnullStr30 &parent) {
    memset(parent.ch, 0, 30);
}

// --- algo.RnullStr30.ch.Max
// always return constant 30
inline int algo::ch_Max(algo::RnullStr30& parent) {
    (void)parent;
    return 30;
}

// --- algo.RnullStr30.ch.N
inline int algo::ch_N(const algo::RnullStr30& parent) {
    u64 ret;
    ret = 30;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr30.ch.Cast
inline algo::RnullStr30::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr30..Lt
inline bool algo::RnullStr30_Lt(algo::RnullStr30 lhs, algo::RnullStr30 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr30..Cmp
inline i32 algo::RnullStr30_Cmp(algo::RnullStr30 lhs, algo::RnullStr30 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr30..Init
// Set all fields to initial values.
inline void algo::RnullStr30_Init(algo::RnullStr30& parent) {
    memset(parent.ch, 0, 30);
}

// --- algo.RnullStr30..Eq
inline bool algo::RnullStr30_Eq(algo::RnullStr30 lhs, algo::RnullStr30 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr30..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr30_Update(algo::RnullStr30 &lhs, algo::RnullStr30 rhs) {
    bool ret = !RnullStr30_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr30..EqStrptr
inline bool algo::RnullStr30_EqStrptr(algo::RnullStr30 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr32::operator ==(const algo::RnullStr32 &rhs) const {
    return algo::RnullStr32_Eq(const_cast<algo::RnullStr32&>(*this),const_cast<algo::RnullStr32&>(rhs));
}

inline bool algo::RnullStr32::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr32_EqStrptr(const_cast<algo::RnullStr32&>(*this),rhs);
}

inline bool algo::RnullStr32::operator <(const algo::RnullStr32 &rhs) const {
    return algo::RnullStr32_Lt(const_cast<algo::RnullStr32&>(*this),const_cast<algo::RnullStr32&>(rhs));
}
inline algo::RnullStr32::RnullStr32() {
    algo::RnullStr32_Init(*this);
}


// --- algo.RnullStr32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr32.ch.HashStrptr
inline u32 algo::RnullStr32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr32.ch.Init
inline void algo::ch_Init(algo::RnullStr32 &parent) {
    memset(parent.ch, 0, 32);
}

// --- algo.RnullStr32.ch.Max
// always return constant 32
inline int algo::ch_Max(algo::RnullStr32& parent) {
    (void)parent;
    return 32;
}

// --- algo.RnullStr32.ch.N
inline int algo::ch_N(const algo::RnullStr32& parent) {
    u64 ret;
    ret = 32;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr32.ch.Cast
inline algo::RnullStr32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr32..Lt
inline bool algo::RnullStr32_Lt(algo::RnullStr32 lhs, algo::RnullStr32 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr32..Cmp
inline i32 algo::RnullStr32_Cmp(algo::RnullStr32 lhs, algo::RnullStr32 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr32..Init
// Set all fields to initial values.
inline void algo::RnullStr32_Init(algo::RnullStr32& parent) {
    memset(parent.ch, 0, 32);
}

// --- algo.RnullStr32..Eq
inline bool algo::RnullStr32_Eq(algo::RnullStr32 lhs, algo::RnullStr32 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr32..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr32_Update(algo::RnullStr32 &lhs, algo::RnullStr32 rhs) {
    bool ret = !RnullStr32_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr32..EqStrptr
inline bool algo::RnullStr32_EqStrptr(algo::RnullStr32 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr33::operator ==(const algo::RnullStr33 &rhs) const {
    return algo::RnullStr33_Eq(const_cast<algo::RnullStr33&>(*this),const_cast<algo::RnullStr33&>(rhs));
}

inline bool algo::RnullStr33::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr33_EqStrptr(const_cast<algo::RnullStr33&>(*this),rhs);
}

inline bool algo::RnullStr33::operator <(const algo::RnullStr33 &rhs) const {
    return algo::RnullStr33_Lt(const_cast<algo::RnullStr33&>(*this),const_cast<algo::RnullStr33&>(rhs));
}
inline algo::RnullStr33::RnullStr33() {
    algo::RnullStr33_Init(*this);
}


// --- algo.RnullStr33.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr33& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr33.ch.HashStrptr
inline u32 algo::RnullStr33_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr33.ch.Init
inline void algo::ch_Init(algo::RnullStr33 &parent) {
    memset(parent.ch, 0, 33);
}

// --- algo.RnullStr33.ch.Max
// always return constant 33
inline int algo::ch_Max(algo::RnullStr33& parent) {
    (void)parent;
    return 33;
}

// --- algo.RnullStr33.ch.N
inline int algo::ch_N(const algo::RnullStr33& parent) {
    u64 ret;
    ret = 33;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr33.ch.Cast
inline algo::RnullStr33::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr33..Lt
inline bool algo::RnullStr33_Lt(algo::RnullStr33 & lhs, algo::RnullStr33 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr33..Cmp
inline i32 algo::RnullStr33_Cmp(algo::RnullStr33 & lhs, algo::RnullStr33 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr33..Init
// Set all fields to initial values.
inline void algo::RnullStr33_Init(algo::RnullStr33& parent) {
    memset(parent.ch, 0, 33);
}

// --- algo.RnullStr33..Eq
inline bool algo::RnullStr33_Eq(const algo::RnullStr33 & lhs,const algo::RnullStr33 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr33..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr33_Update(algo::RnullStr33 &lhs, algo::RnullStr33 & rhs) {
    bool ret = !RnullStr33_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr33..EqStrptr
inline bool algo::RnullStr33_EqStrptr(algo::RnullStr33 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr35::operator ==(const algo::RnullStr35 &rhs) const {
    return algo::RnullStr35_Eq(const_cast<algo::RnullStr35&>(*this),const_cast<algo::RnullStr35&>(rhs));
}

inline bool algo::RnullStr35::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr35_EqStrptr(const_cast<algo::RnullStr35&>(*this),rhs);
}

inline bool algo::RnullStr35::operator <(const algo::RnullStr35 &rhs) const {
    return algo::RnullStr35_Lt(const_cast<algo::RnullStr35&>(*this),const_cast<algo::RnullStr35&>(rhs));
}
inline algo::RnullStr35::RnullStr35() {
    algo::RnullStr35_Init(*this);
}


// --- algo.RnullStr35.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr35& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr35.ch.HashStrptr
inline u32 algo::RnullStr35_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr35.ch.Init
inline void algo::ch_Init(algo::RnullStr35 &parent) {
    memset(parent.ch, 0, 35);
}

// --- algo.RnullStr35.ch.Max
// always return constant 35
inline int algo::ch_Max(algo::RnullStr35& parent) {
    (void)parent;
    return 35;
}

// --- algo.RnullStr35.ch.N
inline int algo::ch_N(const algo::RnullStr35& parent) {
    u64 ret;
    ret = 35;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr35.ch.Cast
inline algo::RnullStr35::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr35..Lt
inline bool algo::RnullStr35_Lt(algo::RnullStr35 & lhs, algo::RnullStr35 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr35..Cmp
inline i32 algo::RnullStr35_Cmp(algo::RnullStr35 & lhs, algo::RnullStr35 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr35..Init
// Set all fields to initial values.
inline void algo::RnullStr35_Init(algo::RnullStr35& parent) {
    memset(parent.ch, 0, 35);
}

// --- algo.RnullStr35..Eq
inline bool algo::RnullStr35_Eq(const algo::RnullStr35 & lhs,const algo::RnullStr35 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr35..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr35_Update(algo::RnullStr35 &lhs, algo::RnullStr35 & rhs) {
    bool ret = !RnullStr35_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr35..EqStrptr
inline bool algo::RnullStr35_EqStrptr(algo::RnullStr35 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr36::operator ==(const algo::RnullStr36 &rhs) const {
    return algo::RnullStr36_Eq(const_cast<algo::RnullStr36&>(*this),const_cast<algo::RnullStr36&>(rhs));
}

inline bool algo::RnullStr36::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr36_EqStrptr(const_cast<algo::RnullStr36&>(*this),rhs);
}

inline bool algo::RnullStr36::operator <(const algo::RnullStr36 &rhs) const {
    return algo::RnullStr36_Lt(const_cast<algo::RnullStr36&>(*this),const_cast<algo::RnullStr36&>(rhs));
}
inline algo::RnullStr36::RnullStr36() {
    algo::RnullStr36_Init(*this);
}


// --- algo.RnullStr36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr36.ch.HashStrptr
inline u32 algo::RnullStr36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr36.ch.Init
inline void algo::ch_Init(algo::RnullStr36 &parent) {
    memset(parent.ch, 0, 36);
}

// --- algo.RnullStr36.ch.Max
// always return constant 36
inline int algo::ch_Max(algo::RnullStr36& parent) {
    (void)parent;
    return 36;
}

// --- algo.RnullStr36.ch.N
inline int algo::ch_N(const algo::RnullStr36& parent) {
    u64 ret;
    ret = 36;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr36.ch.Cast
inline algo::RnullStr36::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr36..Lt
inline bool algo::RnullStr36_Lt(algo::RnullStr36 & lhs, algo::RnullStr36 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr36..Cmp
inline i32 algo::RnullStr36_Cmp(algo::RnullStr36 & lhs, algo::RnullStr36 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr36..Init
// Set all fields to initial values.
inline void algo::RnullStr36_Init(algo::RnullStr36& parent) {
    memset(parent.ch, 0, 36);
}

// --- algo.RnullStr36..Eq
inline bool algo::RnullStr36_Eq(const algo::RnullStr36 & lhs,const algo::RnullStr36 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr36..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr36_Update(algo::RnullStr36 &lhs, algo::RnullStr36 & rhs) {
    bool ret = !RnullStr36_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr36..EqStrptr
inline bool algo::RnullStr36_EqStrptr(algo::RnullStr36 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr4::RnullStr4() {
    algo::RnullStr4_Init(*this);
}


// --- algo.RnullStr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr4.ch.HashStrptr
inline u32 algo::RnullStr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr4.ch.Init
inline void algo::ch_Init(algo::RnullStr4 &parent) {
    memset(parent.ch, 0, 4);
}

// --- algo.RnullStr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::RnullStr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.RnullStr4.ch.N
inline int algo::ch_N(const algo::RnullStr4& parent) {
    u64 ret;
    ret = 4;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr4.ch.Cast
inline algo::RnullStr4::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr4..Lt
inline bool algo::RnullStr4_Lt(algo::RnullStr4 lhs, algo::RnullStr4 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr4..Cmp
inline i32 algo::RnullStr4_Cmp(algo::RnullStr4 lhs, algo::RnullStr4 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr4..Init
// Set all fields to initial values.
inline void algo::RnullStr4_Init(algo::RnullStr4& parent) {
    memset(parent.ch, 0, 4);
}

// --- algo.RnullStr4..Eq
inline bool algo::RnullStr4_Eq(algo::RnullStr4 lhs, algo::RnullStr4 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr4..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr4_Update(algo::RnullStr4 &lhs, algo::RnullStr4 rhs) {
    bool ret = !RnullStr4_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr4..EqStrptr
inline bool algo::RnullStr4_EqStrptr(algo::RnullStr4 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr40::operator ==(const algo::RnullStr40 &rhs) const {
    return algo::RnullStr40_Eq(const_cast<algo::RnullStr40&>(*this),const_cast<algo::RnullStr40&>(rhs));
}

inline bool algo::RnullStr40::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr40_EqStrptr(const_cast<algo::RnullStr40&>(*this),rhs);
}

inline bool algo::RnullStr40::operator <(const algo::RnullStr40 &rhs) const {
    return algo::RnullStr40_Lt(const_cast<algo::RnullStr40&>(*this),const_cast<algo::RnullStr40&>(rhs));
}
inline algo::RnullStr40::RnullStr40() {
    algo::RnullStr40_Init(*this);
}


// --- algo.RnullStr40.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr40& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr40.ch.HashStrptr
inline u32 algo::RnullStr40_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr40.ch.Init
inline void algo::ch_Init(algo::RnullStr40 &parent) {
    memset(parent.ch, 0, 40);
}

// --- algo.RnullStr40.ch.Max
// always return constant 40
inline int algo::ch_Max(algo::RnullStr40& parent) {
    (void)parent;
    return 40;
}

// --- algo.RnullStr40.ch.N
inline int algo::ch_N(const algo::RnullStr40& parent) {
    u64 ret;
    ret = 40;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr40.ch.Cast
inline algo::RnullStr40::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr40..Lt
inline bool algo::RnullStr40_Lt(algo::RnullStr40 & lhs, algo::RnullStr40 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr40..Cmp
inline i32 algo::RnullStr40_Cmp(algo::RnullStr40 & lhs, algo::RnullStr40 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr40..Init
// Set all fields to initial values.
inline void algo::RnullStr40_Init(algo::RnullStr40& parent) {
    memset(parent.ch, 0, 40);
}

// --- algo.RnullStr40..Eq
inline bool algo::RnullStr40_Eq(const algo::RnullStr40 & lhs,const algo::RnullStr40 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr40..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr40_Update(algo::RnullStr40 &lhs, algo::RnullStr40 & rhs) {
    bool ret = !RnullStr40_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr40..EqStrptr
inline bool algo::RnullStr40_EqStrptr(algo::RnullStr40 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr41::operator ==(const algo::RnullStr41 &rhs) const {
    return algo::RnullStr41_Eq(const_cast<algo::RnullStr41&>(*this),const_cast<algo::RnullStr41&>(rhs));
}

inline bool algo::RnullStr41::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr41_EqStrptr(const_cast<algo::RnullStr41&>(*this),rhs);
}

inline bool algo::RnullStr41::operator <(const algo::RnullStr41 &rhs) const {
    return algo::RnullStr41_Lt(const_cast<algo::RnullStr41&>(*this),const_cast<algo::RnullStr41&>(rhs));
}
inline algo::RnullStr41::RnullStr41() {
    algo::RnullStr41_Init(*this);
}


// --- algo.RnullStr41.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr41& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr41.ch.HashStrptr
inline u32 algo::RnullStr41_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr41.ch.Init
inline void algo::ch_Init(algo::RnullStr41 &parent) {
    memset(parent.ch, 0, 41);
}

// --- algo.RnullStr41.ch.Max
// always return constant 41
inline int algo::ch_Max(algo::RnullStr41& parent) {
    (void)parent;
    return 41;
}

// --- algo.RnullStr41.ch.N
inline int algo::ch_N(const algo::RnullStr41& parent) {
    u64 ret;
    ret = 41;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr41.ch.Cast
inline algo::RnullStr41::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr41..Lt
inline bool algo::RnullStr41_Lt(algo::RnullStr41 & lhs, algo::RnullStr41 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr41..Cmp
inline i32 algo::RnullStr41_Cmp(algo::RnullStr41 & lhs, algo::RnullStr41 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr41..Init
// Set all fields to initial values.
inline void algo::RnullStr41_Init(algo::RnullStr41& parent) {
    memset(parent.ch, 0, 41);
}

// --- algo.RnullStr41..Eq
inline bool algo::RnullStr41_Eq(const algo::RnullStr41 & lhs,const algo::RnullStr41 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr41..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr41_Update(algo::RnullStr41 &lhs, algo::RnullStr41 & rhs) {
    bool ret = !RnullStr41_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr41..EqStrptr
inline bool algo::RnullStr41_EqStrptr(algo::RnullStr41 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr43::RnullStr43() {
    algo::RnullStr43_Init(*this);
}


// --- algo.RnullStr43.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr43& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr43.ch.HashStrptr
inline u32 algo::RnullStr43_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr43.ch.Init
inline void algo::ch_Init(algo::RnullStr43 &parent) {
    memset(parent.ch, 0, 43);
}

// --- algo.RnullStr43.ch.Max
// always return constant 43
inline int algo::ch_Max(algo::RnullStr43& parent) {
    (void)parent;
    return 43;
}

// --- algo.RnullStr43.ch.N
inline int algo::ch_N(const algo::RnullStr43& parent) {
    u64 ret;
    ret = 43;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr43.ch.Cast
inline algo::RnullStr43::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr43..Lt
inline bool algo::RnullStr43_Lt(algo::RnullStr43 & lhs, algo::RnullStr43 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr43..Cmp
inline i32 algo::RnullStr43_Cmp(algo::RnullStr43 & lhs, algo::RnullStr43 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr43..Init
// Set all fields to initial values.
inline void algo::RnullStr43_Init(algo::RnullStr43& parent) {
    memset(parent.ch, 0, 43);
}

// --- algo.RnullStr43..Eq
inline bool algo::RnullStr43_Eq(const algo::RnullStr43 & lhs,const algo::RnullStr43 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr43..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr43_Update(algo::RnullStr43 &lhs, algo::RnullStr43 & rhs) {
    bool ret = !RnullStr43_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr43..EqStrptr
inline bool algo::RnullStr43_EqStrptr(algo::RnullStr43 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr44::RnullStr44() {
    algo::RnullStr44_Init(*this);
}


// --- algo.RnullStr44.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr44& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr44.ch.HashStrptr
inline u32 algo::RnullStr44_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr44.ch.Init
inline void algo::ch_Init(algo::RnullStr44 &parent) {
    memset(parent.ch, 0, 44);
}

// --- algo.RnullStr44.ch.Max
// always return constant 44
inline int algo::ch_Max(algo::RnullStr44& parent) {
    (void)parent;
    return 44;
}

// --- algo.RnullStr44.ch.N
inline int algo::ch_N(const algo::RnullStr44& parent) {
    u64 ret;
    ret = 44;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr44.ch.Cast
inline algo::RnullStr44::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr44..Lt
inline bool algo::RnullStr44_Lt(algo::RnullStr44 & lhs, algo::RnullStr44 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr44..Cmp
inline i32 algo::RnullStr44_Cmp(algo::RnullStr44 & lhs, algo::RnullStr44 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr44..Init
// Set all fields to initial values.
inline void algo::RnullStr44_Init(algo::RnullStr44& parent) {
    memset(parent.ch, 0, 44);
}

// --- algo.RnullStr44..Eq
inline bool algo::RnullStr44_Eq(const algo::RnullStr44 & lhs,const algo::RnullStr44 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr44..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr44_Update(algo::RnullStr44 &lhs, algo::RnullStr44 & rhs) {
    bool ret = !RnullStr44_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr44..EqStrptr
inline bool algo::RnullStr44_EqStrptr(algo::RnullStr44 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr48::RnullStr48() {
    algo::RnullStr48_Init(*this);
}


// --- algo.RnullStr48.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr48& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr48.ch.HashStrptr
inline u32 algo::RnullStr48_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr48.ch.Init
inline void algo::ch_Init(algo::RnullStr48 &parent) {
    memset(parent.ch, 0, 48);
}

// --- algo.RnullStr48.ch.Max
// always return constant 48
inline int algo::ch_Max(algo::RnullStr48& parent) {
    (void)parent;
    return 48;
}

// --- algo.RnullStr48.ch.N
inline int algo::ch_N(const algo::RnullStr48& parent) {
    u64 ret;
    ret = 48;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr48.ch.Cast
inline algo::RnullStr48::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr48..Lt
inline bool algo::RnullStr48_Lt(algo::RnullStr48 & lhs, algo::RnullStr48 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr48..Cmp
inline i32 algo::RnullStr48_Cmp(algo::RnullStr48 & lhs, algo::RnullStr48 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr48..Init
// Set all fields to initial values.
inline void algo::RnullStr48_Init(algo::RnullStr48& parent) {
    memset(parent.ch, 0, 48);
}

// --- algo.RnullStr48..Eq
inline bool algo::RnullStr48_Eq(const algo::RnullStr48 & lhs,const algo::RnullStr48 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr48..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr48_Update(algo::RnullStr48 &lhs, algo::RnullStr48 & rhs) {
    bool ret = !RnullStr48_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr48..EqStrptr
inline bool algo::RnullStr48_EqStrptr(algo::RnullStr48 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr5::RnullStr5() {
    algo::RnullStr5_Init(*this);
}


// --- algo.RnullStr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr5.ch.HashStrptr
inline u32 algo::RnullStr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr5.ch.Init
inline void algo::ch_Init(algo::RnullStr5 &parent) {
    memset(parent.ch, 0, 5);
}

// --- algo.RnullStr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::RnullStr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.RnullStr5.ch.N
inline int algo::ch_N(const algo::RnullStr5& parent) {
    u64 ret;
    ret = 5;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr5.ch.Cast
inline algo::RnullStr5::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr5..Lt
inline bool algo::RnullStr5_Lt(algo::RnullStr5 lhs, algo::RnullStr5 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr5..Cmp
inline i32 algo::RnullStr5_Cmp(algo::RnullStr5 lhs, algo::RnullStr5 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr5..Init
// Set all fields to initial values.
inline void algo::RnullStr5_Init(algo::RnullStr5& parent) {
    memset(parent.ch, 0, 5);
}

// --- algo.RnullStr5..Eq
inline bool algo::RnullStr5_Eq(algo::RnullStr5 lhs, algo::RnullStr5 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr5..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr5_Update(algo::RnullStr5 &lhs, algo::RnullStr5 rhs) {
    bool ret = !RnullStr5_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr5..EqStrptr
inline bool algo::RnullStr5_EqStrptr(algo::RnullStr5 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr50::RnullStr50() {
    algo::RnullStr50_Init(*this);
}


// --- algo.RnullStr50.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr50& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr50.ch.HashStrptr
inline u32 algo::RnullStr50_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr50.ch.Init
inline void algo::ch_Init(algo::RnullStr50 &parent) {
    memset(parent.ch, 0, 50);
}

// --- algo.RnullStr50.ch.Max
// always return constant 50
inline int algo::ch_Max(algo::RnullStr50& parent) {
    (void)parent;
    return 50;
}

// --- algo.RnullStr50.ch.N
inline int algo::ch_N(const algo::RnullStr50& parent) {
    u64 ret;
    ret = 50;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr50.ch.Cast
inline algo::RnullStr50::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr50..Lt
inline bool algo::RnullStr50_Lt(algo::RnullStr50 & lhs, algo::RnullStr50 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr50..Cmp
inline i32 algo::RnullStr50_Cmp(algo::RnullStr50 & lhs, algo::RnullStr50 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr50..Init
// Set all fields to initial values.
inline void algo::RnullStr50_Init(algo::RnullStr50& parent) {
    memset(parent.ch, 0, 50);
}

// --- algo.RnullStr50..Eq
inline bool algo::RnullStr50_Eq(const algo::RnullStr50 & lhs,const algo::RnullStr50 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr50..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr50_Update(algo::RnullStr50 &lhs, algo::RnullStr50 & rhs) {
    bool ret = !RnullStr50_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr50..EqStrptr
inline bool algo::RnullStr50_EqStrptr(algo::RnullStr50 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr54::operator ==(const algo::RnullStr54 &rhs) const {
    return algo::RnullStr54_Eq(const_cast<algo::RnullStr54&>(*this),const_cast<algo::RnullStr54&>(rhs));
}

inline bool algo::RnullStr54::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr54_EqStrptr(const_cast<algo::RnullStr54&>(*this),rhs);
}

inline bool algo::RnullStr54::operator <(const algo::RnullStr54 &rhs) const {
    return algo::RnullStr54_Lt(const_cast<algo::RnullStr54&>(*this),const_cast<algo::RnullStr54&>(rhs));
}
inline algo::RnullStr54::RnullStr54() {
    algo::RnullStr54_Init(*this);
}


// --- algo.RnullStr54.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr54& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr54.ch.HashStrptr
inline u32 algo::RnullStr54_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr54.ch.Init
inline void algo::ch_Init(algo::RnullStr54 &parent) {
    memset(parent.ch, 0, 54);
}

// --- algo.RnullStr54.ch.Max
// always return constant 54
inline int algo::ch_Max(algo::RnullStr54& parent) {
    (void)parent;
    return 54;
}

// --- algo.RnullStr54.ch.N
inline int algo::ch_N(const algo::RnullStr54& parent) {
    u64 ret;
    ret = 54;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr54.ch.Cast
inline algo::RnullStr54::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr54..Lt
inline bool algo::RnullStr54_Lt(algo::RnullStr54 & lhs, algo::RnullStr54 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr54..Cmp
inline i32 algo::RnullStr54_Cmp(algo::RnullStr54 & lhs, algo::RnullStr54 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr54..Init
// Set all fields to initial values.
inline void algo::RnullStr54_Init(algo::RnullStr54& parent) {
    memset(parent.ch, 0, 54);
}

// --- algo.RnullStr54..Eq
inline bool algo::RnullStr54_Eq(const algo::RnullStr54 & lhs,const algo::RnullStr54 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr54..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr54_Update(algo::RnullStr54 &lhs, algo::RnullStr54 & rhs) {
    bool ret = !RnullStr54_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr54..EqStrptr
inline bool algo::RnullStr54_EqStrptr(algo::RnullStr54 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr55::RnullStr55() {
    algo::RnullStr55_Init(*this);
}


// --- algo.RnullStr55.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr55& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr55.ch.HashStrptr
inline u32 algo::RnullStr55_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr55.ch.Init
inline void algo::ch_Init(algo::RnullStr55 &parent) {
    memset(parent.ch, 0, 55);
}

// --- algo.RnullStr55.ch.Max
// always return constant 55
inline int algo::ch_Max(algo::RnullStr55& parent) {
    (void)parent;
    return 55;
}

// --- algo.RnullStr55.ch.N
inline int algo::ch_N(const algo::RnullStr55& parent) {
    u64 ret;
    ret = 55;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr55.ch.Cast
inline algo::RnullStr55::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr55..Lt
inline bool algo::RnullStr55_Lt(algo::RnullStr55 & lhs, algo::RnullStr55 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr55..Cmp
inline i32 algo::RnullStr55_Cmp(algo::RnullStr55 & lhs, algo::RnullStr55 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr55..Init
// Set all fields to initial values.
inline void algo::RnullStr55_Init(algo::RnullStr55& parent) {
    memset(parent.ch, 0, 55);
}

// --- algo.RnullStr55..Eq
inline bool algo::RnullStr55_Eq(const algo::RnullStr55 & lhs,const algo::RnullStr55 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr55..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr55_Update(algo::RnullStr55 &lhs, algo::RnullStr55 & rhs) {
    bool ret = !RnullStr55_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr55..EqStrptr
inline bool algo::RnullStr55_EqStrptr(algo::RnullStr55 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr6::operator ==(const algo::RnullStr6 &rhs) const {
    return algo::RnullStr6_Eq(const_cast<algo::RnullStr6&>(*this),const_cast<algo::RnullStr6&>(rhs));
}

inline bool algo::RnullStr6::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr6_EqStrptr(const_cast<algo::RnullStr6&>(*this),rhs);
}

inline bool algo::RnullStr6::operator <(const algo::RnullStr6 &rhs) const {
    return algo::RnullStr6_Lt(const_cast<algo::RnullStr6&>(*this),const_cast<algo::RnullStr6&>(rhs));
}
inline algo::RnullStr6::RnullStr6() {
    algo::RnullStr6_Init(*this);
}


// --- algo.RnullStr6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr6.ch.HashStrptr
inline u32 algo::RnullStr6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr6.ch.Init
inline void algo::ch_Init(algo::RnullStr6 &parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::RnullStr6& parent) {
    (void)parent;
    return 6;
}

// --- algo.RnullStr6.ch.N
inline int algo::ch_N(const algo::RnullStr6& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr6.ch.Cast
inline algo::RnullStr6::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr6..Lt
inline bool algo::RnullStr6_Lt(algo::RnullStr6 lhs, algo::RnullStr6 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr6..Cmp
inline i32 algo::RnullStr6_Cmp(algo::RnullStr6 lhs, algo::RnullStr6 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr6..Init
// Set all fields to initial values.
inline void algo::RnullStr6_Init(algo::RnullStr6& parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6..Eq
inline bool algo::RnullStr6_Eq(algo::RnullStr6 lhs, algo::RnullStr6 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr6..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr6_Update(algo::RnullStr6 &lhs, algo::RnullStr6 rhs) {
    bool ret = !RnullStr6_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr6..EqStrptr
inline bool algo::RnullStr6_EqStrptr(algo::RnullStr6 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr60::operator ==(const algo::RnullStr60 &rhs) const {
    return algo::RnullStr60_Eq(const_cast<algo::RnullStr60&>(*this),const_cast<algo::RnullStr60&>(rhs));
}

inline bool algo::RnullStr60::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr60_EqStrptr(const_cast<algo::RnullStr60&>(*this),rhs);
}

inline bool algo::RnullStr60::operator <(const algo::RnullStr60 &rhs) const {
    return algo::RnullStr60_Lt(const_cast<algo::RnullStr60&>(*this),const_cast<algo::RnullStr60&>(rhs));
}
inline algo::RnullStr60::RnullStr60() {
    algo::RnullStr60_Init(*this);
}


// --- algo.RnullStr60.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr60& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr60.ch.HashStrptr
inline u32 algo::RnullStr60_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr60.ch.Init
inline void algo::ch_Init(algo::RnullStr60 &parent) {
    memset(parent.ch, 0, 60);
}

// --- algo.RnullStr60.ch.Max
// always return constant 60
inline int algo::ch_Max(algo::RnullStr60& parent) {
    (void)parent;
    return 60;
}

// --- algo.RnullStr60.ch.N
inline int algo::ch_N(const algo::RnullStr60& parent) {
    u64 ret;
    ret = 60;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr60.ch.Cast
inline algo::RnullStr60::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr60..Lt
inline bool algo::RnullStr60_Lt(algo::RnullStr60 & lhs, algo::RnullStr60 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr60..Cmp
inline i32 algo::RnullStr60_Cmp(algo::RnullStr60 & lhs, algo::RnullStr60 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr60..Init
// Set all fields to initial values.
inline void algo::RnullStr60_Init(algo::RnullStr60& parent) {
    memset(parent.ch, 0, 60);
}

// --- algo.RnullStr60..Eq
inline bool algo::RnullStr60_Eq(const algo::RnullStr60 & lhs,const algo::RnullStr60 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr60..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr60_Update(algo::RnullStr60 &lhs, algo::RnullStr60 & rhs) {
    bool ret = !RnullStr60_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr60..EqStrptr
inline bool algo::RnullStr60_EqStrptr(algo::RnullStr60 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr62::operator ==(const algo::RnullStr62 &rhs) const {
    return algo::RnullStr62_Eq(const_cast<algo::RnullStr62&>(*this),const_cast<algo::RnullStr62&>(rhs));
}

inline bool algo::RnullStr62::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr62_EqStrptr(const_cast<algo::RnullStr62&>(*this),rhs);
}

inline bool algo::RnullStr62::operator <(const algo::RnullStr62 &rhs) const {
    return algo::RnullStr62_Lt(const_cast<algo::RnullStr62&>(*this),const_cast<algo::RnullStr62&>(rhs));
}
inline algo::RnullStr62::RnullStr62() {
    algo::RnullStr62_Init(*this);
}


// --- algo.RnullStr62.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr62& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr62.ch.HashStrptr
inline u32 algo::RnullStr62_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr62.ch.Init
inline void algo::ch_Init(algo::RnullStr62 &parent) {
    memset(parent.ch, 0, 62);
}

// --- algo.RnullStr62.ch.Max
// always return constant 62
inline int algo::ch_Max(algo::RnullStr62& parent) {
    (void)parent;
    return 62;
}

// --- algo.RnullStr62.ch.N
inline int algo::ch_N(const algo::RnullStr62& parent) {
    u64 ret;
    ret = 62;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr62.ch.Cast
inline algo::RnullStr62::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr62..Lt
inline bool algo::RnullStr62_Lt(algo::RnullStr62 & lhs, algo::RnullStr62 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr62..Cmp
inline i32 algo::RnullStr62_Cmp(algo::RnullStr62 & lhs, algo::RnullStr62 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr62..Init
// Set all fields to initial values.
inline void algo::RnullStr62_Init(algo::RnullStr62& parent) {
    memset(parent.ch, 0, 62);
}

// --- algo.RnullStr62..Eq
inline bool algo::RnullStr62_Eq(const algo::RnullStr62 & lhs,const algo::RnullStr62 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr62..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr62_Update(algo::RnullStr62 &lhs, algo::RnullStr62 & rhs) {
    bool ret = !RnullStr62_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr62..EqStrptr
inline bool algo::RnullStr62_EqStrptr(algo::RnullStr62 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr66::RnullStr66() {
    algo::RnullStr66_Init(*this);
}


// --- algo.RnullStr66.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr66& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr66.ch.HashStrptr
inline u32 algo::RnullStr66_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr66.ch.Init
inline void algo::ch_Init(algo::RnullStr66 &parent) {
    memset(parent.ch, 0, 66);
}

// --- algo.RnullStr66.ch.Max
// always return constant 66
inline int algo::ch_Max(algo::RnullStr66& parent) {
    (void)parent;
    return 66;
}

// --- algo.RnullStr66.ch.N
inline int algo::ch_N(const algo::RnullStr66& parent) {
    u64 ret;
    ret = 66;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr66.ch.Cast
inline algo::RnullStr66::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr66..Lt
inline bool algo::RnullStr66_Lt(algo::RnullStr66 & lhs, algo::RnullStr66 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr66..Cmp
inline i32 algo::RnullStr66_Cmp(algo::RnullStr66 & lhs, algo::RnullStr66 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr66..Init
// Set all fields to initial values.
inline void algo::RnullStr66_Init(algo::RnullStr66& parent) {
    memset(parent.ch, 0, 66);
}

// --- algo.RnullStr66..Eq
inline bool algo::RnullStr66_Eq(const algo::RnullStr66 & lhs,const algo::RnullStr66 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr66..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr66_Update(algo::RnullStr66 &lhs, algo::RnullStr66 & rhs) {
    bool ret = !RnullStr66_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr66..EqStrptr
inline bool algo::RnullStr66_EqStrptr(algo::RnullStr66 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr6_U32::operator ==(const algo::RnullStr6_U32 &rhs) const {
    return algo::RnullStr6_U32_Eq(const_cast<algo::RnullStr6_U32&>(*this),const_cast<algo::RnullStr6_U32&>(rhs));
}

inline bool algo::RnullStr6_U32::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr6_U32_EqStrptr(const_cast<algo::RnullStr6_U32&>(*this),rhs);
}
inline algo::RnullStr6_U32::RnullStr6_U32() {
    algo::RnullStr6_U32_Init(*this);
}


// --- algo.RnullStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr6_U32.ch.HashStrptr
inline u32 algo::RnullStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr6_U32.ch.Init
inline void algo::ch_Init(algo::RnullStr6_U32 &parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6_U32.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::RnullStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- algo.RnullStr6_U32.ch.N
inline int algo::ch_N(const algo::RnullStr6_U32& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr6_U32.ch.Cast
inline algo::RnullStr6_U32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr6_U32..Cmp
inline i32 algo::RnullStr6_U32_Cmp(algo::RnullStr6_U32 & lhs, algo::RnullStr6_U32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr6_U32..Init
// Set all fields to initial values.
inline void algo::RnullStr6_U32_Init(algo::RnullStr6_U32& parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6_U32..Eq
inline bool algo::RnullStr6_U32_Eq(const algo::RnullStr6_U32 & lhs,const algo::RnullStr6_U32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr6_U32..EqStrptr
inline bool algo::RnullStr6_U32_EqStrptr(algo::RnullStr6_U32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr7::operator ==(const algo::RnullStr7 &rhs) const {
    return algo::RnullStr7_Eq(const_cast<algo::RnullStr7&>(*this),const_cast<algo::RnullStr7&>(rhs));
}

inline bool algo::RnullStr7::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr7_EqStrptr(const_cast<algo::RnullStr7&>(*this),rhs);
}

inline bool algo::RnullStr7::operator <(const algo::RnullStr7 &rhs) const {
    return algo::RnullStr7_Lt(const_cast<algo::RnullStr7&>(*this),const_cast<algo::RnullStr7&>(rhs));
}
inline algo::RnullStr7::RnullStr7() {
    algo::RnullStr7_Init(*this);
}


// --- algo.RnullStr7.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr7& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr7.ch.HashStrptr
inline u32 algo::RnullStr7_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr7.ch.Init
inline void algo::ch_Init(algo::RnullStr7 &parent) {
    memset(parent.ch, 0, 7);
}

// --- algo.RnullStr7.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::RnullStr7& parent) {
    (void)parent;
    return 7;
}

// --- algo.RnullStr7.ch.N
inline int algo::ch_N(const algo::RnullStr7& parent) {
    u64 ret;
    ret = 7;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr7.ch.Cast
inline algo::RnullStr7::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr7..Lt
inline bool algo::RnullStr7_Lt(algo::RnullStr7 lhs, algo::RnullStr7 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr7..Cmp
inline i32 algo::RnullStr7_Cmp(algo::RnullStr7 lhs, algo::RnullStr7 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr7..Init
// Set all fields to initial values.
inline void algo::RnullStr7_Init(algo::RnullStr7& parent) {
    memset(parent.ch, 0, 7);
}

// --- algo.RnullStr7..Eq
inline bool algo::RnullStr7_Eq(algo::RnullStr7 lhs, algo::RnullStr7 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr7..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr7_Update(algo::RnullStr7 &lhs, algo::RnullStr7 rhs) {
    bool ret = !RnullStr7_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr7..EqStrptr
inline bool algo::RnullStr7_EqStrptr(algo::RnullStr7 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr8::RnullStr8() {
    algo::RnullStr8_Init(*this);
}


// --- algo.RnullStr8.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr8& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr8.ch.HashStrptr
inline u32 algo::RnullStr8_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr8.ch.Init
inline void algo::ch_Init(algo::RnullStr8 &parent) {
    memset(parent.ch, 0, 8);
}

// --- algo.RnullStr8.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::RnullStr8& parent) {
    (void)parent;
    return 8;
}

// --- algo.RnullStr8.ch.N
inline int algo::ch_N(const algo::RnullStr8& parent) {
    u64 ret;
    ret = 8;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr8.ch.Cast
inline algo::RnullStr8::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr8..Lt
inline bool algo::RnullStr8_Lt(algo::RnullStr8 lhs, algo::RnullStr8 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr8..Cmp
inline i32 algo::RnullStr8_Cmp(algo::RnullStr8 lhs, algo::RnullStr8 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr8..Init
// Set all fields to initial values.
inline void algo::RnullStr8_Init(algo::RnullStr8& parent) {
    memset(parent.ch, 0, 8);
}

// --- algo.RnullStr8..Eq
inline bool algo::RnullStr8_Eq(algo::RnullStr8 lhs, algo::RnullStr8 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr8..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr8_Update(algo::RnullStr8 &lhs, algo::RnullStr8 rhs) {
    bool ret = !RnullStr8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr8..EqStrptr
inline bool algo::RnullStr8_EqStrptr(algo::RnullStr8 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RnullStr80::RnullStr80() {
    algo::RnullStr80_Init(*this);
}


// --- algo.RnullStr80.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr80& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr80.ch.HashStrptr
inline u32 algo::RnullStr80_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr80.ch.Init
inline void algo::ch_Init(algo::RnullStr80 &parent) {
    memset(parent.ch, 0, 80);
}

// --- algo.RnullStr80.ch.Max
// always return constant 80
inline int algo::ch_Max(algo::RnullStr80& parent) {
    (void)parent;
    return 80;
}

// --- algo.RnullStr80.ch.N
inline int algo::ch_N(const algo::RnullStr80& parent) {
    u64 ret;
    ret = 80;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr80.ch.Cast
inline algo::RnullStr80::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr80..Lt
inline bool algo::RnullStr80_Lt(algo::RnullStr80 & lhs, algo::RnullStr80 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr80..Cmp
inline i32 algo::RnullStr80_Cmp(algo::RnullStr80 & lhs, algo::RnullStr80 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr80..Init
// Set all fields to initial values.
inline void algo::RnullStr80_Init(algo::RnullStr80& parent) {
    memset(parent.ch, 0, 80);
}

// --- algo.RnullStr80..Eq
inline bool algo::RnullStr80_Eq(const algo::RnullStr80 & lhs,const algo::RnullStr80 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr80..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr80_Update(algo::RnullStr80 &lhs, algo::RnullStr80 & rhs) {
    bool ret = !RnullStr80_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr80..EqStrptr
inline bool algo::RnullStr80_EqStrptr(algo::RnullStr80 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RnullStr9::operator ==(const algo::RnullStr9 &rhs) const {
    return algo::RnullStr9_Eq(const_cast<algo::RnullStr9&>(*this),const_cast<algo::RnullStr9&>(rhs));
}

inline bool algo::RnullStr9::operator ==(const algo::strptr &rhs) const {
    return algo::RnullStr9_EqStrptr(const_cast<algo::RnullStr9&>(*this),rhs);
}

inline bool algo::RnullStr9::operator <(const algo::RnullStr9 &rhs) const {
    return algo::RnullStr9_Lt(const_cast<algo::RnullStr9&>(*this),const_cast<algo::RnullStr9&>(rhs));
}
inline algo::RnullStr9::RnullStr9() {
    algo::RnullStr9_Init(*this);
}


// --- algo.RnullStr9.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr9& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr9.ch.HashStrptr
inline u32 algo::RnullStr9_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr9.ch.Init
inline void algo::ch_Init(algo::RnullStr9 &parent) {
    memset(parent.ch, 0, 9);
}

// --- algo.RnullStr9.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::RnullStr9& parent) {
    (void)parent;
    return 9;
}

// --- algo.RnullStr9.ch.N
inline int algo::ch_N(const algo::RnullStr9& parent) {
    u64 ret;
    ret = 9;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr9.ch.Cast
inline algo::RnullStr9::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RnullStr9..Lt
inline bool algo::RnullStr9_Lt(algo::RnullStr9 & lhs, algo::RnullStr9 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr9..Cmp
inline i32 algo::RnullStr9_Cmp(algo::RnullStr9 & lhs, algo::RnullStr9 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr9..Init
// Set all fields to initial values.
inline void algo::RnullStr9_Init(algo::RnullStr9& parent) {
    memset(parent.ch, 0, 9);
}

// --- algo.RnullStr9..Eq
inline bool algo::RnullStr9_Eq(const algo::RnullStr9 & lhs,const algo::RnullStr9 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr9..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr9_Update(algo::RnullStr9 &lhs, algo::RnullStr9 & rhs) {
    bool ret = !RnullStr9_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr9..EqStrptr
inline bool algo::RnullStr9_EqStrptr(algo::RnullStr9 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr10::operator ==(const algo::RspaceStr10 &rhs) const {
    return algo::RspaceStr10_Eq(const_cast<algo::RspaceStr10&>(*this),const_cast<algo::RspaceStr10&>(rhs));
}

inline bool algo::RspaceStr10::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr10_EqStrptr(const_cast<algo::RspaceStr10&>(*this),rhs);
}
inline algo::RspaceStr10::RspaceStr10() {
    algo::RspaceStr10_Init(*this);
}


// --- algo.RspaceStr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr10.ch.HashStrptr
inline u32 algo::RspaceStr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr10.ch.Init
inline void algo::ch_Init(algo::RspaceStr10 &parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.RspaceStr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::RspaceStr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.RspaceStr10.ch.N
inline int algo::ch_N(const algo::RspaceStr10& parent) {
    u64 ret;
    ret = 10;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr10.ch.Cast
inline algo::RspaceStr10::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr10..Cmp
inline i32 algo::RspaceStr10_Cmp(algo::RspaceStr10 & lhs, algo::RspaceStr10 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr10..Init
// Set all fields to initial values.
inline void algo::RspaceStr10_Init(algo::RspaceStr10& parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.RspaceStr10..Eq
inline bool algo::RspaceStr10_Eq(const algo::RspaceStr10 & lhs,const algo::RspaceStr10 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr10..EqStrptr
inline bool algo::RspaceStr10_EqStrptr(algo::RspaceStr10 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr100::operator ==(const algo::RspaceStr100 &rhs) const {
    return algo::RspaceStr100_Eq(const_cast<algo::RspaceStr100&>(*this),const_cast<algo::RspaceStr100&>(rhs));
}

inline bool algo::RspaceStr100::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr100_EqStrptr(const_cast<algo::RspaceStr100&>(*this),rhs);
}
inline algo::RspaceStr100::RspaceStr100() {
    algo::RspaceStr100_Init(*this);
}


// --- algo.RspaceStr100.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr100& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr100.ch.HashStrptr
inline u32 algo::RspaceStr100_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr100.ch.Init
inline void algo::ch_Init(algo::RspaceStr100 &parent) {
    memset(parent.ch, ' ', 100);
}

// --- algo.RspaceStr100.ch.Max
// always return constant 100
inline int algo::ch_Max(algo::RspaceStr100& parent) {
    (void)parent;
    return 100;
}

// --- algo.RspaceStr100.ch.N
inline int algo::ch_N(const algo::RspaceStr100& parent) {
    u64 ret;
    ret = 100;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr100.ch.Cast
inline algo::RspaceStr100::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr100..Cmp
inline i32 algo::RspaceStr100_Cmp(algo::RspaceStr100 & lhs, algo::RspaceStr100 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr100..Init
// Set all fields to initial values.
inline void algo::RspaceStr100_Init(algo::RspaceStr100& parent) {
    memset(parent.ch, ' ', 100);
}

// --- algo.RspaceStr100..Eq
inline bool algo::RspaceStr100_Eq(const algo::RspaceStr100 & lhs,const algo::RspaceStr100 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr100..EqStrptr
inline bool algo::RspaceStr100_EqStrptr(algo::RspaceStr100 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr11::operator ==(const algo::RspaceStr11 &rhs) const {
    return algo::RspaceStr11_Eq(const_cast<algo::RspaceStr11&>(*this),const_cast<algo::RspaceStr11&>(rhs));
}

inline bool algo::RspaceStr11::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr11_EqStrptr(const_cast<algo::RspaceStr11&>(*this),rhs);
}
inline algo::RspaceStr11::RspaceStr11() {
    algo::RspaceStr11_Init(*this);
}


// --- algo.RspaceStr11.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr11& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr11.ch.HashStrptr
inline u32 algo::RspaceStr11_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr11.ch.Init
inline void algo::ch_Init(algo::RspaceStr11 &parent) {
    memset(parent.ch, ' ', 11);
}

// --- algo.RspaceStr11.ch.Max
// always return constant 11
inline int algo::ch_Max(algo::RspaceStr11& parent) {
    (void)parent;
    return 11;
}

// --- algo.RspaceStr11.ch.N
inline int algo::ch_N(const algo::RspaceStr11& parent) {
    u64 ret;
    ret = 11;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr11.ch.Cast
inline algo::RspaceStr11::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr11..Cmp
inline i32 algo::RspaceStr11_Cmp(algo::RspaceStr11 & lhs, algo::RspaceStr11 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr11..Init
// Set all fields to initial values.
inline void algo::RspaceStr11_Init(algo::RspaceStr11& parent) {
    memset(parent.ch, ' ', 11);
}

// --- algo.RspaceStr11..Eq
inline bool algo::RspaceStr11_Eq(const algo::RspaceStr11 & lhs,const algo::RspaceStr11 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr11..EqStrptr
inline bool algo::RspaceStr11_EqStrptr(algo::RspaceStr11 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RspaceStr16::RspaceStr16() {
    algo::RspaceStr16_Init(*this);
}


// --- algo.RspaceStr16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr16.ch.HashStrptr
inline u32 algo::RspaceStr16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr16.ch.Init
inline void algo::ch_Init(algo::RspaceStr16 &parent) {
    memset(parent.ch, ' ', 16);
}

// --- algo.RspaceStr16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::RspaceStr16& parent) {
    (void)parent;
    return 16;
}

// --- algo.RspaceStr16.ch.N
inline int algo::ch_N(const algo::RspaceStr16& parent) {
    u64 ret;
    ret = 16;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr16.ch.Cast
inline algo::RspaceStr16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr16..Lt
inline bool algo::RspaceStr16_Lt(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr16..Cmp
inline i32 algo::RspaceStr16_Cmp(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr16..Init
// Set all fields to initial values.
inline void algo::RspaceStr16_Init(algo::RspaceStr16& parent) {
    memset(parent.ch, ' ', 16);
}

// --- algo.RspaceStr16..Eq
inline bool algo::RspaceStr16_Eq(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr16..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr16_Update(algo::RspaceStr16 &lhs, algo::RspaceStr16 rhs) {
    bool ret = !RspaceStr16_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr16..EqStrptr
inline bool algo::RspaceStr16_EqStrptr(algo::RspaceStr16 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr2::operator ==(const algo::RspaceStr2 &rhs) const {
    return algo::RspaceStr2_Eq(const_cast<algo::RspaceStr2&>(*this),const_cast<algo::RspaceStr2&>(rhs));
}

inline bool algo::RspaceStr2::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr2_EqStrptr(const_cast<algo::RspaceStr2&>(*this),rhs);
}
inline algo::RspaceStr2::RspaceStr2() {
    algo::RspaceStr2_Init(*this);
}


// --- algo.RspaceStr2.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr2& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr2.ch.HashStrptr
inline u32 algo::RspaceStr2_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr2.ch.Init
inline void algo::ch_Init(algo::RspaceStr2 &parent) {
    memset(parent.ch, ' ', 2);
}

// --- algo.RspaceStr2.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::RspaceStr2& parent) {
    (void)parent;
    return 2;
}

// --- algo.RspaceStr2.ch.N
inline int algo::ch_N(const algo::RspaceStr2& parent) {
    u64 ret;
    ret = 2;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr2.ch.Cast
inline algo::RspaceStr2::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr2..Cmp
inline i32 algo::RspaceStr2_Cmp(algo::RspaceStr2 lhs, algo::RspaceStr2 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr2..Init
// Set all fields to initial values.
inline void algo::RspaceStr2_Init(algo::RspaceStr2& parent) {
    memset(parent.ch, ' ', 2);
}

// --- algo.RspaceStr2..Eq
inline bool algo::RspaceStr2_Eq(algo::RspaceStr2 lhs, algo::RspaceStr2 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr2..EqStrptr
inline bool algo::RspaceStr2_EqStrptr(algo::RspaceStr2 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr20::operator ==(const algo::RspaceStr20 &rhs) const {
    return algo::RspaceStr20_Eq(const_cast<algo::RspaceStr20&>(*this),const_cast<algo::RspaceStr20&>(rhs));
}

inline bool algo::RspaceStr20::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr20_EqStrptr(const_cast<algo::RspaceStr20&>(*this),rhs);
}
inline algo::RspaceStr20::RspaceStr20() {
    algo::RspaceStr20_Init(*this);
}


// --- algo.RspaceStr20.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr20& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr20.ch.HashStrptr
inline u32 algo::RspaceStr20_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr20.ch.Init
inline void algo::ch_Init(algo::RspaceStr20 &parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.RspaceStr20.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::RspaceStr20& parent) {
    (void)parent;
    return 20;
}

// --- algo.RspaceStr20.ch.N
inline int algo::ch_N(const algo::RspaceStr20& parent) {
    u64 ret;
    ret = 20;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr20.ch.Cast
inline algo::RspaceStr20::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr20..Cmp
inline i32 algo::RspaceStr20_Cmp(algo::RspaceStr20 & lhs, algo::RspaceStr20 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr20..Init
// Set all fields to initial values.
inline void algo::RspaceStr20_Init(algo::RspaceStr20& parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.RspaceStr20..Eq
inline bool algo::RspaceStr20_Eq(const algo::RspaceStr20 & lhs,const algo::RspaceStr20 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr20..EqStrptr
inline bool algo::RspaceStr20_EqStrptr(algo::RspaceStr20 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr200::operator ==(const algo::RspaceStr200 &rhs) const {
    return algo::RspaceStr200_Eq(const_cast<algo::RspaceStr200&>(*this),const_cast<algo::RspaceStr200&>(rhs));
}

inline bool algo::RspaceStr200::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr200_EqStrptr(const_cast<algo::RspaceStr200&>(*this),rhs);
}
inline algo::RspaceStr200::RspaceStr200() {
    algo::RspaceStr200_Init(*this);
}


// --- algo.RspaceStr200.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr200& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr200.ch.HashStrptr
inline u32 algo::RspaceStr200_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr200.ch.Init
inline void algo::ch_Init(algo::RspaceStr200 &parent) {
    memset(parent.ch, ' ', 200);
}

// --- algo.RspaceStr200.ch.Max
// always return constant 200
inline int algo::ch_Max(algo::RspaceStr200& parent) {
    (void)parent;
    return 200;
}

// --- algo.RspaceStr200.ch.N
inline int algo::ch_N(const algo::RspaceStr200& parent) {
    u64 ret;
    ret = 200;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr200.ch.Cast
inline algo::RspaceStr200::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr200..Cmp
inline i32 algo::RspaceStr200_Cmp(algo::RspaceStr200 & lhs, algo::RspaceStr200 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr200..Init
// Set all fields to initial values.
inline void algo::RspaceStr200_Init(algo::RspaceStr200& parent) {
    memset(parent.ch, ' ', 200);
}

// --- algo.RspaceStr200..Eq
inline bool algo::RspaceStr200_Eq(const algo::RspaceStr200 & lhs,const algo::RspaceStr200 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr200..EqStrptr
inline bool algo::RspaceStr200_EqStrptr(algo::RspaceStr200 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr21::operator ==(const algo::RspaceStr21 &rhs) const {
    return algo::RspaceStr21_Eq(const_cast<algo::RspaceStr21&>(*this),const_cast<algo::RspaceStr21&>(rhs));
}

inline bool algo::RspaceStr21::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr21_EqStrptr(const_cast<algo::RspaceStr21&>(*this),rhs);
}
inline algo::RspaceStr21::RspaceStr21() {
    algo::RspaceStr21_Init(*this);
}


// --- algo.RspaceStr21.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr21& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr21.ch.HashStrptr
inline u32 algo::RspaceStr21_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr21.ch.Init
inline void algo::ch_Init(algo::RspaceStr21 &parent) {
    memset(parent.ch, ' ', 21);
}

// --- algo.RspaceStr21.ch.Max
// always return constant 21
inline int algo::ch_Max(algo::RspaceStr21& parent) {
    (void)parent;
    return 21;
}

// --- algo.RspaceStr21.ch.N
inline int algo::ch_N(const algo::RspaceStr21& parent) {
    u64 ret;
    ret = 21;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr21.ch.Cast
inline algo::RspaceStr21::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr21..Cmp
inline i32 algo::RspaceStr21_Cmp(algo::RspaceStr21 & lhs, algo::RspaceStr21 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr21..Init
// Set all fields to initial values.
inline void algo::RspaceStr21_Init(algo::RspaceStr21& parent) {
    memset(parent.ch, ' ', 21);
}

// --- algo.RspaceStr21..Eq
inline bool algo::RspaceStr21_Eq(const algo::RspaceStr21 & lhs,const algo::RspaceStr21 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr21..EqStrptr
inline bool algo::RspaceStr21_EqStrptr(algo::RspaceStr21 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RspaceStr24::RspaceStr24() {
    algo::RspaceStr24_Init(*this);
}


// --- algo.RspaceStr24.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr24& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr24.ch.HashStrptr
inline u32 algo::RspaceStr24_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr24.ch.Init
inline void algo::ch_Init(algo::RspaceStr24 &parent) {
    memset(parent.ch, ' ', 24);
}

// --- algo.RspaceStr24.ch.Max
// always return constant 24
inline int algo::ch_Max(algo::RspaceStr24& parent) {
    (void)parent;
    return 24;
}

// --- algo.RspaceStr24.ch.N
inline int algo::ch_N(const algo::RspaceStr24& parent) {
    u64 ret;
    ret = 24;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr24.ch.Cast
inline algo::RspaceStr24::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr24..Lt
inline bool algo::RspaceStr24_Lt(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr24..Cmp
inline i32 algo::RspaceStr24_Cmp(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr24..Init
// Set all fields to initial values.
inline void algo::RspaceStr24_Init(algo::RspaceStr24& parent) {
    memset(parent.ch, ' ', 24);
}

// --- algo.RspaceStr24..Eq
inline bool algo::RspaceStr24_Eq(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr24..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr24_Update(algo::RspaceStr24 &lhs, algo::RspaceStr24 rhs) {
    bool ret = !RspaceStr24_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr24..EqStrptr
inline bool algo::RspaceStr24_EqStrptr(algo::RspaceStr24 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr240::operator ==(const algo::RspaceStr240 &rhs) const {
    return algo::RspaceStr240_Eq(const_cast<algo::RspaceStr240&>(*this),const_cast<algo::RspaceStr240&>(rhs));
}

inline bool algo::RspaceStr240::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr240_EqStrptr(const_cast<algo::RspaceStr240&>(*this),rhs);
}
inline algo::RspaceStr240::RspaceStr240() {
    algo::RspaceStr240_Init(*this);
}


// --- algo.RspaceStr240.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr240& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr240.ch.HashStrptr
inline u32 algo::RspaceStr240_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr240.ch.Init
inline void algo::ch_Init(algo::RspaceStr240 &parent) {
    memset(parent.ch, ' ', 240);
}

// --- algo.RspaceStr240.ch.Max
// always return constant 240
inline int algo::ch_Max(algo::RspaceStr240& parent) {
    (void)parent;
    return 240;
}

// --- algo.RspaceStr240.ch.N
inline int algo::ch_N(const algo::RspaceStr240& parent) {
    u64 ret;
    ret = 240;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr240.ch.Cast
inline algo::RspaceStr240::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr240..Cmp
inline i32 algo::RspaceStr240_Cmp(algo::RspaceStr240 & lhs, algo::RspaceStr240 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr240..Init
// Set all fields to initial values.
inline void algo::RspaceStr240_Init(algo::RspaceStr240& parent) {
    memset(parent.ch, ' ', 240);
}

// --- algo.RspaceStr240..Eq
inline bool algo::RspaceStr240_Eq(const algo::RspaceStr240 & lhs,const algo::RspaceStr240 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr240..EqStrptr
inline bool algo::RspaceStr240_EqStrptr(algo::RspaceStr240 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr26::operator ==(const algo::RspaceStr26 &rhs) const {
    return algo::RspaceStr26_Eq(const_cast<algo::RspaceStr26&>(*this),const_cast<algo::RspaceStr26&>(rhs));
}

inline bool algo::RspaceStr26::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr26_EqStrptr(const_cast<algo::RspaceStr26&>(*this),rhs);
}
inline algo::RspaceStr26::RspaceStr26() {
    algo::RspaceStr26_Init(*this);
}


// --- algo.RspaceStr26.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr26& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr26.ch.HashStrptr
inline u32 algo::RspaceStr26_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr26.ch.Init
inline void algo::ch_Init(algo::RspaceStr26 &parent) {
    memset(parent.ch, ' ', 26);
}

// --- algo.RspaceStr26.ch.Max
// always return constant 26
inline int algo::ch_Max(algo::RspaceStr26& parent) {
    (void)parent;
    return 26;
}

// --- algo.RspaceStr26.ch.N
inline int algo::ch_N(const algo::RspaceStr26& parent) {
    u64 ret;
    ret = 26;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr26.ch.Cast
inline algo::RspaceStr26::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr26..Cmp
inline i32 algo::RspaceStr26_Cmp(algo::RspaceStr26 & lhs, algo::RspaceStr26 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr26..Init
// Set all fields to initial values.
inline void algo::RspaceStr26_Init(algo::RspaceStr26& parent) {
    memset(parent.ch, ' ', 26);
}

// --- algo.RspaceStr26..Eq
inline bool algo::RspaceStr26_Eq(const algo::RspaceStr26 & lhs,const algo::RspaceStr26 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr26..EqStrptr
inline bool algo::RspaceStr26_EqStrptr(algo::RspaceStr26 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr3::operator ==(const algo::RspaceStr3 &rhs) const {
    return algo::RspaceStr3_Eq(const_cast<algo::RspaceStr3&>(*this),const_cast<algo::RspaceStr3&>(rhs));
}

inline bool algo::RspaceStr3::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr3_EqStrptr(const_cast<algo::RspaceStr3&>(*this),rhs);
}
inline algo::RspaceStr3::RspaceStr3() {
    algo::RspaceStr3_Init(*this);
}


// --- algo.RspaceStr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr3.ch.HashStrptr
inline u32 algo::RspaceStr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr3.ch.Init
inline void algo::ch_Init(algo::RspaceStr3 &parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.RspaceStr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::RspaceStr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.RspaceStr3.ch.N
inline int algo::ch_N(const algo::RspaceStr3& parent) {
    u64 ret;
    ret = 3;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr3.ch.Cast
inline algo::RspaceStr3::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr3..Cmp
inline i32 algo::RspaceStr3_Cmp(algo::RspaceStr3 & lhs, algo::RspaceStr3 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr3..Init
// Set all fields to initial values.
inline void algo::RspaceStr3_Init(algo::RspaceStr3& parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.RspaceStr3..Eq
inline bool algo::RspaceStr3_Eq(const algo::RspaceStr3 & lhs,const algo::RspaceStr3 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr3..EqStrptr
inline bool algo::RspaceStr3_EqStrptr(algo::RspaceStr3 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr31::operator ==(const algo::RspaceStr31 &rhs) const {
    return algo::RspaceStr31_Eq(const_cast<algo::RspaceStr31&>(*this),const_cast<algo::RspaceStr31&>(rhs));
}

inline bool algo::RspaceStr31::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr31_EqStrptr(const_cast<algo::RspaceStr31&>(*this),rhs);
}
inline algo::RspaceStr31::RspaceStr31() {
    algo::RspaceStr31_Init(*this);
}


// --- algo.RspaceStr31.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr31& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr31.ch.HashStrptr
inline u32 algo::RspaceStr31_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr31.ch.Init
inline void algo::ch_Init(algo::RspaceStr31 &parent) {
    memset(parent.ch, ' ', 31);
}

// --- algo.RspaceStr31.ch.Max
// always return constant 31
inline int algo::ch_Max(algo::RspaceStr31& parent) {
    (void)parent;
    return 31;
}

// --- algo.RspaceStr31.ch.N
inline int algo::ch_N(const algo::RspaceStr31& parent) {
    u64 ret;
    ret = 31;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr31.ch.Cast
inline algo::RspaceStr31::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr31..Cmp
inline i32 algo::RspaceStr31_Cmp(algo::RspaceStr31 & lhs, algo::RspaceStr31 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr31..Init
// Set all fields to initial values.
inline void algo::RspaceStr31_Init(algo::RspaceStr31& parent) {
    memset(parent.ch, ' ', 31);
}

// --- algo.RspaceStr31..Eq
inline bool algo::RspaceStr31_Eq(const algo::RspaceStr31 & lhs,const algo::RspaceStr31 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr31..EqStrptr
inline bool algo::RspaceStr31_EqStrptr(algo::RspaceStr31 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr32::operator ==(const algo::RspaceStr32 &rhs) const {
    return algo::RspaceStr32_Eq(const_cast<algo::RspaceStr32&>(*this),const_cast<algo::RspaceStr32&>(rhs));
}

inline bool algo::RspaceStr32::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr32_EqStrptr(const_cast<algo::RspaceStr32&>(*this),rhs);
}
inline algo::RspaceStr32::RspaceStr32() {
    algo::RspaceStr32_Init(*this);
}


// --- algo.RspaceStr32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr32.ch.HashStrptr
inline u32 algo::RspaceStr32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr32.ch.Init
inline void algo::ch_Init(algo::RspaceStr32 &parent) {
    memset(parent.ch, ' ', 32);
}

// --- algo.RspaceStr32.ch.Max
// always return constant 32
inline int algo::ch_Max(algo::RspaceStr32& parent) {
    (void)parent;
    return 32;
}

// --- algo.RspaceStr32.ch.N
inline int algo::ch_N(const algo::RspaceStr32& parent) {
    u64 ret;
    ret = 32;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr32.ch.Cast
inline algo::RspaceStr32::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr32..Cmp
inline i32 algo::RspaceStr32_Cmp(algo::RspaceStr32 & lhs, algo::RspaceStr32 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr32..Init
// Set all fields to initial values.
inline void algo::RspaceStr32_Init(algo::RspaceStr32& parent) {
    memset(parent.ch, ' ', 32);
}

// --- algo.RspaceStr32..Eq
inline bool algo::RspaceStr32_Eq(const algo::RspaceStr32 & lhs,const algo::RspaceStr32 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr32..EqStrptr
inline bool algo::RspaceStr32_EqStrptr(algo::RspaceStr32 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr4::operator ==(const algo::RspaceStr4 &rhs) const {
    return algo::RspaceStr4_Eq(const_cast<algo::RspaceStr4&>(*this),const_cast<algo::RspaceStr4&>(rhs));
}

inline bool algo::RspaceStr4::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr4_EqStrptr(const_cast<algo::RspaceStr4&>(*this),rhs);
}
inline algo::RspaceStr4::RspaceStr4() {
    algo::RspaceStr4_Init(*this);
}


// --- algo.RspaceStr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr4.ch.HashStrptr
inline u32 algo::RspaceStr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr4.ch.Init
inline void algo::ch_Init(algo::RspaceStr4 &parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.RspaceStr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::RspaceStr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.RspaceStr4.ch.N
inline int algo::ch_N(const algo::RspaceStr4& parent) {
    u64 ret;
    ret = 4;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr4.ch.Cast
inline algo::RspaceStr4::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr4..Cmp
inline i32 algo::RspaceStr4_Cmp(algo::RspaceStr4 lhs, algo::RspaceStr4 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr4..Init
// Set all fields to initial values.
inline void algo::RspaceStr4_Init(algo::RspaceStr4& parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.RspaceStr4..Eq
inline bool algo::RspaceStr4_Eq(algo::RspaceStr4 lhs, algo::RspaceStr4 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr4..EqStrptr
inline bool algo::RspaceStr4_EqStrptr(algo::RspaceStr4 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RspaceStr40::RspaceStr40() {
    algo::RspaceStr40_Init(*this);
}


// --- algo.RspaceStr40.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr40& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr40.ch.HashStrptr
inline u32 algo::RspaceStr40_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr40.ch.Init
inline void algo::ch_Init(algo::RspaceStr40 &parent) {
    memset(parent.ch, ' ', 40);
}

// --- algo.RspaceStr40.ch.Max
// always return constant 40
inline int algo::ch_Max(algo::RspaceStr40& parent) {
    (void)parent;
    return 40;
}

// --- algo.RspaceStr40.ch.N
inline int algo::ch_N(const algo::RspaceStr40& parent) {
    u64 ret;
    ret = 40;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr40.ch.Cast
inline algo::RspaceStr40::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr40..Cmp
inline i32 algo::RspaceStr40_Cmp(algo::RspaceStr40 & lhs, algo::RspaceStr40 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr40..Init
// Set all fields to initial values.
inline void algo::RspaceStr40_Init(algo::RspaceStr40& parent) {
    memset(parent.ch, ' ', 40);
}

// --- algo.RspaceStr40..Eq
inline bool algo::RspaceStr40_Eq(const algo::RspaceStr40 & lhs,const algo::RspaceStr40 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr40..EqStrptr
inline bool algo::RspaceStr40_EqStrptr(algo::RspaceStr40 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr5::operator ==(const algo::RspaceStr5 &rhs) const {
    return algo::RspaceStr5_Eq(const_cast<algo::RspaceStr5&>(*this),const_cast<algo::RspaceStr5&>(rhs));
}

inline bool algo::RspaceStr5::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr5_EqStrptr(const_cast<algo::RspaceStr5&>(*this),rhs);
}
inline algo::RspaceStr5::RspaceStr5() {
    algo::RspaceStr5_Init(*this);
}


// --- algo.RspaceStr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr5.ch.HashStrptr
inline u32 algo::RspaceStr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr5.ch.Init
inline void algo::ch_Init(algo::RspaceStr5 &parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.RspaceStr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::RspaceStr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.RspaceStr5.ch.N
inline int algo::ch_N(const algo::RspaceStr5& parent) {
    u64 ret;
    ret = 5;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr5.ch.Cast
inline algo::RspaceStr5::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr5..Cmp
inline i32 algo::RspaceStr5_Cmp(algo::RspaceStr5 lhs, algo::RspaceStr5 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr5..Init
// Set all fields to initial values.
inline void algo::RspaceStr5_Init(algo::RspaceStr5& parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.RspaceStr5..Eq
inline bool algo::RspaceStr5_Eq(algo::RspaceStr5 lhs, algo::RspaceStr5 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr5..EqStrptr
inline bool algo::RspaceStr5_EqStrptr(algo::RspaceStr5 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr50::operator ==(const algo::RspaceStr50 &rhs) const {
    return algo::RspaceStr50_Eq(const_cast<algo::RspaceStr50&>(*this),const_cast<algo::RspaceStr50&>(rhs));
}

inline bool algo::RspaceStr50::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr50_EqStrptr(const_cast<algo::RspaceStr50&>(*this),rhs);
}
inline algo::RspaceStr50::RspaceStr50() {
    algo::RspaceStr50_Init(*this);
}


// --- algo.RspaceStr50.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr50& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr50.ch.HashStrptr
inline u32 algo::RspaceStr50_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr50.ch.Init
inline void algo::ch_Init(algo::RspaceStr50 &parent) {
    memset(parent.ch, ' ', 50);
}

// --- algo.RspaceStr50.ch.Max
// always return constant 50
inline int algo::ch_Max(algo::RspaceStr50& parent) {
    (void)parent;
    return 50;
}

// --- algo.RspaceStr50.ch.N
inline int algo::ch_N(const algo::RspaceStr50& parent) {
    u64 ret;
    ret = 50;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr50.ch.Cast
inline algo::RspaceStr50::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr50..Cmp
inline i32 algo::RspaceStr50_Cmp(algo::RspaceStr50 & lhs, algo::RspaceStr50 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr50..Init
// Set all fields to initial values.
inline void algo::RspaceStr50_Init(algo::RspaceStr50& parent) {
    memset(parent.ch, ' ', 50);
}

// --- algo.RspaceStr50..Eq
inline bool algo::RspaceStr50_Eq(const algo::RspaceStr50 & lhs,const algo::RspaceStr50 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr50..EqStrptr
inline bool algo::RspaceStr50_EqStrptr(algo::RspaceStr50 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr6::operator ==(const algo::RspaceStr6 &rhs) const {
    return algo::RspaceStr6_Eq(const_cast<algo::RspaceStr6&>(*this),const_cast<algo::RspaceStr6&>(rhs));
}

inline bool algo::RspaceStr6::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr6_EqStrptr(const_cast<algo::RspaceStr6&>(*this),rhs);
}

inline bool algo::RspaceStr6::operator <(const algo::RspaceStr6 &rhs) const {
    return algo::RspaceStr6_Lt(const_cast<algo::RspaceStr6&>(*this),const_cast<algo::RspaceStr6&>(rhs));
}
inline algo::RspaceStr6::RspaceStr6() {
    algo::RspaceStr6_Init(*this);
}


// --- algo.RspaceStr6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr6.ch.HashStrptr
inline u32 algo::RspaceStr6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr6.ch.Init
inline void algo::ch_Init(algo::RspaceStr6 &parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.RspaceStr6.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::RspaceStr6& parent) {
    (void)parent;
    return 6;
}

// --- algo.RspaceStr6.ch.N
inline int algo::ch_N(const algo::RspaceStr6& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr6.ch.Cast
inline algo::RspaceStr6::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr6..Lt
inline bool algo::RspaceStr6_Lt(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr6..Cmp
inline i32 algo::RspaceStr6_Cmp(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr6..Init
// Set all fields to initial values.
inline void algo::RspaceStr6_Init(algo::RspaceStr6& parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.RspaceStr6..Eq
inline bool algo::RspaceStr6_Eq(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr6..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr6_Update(algo::RspaceStr6 &lhs, algo::RspaceStr6 rhs) {
    bool ret = !RspaceStr6_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr6..EqStrptr
inline bool algo::RspaceStr6_EqStrptr(algo::RspaceStr6 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr64::operator ==(const algo::RspaceStr64 &rhs) const {
    return algo::RspaceStr64_Eq(const_cast<algo::RspaceStr64&>(*this),const_cast<algo::RspaceStr64&>(rhs));
}

inline bool algo::RspaceStr64::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr64_EqStrptr(const_cast<algo::RspaceStr64&>(*this),rhs);
}
inline algo::RspaceStr64::RspaceStr64() {
    algo::RspaceStr64_Init(*this);
}


// --- algo.RspaceStr64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr64.ch.HashStrptr
inline u32 algo::RspaceStr64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr64.ch.Init
inline void algo::ch_Init(algo::RspaceStr64 &parent) {
    memset(parent.ch, ' ', 64);
}

// --- algo.RspaceStr64.ch.Max
// always return constant 64
inline int algo::ch_Max(algo::RspaceStr64& parent) {
    (void)parent;
    return 64;
}

// --- algo.RspaceStr64.ch.N
inline int algo::ch_N(const algo::RspaceStr64& parent) {
    u64 ret;
    ret = 64;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr64.ch.Cast
inline algo::RspaceStr64::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr64..Cmp
inline i32 algo::RspaceStr64_Cmp(algo::RspaceStr64 & lhs, algo::RspaceStr64 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr64..Init
// Set all fields to initial values.
inline void algo::RspaceStr64_Init(algo::RspaceStr64& parent) {
    memset(parent.ch, ' ', 64);
}

// --- algo.RspaceStr64..Eq
inline bool algo::RspaceStr64_Eq(const algo::RspaceStr64 & lhs,const algo::RspaceStr64 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr64..EqStrptr
inline bool algo::RspaceStr64_EqStrptr(algo::RspaceStr64 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr7::operator ==(const algo::RspaceStr7 &rhs) const {
    return algo::RspaceStr7_Eq(const_cast<algo::RspaceStr7&>(*this),const_cast<algo::RspaceStr7&>(rhs));
}

inline bool algo::RspaceStr7::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr7_EqStrptr(const_cast<algo::RspaceStr7&>(*this),rhs);
}
inline algo::RspaceStr7::RspaceStr7() {
    algo::RspaceStr7_Init(*this);
}


// --- algo.RspaceStr7.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr7& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr7.ch.HashStrptr
inline u32 algo::RspaceStr7_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr7.ch.Init
inline void algo::ch_Init(algo::RspaceStr7 &parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.RspaceStr7.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::RspaceStr7& parent) {
    (void)parent;
    return 7;
}

// --- algo.RspaceStr7.ch.N
inline int algo::ch_N(const algo::RspaceStr7& parent) {
    u64 ret;
    ret = 7;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr7.ch.Cast
inline algo::RspaceStr7::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr7..Cmp
inline i32 algo::RspaceStr7_Cmp(algo::RspaceStr7 lhs, algo::RspaceStr7 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr7..Init
// Set all fields to initial values.
inline void algo::RspaceStr7_Init(algo::RspaceStr7& parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.RspaceStr7..Eq
inline bool algo::RspaceStr7_Eq(algo::RspaceStr7 lhs, algo::RspaceStr7 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr7..EqStrptr
inline bool algo::RspaceStr7_EqStrptr(algo::RspaceStr7 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::RspaceStr8::RspaceStr8() {
    algo::RspaceStr8_Init(*this);
}


// --- algo.RspaceStr8.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr8& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr8.ch.HashStrptr
inline u32 algo::RspaceStr8_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr8.ch.Init
inline void algo::ch_Init(algo::RspaceStr8 &parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.RspaceStr8.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::RspaceStr8& parent) {
    (void)parent;
    return 8;
}

// --- algo.RspaceStr8.ch.N
inline int algo::ch_N(const algo::RspaceStr8& parent) {
    u64 ret;
    ret = 8;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr8.ch.Cast
inline algo::RspaceStr8::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr8..Lt
inline bool algo::RspaceStr8_Lt(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr8..Cmp
inline i32 algo::RspaceStr8_Cmp(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr8..Init
// Set all fields to initial values.
inline void algo::RspaceStr8_Init(algo::RspaceStr8& parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.RspaceStr8..Eq
inline bool algo::RspaceStr8_Eq(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr8..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr8_Update(algo::RspaceStr8 &lhs, algo::RspaceStr8 rhs) {
    bool ret = !RspaceStr8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr8..EqStrptr
inline bool algo::RspaceStr8_EqStrptr(algo::RspaceStr8 lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::RspaceStr9::operator ==(const algo::RspaceStr9 &rhs) const {
    return algo::RspaceStr9_Eq(const_cast<algo::RspaceStr9&>(*this),const_cast<algo::RspaceStr9&>(rhs));
}

inline bool algo::RspaceStr9::operator ==(const algo::strptr &rhs) const {
    return algo::RspaceStr9_EqStrptr(const_cast<algo::RspaceStr9&>(*this),rhs);
}
inline algo::RspaceStr9::RspaceStr9() {
    algo::RspaceStr9_Init(*this);
}


// --- algo.RspaceStr9.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr9& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr9.ch.HashStrptr
inline u32 algo::RspaceStr9_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr9.ch.Init
inline void algo::ch_Init(algo::RspaceStr9 &parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.RspaceStr9.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::RspaceStr9& parent) {
    (void)parent;
    return 9;
}

// --- algo.RspaceStr9.ch.N
inline int algo::ch_N(const algo::RspaceStr9& parent) {
    u64 ret;
    ret = 9;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr9.ch.Cast
inline algo::RspaceStr9::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr9..Cmp
inline i32 algo::RspaceStr9_Cmp(algo::RspaceStr9 & lhs, algo::RspaceStr9 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr9..Init
// Set all fields to initial values.
inline void algo::RspaceStr9_Init(algo::RspaceStr9& parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.RspaceStr9..Eq
inline bool algo::RspaceStr9_Eq(const algo::RspaceStr9 & lhs,const algo::RspaceStr9 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr9..EqStrptr
inline bool algo::RspaceStr9_EqStrptr(algo::RspaceStr9 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::SeqType::SeqType(u64                            in_value)
    : value(in_value)
{
}
inline algo::SeqType::SeqType() {
    algo::SeqType_Init(*this);
}


// --- algo.SeqType.value.Cast
inline algo::SeqType::operator u64 () const {
    return u64((*this).value);
}

// --- algo.SeqType..Hash
inline u32 algo::SeqType_Hash(u32 prev, algo::SeqType rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.SeqType..Lt
inline bool algo::SeqType_Lt(algo::SeqType lhs, algo::SeqType rhs) {
    return u64_Lt(lhs.value, rhs.value);
}

// --- algo.SeqType..Cmp
inline i32 algo::SeqType_Cmp(algo::SeqType lhs, algo::SeqType rhs) {
    i32 retval = 0;
    retval = u64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.SeqType..Init
// Set all fields to initial values.
inline void algo::SeqType_Init(algo::SeqType& parent) {
    parent.value = u64(0);
}

// --- algo.SeqType..Eq
inline bool algo::SeqType_Eq(algo::SeqType lhs, algo::SeqType rhs) {
    bool retval = true;
    retval = u64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.SeqType..Update
// Set value. Return true if new value is different from old value.
inline bool algo::SeqType_Update(algo::SeqType &lhs, algo::SeqType rhs) {
    bool ret = !SeqType_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline bool algo::Sha1sig::operator ==(const algo::Sha1sig &rhs) const {
    return algo::Sha1sig_Eq(const_cast<algo::Sha1sig&>(*this),const_cast<algo::Sha1sig&>(rhs));
}

inline bool algo::Sha1sig::operator <(const algo::Sha1sig &rhs) const {
    return algo::Sha1sig_Lt(const_cast<algo::Sha1sig&>(*this),const_cast<algo::Sha1sig&>(rhs));
}
inline algo::Sha1sig::Sha1sig() {
    algo::Sha1sig_Init(*this);
}


// --- algo.Sha1sig.sha1sig.Fill
// Set all elements of fixed array to value RHS
inline void algo::sha1sig_Fill(algo::Sha1sig& parent, const u8 &rhs) {
    for (int i = 0; i < 20; i++) {
        parent.sha1sig_elems[i] = rhs;
    }
}

// --- algo.Sha1sig.sha1sig.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::sha1sig_Find(algo::Sha1sig& parent, u64 t) {
    u64 idx = t;
    u64 lim = 20;
    return idx < lim ? parent.sha1sig_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Sha1sig.sha1sig.Getary
// Access fixed array sha1sig as aryptr.
inline algo::aryptr<u8> algo::sha1sig_Getary(algo::Sha1sig& parent) {
    return algo::aryptr<u8>(parent.sha1sig_elems, 20);
}

// --- algo.Sha1sig.sha1sig.Max
// Return max number of items in the array
inline i32 algo::sha1sig_Max(algo::Sha1sig& parent) {
    (void)parent;
    return 20;
}

// --- algo.Sha1sig.sha1sig.N
// Return number of items in the array
inline i32 algo::sha1sig_N(const algo::Sha1sig& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 20;
}

// --- algo.Sha1sig.sha1sig.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::sha1sig_Setary(algo::Sha1sig& parent, const algo::aryptr<u8> &rhs) {
    int n = 20 < rhs.n_elems ? 20 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        parent.sha1sig_elems[i] = rhs[i];
    }
}

// --- algo.Sha1sig.sha1sig.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u8& algo::sha1sig_qFind(algo::Sha1sig& parent, u64 t) {
    return parent.sha1sig_elems[t];
}

// --- algo.Sha1sig.sha1sig_curs.Reset
// cursor points to valid item
inline void algo::Sha1sig_sha1sig_curs_Reset(Sha1sig_sha1sig_curs &curs, algo::Sha1sig &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Sha1sig.sha1sig_curs.ValidQ
// cursor points to valid item
inline bool algo::Sha1sig_sha1sig_curs_ValidQ(Sha1sig_sha1sig_curs &curs) {
    return u64(curs.index) < u64(20);
}

// --- algo.Sha1sig.sha1sig_curs.Next
// proceed to next item
inline void algo::Sha1sig_sha1sig_curs_Next(Sha1sig_sha1sig_curs &curs) {
    curs.index++;
}

// --- algo.Sha1sig.sha1sig_curs.Access
// item access
inline u8& algo::Sha1sig_sha1sig_curs_Access(Sha1sig_sha1sig_curs &curs) {
    return sha1sig_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Sha1sig..Lt
inline bool algo::Sha1sig_Lt(algo::Sha1sig & lhs, algo::Sha1sig & rhs) {
    return sha1sig_Cmp(lhs,rhs) < 0;
}

// --- algo.Sha1sig..Cmp
inline i32 algo::Sha1sig_Cmp(algo::Sha1sig & lhs, algo::Sha1sig & rhs) {
    i32 retval = 0;
    retval = sha1sig_Cmp(lhs,rhs);
    return retval;
}

// --- algo.Sha1sig..Init
// Set all fields to initial values.
inline void algo::Sha1sig_Init(algo::Sha1sig& parent) {
    for (int i = 0; i < 20; i++) {
        parent.sha1sig_elems[i] = 0;
    }
}

// --- algo.Sha1sig..Eq
inline bool algo::Sha1sig_Eq(const algo::Sha1sig & lhs,const algo::Sha1sig & rhs) {
    bool retval = true;
    retval = sha1sig_Eq(lhs,rhs);
    return retval;
}

// --- algo.Sha1sig..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Sha1sig_Update(algo::Sha1sig &lhs, algo::Sha1sig & rhs) {
    bool ret = !Sha1sig_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline bool algo::Smallstr1::operator ==(const algo::Smallstr1 &rhs) const {
    return algo::Smallstr1_Eq(const_cast<algo::Smallstr1&>(*this),const_cast<algo::Smallstr1&>(rhs));
}

inline bool algo::Smallstr1::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr1_EqStrptr(const_cast<algo::Smallstr1&>(*this),rhs);
}
inline algo::Smallstr1::Smallstr1() {
    algo::Smallstr1_Init(*this);
}


// --- algo.Smallstr1.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr1& parent, char c) {
    if (parent.n_ch < 1) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr1.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr1& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 1) {
        n_new = 1 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr1.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr1& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr1.ch.HashStrptr
inline u32 algo::Smallstr1_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr1.ch.Init
inline void algo::ch_Init(algo::Smallstr1 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr1.ch.Max
// always return constant 1
inline int algo::ch_Max(algo::Smallstr1& parent) {
    (void)parent;
    return 1;
}

// --- algo.Smallstr1.ch.N
inline int algo::ch_N(const algo::Smallstr1& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr1.ch.Cast
inline algo::Smallstr1::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr1..Cmp
inline i32 algo::Smallstr1_Cmp(algo::Smallstr1 & lhs, algo::Smallstr1 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr1..Init
// Set all fields to initial values.
inline void algo::Smallstr1_Init(algo::Smallstr1& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr1..Eq
inline bool algo::Smallstr1_Eq(const algo::Smallstr1 & lhs,const algo::Smallstr1 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr1..EqStrptr
inline bool algo::Smallstr1_EqStrptr(algo::Smallstr1 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr10::operator ==(const algo::Smallstr10 &rhs) const {
    return algo::Smallstr10_Eq(const_cast<algo::Smallstr10&>(*this),const_cast<algo::Smallstr10&>(rhs));
}

inline bool algo::Smallstr10::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr10_EqStrptr(const_cast<algo::Smallstr10&>(*this),rhs);
}
inline algo::Smallstr10::Smallstr10() {
    algo::Smallstr10_Init(*this);
}


// --- algo.Smallstr10.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr10& parent, char c) {
    if (parent.n_ch < 10) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr10.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr10& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 10) {
        n_new = 10 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr10.ch.HashStrptr
inline u32 algo::Smallstr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr10.ch.Init
inline void algo::ch_Init(algo::Smallstr10 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::Smallstr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.Smallstr10.ch.N
inline int algo::ch_N(const algo::Smallstr10& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr10.ch.Cast
inline algo::Smallstr10::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr10..Cmp
inline i32 algo::Smallstr10_Cmp(algo::Smallstr10 & lhs, algo::Smallstr10 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr10..Init
// Set all fields to initial values.
inline void algo::Smallstr10_Init(algo::Smallstr10& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr10..Eq
inline bool algo::Smallstr10_Eq(const algo::Smallstr10 & lhs,const algo::Smallstr10 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr10..EqStrptr
inline bool algo::Smallstr10_EqStrptr(algo::Smallstr10 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::Smallstr100::Smallstr100() {
    algo::Smallstr100_Init(*this);
}


// --- algo.Smallstr100.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr100& parent, char c) {
    if (parent.n_ch < 100) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr100.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr100& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 100) {
        n_new = 100 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr100.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr100& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr100.ch.HashStrptr
inline u32 algo::Smallstr100_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr100.ch.Init
inline void algo::ch_Init(algo::Smallstr100 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr100.ch.Max
// always return constant 100
inline int algo::ch_Max(algo::Smallstr100& parent) {
    (void)parent;
    return 100;
}

// --- algo.Smallstr100.ch.N
inline int algo::ch_N(const algo::Smallstr100& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr100.ch.Cast
inline algo::Smallstr100::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr100..Cmp
inline i32 algo::Smallstr100_Cmp(algo::Smallstr100 & lhs, algo::Smallstr100 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr100..Init
// Set all fields to initial values.
inline void algo::Smallstr100_Init(algo::Smallstr100& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr100..Eq
inline bool algo::Smallstr100_Eq(const algo::Smallstr100 & lhs,const algo::Smallstr100 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr100..EqStrptr
inline bool algo::Smallstr100_EqStrptr(algo::Smallstr100 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr16::operator ==(const algo::Smallstr16 &rhs) const {
    return algo::Smallstr16_Eq(const_cast<algo::Smallstr16&>(*this),const_cast<algo::Smallstr16&>(rhs));
}

inline bool algo::Smallstr16::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr16_EqStrptr(const_cast<algo::Smallstr16&>(*this),rhs);
}
inline algo::Smallstr16::Smallstr16() {
    algo::Smallstr16_Init(*this);
}


// --- algo.Smallstr16.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr16& parent, char c) {
    if (parent.n_ch < 16) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr16.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr16& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 16) {
        n_new = 16 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr16.ch.HashStrptr
inline u32 algo::Smallstr16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr16.ch.Init
inline void algo::ch_Init(algo::Smallstr16 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::Smallstr16& parent) {
    (void)parent;
    return 16;
}

// --- algo.Smallstr16.ch.N
inline int algo::ch_N(const algo::Smallstr16& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr16.ch.Cast
inline algo::Smallstr16::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr16..Cmp
inline i32 algo::Smallstr16_Cmp(algo::Smallstr16 & lhs, algo::Smallstr16 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr16..Init
// Set all fields to initial values.
inline void algo::Smallstr16_Init(algo::Smallstr16& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr16..Eq
inline bool algo::Smallstr16_Eq(const algo::Smallstr16 & lhs,const algo::Smallstr16 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr16..EqStrptr
inline bool algo::Smallstr16_EqStrptr(algo::Smallstr16 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr2::operator ==(const algo::Smallstr2 &rhs) const {
    return algo::Smallstr2_Eq(const_cast<algo::Smallstr2&>(*this),const_cast<algo::Smallstr2&>(rhs));
}

inline bool algo::Smallstr2::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr2_EqStrptr(const_cast<algo::Smallstr2&>(*this),rhs);
}
inline algo::Smallstr2::Smallstr2() {
    algo::Smallstr2_Init(*this);
}


// --- algo.Smallstr2.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr2& parent, char c) {
    if (parent.n_ch < 2) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr2.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr2& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 2) {
        n_new = 2 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr2.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr2& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr2.ch.HashStrptr
inline u32 algo::Smallstr2_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr2.ch.Init
inline void algo::ch_Init(algo::Smallstr2 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr2.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::Smallstr2& parent) {
    (void)parent;
    return 2;
}

// --- algo.Smallstr2.ch.N
inline int algo::ch_N(const algo::Smallstr2& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr2.ch.Cast
inline algo::Smallstr2::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr2..Cmp
inline i32 algo::Smallstr2_Cmp(algo::Smallstr2 & lhs, algo::Smallstr2 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr2..Init
// Set all fields to initial values.
inline void algo::Smallstr2_Init(algo::Smallstr2& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr2..Eq
inline bool algo::Smallstr2_Eq(const algo::Smallstr2 & lhs,const algo::Smallstr2 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr2..EqStrptr
inline bool algo::Smallstr2_EqStrptr(algo::Smallstr2 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr20::operator ==(const algo::Smallstr20 &rhs) const {
    return algo::Smallstr20_Eq(const_cast<algo::Smallstr20&>(*this),const_cast<algo::Smallstr20&>(rhs));
}

inline bool algo::Smallstr20::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr20_EqStrptr(const_cast<algo::Smallstr20&>(*this),rhs);
}

inline bool algo::Smallstr20::operator <(const algo::Smallstr20 &rhs) const {
    return algo::Smallstr20_Lt(const_cast<algo::Smallstr20&>(*this),const_cast<algo::Smallstr20&>(rhs));
}
inline algo::Smallstr20::Smallstr20() {
    algo::Smallstr20_Init(*this);
}


// --- algo.Smallstr20.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr20& parent, char c) {
    if (parent.n_ch < 20) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr20.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr20& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 20) {
        n_new = 20 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr20.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr20& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr20.ch.HashStrptr
inline u32 algo::Smallstr20_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr20.ch.Init
inline void algo::ch_Init(algo::Smallstr20 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr20.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::Smallstr20& parent) {
    (void)parent;
    return 20;
}

// --- algo.Smallstr20.ch.N
inline int algo::ch_N(const algo::Smallstr20& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr20.ch.Cast
inline algo::Smallstr20::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr20..Lt
inline bool algo::Smallstr20_Lt(algo::Smallstr20 & lhs, algo::Smallstr20 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.Smallstr20..Cmp
inline i32 algo::Smallstr20_Cmp(algo::Smallstr20 & lhs, algo::Smallstr20 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr20..Init
// Set all fields to initial values.
inline void algo::Smallstr20_Init(algo::Smallstr20& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr20..Eq
inline bool algo::Smallstr20_Eq(const algo::Smallstr20 & lhs,const algo::Smallstr20 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr20..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Smallstr20_Update(algo::Smallstr20 &lhs, algo::Smallstr20 & rhs) {
    bool ret = !Smallstr20_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Smallstr20..EqStrptr
inline bool algo::Smallstr20_EqStrptr(algo::Smallstr20 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr25::operator ==(const algo::Smallstr25 &rhs) const {
    return algo::Smallstr25_Eq(const_cast<algo::Smallstr25&>(*this),const_cast<algo::Smallstr25&>(rhs));
}

inline bool algo::Smallstr25::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr25_EqStrptr(const_cast<algo::Smallstr25&>(*this),rhs);
}
inline algo::Smallstr25::Smallstr25() {
    algo::Smallstr25_Init(*this);
}


// --- algo.Smallstr25.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr25& parent, char c) {
    if (parent.n_ch < 25) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr25.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr25& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 25) {
        n_new = 25 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr25.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr25& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr25.ch.HashStrptr
inline u32 algo::Smallstr25_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr25.ch.Init
inline void algo::ch_Init(algo::Smallstr25 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr25.ch.Max
// always return constant 25
inline int algo::ch_Max(algo::Smallstr25& parent) {
    (void)parent;
    return 25;
}

// --- algo.Smallstr25.ch.N
inline int algo::ch_N(const algo::Smallstr25& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr25.ch.Cast
inline algo::Smallstr25::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr25..Cmp
inline i32 algo::Smallstr25_Cmp(algo::Smallstr25 & lhs, algo::Smallstr25 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr25..Init
// Set all fields to initial values.
inline void algo::Smallstr25_Init(algo::Smallstr25& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr25..Eq
inline bool algo::Smallstr25_Eq(const algo::Smallstr25 & lhs,const algo::Smallstr25 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr25..EqStrptr
inline bool algo::Smallstr25_EqStrptr(algo::Smallstr25 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr250::operator ==(const algo::Smallstr250 &rhs) const {
    return algo::Smallstr250_Eq(const_cast<algo::Smallstr250&>(*this),const_cast<algo::Smallstr250&>(rhs));
}

inline bool algo::Smallstr250::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr250_EqStrptr(const_cast<algo::Smallstr250&>(*this),rhs);
}
inline algo::Smallstr250::Smallstr250() {
    algo::Smallstr250_Init(*this);
}


// --- algo.Smallstr250.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr250& parent, char c) {
    if (parent.n_ch < 250) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr250.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr250& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 250) {
        n_new = 250 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr250.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr250& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr250.ch.HashStrptr
inline u32 algo::Smallstr250_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr250.ch.Init
inline void algo::ch_Init(algo::Smallstr250 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr250.ch.Max
// always return constant 250
inline int algo::ch_Max(algo::Smallstr250& parent) {
    (void)parent;
    return 250;
}

// --- algo.Smallstr250.ch.N
inline int algo::ch_N(const algo::Smallstr250& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr250.ch.Cast
inline algo::Smallstr250::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr250..Cmp
inline i32 algo::Smallstr250_Cmp(algo::Smallstr250 & lhs, algo::Smallstr250 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr250..Init
// Set all fields to initial values.
inline void algo::Smallstr250_Init(algo::Smallstr250& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr250..Eq
inline bool algo::Smallstr250_Eq(const algo::Smallstr250 & lhs,const algo::Smallstr250 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr250..EqStrptr
inline bool algo::Smallstr250_EqStrptr(algo::Smallstr250 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr30::operator ==(const algo::Smallstr30 &rhs) const {
    return algo::Smallstr30_Eq(const_cast<algo::Smallstr30&>(*this),const_cast<algo::Smallstr30&>(rhs));
}

inline bool algo::Smallstr30::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr30_EqStrptr(const_cast<algo::Smallstr30&>(*this),rhs);
}

inline bool algo::Smallstr30::operator <(const algo::Smallstr30 &rhs) const {
    return algo::Smallstr30_Lt(const_cast<algo::Smallstr30&>(*this),const_cast<algo::Smallstr30&>(rhs));
}
inline algo::Smallstr30::Smallstr30() {
    algo::Smallstr30_Init(*this);
}


// --- algo.Smallstr30.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr30& parent, char c) {
    if (parent.n_ch < 30) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr30.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr30& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 30) {
        n_new = 30 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr30.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr30& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr30.ch.HashStrptr
inline u32 algo::Smallstr30_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr30.ch.Init
inline void algo::ch_Init(algo::Smallstr30 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr30.ch.Max
// always return constant 30
inline int algo::ch_Max(algo::Smallstr30& parent) {
    (void)parent;
    return 30;
}

// --- algo.Smallstr30.ch.N
inline int algo::ch_N(const algo::Smallstr30& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr30.ch.Cast
inline algo::Smallstr30::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr30..Lt
inline bool algo::Smallstr30_Lt(algo::Smallstr30 & lhs, algo::Smallstr30 & rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.Smallstr30..Cmp
inline i32 algo::Smallstr30_Cmp(algo::Smallstr30 & lhs, algo::Smallstr30 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr30..Init
// Set all fields to initial values.
inline void algo::Smallstr30_Init(algo::Smallstr30& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr30..Eq
inline bool algo::Smallstr30_Eq(const algo::Smallstr30 & lhs,const algo::Smallstr30 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr30..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Smallstr30_Update(algo::Smallstr30 &lhs, algo::Smallstr30 & rhs) {
    bool ret = !Smallstr30_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Smallstr30..EqStrptr
inline bool algo::Smallstr30_EqStrptr(algo::Smallstr30 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr4::operator ==(const algo::Smallstr4 &rhs) const {
    return algo::Smallstr4_Eq(const_cast<algo::Smallstr4&>(*this),const_cast<algo::Smallstr4&>(rhs));
}

inline bool algo::Smallstr4::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr4_EqStrptr(const_cast<algo::Smallstr4&>(*this),rhs);
}
inline algo::Smallstr4::Smallstr4() {
    algo::Smallstr4_Init(*this);
}


// --- algo.Smallstr4.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr4& parent, char c) {
    if (parent.n_ch < 4) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr4.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr4& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 4) {
        n_new = 4 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr4.ch.HashStrptr
inline u32 algo::Smallstr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr4.ch.Init
inline void algo::ch_Init(algo::Smallstr4 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::Smallstr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.Smallstr4.ch.N
inline int algo::ch_N(const algo::Smallstr4& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr4.ch.Cast
inline algo::Smallstr4::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr4..Cmp
inline i32 algo::Smallstr4_Cmp(algo::Smallstr4 & lhs, algo::Smallstr4 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr4..Init
// Set all fields to initial values.
inline void algo::Smallstr4_Init(algo::Smallstr4& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr4..Eq
inline bool algo::Smallstr4_Eq(const algo::Smallstr4 & lhs,const algo::Smallstr4 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr4..EqStrptr
inline bool algo::Smallstr4_EqStrptr(algo::Smallstr4 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr40::operator ==(const algo::Smallstr40 &rhs) const {
    return algo::Smallstr40_Eq(const_cast<algo::Smallstr40&>(*this),const_cast<algo::Smallstr40&>(rhs));
}

inline bool algo::Smallstr40::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr40_EqStrptr(const_cast<algo::Smallstr40&>(*this),rhs);
}
inline algo::Smallstr40::Smallstr40() {
    algo::Smallstr40_Init(*this);
}


// --- algo.Smallstr40.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr40& parent, char c) {
    if (parent.n_ch < 40) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr40.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr40& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 40) {
        n_new = 40 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr40.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr40& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr40.ch.HashStrptr
inline u32 algo::Smallstr40_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr40.ch.Init
inline void algo::ch_Init(algo::Smallstr40 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr40.ch.Max
// always return constant 40
inline int algo::ch_Max(algo::Smallstr40& parent) {
    (void)parent;
    return 40;
}

// --- algo.Smallstr40.ch.N
inline int algo::ch_N(const algo::Smallstr40& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr40.ch.Cast
inline algo::Smallstr40::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr40..Cmp
inline i32 algo::Smallstr40_Cmp(algo::Smallstr40 & lhs, algo::Smallstr40 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr40..Init
// Set all fields to initial values.
inline void algo::Smallstr40_Init(algo::Smallstr40& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr40..Eq
inline bool algo::Smallstr40_Eq(const algo::Smallstr40 & lhs,const algo::Smallstr40 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr40..EqStrptr
inline bool algo::Smallstr40_EqStrptr(algo::Smallstr40 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}

inline bool algo::Smallstr5::operator ==(const algo::Smallstr5 &rhs) const {
    return algo::Smallstr5_Eq(const_cast<algo::Smallstr5&>(*this),const_cast<algo::Smallstr5&>(rhs));
}

inline bool algo::Smallstr5::operator ==(const algo::strptr &rhs) const {
    return algo::Smallstr5_EqStrptr(const_cast<algo::Smallstr5&>(*this),rhs);
}
inline algo::Smallstr5::Smallstr5() {
    algo::Smallstr5_Init(*this);
}


// --- algo.Smallstr5.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr5& parent, char c) {
    if (parent.n_ch < 5) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr5.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr5& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 5) {
        n_new = 5 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr5.ch.HashStrptr
inline u32 algo::Smallstr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr5.ch.Init
inline void algo::ch_Init(algo::Smallstr5 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::Smallstr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.Smallstr5.ch.N
inline int algo::ch_N(const algo::Smallstr5& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr5.ch.Cast
inline algo::Smallstr5::operator algo::strptr () const {
    return ch_Getary(*this);
}

// --- algo.Smallstr5..Cmp
inline i32 algo::Smallstr5_Cmp(algo::Smallstr5 & lhs, algo::Smallstr5 & rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr5..Init
// Set all fields to initial values.
inline void algo::Smallstr5_Init(algo::Smallstr5& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr5..Eq
inline bool algo::Smallstr5_Eq(const algo::Smallstr5 & lhs,const algo::Smallstr5 & rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr5..EqStrptr
inline bool algo::Smallstr5_EqStrptr(algo::Smallstr5 & lhs, const algo::strptr &rhs) {
    return algo::strptr_Eq(ch_Getary(lhs), rhs);
}
inline algo::TermStyle::TermStyle(u32                            in_value)
    : value(in_value)
{
}
inline algo::TermStyle::TermStyle(algo_TermStyleEnum arg) { this->value = u32(arg); }
inline algo::TermStyle::TermStyle() {
    algo::TermStyle_Init(*this);
}


// --- algo.TermStyle.value.GetEnum
// Get value of field as enum type
inline algo_TermStyleEnum algo::value_GetEnum(const algo::TermStyle& parent) {
    return algo_TermStyleEnum(parent.value);
}

// --- algo.TermStyle.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::TermStyle& parent, algo_TermStyleEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.TermStyle.value.Cast
inline algo::TermStyle::operator algo_TermStyleEnum () const {
    return algo_TermStyleEnum((*this).value);
}

// --- algo.TermStyle..Init
// Set all fields to initial values.
inline void algo::TermStyle_Init(algo::TermStyle& parent) {
    parent.value = u32(0);
}
inline algo::TextJust::TextJust(u32                            in_value)
    : value(in_value)
{
}
inline algo::TextJust::TextJust(algo_TextJustEnum arg) { this->value = u32(arg); }
inline algo::TextJust::TextJust() {
    algo::TextJust_Init(*this);
}


// --- algo.TextJust.value.GetEnum
// Get value of field as enum type
inline algo_TextJustEnum algo::value_GetEnum(const algo::TextJust& parent) {
    return algo_TextJustEnum(parent.value);
}

// --- algo.TextJust.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::TextJust& parent, algo_TextJustEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.TextJust.value.Cast
inline algo::TextJust::operator algo_TextJustEnum () const {
    return algo_TextJustEnum((*this).value);
}

// --- algo.TextJust..Init
// Set all fields to initial values.
inline void algo::TextJust_Init(algo::TextJust& parent) {
    parent.value = u32(0);
}
inline algo::TstampCache::TstampCache() {
    algo::TstampCache_Init(*this);
}

inline algo::U16Dec2::U16Dec2(u16                            in_value)
    : value(in_value)
{
}
inline algo::U16Dec2::U16Dec2() {
    algo::U16Dec2_Init(*this);
}


// --- algo.U16Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U16Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U16Dec2.value.GetDouble
inline double algo::value_GetDouble(algo::U16Dec2& parent) {
    double ret;
    ret = parent.value * 0.01;
    return ret;
}

// --- algo.U16Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline u16 algo::value_GetInt(algo::U16Dec2& parent) {
    u16 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.U16Dec2.value.GetScale
// Return constant 100
inline u16 algo::U16Dec2_GetScale() {
    return 100;
}

// --- algo.U16Dec2.value.Cast
inline algo::U16Dec2::operator u16 () const {
    return u16((*this).value);
}

// --- algo.U16Dec2..Hash
inline u32 algo::U16Dec2_Hash(u32 prev, algo::U16Dec2 rhs) {
    prev = u16_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U16Dec2..Init
// Set all fields to initial values.
inline void algo::U16Dec2_Init(algo::U16Dec2& parent) {
    parent.value = u16(0);
}
inline algo::U32Dec1::U32Dec1(u32                            in_value)
    : value(in_value)
{
}
inline algo::U32Dec1::U32Dec1() {
    algo::U32Dec1_Init(*this);
}


// --- algo.U32Dec1.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec1& parent, double val) {
    double intval = val * 10 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec1.value.GetDouble
inline double algo::value_GetDouble(algo::U32Dec1& parent) {
    double ret;
    ret = parent.value * 0.1;
    return ret;
}

// --- algo.U32Dec1.value.GetInt
// Return integer portion (divide number by 10)
inline u32 algo::value_GetInt(algo::U32Dec1& parent) {
    u32 ret;
    ret = parent.value / 10;
    return ret;
}

// --- algo.U32Dec1.value.GetScale
// Return constant 10
inline u32 algo::U32Dec1_GetScale() {
    return 10;
}

// --- algo.U32Dec1.value.Cast
inline algo::U32Dec1::operator u32 () const {
    return u32((*this).value);
}

// --- algo.U32Dec1..Hash
inline u32 algo::U32Dec1_Hash(u32 prev, algo::U32Dec1 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec1..Init
// Set all fields to initial values.
inline void algo::U32Dec1_Init(algo::U32Dec1& parent) {
    parent.value = u32(0);
}
inline algo::U32Dec2::U32Dec2(u32                            in_value)
    : value(in_value)
{
}
inline algo::U32Dec2::U32Dec2() {
    algo::U32Dec2_Init(*this);
}


// --- algo.U32Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec2.value.GetDouble
inline double algo::value_GetDouble(algo::U32Dec2& parent) {
    double ret;
    ret = parent.value * 0.01;
    return ret;
}

// --- algo.U32Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline u32 algo::value_GetInt(algo::U32Dec2& parent) {
    u32 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.U32Dec2.value.GetScale
// Return constant 100
inline u32 algo::U32Dec2_GetScale() {
    return 100;
}

// --- algo.U32Dec2.value.Cast
inline algo::U32Dec2::operator u32 () const {
    return u32((*this).value);
}

// --- algo.U32Dec2..Hash
inline u32 algo::U32Dec2_Hash(u32 prev, algo::U32Dec2 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec2..Init
// Set all fields to initial values.
inline void algo::U32Dec2_Init(algo::U32Dec2& parent) {
    parent.value = u32(0);
}
inline algo::U32Dec3::U32Dec3(u32                            in_value)
    : value(in_value)
{
}
inline algo::U32Dec3::U32Dec3() {
    algo::U32Dec3_Init(*this);
}


// --- algo.U32Dec3.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec3& parent, double val) {
    double intval = val * 1000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec3.value.GetDouble
inline double algo::value_GetDouble(algo::U32Dec3& parent) {
    double ret;
    ret = parent.value * 0.001;
    return ret;
}

// --- algo.U32Dec3.value.GetInt
// Return integer portion (divide number by 1000)
inline u32 algo::value_GetInt(algo::U32Dec3& parent) {
    u32 ret;
    ret = parent.value / 1000;
    return ret;
}

// --- algo.U32Dec3.value.GetScale
// Return constant 1000
inline u32 algo::U32Dec3_GetScale() {
    return 1000;
}

// --- algo.U32Dec3.value.Cast
inline algo::U32Dec3::operator u32 () const {
    return u32((*this).value);
}

// --- algo.U32Dec3..Hash
inline u32 algo::U32Dec3_Hash(u32 prev, algo::U32Dec3 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec3..Init
// Set all fields to initial values.
inline void algo::U32Dec3_Init(algo::U32Dec3& parent) {
    parent.value = u32(0);
}
inline algo::U32Dec4::U32Dec4(u32                            in_value)
    : value(in_value)
{
}
inline algo::U32Dec4::U32Dec4() {
    algo::U32Dec4_Init(*this);
}


// --- algo.U32Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec4.value.GetDouble
inline double algo::value_GetDouble(algo::U32Dec4& parent) {
    double ret;
    ret = parent.value * 0.0001;
    return ret;
}

// --- algo.U32Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline u32 algo::value_GetInt(algo::U32Dec4& parent) {
    u32 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.U32Dec4.value.GetScale
// Return constant 10000
inline u32 algo::U32Dec4_GetScale() {
    return 10000;
}

// --- algo.U32Dec4.value.Cast
inline algo::U32Dec4::operator u32 () const {
    return u32((*this).value);
}

// --- algo.U32Dec4..Hash
inline u32 algo::U32Dec4_Hash(u32 prev, algo::U32Dec4 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec4..Init
// Set all fields to initial values.
inline void algo::U32Dec4_Init(algo::U32Dec4& parent) {
    parent.value = u32(0);
}
inline algo::U32Dec5::U32Dec5(u32                            in_value)
    : value(in_value)
{
}
inline algo::U32Dec5::U32Dec5() {
    algo::U32Dec5_Init(*this);
}


// --- algo.U32Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec5.value.GetDouble
inline double algo::value_GetDouble(algo::U32Dec5& parent) {
    double ret;
    ret = parent.value * 0.00001;
    return ret;
}

// --- algo.U32Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline u32 algo::value_GetInt(algo::U32Dec5& parent) {
    u32 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.U32Dec5.value.GetScale
// Return constant 100000
inline u32 algo::U32Dec5_GetScale() {
    return 100000;
}

// --- algo.U32Dec5.value.Cast
inline algo::U32Dec5::operator u32 () const {
    return u32((*this).value);
}

// --- algo.U32Dec5..Hash
inline u32 algo::U32Dec5_Hash(u32 prev, algo::U32Dec5 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec5..Init
// Set all fields to initial values.
inline void algo::U32Dec5_Init(algo::U32Dec5& parent) {
    parent.value = u32(0);
}
inline algo::U64Ary::U64Ary() {
    algo::U64Ary_Init(*this);
}

inline algo::U64Ary::~U64Ary() {
    algo::U64Ary_Uninit(*this);
}


// --- algo.U64Ary.ary.EmptyQ
// Return true if index is empty
inline bool algo::ary_EmptyQ(algo::U64Ary& parent) {
    return parent.ary_n == 0;
}

// --- algo.U64Ary.ary.Find
// Look up row by row id. Return NULL if out of range
inline u64* algo::ary_Find(algo::U64Ary& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- algo.U64Ary.ary.Getary
// Return array pointer by value
inline algo::aryptr<u64> algo::ary_Getary(algo::U64Ary& parent) {
    return algo::aryptr<u64>(parent.ary_elems, parent.ary_n);
}

// --- algo.U64Ary.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u64* algo::ary_Last(algo::U64Ary& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- algo.U64Ary.ary.Max
// Return max. number of items in the array
inline i32 algo::ary_Max(algo::U64Ary& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- algo.U64Ary.ary.N
// Return number of items in the array
inline i32 algo::ary_N(const algo::U64Ary& parent) {
    return parent.ary_n;
}

// --- algo.U64Ary.ary.RemoveAll
inline void algo::ary_RemoveAll(algo::U64Ary& parent) {
    parent.ary_n = 0;
}

// --- algo.U64Ary.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ary_Reserve(algo::U64Ary& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- algo.U64Ary.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u64& algo::ary_qFind(algo::U64Ary& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- algo.U64Ary.ary.qLast
// Return reference to last element of array. No bounds checking
inline u64& algo::ary_qLast(algo::U64Ary& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- algo.U64Ary.ary.rowid_Get
// Return row id of specified element
inline u64 algo::ary_rowid_Get(algo::U64Ary& parent, u64 &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- algo.U64Ary.ary_curs.Next
// proceed to next item
inline void algo::U64Ary_ary_curs_Next(U64Ary_ary_curs &curs) {
    curs.index++;
}

// --- algo.U64Ary.ary_curs.Reset
inline void algo::U64Ary_ary_curs_Reset(U64Ary_ary_curs &curs, algo::U64Ary &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- algo.U64Ary.ary_curs.ValidQ
// cursor points to valid item
inline bool algo::U64Ary_ary_curs_ValidQ(U64Ary_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.U64Ary.ary_curs.Access
// item access
inline u64& algo::U64Ary_ary_curs_Access(U64Ary_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.U64Ary..Init
// Set all fields to initial values.
inline void algo::U64Ary_Init(algo::U64Ary& parent) {
    parent.ary_elems 	= 0; // (algo.U64Ary.ary)
    parent.ary_n     	= 0; // (algo.U64Ary.ary)
    parent.ary_max   	= 0; // (algo.U64Ary.ary)
}
inline algo::U64Dec10::U64Dec10(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec10::U64Dec10() {
    algo::U64Dec10_Init(*this);
}


// --- algo.U64Dec10.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec10& parent, double val) {
    double intval = val * 10000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec10.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec10& parent) {
    double ret;
    ret = parent.value * 0.0000000001;
    return ret;
}

// --- algo.U64Dec10.value.GetInt
// Return integer portion (divide number by 10000000000)
inline u64 algo::value_GetInt(algo::U64Dec10& parent) {
    u64 ret;
    ret = parent.value / 10000000000;
    return ret;
}

// --- algo.U64Dec10.value.GetScale
// Return constant 10000000000
inline u64 algo::U64Dec10_GetScale() {
    return 10000000000;
}

// --- algo.U64Dec10.value.Cast
inline algo::U64Dec10::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec10..Hash
inline u32 algo::U64Dec10_Hash(u32 prev, algo::U64Dec10 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec10..Init
// Set all fields to initial values.
inline void algo::U64Dec10_Init(algo::U64Dec10& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec2::U64Dec2(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec2::U64Dec2() {
    algo::U64Dec2_Init(*this);
}


// --- algo.U64Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec2.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec2& parent) {
    double ret;
    ret = parent.value * 0.01;
    return ret;
}

// --- algo.U64Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline u64 algo::value_GetInt(algo::U64Dec2& parent) {
    u64 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.U64Dec2.value.GetScale
// Return constant 100
inline u64 algo::U64Dec2_GetScale() {
    return 100;
}

// --- algo.U64Dec2.value.Cast
inline algo::U64Dec2::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec2..Hash
inline u32 algo::U64Dec2_Hash(u32 prev, algo::U64Dec2 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec2..Init
// Set all fields to initial values.
inline void algo::U64Dec2_Init(algo::U64Dec2& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec4::U64Dec4(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec4::U64Dec4() {
    algo::U64Dec4_Init(*this);
}


// --- algo.U64Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec4.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec4& parent) {
    double ret;
    ret = parent.value * 0.0001;
    return ret;
}

// --- algo.U64Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline u64 algo::value_GetInt(algo::U64Dec4& parent) {
    u64 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.U64Dec4.value.GetScale
// Return constant 10000
inline u64 algo::U64Dec4_GetScale() {
    return 10000;
}

// --- algo.U64Dec4.value.Cast
inline algo::U64Dec4::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec4..Hash
inline u32 algo::U64Dec4_Hash(u32 prev, algo::U64Dec4 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec4..Init
// Set all fields to initial values.
inline void algo::U64Dec4_Init(algo::U64Dec4& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec5::U64Dec5(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec5::U64Dec5() {
    algo::U64Dec5_Init(*this);
}


// --- algo.U64Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec5.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec5& parent) {
    double ret;
    ret = parent.value * 0.00001;
    return ret;
}

// --- algo.U64Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline u64 algo::value_GetInt(algo::U64Dec5& parent) {
    u64 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.U64Dec5.value.GetScale
// Return constant 100000
inline u64 algo::U64Dec5_GetScale() {
    return 100000;
}

// --- algo.U64Dec5.value.Cast
inline algo::U64Dec5::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec5..Hash
inline u32 algo::U64Dec5_Hash(u32 prev, algo::U64Dec5 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec5..Init
// Set all fields to initial values.
inline void algo::U64Dec5_Init(algo::U64Dec5& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec6::U64Dec6(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec6::U64Dec6() {
    algo::U64Dec6_Init(*this);
}


// --- algo.U64Dec6.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec6& parent, double val) {
    double intval = val * 1000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec6.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec6& parent) {
    double ret;
    ret = parent.value * 0.000001;
    return ret;
}

// --- algo.U64Dec6.value.GetInt
// Return integer portion (divide number by 1000000)
inline u64 algo::value_GetInt(algo::U64Dec6& parent) {
    u64 ret;
    ret = parent.value / 1000000;
    return ret;
}

// --- algo.U64Dec6.value.GetScale
// Return constant 1000000
inline u64 algo::U64Dec6_GetScale() {
    return 1000000;
}

// --- algo.U64Dec6.value.Cast
inline algo::U64Dec6::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec6..Hash
inline u32 algo::U64Dec6_Hash(u32 prev, algo::U64Dec6 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec6..Init
// Set all fields to initial values.
inline void algo::U64Dec6_Init(algo::U64Dec6& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec7::U64Dec7(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec7::U64Dec7() {
    algo::U64Dec7_Init(*this);
}


// --- algo.U64Dec7.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec7& parent, double val) {
    double intval = val * 10000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec7.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec7& parent) {
    double ret;
    ret = parent.value * 0.0000001;
    return ret;
}

// --- algo.U64Dec7.value.GetInt
// Return integer portion (divide number by 10000000)
inline u64 algo::value_GetInt(algo::U64Dec7& parent) {
    u64 ret;
    ret = parent.value / 10000000;
    return ret;
}

// --- algo.U64Dec7.value.GetScale
// Return constant 10000000
inline u64 algo::U64Dec7_GetScale() {
    return 10000000;
}

// --- algo.U64Dec7.value.Cast
inline algo::U64Dec7::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec7..Hash
inline u32 algo::U64Dec7_Hash(u32 prev, algo::U64Dec7 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec7..Init
// Set all fields to initial values.
inline void algo::U64Dec7_Init(algo::U64Dec7& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec8::U64Dec8(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec8::U64Dec8() {
    algo::U64Dec8_Init(*this);
}


// --- algo.U64Dec8.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec8& parent, double val) {
    double intval = val * 100000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec8.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec8& parent) {
    double ret;
    ret = parent.value * 0.00000001;
    return ret;
}

// --- algo.U64Dec8.value.GetInt
// Return integer portion (divide number by 100000000)
inline u64 algo::value_GetInt(algo::U64Dec8& parent) {
    u64 ret;
    ret = parent.value / 100000000;
    return ret;
}

// --- algo.U64Dec8.value.GetScale
// Return constant 100000000
inline u64 algo::U64Dec8_GetScale() {
    return 100000000;
}

// --- algo.U64Dec8.value.Cast
inline algo::U64Dec8::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec8..Hash
inline u32 algo::U64Dec8_Hash(u32 prev, algo::U64Dec8 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec8..Init
// Set all fields to initial values.
inline void algo::U64Dec8_Init(algo::U64Dec8& parent) {
    parent.value = u64(0);
}
inline algo::U64Dec9::U64Dec9(u64                            in_value)
    : value(in_value)
{
}
inline algo::U64Dec9::U64Dec9() {
    algo::U64Dec9_Init(*this);
}


// --- algo.U64Dec9.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec9& parent, double val) {
    double intval = val * 1000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec9.value.GetDouble
inline double algo::value_GetDouble(algo::U64Dec9& parent) {
    double ret;
    ret = parent.value * 0.000000001;
    return ret;
}

// --- algo.U64Dec9.value.GetInt
// Return integer portion (divide number by 1000000000)
inline u64 algo::value_GetInt(algo::U64Dec9& parent) {
    u64 ret;
    ret = parent.value / 1000000000;
    return ret;
}

// --- algo.U64Dec9.value.GetScale
// Return constant 1000000000
inline u64 algo::U64Dec9_GetScale() {
    return 1000000000;
}

// --- algo.U64Dec9.value.Cast
inline algo::U64Dec9::operator u64 () const {
    return u64((*this).value);
}

// --- algo.U64Dec9..Hash
inline u32 algo::U64Dec9_Hash(u32 prev, algo::U64Dec9 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec9..Init
// Set all fields to initial values.
inline void algo::U64Dec9_Init(algo::U64Dec9& parent) {
    parent.value = u64(0);
}
inline algo::URL::URL(const algo::strptr&            in_protocol
        ,const algo::strptr&            in_username
        ,const algo::strptr&            in_password
        ,const algo::strptr&            in_server
        ,const algo::strptr&            in_dir
        ,i32                            in_port
        ,u32                            in_source_addr_host
        ,const algo::strptr&            in_host)
    : protocol(in_protocol)
    , username(in_username)
    , password(in_password)
    , server(in_server)
    , dir(in_dir)
    , port(in_port)
    , source_addr_host(in_source_addr_host)
    , host(in_host)
{
}
inline algo::URL::URL() {
    algo::URL_Init(*this);
}


// --- algo.URL..Init
// Set all fields to initial values.
inline void algo::URL_Init(algo::URL& parent) {
    parent.port = i32(-1);
    parent.source_addr_host = u32(0);
}
inline algo::UnDiff::UnDiff(i64                            in_value)
    : value(in_value)
{
}

inline bool algo::UnDiff::operator ==(const algo::UnDiff &rhs) const {
    return algo::UnDiff_Eq(const_cast<algo::UnDiff&>(*this),const_cast<algo::UnDiff&>(rhs));
}

inline bool algo::UnDiff::operator <(const algo::UnDiff &rhs) const {
    return algo::UnDiff_Lt(const_cast<algo::UnDiff&>(*this),const_cast<algo::UnDiff&>(rhs));
}
inline algo::UnDiff::UnDiff() {
    algo::UnDiff_Init(*this);
}


// --- algo.UnDiff..Hash
inline u32 algo::UnDiff_Hash(u32 prev, algo::UnDiff rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnDiff..Lt
inline bool algo::UnDiff_Lt(algo::UnDiff lhs, algo::UnDiff rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnDiff..Cmp
inline i32 algo::UnDiff_Cmp(algo::UnDiff lhs, algo::UnDiff rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnDiff..Init
// Set all fields to initial values.
inline void algo::UnDiff_Init(algo::UnDiff& parent) {
    parent.value = i64(0);
}

// --- algo.UnDiff..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnDiff_UpdateMax(algo::UnDiff &lhs, algo::UnDiff rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnDiff..Min
// Return the lesser of two values
inline algo::UnDiff algo::UnDiff_Min(algo::UnDiff lhs, algo::UnDiff rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnDiff..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnDiff_UpdateMin(algo::UnDiff &lhs, algo::UnDiff rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnDiff..Max
// Return the greater of two values
inline algo::UnDiff algo::UnDiff_Max(algo::UnDiff lhs, algo::UnDiff rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnDiff..Eq
inline bool algo::UnDiff_Eq(algo::UnDiff lhs, algo::UnDiff rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnDiff..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnDiff_Update(algo::UnDiff &lhs, algo::UnDiff rhs) {
    bool ret = !UnDiff_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::UnixDiff::UnixDiff(i64                            in_value)
    : value(in_value)
{
}

inline bool algo::UnixDiff::operator ==(const algo::UnixDiff &rhs) const {
    return algo::UnixDiff_Eq(const_cast<algo::UnixDiff&>(*this),const_cast<algo::UnixDiff&>(rhs));
}

inline bool algo::UnixDiff::operator <(const algo::UnixDiff &rhs) const {
    return algo::UnixDiff_Lt(const_cast<algo::UnixDiff&>(*this),const_cast<algo::UnixDiff&>(rhs));
}
inline algo::UnixDiff::UnixDiff() {
    algo::UnixDiff_Init(*this);
}


// --- algo.UnixDiff..Hash
inline u32 algo::UnixDiff_Hash(u32 prev, algo::UnixDiff rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnixDiff..Lt
inline bool algo::UnixDiff_Lt(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnixDiff..Cmp
inline i32 algo::UnixDiff_Cmp(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixDiff..Init
// Set all fields to initial values.
inline void algo::UnixDiff_Init(algo::UnixDiff& parent) {
    parent.value = i64(0);
}

// --- algo.UnixDiff..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnixDiff_UpdateMax(algo::UnixDiff &lhs, algo::UnixDiff rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixDiff..Min
// Return the lesser of two values
inline algo::UnixDiff algo::UnixDiff_Min(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnixDiff..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnixDiff_UpdateMin(algo::UnixDiff &lhs, algo::UnixDiff rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixDiff..Max
// Return the greater of two values
inline algo::UnixDiff algo::UnixDiff_Max(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnixDiff..Eq
inline bool algo::UnixDiff_Eq(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixDiff..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnixDiff_Update(algo::UnixDiff &lhs, algo::UnixDiff rhs) {
    bool ret = !UnixDiff_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::UnixTime::UnixTime(i64                            in_value)
    : value(in_value)
{
}

inline bool algo::UnixTime::operator ==(const algo::UnixTime &rhs) const {
    return algo::UnixTime_Eq(const_cast<algo::UnixTime&>(*this),const_cast<algo::UnixTime&>(rhs));
}

inline bool algo::UnixTime::operator <(const algo::UnixTime &rhs) const {
    return algo::UnixTime_Lt(const_cast<algo::UnixTime&>(*this),const_cast<algo::UnixTime&>(rhs));
}
inline algo::UnixTime::UnixTime() {
    algo::UnixTime_Init(*this);
}


// --- algo.UnixTime..Hash
inline u32 algo::UnixTime_Hash(u32 prev, algo::UnixTime rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnixTime..Lt
inline bool algo::UnixTime_Lt(algo::UnixTime lhs, algo::UnixTime rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnixTime..Cmp
inline i32 algo::UnixTime_Cmp(algo::UnixTime lhs, algo::UnixTime rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixTime..Init
// Set all fields to initial values.
inline void algo::UnixTime_Init(algo::UnixTime& parent) {
    parent.value = i64(0);
}

// --- algo.UnixTime..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnixTime_UpdateMax(algo::UnixTime &lhs, algo::UnixTime rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixTime..Min
// Return the lesser of two values
inline algo::UnixTime algo::UnixTime_Min(algo::UnixTime lhs, algo::UnixTime rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnixTime..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnixTime_UpdateMin(algo::UnixTime &lhs, algo::UnixTime rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixTime..Max
// Return the greater of two values
inline algo::UnixTime algo::UnixTime_Max(algo::UnixTime lhs, algo::UnixTime rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnixTime..Eq
inline bool algo::UnixTime_Eq(algo::UnixTime lhs, algo::UnixTime rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnixTime_Update(algo::UnixTime &lhs, algo::UnixTime rhs) {
    bool ret = !UnixTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline algo::i32_Range::i32_Range(i32                            in_beg
        ,i32                            in_end)
    : beg(in_beg)
    , end(in_end)
{
}

inline bool algo::i32_Range::operator ==(const algo::i32_Range &rhs) const {
    return algo::i32_Range_Eq(const_cast<algo::i32_Range&>(*this),const_cast<algo::i32_Range&>(rhs));
}

inline bool algo::i32_Range::operator <(const algo::i32_Range &rhs) const {
    return algo::i32_Range_Lt(const_cast<algo::i32_Range&>(*this),const_cast<algo::i32_Range&>(rhs));
}
inline algo::i32_Range::i32_Range() {
    algo::i32_Range_Init(*this);
}


// --- algo.i32_Range..Hash
inline u32 algo::i32_Range_Hash(u32 prev, const algo::i32_Range & rhs) {
    prev = i32_Hash(prev, rhs.beg);
    prev = i32_Hash(prev, rhs.end);
    return prev;
}

// --- algo.i32_Range..Lt
inline bool algo::i32_Range_Lt(algo::i32_Range & lhs, algo::i32_Range & rhs) {
    return i32_Range_Cmp(lhs,rhs) < 0;
}

// --- algo.i32_Range..Cmp
inline i32 algo::i32_Range_Cmp(algo::i32_Range & lhs, algo::i32_Range & rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.beg, rhs.beg);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.end, rhs.end);
    return retval;
}

// --- algo.i32_Range..Init
// Set all fields to initial values.
inline void algo::i32_Range_Init(algo::i32_Range& stack) {
    stack.beg = i32(0);
    stack.end = i32(0);
}

// --- algo.i32_Range..Eq
inline bool algo::i32_Range_Eq(const algo::i32_Range & lhs,const algo::i32_Range & rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.beg, rhs.beg);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.end, rhs.end);
    return retval;
}

// --- algo.i32_Range..Update
// Set value. Return true if new value is different from old value.
inline bool algo::i32_Range_Update(algo::i32_Range &lhs, algo::i32_Range & rhs) {
    bool ret = !i32_Range_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::ArgProto &row) {// cfmt:algo.ArgProto.String
    algo::ArgProto_Print(const_cast<algo::ArgProto&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Attr &row) {// cfmt:algo.Attr.String
    algo::Attr_Print(const_cast<algo::Attr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Tuple &row) {// cfmt:algo.Tuple.String
    algo::Tuple_Print(const_cast<algo::Tuple&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Argtuple &row) {// cfmt:algo.Argtuple.String
    algo::Argtuple_Print(const_cast<algo::Argtuple&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Bool &row) {// cfmt:algo.Bool.String
    algo::Bool_Print(const_cast<algo::Bool&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Comment &row) {// cfmt:algo.Comment.String
    algo::Comment_Print(const_cast<algo::Comment&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnTime &row) {// cfmt:algo.UnTime.String
    algo::UnTime_Print(const_cast<algo::UnTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Dbbox &row) {// cfmt:algo.Dbbox.String
    algo::Dbbox_Print(const_cast<algo::Dbbox&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::DryrunQ &row) {// cfmt:algo.DryrunQ.String
    algo::DryrunQ_Print(const_cast<algo::DryrunQ&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::EchoQ &row) {// cfmt:algo.EchoQ.String
    algo::EchoQ_Print(const_cast<algo::EchoQ&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Errcode &row) {// cfmt:algo.Errcode.String
    algo::Errcode_Print(const_cast<algo::Errcode&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::FailokQ &row) {// cfmt:algo.FailokQ.String
    algo::FailokQ_Print(const_cast<algo::FailokQ&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::FieldId &row) {// cfmt:algo.FieldId.String
    algo::FieldId_Print(const_cast<algo::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::FileFlags &row) {// cfmt:algo.FileFlags.String
    algo::FileFlags_Print(const_cast<algo::FileFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec1 &row) {// cfmt:algo.I32Dec1.String
    algo::I32Dec1_Print(const_cast<algo::I32Dec1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec2 &row) {// cfmt:algo.I32Dec2.String
    algo::I32Dec2_Print(const_cast<algo::I32Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec3 &row) {// cfmt:algo.I32Dec3.String
    algo::I32Dec3_Print(const_cast<algo::I32Dec3&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec4 &row) {// cfmt:algo.I32Dec4.String
    algo::I32Dec4_Print(const_cast<algo::I32Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec5 &row) {// cfmt:algo.I32Dec5.String
    algo::I32Dec5_Print(const_cast<algo::I32Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec1 &row) {// cfmt:algo.I64Dec1.String
    algo::I64Dec1_Print(const_cast<algo::I64Dec1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec10 &row) {// cfmt:algo.I64Dec10.String
    algo::I64Dec10_Print(const_cast<algo::I64Dec10&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec2 &row) {// cfmt:algo.I64Dec2.String
    algo::I64Dec2_Print(const_cast<algo::I64Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec3 &row) {// cfmt:algo.I64Dec3.String
    algo::I64Dec3_Print(const_cast<algo::I64Dec3&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec4 &row) {// cfmt:algo.I64Dec4.String
    algo::I64Dec4_Print(const_cast<algo::I64Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec5 &row) {// cfmt:algo.I64Dec5.String
    algo::I64Dec5_Print(const_cast<algo::I64Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec6 &row) {// cfmt:algo.I64Dec6.String
    algo::I64Dec6_Print(const_cast<algo::I64Dec6&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec7 &row) {// cfmt:algo.I64Dec7.String
    algo::I64Dec7_Print(const_cast<algo::I64Dec7&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec8 &row) {// cfmt:algo.I64Dec8.String
    algo::I64Dec8_Print(const_cast<algo::I64Dec8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec9 &row) {// cfmt:algo.I64Dec9.String
    algo::I64Dec9_Print(const_cast<algo::I64Dec9&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::IOEvtFlags &row) {// cfmt:algo.IOEvtFlags.String
    algo::IOEvtFlags_Print(const_cast<algo::IOEvtFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Imdb &row) {// cfmt:algo.Imdb.String
    algo::Imdb_Print(const_cast<algo::Imdb&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::ImrowPtr &row) {// cfmt:algo.ImrowPtr.String
    algo::ImrowPtr_Print(const_cast<algo::ImrowPtr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Imtable &row) {// cfmt:algo.Imtable.String
    algo::Imtable_Print(const_cast<algo::Imtable&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Ipmask &row) {// cfmt:algo.Ipmask.String
    algo::Ipmask_Print(const_cast<algo::Ipmask&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::LogcatId &row) {// cfmt:algo.LogcatId.String
    algo::LogcatId_Print(const_cast<algo::LogcatId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::LogcatKey &row) {// cfmt:algo.LogcatKey.String
    algo::LogcatKey_Print(const_cast<algo::LogcatKey&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::SchedTime &row) {// cfmt:algo.SchedTime.String
    algo::SchedTime_Print(const_cast<algo::SchedTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Logmsg &row) {// cfmt:algo.Logmsg.String
    algo::Logmsg_Print(const_cast<algo::Logmsg&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Md5Digest &row) {// cfmt:algo.Md5Digest.String
    algo::Md5Digest_Print(const_cast<algo::Md5Digest&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Month &row) {// cfmt:algo.Month.String
    algo::Month_Print(const_cast<algo::Month&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::NumParseFlags &row) {// cfmt:algo.NumParseFlags.String
    algo::NumParseFlags_Print(const_cast<algo::NumParseFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::PrintDouble &row) {// cfmt:algo.PrintDouble.String
    algo::PrintDouble_Print(const_cast<algo::PrintDouble&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::SeqType &row) {// cfmt:algo.SeqType.String
    algo::SeqType_Print(const_cast<algo::SeqType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Sha1sig &row) {// cfmt:algo.Sha1sig.String
    algo::Sha1sig_Print(const_cast<algo::Sha1sig&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::TermStyle &row) {// cfmt:algo.TermStyle.String
    algo::TermStyle_Print(const_cast<algo::TermStyle&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::TextJust &row) {// cfmt:algo.TextJust.String
    algo::TextJust_Print(const_cast<algo::TextJust&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U16Dec2 &row) {// cfmt:algo.U16Dec2.String
    algo::U16Dec2_Print(const_cast<algo::U16Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec1 &row) {// cfmt:algo.U32Dec1.String
    algo::U32Dec1_Print(const_cast<algo::U32Dec1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec2 &row) {// cfmt:algo.U32Dec2.String
    algo::U32Dec2_Print(const_cast<algo::U32Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec3 &row) {// cfmt:algo.U32Dec3.String
    algo::U32Dec3_Print(const_cast<algo::U32Dec3&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec4 &row) {// cfmt:algo.U32Dec4.String
    algo::U32Dec4_Print(const_cast<algo::U32Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec5 &row) {// cfmt:algo.U32Dec5.String
    algo::U32Dec5_Print(const_cast<algo::U32Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec10 &row) {// cfmt:algo.U64Dec10.String
    algo::U64Dec10_Print(const_cast<algo::U64Dec10&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec2 &row) {// cfmt:algo.U64Dec2.String
    algo::U64Dec2_Print(const_cast<algo::U64Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec4 &row) {// cfmt:algo.U64Dec4.String
    algo::U64Dec4_Print(const_cast<algo::U64Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec5 &row) {// cfmt:algo.U64Dec5.String
    algo::U64Dec5_Print(const_cast<algo::U64Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec6 &row) {// cfmt:algo.U64Dec6.String
    algo::U64Dec6_Print(const_cast<algo::U64Dec6&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec7 &row) {// cfmt:algo.U64Dec7.String
    algo::U64Dec7_Print(const_cast<algo::U64Dec7&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec8 &row) {// cfmt:algo.U64Dec8.String
    algo::U64Dec8_Print(const_cast<algo::U64Dec8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec9 &row) {// cfmt:algo.U64Dec9.String
    algo::U64Dec9_Print(const_cast<algo::U64Dec9&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::URL &row) {// cfmt:algo.URL.String
    algo::URL_Print(const_cast<algo::URL&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnDiff &row) {// cfmt:algo.UnDiff.String
    algo::UnDiff_Print(const_cast<algo::UnDiff&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnixDiff &row) {// cfmt:algo.UnixDiff.String
    algo::UnixDiff_Print(const_cast<algo::UnixDiff&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnixTime &row) {// cfmt:algo.UnixTime.String
    algo::UnixTime_Print(const_cast<algo::UnixTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::i32_Range &row) {// cfmt:algo.i32_Range.String
    algo::i32_Range_Print(const_cast<algo::i32_Range&>(row), str);
    return str;
}
