//
// include/gen/algo_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
//#pragma endinclude

// --- algo.cstring.ch.EmptyQ
// Return true if index is empty
inline bool algo::ch_EmptyQ(algo::cstring& parent) {
    return parent.ch_n == 0;
}

// --- algo.cstring.ch.Find
// Look up row by row id. Return NULL if out of range
inline char* algo::ch_Find(algo::cstring& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ch_n;
    if (idx >= lim) return NULL;
    return parent.ch_elems + idx;
}

// --- algo.cstring.ch.Getary
// Return array pointer by value
inline algo::aryptr<char> algo::ch_Getary(const algo::cstring& parent) {
    return algo::aryptr<char>(parent.ch_elems, parent.ch_n);
}

// --- algo.cstring.ch.Last
// Return pointer to last element of array, or NULL if array is empty
inline char* algo::ch_Last(algo::cstring& parent) {
    return ch_Find(parent, u64(parent.ch_n-1));
}

// --- algo.cstring.ch.AssignAryptr
// Copy from aryptr (operator=)
inline void algo::cstring::operator =(const algo::aryptr<char> &rhs) {
    ch_Setary(*this, rhs);
}

// --- algo.cstring.ch.CtorAryptr
inline  algo::cstring::cstring(const algo::aryptr<char> &rhs) {
    ch_elems 	= 0; // (algo.cstring.ch)
    ch_n     	= 0; // (algo.cstring.ch)
    ch_max   	= 0; // (algo.cstring.ch)
    ch_Addary(*this, rhs);
}

// --- algo.cstring.ch.Max
// Return max. number of items in the array
inline i32 algo::ch_Max(algo::cstring& parent) {
    (void)parent;
    return parent.ch_max;
}

// --- algo.cstring.ch.N
// Return number of items in the array
inline i32 algo::ch_N(const algo::cstring& parent) {
    return parent.ch_n;
}

// --- algo.cstring.ch.RemoveAll
inline void algo::ch_RemoveAll(algo::cstring& parent) {
    parent.ch_n = 0;
}

// --- algo.cstring.ch.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ch_Reserve(algo::cstring& parent, int n) {
    u32 new_n = parent.ch_n + n;
    if (UNLIKELY(new_n > parent.ch_max)) {
        ch_AbsReserve(parent, new_n);
    }
}

// --- algo.cstring.ch.qFind
// 'quick' Access row by row id. No bounds checking.
inline char& algo::ch_qFind(algo::cstring& parent, u64 t) {
    return parent.ch_elems[t];
}

// --- algo.cstring.ch.qLast
// Return reference to last element of array. No bounds checking
inline char& algo::ch_qLast(algo::cstring& parent) {
    return ch_qFind(parent, u64(parent.ch_n-1));
}

// --- algo.cstring.ch.rowid_Get
// Return row id of specified element
inline u64 algo::ch_rowid_Get(algo::cstring& parent, char &elem) {
    u64 id = &elem - parent.ch_elems;
    return u64(id);
}

// --- algo.cstring.ch.Cast
inline  algo::cstring::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.cstring.ch_curs.Next
// proceed to next item
inline void algo::cstring_ch_curs_Next(cstring_ch_curs &curs) {
    curs.index++;
}

// --- algo.cstring.ch_curs.Reset
inline void algo::cstring_ch_curs_Reset(cstring_ch_curs &curs, algo::cstring &parent) {
    curs.elems = parent.ch_elems;
    curs.n_elems = parent.ch_n;
    curs.index = 0;
}

// --- algo.cstring.ch_curs.ValidQ
// cursor points to valid item
inline bool algo::cstring_ch_curs_ValidQ(cstring_ch_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.cstring.ch_curs.Access
// item access
inline char& algo::cstring_ch_curs_Access(cstring_ch_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.cstring..EqOp
inline bool algo::cstring::operator ==(const algo::cstring &rhs) const {
    return algo::cstring_Eq(const_cast<algo::cstring&>(*this),const_cast<algo::cstring&>(rhs));
}

// --- algo.cstring..NeOp
inline bool algo::cstring::operator !=(const algo::cstring &rhs) const {
    return !algo::cstring_Eq(const_cast<algo::cstring&>(*this),const_cast<algo::cstring&>(rhs));
}

// --- algo.cstring..LtOp
inline bool algo::cstring::operator <(const algo::cstring &rhs) const {
    return algo::cstring_Lt(const_cast<algo::cstring&>(*this),const_cast<algo::cstring&>(rhs));
}

// --- algo.cstring..GtOp
inline bool algo::cstring::operator >(const algo::cstring &rhs) const {
    return algo::cstring_Lt(const_cast<algo::cstring&>(rhs),const_cast<algo::cstring&>(*this));
}

// --- algo.cstring..LeOp
inline bool algo::cstring::operator <=(const algo::cstring &rhs) const {
    return !algo::cstring_Lt(const_cast<algo::cstring&>(rhs),const_cast<algo::cstring&>(*this));
}

// --- algo.cstring..GeOp
inline bool algo::cstring::operator >=(const algo::cstring &rhs) const {
    return !algo::cstring_Lt(const_cast<algo::cstring&>(*this),const_cast<algo::cstring&>(rhs));
}

// --- algo.cstring..Lt
inline bool algo::cstring_Lt(algo::cstring& lhs, algo::cstring& rhs) {
    return ch_Cmp(lhs,rhs) < 0;
}

// --- algo.cstring..Cmp
inline i32 algo::cstring_Cmp(algo::cstring& lhs, algo::cstring& rhs) {
    i32 retval = 0;
    retval = ch_Cmp(lhs,rhs);
    return retval;
}

// --- algo.cstring..Init
// Set all fields to initial values.
inline void algo::cstring_Init(algo::cstring& parent) {
    parent.ch_elems 	= 0; // (algo.cstring.ch)
    parent.ch_n     	= 0; // (algo.cstring.ch)
    parent.ch_max   	= 0; // (algo.cstring.ch)
}

// --- algo.cstring..Eq
inline bool algo::cstring_Eq(algo::cstring& lhs, algo::cstring& rhs) {
    bool retval = true;
    retval = ch_Eq(lhs,rhs);
    return retval;
}

// --- algo.cstring..Update
// Set value. Return true if new value is different from old value.
inline bool algo::cstring_Update(algo::cstring &lhs, algo::cstring& rhs) {
    bool ret = !cstring_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.cstring..Ctor
inline  algo::cstring::cstring() {
    algo::cstring_Init(*this);
}

// --- algo.cstring..Dtor
inline  algo::cstring::~cstring() {
    algo::cstring_Uninit(*this);
}

// --- algo.Attr..EqOp
inline bool algo::Attr::operator ==(const algo::Attr &rhs) const {
    return algo::Attr_Eq(const_cast<algo::Attr&>(*this),const_cast<algo::Attr&>(rhs));
}

// --- algo.Attr..NeOp
inline bool algo::Attr::operator !=(const algo::Attr &rhs) const {
    return !algo::Attr_Eq(const_cast<algo::Attr&>(*this),const_cast<algo::Attr&>(rhs));
}

// --- algo.Attr..Cmp
inline i32 algo::Attr_Cmp(algo::Attr& lhs, algo::Attr& rhs) {
    i32 retval = 0;
    retval = algo::cstring_Cmp(lhs.name, rhs.name);
    if (retval != 0) {
        return retval;
    }
    retval = algo::cstring_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.Attr..Eq
inline bool algo::Attr_Eq(algo::Attr& lhs, algo::Attr& rhs) {
    bool retval = true;
    retval = algo::cstring_Eq(lhs.name, rhs.name);
    if (!retval) {
        return false;
    }
    retval = algo::cstring_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.Attr..Ctor
inline  algo::Attr::Attr() {
}

// --- algo.Attr..FieldwiseCtor
inline  algo::Attr::Attr(const algo::strptr& in_name, const algo::strptr& in_value)
    : name(in_name)
    , value(in_value)
 {
}

// --- algo.Bool.value.GetEnum
// Get value of field as enum type
inline algo_BoolEnum algo::value_GetEnum(const algo::Bool& parent) {
    return algo_BoolEnum(parent.value);
}

// --- algo.Bool.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::Bool& parent, algo_BoolEnum rhs) {
    parent.value = u8(rhs);
}

// --- algo.Bool.value.Cast
inline  algo::Bool::operator algo_BoolEnum() const {
    return algo_BoolEnum((*this).value);
}

// --- algo.Bool..Init
// Set all fields to initial values.
inline void algo::Bool_Init(algo::Bool& parent) {
    parent.value = u8(false);
}

// --- algo.Bool..Ctor
inline  algo::Bool::Bool() {
    algo::Bool_Init(*this);
}

// --- algo.Bool..FieldwiseCtor
inline  algo::Bool::Bool(u8 in_value)
    : value(in_value)
 {
}

// --- algo.Bool..EnumCtor
inline  algo::Bool::Bool(algo_BoolEnum arg) {
    this->value = u8(arg);
}

// --- algo.ByteAry.ary.EmptyQ
// Return true if index is empty
inline bool algo::ary_EmptyQ(algo::ByteAry& parent) {
    return parent.ary_n == 0;
}

// --- algo.ByteAry.ary.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::ary_Find(algo::ByteAry& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- algo.ByteAry.ary.Getary
// Return array pointer by value
inline algo::aryptr<u8> algo::ary_Getary(const algo::ByteAry& parent) {
    return algo::aryptr<u8>(parent.ary_elems, parent.ary_n);
}

// --- algo.ByteAry.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* algo::ary_Last(algo::ByteAry& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- algo.ByteAry.ary.AssignAryptr
// Copy from aryptr (operator=)
inline void algo::ByteAry::operator =(const algo::aryptr<u8> &rhs) {
    ary_Setary(*this, rhs);
}

// --- algo.ByteAry.ary.CtorAryptr
inline  algo::ByteAry::ByteAry(const algo::aryptr<u8> &rhs) {
    ary_elems 	= 0; // (algo.ByteAry.ary)
    ary_n     	= 0; // (algo.ByteAry.ary)
    ary_max   	= 0; // (algo.ByteAry.ary)
    ary_Addary(*this, rhs);
}

// --- algo.ByteAry.ary.Max
// Return max. number of items in the array
inline i32 algo::ary_Max(algo::ByteAry& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- algo.ByteAry.ary.N
// Return number of items in the array
inline i32 algo::ary_N(const algo::ByteAry& parent) {
    return parent.ary_n;
}

// --- algo.ByteAry.ary.RemoveAll
inline void algo::ary_RemoveAll(algo::ByteAry& parent) {
    parent.ary_n = 0;
}

// --- algo.ByteAry.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ary_Reserve(algo::ByteAry& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- algo.ByteAry.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& algo::ary_qFind(algo::ByteAry& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- algo.ByteAry.ary.qLast
// Return reference to last element of array. No bounds checking
inline u8& algo::ary_qLast(algo::ByteAry& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- algo.ByteAry.ary.rowid_Get
// Return row id of specified element
inline u64 algo::ary_rowid_Get(algo::ByteAry& parent, u8 &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- algo.ByteAry.ary.Cast
inline  algo::ByteAry::operator algo::aryptr<u8>() const {
    return ary_Getary(*this);
}

// --- algo.ByteAry.ary_curs.Next
// proceed to next item
inline void algo::ByteAry_ary_curs_Next(ByteAry_ary_curs &curs) {
    curs.index++;
}

// --- algo.ByteAry.ary_curs.Reset
inline void algo::ByteAry_ary_curs_Reset(ByteAry_ary_curs &curs, algo::ByteAry &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- algo.ByteAry.ary_curs.ValidQ
// cursor points to valid item
inline bool algo::ByteAry_ary_curs_ValidQ(ByteAry_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.ByteAry.ary_curs.Access
// item access
inline u8& algo::ByteAry_ary_curs_Access(ByteAry_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.ByteAry..Init
// Set all fields to initial values.
inline void algo::ByteAry_Init(algo::ByteAry& parent) {
    parent.ary_elems 	= 0; // (algo.ByteAry.ary)
    parent.ary_n     	= 0; // (algo.ByteAry.ary)
    parent.ary_max   	= 0; // (algo.ByteAry.ary)
}

// --- algo.ByteAry..Ctor
inline  algo::ByteAry::ByteAry() {
    algo::ByteAry_Init(*this);
}

// --- algo.ByteAry..Dtor
inline  algo::ByteAry::~ByteAry() {
    algo::ByteAry_Uninit(*this);
}

// --- algo.Charset.ch.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int algo::ch_Nbits(algo::Charset& parent) {
    return ch_N(parent) * 64;
}

// --- algo.Charset.ch.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool algo::ch_qGetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- algo.Charset.ch.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool algo::ch_GetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    bool ret = false;
    u64 lim = ch_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ch_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- algo.Charset.ch.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool algo::ch_BitsEmptyQ(algo::Charset& parent) {
    bool retval = true;
    u64 n = ch_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (ch_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- algo.Charset.ch.Sum1s
inline u64 algo::ch_Sum1s(algo::Charset& parent) {
    u64 sum = 0;
    u64 n = ch_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u64_Count1s(ch_qFind(parent, i));
    }
    return sum;
}

// --- algo.Charset.ch.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qClearBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u64(1) << shift); // clear bit
}

// --- algo.Charset.ch.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void algo::ch_ClearBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = ch_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ch_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u64(1) << shift); // clear bit
    }
}

// --- algo.Charset.ch.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qSetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(1) << shift); // set bit
}

// --- algo.Charset.ch.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void algo::ch_SetBit(algo::Charset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = ch_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ch_qFind(parent, elem_idx); // fetch
        elem = elem | (u64(1) << shift); // set bit
    }
}

// --- algo.Charset.ch.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qSetBitVal(algo::Charset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u64(1) << shift)) | (u64(val) << shift); // insert new value
}

// --- algo.Charset.ch.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void algo::ch_qOrBitVal(algo::Charset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ch_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(val) << shift); // Or in val into elem
}

// --- algo.Charset.ch.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void algo::ch_ClearBitsAll(algo::Charset& parent) {
    u64 n = ch_N(parent);
    for (u64 i = 0; i < n; i++) {
        ch_qFind(parent, i) = 0;
    }
}

// --- algo.Charset.ch.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void algo::ch_ClearBits(algo::Charset& parent, algo::Charset &rhs) {
    u64 n = u64_Min(ch_N(parent), ch_N(rhs));
    for (u64 i = 0; i < n; i++) {
        ch_qFind(parent, i) &= ~ch_qFind(rhs, i);
    }
}

// --- algo.Charset.ch.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void algo::ch_OrBits(algo::Charset& parent, algo::Charset &rhs) {
    u64 n = u64_Min(ch_N(parent), ch_N(rhs));
    for (u64 i = 0; i < n; i++) {
        ch_qFind(parent, i) |= ch_qFind(rhs, i);
    }
}

// --- algo.Charset.ch.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 algo::ch_Sup(algo::Charset& parent) {
    u64 lim = ch_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u64 &val = ch_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 64 + bitidx;
            break;
        }
    }
    return ret;
}

// --- algo.Charset.ch.Fill
// Set all elements of fixed array to value RHS
inline void algo::ch_Fill(algo::Charset& parent, const u64 &rhs) {
    for (int i = 0; i < 8; i++) {
        parent.ch_elems[i] = rhs;
    }
}

// --- algo.Charset.ch.Find
// Look up row by row id. Return NULL if out of range
inline u64* algo::ch_Find(algo::Charset& parent, u64 t) {
    u64 idx = t;
    u64 lim = 8;
    return idx < lim ? parent.ch_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Charset.ch.Getary
// Access fixed array ch as aryptr.
inline algo::aryptr<u64> algo::ch_Getary(algo::Charset& parent) {
    return algo::aryptr<u64>(parent.ch_elems, 8);
}

// --- algo.Charset.ch.Max
// Return max number of items in the array
inline i32 algo::ch_Max(algo::Charset& parent) {
    (void)parent;
    return 8;
}

// --- algo.Charset.ch.N
// Return number of items in the array
inline i32 algo::ch_N(const algo::Charset& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 8;
}

// --- algo.Charset.ch.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::ch_Setary(algo::Charset& parent, const algo::aryptr<u64> &rhs) {
    int n = i32_Min(8, rhs.n_elems);
    memcpy(parent.ch_elems, rhs.elems, sizeof(u64)*n);
}

// --- algo.Charset.ch.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u64& algo::ch_qFind(algo::Charset& parent, u64 t) {
    return parent.ch_elems[u64(t)];
}

// --- algo.Charset.ch_bitcurs.Reset
inline void algo::Charset_ch_bitcurs_Reset(Charset_ch_bitcurs &curs, algo::Charset &parent) {
    curs.elems = &ch_qFind(parent,0);
    curs.n_elems = ch_N(parent);
    curs.bit = -1;
    Charset_ch_bitcurs_Next(curs);
}

// --- algo.Charset.ch_bitcurs.ValidQ
// cursor points to valid item
inline bool algo::Charset_ch_bitcurs_ValidQ(Charset_ch_bitcurs &curs) {
    return curs.bit < curs.n_elems*64;
}

// --- algo.Charset.ch_bitcurs.Access
// item access
inline int& algo::Charset_ch_bitcurs_Access(Charset_ch_bitcurs &curs) {
    return curs.bit;
}

// --- algo.Charset.ch_curs.Reset
// cursor points to valid item
inline void algo::Charset_ch_curs_Reset(Charset_ch_curs &curs, algo::Charset &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Charset.ch_curs.ValidQ
// cursor points to valid item
inline bool algo::Charset_ch_curs_ValidQ(Charset_ch_curs &curs) {
    return u64(curs.index) < u64(8);
}

// --- algo.Charset.ch_curs.Next
// proceed to next item
inline void algo::Charset_ch_curs_Next(Charset_ch_curs &curs) {
    curs.index++;
}

// --- algo.Charset.ch_curs.Access
// item access
inline u64& algo::Charset_ch_curs_Access(Charset_ch_curs &curs) {
    return ch_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Charset..Init
// Set all fields to initial values.
inline void algo::Charset_Init(algo::Charset& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch_elems[i] = 0;
    }
}

// --- algo.Charset..Ctor
inline  algo::Charset::Charset() {
    algo::Charset_Init(*this);
}

// --- algo.Smallstr150.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr150& parent, char c) {
    if (parent.n_ch < 150) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr150.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr150& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 150) {
        n_new = 150 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr150.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr150& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr150.ch.HashStrptr
inline u32 algo::Smallstr150_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr150.ch.Init
inline void algo::ch_Init(algo::Smallstr150 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr150.ch.Max
// always return constant 150
inline int algo::ch_Max(algo::Smallstr150& parent) {
    (void)parent;
    return 150;
}

// --- algo.Smallstr150.ch.N
inline int algo::ch_N(const algo::Smallstr150& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr150.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr150::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr150.ch.CtorStrptr
inline  algo::Smallstr150::Smallstr150(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr150.ch.Cast
inline  algo::Smallstr150::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr150..EqOp
inline bool algo::Smallstr150::operator ==(const algo::Smallstr150 &rhs) const {
    return algo::Smallstr150_Eq(const_cast<algo::Smallstr150&>(*this),const_cast<algo::Smallstr150&>(rhs));
}

// --- algo.Smallstr150..NeOp
inline bool algo::Smallstr150::operator !=(const algo::Smallstr150 &rhs) const {
    return !algo::Smallstr150_Eq(const_cast<algo::Smallstr150&>(*this),const_cast<algo::Smallstr150&>(rhs));
}

// --- algo.Smallstr150..Cmp
inline i32 algo::Smallstr150_Cmp(algo::Smallstr150& lhs, algo::Smallstr150& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr150..Init
// Set all fields to initial values.
inline void algo::Smallstr150_Init(algo::Smallstr150& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr150..Eq
inline bool algo::Smallstr150_Eq(algo::Smallstr150& lhs, algo::Smallstr150& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr150..EqOpAryptr
inline bool algo::Smallstr150::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr150..AssignOp
inline algo::Smallstr150& algo::Smallstr150::operator =(const algo::Smallstr150 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr150..Ctor
inline  algo::Smallstr150::Smallstr150() {
    algo::Smallstr150_Init(*this);
}

// --- algo.Smallstr150..CopyCtor
inline  algo::Smallstr150::Smallstr150(const algo::Smallstr150 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Comment.value.Cast
inline  algo::Comment::operator algo::strptr() const {
    return algo::strptr((*this).value);
}

// --- algo.Comment..Cmp
inline i32 algo::Comment_Cmp(algo::Comment& lhs, algo::Comment& rhs) {
    i32 retval = 0;
    retval = algo::Smallstr150_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.Comment..Eq
inline bool algo::Comment_Eq(algo::Comment& lhs, algo::Comment& rhs) {
    bool retval = true;
    retval = algo::Smallstr150_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.Comment..Ctor
inline  algo::Comment::Comment() {
}

// --- algo.Comment..FieldwiseCtor
inline  algo::Comment::Comment(const algo::strptr& in_value)
    : value(in_value)
 {
}

// --- algo.Smallstr250.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr250& parent, char c) {
    if (parent.n_ch < 250) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr250.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr250& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 250) {
        n_new = 250 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr250.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr250& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr250.ch.HashStrptr
inline u32 algo::Smallstr250_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr250.ch.Init
inline void algo::ch_Init(algo::Smallstr250 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr250.ch.Max
// always return constant 250
inline int algo::ch_Max(algo::Smallstr250& parent) {
    (void)parent;
    return 250;
}

// --- algo.Smallstr250.ch.N
inline int algo::ch_N(const algo::Smallstr250& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr250.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr250::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr250.ch.CtorStrptr
inline  algo::Smallstr250::Smallstr250(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr250.ch.Cast
inline  algo::Smallstr250::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr250..EqOp
inline bool algo::Smallstr250::operator ==(const algo::Smallstr250 &rhs) const {
    return algo::Smallstr250_Eq(const_cast<algo::Smallstr250&>(*this),const_cast<algo::Smallstr250&>(rhs));
}

// --- algo.Smallstr250..NeOp
inline bool algo::Smallstr250::operator !=(const algo::Smallstr250 &rhs) const {
    return !algo::Smallstr250_Eq(const_cast<algo::Smallstr250&>(*this),const_cast<algo::Smallstr250&>(rhs));
}

// --- algo.Smallstr250..Cmp
inline i32 algo::Smallstr250_Cmp(algo::Smallstr250& lhs, algo::Smallstr250& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr250..Init
// Set all fields to initial values.
inline void algo::Smallstr250_Init(algo::Smallstr250& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr250..Eq
inline bool algo::Smallstr250_Eq(algo::Smallstr250& lhs, algo::Smallstr250& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr250..EqOpAryptr
inline bool algo::Smallstr250::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr250..AssignOp
inline algo::Smallstr250& algo::Smallstr250::operator =(const algo::Smallstr250 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr250..Ctor
inline  algo::Smallstr250::Smallstr250() {
    algo::Smallstr250_Init(*this);
}

// --- algo.Smallstr250..CopyCtor
inline  algo::Smallstr250::Smallstr250(const algo::Smallstr250 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.CppExpr..Ctor
inline  algo::CppExpr::CppExpr() {
}

// --- algo.CppExpr..FieldwiseCtor
inline  algo::CppExpr::CppExpr(const algo::strptr& in_value)
    : value(in_value)
 {
}

// --- algo.UnTime..Hash
inline u32 algo::UnTime_Hash(u32 prev, algo::UnTime rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnTime..EqOp
inline bool algo::UnTime::operator ==(const algo::UnTime &rhs) const {
    return algo::UnTime_Eq(const_cast<algo::UnTime&>(*this),const_cast<algo::UnTime&>(rhs));
}

// --- algo.UnTime..NeOp
inline bool algo::UnTime::operator !=(const algo::UnTime &rhs) const {
    return !algo::UnTime_Eq(const_cast<algo::UnTime&>(*this),const_cast<algo::UnTime&>(rhs));
}

// --- algo.UnTime..LtOp
inline bool algo::UnTime::operator <(const algo::UnTime &rhs) const {
    return algo::UnTime_Lt(const_cast<algo::UnTime&>(*this),const_cast<algo::UnTime&>(rhs));
}

// --- algo.UnTime..GtOp
inline bool algo::UnTime::operator >(const algo::UnTime &rhs) const {
    return algo::UnTime_Lt(const_cast<algo::UnTime&>(rhs),const_cast<algo::UnTime&>(*this));
}

// --- algo.UnTime..LeOp
inline bool algo::UnTime::operator <=(const algo::UnTime &rhs) const {
    return !algo::UnTime_Lt(const_cast<algo::UnTime&>(rhs),const_cast<algo::UnTime&>(*this));
}

// --- algo.UnTime..GeOp
inline bool algo::UnTime::operator >=(const algo::UnTime &rhs) const {
    return !algo::UnTime_Lt(const_cast<algo::UnTime&>(*this),const_cast<algo::UnTime&>(rhs));
}

// --- algo.UnTime..Lt
inline bool algo::UnTime_Lt(algo::UnTime lhs, algo::UnTime rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnTime..Cmp
inline i32 algo::UnTime_Cmp(algo::UnTime lhs, algo::UnTime rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnTime..Init
// Set all fields to initial values.
inline void algo::UnTime_Init(algo::UnTime& parent) {
    parent.value = i64(0);
}

// --- algo.UnTime..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnTime_UpdateMax(algo::UnTime &lhs, algo::UnTime rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnTime..Min
// Return the lesser of two values
inline algo::UnTime algo::UnTime_Min(algo::UnTime lhs, algo::UnTime rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnTime..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnTime_UpdateMin(algo::UnTime &lhs, algo::UnTime rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnTime..Max
// Return the greater of two values
inline algo::UnTime algo::UnTime_Max(algo::UnTime lhs, algo::UnTime rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnTime..Eq
inline bool algo::UnTime_Eq(algo::UnTime lhs, algo::UnTime rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnTime_Update(algo::UnTime &lhs, algo::UnTime rhs) {
    bool ret = !UnTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.UnTime..Ctor
inline  algo::UnTime::UnTime() {
    algo::UnTime_Init(*this);
}

// --- algo.UnTime..FieldwiseCtor
inline  algo::UnTime::UnTime(i64 in_value)
    : value(in_value)
 {
}

// --- algo.DateCache..Ctor
inline  algo::DateCache::DateCache() {
}

// --- algo.DayRange..Ctor
inline  algo::DayRange::DayRange() {
}

// --- algo.DayRange..FieldwiseCtor
inline  algo::DayRange::DayRange(algo::UnTime in_start, algo::UnTime in_end)
    : start(in_start)
    , end(in_end)
 {
}

// --- algo.Decimal..EqOp
inline bool algo::Decimal::operator ==(const algo::Decimal &rhs) const {
    return algo::Decimal_Eq(const_cast<algo::Decimal&>(*this),const_cast<algo::Decimal&>(rhs));
}

// --- algo.Decimal..NeOp
inline bool algo::Decimal::operator !=(const algo::Decimal &rhs) const {
    return !algo::Decimal_Eq(const_cast<algo::Decimal&>(*this),const_cast<algo::Decimal&>(rhs));
}

// --- algo.Decimal..Cmp
inline i32 algo::Decimal_Cmp(algo::Decimal lhs, algo::Decimal rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.exponent, rhs.exponent);
    if (retval != 0) {
        return retval;
    }
    retval = i64_Cmp(lhs.mantissa, rhs.mantissa);
    return retval;
}

// --- algo.Decimal..Init
// Set all fields to initial values.
inline void algo::Decimal_Init(algo::Decimal& parent) {
    parent.exponent = i32(0);
    parent.mantissa = i64(0);
}

// --- algo.Decimal..Eq
inline bool algo::Decimal_Eq(algo::Decimal lhs, algo::Decimal rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.exponent, rhs.exponent);
    if (!retval) {
        return false;
    }
    retval = i64_Eq(lhs.mantissa, rhs.mantissa);
    return retval;
}

// --- algo.Decimal..Ctor
inline  algo::Decimal::Decimal() {
    algo::Decimal_Init(*this);
}

// --- algo.Decimal..FieldwiseCtor
inline  algo::Decimal::Decimal(i32 in_exponent, i64 in_mantissa)
    : exponent(in_exponent)
    , mantissa(in_mantissa)
 {
}

// --- algo.DirEntry..Ctor
inline  algo::DirEntry::DirEntry() {
    algo::DirEntry_Init(*this);
}

// --- algo.DirEntry..Dtor
inline  algo::DirEntry::~DirEntry() {
    algo::DirEntry_Uninit(*this);
}

// --- algo.DryrunQ.value.Cast
inline  algo::DryrunQ::operator bool() const {
    return bool((*this).value);
}

// --- algo.DryrunQ..Init
// Set all fields to initial values.
inline void algo::DryrunQ_Init(algo::DryrunQ& parent) {
    parent.value = bool(false);
}

// --- algo.DryrunQ..Ctor
inline  algo::DryrunQ::DryrunQ() {
    algo::DryrunQ_Init(*this);
}

// --- algo.DryrunQ..FieldwiseCtor
inline  algo::DryrunQ::DryrunQ(bool in_value)
    : value(in_value)
 {
}

// --- algo.EchoQ.value.GetEnum
// Get value of field as enum type
inline algo_EchoQEnum algo::value_GetEnum(const algo::EchoQ& parent) {
    return algo_EchoQEnum(parent.value);
}

// --- algo.EchoQ.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::EchoQ& parent, algo_EchoQEnum rhs) {
    parent.value = bool(rhs);
}

// --- algo.EchoQ.value.Cast
inline  algo::EchoQ::operator algo_EchoQEnum() const {
    return algo_EchoQEnum((*this).value);
}

// --- algo.EchoQ..Init
// Set all fields to initial values.
inline void algo::EchoQ_Init(algo::EchoQ& parent) {
    parent.value = bool(false);
}

// --- algo.EchoQ..Ctor
inline  algo::EchoQ::EchoQ() {
    algo::EchoQ_Init(*this);
}

// --- algo.EchoQ..FieldwiseCtor
inline  algo::EchoQ::EchoQ(bool in_value)
    : value(in_value)
 {
}

// --- algo.EchoQ..EnumCtor
inline  algo::EchoQ::EchoQ(algo_EchoQEnum arg) {
    this->value = bool(arg);
}

// --- algo.Errns.value.GetEnum
// Get value of field as enum type
inline algo_ErrnsEnum algo::value_GetEnum(const algo::Errns& parent) {
    return algo_ErrnsEnum(parent.value);
}

// --- algo.Errns.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::Errns& parent, algo_ErrnsEnum rhs) {
    parent.value = u8(rhs);
}

// --- algo.Errns.value.Cast
inline  algo::Errns::operator algo_ErrnsEnum() const {
    return algo_ErrnsEnum((*this).value);
}

// --- algo.Errns..Init
// Set all fields to initial values.
inline void algo::Errns_Init(algo::Errns& parent) {
    parent.value = u8(0);
}

// --- algo.Errns..Ctor
inline  algo::Errns::Errns() {
    algo::Errns_Init(*this);
}

// --- algo.Errns..FieldwiseCtor
inline  algo::Errns::Errns(u8 in_value)
    : value(in_value)
 {
}

// --- algo.Errns..EnumCtor
inline  algo::Errns::Errns(algo_ErrnsEnum arg) {
    this->value = u8(arg);
}

// --- algo.Errcode.code.Get
// Retrieve bitfield from value of field value
//    32 bits starting at bit 0.
inline i32 algo::code_Get(const algo::Errcode& parent) {
    return i32((parent.value >> 0) & 0xffffffff);
}

// --- algo.Errcode.code.Set
// Set bitfield in value of field 'value'
//    32 bits starting at bit 0.
inline void algo::code_Set(algo::Errcode& parent, i32 rhs) {
    u64 t1    = u64(0xffffffff) << 0;
    u64 t2    = (u64(rhs) & 0xffffffff) << 0;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- algo.Errcode.type.Get
// Retrieve bitfield from value of field value
//    8 bits starting at bit 32.
inline algo::Errns algo::type_Get(const algo::Errcode& parent) {
    return algo::Errns((parent.value >> 32) & 0xff);
}

// --- algo.Errcode.type.Set
// Set bitfield in value of field 'value'
//    8 bits starting at bit 32.
inline void algo::type_Set(algo::Errcode& parent, algo::Errns rhs) {
    u64 t1    = u64(0xff) << 32;
    u64 t2    = (u64(rhs.value) & 0xff) << 32;
    parent.value = u64((parent.value & ~t1) | t2);
}

// --- algo.Errcode..Init
// Set all fields to initial values.
inline void algo::Errcode_Init(algo::Errcode& parent) {
    parent.value = u64(0);
}

// --- algo.Errcode..Ctor
inline  algo::Errcode::Errcode() {
    algo::Errcode_Init(*this);
}

// --- algo.FailokQ.value.GetEnum
// Get value of field as enum type
inline algo_FailokQEnum algo::value_GetEnum(const algo::FailokQ& parent) {
    return algo_FailokQEnum(parent.value);
}

// --- algo.FailokQ.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::FailokQ& parent, algo_FailokQEnum rhs) {
    parent.value = bool(rhs);
}

// --- algo.FailokQ.value.Cast
inline  algo::FailokQ::operator algo_FailokQEnum() const {
    return algo_FailokQEnum((*this).value);
}

// --- algo.FailokQ..Init
// Set all fields to initial values.
inline void algo::FailokQ_Init(algo::FailokQ& parent) {
    parent.value = bool(false);
}

// --- algo.FailokQ..Ctor
inline  algo::FailokQ::FailokQ() {
    algo::FailokQ_Init(*this);
}

// --- algo.FailokQ..FieldwiseCtor
inline  algo::FailokQ::FailokQ(bool in_value)
    : value(in_value)
 {
}

// --- algo.FailokQ..EnumCtor
inline  algo::FailokQ::FailokQ(algo_FailokQEnum arg) {
    this->value = bool(arg);
}

// --- algo.FieldId.value.GetEnum
// Get value of field as enum type
inline algo_FieldIdEnum algo::value_GetEnum(const algo::FieldId& parent) {
    return algo_FieldIdEnum(parent.value);
}

// --- algo.FieldId.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::FieldId& parent, algo_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- algo.FieldId.value.Cast
inline  algo::FieldId::operator algo_FieldIdEnum() const {
    return algo_FieldIdEnum((*this).value);
}

// --- algo.FieldId..Init
// Set all fields to initial values.
inline void algo::FieldId_Init(algo::FieldId& parent) {
    parent.value = i32(-1);
}

// --- algo.FieldId..Ctor
inline  algo::FieldId::FieldId() {
    algo::FieldId_Init(*this);
}

// --- algo.FieldId..FieldwiseCtor
inline  algo::FieldId::FieldId(i32 in_value)
    : value(in_value)
 {
}

// --- algo.FieldId..EnumCtor
inline  algo::FieldId::FieldId(algo_FieldIdEnum arg) {
    this->value = i32(arg);
}

// --- algo.Fildes..Hash
inline u32 algo::Fildes_Hash(u32 prev, const algo::Fildes& rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.Fildes..EqOp
inline bool algo::Fildes::operator ==(const algo::Fildes &rhs) const {
    return algo::Fildes_Eq(const_cast<algo::Fildes&>(*this),const_cast<algo::Fildes&>(rhs));
}

// --- algo.Fildes..NeOp
inline bool algo::Fildes::operator !=(const algo::Fildes &rhs) const {
    return !algo::Fildes_Eq(const_cast<algo::Fildes&>(*this),const_cast<algo::Fildes&>(rhs));
}

// --- algo.Fildes..LtOp
inline bool algo::Fildes::operator <(const algo::Fildes &rhs) const {
    return algo::Fildes_Lt(const_cast<algo::Fildes&>(*this),const_cast<algo::Fildes&>(rhs));
}

// --- algo.Fildes..GtOp
inline bool algo::Fildes::operator >(const algo::Fildes &rhs) const {
    return algo::Fildes_Lt(const_cast<algo::Fildes&>(rhs),const_cast<algo::Fildes&>(*this));
}

// --- algo.Fildes..LeOp
inline bool algo::Fildes::operator <=(const algo::Fildes &rhs) const {
    return !algo::Fildes_Lt(const_cast<algo::Fildes&>(rhs),const_cast<algo::Fildes&>(*this));
}

// --- algo.Fildes..GeOp
inline bool algo::Fildes::operator >=(const algo::Fildes &rhs) const {
    return !algo::Fildes_Lt(const_cast<algo::Fildes&>(*this),const_cast<algo::Fildes&>(rhs));
}

// --- algo.Fildes..Lt
inline bool algo::Fildes_Lt(algo::Fildes& lhs, algo::Fildes& rhs) {
    return i32_Lt(lhs.value, rhs.value);
}

// --- algo.Fildes..Cmp
inline i32 algo::Fildes_Cmp(algo::Fildes& lhs, algo::Fildes& rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.Fildes..Init
// Set all fields to initial values.
inline void algo::Fildes_Init(algo::Fildes& parent) {
    parent.value = i32(-1);
}

// --- algo.Fildes..Eq
inline bool algo::Fildes_Eq(algo::Fildes& lhs, algo::Fildes& rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.Fildes..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Fildes_Update(algo::Fildes &lhs, algo::Fildes& rhs) {
    bool ret = !Fildes_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Fildes..Ctor
inline  algo::Fildes::Fildes() {
    algo::Fildes_Init(*this);
}

// --- algo.Fildes..FieldwiseCtor
inline  algo::Fildes::Fildes(i32 in_value)
    : value(in_value)
 {
}

// --- algo.FileFlags.value.Cast
inline  algo::FileFlags::operator algo_FileFlagsEnum() const {
    return algo_FileFlagsEnum((*this).value);
}

// --- algo.FileFlags.append.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
inline bool algo::append_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 4) & 0x01);
}

// --- algo.FileFlags.append.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
inline void algo::append_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 4;
    u32 t2    = (u32(rhs) & 0x01) << 4;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool algo::read_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- algo.FileFlags.read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void algo::read_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 0;
    u32 t2    = (u32(rhs) & 0x01) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool algo::write_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- algo.FileFlags.write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void algo::write_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 1;
    u32 t2    = (u32(rhs) & 0x01) << 1;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags._throw.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 5.
inline bool algo::_throw_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 5) & 0x01);
}

// --- algo.FileFlags._throw.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 5.
inline void algo::_throw_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 5;
    u32 t2    = (u32(rhs) & 0x01) << 5;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.temp.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
inline bool algo::temp_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 6) & 0x01);
}

// --- algo.FileFlags.temp.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
inline void algo::temp_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 6;
    u32 t2    = (u32(rhs) & 0x01) << 6;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.overlap.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 7.
inline bool algo::overlap_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 7) & 0x01);
}

// --- algo.FileFlags.overlap.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 7.
inline void algo::overlap_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 7;
    u32 t2    = (u32(rhs) & 0x01) << 7;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.linear.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 8.
inline bool algo::linear_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 8) & 0x01);
}

// --- algo.FileFlags.linear.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 8.
inline void algo::linear_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 8;
    u32 t2    = (u32(rhs) & 0x01) << 8;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags.printerr.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 9.
inline bool algo::printerr_Get(const algo::FileFlags& parent) {
    return bool((parent.value >> 9) & 0x01);
}

// --- algo.FileFlags.printerr.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 9.
inline void algo::printerr_Set(algo::FileFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 9;
    u32 t2    = (u32(rhs) & 0x01) << 9;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.FileFlags..Init
// Set all fields to initial values.
inline void algo::FileFlags_Init(algo::FileFlags& parent) {
    parent.value = u32(0);
}

// --- algo.FileFlags..Ctor
inline  algo::FileFlags::FileFlags() {
    algo::FileFlags_Init(*this);
}

// --- algo.FileFlags..FieldwiseCtor
inline  algo::FileFlags::FileFlags(u32 in_value)
    : value(in_value)
 {
}

// --- algo.FileFlags..EnumCtor
inline  algo::FileFlags::FileFlags(algo_FileFlagsEnum arg) {
    this->value = u32(arg);
}

// --- algo.I32Dec1.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec1& parent, double val) {
    double intval = val * 10 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec1.value.GetDouble
inline double algo::value_GetDouble(const algo::I32Dec1& parent) {
    double ret;
    ret = parent.value / double(10);
    return ret;
}

// --- algo.I32Dec1.value.GetInt
// Return integer portion (divide number by 10)
inline i32 algo::value_GetInt(const algo::I32Dec1& parent) {
    i32 ret;
    ret = parent.value / 10;
    return ret;
}

// --- algo.I32Dec1.value.GetScale
// Return constant 10
inline i32 algo::I32Dec1_GetScale() {
    return 10;
}

// --- algo.I32Dec1.value.Cast
inline  algo::I32Dec1::operator i32() const {
    return i32((*this).value);
}

// --- algo.I32Dec1..Hash
inline u32 algo::I32Dec1_Hash(u32 prev, algo::I32Dec1 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec1..Init
// Set all fields to initial values.
inline void algo::I32Dec1_Init(algo::I32Dec1& parent) {
    parent.value = i32(0);
}

// --- algo.I32Dec1..Ctor
inline  algo::I32Dec1::I32Dec1() {
    algo::I32Dec1_Init(*this);
}

// --- algo.I32Dec1..FieldwiseCtor
inline  algo::I32Dec1::I32Dec1(i32 in_value)
    : value(in_value)
 {
}

// --- algo.I32Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec2.value.GetDouble
inline double algo::value_GetDouble(const algo::I32Dec2& parent) {
    double ret;
    ret = parent.value / double(100);
    return ret;
}

// --- algo.I32Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline i32 algo::value_GetInt(const algo::I32Dec2& parent) {
    i32 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.I32Dec2.value.GetScale
// Return constant 100
inline i32 algo::I32Dec2_GetScale() {
    return 100;
}

// --- algo.I32Dec2.value.Cast
inline  algo::I32Dec2::operator i32() const {
    return i32((*this).value);
}

// --- algo.I32Dec2..Hash
inline u32 algo::I32Dec2_Hash(u32 prev, algo::I32Dec2 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec2..Init
// Set all fields to initial values.
inline void algo::I32Dec2_Init(algo::I32Dec2& parent) {
    parent.value = i32(0);
}

// --- algo.I32Dec2..Ctor
inline  algo::I32Dec2::I32Dec2() {
    algo::I32Dec2_Init(*this);
}

// --- algo.I32Dec2..FieldwiseCtor
inline  algo::I32Dec2::I32Dec2(i32 in_value)
    : value(in_value)
 {
}

// --- algo.I32Dec3.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec3& parent, double val) {
    double intval = val * 1000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec3.value.GetDouble
inline double algo::value_GetDouble(const algo::I32Dec3& parent) {
    double ret;
    ret = parent.value / double(1000);
    return ret;
}

// --- algo.I32Dec3.value.GetInt
// Return integer portion (divide number by 1000)
inline i32 algo::value_GetInt(const algo::I32Dec3& parent) {
    i32 ret;
    ret = parent.value / 1000;
    return ret;
}

// --- algo.I32Dec3.value.GetScale
// Return constant 1000
inline i32 algo::I32Dec3_GetScale() {
    return 1000;
}

// --- algo.I32Dec3.value.Cast
inline  algo::I32Dec3::operator i32() const {
    return i32((*this).value);
}

// --- algo.I32Dec3..Hash
inline u32 algo::I32Dec3_Hash(u32 prev, algo::I32Dec3 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec3..Init
// Set all fields to initial values.
inline void algo::I32Dec3_Init(algo::I32Dec3& parent) {
    parent.value = i32(0);
}

// --- algo.I32Dec3..Ctor
inline  algo::I32Dec3::I32Dec3() {
    algo::I32Dec3_Init(*this);
}

// --- algo.I32Dec3..FieldwiseCtor
inline  algo::I32Dec3::I32Dec3(i32 in_value)
    : value(in_value)
 {
}

// --- algo.I32Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec4.value.GetDouble
inline double algo::value_GetDouble(const algo::I32Dec4& parent) {
    double ret;
    ret = parent.value / double(10000);
    return ret;
}

// --- algo.I32Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline i32 algo::value_GetInt(const algo::I32Dec4& parent) {
    i32 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.I32Dec4.value.GetScale
// Return constant 10000
inline i32 algo::I32Dec4_GetScale() {
    return 10000;
}

// --- algo.I32Dec4.value.Cast
inline  algo::I32Dec4::operator i32() const {
    return i32((*this).value);
}

// --- algo.I32Dec4..Hash
inline u32 algo::I32Dec4_Hash(u32 prev, algo::I32Dec4 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec4..Init
// Set all fields to initial values.
inline void algo::I32Dec4_Init(algo::I32Dec4& parent) {
    parent.value = i32(0);
}

// --- algo.I32Dec4..Ctor
inline  algo::I32Dec4::I32Dec4() {
    algo::I32Dec4_Init(*this);
}

// --- algo.I32Dec4..FieldwiseCtor
inline  algo::I32Dec4::I32Dec4(i32 in_value)
    : value(in_value)
 {
}

// --- algo.I32Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I32Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I32Dec5.value.GetDouble
inline double algo::value_GetDouble(const algo::I32Dec5& parent) {
    double ret;
    ret = parent.value / double(100000);
    return ret;
}

// --- algo.I32Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline i32 algo::value_GetInt(const algo::I32Dec5& parent) {
    i32 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.I32Dec5.value.GetScale
// Return constant 100000
inline i32 algo::I32Dec5_GetScale() {
    return 100000;
}

// --- algo.I32Dec5.value.Cast
inline  algo::I32Dec5::operator i32() const {
    return i32((*this).value);
}

// --- algo.I32Dec5..Hash
inline u32 algo::I32Dec5_Hash(u32 prev, algo::I32Dec5 rhs) {
    prev = i32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I32Dec5..Init
// Set all fields to initial values.
inline void algo::I32Dec5_Init(algo::I32Dec5& parent) {
    parent.value = i32(0);
}

// --- algo.I32Dec5..Ctor
inline  algo::I32Dec5::I32Dec5() {
    algo::I32Dec5_Init(*this);
}

// --- algo.I32Dec5..FieldwiseCtor
inline  algo::I32Dec5::I32Dec5(i32 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec1.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec1& parent, double val) {
    double intval = val * 10 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec1.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec1& parent) {
    double ret;
    ret = parent.value / double(10);
    return ret;
}

// --- algo.I64Dec1.value.GetInt
// Return integer portion (divide number by 10)
inline i64 algo::value_GetInt(const algo::I64Dec1& parent) {
    i64 ret;
    ret = parent.value / 10;
    return ret;
}

// --- algo.I64Dec1.value.GetScale
// Return constant 10
inline i64 algo::I64Dec1_GetScale() {
    return 10;
}

// --- algo.I64Dec1.value.Cast
inline  algo::I64Dec1::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec1..Hash
inline u32 algo::I64Dec1_Hash(u32 prev, algo::I64Dec1 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec1..Init
// Set all fields to initial values.
inline void algo::I64Dec1_Init(algo::I64Dec1& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec1..Ctor
inline  algo::I64Dec1::I64Dec1() {
    algo::I64Dec1_Init(*this);
}

// --- algo.I64Dec1..FieldwiseCtor
inline  algo::I64Dec1::I64Dec1(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec10.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec10& parent, double val) {
    double intval = val * 10000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec10.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec10& parent) {
    double ret;
    ret = parent.value / double(10000000000);
    return ret;
}

// --- algo.I64Dec10.value.GetInt
// Return integer portion (divide number by 10000000000)
inline i64 algo::value_GetInt(const algo::I64Dec10& parent) {
    i64 ret;
    ret = parent.value / 10000000000;
    return ret;
}

// --- algo.I64Dec10.value.GetScale
// Return constant 10000000000
inline i64 algo::I64Dec10_GetScale() {
    return 10000000000;
}

// --- algo.I64Dec10.value.Cast
inline  algo::I64Dec10::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec10..Hash
inline u32 algo::I64Dec10_Hash(u32 prev, algo::I64Dec10 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec10..Init
// Set all fields to initial values.
inline void algo::I64Dec10_Init(algo::I64Dec10& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec10..Ctor
inline  algo::I64Dec10::I64Dec10() {
    algo::I64Dec10_Init(*this);
}

// --- algo.I64Dec10..FieldwiseCtor
inline  algo::I64Dec10::I64Dec10(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec2.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec2& parent) {
    double ret;
    ret = parent.value / double(100);
    return ret;
}

// --- algo.I64Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline i64 algo::value_GetInt(const algo::I64Dec2& parent) {
    i64 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.I64Dec2.value.GetScale
// Return constant 100
inline i64 algo::I64Dec2_GetScale() {
    return 100;
}

// --- algo.I64Dec2.value.Cast
inline  algo::I64Dec2::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec2..Hash
inline u32 algo::I64Dec2_Hash(u32 prev, algo::I64Dec2 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec2..Init
// Set all fields to initial values.
inline void algo::I64Dec2_Init(algo::I64Dec2& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec2..Ctor
inline  algo::I64Dec2::I64Dec2() {
    algo::I64Dec2_Init(*this);
}

// --- algo.I64Dec2..FieldwiseCtor
inline  algo::I64Dec2::I64Dec2(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec3.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec3& parent, double val) {
    double intval = val * 1000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec3.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec3& parent) {
    double ret;
    ret = parent.value / double(1000);
    return ret;
}

// --- algo.I64Dec3.value.GetInt
// Return integer portion (divide number by 1000)
inline i64 algo::value_GetInt(const algo::I64Dec3& parent) {
    i64 ret;
    ret = parent.value / 1000;
    return ret;
}

// --- algo.I64Dec3.value.GetScale
// Return constant 1000
inline i64 algo::I64Dec3_GetScale() {
    return 1000;
}

// --- algo.I64Dec3.value.Cast
inline  algo::I64Dec3::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec3..Hash
inline u32 algo::I64Dec3_Hash(u32 prev, algo::I64Dec3 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec3..Init
// Set all fields to initial values.
inline void algo::I64Dec3_Init(algo::I64Dec3& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec3..Ctor
inline  algo::I64Dec3::I64Dec3() {
    algo::I64Dec3_Init(*this);
}

// --- algo.I64Dec3..FieldwiseCtor
inline  algo::I64Dec3::I64Dec3(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec4.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec4& parent) {
    double ret;
    ret = parent.value / double(10000);
    return ret;
}

// --- algo.I64Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline i64 algo::value_GetInt(const algo::I64Dec4& parent) {
    i64 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.I64Dec4.value.GetScale
// Return constant 10000
inline i64 algo::I64Dec4_GetScale() {
    return 10000;
}

// --- algo.I64Dec4.value.Cast
inline  algo::I64Dec4::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec4..Hash
inline u32 algo::I64Dec4_Hash(u32 prev, algo::I64Dec4 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec4..Init
// Set all fields to initial values.
inline void algo::I64Dec4_Init(algo::I64Dec4& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec4..Ctor
inline  algo::I64Dec4::I64Dec4() {
    algo::I64Dec4_Init(*this);
}

// --- algo.I64Dec4..FieldwiseCtor
inline  algo::I64Dec4::I64Dec4(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec5.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec5& parent) {
    double ret;
    ret = parent.value / double(100000);
    return ret;
}

// --- algo.I64Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline i64 algo::value_GetInt(const algo::I64Dec5& parent) {
    i64 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.I64Dec5.value.GetScale
// Return constant 100000
inline i64 algo::I64Dec5_GetScale() {
    return 100000;
}

// --- algo.I64Dec5.value.Cast
inline  algo::I64Dec5::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec5..Hash
inline u32 algo::I64Dec5_Hash(u32 prev, algo::I64Dec5 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec5..Init
// Set all fields to initial values.
inline void algo::I64Dec5_Init(algo::I64Dec5& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec5..Ctor
inline  algo::I64Dec5::I64Dec5() {
    algo::I64Dec5_Init(*this);
}

// --- algo.I64Dec5..FieldwiseCtor
inline  algo::I64Dec5::I64Dec5(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec6.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec6& parent, double val) {
    double intval = val * 1000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec6.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec6& parent) {
    double ret;
    ret = parent.value / double(1000000);
    return ret;
}

// --- algo.I64Dec6.value.GetInt
// Return integer portion (divide number by 1000000)
inline i64 algo::value_GetInt(const algo::I64Dec6& parent) {
    i64 ret;
    ret = parent.value / 1000000;
    return ret;
}

// --- algo.I64Dec6.value.GetScale
// Return constant 1000000
inline i64 algo::I64Dec6_GetScale() {
    return 1000000;
}

// --- algo.I64Dec6.value.Cast
inline  algo::I64Dec6::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec6..Hash
inline u32 algo::I64Dec6_Hash(u32 prev, algo::I64Dec6 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec6..Init
// Set all fields to initial values.
inline void algo::I64Dec6_Init(algo::I64Dec6& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec6..Ctor
inline  algo::I64Dec6::I64Dec6() {
    algo::I64Dec6_Init(*this);
}

// --- algo.I64Dec6..FieldwiseCtor
inline  algo::I64Dec6::I64Dec6(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec7.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec7& parent, double val) {
    double intval = val * 10000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec7.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec7& parent) {
    double ret;
    ret = parent.value / double(10000000);
    return ret;
}

// --- algo.I64Dec7.value.GetInt
// Return integer portion (divide number by 10000000)
inline i64 algo::value_GetInt(const algo::I64Dec7& parent) {
    i64 ret;
    ret = parent.value / 10000000;
    return ret;
}

// --- algo.I64Dec7.value.GetScale
// Return constant 10000000
inline i64 algo::I64Dec7_GetScale() {
    return 10000000;
}

// --- algo.I64Dec7.value.Cast
inline  algo::I64Dec7::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec7..Hash
inline u32 algo::I64Dec7_Hash(u32 prev, algo::I64Dec7 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec7..Init
// Set all fields to initial values.
inline void algo::I64Dec7_Init(algo::I64Dec7& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec7..Ctor
inline  algo::I64Dec7::I64Dec7() {
    algo::I64Dec7_Init(*this);
}

// --- algo.I64Dec7..FieldwiseCtor
inline  algo::I64Dec7::I64Dec7(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec8.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec8& parent, double val) {
    double intval = val * 100000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec8.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec8& parent) {
    double ret;
    ret = parent.value / double(100000000);
    return ret;
}

// --- algo.I64Dec8.value.GetInt
// Return integer portion (divide number by 100000000)
inline i64 algo::value_GetInt(const algo::I64Dec8& parent) {
    i64 ret;
    ret = parent.value / 100000000;
    return ret;
}

// --- algo.I64Dec8.value.GetScale
// Return constant 100000000
inline i64 algo::I64Dec8_GetScale() {
    return 100000000;
}

// --- algo.I64Dec8.value.Cast
inline  algo::I64Dec8::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec8..Hash
inline u32 algo::I64Dec8_Hash(u32 prev, algo::I64Dec8 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec8..Init
// Set all fields to initial values.
inline void algo::I64Dec8_Init(algo::I64Dec8& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec8..Ctor
inline  algo::I64Dec8::I64Dec8() {
    algo::I64Dec8_Init(*this);
}

// --- algo.I64Dec8..FieldwiseCtor
inline  algo::I64Dec8::I64Dec8(i64 in_value)
    : value(in_value)
 {
}

// --- algo.I64Dec9.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::I64Dec9& parent, double val) {
    double intval = val * 1000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.I64Dec9.value.GetDouble
inline double algo::value_GetDouble(const algo::I64Dec9& parent) {
    double ret;
    ret = parent.value / double(1000000000);
    return ret;
}

// --- algo.I64Dec9.value.GetInt
// Return integer portion (divide number by 1000000000)
inline i64 algo::value_GetInt(const algo::I64Dec9& parent) {
    i64 ret;
    ret = parent.value / 1000000000;
    return ret;
}

// --- algo.I64Dec9.value.GetScale
// Return constant 1000000000
inline i64 algo::I64Dec9_GetScale() {
    return 1000000000;
}

// --- algo.I64Dec9.value.Cast
inline  algo::I64Dec9::operator i64() const {
    return i64((*this).value);
}

// --- algo.I64Dec9..Hash
inline u32 algo::I64Dec9_Hash(u32 prev, algo::I64Dec9 rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.I64Dec9..Init
// Set all fields to initial values.
inline void algo::I64Dec9_Init(algo::I64Dec9& parent) {
    parent.value = i64(0);
}

// --- algo.I64Dec9..Ctor
inline  algo::I64Dec9::I64Dec9() {
    algo::I64Dec9_Init(*this);
}

// --- algo.I64Dec9..FieldwiseCtor
inline  algo::I64Dec9::I64Dec9(i64 in_value)
    : value(in_value)
 {
}

// --- algo.IOEvtFlags.value.Cast
inline  algo::IOEvtFlags::operator algo_IOEvtFlagsEnum() const {
    return algo_IOEvtFlagsEnum((*this).value);
}

// --- algo.IOEvtFlags.read.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool algo::read_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- algo.IOEvtFlags.read.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void algo::read_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 0;
    u32 t2    = (u32(rhs) & 0x01) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags.write.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool algo::write_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- algo.IOEvtFlags.write.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void algo::write_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 1;
    u32 t2    = (u32(rhs) & 0x01) << 1;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags.eof.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool algo::eof_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- algo.IOEvtFlags.eof.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void algo::eof_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 2;
    u32 t2    = (u32(rhs) & 0x01) << 2;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags.err.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool algo::err_Get(const algo::IOEvtFlags& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- algo.IOEvtFlags.err.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void algo::err_Set(algo::IOEvtFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 3;
    u32 t2    = (u32(rhs) & 0x01) << 3;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.IOEvtFlags..Init
// Set all fields to initial values.
inline void algo::IOEvtFlags_Init(algo::IOEvtFlags& parent) {
    parent.value = u32(0);
}

// --- algo.IOEvtFlags..Ctor
inline  algo::IOEvtFlags::IOEvtFlags() {
    algo::IOEvtFlags_Init(*this);
}

// --- algo.IOEvtFlags..FieldwiseCtor
inline  algo::IOEvtFlags::IOEvtFlags(u32 in_value)
    : value(in_value)
 {
}

// --- algo.IOEvtFlags..EnumCtor
inline  algo::IOEvtFlags::IOEvtFlags(algo_IOEvtFlagsEnum arg) {
    this->value = u32(arg);
}

// --- algo.IPoint..Init
// Set all fields to initial values.
inline void algo::IPoint_Init(algo::IPoint& parent) {
    parent.x = i32(0);
    parent.y = i32(0);
}

// --- algo.IPoint..Ctor
inline  algo::IPoint::IPoint() {
    algo::IPoint_Init(*this);
}

// --- algo.Smallstr50.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr50& parent, char c) {
    if (parent.n_ch < 50) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr50.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr50& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 50) {
        n_new = 50 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr50.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr50& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr50.ch.HashStrptr
inline u32 algo::Smallstr50_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr50.ch.Init
inline void algo::ch_Init(algo::Smallstr50 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr50.ch.Max
// always return constant 50
inline int algo::ch_Max(algo::Smallstr50& parent) {
    (void)parent;
    return 50;
}

// --- algo.Smallstr50.ch.N
inline int algo::ch_N(const algo::Smallstr50& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr50.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr50::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr50.ch.CtorStrptr
inline  algo::Smallstr50::Smallstr50(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr50.ch.Cast
inline  algo::Smallstr50::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr50..EqOp
inline bool algo::Smallstr50::operator ==(const algo::Smallstr50 &rhs) const {
    return algo::Smallstr50_Eq(const_cast<algo::Smallstr50&>(*this),const_cast<algo::Smallstr50&>(rhs));
}

// --- algo.Smallstr50..NeOp
inline bool algo::Smallstr50::operator !=(const algo::Smallstr50 &rhs) const {
    return !algo::Smallstr50_Eq(const_cast<algo::Smallstr50&>(*this),const_cast<algo::Smallstr50&>(rhs));
}

// --- algo.Smallstr50..LtOp
inline bool algo::Smallstr50::operator <(const algo::Smallstr50 &rhs) const {
    return algo::Smallstr50_Lt(const_cast<algo::Smallstr50&>(*this),const_cast<algo::Smallstr50&>(rhs));
}

// --- algo.Smallstr50..GtOp
inline bool algo::Smallstr50::operator >(const algo::Smallstr50 &rhs) const {
    return algo::Smallstr50_Lt(const_cast<algo::Smallstr50&>(rhs),const_cast<algo::Smallstr50&>(*this));
}

// --- algo.Smallstr50..LeOp
inline bool algo::Smallstr50::operator <=(const algo::Smallstr50 &rhs) const {
    return !algo::Smallstr50_Lt(const_cast<algo::Smallstr50&>(rhs),const_cast<algo::Smallstr50&>(*this));
}

// --- algo.Smallstr50..GeOp
inline bool algo::Smallstr50::operator >=(const algo::Smallstr50 &rhs) const {
    return !algo::Smallstr50_Lt(const_cast<algo::Smallstr50&>(*this),const_cast<algo::Smallstr50&>(rhs));
}

// --- algo.Smallstr50..Lt
inline bool algo::Smallstr50_Lt(algo::Smallstr50& lhs, algo::Smallstr50& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.Smallstr50..Cmp
inline i32 algo::Smallstr50_Cmp(algo::Smallstr50& lhs, algo::Smallstr50& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr50..Init
// Set all fields to initial values.
inline void algo::Smallstr50_Init(algo::Smallstr50& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr50..Eq
inline bool algo::Smallstr50_Eq(algo::Smallstr50& lhs, algo::Smallstr50& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr50..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Smallstr50_Update(algo::Smallstr50 &lhs, algo::Smallstr50& rhs) {
    bool ret = !Smallstr50_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Smallstr50..EqOpAryptr
inline bool algo::Smallstr50::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr50..AssignOp
inline algo::Smallstr50& algo::Smallstr50::operator =(const algo::Smallstr50 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr50..Ctor
inline  algo::Smallstr50::Smallstr50() {
    algo::Smallstr50_Init(*this);
}

// --- algo.Smallstr50..CopyCtor
inline  algo::Smallstr50::Smallstr50(const algo::Smallstr50 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Imdb..Init
// Set all fields to initial values.
inline void algo::Imdb_Init(algo::Imdb& parent) {
    memset(&parent.InsertStrptrMaybe, 0, sizeof(parent.InsertStrptrMaybe));
    memset(&parent.Step, 0, sizeof(parent.Step));
    memset(&parent.MainLoop, 0, sizeof(parent.MainLoop));
    memset(&parent.GetTrace, 0, sizeof(parent.GetTrace));
}

// --- algo.Imdb..Ctor
inline  algo::Imdb::Imdb() {
    algo::Imdb_Init(*this);
}

// --- algo.Imdb..FieldwiseCtor
inline  algo::Imdb::Imdb(const algo::strptr& in_imdb, const algo::ImdbInsertStrptrMaybeFcn& in_InsertStrptrMaybe, const algo::ImdbStepFcn& in_Step, const algo::ImdbMainLoopFcn& in_MainLoop, const algo::ImdbGetTraceFcn& in_GetTrace, const algo::Comment& in_comment)
    : imdb(in_imdb)
    , InsertStrptrMaybe(in_InsertStrptrMaybe)
    , Step(in_Step)
    , MainLoop(in_MainLoop)
    , GetTrace(in_GetTrace)
    , comment(in_comment)
 {
}

// --- algo.ImrowPtr.value.Cast
inline  algo::ImrowPtr::operator u64() const {
    return u64((*this).value);
}

// --- algo.ImrowPtr..Init
// Set all fields to initial values.
inline void algo::ImrowPtr_Init(algo::ImrowPtr& parent) {
    parent.value = u64(0);
}

// --- algo.ImrowPtr..Ctor
inline  algo::ImrowPtr::ImrowPtr() {
    algo::ImrowPtr_Init(*this);
}

// --- algo.ImrowPtr..FieldwiseCtor
inline  algo::ImrowPtr::ImrowPtr(u64 in_value)
    : value(in_value)
 {
}

// --- algo.Smallstr100.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr100& parent, char c) {
    if (parent.n_ch < 100) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr100.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr100& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 100) {
        n_new = 100 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr100.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr100& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr100.ch.HashStrptr
inline u32 algo::Smallstr100_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr100.ch.Init
inline void algo::ch_Init(algo::Smallstr100 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr100.ch.Max
// always return constant 100
inline int algo::ch_Max(algo::Smallstr100& parent) {
    (void)parent;
    return 100;
}

// --- algo.Smallstr100.ch.N
inline int algo::ch_N(const algo::Smallstr100& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr100.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr100::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr100.ch.CtorStrptr
inline  algo::Smallstr100::Smallstr100(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr100.ch.Cast
inline  algo::Smallstr100::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr100..Cmp
inline i32 algo::Smallstr100_Cmp(algo::Smallstr100& lhs, algo::Smallstr100& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr100..Init
// Set all fields to initial values.
inline void algo::Smallstr100_Init(algo::Smallstr100& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr100..Eq
inline bool algo::Smallstr100_Eq(algo::Smallstr100& lhs, algo::Smallstr100& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr100..EqOpAryptr
inline bool algo::Smallstr100::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr100..AssignOp
inline algo::Smallstr100& algo::Smallstr100::operator =(const algo::Smallstr100 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr100..Ctor
inline  algo::Smallstr100::Smallstr100() {
    algo::Smallstr100_Init(*this);
}

// --- algo.Smallstr100..CopyCtor
inline  algo::Smallstr100::Smallstr100(const algo::Smallstr100 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Imtable..Init
// Set all fields to initial values.
inline void algo::Imtable_Init(algo::Imtable& parent) {
    memset(&parent.c_RowidFind, 0, sizeof(parent.c_RowidFind));
    memset(&parent.XrefX, 0, sizeof(parent.XrefX));
    memset(&parent.NItems, 0, sizeof(parent.NItems));
    memset(&parent.Print, 0, sizeof(parent.Print));
    parent.size = i32(0);
}

// --- algo.Imtable..Ctor
inline  algo::Imtable::Imtable() {
    algo::Imtable_Init(*this);
}

// --- algo.Imtable..FieldwiseCtor
inline  algo::Imtable::Imtable(const algo::strptr& in_imtable, const algo::strptr& in_elem_type, const algo::ImrowRowidFindFcn& in_c_RowidFind, const algo::ImrowXrefXFcn& in_XrefX, const algo::ImrowNItemsFcn& in_NItems, const algo::ImrowPrintFcn& in_Print, i32 in_size, const algo::strptr& in_ssimfile, const algo::Comment& in_comment)
    : imtable(in_imtable)
    , elem_type(in_elem_type)
    , c_RowidFind(in_c_RowidFind)
    , XrefX(in_XrefX)
    , NItems(in_NItems)
    , Print(in_Print)
    , size(in_size)
    , ssimfile(in_ssimfile)
    , comment(in_comment)
 {
}

// --- algo.Ipmask..Init
// Set all fields to initial values.
inline void algo::Ipmask_Init(algo::Ipmask& parent) {
    parent.ip_host = u32(0);
    parent.mask = u32(0);
}

// --- algo.Ipmask..Ctor
inline  algo::Ipmask::Ipmask() {
    algo::Ipmask_Init(*this);
}

// --- algo.strptr..Update
// Set value. Return true if new value is different from old value.
inline bool algo::strptr_Update(algo::strptr &lhs, algo::strptr rhs) {
    bool ret = !strptr_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.LineBuf.buf.EmptyQ
// Return true if index is empty
inline bool algo::buf_EmptyQ(algo::LineBuf& parent) {
    return parent.buf_n == 0;
}

// --- algo.LineBuf.buf.Find
// Look up row by row id. Return NULL if out of range
inline char* algo::buf_Find(algo::LineBuf& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.buf_n;
    if (idx >= lim) return NULL;
    return parent.buf_elems + idx;
}

// --- algo.LineBuf.buf.Getary
// Return array pointer by value
inline algo::aryptr<char> algo::buf_Getary(const algo::LineBuf& parent) {
    return algo::aryptr<char>(parent.buf_elems, parent.buf_n);
}

// --- algo.LineBuf.buf.Last
// Return pointer to last element of array, or NULL if array is empty
inline char* algo::buf_Last(algo::LineBuf& parent) {
    return buf_Find(parent, u64(parent.buf_n-1));
}

// --- algo.LineBuf.buf.Max
// Return max. number of items in the array
inline i32 algo::buf_Max(algo::LineBuf& parent) {
    (void)parent;
    return parent.buf_max;
}

// --- algo.LineBuf.buf.N
// Return number of items in the array
inline i32 algo::buf_N(const algo::LineBuf& parent) {
    return parent.buf_n;
}

// --- algo.LineBuf.buf.RemoveAll
inline void algo::buf_RemoveAll(algo::LineBuf& parent) {
    parent.buf_n = 0;
}

// --- algo.LineBuf.buf.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::buf_Reserve(algo::LineBuf& parent, int n) {
    u32 new_n = parent.buf_n + n;
    if (UNLIKELY(new_n > parent.buf_max)) {
        buf_AbsReserve(parent, new_n);
    }
}

// --- algo.LineBuf.buf.qFind
// 'quick' Access row by row id. No bounds checking.
inline char& algo::buf_qFind(algo::LineBuf& parent, u64 t) {
    return parent.buf_elems[t];
}

// --- algo.LineBuf.buf.qLast
// Return reference to last element of array. No bounds checking
inline char& algo::buf_qLast(algo::LineBuf& parent) {
    return buf_qFind(parent, u64(parent.buf_n-1));
}

// --- algo.LineBuf.buf.rowid_Get
// Return row id of specified element
inline u64 algo::buf_rowid_Get(algo::LineBuf& parent, char &elem) {
    u64 id = &elem - parent.buf_elems;
    return u64(id);
}

// --- algo.LineBuf.buf_curs.Next
// proceed to next item
inline void algo::LineBuf_buf_curs_Next(LineBuf_buf_curs &curs) {
    curs.index++;
}

// --- algo.LineBuf.buf_curs.Reset
inline void algo::LineBuf_buf_curs_Reset(LineBuf_buf_curs &curs, algo::LineBuf &parent) {
    curs.elems = parent.buf_elems;
    curs.n_elems = parent.buf_n;
    curs.index = 0;
}

// --- algo.LineBuf.buf_curs.ValidQ
// cursor points to valid item
inline bool algo::LineBuf_buf_curs_ValidQ(LineBuf_buf_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.LineBuf.buf_curs.Access
// item access
inline char& algo::LineBuf_buf_curs_Access(LineBuf_buf_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.LineBuf..Init
// Set all fields to initial values.
inline void algo::LineBuf_Init(algo::LineBuf& parent) {
    parent.buf_elems 	= 0; // (algo.LineBuf.buf)
    parent.buf_n     	= 0; // (algo.LineBuf.buf)
    parent.buf_max   	= 0; // (algo.LineBuf.buf)
    parent.implied_eof = bool(false);
    parent.eof = bool(false);
}

// --- algo.LineBuf..Ctor
inline  algo::LineBuf::LineBuf() {
    algo::LineBuf_Init(*this);
}

// --- algo.LineBuf..Dtor
inline  algo::LineBuf::~LineBuf() {
    algo::LineBuf_Uninit(*this);
}

// --- algo.LnumStr10_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr10_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 10 - len;
    return ret;
}

// --- algo.LnumStr10_U64.ch.HashStrptr
inline u32 algo::LnumStr10_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr10_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr10_U64 &parent) {
    for (int i = 0; i < 10; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr10_U64.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::LnumStr10_U64& parent) {
    (void)parent;
    return 10;
}

// --- algo.LnumStr10_U64.ch.N
inline int algo::ch_N(const algo::LnumStr10_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<10 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 10 - ret;
    return int(ret);
}

// --- algo.LnumStr10_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr10_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr10_U64.ch.CtorStrptr
inline  algo::LnumStr10_U64::LnumStr10_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr10_U64.ch.Cast
inline  algo::LnumStr10_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr10_U64..EqOp
inline bool algo::LnumStr10_U64::operator ==(const algo::LnumStr10_U64 &rhs) const {
    return algo::LnumStr10_U64_Eq(const_cast<algo::LnumStr10_U64&>(*this),const_cast<algo::LnumStr10_U64&>(rhs));
}

// --- algo.LnumStr10_U64..NeOp
inline bool algo::LnumStr10_U64::operator !=(const algo::LnumStr10_U64 &rhs) const {
    return !algo::LnumStr10_U64_Eq(const_cast<algo::LnumStr10_U64&>(*this),const_cast<algo::LnumStr10_U64&>(rhs));
}

// --- algo.LnumStr10_U64..Cmp
inline i32 algo::LnumStr10_U64_Cmp(algo::LnumStr10_U64& lhs, algo::LnumStr10_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr10_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr10_U64_Init(algo::LnumStr10_U64& parent) {
    for (int i = 0; i < 10; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr10_U64..Eq
inline bool algo::LnumStr10_U64_Eq(algo::LnumStr10_U64& lhs, algo::LnumStr10_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8);
    return retval;
}

// --- algo.LnumStr10_U64..EqOpAryptr
inline bool algo::LnumStr10_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr10_U64..AssignOp
inline algo::LnumStr10_U64& algo::LnumStr10_U64::operator =(const algo::LnumStr10_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr10_U64));
    return *this;
}

// --- algo.LnumStr10_U64..Ctor
inline  algo::LnumStr10_U64::LnumStr10_U64() {
    algo::LnumStr10_U64_Init(*this);
}

// --- algo.LnumStr10_U64..CopyCtor
inline  algo::LnumStr10_U64::LnumStr10_U64(const algo::LnumStr10_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr10_U64));
}

// --- algo.LnumStr11_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr11_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 11 - len;
    return ret;
}

// --- algo.LnumStr11_U64.ch.HashStrptr
inline u32 algo::LnumStr11_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr11_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr11_U64 &parent) {
    for (int i = 0; i < 11; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr11_U64.ch.Max
// always return constant 11
inline int algo::ch_Max(algo::LnumStr11_U64& parent) {
    (void)parent;
    return 11;
}

// --- algo.LnumStr11_U64.ch.N
inline int algo::ch_N(const algo::LnumStr11_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<11 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 11 - ret;
    return int(ret);
}

// --- algo.LnumStr11_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr11_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr11_U64.ch.CtorStrptr
inline  algo::LnumStr11_U64::LnumStr11_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr11_U64.ch.Cast
inline  algo::LnumStr11_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr11_U64..EqOp
inline bool algo::LnumStr11_U64::operator ==(const algo::LnumStr11_U64 &rhs) const {
    return algo::LnumStr11_U64_Eq(const_cast<algo::LnumStr11_U64&>(*this),const_cast<algo::LnumStr11_U64&>(rhs));
}

// --- algo.LnumStr11_U64..NeOp
inline bool algo::LnumStr11_U64::operator !=(const algo::LnumStr11_U64 &rhs) const {
    return !algo::LnumStr11_U64_Eq(const_cast<algo::LnumStr11_U64&>(*this),const_cast<algo::LnumStr11_U64&>(rhs));
}

// --- algo.LnumStr11_U64..Cmp
inline i32 algo::LnumStr11_U64_Cmp(algo::LnumStr11_U64& lhs, algo::LnumStr11_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr11_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr11_U64_Init(algo::LnumStr11_U64& parent) {
    for (int i = 0; i < 11; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr11_U64..Eq
inline bool algo::LnumStr11_U64_Eq(algo::LnumStr11_U64& lhs, algo::LnumStr11_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8)
    &&*(u8*)(lhs.ch+10) == *(u8*)(rhs.ch+10);
    return retval;
}

// --- algo.LnumStr11_U64..EqOpAryptr
inline bool algo::LnumStr11_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr11_U64..AssignOp
inline algo::LnumStr11_U64& algo::LnumStr11_U64::operator =(const algo::LnumStr11_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr11_U64));
    return *this;
}

// --- algo.LnumStr11_U64..Ctor
inline  algo::LnumStr11_U64::LnumStr11_U64() {
    algo::LnumStr11_U64_Init(*this);
}

// --- algo.LnumStr11_U64..CopyCtor
inline  algo::LnumStr11_U64::LnumStr11_U64(const algo::LnumStr11_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr11_U64));
}

// --- algo.LnumStr12_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr12_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 12 - len;
    return ret;
}

// --- algo.LnumStr12_U64.ch.HashStrptr
inline u32 algo::LnumStr12_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr12_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr12_U64 &parent) {
    for (int i = 0; i < 12; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr12_U64.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::LnumStr12_U64& parent) {
    (void)parent;
    return 12;
}

// --- algo.LnumStr12_U64.ch.N
inline int algo::ch_N(const algo::LnumStr12_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<12 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 12 - ret;
    return int(ret);
}

// --- algo.LnumStr12_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr12_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr12_U64.ch.CtorStrptr
inline  algo::LnumStr12_U64::LnumStr12_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr12_U64.ch.Cast
inline  algo::LnumStr12_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr12_U64..EqOp
inline bool algo::LnumStr12_U64::operator ==(const algo::LnumStr12_U64 &rhs) const {
    return algo::LnumStr12_U64_Eq(const_cast<algo::LnumStr12_U64&>(*this),const_cast<algo::LnumStr12_U64&>(rhs));
}

// --- algo.LnumStr12_U64..NeOp
inline bool algo::LnumStr12_U64::operator !=(const algo::LnumStr12_U64 &rhs) const {
    return !algo::LnumStr12_U64_Eq(const_cast<algo::LnumStr12_U64&>(*this),const_cast<algo::LnumStr12_U64&>(rhs));
}

// --- algo.LnumStr12_U64..Cmp
inline i32 algo::LnumStr12_U64_Cmp(algo::LnumStr12_U64& lhs, algo::LnumStr12_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr12_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr12_U64_Init(algo::LnumStr12_U64& parent) {
    for (int i = 0; i < 12; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr12_U64..Eq
inline bool algo::LnumStr12_U64_Eq(algo::LnumStr12_U64& lhs, algo::LnumStr12_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8);
    return retval;
}

// --- algo.LnumStr12_U64..EqOpAryptr
inline bool algo::LnumStr12_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr12_U64..AssignOp
inline algo::LnumStr12_U64& algo::LnumStr12_U64::operator =(const algo::LnumStr12_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr12_U64));
    return *this;
}

// --- algo.LnumStr12_U64..Ctor
inline  algo::LnumStr12_U64::LnumStr12_U64() {
    algo::LnumStr12_U64_Init(*this);
}

// --- algo.LnumStr12_U64..CopyCtor
inline  algo::LnumStr12_U64::LnumStr12_U64(const algo::LnumStr12_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr12_U64));
}

// --- algo.LnumStr13_U64_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr13_U64_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 13 - len;
    return ret;
}

// --- algo.LnumStr13_U64_Base36.ch.HashStrptr
inline u32 algo::LnumStr13_U64_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr13_U64_Base36.ch.Init
inline void algo::ch_Init(algo::LnumStr13_U64_Base36 &parent) {
    for (int i = 0; i < 13; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr13_U64_Base36.ch.Max
// always return constant 13
inline int algo::ch_Max(algo::LnumStr13_U64_Base36& parent) {
    (void)parent;
    return 13;
}

// --- algo.LnumStr13_U64_Base36.ch.N
inline int algo::ch_N(const algo::LnumStr13_U64_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<13 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 13 - ret;
    return int(ret);
}

// --- algo.LnumStr13_U64_Base36.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr13_U64_Base36::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr13_U64_Base36.ch.CtorStrptr
inline  algo::LnumStr13_U64_Base36::LnumStr13_U64_Base36(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr13_U64_Base36.ch.Cast
inline  algo::LnumStr13_U64_Base36::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr13_U64_Base36..EqOp
inline bool algo::LnumStr13_U64_Base36::operator ==(const algo::LnumStr13_U64_Base36 &rhs) const {
    return algo::LnumStr13_U64_Base36_Eq(const_cast<algo::LnumStr13_U64_Base36&>(*this),const_cast<algo::LnumStr13_U64_Base36&>(rhs));
}

// --- algo.LnumStr13_U64_Base36..NeOp
inline bool algo::LnumStr13_U64_Base36::operator !=(const algo::LnumStr13_U64_Base36 &rhs) const {
    return !algo::LnumStr13_U64_Base36_Eq(const_cast<algo::LnumStr13_U64_Base36&>(*this),const_cast<algo::LnumStr13_U64_Base36&>(rhs));
}

// --- algo.LnumStr13_U64_Base36..Cmp
inline i32 algo::LnumStr13_U64_Base36_Cmp(algo::LnumStr13_U64_Base36& lhs, algo::LnumStr13_U64_Base36& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr13_U64_Base36..Init
// Set all fields to initial values.
inline void algo::LnumStr13_U64_Base36_Init(algo::LnumStr13_U64_Base36& parent) {
    for (int i = 0; i < 13; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr13_U64_Base36..Eq
inline bool algo::LnumStr13_U64_Base36_Eq(algo::LnumStr13_U64_Base36& lhs, algo::LnumStr13_U64_Base36& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u8*)(lhs.ch+12) == *(u8*)(rhs.ch+12);
    return retval;
}

// --- algo.LnumStr13_U64_Base36..EqOpAryptr
inline bool algo::LnumStr13_U64_Base36::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr13_U64_Base36..AssignOp
inline algo::LnumStr13_U64_Base36& algo::LnumStr13_U64_Base36::operator =(const algo::LnumStr13_U64_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr13_U64_Base36));
    return *this;
}

// --- algo.LnumStr13_U64_Base36..Ctor
inline  algo::LnumStr13_U64_Base36::LnumStr13_U64_Base36() {
    algo::LnumStr13_U64_Base36_Init(*this);
}

// --- algo.LnumStr13_U64_Base36..CopyCtor
inline  algo::LnumStr13_U64_Base36::LnumStr13_U64_Base36(const algo::LnumStr13_U64_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr13_U64_Base36));
}

// --- algo.LnumStr16_U64_Base16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr16_U64_Base16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 16 - len;
    return ret;
}

// --- algo.LnumStr16_U64_Base16.ch.HashStrptr
inline u32 algo::LnumStr16_U64_Base16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr16_U64_Base16.ch.Init
inline void algo::ch_Init(algo::LnumStr16_U64_Base16 &parent) {
    for (int i = 0; i < 16; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr16_U64_Base16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::LnumStr16_U64_Base16& parent) {
    (void)parent;
    return 16;
}

// --- algo.LnumStr16_U64_Base16.ch.N
inline int algo::ch_N(const algo::LnumStr16_U64_Base16& parent) {
    u64 ret;
    ret = 0;
    while (ret<16 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 16 - ret;
    return int(ret);
}

// --- algo.LnumStr16_U64_Base16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr16_U64_Base16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr16_U64_Base16.ch.CtorStrptr
inline  algo::LnumStr16_U64_Base16::LnumStr16_U64_Base16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr16_U64_Base16.ch.Cast
inline  algo::LnumStr16_U64_Base16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr16_U64_Base16..EqOp
inline bool algo::LnumStr16_U64_Base16::operator ==(const algo::LnumStr16_U64_Base16 &rhs) const {
    return algo::LnumStr16_U64_Base16_Eq(const_cast<algo::LnumStr16_U64_Base16&>(*this),const_cast<algo::LnumStr16_U64_Base16&>(rhs));
}

// --- algo.LnumStr16_U64_Base16..NeOp
inline bool algo::LnumStr16_U64_Base16::operator !=(const algo::LnumStr16_U64_Base16 &rhs) const {
    return !algo::LnumStr16_U64_Base16_Eq(const_cast<algo::LnumStr16_U64_Base16&>(*this),const_cast<algo::LnumStr16_U64_Base16&>(rhs));
}

// --- algo.LnumStr16_U64_Base16..Cmp
inline i32 algo::LnumStr16_U64_Base16_Cmp(algo::LnumStr16_U64_Base16& lhs, algo::LnumStr16_U64_Base16& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr16_U64_Base16..Init
// Set all fields to initial values.
inline void algo::LnumStr16_U64_Base16_Init(algo::LnumStr16_U64_Base16& parent) {
    for (int i = 0; i < 16; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr16_U64_Base16..Eq
inline bool algo::LnumStr16_U64_Base16_Eq(algo::LnumStr16_U64_Base16& lhs, algo::LnumStr16_U64_Base16& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8);
    return retval;
}

// --- algo.LnumStr16_U64_Base16..EqOpAryptr
inline bool algo::LnumStr16_U64_Base16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr16_U64_Base16..AssignOp
inline algo::LnumStr16_U64_Base16& algo::LnumStr16_U64_Base16::operator =(const algo::LnumStr16_U64_Base16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr16_U64_Base16));
    return *this;
}

// --- algo.LnumStr16_U64_Base16..Ctor
inline  algo::LnumStr16_U64_Base16::LnumStr16_U64_Base16() {
    algo::LnumStr16_U64_Base16_Init(*this);
}

// --- algo.LnumStr16_U64_Base16..CopyCtor
inline  algo::LnumStr16_U64_Base16::LnumStr16_U64_Base16(const algo::LnumStr16_U64_Base16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr16_U64_Base16));
}

// --- algo.LnumStr1_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr1_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 1 - len;
    return ret;
}

// --- algo.LnumStr1_U32.ch.HashStrptr
inline u32 algo::LnumStr1_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr1_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr1_U32 &parent) {
    for (int i = 0; i < 1; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr1_U32.ch.Max
// always return constant 1
inline int algo::ch_Max(algo::LnumStr1_U32& parent) {
    (void)parent;
    return 1;
}

// --- algo.LnumStr1_U32.ch.N
inline int algo::ch_N(const algo::LnumStr1_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<1 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 1 - ret;
    return int(ret);
}

// --- algo.LnumStr1_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr1_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr1_U32.ch.CtorStrptr
inline  algo::LnumStr1_U32::LnumStr1_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr1_U32.ch.Cast
inline  algo::LnumStr1_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr1_U32..EqOp
inline bool algo::LnumStr1_U32::operator ==(const algo::LnumStr1_U32 &rhs) const {
    return algo::LnumStr1_U32_Eq(const_cast<algo::LnumStr1_U32&>(*this),const_cast<algo::LnumStr1_U32&>(rhs));
}

// --- algo.LnumStr1_U32..NeOp
inline bool algo::LnumStr1_U32::operator !=(const algo::LnumStr1_U32 &rhs) const {
    return !algo::LnumStr1_U32_Eq(const_cast<algo::LnumStr1_U32&>(*this),const_cast<algo::LnumStr1_U32&>(rhs));
}

// --- algo.LnumStr1_U32..Cmp
inline i32 algo::LnumStr1_U32_Cmp(algo::LnumStr1_U32& lhs, algo::LnumStr1_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr1_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr1_U32_Init(algo::LnumStr1_U32& parent) {
    for (int i = 0; i < 1; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr1_U32..Eq
inline bool algo::LnumStr1_U32_Eq(algo::LnumStr1_U32& lhs, algo::LnumStr1_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u8*)(lhs.ch+0) == *(u8*)(rhs.ch+0);
    return retval;
}

// --- algo.LnumStr1_U32..EqOpAryptr
inline bool algo::LnumStr1_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr1_U32..AssignOp
inline algo::LnumStr1_U32& algo::LnumStr1_U32::operator =(const algo::LnumStr1_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr1_U32));
    return *this;
}

// --- algo.LnumStr1_U32..Ctor
inline  algo::LnumStr1_U32::LnumStr1_U32() {
    algo::LnumStr1_U32_Init(*this);
}

// --- algo.LnumStr1_U32..CopyCtor
inline  algo::LnumStr1_U32::LnumStr1_U32(const algo::LnumStr1_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr1_U32));
}

// --- algo.LnumStr20_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr20_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 20 - len;
    return ret;
}

// --- algo.LnumStr20_U64.ch.HashStrptr
inline u32 algo::LnumStr20_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr20_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr20_U64 &parent) {
    for (int i = 0; i < 20; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr20_U64.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::LnumStr20_U64& parent) {
    (void)parent;
    return 20;
}

// --- algo.LnumStr20_U64.ch.N
inline int algo::ch_N(const algo::LnumStr20_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<20 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 20 - ret;
    return int(ret);
}

// --- algo.LnumStr20_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr20_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr20_U64.ch.CtorStrptr
inline  algo::LnumStr20_U64::LnumStr20_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr20_U64.ch.Cast
inline  algo::LnumStr20_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr20_U64..EqOp
inline bool algo::LnumStr20_U64::operator ==(const algo::LnumStr20_U64 &rhs) const {
    return algo::LnumStr20_U64_Eq(const_cast<algo::LnumStr20_U64&>(*this),const_cast<algo::LnumStr20_U64&>(rhs));
}

// --- algo.LnumStr20_U64..NeOp
inline bool algo::LnumStr20_U64::operator !=(const algo::LnumStr20_U64 &rhs) const {
    return !algo::LnumStr20_U64_Eq(const_cast<algo::LnumStr20_U64&>(*this),const_cast<algo::LnumStr20_U64&>(rhs));
}

// --- algo.LnumStr20_U64..Cmp
inline i32 algo::LnumStr20_U64_Cmp(algo::LnumStr20_U64& lhs, algo::LnumStr20_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr20_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr20_U64_Init(algo::LnumStr20_U64& parent) {
    for (int i = 0; i < 20; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr20_U64..Eq
inline bool algo::LnumStr20_U64_Eq(algo::LnumStr20_U64& lhs, algo::LnumStr20_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16);
    return retval;
}

// --- algo.LnumStr20_U64..EqOpAryptr
inline bool algo::LnumStr20_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr20_U64..AssignOp
inline algo::LnumStr20_U64& algo::LnumStr20_U64::operator =(const algo::LnumStr20_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr20_U64));
    return *this;
}

// --- algo.LnumStr20_U64..Ctor
inline  algo::LnumStr20_U64::LnumStr20_U64() {
    algo::LnumStr20_U64_Init(*this);
}

// --- algo.LnumStr20_U64..CopyCtor
inline  algo::LnumStr20_U64::LnumStr20_U64(const algo::LnumStr20_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr20_U64));
}

// --- algo.LnumStr22_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr22_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 22 - len;
    return ret;
}

// --- algo.LnumStr22_U64.ch.HashStrptr
inline u32 algo::LnumStr22_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr22_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr22_U64 &parent) {
    for (int i = 0; i < 22; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr22_U64.ch.Max
// always return constant 22
inline int algo::ch_Max(algo::LnumStr22_U64& parent) {
    (void)parent;
    return 22;
}

// --- algo.LnumStr22_U64.ch.N
inline int algo::ch_N(const algo::LnumStr22_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<22 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 22 - ret;
    return int(ret);
}

// --- algo.LnumStr22_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr22_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr22_U64.ch.CtorStrptr
inline  algo::LnumStr22_U64::LnumStr22_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr22_U64.ch.Cast
inline  algo::LnumStr22_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr22_U64..EqOp
inline bool algo::LnumStr22_U64::operator ==(const algo::LnumStr22_U64 &rhs) const {
    return algo::LnumStr22_U64_Eq(const_cast<algo::LnumStr22_U64&>(*this),const_cast<algo::LnumStr22_U64&>(rhs));
}

// --- algo.LnumStr22_U64..NeOp
inline bool algo::LnumStr22_U64::operator !=(const algo::LnumStr22_U64 &rhs) const {
    return !algo::LnumStr22_U64_Eq(const_cast<algo::LnumStr22_U64&>(*this),const_cast<algo::LnumStr22_U64&>(rhs));
}

// --- algo.LnumStr22_U64..Cmp
inline i32 algo::LnumStr22_U64_Cmp(algo::LnumStr22_U64& lhs, algo::LnumStr22_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr22_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr22_U64_Init(algo::LnumStr22_U64& parent) {
    for (int i = 0; i < 22; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr22_U64..Eq
inline bool algo::LnumStr22_U64_Eq(algo::LnumStr22_U64& lhs, algo::LnumStr22_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16)
    &&*(u16*)(lhs.ch+20) == *(u16*)(rhs.ch+20);
    return retval;
}

// --- algo.LnumStr22_U64..EqOpAryptr
inline bool algo::LnumStr22_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr22_U64..AssignOp
inline algo::LnumStr22_U64& algo::LnumStr22_U64::operator =(const algo::LnumStr22_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr22_U64));
    return *this;
}

// --- algo.LnumStr22_U64..Ctor
inline  algo::LnumStr22_U64::LnumStr22_U64() {
    algo::LnumStr22_U64_Init(*this);
}

// --- algo.LnumStr22_U64..CopyCtor
inline  algo::LnumStr22_U64::LnumStr22_U64(const algo::LnumStr22_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr22_U64));
}

// --- algo.LnumStr2_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr2_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 2 - len;
    return ret;
}

// --- algo.LnumStr2_U32.ch.HashStrptr
inline u32 algo::LnumStr2_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr2_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr2_U32 &parent) {
    for (int i = 0; i < 2; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr2_U32.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::LnumStr2_U32& parent) {
    (void)parent;
    return 2;
}

// --- algo.LnumStr2_U32.ch.N
inline int algo::ch_N(const algo::LnumStr2_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<2 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 2 - ret;
    return int(ret);
}

// --- algo.LnumStr2_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr2_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr2_U32.ch.CtorStrptr
inline  algo::LnumStr2_U32::LnumStr2_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr2_U32.ch.Cast
inline  algo::LnumStr2_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr2_U32..EqOp
inline bool algo::LnumStr2_U32::operator ==(const algo::LnumStr2_U32 &rhs) const {
    return algo::LnumStr2_U32_Eq(const_cast<algo::LnumStr2_U32&>(*this),const_cast<algo::LnumStr2_U32&>(rhs));
}

// --- algo.LnumStr2_U32..NeOp
inline bool algo::LnumStr2_U32::operator !=(const algo::LnumStr2_U32 &rhs) const {
    return !algo::LnumStr2_U32_Eq(const_cast<algo::LnumStr2_U32&>(*this),const_cast<algo::LnumStr2_U32&>(rhs));
}

// --- algo.LnumStr2_U32..Cmp
inline i32 algo::LnumStr2_U32_Cmp(algo::LnumStr2_U32& lhs, algo::LnumStr2_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr2_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr2_U32_Init(algo::LnumStr2_U32& parent) {
    for (int i = 0; i < 2; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr2_U32..Eq
inline bool algo::LnumStr2_U32_Eq(algo::LnumStr2_U32& lhs, algo::LnumStr2_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0);
    return retval;
}

// --- algo.LnumStr2_U32..EqOpAryptr
inline bool algo::LnumStr2_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr2_U32..AssignOp
inline algo::LnumStr2_U32& algo::LnumStr2_U32::operator =(const algo::LnumStr2_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr2_U32));
    return *this;
}

// --- algo.LnumStr2_U32..Ctor
inline  algo::LnumStr2_U32::LnumStr2_U32() {
    algo::LnumStr2_U32_Init(*this);
}

// --- algo.LnumStr2_U32..CopyCtor
inline  algo::LnumStr2_U32::LnumStr2_U32(const algo::LnumStr2_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr2_U32));
}

// --- algo.LnumStr3_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr3_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 3 - len;
    return ret;
}

// --- algo.LnumStr3_U32.ch.HashStrptr
inline u32 algo::LnumStr3_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr3_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr3_U32 &parent) {
    for (int i = 0; i < 3; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr3_U32.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::LnumStr3_U32& parent) {
    (void)parent;
    return 3;
}

// --- algo.LnumStr3_U32.ch.N
inline int algo::ch_N(const algo::LnumStr3_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<3 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 3 - ret;
    return int(ret);
}

// --- algo.LnumStr3_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr3_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr3_U32.ch.CtorStrptr
inline  algo::LnumStr3_U32::LnumStr3_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr3_U32.ch.Cast
inline  algo::LnumStr3_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr3_U32..EqOp
inline bool algo::LnumStr3_U32::operator ==(const algo::LnumStr3_U32 &rhs) const {
    return algo::LnumStr3_U32_Eq(const_cast<algo::LnumStr3_U32&>(*this),const_cast<algo::LnumStr3_U32&>(rhs));
}

// --- algo.LnumStr3_U32..NeOp
inline bool algo::LnumStr3_U32::operator !=(const algo::LnumStr3_U32 &rhs) const {
    return !algo::LnumStr3_U32_Eq(const_cast<algo::LnumStr3_U32&>(*this),const_cast<algo::LnumStr3_U32&>(rhs));
}

// --- algo.LnumStr3_U32..Cmp
inline i32 algo::LnumStr3_U32_Cmp(algo::LnumStr3_U32& lhs, algo::LnumStr3_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr3_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr3_U32_Init(algo::LnumStr3_U32& parent) {
    for (int i = 0; i < 3; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr3_U32..Eq
inline bool algo::LnumStr3_U32_Eq(algo::LnumStr3_U32& lhs, algo::LnumStr3_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+2) == *(u8*)(rhs.ch+2);
    return retval;
}

// --- algo.LnumStr3_U32..EqOpAryptr
inline bool algo::LnumStr3_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr3_U32..AssignOp
inline algo::LnumStr3_U32& algo::LnumStr3_U32::operator =(const algo::LnumStr3_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr3_U32));
    return *this;
}

// --- algo.LnumStr3_U32..Ctor
inline  algo::LnumStr3_U32::LnumStr3_U32() {
    algo::LnumStr3_U32_Init(*this);
}

// --- algo.LnumStr3_U32..CopyCtor
inline  algo::LnumStr3_U32::LnumStr3_U32(const algo::LnumStr3_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr3_U32));
}

// --- algo.LnumStr4_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr4_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 4 - len;
    return ret;
}

// --- algo.LnumStr4_U32.ch.HashStrptr
inline u32 algo::LnumStr4_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr4_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr4_U32 &parent) {
    for (int i = 0; i < 4; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr4_U32.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::LnumStr4_U32& parent) {
    (void)parent;
    return 4;
}

// --- algo.LnumStr4_U32.ch.N
inline int algo::ch_N(const algo::LnumStr4_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<4 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 4 - ret;
    return int(ret);
}

// --- algo.LnumStr4_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr4_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr4_U32.ch.CtorStrptr
inline  algo::LnumStr4_U32::LnumStr4_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr4_U32.ch.Cast
inline  algo::LnumStr4_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr4_U32..EqOp
inline bool algo::LnumStr4_U32::operator ==(const algo::LnumStr4_U32 &rhs) const {
    return algo::LnumStr4_U32_Eq(const_cast<algo::LnumStr4_U32&>(*this),const_cast<algo::LnumStr4_U32&>(rhs));
}

// --- algo.LnumStr4_U32..NeOp
inline bool algo::LnumStr4_U32::operator !=(const algo::LnumStr4_U32 &rhs) const {
    return !algo::LnumStr4_U32_Eq(const_cast<algo::LnumStr4_U32&>(*this),const_cast<algo::LnumStr4_U32&>(rhs));
}

// --- algo.LnumStr4_U32..Cmp
inline i32 algo::LnumStr4_U32_Cmp(algo::LnumStr4_U32& lhs, algo::LnumStr4_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr4_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr4_U32_Init(algo::LnumStr4_U32& parent) {
    for (int i = 0; i < 4; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr4_U32..Eq
inline bool algo::LnumStr4_U32_Eq(algo::LnumStr4_U32& lhs, algo::LnumStr4_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0);
    return retval;
}

// --- algo.LnumStr4_U32..EqOpAryptr
inline bool algo::LnumStr4_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr4_U32..AssignOp
inline algo::LnumStr4_U32& algo::LnumStr4_U32::operator =(const algo::LnumStr4_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr4_U32));
    return *this;
}

// --- algo.LnumStr4_U32..Ctor
inline  algo::LnumStr4_U32::LnumStr4_U32() {
    algo::LnumStr4_U32_Init(*this);
}

// --- algo.LnumStr4_U32..CopyCtor
inline  algo::LnumStr4_U32::LnumStr4_U32(const algo::LnumStr4_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr4_U32));
}

// --- algo.LnumStr5_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr5_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LnumStr5_U32.ch.HashStrptr
inline u32 algo::LnumStr5_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr5_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr5_U32 &parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LnumStr5_U32& parent) {
    (void)parent;
    return 5;
}

// --- algo.LnumStr5_U32.ch.N
inline int algo::ch_N(const algo::LnumStr5_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LnumStr5_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr5_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr5_U32.ch.CtorStrptr
inline  algo::LnumStr5_U32::LnumStr5_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr5_U32.ch.Cast
inline  algo::LnumStr5_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr5_U32..EqOp
inline bool algo::LnumStr5_U32::operator ==(const algo::LnumStr5_U32 &rhs) const {
    return algo::LnumStr5_U32_Eq(const_cast<algo::LnumStr5_U32&>(*this),const_cast<algo::LnumStr5_U32&>(rhs));
}

// --- algo.LnumStr5_U32..NeOp
inline bool algo::LnumStr5_U32::operator !=(const algo::LnumStr5_U32 &rhs) const {
    return !algo::LnumStr5_U32_Eq(const_cast<algo::LnumStr5_U32&>(*this),const_cast<algo::LnumStr5_U32&>(rhs));
}

// --- algo.LnumStr5_U32..Cmp
inline i32 algo::LnumStr5_U32_Cmp(algo::LnumStr5_U32& lhs, algo::LnumStr5_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr5_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr5_U32_Init(algo::LnumStr5_U32& parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32..Eq
inline bool algo::LnumStr5_U32_Eq(algo::LnumStr5_U32& lhs, algo::LnumStr5_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+4) == *(u8*)(rhs.ch+4);
    return retval;
}

// --- algo.LnumStr5_U32..EqOpAryptr
inline bool algo::LnumStr5_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr5_U32..AssignOp
inline algo::LnumStr5_U32& algo::LnumStr5_U32::operator =(const algo::LnumStr5_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr5_U32));
    return *this;
}

// --- algo.LnumStr5_U32..Ctor
inline  algo::LnumStr5_U32::LnumStr5_U32() {
    algo::LnumStr5_U32_Init(*this);
}

// --- algo.LnumStr5_U32..CopyCtor
inline  algo::LnumStr5_U32::LnumStr5_U32(const algo::LnumStr5_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr5_U32));
}

// --- algo.LnumStr5_U32_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr5_U32_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LnumStr5_U32_Base36.ch.HashStrptr
inline u32 algo::LnumStr5_U32_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr5_U32_Base36.ch.Init
inline void algo::ch_Init(algo::LnumStr5_U32_Base36 &parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32_Base36.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LnumStr5_U32_Base36& parent) {
    (void)parent;
    return 5;
}

// --- algo.LnumStr5_U32_Base36.ch.N
inline int algo::ch_N(const algo::LnumStr5_U32_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LnumStr5_U32_Base36.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr5_U32_Base36::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr5_U32_Base36.ch.CtorStrptr
inline  algo::LnumStr5_U32_Base36::LnumStr5_U32_Base36(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr5_U32_Base36.ch.Cast
inline  algo::LnumStr5_U32_Base36::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr5_U32_Base36..EqOp
inline bool algo::LnumStr5_U32_Base36::operator ==(const algo::LnumStr5_U32_Base36 &rhs) const {
    return algo::LnumStr5_U32_Base36_Eq(const_cast<algo::LnumStr5_U32_Base36&>(*this),const_cast<algo::LnumStr5_U32_Base36&>(rhs));
}

// --- algo.LnumStr5_U32_Base36..NeOp
inline bool algo::LnumStr5_U32_Base36::operator !=(const algo::LnumStr5_U32_Base36 &rhs) const {
    return !algo::LnumStr5_U32_Base36_Eq(const_cast<algo::LnumStr5_U32_Base36&>(*this),const_cast<algo::LnumStr5_U32_Base36&>(rhs));
}

// --- algo.LnumStr5_U32_Base36..Cmp
inline i32 algo::LnumStr5_U32_Base36_Cmp(algo::LnumStr5_U32_Base36& lhs, algo::LnumStr5_U32_Base36& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr5_U32_Base36..Init
// Set all fields to initial values.
inline void algo::LnumStr5_U32_Base36_Init(algo::LnumStr5_U32_Base36& parent) {
    for (int i = 0; i < 5; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr5_U32_Base36..Eq
inline bool algo::LnumStr5_U32_Base36_Eq(algo::LnumStr5_U32_Base36& lhs, algo::LnumStr5_U32_Base36& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+4) == *(u8*)(rhs.ch+4);
    return retval;
}

// --- algo.LnumStr5_U32_Base36..EqOpAryptr
inline bool algo::LnumStr5_U32_Base36::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr5_U32_Base36..AssignOp
inline algo::LnumStr5_U32_Base36& algo::LnumStr5_U32_Base36::operator =(const algo::LnumStr5_U32_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr5_U32_Base36));
    return *this;
}

// --- algo.LnumStr5_U32_Base36..Ctor
inline  algo::LnumStr5_U32_Base36::LnumStr5_U32_Base36() {
    algo::LnumStr5_U32_Base36_Init(*this);
}

// --- algo.LnumStr5_U32_Base36..CopyCtor
inline  algo::LnumStr5_U32_Base36::LnumStr5_U32_Base36(const algo::LnumStr5_U32_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr5_U32_Base36));
}

// --- algo.LnumStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 6 - len;
    return ret;
}

// --- algo.LnumStr6_U32.ch.HashStrptr
inline u32 algo::LnumStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr6_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr6_U32 &parent) {
    for (int i = 0; i < 6; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr6_U32.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::LnumStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- algo.LnumStr6_U32.ch.N
inline int algo::ch_N(const algo::LnumStr6_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<6 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 6 - ret;
    return int(ret);
}

// --- algo.LnumStr6_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr6_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr6_U32.ch.CtorStrptr
inline  algo::LnumStr6_U32::LnumStr6_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr6_U32.ch.Cast
inline  algo::LnumStr6_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr6_U32..EqOp
inline bool algo::LnumStr6_U32::operator ==(const algo::LnumStr6_U32 &rhs) const {
    return algo::LnumStr6_U32_Eq(const_cast<algo::LnumStr6_U32&>(*this),const_cast<algo::LnumStr6_U32&>(rhs));
}

// --- algo.LnumStr6_U32..NeOp
inline bool algo::LnumStr6_U32::operator !=(const algo::LnumStr6_U32 &rhs) const {
    return !algo::LnumStr6_U32_Eq(const_cast<algo::LnumStr6_U32&>(*this),const_cast<algo::LnumStr6_U32&>(rhs));
}

// --- algo.LnumStr6_U32..Cmp
inline i32 algo::LnumStr6_U32_Cmp(algo::LnumStr6_U32& lhs, algo::LnumStr6_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr6_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr6_U32_Init(algo::LnumStr6_U32& parent) {
    for (int i = 0; i < 6; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr6_U32..Eq
inline bool algo::LnumStr6_U32_Eq(algo::LnumStr6_U32& lhs, algo::LnumStr6_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4);
    return retval;
}

// --- algo.LnumStr6_U32..EqOpAryptr
inline bool algo::LnumStr6_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr6_U32..AssignOp
inline algo::LnumStr6_U32& algo::LnumStr6_U32::operator =(const algo::LnumStr6_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr6_U32));
    return *this;
}

// --- algo.LnumStr6_U32..Ctor
inline  algo::LnumStr6_U32::LnumStr6_U32() {
    algo::LnumStr6_U32_Init(*this);
}

// --- algo.LnumStr6_U32..CopyCtor
inline  algo::LnumStr6_U32::LnumStr6_U32(const algo::LnumStr6_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr6_U32));
}

// --- algo.LnumStr7_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr7_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 7 - len;
    return ret;
}

// --- algo.LnumStr7_U32.ch.HashStrptr
inline u32 algo::LnumStr7_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr7_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr7_U32 &parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::LnumStr7_U32& parent) {
    (void)parent;
    return 7;
}

// --- algo.LnumStr7_U32.ch.N
inline int algo::ch_N(const algo::LnumStr7_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<7 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 7 - ret;
    return int(ret);
}

// --- algo.LnumStr7_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr7_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr7_U32.ch.CtorStrptr
inline  algo::LnumStr7_U32::LnumStr7_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr7_U32.ch.Cast
inline  algo::LnumStr7_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr7_U32..EqOp
inline bool algo::LnumStr7_U32::operator ==(const algo::LnumStr7_U32 &rhs) const {
    return algo::LnumStr7_U32_Eq(const_cast<algo::LnumStr7_U32&>(*this),const_cast<algo::LnumStr7_U32&>(rhs));
}

// --- algo.LnumStr7_U32..NeOp
inline bool algo::LnumStr7_U32::operator !=(const algo::LnumStr7_U32 &rhs) const {
    return !algo::LnumStr7_U32_Eq(const_cast<algo::LnumStr7_U32&>(*this),const_cast<algo::LnumStr7_U32&>(rhs));
}

// --- algo.LnumStr7_U32..Cmp
inline i32 algo::LnumStr7_U32_Cmp(algo::LnumStr7_U32& lhs, algo::LnumStr7_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr7_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr7_U32_Init(algo::LnumStr7_U32& parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32..Eq
inline bool algo::LnumStr7_U32_Eq(algo::LnumStr7_U32& lhs, algo::LnumStr7_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4)
    &&*(u8*)(lhs.ch+6) == *(u8*)(rhs.ch+6);
    return retval;
}

// --- algo.LnumStr7_U32..EqOpAryptr
inline bool algo::LnumStr7_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr7_U32..AssignOp
inline algo::LnumStr7_U32& algo::LnumStr7_U32::operator =(const algo::LnumStr7_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr7_U32));
    return *this;
}

// --- algo.LnumStr7_U32..Ctor
inline  algo::LnumStr7_U32::LnumStr7_U32() {
    algo::LnumStr7_U32_Init(*this);
}

// --- algo.LnumStr7_U32..CopyCtor
inline  algo::LnumStr7_U32::LnumStr7_U32(const algo::LnumStr7_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr7_U32));
}

// --- algo.LnumStr7_U32_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr7_U32_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 7 - len;
    return ret;
}

// --- algo.LnumStr7_U32_Base36.ch.HashStrptr
inline u32 algo::LnumStr7_U32_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr7_U32_Base36.ch.Init
inline void algo::ch_Init(algo::LnumStr7_U32_Base36 &parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32_Base36.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::LnumStr7_U32_Base36& parent) {
    (void)parent;
    return 7;
}

// --- algo.LnumStr7_U32_Base36.ch.N
inline int algo::ch_N(const algo::LnumStr7_U32_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<7 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 7 - ret;
    return int(ret);
}

// --- algo.LnumStr7_U32_Base36.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr7_U32_Base36::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr7_U32_Base36.ch.CtorStrptr
inline  algo::LnumStr7_U32_Base36::LnumStr7_U32_Base36(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr7_U32_Base36.ch.Cast
inline  algo::LnumStr7_U32_Base36::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr7_U32_Base36..EqOp
inline bool algo::LnumStr7_U32_Base36::operator ==(const algo::LnumStr7_U32_Base36 &rhs) const {
    return algo::LnumStr7_U32_Base36_Eq(const_cast<algo::LnumStr7_U32_Base36&>(*this),const_cast<algo::LnumStr7_U32_Base36&>(rhs));
}

// --- algo.LnumStr7_U32_Base36..NeOp
inline bool algo::LnumStr7_U32_Base36::operator !=(const algo::LnumStr7_U32_Base36 &rhs) const {
    return !algo::LnumStr7_U32_Base36_Eq(const_cast<algo::LnumStr7_U32_Base36&>(*this),const_cast<algo::LnumStr7_U32_Base36&>(rhs));
}

// --- algo.LnumStr7_U32_Base36..Cmp
inline i32 algo::LnumStr7_U32_Base36_Cmp(algo::LnumStr7_U32_Base36& lhs, algo::LnumStr7_U32_Base36& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr7_U32_Base36..Init
// Set all fields to initial values.
inline void algo::LnumStr7_U32_Base36_Init(algo::LnumStr7_U32_Base36& parent) {
    for (int i = 0; i < 7; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr7_U32_Base36..Eq
inline bool algo::LnumStr7_U32_Base36_Eq(algo::LnumStr7_U32_Base36& lhs, algo::LnumStr7_U32_Base36& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4)
    &&*(u8*)(lhs.ch+6) == *(u8*)(rhs.ch+6);
    return retval;
}

// --- algo.LnumStr7_U32_Base36..EqOpAryptr
inline bool algo::LnumStr7_U32_Base36::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr7_U32_Base36..AssignOp
inline algo::LnumStr7_U32_Base36& algo::LnumStr7_U32_Base36::operator =(const algo::LnumStr7_U32_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr7_U32_Base36));
    return *this;
}

// --- algo.LnumStr7_U32_Base36..Ctor
inline  algo::LnumStr7_U32_Base36::LnumStr7_U32_Base36() {
    algo::LnumStr7_U32_Base36_Init(*this);
}

// --- algo.LnumStr7_U32_Base36..CopyCtor
inline  algo::LnumStr7_U32_Base36::LnumStr7_U32_Base36(const algo::LnumStr7_U32_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr7_U32_Base36));
}

// --- algo.LnumStr8_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr8_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LnumStr8_U32.ch.HashStrptr
inline u32 algo::LnumStr8_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr8_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr8_U32 &parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LnumStr8_U32& parent) {
    (void)parent;
    return 8;
}

// --- algo.LnumStr8_U32.ch.N
inline int algo::ch_N(const algo::LnumStr8_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LnumStr8_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr8_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr8_U32.ch.CtorStrptr
inline  algo::LnumStr8_U32::LnumStr8_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr8_U32.ch.Cast
inline  algo::LnumStr8_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr8_U32..EqOp
inline bool algo::LnumStr8_U32::operator ==(const algo::LnumStr8_U32 &rhs) const {
    return algo::LnumStr8_U32_Eq(const_cast<algo::LnumStr8_U32&>(*this),const_cast<algo::LnumStr8_U32&>(rhs));
}

// --- algo.LnumStr8_U32..NeOp
inline bool algo::LnumStr8_U32::operator !=(const algo::LnumStr8_U32 &rhs) const {
    return !algo::LnumStr8_U32_Eq(const_cast<algo::LnumStr8_U32&>(*this),const_cast<algo::LnumStr8_U32&>(rhs));
}

// --- algo.LnumStr8_U32..Cmp
inline i32 algo::LnumStr8_U32_Cmp(algo::LnumStr8_U32& lhs, algo::LnumStr8_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr8_U32_Init(algo::LnumStr8_U32& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32..Eq
inline bool algo::LnumStr8_U32_Eq(algo::LnumStr8_U32& lhs, algo::LnumStr8_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0);
    return retval;
}

// --- algo.LnumStr8_U32..EqOpAryptr
inline bool algo::LnumStr8_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr8_U32..AssignOp
inline algo::LnumStr8_U32& algo::LnumStr8_U32::operator =(const algo::LnumStr8_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr8_U32));
    return *this;
}

// --- algo.LnumStr8_U32..Ctor
inline  algo::LnumStr8_U32::LnumStr8_U32() {
    algo::LnumStr8_U32_Init(*this);
}

// --- algo.LnumStr8_U32..CopyCtor
inline  algo::LnumStr8_U32::LnumStr8_U32(const algo::LnumStr8_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr8_U32));
}

// --- algo.LnumStr8_U32_Base16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr8_U32_Base16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LnumStr8_U32_Base16.ch.HashStrptr
inline u32 algo::LnumStr8_U32_Base16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr8_U32_Base16.ch.Init
inline void algo::ch_Init(algo::LnumStr8_U32_Base16 &parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32_Base16.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LnumStr8_U32_Base16& parent) {
    (void)parent;
    return 8;
}

// --- algo.LnumStr8_U32_Base16.ch.N
inline int algo::ch_N(const algo::LnumStr8_U32_Base16& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LnumStr8_U32_Base16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr8_U32_Base16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr8_U32_Base16.ch.CtorStrptr
inline  algo::LnumStr8_U32_Base16::LnumStr8_U32_Base16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr8_U32_Base16.ch.Cast
inline  algo::LnumStr8_U32_Base16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr8_U32_Base16..EqOp
inline bool algo::LnumStr8_U32_Base16::operator ==(const algo::LnumStr8_U32_Base16 &rhs) const {
    return algo::LnumStr8_U32_Base16_Eq(const_cast<algo::LnumStr8_U32_Base16&>(*this),const_cast<algo::LnumStr8_U32_Base16&>(rhs));
}

// --- algo.LnumStr8_U32_Base16..NeOp
inline bool algo::LnumStr8_U32_Base16::operator !=(const algo::LnumStr8_U32_Base16 &rhs) const {
    return !algo::LnumStr8_U32_Base16_Eq(const_cast<algo::LnumStr8_U32_Base16&>(*this),const_cast<algo::LnumStr8_U32_Base16&>(rhs));
}

// --- algo.LnumStr8_U32_Base16..Cmp
inline i32 algo::LnumStr8_U32_Base16_Cmp(algo::LnumStr8_U32_Base16& lhs, algo::LnumStr8_U32_Base16& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U32_Base16..Init
// Set all fields to initial values.
inline void algo::LnumStr8_U32_Base16_Init(algo::LnumStr8_U32_Base16& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U32_Base16..Eq
inline bool algo::LnumStr8_U32_Base16_Eq(algo::LnumStr8_U32_Base16& lhs, algo::LnumStr8_U32_Base16& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0);
    return retval;
}

// --- algo.LnumStr8_U32_Base16..EqOpAryptr
inline bool algo::LnumStr8_U32_Base16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr8_U32_Base16..AssignOp
inline algo::LnumStr8_U32_Base16& algo::LnumStr8_U32_Base16::operator =(const algo::LnumStr8_U32_Base16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr8_U32_Base16));
    return *this;
}

// --- algo.LnumStr8_U32_Base16..Ctor
inline  algo::LnumStr8_U32_Base16::LnumStr8_U32_Base16() {
    algo::LnumStr8_U32_Base16_Init(*this);
}

// --- algo.LnumStr8_U32_Base16..CopyCtor
inline  algo::LnumStr8_U32_Base16::LnumStr8_U32_Base16(const algo::LnumStr8_U32_Base16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr8_U32_Base16));
}

// --- algo.LnumStr8_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr8_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LnumStr8_U64.ch.HashStrptr
inline u32 algo::LnumStr8_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr8_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr8_U64 &parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U64.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LnumStr8_U64& parent) {
    (void)parent;
    return 8;
}

// --- algo.LnumStr8_U64.ch.N
inline int algo::ch_N(const algo::LnumStr8_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LnumStr8_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr8_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr8_U64.ch.CtorStrptr
inline  algo::LnumStr8_U64::LnumStr8_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr8_U64.ch.Cast
inline  algo::LnumStr8_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr8_U64..EqOp
inline bool algo::LnumStr8_U64::operator ==(const algo::LnumStr8_U64 &rhs) const {
    return algo::LnumStr8_U64_Eq(const_cast<algo::LnumStr8_U64&>(*this),const_cast<algo::LnumStr8_U64&>(rhs));
}

// --- algo.LnumStr8_U64..NeOp
inline bool algo::LnumStr8_U64::operator !=(const algo::LnumStr8_U64 &rhs) const {
    return !algo::LnumStr8_U64_Eq(const_cast<algo::LnumStr8_U64&>(*this),const_cast<algo::LnumStr8_U64&>(rhs));
}

// --- algo.LnumStr8_U64..Cmp
inline i32 algo::LnumStr8_U64_Cmp(algo::LnumStr8_U64& lhs, algo::LnumStr8_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr8_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr8_U64_Init(algo::LnumStr8_U64& parent) {
    for (int i = 0; i < 8; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr8_U64..Eq
inline bool algo::LnumStr8_U64_Eq(algo::LnumStr8_U64& lhs, algo::LnumStr8_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0);
    return retval;
}

// --- algo.LnumStr8_U64..EqOpAryptr
inline bool algo::LnumStr8_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr8_U64..AssignOp
inline algo::LnumStr8_U64& algo::LnumStr8_U64::operator =(const algo::LnumStr8_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr8_U64));
    return *this;
}

// --- algo.LnumStr8_U64..Ctor
inline  algo::LnumStr8_U64::LnumStr8_U64() {
    algo::LnumStr8_U64_Init(*this);
}

// --- algo.LnumStr8_U64..CopyCtor
inline  algo::LnumStr8_U64::LnumStr8_U64(const algo::LnumStr8_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr8_U64));
}

// --- algo.LnumStr9_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr9_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 9 - len;
    return ret;
}

// --- algo.LnumStr9_U32.ch.HashStrptr
inline u32 algo::LnumStr9_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr9_U32.ch.Init
inline void algo::ch_Init(algo::LnumStr9_U32 &parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U32.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::LnumStr9_U32& parent) {
    (void)parent;
    return 9;
}

// --- algo.LnumStr9_U32.ch.N
inline int algo::ch_N(const algo::LnumStr9_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<9 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 9 - ret;
    return int(ret);
}

// --- algo.LnumStr9_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr9_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr9_U32.ch.CtorStrptr
inline  algo::LnumStr9_U32::LnumStr9_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr9_U32.ch.Cast
inline  algo::LnumStr9_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr9_U32..EqOp
inline bool algo::LnumStr9_U32::operator ==(const algo::LnumStr9_U32 &rhs) const {
    return algo::LnumStr9_U32_Eq(const_cast<algo::LnumStr9_U32&>(*this),const_cast<algo::LnumStr9_U32&>(rhs));
}

// --- algo.LnumStr9_U32..NeOp
inline bool algo::LnumStr9_U32::operator !=(const algo::LnumStr9_U32 &rhs) const {
    return !algo::LnumStr9_U32_Eq(const_cast<algo::LnumStr9_U32&>(*this),const_cast<algo::LnumStr9_U32&>(rhs));
}

// --- algo.LnumStr9_U32..Cmp
inline i32 algo::LnumStr9_U32_Cmp(algo::LnumStr9_U32& lhs, algo::LnumStr9_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr9_U32..Init
// Set all fields to initial values.
inline void algo::LnumStr9_U32_Init(algo::LnumStr9_U32& parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U32..Eq
inline bool algo::LnumStr9_U32_Eq(algo::LnumStr9_U32& lhs, algo::LnumStr9_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+8) == *(u8*)(rhs.ch+8);
    return retval;
}

// --- algo.LnumStr9_U32..EqOpAryptr
inline bool algo::LnumStr9_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr9_U32..AssignOp
inline algo::LnumStr9_U32& algo::LnumStr9_U32::operator =(const algo::LnumStr9_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr9_U32));
    return *this;
}

// --- algo.LnumStr9_U32..Ctor
inline  algo::LnumStr9_U32::LnumStr9_U32() {
    algo::LnumStr9_U32_Init(*this);
}

// --- algo.LnumStr9_U32..CopyCtor
inline  algo::LnumStr9_U32::LnumStr9_U32(const algo::LnumStr9_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr9_U32));
}

// --- algo.LnumStr9_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LnumStr9_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 9 - len;
    return ret;
}

// --- algo.LnumStr9_U64.ch.HashStrptr
inline u32 algo::LnumStr9_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LnumStr9_U64.ch.Init
inline void algo::ch_Init(algo::LnumStr9_U64 &parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U64.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::LnumStr9_U64& parent) {
    (void)parent;
    return 9;
}

// --- algo.LnumStr9_U64.ch.N
inline int algo::ch_N(const algo::LnumStr9_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<9 && parent.ch[ret]==u8('0')) {
        ret++;
    }
    ret = 9 - ret;
    return int(ret);
}

// --- algo.LnumStr9_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LnumStr9_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LnumStr9_U64.ch.CtorStrptr
inline  algo::LnumStr9_U64::LnumStr9_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LnumStr9_U64.ch.Cast
inline  algo::LnumStr9_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LnumStr9_U64..EqOp
inline bool algo::LnumStr9_U64::operator ==(const algo::LnumStr9_U64 &rhs) const {
    return algo::LnumStr9_U64_Eq(const_cast<algo::LnumStr9_U64&>(*this),const_cast<algo::LnumStr9_U64&>(rhs));
}

// --- algo.LnumStr9_U64..NeOp
inline bool algo::LnumStr9_U64::operator !=(const algo::LnumStr9_U64 &rhs) const {
    return !algo::LnumStr9_U64_Eq(const_cast<algo::LnumStr9_U64&>(*this),const_cast<algo::LnumStr9_U64&>(rhs));
}

// --- algo.LnumStr9_U64..Cmp
inline i32 algo::LnumStr9_U64_Cmp(algo::LnumStr9_U64& lhs, algo::LnumStr9_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LnumStr9_U64..Init
// Set all fields to initial values.
inline void algo::LnumStr9_U64_Init(algo::LnumStr9_U64& parent) {
    for (int i = 0; i < 9; i++) {
        parent.ch[i] = '0';
    }
}

// --- algo.LnumStr9_U64..Eq
inline bool algo::LnumStr9_U64_Eq(algo::LnumStr9_U64& lhs, algo::LnumStr9_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+8) == *(u8*)(rhs.ch+8);
    return retval;
}

// --- algo.LnumStr9_U64..EqOpAryptr
inline bool algo::LnumStr9_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LnumStr9_U64..AssignOp
inline algo::LnumStr9_U64& algo::LnumStr9_U64::operator =(const algo::LnumStr9_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr9_U64));
    return *this;
}

// --- algo.LnumStr9_U64..Ctor
inline  algo::LnumStr9_U64::LnumStr9_U64() {
    algo::LnumStr9_U64_Init(*this);
}

// --- algo.LnumStr9_U64..CopyCtor
inline  algo::LnumStr9_U64::LnumStr9_U64(const algo::LnumStr9_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LnumStr9_U64));
}

// --- algo.LspaceStr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 10 - len;
    return ret;
}

// --- algo.LspaceStr10.ch.HashStrptr
inline u32 algo::LspaceStr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr10.ch.Init
inline void algo::ch_Init(algo::LspaceStr10 &parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.LspaceStr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::LspaceStr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.LspaceStr10.ch.N
inline int algo::ch_N(const algo::LspaceStr10& parent) {
    u64 ret;
    ret = 0;
    while (ret<10 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 10 - ret;
    return int(ret);
}

// --- algo.LspaceStr10.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr10::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr10.ch.CtorStrptr
inline  algo::LspaceStr10::LspaceStr10(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr10.ch.Cast
inline  algo::LspaceStr10::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr10..EqOp
inline bool algo::LspaceStr10::operator ==(const algo::LspaceStr10 &rhs) const {
    return algo::LspaceStr10_Eq(const_cast<algo::LspaceStr10&>(*this),const_cast<algo::LspaceStr10&>(rhs));
}

// --- algo.LspaceStr10..NeOp
inline bool algo::LspaceStr10::operator !=(const algo::LspaceStr10 &rhs) const {
    return !algo::LspaceStr10_Eq(const_cast<algo::LspaceStr10&>(*this),const_cast<algo::LspaceStr10&>(rhs));
}

// --- algo.LspaceStr10..Cmp
inline i32 algo::LspaceStr10_Cmp(algo::LspaceStr10& lhs, algo::LspaceStr10& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr10..Init
// Set all fields to initial values.
inline void algo::LspaceStr10_Init(algo::LspaceStr10& parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.LspaceStr10..Eq
inline bool algo::LspaceStr10_Eq(algo::LspaceStr10& lhs, algo::LspaceStr10& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8);
    return retval;
}

// --- algo.LspaceStr10..EqOpAryptr
inline bool algo::LspaceStr10::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr10..AssignOp
inline algo::LspaceStr10& algo::LspaceStr10::operator =(const algo::LspaceStr10 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr10));
    return *this;
}

// --- algo.LspaceStr10..Ctor
inline  algo::LspaceStr10::LspaceStr10() {
    algo::LspaceStr10_Init(*this);
}

// --- algo.LspaceStr10..CopyCtor
inline  algo::LspaceStr10::LspaceStr10(const algo::LspaceStr10 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr10));
}

// --- algo.LspaceStr12.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr12& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 12 - len;
    return ret;
}

// --- algo.LspaceStr12.ch.HashStrptr
inline u32 algo::LspaceStr12_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr12.ch.Init
inline void algo::ch_Init(algo::LspaceStr12 &parent) {
    memset(parent.ch, ' ', 12);
}

// --- algo.LspaceStr12.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::LspaceStr12& parent) {
    (void)parent;
    return 12;
}

// --- algo.LspaceStr12.ch.N
inline int algo::ch_N(const algo::LspaceStr12& parent) {
    u64 ret;
    ret = 0;
    while (ret<12 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 12 - ret;
    return int(ret);
}

// --- algo.LspaceStr12.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr12::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr12.ch.CtorStrptr
inline  algo::LspaceStr12::LspaceStr12(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr12.ch.Cast
inline  algo::LspaceStr12::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr12..EqOp
inline bool algo::LspaceStr12::operator ==(const algo::LspaceStr12 &rhs) const {
    return algo::LspaceStr12_Eq(const_cast<algo::LspaceStr12&>(*this),const_cast<algo::LspaceStr12&>(rhs));
}

// --- algo.LspaceStr12..NeOp
inline bool algo::LspaceStr12::operator !=(const algo::LspaceStr12 &rhs) const {
    return !algo::LspaceStr12_Eq(const_cast<algo::LspaceStr12&>(*this),const_cast<algo::LspaceStr12&>(rhs));
}

// --- algo.LspaceStr12..Cmp
inline i32 algo::LspaceStr12_Cmp(algo::LspaceStr12& lhs, algo::LspaceStr12& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr12..Init
// Set all fields to initial values.
inline void algo::LspaceStr12_Init(algo::LspaceStr12& parent) {
    memset(parent.ch, ' ', 12);
}

// --- algo.LspaceStr12..Eq
inline bool algo::LspaceStr12_Eq(algo::LspaceStr12& lhs, algo::LspaceStr12& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8);
    return retval;
}

// --- algo.LspaceStr12..EqOpAryptr
inline bool algo::LspaceStr12::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr12..AssignOp
inline algo::LspaceStr12& algo::LspaceStr12::operator =(const algo::LspaceStr12 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr12));
    return *this;
}

// --- algo.LspaceStr12..Ctor
inline  algo::LspaceStr12::LspaceStr12() {
    algo::LspaceStr12_Init(*this);
}

// --- algo.LspaceStr12..CopyCtor
inline  algo::LspaceStr12::LspaceStr12(const algo::LspaceStr12 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr12));
}

// --- algo.LspaceStr14.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr14& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 14 - len;
    return ret;
}

// --- algo.LspaceStr14.ch.HashStrptr
inline u32 algo::LspaceStr14_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr14.ch.Init
inline void algo::ch_Init(algo::LspaceStr14 &parent) {
    memset(parent.ch, ' ', 14);
}

// --- algo.LspaceStr14.ch.Max
// always return constant 14
inline int algo::ch_Max(algo::LspaceStr14& parent) {
    (void)parent;
    return 14;
}

// --- algo.LspaceStr14.ch.N
inline int algo::ch_N(const algo::LspaceStr14& parent) {
    u64 ret;
    ret = 0;
    while (ret<14 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 14 - ret;
    return int(ret);
}

// --- algo.LspaceStr14.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr14::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr14.ch.CtorStrptr
inline  algo::LspaceStr14::LspaceStr14(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr14.ch.Cast
inline  algo::LspaceStr14::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr14..EqOp
inline bool algo::LspaceStr14::operator ==(const algo::LspaceStr14 &rhs) const {
    return algo::LspaceStr14_Eq(const_cast<algo::LspaceStr14&>(*this),const_cast<algo::LspaceStr14&>(rhs));
}

// --- algo.LspaceStr14..NeOp
inline bool algo::LspaceStr14::operator !=(const algo::LspaceStr14 &rhs) const {
    return !algo::LspaceStr14_Eq(const_cast<algo::LspaceStr14&>(*this),const_cast<algo::LspaceStr14&>(rhs));
}

// --- algo.LspaceStr14..Cmp
inline i32 algo::LspaceStr14_Cmp(algo::LspaceStr14& lhs, algo::LspaceStr14& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr14..Init
// Set all fields to initial values.
inline void algo::LspaceStr14_Init(algo::LspaceStr14& parent) {
    memset(parent.ch, ' ', 14);
}

// --- algo.LspaceStr14..Eq
inline bool algo::LspaceStr14_Eq(algo::LspaceStr14& lhs, algo::LspaceStr14& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+12) == *(u16*)(rhs.ch+12);
    return retval;
}

// --- algo.LspaceStr14..EqOpAryptr
inline bool algo::LspaceStr14::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr14..AssignOp
inline algo::LspaceStr14& algo::LspaceStr14::operator =(const algo::LspaceStr14 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr14));
    return *this;
}

// --- algo.LspaceStr14..Ctor
inline  algo::LspaceStr14::LspaceStr14() {
    algo::LspaceStr14_Init(*this);
}

// --- algo.LspaceStr14..CopyCtor
inline  algo::LspaceStr14::LspaceStr14(const algo::LspaceStr14 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr14));
}

// --- algo.LspaceStr15.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr15& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 15 - len;
    return ret;
}

// --- algo.LspaceStr15.ch.HashStrptr
inline u32 algo::LspaceStr15_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr15.ch.Init
inline void algo::ch_Init(algo::LspaceStr15 &parent) {
    memset(parent.ch, ' ', 15);
}

// --- algo.LspaceStr15.ch.Max
// always return constant 15
inline int algo::ch_Max(algo::LspaceStr15& parent) {
    (void)parent;
    return 15;
}

// --- algo.LspaceStr15.ch.N
inline int algo::ch_N(const algo::LspaceStr15& parent) {
    u64 ret;
    ret = 0;
    while (ret<15 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 15 - ret;
    return int(ret);
}

// --- algo.LspaceStr15.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr15::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr15.ch.CtorStrptr
inline  algo::LspaceStr15::LspaceStr15(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr15.ch.Cast
inline  algo::LspaceStr15::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr15..EqOp
inline bool algo::LspaceStr15::operator ==(const algo::LspaceStr15 &rhs) const {
    return algo::LspaceStr15_Eq(const_cast<algo::LspaceStr15&>(*this),const_cast<algo::LspaceStr15&>(rhs));
}

// --- algo.LspaceStr15..NeOp
inline bool algo::LspaceStr15::operator !=(const algo::LspaceStr15 &rhs) const {
    return !algo::LspaceStr15_Eq(const_cast<algo::LspaceStr15&>(*this),const_cast<algo::LspaceStr15&>(rhs));
}

// --- algo.LspaceStr15..Cmp
inline i32 algo::LspaceStr15_Cmp(algo::LspaceStr15& lhs, algo::LspaceStr15& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr15..Init
// Set all fields to initial values.
inline void algo::LspaceStr15_Init(algo::LspaceStr15& parent) {
    memset(parent.ch, ' ', 15);
}

// --- algo.LspaceStr15..Eq
inline bool algo::LspaceStr15_Eq(algo::LspaceStr15& lhs, algo::LspaceStr15& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+12) == *(u16*)(rhs.ch+12)
    &&*(u8*)(lhs.ch+14) == *(u8*)(rhs.ch+14);
    return retval;
}

// --- algo.LspaceStr15..EqOpAryptr
inline bool algo::LspaceStr15::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr15..AssignOp
inline algo::LspaceStr15& algo::LspaceStr15::operator =(const algo::LspaceStr15 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr15));
    return *this;
}

// --- algo.LspaceStr15..Ctor
inline  algo::LspaceStr15::LspaceStr15() {
    algo::LspaceStr15_Init(*this);
}

// --- algo.LspaceStr15..CopyCtor
inline  algo::LspaceStr15::LspaceStr15(const algo::LspaceStr15 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr15));
}

// --- algo.LspaceStr20_I64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr20_I64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 20 - len;
    return ret;
}

// --- algo.LspaceStr20_I64.ch.HashStrptr
inline u32 algo::LspaceStr20_I64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr20_I64.ch.Init
inline void algo::ch_Init(algo::LspaceStr20_I64 &parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_I64.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::LspaceStr20_I64& parent) {
    (void)parent;
    return 20;
}

// --- algo.LspaceStr20_I64.ch.N
inline int algo::ch_N(const algo::LspaceStr20_I64& parent) {
    u64 ret;
    ret = 0;
    while (ret<20 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 20 - ret;
    return int(ret);
}

// --- algo.LspaceStr20_I64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr20_I64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr20_I64.ch.CtorStrptr
inline  algo::LspaceStr20_I64::LspaceStr20_I64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr20_I64.ch.Cast
inline  algo::LspaceStr20_I64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr20_I64..EqOp
inline bool algo::LspaceStr20_I64::operator ==(const algo::LspaceStr20_I64 &rhs) const {
    return algo::LspaceStr20_I64_Eq(const_cast<algo::LspaceStr20_I64&>(*this),const_cast<algo::LspaceStr20_I64&>(rhs));
}

// --- algo.LspaceStr20_I64..NeOp
inline bool algo::LspaceStr20_I64::operator !=(const algo::LspaceStr20_I64 &rhs) const {
    return !algo::LspaceStr20_I64_Eq(const_cast<algo::LspaceStr20_I64&>(*this),const_cast<algo::LspaceStr20_I64&>(rhs));
}

// --- algo.LspaceStr20_I64..Cmp
inline i32 algo::LspaceStr20_I64_Cmp(algo::LspaceStr20_I64& lhs, algo::LspaceStr20_I64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr20_I64..Init
// Set all fields to initial values.
inline void algo::LspaceStr20_I64_Init(algo::LspaceStr20_I64& parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_I64..Eq
inline bool algo::LspaceStr20_I64_Eq(algo::LspaceStr20_I64& lhs, algo::LspaceStr20_I64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16);
    return retval;
}

// --- algo.LspaceStr20_I64..EqOpAryptr
inline bool algo::LspaceStr20_I64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr20_I64..AssignOp
inline algo::LspaceStr20_I64& algo::LspaceStr20_I64::operator =(const algo::LspaceStr20_I64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr20_I64));
    return *this;
}

// --- algo.LspaceStr20_I64..Ctor
inline  algo::LspaceStr20_I64::LspaceStr20_I64() {
    algo::LspaceStr20_I64_Init(*this);
}

// --- algo.LspaceStr20_I64..CopyCtor
inline  algo::LspaceStr20_I64::LspaceStr20_I64(const algo::LspaceStr20_I64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr20_I64));
}

// --- algo.LspaceStr20_U64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr20_U64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 20 - len;
    return ret;
}

// --- algo.LspaceStr20_U64.ch.HashStrptr
inline u32 algo::LspaceStr20_U64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr20_U64.ch.Init
inline void algo::ch_Init(algo::LspaceStr20_U64 &parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_U64.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::LspaceStr20_U64& parent) {
    (void)parent;
    return 20;
}

// --- algo.LspaceStr20_U64.ch.N
inline int algo::ch_N(const algo::LspaceStr20_U64& parent) {
    u64 ret;
    ret = 0;
    while (ret<20 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 20 - ret;
    return int(ret);
}

// --- algo.LspaceStr20_U64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr20_U64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr20_U64.ch.CtorStrptr
inline  algo::LspaceStr20_U64::LspaceStr20_U64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr20_U64.ch.Cast
inline  algo::LspaceStr20_U64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr20_U64..EqOp
inline bool algo::LspaceStr20_U64::operator ==(const algo::LspaceStr20_U64 &rhs) const {
    return algo::LspaceStr20_U64_Eq(const_cast<algo::LspaceStr20_U64&>(*this),const_cast<algo::LspaceStr20_U64&>(rhs));
}

// --- algo.LspaceStr20_U64..NeOp
inline bool algo::LspaceStr20_U64::operator !=(const algo::LspaceStr20_U64 &rhs) const {
    return !algo::LspaceStr20_U64_Eq(const_cast<algo::LspaceStr20_U64&>(*this),const_cast<algo::LspaceStr20_U64&>(rhs));
}

// --- algo.LspaceStr20_U64..Cmp
inline i32 algo::LspaceStr20_U64_Cmp(algo::LspaceStr20_U64& lhs, algo::LspaceStr20_U64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr20_U64..Init
// Set all fields to initial values.
inline void algo::LspaceStr20_U64_Init(algo::LspaceStr20_U64& parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.LspaceStr20_U64..Eq
inline bool algo::LspaceStr20_U64_Eq(algo::LspaceStr20_U64& lhs, algo::LspaceStr20_U64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16);
    return retval;
}

// --- algo.LspaceStr20_U64..EqOpAryptr
inline bool algo::LspaceStr20_U64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr20_U64..AssignOp
inline algo::LspaceStr20_U64& algo::LspaceStr20_U64::operator =(const algo::LspaceStr20_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr20_U64));
    return *this;
}

// --- algo.LspaceStr20_U64..Ctor
inline  algo::LspaceStr20_U64::LspaceStr20_U64() {
    algo::LspaceStr20_U64_Init(*this);
}

// --- algo.LspaceStr20_U64..CopyCtor
inline  algo::LspaceStr20_U64::LspaceStr20_U64(const algo::LspaceStr20_U64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr20_U64));
}

// --- algo.LspaceStr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 3 - len;
    return ret;
}

// --- algo.LspaceStr3.ch.HashStrptr
inline u32 algo::LspaceStr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr3.ch.Init
inline void algo::ch_Init(algo::LspaceStr3 &parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::LspaceStr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.LspaceStr3.ch.N
inline int algo::ch_N(const algo::LspaceStr3& parent) {
    u64 ret;
    ret = 0;
    while (ret<3 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 3 - ret;
    return int(ret);
}

// --- algo.LspaceStr3.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr3::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr3.ch.CtorStrptr
inline  algo::LspaceStr3::LspaceStr3(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr3.ch.Cast
inline  algo::LspaceStr3::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr3..EqOp
inline bool algo::LspaceStr3::operator ==(const algo::LspaceStr3 &rhs) const {
    return algo::LspaceStr3_Eq(const_cast<algo::LspaceStr3&>(*this),const_cast<algo::LspaceStr3&>(rhs));
}

// --- algo.LspaceStr3..NeOp
inline bool algo::LspaceStr3::operator !=(const algo::LspaceStr3 &rhs) const {
    return !algo::LspaceStr3_Eq(const_cast<algo::LspaceStr3&>(*this),const_cast<algo::LspaceStr3&>(rhs));
}

// --- algo.LspaceStr3..Cmp
inline i32 algo::LspaceStr3_Cmp(algo::LspaceStr3& lhs, algo::LspaceStr3& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr3..Init
// Set all fields to initial values.
inline void algo::LspaceStr3_Init(algo::LspaceStr3& parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3..Eq
inline bool algo::LspaceStr3_Eq(algo::LspaceStr3& lhs, algo::LspaceStr3& rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+2) == *(u8*)(rhs.ch+2);
    return retval;
}

// --- algo.LspaceStr3..EqOpAryptr
inline bool algo::LspaceStr3::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr3..AssignOp
inline algo::LspaceStr3& algo::LspaceStr3::operator =(const algo::LspaceStr3 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr3));
    return *this;
}

// --- algo.LspaceStr3..Ctor
inline  algo::LspaceStr3::LspaceStr3() {
    algo::LspaceStr3_Init(*this);
}

// --- algo.LspaceStr3..CopyCtor
inline  algo::LspaceStr3::LspaceStr3(const algo::LspaceStr3 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr3));
}

// --- algo.LspaceStr3_I16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr3_I16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 3 - len;
    return ret;
}

// --- algo.LspaceStr3_I16.ch.HashStrptr
inline u32 algo::LspaceStr3_I16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr3_I16.ch.Init
inline void algo::ch_Init(algo::LspaceStr3_I16 &parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3_I16.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::LspaceStr3_I16& parent) {
    (void)parent;
    return 3;
}

// --- algo.LspaceStr3_I16.ch.N
inline int algo::ch_N(const algo::LspaceStr3_I16& parent) {
    u64 ret;
    ret = 0;
    while (ret<3 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 3 - ret;
    return int(ret);
}

// --- algo.LspaceStr3_I16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr3_I16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr3_I16.ch.CtorStrptr
inline  algo::LspaceStr3_I16::LspaceStr3_I16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr3_I16.ch.Cast
inline  algo::LspaceStr3_I16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr3_I16..EqOp
inline bool algo::LspaceStr3_I16::operator ==(const algo::LspaceStr3_I16 &rhs) const {
    return algo::LspaceStr3_I16_Eq(const_cast<algo::LspaceStr3_I16&>(*this),const_cast<algo::LspaceStr3_I16&>(rhs));
}

// --- algo.LspaceStr3_I16..NeOp
inline bool algo::LspaceStr3_I16::operator !=(const algo::LspaceStr3_I16 &rhs) const {
    return !algo::LspaceStr3_I16_Eq(const_cast<algo::LspaceStr3_I16&>(*this),const_cast<algo::LspaceStr3_I16&>(rhs));
}

// --- algo.LspaceStr3_I16..Cmp
inline i32 algo::LspaceStr3_I16_Cmp(algo::LspaceStr3_I16& lhs, algo::LspaceStr3_I16& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr3_I16..Init
// Set all fields to initial values.
inline void algo::LspaceStr3_I16_Init(algo::LspaceStr3_I16& parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.LspaceStr3_I16..Eq
inline bool algo::LspaceStr3_I16_Eq(algo::LspaceStr3_I16& lhs, algo::LspaceStr3_I16& rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+2) == *(u8*)(rhs.ch+2);
    return retval;
}

// --- algo.LspaceStr3_I16..EqOpAryptr
inline bool algo::LspaceStr3_I16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr3_I16..AssignOp
inline algo::LspaceStr3_I16& algo::LspaceStr3_I16::operator =(const algo::LspaceStr3_I16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr3_I16));
    return *this;
}

// --- algo.LspaceStr3_I16..Ctor
inline  algo::LspaceStr3_I16::LspaceStr3_I16() {
    algo::LspaceStr3_I16_Init(*this);
}

// --- algo.LspaceStr3_I16..CopyCtor
inline  algo::LspaceStr3_I16::LspaceStr3_I16(const algo::LspaceStr3_I16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr3_I16));
}

// --- algo.LspaceStr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 4 - len;
    return ret;
}

// --- algo.LspaceStr4.ch.HashStrptr
inline u32 algo::LspaceStr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr4.ch.Init
inline void algo::ch_Init(algo::LspaceStr4 &parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.LspaceStr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::LspaceStr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.LspaceStr4.ch.N
inline int algo::ch_N(const algo::LspaceStr4& parent) {
    u64 ret;
    ret = 0;
    while (ret<4 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 4 - ret;
    return int(ret);
}

// --- algo.LspaceStr4.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr4::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr4.ch.CtorStrptr
inline  algo::LspaceStr4::LspaceStr4(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr4.ch.Cast
inline  algo::LspaceStr4::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr4..EqOp
inline bool algo::LspaceStr4::operator ==(const algo::LspaceStr4 &rhs) const {
    return algo::LspaceStr4_Eq(const_cast<algo::LspaceStr4&>(*this),const_cast<algo::LspaceStr4&>(rhs));
}

// --- algo.LspaceStr4..NeOp
inline bool algo::LspaceStr4::operator !=(const algo::LspaceStr4 &rhs) const {
    return !algo::LspaceStr4_Eq(const_cast<algo::LspaceStr4&>(*this),const_cast<algo::LspaceStr4&>(rhs));
}

// --- algo.LspaceStr4..Cmp
inline i32 algo::LspaceStr4_Cmp(algo::LspaceStr4& lhs, algo::LspaceStr4& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr4..Init
// Set all fields to initial values.
inline void algo::LspaceStr4_Init(algo::LspaceStr4& parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.LspaceStr4..Eq
inline bool algo::LspaceStr4_Eq(algo::LspaceStr4& lhs, algo::LspaceStr4& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0);
    return retval;
}

// --- algo.LspaceStr4..EqOpAryptr
inline bool algo::LspaceStr4::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr4..AssignOp
inline algo::LspaceStr4& algo::LspaceStr4::operator =(const algo::LspaceStr4 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr4));
    return *this;
}

// --- algo.LspaceStr4..Ctor
inline  algo::LspaceStr4::LspaceStr4() {
    algo::LspaceStr4_Init(*this);
}

// --- algo.LspaceStr4..CopyCtor
inline  algo::LspaceStr4::LspaceStr4(const algo::LspaceStr4 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr4));
}

// --- algo.LspaceStr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LspaceStr5.ch.HashStrptr
inline u32 algo::LspaceStr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr5.ch.Init
inline void algo::ch_Init(algo::LspaceStr5 &parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LspaceStr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.LspaceStr5.ch.N
inline int algo::ch_N(const algo::LspaceStr5& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LspaceStr5.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr5::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr5.ch.CtorStrptr
inline  algo::LspaceStr5::LspaceStr5(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr5.ch.Cast
inline  algo::LspaceStr5::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr5..EqOp
inline bool algo::LspaceStr5::operator ==(const algo::LspaceStr5 &rhs) const {
    return algo::LspaceStr5_Eq(const_cast<algo::LspaceStr5&>(*this),const_cast<algo::LspaceStr5&>(rhs));
}

// --- algo.LspaceStr5..NeOp
inline bool algo::LspaceStr5::operator !=(const algo::LspaceStr5 &rhs) const {
    return !algo::LspaceStr5_Eq(const_cast<algo::LspaceStr5&>(*this),const_cast<algo::LspaceStr5&>(rhs));
}

// --- algo.LspaceStr5..Cmp
inline i32 algo::LspaceStr5_Cmp(algo::LspaceStr5& lhs, algo::LspaceStr5& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr5..Init
// Set all fields to initial values.
inline void algo::LspaceStr5_Init(algo::LspaceStr5& parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5..Eq
inline bool algo::LspaceStr5_Eq(algo::LspaceStr5& lhs, algo::LspaceStr5& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+4) == *(u8*)(rhs.ch+4);
    return retval;
}

// --- algo.LspaceStr5..EqOpAryptr
inline bool algo::LspaceStr5::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr5..AssignOp
inline algo::LspaceStr5& algo::LspaceStr5::operator =(const algo::LspaceStr5 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr5));
    return *this;
}

// --- algo.LspaceStr5..Ctor
inline  algo::LspaceStr5::LspaceStr5() {
    algo::LspaceStr5_Init(*this);
}

// --- algo.LspaceStr5..CopyCtor
inline  algo::LspaceStr5::LspaceStr5(const algo::LspaceStr5 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr5));
}

// --- algo.LspaceStr5_I16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr5_I16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 5 - len;
    return ret;
}

// --- algo.LspaceStr5_I16.ch.HashStrptr
inline u32 algo::LspaceStr5_I16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr5_I16.ch.Init
inline void algo::ch_Init(algo::LspaceStr5_I16 &parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5_I16.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::LspaceStr5_I16& parent) {
    (void)parent;
    return 5;
}

// --- algo.LspaceStr5_I16.ch.N
inline int algo::ch_N(const algo::LspaceStr5_I16& parent) {
    u64 ret;
    ret = 0;
    while (ret<5 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 5 - ret;
    return int(ret);
}

// --- algo.LspaceStr5_I16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr5_I16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr5_I16.ch.CtorStrptr
inline  algo::LspaceStr5_I16::LspaceStr5_I16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr5_I16.ch.Cast
inline  algo::LspaceStr5_I16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr5_I16..EqOp
inline bool algo::LspaceStr5_I16::operator ==(const algo::LspaceStr5_I16 &rhs) const {
    return algo::LspaceStr5_I16_Eq(const_cast<algo::LspaceStr5_I16&>(*this),const_cast<algo::LspaceStr5_I16&>(rhs));
}

// --- algo.LspaceStr5_I16..NeOp
inline bool algo::LspaceStr5_I16::operator !=(const algo::LspaceStr5_I16 &rhs) const {
    return !algo::LspaceStr5_I16_Eq(const_cast<algo::LspaceStr5_I16&>(*this),const_cast<algo::LspaceStr5_I16&>(rhs));
}

// --- algo.LspaceStr5_I16..Cmp
inline i32 algo::LspaceStr5_I16_Cmp(algo::LspaceStr5_I16& lhs, algo::LspaceStr5_I16& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr5_I16..Init
// Set all fields to initial values.
inline void algo::LspaceStr5_I16_Init(algo::LspaceStr5_I16& parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.LspaceStr5_I16..Eq
inline bool algo::LspaceStr5_I16_Eq(algo::LspaceStr5_I16& lhs, algo::LspaceStr5_I16& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+4) == *(u8*)(rhs.ch+4);
    return retval;
}

// --- algo.LspaceStr5_I16..EqOpAryptr
inline bool algo::LspaceStr5_I16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr5_I16..AssignOp
inline algo::LspaceStr5_I16& algo::LspaceStr5_I16::operator =(const algo::LspaceStr5_I16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr5_I16));
    return *this;
}

// --- algo.LspaceStr5_I16..Ctor
inline  algo::LspaceStr5_I16::LspaceStr5_I16() {
    algo::LspaceStr5_I16_Init(*this);
}

// --- algo.LspaceStr5_I16..CopyCtor
inline  algo::LspaceStr5_I16::LspaceStr5_I16(const algo::LspaceStr5_I16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr5_I16));
}

// --- algo.LspaceStr6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 6 - len;
    return ret;
}

// --- algo.LspaceStr6.ch.HashStrptr
inline u32 algo::LspaceStr6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr6.ch.Init
inline void algo::ch_Init(algo::LspaceStr6 &parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::LspaceStr6& parent) {
    (void)parent;
    return 6;
}

// --- algo.LspaceStr6.ch.N
inline int algo::ch_N(const algo::LspaceStr6& parent) {
    u64 ret;
    ret = 0;
    while (ret<6 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 6 - ret;
    return int(ret);
}

// --- algo.LspaceStr6.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr6::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr6.ch.CtorStrptr
inline  algo::LspaceStr6::LspaceStr6(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr6.ch.Cast
inline  algo::LspaceStr6::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr6..EqOp
inline bool algo::LspaceStr6::operator ==(const algo::LspaceStr6 &rhs) const {
    return algo::LspaceStr6_Eq(const_cast<algo::LspaceStr6&>(*this),const_cast<algo::LspaceStr6&>(rhs));
}

// --- algo.LspaceStr6..NeOp
inline bool algo::LspaceStr6::operator !=(const algo::LspaceStr6 &rhs) const {
    return !algo::LspaceStr6_Eq(const_cast<algo::LspaceStr6&>(*this),const_cast<algo::LspaceStr6&>(rhs));
}

// --- algo.LspaceStr6..Cmp
inline i32 algo::LspaceStr6_Cmp(algo::LspaceStr6& lhs, algo::LspaceStr6& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr6..Init
// Set all fields to initial values.
inline void algo::LspaceStr6_Init(algo::LspaceStr6& parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6..Eq
inline bool algo::LspaceStr6_Eq(algo::LspaceStr6& lhs, algo::LspaceStr6& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4);
    return retval;
}

// --- algo.LspaceStr6..EqOpAryptr
inline bool algo::LspaceStr6::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr6..AssignOp
inline algo::LspaceStr6& algo::LspaceStr6::operator =(const algo::LspaceStr6 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr6));
    return *this;
}

// --- algo.LspaceStr6..Ctor
inline  algo::LspaceStr6::LspaceStr6() {
    algo::LspaceStr6_Init(*this);
}

// --- algo.LspaceStr6..CopyCtor
inline  algo::LspaceStr6::LspaceStr6(const algo::LspaceStr6 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr6));
}

// --- algo.LspaceStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 6 - len;
    return ret;
}

// --- algo.LspaceStr6_U32.ch.HashStrptr
inline u32 algo::LspaceStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr6_U32.ch.Init
inline void algo::ch_Init(algo::LspaceStr6_U32 &parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6_U32.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::LspaceStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- algo.LspaceStr6_U32.ch.N
inline int algo::ch_N(const algo::LspaceStr6_U32& parent) {
    u64 ret;
    ret = 0;
    while (ret<6 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 6 - ret;
    return int(ret);
}

// --- algo.LspaceStr6_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr6_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr6_U32.ch.CtorStrptr
inline  algo::LspaceStr6_U32::LspaceStr6_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr6_U32.ch.Cast
inline  algo::LspaceStr6_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr6_U32..EqOp
inline bool algo::LspaceStr6_U32::operator ==(const algo::LspaceStr6_U32 &rhs) const {
    return algo::LspaceStr6_U32_Eq(const_cast<algo::LspaceStr6_U32&>(*this),const_cast<algo::LspaceStr6_U32&>(rhs));
}

// --- algo.LspaceStr6_U32..NeOp
inline bool algo::LspaceStr6_U32::operator !=(const algo::LspaceStr6_U32 &rhs) const {
    return !algo::LspaceStr6_U32_Eq(const_cast<algo::LspaceStr6_U32&>(*this),const_cast<algo::LspaceStr6_U32&>(rhs));
}

// --- algo.LspaceStr6_U32..Cmp
inline i32 algo::LspaceStr6_U32_Cmp(algo::LspaceStr6_U32& lhs, algo::LspaceStr6_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr6_U32..Init
// Set all fields to initial values.
inline void algo::LspaceStr6_U32_Init(algo::LspaceStr6_U32& parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.LspaceStr6_U32..Eq
inline bool algo::LspaceStr6_U32_Eq(algo::LspaceStr6_U32& lhs, algo::LspaceStr6_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4);
    return retval;
}

// --- algo.LspaceStr6_U32..EqOpAryptr
inline bool algo::LspaceStr6_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr6_U32..AssignOp
inline algo::LspaceStr6_U32& algo::LspaceStr6_U32::operator =(const algo::LspaceStr6_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr6_U32));
    return *this;
}

// --- algo.LspaceStr6_U32..Ctor
inline  algo::LspaceStr6_U32::LspaceStr6_U32() {
    algo::LspaceStr6_U32_Init(*this);
}

// --- algo.LspaceStr6_U32..CopyCtor
inline  algo::LspaceStr6_U32::LspaceStr6_U32(const algo::LspaceStr6_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr6_U32));
}

// --- algo.LspaceStr7_I32_Base36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr7_I32_Base36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 7 - len;
    return ret;
}

// --- algo.LspaceStr7_I32_Base36.ch.HashStrptr
inline u32 algo::LspaceStr7_I32_Base36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr7_I32_Base36.ch.Init
inline void algo::ch_Init(algo::LspaceStr7_I32_Base36 &parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.LspaceStr7_I32_Base36.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::LspaceStr7_I32_Base36& parent) {
    (void)parent;
    return 7;
}

// --- algo.LspaceStr7_I32_Base36.ch.N
inline int algo::ch_N(const algo::LspaceStr7_I32_Base36& parent) {
    u64 ret;
    ret = 0;
    while (ret<7 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 7 - ret;
    return int(ret);
}

// --- algo.LspaceStr7_I32_Base36.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr7_I32_Base36::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr7_I32_Base36.ch.CtorStrptr
inline  algo::LspaceStr7_I32_Base36::LspaceStr7_I32_Base36(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr7_I32_Base36.ch.Cast
inline  algo::LspaceStr7_I32_Base36::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr7_I32_Base36..EqOp
inline bool algo::LspaceStr7_I32_Base36::operator ==(const algo::LspaceStr7_I32_Base36 &rhs) const {
    return algo::LspaceStr7_I32_Base36_Eq(const_cast<algo::LspaceStr7_I32_Base36&>(*this),const_cast<algo::LspaceStr7_I32_Base36&>(rhs));
}

// --- algo.LspaceStr7_I32_Base36..NeOp
inline bool algo::LspaceStr7_I32_Base36::operator !=(const algo::LspaceStr7_I32_Base36 &rhs) const {
    return !algo::LspaceStr7_I32_Base36_Eq(const_cast<algo::LspaceStr7_I32_Base36&>(*this),const_cast<algo::LspaceStr7_I32_Base36&>(rhs));
}

// --- algo.LspaceStr7_I32_Base36..Cmp
inline i32 algo::LspaceStr7_I32_Base36_Cmp(algo::LspaceStr7_I32_Base36& lhs, algo::LspaceStr7_I32_Base36& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..Init
// Set all fields to initial values.
inline void algo::LspaceStr7_I32_Base36_Init(algo::LspaceStr7_I32_Base36& parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.LspaceStr7_I32_Base36..Eq
inline bool algo::LspaceStr7_I32_Base36_Eq(algo::LspaceStr7_I32_Base36& lhs, algo::LspaceStr7_I32_Base36& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4)
    &&*(u8*)(lhs.ch+6) == *(u8*)(rhs.ch+6);
    return retval;
}

// --- algo.LspaceStr7_I32_Base36..EqOpAryptr
inline bool algo::LspaceStr7_I32_Base36::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr7_I32_Base36..AssignOp
inline algo::LspaceStr7_I32_Base36& algo::LspaceStr7_I32_Base36::operator =(const algo::LspaceStr7_I32_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr7_I32_Base36));
    return *this;
}

// --- algo.LspaceStr7_I32_Base36..Ctor
inline  algo::LspaceStr7_I32_Base36::LspaceStr7_I32_Base36() {
    algo::LspaceStr7_I32_Base36_Init(*this);
}

// --- algo.LspaceStr7_I32_Base36..CopyCtor
inline  algo::LspaceStr7_I32_Base36::LspaceStr7_I32_Base36(const algo::LspaceStr7_I32_Base36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr7_I32_Base36));
}

// --- algo.LspaceStr8.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr8& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 8 - len;
    return ret;
}

// --- algo.LspaceStr8.ch.HashStrptr
inline u32 algo::LspaceStr8_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr8.ch.Init
inline void algo::ch_Init(algo::LspaceStr8 &parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.LspaceStr8.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::LspaceStr8& parent) {
    (void)parent;
    return 8;
}

// --- algo.LspaceStr8.ch.N
inline int algo::ch_N(const algo::LspaceStr8& parent) {
    u64 ret;
    ret = 0;
    while (ret<8 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 8 - ret;
    return int(ret);
}

// --- algo.LspaceStr8.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr8::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr8.ch.CtorStrptr
inline  algo::LspaceStr8::LspaceStr8(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr8.ch.Cast
inline  algo::LspaceStr8::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr8..EqOp
inline bool algo::LspaceStr8::operator ==(const algo::LspaceStr8 &rhs) const {
    return algo::LspaceStr8_Eq(const_cast<algo::LspaceStr8&>(*this),const_cast<algo::LspaceStr8&>(rhs));
}

// --- algo.LspaceStr8..NeOp
inline bool algo::LspaceStr8::operator !=(const algo::LspaceStr8 &rhs) const {
    return !algo::LspaceStr8_Eq(const_cast<algo::LspaceStr8&>(*this),const_cast<algo::LspaceStr8&>(rhs));
}

// --- algo.LspaceStr8..Cmp
inline i32 algo::LspaceStr8_Cmp(algo::LspaceStr8& lhs, algo::LspaceStr8& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr8..Init
// Set all fields to initial values.
inline void algo::LspaceStr8_Init(algo::LspaceStr8& parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.LspaceStr8..Eq
inline bool algo::LspaceStr8_Eq(algo::LspaceStr8& lhs, algo::LspaceStr8& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0);
    return retval;
}

// --- algo.LspaceStr8..EqOpAryptr
inline bool algo::LspaceStr8::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr8..AssignOp
inline algo::LspaceStr8& algo::LspaceStr8::operator =(const algo::LspaceStr8 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr8));
    return *this;
}

// --- algo.LspaceStr8..Ctor
inline  algo::LspaceStr8::LspaceStr8() {
    algo::LspaceStr8_Init(*this);
}

// --- algo.LspaceStr8..CopyCtor
inline  algo::LspaceStr8::LspaceStr8(const algo::LspaceStr8 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr8));
}

// --- algo.LspaceStr9.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::LspaceStr9& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    ret.elems += 9 - len;
    return ret;
}

// --- algo.LspaceStr9.ch.HashStrptr
inline u32 algo::LspaceStr9_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.LspaceStr9.ch.Init
inline void algo::ch_Init(algo::LspaceStr9 &parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.LspaceStr9.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::LspaceStr9& parent) {
    (void)parent;
    return 9;
}

// --- algo.LspaceStr9.ch.N
inline int algo::ch_N(const algo::LspaceStr9& parent) {
    u64 ret;
    ret = 0;
    while (ret<9 && parent.ch[ret]==u8(' ')) {
        ret++;
    }
    ret = 9 - ret;
    return int(ret);
}

// --- algo.LspaceStr9.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::LspaceStr9::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.LspaceStr9.ch.CtorStrptr
inline  algo::LspaceStr9::LspaceStr9(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.LspaceStr9.ch.Cast
inline  algo::LspaceStr9::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.LspaceStr9..EqOp
inline bool algo::LspaceStr9::operator ==(const algo::LspaceStr9 &rhs) const {
    return algo::LspaceStr9_Eq(const_cast<algo::LspaceStr9&>(*this),const_cast<algo::LspaceStr9&>(rhs));
}

// --- algo.LspaceStr9..NeOp
inline bool algo::LspaceStr9::operator !=(const algo::LspaceStr9 &rhs) const {
    return !algo::LspaceStr9_Eq(const_cast<algo::LspaceStr9&>(*this),const_cast<algo::LspaceStr9&>(rhs));
}

// --- algo.LspaceStr9..Cmp
inline i32 algo::LspaceStr9_Cmp(algo::LspaceStr9& lhs, algo::LspaceStr9& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.LspaceStr9..Init
// Set all fields to initial values.
inline void algo::LspaceStr9_Init(algo::LspaceStr9& parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.LspaceStr9..Eq
inline bool algo::LspaceStr9_Eq(algo::LspaceStr9& lhs, algo::LspaceStr9& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+8) == *(u8*)(rhs.ch+8);
    return retval;
}

// --- algo.LspaceStr9..EqOpAryptr
inline bool algo::LspaceStr9::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.LspaceStr9..AssignOp
inline algo::LspaceStr9& algo::LspaceStr9::operator =(const algo::LspaceStr9 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr9));
    return *this;
}

// --- algo.LspaceStr9..Ctor
inline  algo::LspaceStr9::LspaceStr9() {
    algo::LspaceStr9_Init(*this);
}

// --- algo.LspaceStr9..CopyCtor
inline  algo::LspaceStr9::LspaceStr9(const algo::LspaceStr9 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::LspaceStr9));
}

// --- algo.Md5Digest.value.Fill
// Set all elements of fixed array to value RHS
inline void algo::value_Fill(algo::Md5Digest& parent, const u8 &rhs) {
    for (int i = 0; i < 16; i++) {
        parent.value_elems[i] = rhs;
    }
}

// --- algo.Md5Digest.value.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::value_Find(algo::Md5Digest& parent, u64 t) {
    u64 idx = t;
    u64 lim = 16;
    return idx < lim ? parent.value_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Md5Digest.value.Getary
// Access fixed array value as aryptr.
inline algo::aryptr<u8> algo::value_Getary(algo::Md5Digest& parent) {
    return algo::aryptr<u8>(parent.value_elems, 16);
}

// --- algo.Md5Digest.value.Max
// Return max number of items in the array
inline i32 algo::value_Max(algo::Md5Digest& parent) {
    (void)parent;
    return 16;
}

// --- algo.Md5Digest.value.N
// Return number of items in the array
inline i32 algo::value_N(const algo::Md5Digest& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 16;
}

// --- algo.Md5Digest.value.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::value_Setary(algo::Md5Digest& parent, const algo::aryptr<u8> &rhs) {
    int n = i32_Min(16, rhs.n_elems);
    memcpy(parent.value_elems, rhs.elems, sizeof(u8)*n);
}

// --- algo.Md5Digest.value.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u8& algo::value_qFind(algo::Md5Digest& parent, u64 t) {
    return parent.value_elems[u64(t)];
}

// --- algo.Md5Digest.value_curs.Reset
// cursor points to valid item
inline void algo::Md5Digest_value_curs_Reset(Md5Digest_value_curs &curs, algo::Md5Digest &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Md5Digest.value_curs.ValidQ
// cursor points to valid item
inline bool algo::Md5Digest_value_curs_ValidQ(Md5Digest_value_curs &curs) {
    return u64(curs.index) < u64(16);
}

// --- algo.Md5Digest.value_curs.Next
// proceed to next item
inline void algo::Md5Digest_value_curs_Next(Md5Digest_value_curs &curs) {
    curs.index++;
}

// --- algo.Md5Digest.value_curs.Access
// item access
inline u8& algo::Md5Digest_value_curs_Access(Md5Digest_value_curs &curs) {
    return value_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Md5Digest..Init
// Set all fields to initial values.
inline void algo::Md5Digest_Init(algo::Md5Digest& parent) {
    for (int i = 0; i < 16; i++) {
        parent.value_elems[i] = 0;
    }
}

// --- algo.Md5Digest..Ctor
inline  algo::Md5Digest::Md5Digest() {
    algo::Md5Digest_Init(*this);
}

// --- algo.Md5Digest..FieldwiseCtor
inline  algo::Md5Digest::Md5Digest(algo::aryptr<u8 > in_value) {
    value_Setary(*this, in_value);
}

// --- algo.Month.value.GetEnum
// Get value of field as enum type
inline algo_MonthEnum algo::value_GetEnum(const algo::Month& parent) {
    return algo_MonthEnum(parent.value);
}

// --- algo.Month.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::Month& parent, algo_MonthEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.Month.value.Cast
inline  algo::Month::operator algo_MonthEnum() const {
    return algo_MonthEnum((*this).value);
}

// --- algo.Month..Init
// Set all fields to initial values.
inline void algo::Month_Init(algo::Month& parent) {
    parent.value = u32(0);
}

// --- algo.Month..Ctor
inline  algo::Month::Month() {
    algo::Month_Init(*this);
}

// --- algo.Month..FieldwiseCtor
inline  algo::Month::Month(u32 in_value)
    : value(in_value)
 {
}

// --- algo.Month..EnumCtor
inline  algo::Month::Month(algo_MonthEnum arg) {
    this->value = u32(arg);
}

// --- algo.NumParseFlags.value.Cast
inline  algo::NumParseFlags::operator algo_NumParseFlagsEnum() const {
    return algo_NumParseFlagsEnum((*this).value);
}

// --- algo.NumParseFlags.err.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
inline bool algo::err_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 0) & 0x01);
}

// --- algo.NumParseFlags.err.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
inline void algo::err_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 0;
    u32 t2    = (u32(rhs) & 0x01) << 0;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.ok.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
inline bool algo::ok_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 1) & 0x01);
}

// --- algo.NumParseFlags.ok.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
inline void algo::ok_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 1;
    u32 t2    = (u32(rhs) & 0x01) << 1;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.neg.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
inline bool algo::neg_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 2) & 0x01);
}

// --- algo.NumParseFlags.neg.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
inline void algo::neg_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 2;
    u32 t2    = (u32(rhs) & 0x01) << 2;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.overflow.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
inline bool algo::overflow_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 3) & 0x01);
}

// --- algo.NumParseFlags.overflow.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
inline void algo::overflow_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 3;
    u32 t2    = (u32(rhs) & 0x01) << 3;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags.hex.Get
// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
inline bool algo::hex_Get(const algo::NumParseFlags& parent) {
    return bool((parent.value >> 4) & 0x01);
}

// --- algo.NumParseFlags.hex.Set
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
inline void algo::hex_Set(algo::NumParseFlags& parent, bool rhs) {
    u32 t1    = u32(0x01) << 4;
    u32 t2    = (u32(rhs) & 0x01) << 4;
    parent.value = u32((parent.value & ~t1) | t2);
}

// --- algo.NumParseFlags..Init
// Set all fields to initial values.
inline void algo::NumParseFlags_Init(algo::NumParseFlags& parent) {
    parent.value = u32(0);
}

// --- algo.NumParseFlags..Ctor
inline  algo::NumParseFlags::NumParseFlags() {
    algo::NumParseFlags_Init(*this);
}

// --- algo.NumParseFlags..FieldwiseCtor
inline  algo::NumParseFlags::NumParseFlags(u32 in_value)
    : value(in_value)
 {
}

// --- algo.NumParseFlags..EnumCtor
inline  algo::NumParseFlags::NumParseFlags(algo_NumParseFlagsEnum arg) {
    this->value = u32(arg);
}

// --- algo.RnullStr1.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr1& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr1.ch.HashStrptr
inline u32 algo::RnullStr1_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr1.ch.Init
inline void algo::ch_Init(algo::RnullStr1 &parent) {
    memset(parent.ch, 0, 1);
}

// --- algo.RnullStr1.ch.Max
// always return constant 1
inline int algo::ch_Max(algo::RnullStr1& parent) {
    (void)parent;
    return 1;
}

// --- algo.RnullStr1.ch.N
inline int algo::ch_N(const algo::RnullStr1& parent) {
    u64 ret;
    ret = 1;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr1.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr1::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr1.ch.CtorStrptr
inline  algo::RnullStr1::RnullStr1(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr1.ch.Cast
inline  algo::RnullStr1::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr1..EqOp
inline bool algo::RnullStr1::operator ==(const algo::RnullStr1 &rhs) const {
    return algo::RnullStr1_Eq(const_cast<algo::RnullStr1&>(*this),const_cast<algo::RnullStr1&>(rhs));
}

// --- algo.RnullStr1..NeOp
inline bool algo::RnullStr1::operator !=(const algo::RnullStr1 &rhs) const {
    return !algo::RnullStr1_Eq(const_cast<algo::RnullStr1&>(*this),const_cast<algo::RnullStr1&>(rhs));
}

// --- algo.RnullStr1..LtOp
inline bool algo::RnullStr1::operator <(const algo::RnullStr1 &rhs) const {
    return algo::RnullStr1_Lt(const_cast<algo::RnullStr1&>(*this),const_cast<algo::RnullStr1&>(rhs));
}

// --- algo.RnullStr1..GtOp
inline bool algo::RnullStr1::operator >(const algo::RnullStr1 &rhs) const {
    return algo::RnullStr1_Lt(const_cast<algo::RnullStr1&>(rhs),const_cast<algo::RnullStr1&>(*this));
}

// --- algo.RnullStr1..LeOp
inline bool algo::RnullStr1::operator <=(const algo::RnullStr1 &rhs) const {
    return !algo::RnullStr1_Lt(const_cast<algo::RnullStr1&>(rhs),const_cast<algo::RnullStr1&>(*this));
}

// --- algo.RnullStr1..GeOp
inline bool algo::RnullStr1::operator >=(const algo::RnullStr1 &rhs) const {
    return !algo::RnullStr1_Lt(const_cast<algo::RnullStr1&>(*this),const_cast<algo::RnullStr1&>(rhs));
}

// --- algo.RnullStr1..Lt
inline bool algo::RnullStr1_Lt(algo::RnullStr1 lhs, algo::RnullStr1 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr1..Cmp
inline i32 algo::RnullStr1_Cmp(algo::RnullStr1 lhs, algo::RnullStr1 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr1..Init
// Set all fields to initial values.
inline void algo::RnullStr1_Init(algo::RnullStr1& parent) {
    memset(parent.ch, 0, 1);
}

// --- algo.RnullStr1..Eq
inline bool algo::RnullStr1_Eq(algo::RnullStr1 lhs, algo::RnullStr1 rhs) {
    bool retval = true;
    retval = retval
    &&*(u8*)(lhs.ch+0) == *(u8*)(rhs.ch+0);
    return retval;
}

// --- algo.RnullStr1..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr1_Update(algo::RnullStr1 &lhs, algo::RnullStr1 rhs) {
    bool ret = !RnullStr1_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr1..EqOpAryptr
inline bool algo::RnullStr1::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr1..AssignOp
inline algo::RnullStr1& algo::RnullStr1::operator =(const algo::RnullStr1 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr1));
    return *this;
}

// --- algo.RnullStr1..Ctor
inline  algo::RnullStr1::RnullStr1() {
    algo::RnullStr1_Init(*this);
}

// --- algo.RnullStr1..CopyCtor
inline  algo::RnullStr1::RnullStr1(const algo::RnullStr1 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr1));
}

// --- algo.RnullStr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr10.ch.HashStrptr
inline u32 algo::RnullStr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr10.ch.Init
inline void algo::ch_Init(algo::RnullStr10 &parent) {
    memset(parent.ch, 0, 10);
}

// --- algo.RnullStr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::RnullStr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.RnullStr10.ch.N
inline int algo::ch_N(const algo::RnullStr10& parent) {
    u64 ret;
    ret = 10;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr10.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr10::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr10.ch.CtorStrptr
inline  algo::RnullStr10::RnullStr10(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr10.ch.Cast
inline  algo::RnullStr10::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr10..EqOp
inline bool algo::RnullStr10::operator ==(const algo::RnullStr10 &rhs) const {
    return algo::RnullStr10_Eq(const_cast<algo::RnullStr10&>(*this),const_cast<algo::RnullStr10&>(rhs));
}

// --- algo.RnullStr10..NeOp
inline bool algo::RnullStr10::operator !=(const algo::RnullStr10 &rhs) const {
    return !algo::RnullStr10_Eq(const_cast<algo::RnullStr10&>(*this),const_cast<algo::RnullStr10&>(rhs));
}

// --- algo.RnullStr10..LtOp
inline bool algo::RnullStr10::operator <(const algo::RnullStr10 &rhs) const {
    return algo::RnullStr10_Lt(const_cast<algo::RnullStr10&>(*this),const_cast<algo::RnullStr10&>(rhs));
}

// --- algo.RnullStr10..GtOp
inline bool algo::RnullStr10::operator >(const algo::RnullStr10 &rhs) const {
    return algo::RnullStr10_Lt(const_cast<algo::RnullStr10&>(rhs),const_cast<algo::RnullStr10&>(*this));
}

// --- algo.RnullStr10..LeOp
inline bool algo::RnullStr10::operator <=(const algo::RnullStr10 &rhs) const {
    return !algo::RnullStr10_Lt(const_cast<algo::RnullStr10&>(rhs),const_cast<algo::RnullStr10&>(*this));
}

// --- algo.RnullStr10..GeOp
inline bool algo::RnullStr10::operator >=(const algo::RnullStr10 &rhs) const {
    return !algo::RnullStr10_Lt(const_cast<algo::RnullStr10&>(*this),const_cast<algo::RnullStr10&>(rhs));
}

// --- algo.RnullStr10..Lt
inline bool algo::RnullStr10_Lt(algo::RnullStr10 lhs, algo::RnullStr10 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr10..Cmp
inline i32 algo::RnullStr10_Cmp(algo::RnullStr10 lhs, algo::RnullStr10 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr10..Init
// Set all fields to initial values.
inline void algo::RnullStr10_Init(algo::RnullStr10& parent) {
    memset(parent.ch, 0, 10);
}

// --- algo.RnullStr10..Eq
inline bool algo::RnullStr10_Eq(algo::RnullStr10 lhs, algo::RnullStr10 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8);
    return retval;
}

// --- algo.RnullStr10..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr10_Update(algo::RnullStr10 &lhs, algo::RnullStr10 rhs) {
    bool ret = !RnullStr10_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr10..EqOpAryptr
inline bool algo::RnullStr10::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr10..AssignOp
inline algo::RnullStr10& algo::RnullStr10::operator =(const algo::RnullStr10 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr10));
    return *this;
}

// --- algo.RnullStr10..Ctor
inline  algo::RnullStr10::RnullStr10() {
    algo::RnullStr10_Init(*this);
}

// --- algo.RnullStr10..CopyCtor
inline  algo::RnullStr10::RnullStr10(const algo::RnullStr10 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr10));
}

// --- algo.RnullStr100.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr100& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr100.ch.HashStrptr
inline u32 algo::RnullStr100_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr100.ch.Init
inline void algo::ch_Init(algo::RnullStr100 &parent) {
    memset(parent.ch, 0, 100);
}

// --- algo.RnullStr100.ch.Max
// always return constant 100
inline int algo::ch_Max(algo::RnullStr100& parent) {
    (void)parent;
    return 100;
}

// --- algo.RnullStr100.ch.N
inline int algo::ch_N(const algo::RnullStr100& parent) {
    u64 ret;
    ret = 100;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr100.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr100::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr100.ch.CtorStrptr
inline  algo::RnullStr100::RnullStr100(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr100.ch.Cast
inline  algo::RnullStr100::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr100..Lt
inline bool algo::RnullStr100_Lt(algo::RnullStr100& lhs, algo::RnullStr100& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr100..Cmp
inline i32 algo::RnullStr100_Cmp(algo::RnullStr100& lhs, algo::RnullStr100& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr100..Init
// Set all fields to initial values.
inline void algo::RnullStr100_Init(algo::RnullStr100& parent) {
    memset(parent.ch, 0, 100);
}

// --- algo.RnullStr100..Eq
inline bool algo::RnullStr100_Eq(algo::RnullStr100& lhs, algo::RnullStr100& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56)
    &&*(u64*)(lhs.ch+64) == *(u64*)(rhs.ch+64)
    &&*(u64*)(lhs.ch+72) == *(u64*)(rhs.ch+72)
    &&*(u64*)(lhs.ch+80) == *(u64*)(rhs.ch+80)
    &&*(u64*)(lhs.ch+88) == *(u64*)(rhs.ch+88)
    &&*(u32*)(lhs.ch+96) == *(u32*)(rhs.ch+96);
    return retval;
}

// --- algo.RnullStr100..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr100_Update(algo::RnullStr100 &lhs, algo::RnullStr100& rhs) {
    bool ret = !RnullStr100_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr100..EqOpAryptr
inline bool algo::RnullStr100::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr100..AssignOp
inline algo::RnullStr100& algo::RnullStr100::operator =(const algo::RnullStr100 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr100));
    return *this;
}

// --- algo.RnullStr100..Ctor
inline  algo::RnullStr100::RnullStr100() {
    algo::RnullStr100_Init(*this);
}

// --- algo.RnullStr100..CopyCtor
inline  algo::RnullStr100::RnullStr100(const algo::RnullStr100 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr100));
}

// --- algo.RnullStr1000.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr1000& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr1000.ch.HashStrptr
inline u32 algo::RnullStr1000_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr1000.ch.Init
inline void algo::ch_Init(algo::RnullStr1000 &parent) {
    memset(parent.ch, 0, 1000);
}

// --- algo.RnullStr1000.ch.Max
// always return constant 1000
inline int algo::ch_Max(algo::RnullStr1000& parent) {
    (void)parent;
    return 1000;
}

// --- algo.RnullStr1000.ch.N
inline int algo::ch_N(const algo::RnullStr1000& parent) {
    u64 ret;
    ret = 1000;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr1000.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr1000::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr1000.ch.CtorStrptr
inline  algo::RnullStr1000::RnullStr1000(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr1000.ch.Cast
inline  algo::RnullStr1000::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr1000..EqOp
inline bool algo::RnullStr1000::operator ==(const algo::RnullStr1000 &rhs) const {
    return algo::RnullStr1000_Eq(const_cast<algo::RnullStr1000&>(*this),const_cast<algo::RnullStr1000&>(rhs));
}

// --- algo.RnullStr1000..NeOp
inline bool algo::RnullStr1000::operator !=(const algo::RnullStr1000 &rhs) const {
    return !algo::RnullStr1000_Eq(const_cast<algo::RnullStr1000&>(*this),const_cast<algo::RnullStr1000&>(rhs));
}

// --- algo.RnullStr1000..LtOp
inline bool algo::RnullStr1000::operator <(const algo::RnullStr1000 &rhs) const {
    return algo::RnullStr1000_Lt(const_cast<algo::RnullStr1000&>(*this),const_cast<algo::RnullStr1000&>(rhs));
}

// --- algo.RnullStr1000..GtOp
inline bool algo::RnullStr1000::operator >(const algo::RnullStr1000 &rhs) const {
    return algo::RnullStr1000_Lt(const_cast<algo::RnullStr1000&>(rhs),const_cast<algo::RnullStr1000&>(*this));
}

// --- algo.RnullStr1000..LeOp
inline bool algo::RnullStr1000::operator <=(const algo::RnullStr1000 &rhs) const {
    return !algo::RnullStr1000_Lt(const_cast<algo::RnullStr1000&>(rhs),const_cast<algo::RnullStr1000&>(*this));
}

// --- algo.RnullStr1000..GeOp
inline bool algo::RnullStr1000::operator >=(const algo::RnullStr1000 &rhs) const {
    return !algo::RnullStr1000_Lt(const_cast<algo::RnullStr1000&>(*this),const_cast<algo::RnullStr1000&>(rhs));
}

// --- algo.RnullStr1000..Lt
inline bool algo::RnullStr1000_Lt(algo::RnullStr1000& lhs, algo::RnullStr1000& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr1000..Cmp
inline i32 algo::RnullStr1000_Cmp(algo::RnullStr1000& lhs, algo::RnullStr1000& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr1000..Init
// Set all fields to initial values.
inline void algo::RnullStr1000_Init(algo::RnullStr1000& parent) {
    memset(parent.ch, 0, 1000);
}

// --- algo.RnullStr1000..Eq
inline bool algo::RnullStr1000_Eq(algo::RnullStr1000& lhs, algo::RnullStr1000& rhs) {
    bool retval = true;
    for (int i=0; i<125 && retval; i++) {
        retval = ((u64*)lhs.ch)[i] == ((u64*)rhs.ch)[i];
    }
    return retval;
}

// --- algo.RnullStr1000..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr1000_Update(algo::RnullStr1000 &lhs, algo::RnullStr1000& rhs) {
    bool ret = !RnullStr1000_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr1000..EqOpAryptr
inline bool algo::RnullStr1000::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr1000..AssignOp
inline algo::RnullStr1000& algo::RnullStr1000::operator =(const algo::RnullStr1000 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr1000));
    return *this;
}

// --- algo.RnullStr1000..Ctor
inline  algo::RnullStr1000::RnullStr1000() {
    algo::RnullStr1000_Init(*this);
}

// --- algo.RnullStr1000..CopyCtor
inline  algo::RnullStr1000::RnullStr1000(const algo::RnullStr1000 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr1000));
}

// --- algo.RnullStr11.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr11& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr11.ch.HashStrptr
inline u32 algo::RnullStr11_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr11.ch.Init
inline void algo::ch_Init(algo::RnullStr11 &parent) {
    memset(parent.ch, 0, 11);
}

// --- algo.RnullStr11.ch.Max
// always return constant 11
inline int algo::ch_Max(algo::RnullStr11& parent) {
    (void)parent;
    return 11;
}

// --- algo.RnullStr11.ch.N
inline int algo::ch_N(const algo::RnullStr11& parent) {
    u64 ret;
    ret = 11;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr11.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr11::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr11.ch.CtorStrptr
inline  algo::RnullStr11::RnullStr11(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr11.ch.Cast
inline  algo::RnullStr11::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr11..EqOp
inline bool algo::RnullStr11::operator ==(const algo::RnullStr11 &rhs) const {
    return algo::RnullStr11_Eq(const_cast<algo::RnullStr11&>(*this),const_cast<algo::RnullStr11&>(rhs));
}

// --- algo.RnullStr11..NeOp
inline bool algo::RnullStr11::operator !=(const algo::RnullStr11 &rhs) const {
    return !algo::RnullStr11_Eq(const_cast<algo::RnullStr11&>(*this),const_cast<algo::RnullStr11&>(rhs));
}

// --- algo.RnullStr11..LtOp
inline bool algo::RnullStr11::operator <(const algo::RnullStr11 &rhs) const {
    return algo::RnullStr11_Lt(const_cast<algo::RnullStr11&>(*this),const_cast<algo::RnullStr11&>(rhs));
}

// --- algo.RnullStr11..GtOp
inline bool algo::RnullStr11::operator >(const algo::RnullStr11 &rhs) const {
    return algo::RnullStr11_Lt(const_cast<algo::RnullStr11&>(rhs),const_cast<algo::RnullStr11&>(*this));
}

// --- algo.RnullStr11..LeOp
inline bool algo::RnullStr11::operator <=(const algo::RnullStr11 &rhs) const {
    return !algo::RnullStr11_Lt(const_cast<algo::RnullStr11&>(rhs),const_cast<algo::RnullStr11&>(*this));
}

// --- algo.RnullStr11..GeOp
inline bool algo::RnullStr11::operator >=(const algo::RnullStr11 &rhs) const {
    return !algo::RnullStr11_Lt(const_cast<algo::RnullStr11&>(*this),const_cast<algo::RnullStr11&>(rhs));
}

// --- algo.RnullStr11..Lt
inline bool algo::RnullStr11_Lt(algo::RnullStr11& lhs, algo::RnullStr11& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr11..Cmp
inline i32 algo::RnullStr11_Cmp(algo::RnullStr11& lhs, algo::RnullStr11& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr11..Init
// Set all fields to initial values.
inline void algo::RnullStr11_Init(algo::RnullStr11& parent) {
    memset(parent.ch, 0, 11);
}

// --- algo.RnullStr11..Eq
inline bool algo::RnullStr11_Eq(algo::RnullStr11& lhs, algo::RnullStr11& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8)
    &&*(u8*)(lhs.ch+10) == *(u8*)(rhs.ch+10);
    return retval;
}

// --- algo.RnullStr11..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr11_Update(algo::RnullStr11 &lhs, algo::RnullStr11& rhs) {
    bool ret = !RnullStr11_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr11..EqOpAryptr
inline bool algo::RnullStr11::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr11..AssignOp
inline algo::RnullStr11& algo::RnullStr11::operator =(const algo::RnullStr11 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr11));
    return *this;
}

// --- algo.RnullStr11..Ctor
inline  algo::RnullStr11::RnullStr11() {
    algo::RnullStr11_Init(*this);
}

// --- algo.RnullStr11..CopyCtor
inline  algo::RnullStr11::RnullStr11(const algo::RnullStr11 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr11));
}

// --- algo.RnullStr12.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr12& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr12.ch.HashStrptr
inline u32 algo::RnullStr12_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr12.ch.Init
inline void algo::ch_Init(algo::RnullStr12 &parent) {
    memset(parent.ch, 0, 12);
}

// --- algo.RnullStr12.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::RnullStr12& parent) {
    (void)parent;
    return 12;
}

// --- algo.RnullStr12.ch.N
inline int algo::ch_N(const algo::RnullStr12& parent) {
    u64 ret;
    ret = 12;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr12.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr12::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr12.ch.CtorStrptr
inline  algo::RnullStr12::RnullStr12(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr12.ch.Cast
inline  algo::RnullStr12::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr12..EqOp
inline bool algo::RnullStr12::operator ==(const algo::RnullStr12 &rhs) const {
    return algo::RnullStr12_Eq(const_cast<algo::RnullStr12&>(*this),const_cast<algo::RnullStr12&>(rhs));
}

// --- algo.RnullStr12..NeOp
inline bool algo::RnullStr12::operator !=(const algo::RnullStr12 &rhs) const {
    return !algo::RnullStr12_Eq(const_cast<algo::RnullStr12&>(*this),const_cast<algo::RnullStr12&>(rhs));
}

// --- algo.RnullStr12..LtOp
inline bool algo::RnullStr12::operator <(const algo::RnullStr12 &rhs) const {
    return algo::RnullStr12_Lt(const_cast<algo::RnullStr12&>(*this),const_cast<algo::RnullStr12&>(rhs));
}

// --- algo.RnullStr12..GtOp
inline bool algo::RnullStr12::operator >(const algo::RnullStr12 &rhs) const {
    return algo::RnullStr12_Lt(const_cast<algo::RnullStr12&>(rhs),const_cast<algo::RnullStr12&>(*this));
}

// --- algo.RnullStr12..LeOp
inline bool algo::RnullStr12::operator <=(const algo::RnullStr12 &rhs) const {
    return !algo::RnullStr12_Lt(const_cast<algo::RnullStr12&>(rhs),const_cast<algo::RnullStr12&>(*this));
}

// --- algo.RnullStr12..GeOp
inline bool algo::RnullStr12::operator >=(const algo::RnullStr12 &rhs) const {
    return !algo::RnullStr12_Lt(const_cast<algo::RnullStr12&>(*this),const_cast<algo::RnullStr12&>(rhs));
}

// --- algo.RnullStr12..Lt
inline bool algo::RnullStr12_Lt(algo::RnullStr12& lhs, algo::RnullStr12& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr12..Cmp
inline i32 algo::RnullStr12_Cmp(algo::RnullStr12& lhs, algo::RnullStr12& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr12..Init
// Set all fields to initial values.
inline void algo::RnullStr12_Init(algo::RnullStr12& parent) {
    memset(parent.ch, 0, 12);
}

// --- algo.RnullStr12..Eq
inline bool algo::RnullStr12_Eq(algo::RnullStr12& lhs, algo::RnullStr12& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8);
    return retval;
}

// --- algo.RnullStr12..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr12_Update(algo::RnullStr12 &lhs, algo::RnullStr12& rhs) {
    bool ret = !RnullStr12_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr12..EqOpAryptr
inline bool algo::RnullStr12::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr12..AssignOp
inline algo::RnullStr12& algo::RnullStr12::operator =(const algo::RnullStr12 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr12));
    return *this;
}

// --- algo.RnullStr12..Ctor
inline  algo::RnullStr12::RnullStr12() {
    algo::RnullStr12_Init(*this);
}

// --- algo.RnullStr12..CopyCtor
inline  algo::RnullStr12::RnullStr12(const algo::RnullStr12 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr12));
}

// --- algo.RnullStr129.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr129& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr129.ch.HashStrptr
inline u32 algo::RnullStr129_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr129.ch.Init
inline void algo::ch_Init(algo::RnullStr129 &parent) {
    memset(parent.ch, 0, 129);
}

// --- algo.RnullStr129.ch.Max
// always return constant 129
inline int algo::ch_Max(algo::RnullStr129& parent) {
    (void)parent;
    return 129;
}

// --- algo.RnullStr129.ch.N
inline int algo::ch_N(const algo::RnullStr129& parent) {
    u64 ret;
    ret = 129;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr129.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr129::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr129.ch.CtorStrptr
inline  algo::RnullStr129::RnullStr129(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr129.ch.Cast
inline  algo::RnullStr129::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr129..EqOp
inline bool algo::RnullStr129::operator ==(const algo::RnullStr129 &rhs) const {
    return algo::RnullStr129_Eq(const_cast<algo::RnullStr129&>(*this),const_cast<algo::RnullStr129&>(rhs));
}

// --- algo.RnullStr129..NeOp
inline bool algo::RnullStr129::operator !=(const algo::RnullStr129 &rhs) const {
    return !algo::RnullStr129_Eq(const_cast<algo::RnullStr129&>(*this),const_cast<algo::RnullStr129&>(rhs));
}

// --- algo.RnullStr129..LtOp
inline bool algo::RnullStr129::operator <(const algo::RnullStr129 &rhs) const {
    return algo::RnullStr129_Lt(const_cast<algo::RnullStr129&>(*this),const_cast<algo::RnullStr129&>(rhs));
}

// --- algo.RnullStr129..GtOp
inline bool algo::RnullStr129::operator >(const algo::RnullStr129 &rhs) const {
    return algo::RnullStr129_Lt(const_cast<algo::RnullStr129&>(rhs),const_cast<algo::RnullStr129&>(*this));
}

// --- algo.RnullStr129..LeOp
inline bool algo::RnullStr129::operator <=(const algo::RnullStr129 &rhs) const {
    return !algo::RnullStr129_Lt(const_cast<algo::RnullStr129&>(rhs),const_cast<algo::RnullStr129&>(*this));
}

// --- algo.RnullStr129..GeOp
inline bool algo::RnullStr129::operator >=(const algo::RnullStr129 &rhs) const {
    return !algo::RnullStr129_Lt(const_cast<algo::RnullStr129&>(*this),const_cast<algo::RnullStr129&>(rhs));
}

// --- algo.RnullStr129..Lt
inline bool algo::RnullStr129_Lt(algo::RnullStr129& lhs, algo::RnullStr129& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr129..Cmp
inline i32 algo::RnullStr129_Cmp(algo::RnullStr129& lhs, algo::RnullStr129& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr129..Init
// Set all fields to initial values.
inline void algo::RnullStr129_Init(algo::RnullStr129& parent) {
    memset(parent.ch, 0, 129);
}

// --- algo.RnullStr129..Eq
inline bool algo::RnullStr129_Eq(algo::RnullStr129& lhs, algo::RnullStr129& rhs) {
    bool retval = true;
    for (int i=0; i<16 && retval; i++) {
        retval = ((u64*)lhs.ch)[i] == ((u64*)rhs.ch)[i];
    }
    retval = retval
    &&*(u8*)(lhs.ch+128) == *(u8*)(rhs.ch+128);
    return retval;
}

// --- algo.RnullStr129..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr129_Update(algo::RnullStr129 &lhs, algo::RnullStr129& rhs) {
    bool ret = !RnullStr129_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr129..EqOpAryptr
inline bool algo::RnullStr129::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr129..AssignOp
inline algo::RnullStr129& algo::RnullStr129::operator =(const algo::RnullStr129 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr129));
    return *this;
}

// --- algo.RnullStr129..Ctor
inline  algo::RnullStr129::RnullStr129() {
    algo::RnullStr129_Init(*this);
}

// --- algo.RnullStr129..CopyCtor
inline  algo::RnullStr129::RnullStr129(const algo::RnullStr129 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr129));
}

// --- algo.RnullStr13.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr13& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr13.ch.HashStrptr
inline u32 algo::RnullStr13_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr13.ch.Init
inline void algo::ch_Init(algo::RnullStr13 &parent) {
    memset(parent.ch, 0, 13);
}

// --- algo.RnullStr13.ch.Max
// always return constant 13
inline int algo::ch_Max(algo::RnullStr13& parent) {
    (void)parent;
    return 13;
}

// --- algo.RnullStr13.ch.N
inline int algo::ch_N(const algo::RnullStr13& parent) {
    u64 ret;
    ret = 13;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr13.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr13::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr13.ch.CtorStrptr
inline  algo::RnullStr13::RnullStr13(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr13.ch.Cast
inline  algo::RnullStr13::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr13..EqOp
inline bool algo::RnullStr13::operator ==(const algo::RnullStr13 &rhs) const {
    return algo::RnullStr13_Eq(const_cast<algo::RnullStr13&>(*this),const_cast<algo::RnullStr13&>(rhs));
}

// --- algo.RnullStr13..NeOp
inline bool algo::RnullStr13::operator !=(const algo::RnullStr13 &rhs) const {
    return !algo::RnullStr13_Eq(const_cast<algo::RnullStr13&>(*this),const_cast<algo::RnullStr13&>(rhs));
}

// --- algo.RnullStr13..LtOp
inline bool algo::RnullStr13::operator <(const algo::RnullStr13 &rhs) const {
    return algo::RnullStr13_Lt(const_cast<algo::RnullStr13&>(*this),const_cast<algo::RnullStr13&>(rhs));
}

// --- algo.RnullStr13..GtOp
inline bool algo::RnullStr13::operator >(const algo::RnullStr13 &rhs) const {
    return algo::RnullStr13_Lt(const_cast<algo::RnullStr13&>(rhs),const_cast<algo::RnullStr13&>(*this));
}

// --- algo.RnullStr13..LeOp
inline bool algo::RnullStr13::operator <=(const algo::RnullStr13 &rhs) const {
    return !algo::RnullStr13_Lt(const_cast<algo::RnullStr13&>(rhs),const_cast<algo::RnullStr13&>(*this));
}

// --- algo.RnullStr13..GeOp
inline bool algo::RnullStr13::operator >=(const algo::RnullStr13 &rhs) const {
    return !algo::RnullStr13_Lt(const_cast<algo::RnullStr13&>(*this),const_cast<algo::RnullStr13&>(rhs));
}

// --- algo.RnullStr13..Lt
inline bool algo::RnullStr13_Lt(algo::RnullStr13& lhs, algo::RnullStr13& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr13..Cmp
inline i32 algo::RnullStr13_Cmp(algo::RnullStr13& lhs, algo::RnullStr13& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr13..Init
// Set all fields to initial values.
inline void algo::RnullStr13_Init(algo::RnullStr13& parent) {
    memset(parent.ch, 0, 13);
}

// --- algo.RnullStr13..Eq
inline bool algo::RnullStr13_Eq(algo::RnullStr13& lhs, algo::RnullStr13& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u8*)(lhs.ch+12) == *(u8*)(rhs.ch+12);
    return retval;
}

// --- algo.RnullStr13..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr13_Update(algo::RnullStr13 &lhs, algo::RnullStr13& rhs) {
    bool ret = !RnullStr13_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr13..EqOpAryptr
inline bool algo::RnullStr13::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr13..AssignOp
inline algo::RnullStr13& algo::RnullStr13::operator =(const algo::RnullStr13 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr13));
    return *this;
}

// --- algo.RnullStr13..Ctor
inline  algo::RnullStr13::RnullStr13() {
    algo::RnullStr13_Init(*this);
}

// --- algo.RnullStr13..CopyCtor
inline  algo::RnullStr13::RnullStr13(const algo::RnullStr13 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr13));
}

// --- algo.RnullStr14.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr14& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr14.ch.HashStrptr
inline u32 algo::RnullStr14_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr14.ch.Init
inline void algo::ch_Init(algo::RnullStr14 &parent) {
    memset(parent.ch, 0, 14);
}

// --- algo.RnullStr14.ch.Max
// always return constant 14
inline int algo::ch_Max(algo::RnullStr14& parent) {
    (void)parent;
    return 14;
}

// --- algo.RnullStr14.ch.N
inline int algo::ch_N(const algo::RnullStr14& parent) {
    u64 ret;
    ret = 14;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr14.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr14::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr14.ch.CtorStrptr
inline  algo::RnullStr14::RnullStr14(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr14.ch.Cast
inline  algo::RnullStr14::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr14..EqOp
inline bool algo::RnullStr14::operator ==(const algo::RnullStr14 &rhs) const {
    return algo::RnullStr14_Eq(const_cast<algo::RnullStr14&>(*this),const_cast<algo::RnullStr14&>(rhs));
}

// --- algo.RnullStr14..NeOp
inline bool algo::RnullStr14::operator !=(const algo::RnullStr14 &rhs) const {
    return !algo::RnullStr14_Eq(const_cast<algo::RnullStr14&>(*this),const_cast<algo::RnullStr14&>(rhs));
}

// --- algo.RnullStr14..LtOp
inline bool algo::RnullStr14::operator <(const algo::RnullStr14 &rhs) const {
    return algo::RnullStr14_Lt(const_cast<algo::RnullStr14&>(*this),const_cast<algo::RnullStr14&>(rhs));
}

// --- algo.RnullStr14..GtOp
inline bool algo::RnullStr14::operator >(const algo::RnullStr14 &rhs) const {
    return algo::RnullStr14_Lt(const_cast<algo::RnullStr14&>(rhs),const_cast<algo::RnullStr14&>(*this));
}

// --- algo.RnullStr14..LeOp
inline bool algo::RnullStr14::operator <=(const algo::RnullStr14 &rhs) const {
    return !algo::RnullStr14_Lt(const_cast<algo::RnullStr14&>(rhs),const_cast<algo::RnullStr14&>(*this));
}

// --- algo.RnullStr14..GeOp
inline bool algo::RnullStr14::operator >=(const algo::RnullStr14 &rhs) const {
    return !algo::RnullStr14_Lt(const_cast<algo::RnullStr14&>(*this),const_cast<algo::RnullStr14&>(rhs));
}

// --- algo.RnullStr14..Lt
inline bool algo::RnullStr14_Lt(algo::RnullStr14& lhs, algo::RnullStr14& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr14..Cmp
inline i32 algo::RnullStr14_Cmp(algo::RnullStr14& lhs, algo::RnullStr14& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr14..Init
// Set all fields to initial values.
inline void algo::RnullStr14_Init(algo::RnullStr14& parent) {
    memset(parent.ch, 0, 14);
}

// --- algo.RnullStr14..Eq
inline bool algo::RnullStr14_Eq(algo::RnullStr14& lhs, algo::RnullStr14& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+12) == *(u16*)(rhs.ch+12);
    return retval;
}

// --- algo.RnullStr14..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr14_Update(algo::RnullStr14 &lhs, algo::RnullStr14& rhs) {
    bool ret = !RnullStr14_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr14..EqOpAryptr
inline bool algo::RnullStr14::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr14..AssignOp
inline algo::RnullStr14& algo::RnullStr14::operator =(const algo::RnullStr14 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr14));
    return *this;
}

// --- algo.RnullStr14..Ctor
inline  algo::RnullStr14::RnullStr14() {
    algo::RnullStr14_Init(*this);
}

// --- algo.RnullStr14..CopyCtor
inline  algo::RnullStr14::RnullStr14(const algo::RnullStr14 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr14));
}

// --- algo.RnullStr15.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr15& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr15.ch.HashStrptr
inline u32 algo::RnullStr15_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr15.ch.Init
inline void algo::ch_Init(algo::RnullStr15 &parent) {
    memset(parent.ch, 0, 15);
}

// --- algo.RnullStr15.ch.Max
// always return constant 15
inline int algo::ch_Max(algo::RnullStr15& parent) {
    (void)parent;
    return 15;
}

// --- algo.RnullStr15.ch.N
inline int algo::ch_N(const algo::RnullStr15& parent) {
    u64 ret;
    ret = 15;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr15.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr15::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr15.ch.CtorStrptr
inline  algo::RnullStr15::RnullStr15(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr15.ch.Cast
inline  algo::RnullStr15::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr15..EqOp
inline bool algo::RnullStr15::operator ==(const algo::RnullStr15 &rhs) const {
    return algo::RnullStr15_Eq(const_cast<algo::RnullStr15&>(*this),const_cast<algo::RnullStr15&>(rhs));
}

// --- algo.RnullStr15..NeOp
inline bool algo::RnullStr15::operator !=(const algo::RnullStr15 &rhs) const {
    return !algo::RnullStr15_Eq(const_cast<algo::RnullStr15&>(*this),const_cast<algo::RnullStr15&>(rhs));
}

// --- algo.RnullStr15..LtOp
inline bool algo::RnullStr15::operator <(const algo::RnullStr15 &rhs) const {
    return algo::RnullStr15_Lt(const_cast<algo::RnullStr15&>(*this),const_cast<algo::RnullStr15&>(rhs));
}

// --- algo.RnullStr15..GtOp
inline bool algo::RnullStr15::operator >(const algo::RnullStr15 &rhs) const {
    return algo::RnullStr15_Lt(const_cast<algo::RnullStr15&>(rhs),const_cast<algo::RnullStr15&>(*this));
}

// --- algo.RnullStr15..LeOp
inline bool algo::RnullStr15::operator <=(const algo::RnullStr15 &rhs) const {
    return !algo::RnullStr15_Lt(const_cast<algo::RnullStr15&>(rhs),const_cast<algo::RnullStr15&>(*this));
}

// --- algo.RnullStr15..GeOp
inline bool algo::RnullStr15::operator >=(const algo::RnullStr15 &rhs) const {
    return !algo::RnullStr15_Lt(const_cast<algo::RnullStr15&>(*this),const_cast<algo::RnullStr15&>(rhs));
}

// --- algo.RnullStr15..Lt
inline bool algo::RnullStr15_Lt(algo::RnullStr15& lhs, algo::RnullStr15& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr15..Cmp
inline i32 algo::RnullStr15_Cmp(algo::RnullStr15& lhs, algo::RnullStr15& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr15..Init
// Set all fields to initial values.
inline void algo::RnullStr15_Init(algo::RnullStr15& parent) {
    memset(parent.ch, 0, 15);
}

// --- algo.RnullStr15..Eq
inline bool algo::RnullStr15_Eq(algo::RnullStr15& lhs, algo::RnullStr15& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+12) == *(u16*)(rhs.ch+12)
    &&*(u8*)(lhs.ch+14) == *(u8*)(rhs.ch+14);
    return retval;
}

// --- algo.RnullStr15..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr15_Update(algo::RnullStr15 &lhs, algo::RnullStr15& rhs) {
    bool ret = !RnullStr15_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr15..EqOpAryptr
inline bool algo::RnullStr15::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr15..AssignOp
inline algo::RnullStr15& algo::RnullStr15::operator =(const algo::RnullStr15 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr15));
    return *this;
}

// --- algo.RnullStr15..Ctor
inline  algo::RnullStr15::RnullStr15() {
    algo::RnullStr15_Init(*this);
}

// --- algo.RnullStr15..CopyCtor
inline  algo::RnullStr15::RnullStr15(const algo::RnullStr15 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr15));
}

// --- algo.RnullStr151.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr151& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr151.ch.HashStrptr
inline u32 algo::RnullStr151_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr151.ch.Init
inline void algo::ch_Init(algo::RnullStr151 &parent) {
    memset(parent.ch, 0, 151);
}

// --- algo.RnullStr151.ch.Max
// always return constant 151
inline int algo::ch_Max(algo::RnullStr151& parent) {
    (void)parent;
    return 151;
}

// --- algo.RnullStr151.ch.N
inline int algo::ch_N(const algo::RnullStr151& parent) {
    u64 ret;
    ret = 151;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr151.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr151::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr151.ch.CtorStrptr
inline  algo::RnullStr151::RnullStr151(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr151.ch.Cast
inline  algo::RnullStr151::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr151..EqOp
inline bool algo::RnullStr151::operator ==(const algo::RnullStr151 &rhs) const {
    return algo::RnullStr151_Eq(const_cast<algo::RnullStr151&>(*this),const_cast<algo::RnullStr151&>(rhs));
}

// --- algo.RnullStr151..NeOp
inline bool algo::RnullStr151::operator !=(const algo::RnullStr151 &rhs) const {
    return !algo::RnullStr151_Eq(const_cast<algo::RnullStr151&>(*this),const_cast<algo::RnullStr151&>(rhs));
}

// --- algo.RnullStr151..LtOp
inline bool algo::RnullStr151::operator <(const algo::RnullStr151 &rhs) const {
    return algo::RnullStr151_Lt(const_cast<algo::RnullStr151&>(*this),const_cast<algo::RnullStr151&>(rhs));
}

// --- algo.RnullStr151..GtOp
inline bool algo::RnullStr151::operator >(const algo::RnullStr151 &rhs) const {
    return algo::RnullStr151_Lt(const_cast<algo::RnullStr151&>(rhs),const_cast<algo::RnullStr151&>(*this));
}

// --- algo.RnullStr151..LeOp
inline bool algo::RnullStr151::operator <=(const algo::RnullStr151 &rhs) const {
    return !algo::RnullStr151_Lt(const_cast<algo::RnullStr151&>(rhs),const_cast<algo::RnullStr151&>(*this));
}

// --- algo.RnullStr151..GeOp
inline bool algo::RnullStr151::operator >=(const algo::RnullStr151 &rhs) const {
    return !algo::RnullStr151_Lt(const_cast<algo::RnullStr151&>(*this),const_cast<algo::RnullStr151&>(rhs));
}

// --- algo.RnullStr151..Lt
inline bool algo::RnullStr151_Lt(algo::RnullStr151& lhs, algo::RnullStr151& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr151..Cmp
inline i32 algo::RnullStr151_Cmp(algo::RnullStr151& lhs, algo::RnullStr151& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr151..Init
// Set all fields to initial values.
inline void algo::RnullStr151_Init(algo::RnullStr151& parent) {
    memset(parent.ch, 0, 151);
}

// --- algo.RnullStr151..Eq
inline bool algo::RnullStr151_Eq(algo::RnullStr151& lhs, algo::RnullStr151& rhs) {
    bool retval = true;
    for (int i=0; i<18 && retval; i++) {
        retval = ((u64*)lhs.ch)[i] == ((u64*)rhs.ch)[i];
    }
    retval = retval
    &&*(u32*)(lhs.ch+144) == *(u32*)(rhs.ch+144)
    &&*(u16*)(lhs.ch+148) == *(u16*)(rhs.ch+148)
    &&*(u8*)(lhs.ch+150) == *(u8*)(rhs.ch+150);
    return retval;
}

// --- algo.RnullStr151..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr151_Update(algo::RnullStr151 &lhs, algo::RnullStr151& rhs) {
    bool ret = !RnullStr151_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr151..EqOpAryptr
inline bool algo::RnullStr151::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr151..AssignOp
inline algo::RnullStr151& algo::RnullStr151::operator =(const algo::RnullStr151 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr151));
    return *this;
}

// --- algo.RnullStr151..Ctor
inline  algo::RnullStr151::RnullStr151() {
    algo::RnullStr151_Init(*this);
}

// --- algo.RnullStr151..CopyCtor
inline  algo::RnullStr151::RnullStr151(const algo::RnullStr151 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr151));
}

// --- algo.RnullStr16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr16.ch.HashStrptr
inline u32 algo::RnullStr16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr16.ch.Init
inline void algo::ch_Init(algo::RnullStr16 &parent) {
    memset(parent.ch, 0, 16);
}

// --- algo.RnullStr16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::RnullStr16& parent) {
    (void)parent;
    return 16;
}

// --- algo.RnullStr16.ch.N
inline int algo::ch_N(const algo::RnullStr16& parent) {
    u64 ret;
    ret = 16;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr16.ch.CtorStrptr
inline  algo::RnullStr16::RnullStr16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr16.ch.Cast
inline  algo::RnullStr16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr16..Lt
inline bool algo::RnullStr16_Lt(algo::RnullStr16 lhs, algo::RnullStr16 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr16..Cmp
inline i32 algo::RnullStr16_Cmp(algo::RnullStr16 lhs, algo::RnullStr16 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr16..Init
// Set all fields to initial values.
inline void algo::RnullStr16_Init(algo::RnullStr16& parent) {
    memset(parent.ch, 0, 16);
}

// --- algo.RnullStr16..Eq
inline bool algo::RnullStr16_Eq(algo::RnullStr16 lhs, algo::RnullStr16 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8);
    return retval;
}

// --- algo.RnullStr16..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr16_Update(algo::RnullStr16 &lhs, algo::RnullStr16 rhs) {
    bool ret = !RnullStr16_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr16..EqOpAryptr
inline bool algo::RnullStr16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr16..AssignOp
inline algo::RnullStr16& algo::RnullStr16::operator =(const algo::RnullStr16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr16));
    return *this;
}

// --- algo.RnullStr16..Ctor
inline  algo::RnullStr16::RnullStr16() {
    algo::RnullStr16_Init(*this);
}

// --- algo.RnullStr16..CopyCtor
inline  algo::RnullStr16::RnullStr16(const algo::RnullStr16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr16));
}

// --- algo.RnullStr17.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr17& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr17.ch.HashStrptr
inline u32 algo::RnullStr17_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr17.ch.Init
inline void algo::ch_Init(algo::RnullStr17 &parent) {
    memset(parent.ch, 0, 17);
}

// --- algo.RnullStr17.ch.Max
// always return constant 17
inline int algo::ch_Max(algo::RnullStr17& parent) {
    (void)parent;
    return 17;
}

// --- algo.RnullStr17.ch.N
inline int algo::ch_N(const algo::RnullStr17& parent) {
    u64 ret;
    ret = 17;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr17.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr17::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr17.ch.CtorStrptr
inline  algo::RnullStr17::RnullStr17(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr17.ch.Cast
inline  algo::RnullStr17::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr17..EqOp
inline bool algo::RnullStr17::operator ==(const algo::RnullStr17 &rhs) const {
    return algo::RnullStr17_Eq(const_cast<algo::RnullStr17&>(*this),const_cast<algo::RnullStr17&>(rhs));
}

// --- algo.RnullStr17..NeOp
inline bool algo::RnullStr17::operator !=(const algo::RnullStr17 &rhs) const {
    return !algo::RnullStr17_Eq(const_cast<algo::RnullStr17&>(*this),const_cast<algo::RnullStr17&>(rhs));
}

// --- algo.RnullStr17..LtOp
inline bool algo::RnullStr17::operator <(const algo::RnullStr17 &rhs) const {
    return algo::RnullStr17_Lt(const_cast<algo::RnullStr17&>(*this),const_cast<algo::RnullStr17&>(rhs));
}

// --- algo.RnullStr17..GtOp
inline bool algo::RnullStr17::operator >(const algo::RnullStr17 &rhs) const {
    return algo::RnullStr17_Lt(const_cast<algo::RnullStr17&>(rhs),const_cast<algo::RnullStr17&>(*this));
}

// --- algo.RnullStr17..LeOp
inline bool algo::RnullStr17::operator <=(const algo::RnullStr17 &rhs) const {
    return !algo::RnullStr17_Lt(const_cast<algo::RnullStr17&>(rhs),const_cast<algo::RnullStr17&>(*this));
}

// --- algo.RnullStr17..GeOp
inline bool algo::RnullStr17::operator >=(const algo::RnullStr17 &rhs) const {
    return !algo::RnullStr17_Lt(const_cast<algo::RnullStr17&>(*this),const_cast<algo::RnullStr17&>(rhs));
}

// --- algo.RnullStr17..Lt
inline bool algo::RnullStr17_Lt(algo::RnullStr17& lhs, algo::RnullStr17& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr17..Cmp
inline i32 algo::RnullStr17_Cmp(algo::RnullStr17& lhs, algo::RnullStr17& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr17..Init
// Set all fields to initial values.
inline void algo::RnullStr17_Init(algo::RnullStr17& parent) {
    memset(parent.ch, 0, 17);
}

// --- algo.RnullStr17..Eq
inline bool algo::RnullStr17_Eq(algo::RnullStr17& lhs, algo::RnullStr17& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u8*)(lhs.ch+16) == *(u8*)(rhs.ch+16);
    return retval;
}

// --- algo.RnullStr17..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr17_Update(algo::RnullStr17 &lhs, algo::RnullStr17& rhs) {
    bool ret = !RnullStr17_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr17..EqOpAryptr
inline bool algo::RnullStr17::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr17..AssignOp
inline algo::RnullStr17& algo::RnullStr17::operator =(const algo::RnullStr17 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr17));
    return *this;
}

// --- algo.RnullStr17..Ctor
inline  algo::RnullStr17::RnullStr17() {
    algo::RnullStr17_Init(*this);
}

// --- algo.RnullStr17..CopyCtor
inline  algo::RnullStr17::RnullStr17(const algo::RnullStr17 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr17));
}

// --- algo.RnullStr18.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr18& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr18.ch.HashStrptr
inline u32 algo::RnullStr18_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr18.ch.Init
inline void algo::ch_Init(algo::RnullStr18 &parent) {
    memset(parent.ch, 0, 18);
}

// --- algo.RnullStr18.ch.Max
// always return constant 18
inline int algo::ch_Max(algo::RnullStr18& parent) {
    (void)parent;
    return 18;
}

// --- algo.RnullStr18.ch.N
inline int algo::ch_N(const algo::RnullStr18& parent) {
    u64 ret;
    ret = 18;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr18.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr18::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr18.ch.CtorStrptr
inline  algo::RnullStr18::RnullStr18(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr18.ch.Cast
inline  algo::RnullStr18::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr18..EqOp
inline bool algo::RnullStr18::operator ==(const algo::RnullStr18 &rhs) const {
    return algo::RnullStr18_Eq(const_cast<algo::RnullStr18&>(*this),const_cast<algo::RnullStr18&>(rhs));
}

// --- algo.RnullStr18..NeOp
inline bool algo::RnullStr18::operator !=(const algo::RnullStr18 &rhs) const {
    return !algo::RnullStr18_Eq(const_cast<algo::RnullStr18&>(*this),const_cast<algo::RnullStr18&>(rhs));
}

// --- algo.RnullStr18..LtOp
inline bool algo::RnullStr18::operator <(const algo::RnullStr18 &rhs) const {
    return algo::RnullStr18_Lt(const_cast<algo::RnullStr18&>(*this),const_cast<algo::RnullStr18&>(rhs));
}

// --- algo.RnullStr18..GtOp
inline bool algo::RnullStr18::operator >(const algo::RnullStr18 &rhs) const {
    return algo::RnullStr18_Lt(const_cast<algo::RnullStr18&>(rhs),const_cast<algo::RnullStr18&>(*this));
}

// --- algo.RnullStr18..LeOp
inline bool algo::RnullStr18::operator <=(const algo::RnullStr18 &rhs) const {
    return !algo::RnullStr18_Lt(const_cast<algo::RnullStr18&>(rhs),const_cast<algo::RnullStr18&>(*this));
}

// --- algo.RnullStr18..GeOp
inline bool algo::RnullStr18::operator >=(const algo::RnullStr18 &rhs) const {
    return !algo::RnullStr18_Lt(const_cast<algo::RnullStr18&>(*this),const_cast<algo::RnullStr18&>(rhs));
}

// --- algo.RnullStr18..Lt
inline bool algo::RnullStr18_Lt(algo::RnullStr18 lhs, algo::RnullStr18 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr18..Cmp
inline i32 algo::RnullStr18_Cmp(algo::RnullStr18 lhs, algo::RnullStr18 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr18..Init
// Set all fields to initial values.
inline void algo::RnullStr18_Init(algo::RnullStr18& parent) {
    memset(parent.ch, 0, 18);
}

// --- algo.RnullStr18..Eq
inline bool algo::RnullStr18_Eq(algo::RnullStr18 lhs, algo::RnullStr18 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+16) == *(u16*)(rhs.ch+16);
    return retval;
}

// --- algo.RnullStr18..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr18_Update(algo::RnullStr18 &lhs, algo::RnullStr18 rhs) {
    bool ret = !RnullStr18_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr18..EqOpAryptr
inline bool algo::RnullStr18::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr18..AssignOp
inline algo::RnullStr18& algo::RnullStr18::operator =(const algo::RnullStr18 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr18));
    return *this;
}

// --- algo.RnullStr18..Ctor
inline  algo::RnullStr18::RnullStr18() {
    algo::RnullStr18_Init(*this);
}

// --- algo.RnullStr18..CopyCtor
inline  algo::RnullStr18::RnullStr18(const algo::RnullStr18 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr18));
}

// --- algo.RnullStr19.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr19& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr19.ch.HashStrptr
inline u32 algo::RnullStr19_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr19.ch.Init
inline void algo::ch_Init(algo::RnullStr19 &parent) {
    memset(parent.ch, 0, 19);
}

// --- algo.RnullStr19.ch.Max
// always return constant 19
inline int algo::ch_Max(algo::RnullStr19& parent) {
    (void)parent;
    return 19;
}

// --- algo.RnullStr19.ch.N
inline int algo::ch_N(const algo::RnullStr19& parent) {
    u64 ret;
    ret = 19;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr19.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr19::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr19.ch.CtorStrptr
inline  algo::RnullStr19::RnullStr19(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr19.ch.Cast
inline  algo::RnullStr19::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr19..Lt
inline bool algo::RnullStr19_Lt(algo::RnullStr19& lhs, algo::RnullStr19& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr19..Cmp
inline i32 algo::RnullStr19_Cmp(algo::RnullStr19& lhs, algo::RnullStr19& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr19..Init
// Set all fields to initial values.
inline void algo::RnullStr19_Init(algo::RnullStr19& parent) {
    memset(parent.ch, 0, 19);
}

// --- algo.RnullStr19..Eq
inline bool algo::RnullStr19_Eq(algo::RnullStr19& lhs, algo::RnullStr19& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+16) == *(u16*)(rhs.ch+16)
    &&*(u8*)(lhs.ch+18) == *(u8*)(rhs.ch+18);
    return retval;
}

// --- algo.RnullStr19..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr19_Update(algo::RnullStr19 &lhs, algo::RnullStr19& rhs) {
    bool ret = !RnullStr19_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr19..EqOpAryptr
inline bool algo::RnullStr19::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr19..AssignOp
inline algo::RnullStr19& algo::RnullStr19::operator =(const algo::RnullStr19 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr19));
    return *this;
}

// --- algo.RnullStr19..Ctor
inline  algo::RnullStr19::RnullStr19() {
    algo::RnullStr19_Init(*this);
}

// --- algo.RnullStr19..CopyCtor
inline  algo::RnullStr19::RnullStr19(const algo::RnullStr19 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr19));
}

// --- algo.RnullStr2.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr2& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr2.ch.HashStrptr
inline u32 algo::RnullStr2_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr2.ch.Init
inline void algo::ch_Init(algo::RnullStr2 &parent) {
    memset(parent.ch, 0, 2);
}

// --- algo.RnullStr2.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::RnullStr2& parent) {
    (void)parent;
    return 2;
}

// --- algo.RnullStr2.ch.N
inline int algo::ch_N(const algo::RnullStr2& parent) {
    u64 ret;
    ret = 2;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr2.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr2::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr2.ch.CtorStrptr
inline  algo::RnullStr2::RnullStr2(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr2.ch.Cast
inline  algo::RnullStr2::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr2..EqOp
inline bool algo::RnullStr2::operator ==(const algo::RnullStr2 &rhs) const {
    return algo::RnullStr2_Eq(const_cast<algo::RnullStr2&>(*this),const_cast<algo::RnullStr2&>(rhs));
}

// --- algo.RnullStr2..NeOp
inline bool algo::RnullStr2::operator !=(const algo::RnullStr2 &rhs) const {
    return !algo::RnullStr2_Eq(const_cast<algo::RnullStr2&>(*this),const_cast<algo::RnullStr2&>(rhs));
}

// --- algo.RnullStr2..LtOp
inline bool algo::RnullStr2::operator <(const algo::RnullStr2 &rhs) const {
    return algo::RnullStr2_Lt(const_cast<algo::RnullStr2&>(*this),const_cast<algo::RnullStr2&>(rhs));
}

// --- algo.RnullStr2..GtOp
inline bool algo::RnullStr2::operator >(const algo::RnullStr2 &rhs) const {
    return algo::RnullStr2_Lt(const_cast<algo::RnullStr2&>(rhs),const_cast<algo::RnullStr2&>(*this));
}

// --- algo.RnullStr2..LeOp
inline bool algo::RnullStr2::operator <=(const algo::RnullStr2 &rhs) const {
    return !algo::RnullStr2_Lt(const_cast<algo::RnullStr2&>(rhs),const_cast<algo::RnullStr2&>(*this));
}

// --- algo.RnullStr2..GeOp
inline bool algo::RnullStr2::operator >=(const algo::RnullStr2 &rhs) const {
    return !algo::RnullStr2_Lt(const_cast<algo::RnullStr2&>(*this),const_cast<algo::RnullStr2&>(rhs));
}

// --- algo.RnullStr2..Lt
inline bool algo::RnullStr2_Lt(algo::RnullStr2 lhs, algo::RnullStr2 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr2..Cmp
inline i32 algo::RnullStr2_Cmp(algo::RnullStr2 lhs, algo::RnullStr2 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr2..Init
// Set all fields to initial values.
inline void algo::RnullStr2_Init(algo::RnullStr2& parent) {
    memset(parent.ch, 0, 2);
}

// --- algo.RnullStr2..Eq
inline bool algo::RnullStr2_Eq(algo::RnullStr2 lhs, algo::RnullStr2 rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0);
    return retval;
}

// --- algo.RnullStr2..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr2_Update(algo::RnullStr2 &lhs, algo::RnullStr2 rhs) {
    bool ret = !RnullStr2_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr2..EqOpAryptr
inline bool algo::RnullStr2::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr2..AssignOp
inline algo::RnullStr2& algo::RnullStr2::operator =(const algo::RnullStr2 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr2));
    return *this;
}

// --- algo.RnullStr2..Ctor
inline  algo::RnullStr2::RnullStr2() {
    algo::RnullStr2_Init(*this);
}

// --- algo.RnullStr2..CopyCtor
inline  algo::RnullStr2::RnullStr2(const algo::RnullStr2 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr2));
}

// --- algo.RnullStr20.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr20& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr20.ch.HashStrptr
inline u32 algo::RnullStr20_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr20.ch.Init
inline void algo::ch_Init(algo::RnullStr20 &parent) {
    memset(parent.ch, 0, 20);
}

// --- algo.RnullStr20.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::RnullStr20& parent) {
    (void)parent;
    return 20;
}

// --- algo.RnullStr20.ch.N
inline int algo::ch_N(const algo::RnullStr20& parent) {
    u64 ret;
    ret = 20;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr20.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr20::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr20.ch.CtorStrptr
inline  algo::RnullStr20::RnullStr20(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr20.ch.Cast
inline  algo::RnullStr20::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr20..EqOp
inline bool algo::RnullStr20::operator ==(const algo::RnullStr20 &rhs) const {
    return algo::RnullStr20_Eq(const_cast<algo::RnullStr20&>(*this),const_cast<algo::RnullStr20&>(rhs));
}

// --- algo.RnullStr20..NeOp
inline bool algo::RnullStr20::operator !=(const algo::RnullStr20 &rhs) const {
    return !algo::RnullStr20_Eq(const_cast<algo::RnullStr20&>(*this),const_cast<algo::RnullStr20&>(rhs));
}

// --- algo.RnullStr20..LtOp
inline bool algo::RnullStr20::operator <(const algo::RnullStr20 &rhs) const {
    return algo::RnullStr20_Lt(const_cast<algo::RnullStr20&>(*this),const_cast<algo::RnullStr20&>(rhs));
}

// --- algo.RnullStr20..GtOp
inline bool algo::RnullStr20::operator >(const algo::RnullStr20 &rhs) const {
    return algo::RnullStr20_Lt(const_cast<algo::RnullStr20&>(rhs),const_cast<algo::RnullStr20&>(*this));
}

// --- algo.RnullStr20..LeOp
inline bool algo::RnullStr20::operator <=(const algo::RnullStr20 &rhs) const {
    return !algo::RnullStr20_Lt(const_cast<algo::RnullStr20&>(rhs),const_cast<algo::RnullStr20&>(*this));
}

// --- algo.RnullStr20..GeOp
inline bool algo::RnullStr20::operator >=(const algo::RnullStr20 &rhs) const {
    return !algo::RnullStr20_Lt(const_cast<algo::RnullStr20&>(*this),const_cast<algo::RnullStr20&>(rhs));
}

// --- algo.RnullStr20..Lt
inline bool algo::RnullStr20_Lt(algo::RnullStr20 lhs, algo::RnullStr20 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr20..Cmp
inline i32 algo::RnullStr20_Cmp(algo::RnullStr20 lhs, algo::RnullStr20 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr20..Init
// Set all fields to initial values.
inline void algo::RnullStr20_Init(algo::RnullStr20& parent) {
    memset(parent.ch, 0, 20);
}

// --- algo.RnullStr20..Eq
inline bool algo::RnullStr20_Eq(algo::RnullStr20 lhs, algo::RnullStr20 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16);
    return retval;
}

// --- algo.RnullStr20..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr20_Update(algo::RnullStr20 &lhs, algo::RnullStr20 rhs) {
    bool ret = !RnullStr20_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr20..EqOpAryptr
inline bool algo::RnullStr20::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr20..AssignOp
inline algo::RnullStr20& algo::RnullStr20::operator =(const algo::RnullStr20 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr20));
    return *this;
}

// --- algo.RnullStr20..Ctor
inline  algo::RnullStr20::RnullStr20() {
    algo::RnullStr20_Init(*this);
}

// --- algo.RnullStr20..CopyCtor
inline  algo::RnullStr20::RnullStr20(const algo::RnullStr20 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr20));
}

// --- algo.RnullStr21.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr21& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr21.ch.HashStrptr
inline u32 algo::RnullStr21_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr21.ch.Init
inline void algo::ch_Init(algo::RnullStr21 &parent) {
    memset(parent.ch, 0, 21);
}

// --- algo.RnullStr21.ch.Max
// always return constant 21
inline int algo::ch_Max(algo::RnullStr21& parent) {
    (void)parent;
    return 21;
}

// --- algo.RnullStr21.ch.N
inline int algo::ch_N(const algo::RnullStr21& parent) {
    u64 ret;
    ret = 21;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr21.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr21::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr21.ch.CtorStrptr
inline  algo::RnullStr21::RnullStr21(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr21.ch.Cast
inline  algo::RnullStr21::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr21..Lt
inline bool algo::RnullStr21_Lt(algo::RnullStr21& lhs, algo::RnullStr21& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr21..Cmp
inline i32 algo::RnullStr21_Cmp(algo::RnullStr21& lhs, algo::RnullStr21& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr21..Init
// Set all fields to initial values.
inline void algo::RnullStr21_Init(algo::RnullStr21& parent) {
    memset(parent.ch, 0, 21);
}

// --- algo.RnullStr21..Eq
inline bool algo::RnullStr21_Eq(algo::RnullStr21& lhs, algo::RnullStr21& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16)
    &&*(u8*)(lhs.ch+20) == *(u8*)(rhs.ch+20);
    return retval;
}

// --- algo.RnullStr21..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr21_Update(algo::RnullStr21 &lhs, algo::RnullStr21& rhs) {
    bool ret = !RnullStr21_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr21..EqOpAryptr
inline bool algo::RnullStr21::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr21..AssignOp
inline algo::RnullStr21& algo::RnullStr21::operator =(const algo::RnullStr21 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr21));
    return *this;
}

// --- algo.RnullStr21..Ctor
inline  algo::RnullStr21::RnullStr21() {
    algo::RnullStr21_Init(*this);
}

// --- algo.RnullStr21..CopyCtor
inline  algo::RnullStr21::RnullStr21(const algo::RnullStr21 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr21));
}

// --- algo.RnullStr24.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr24& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr24.ch.HashStrptr
inline u32 algo::RnullStr24_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr24.ch.Init
inline void algo::ch_Init(algo::RnullStr24 &parent) {
    memset(parent.ch, 0, 24);
}

// --- algo.RnullStr24.ch.Max
// always return constant 24
inline int algo::ch_Max(algo::RnullStr24& parent) {
    (void)parent;
    return 24;
}

// --- algo.RnullStr24.ch.N
inline int algo::ch_N(const algo::RnullStr24& parent) {
    u64 ret;
    ret = 24;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr24.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr24::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr24.ch.CtorStrptr
inline  algo::RnullStr24::RnullStr24(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr24.ch.Cast
inline  algo::RnullStr24::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr24..EqOp
inline bool algo::RnullStr24::operator ==(const algo::RnullStr24 &rhs) const {
    return algo::RnullStr24_Eq(const_cast<algo::RnullStr24&>(*this),const_cast<algo::RnullStr24&>(rhs));
}

// --- algo.RnullStr24..NeOp
inline bool algo::RnullStr24::operator !=(const algo::RnullStr24 &rhs) const {
    return !algo::RnullStr24_Eq(const_cast<algo::RnullStr24&>(*this),const_cast<algo::RnullStr24&>(rhs));
}

// --- algo.RnullStr24..LtOp
inline bool algo::RnullStr24::operator <(const algo::RnullStr24 &rhs) const {
    return algo::RnullStr24_Lt(const_cast<algo::RnullStr24&>(*this),const_cast<algo::RnullStr24&>(rhs));
}

// --- algo.RnullStr24..GtOp
inline bool algo::RnullStr24::operator >(const algo::RnullStr24 &rhs) const {
    return algo::RnullStr24_Lt(const_cast<algo::RnullStr24&>(rhs),const_cast<algo::RnullStr24&>(*this));
}

// --- algo.RnullStr24..LeOp
inline bool algo::RnullStr24::operator <=(const algo::RnullStr24 &rhs) const {
    return !algo::RnullStr24_Lt(const_cast<algo::RnullStr24&>(rhs),const_cast<algo::RnullStr24&>(*this));
}

// --- algo.RnullStr24..GeOp
inline bool algo::RnullStr24::operator >=(const algo::RnullStr24 &rhs) const {
    return !algo::RnullStr24_Lt(const_cast<algo::RnullStr24&>(*this),const_cast<algo::RnullStr24&>(rhs));
}

// --- algo.RnullStr24..Lt
inline bool algo::RnullStr24_Lt(algo::RnullStr24& lhs, algo::RnullStr24& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr24..Cmp
inline i32 algo::RnullStr24_Cmp(algo::RnullStr24& lhs, algo::RnullStr24& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr24..Init
// Set all fields to initial values.
inline void algo::RnullStr24_Init(algo::RnullStr24& parent) {
    memset(parent.ch, 0, 24);
}

// --- algo.RnullStr24..Eq
inline bool algo::RnullStr24_Eq(algo::RnullStr24& lhs, algo::RnullStr24& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16);
    return retval;
}

// --- algo.RnullStr24..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr24_Update(algo::RnullStr24 &lhs, algo::RnullStr24& rhs) {
    bool ret = !RnullStr24_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr24..EqOpAryptr
inline bool algo::RnullStr24::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr24..AssignOp
inline algo::RnullStr24& algo::RnullStr24::operator =(const algo::RnullStr24 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr24));
    return *this;
}

// --- algo.RnullStr24..Ctor
inline  algo::RnullStr24::RnullStr24() {
    algo::RnullStr24_Init(*this);
}

// --- algo.RnullStr24..CopyCtor
inline  algo::RnullStr24::RnullStr24(const algo::RnullStr24 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr24));
}

// --- algo.RnullStr25.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr25& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr25.ch.HashStrptr
inline u32 algo::RnullStr25_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr25.ch.Init
inline void algo::ch_Init(algo::RnullStr25 &parent) {
    memset(parent.ch, 0, 25);
}

// --- algo.RnullStr25.ch.Max
// always return constant 25
inline int algo::ch_Max(algo::RnullStr25& parent) {
    (void)parent;
    return 25;
}

// --- algo.RnullStr25.ch.N
inline int algo::ch_N(const algo::RnullStr25& parent) {
    u64 ret;
    ret = 25;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr25.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr25::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr25.ch.CtorStrptr
inline  algo::RnullStr25::RnullStr25(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr25.ch.Cast
inline  algo::RnullStr25::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr25..EqOp
inline bool algo::RnullStr25::operator ==(const algo::RnullStr25 &rhs) const {
    return algo::RnullStr25_Eq(const_cast<algo::RnullStr25&>(*this),const_cast<algo::RnullStr25&>(rhs));
}

// --- algo.RnullStr25..NeOp
inline bool algo::RnullStr25::operator !=(const algo::RnullStr25 &rhs) const {
    return !algo::RnullStr25_Eq(const_cast<algo::RnullStr25&>(*this),const_cast<algo::RnullStr25&>(rhs));
}

// --- algo.RnullStr25..LtOp
inline bool algo::RnullStr25::operator <(const algo::RnullStr25 &rhs) const {
    return algo::RnullStr25_Lt(const_cast<algo::RnullStr25&>(*this),const_cast<algo::RnullStr25&>(rhs));
}

// --- algo.RnullStr25..GtOp
inline bool algo::RnullStr25::operator >(const algo::RnullStr25 &rhs) const {
    return algo::RnullStr25_Lt(const_cast<algo::RnullStr25&>(rhs),const_cast<algo::RnullStr25&>(*this));
}

// --- algo.RnullStr25..LeOp
inline bool algo::RnullStr25::operator <=(const algo::RnullStr25 &rhs) const {
    return !algo::RnullStr25_Lt(const_cast<algo::RnullStr25&>(rhs),const_cast<algo::RnullStr25&>(*this));
}

// --- algo.RnullStr25..GeOp
inline bool algo::RnullStr25::operator >=(const algo::RnullStr25 &rhs) const {
    return !algo::RnullStr25_Lt(const_cast<algo::RnullStr25&>(*this),const_cast<algo::RnullStr25&>(rhs));
}

// --- algo.RnullStr25..Lt
inline bool algo::RnullStr25_Lt(algo::RnullStr25& lhs, algo::RnullStr25& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr25..Cmp
inline i32 algo::RnullStr25_Cmp(algo::RnullStr25& lhs, algo::RnullStr25& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr25..Init
// Set all fields to initial values.
inline void algo::RnullStr25_Init(algo::RnullStr25& parent) {
    memset(parent.ch, 0, 25);
}

// --- algo.RnullStr25..Eq
inline bool algo::RnullStr25_Eq(algo::RnullStr25& lhs, algo::RnullStr25& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u8*)(lhs.ch+24) == *(u8*)(rhs.ch+24);
    return retval;
}

// --- algo.RnullStr25..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr25_Update(algo::RnullStr25 &lhs, algo::RnullStr25& rhs) {
    bool ret = !RnullStr25_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr25..EqOpAryptr
inline bool algo::RnullStr25::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr25..AssignOp
inline algo::RnullStr25& algo::RnullStr25::operator =(const algo::RnullStr25 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr25));
    return *this;
}

// --- algo.RnullStr25..Ctor
inline  algo::RnullStr25::RnullStr25() {
    algo::RnullStr25_Init(*this);
}

// --- algo.RnullStr25..CopyCtor
inline  algo::RnullStr25::RnullStr25(const algo::RnullStr25 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr25));
}

// --- algo.RnullStr28.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr28& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr28.ch.HashStrptr
inline u32 algo::RnullStr28_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr28.ch.Init
inline void algo::ch_Init(algo::RnullStr28 &parent) {
    memset(parent.ch, 0, 28);
}

// --- algo.RnullStr28.ch.Max
// always return constant 28
inline int algo::ch_Max(algo::RnullStr28& parent) {
    (void)parent;
    return 28;
}

// --- algo.RnullStr28.ch.N
inline int algo::ch_N(const algo::RnullStr28& parent) {
    u64 ret;
    ret = 28;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr28.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr28::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr28.ch.CtorStrptr
inline  algo::RnullStr28::RnullStr28(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr28.ch.Cast
inline  algo::RnullStr28::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr28..EqOp
inline bool algo::RnullStr28::operator ==(const algo::RnullStr28 &rhs) const {
    return algo::RnullStr28_Eq(const_cast<algo::RnullStr28&>(*this),const_cast<algo::RnullStr28&>(rhs));
}

// --- algo.RnullStr28..NeOp
inline bool algo::RnullStr28::operator !=(const algo::RnullStr28 &rhs) const {
    return !algo::RnullStr28_Eq(const_cast<algo::RnullStr28&>(*this),const_cast<algo::RnullStr28&>(rhs));
}

// --- algo.RnullStr28..LtOp
inline bool algo::RnullStr28::operator <(const algo::RnullStr28 &rhs) const {
    return algo::RnullStr28_Lt(const_cast<algo::RnullStr28&>(*this),const_cast<algo::RnullStr28&>(rhs));
}

// --- algo.RnullStr28..GtOp
inline bool algo::RnullStr28::operator >(const algo::RnullStr28 &rhs) const {
    return algo::RnullStr28_Lt(const_cast<algo::RnullStr28&>(rhs),const_cast<algo::RnullStr28&>(*this));
}

// --- algo.RnullStr28..LeOp
inline bool algo::RnullStr28::operator <=(const algo::RnullStr28 &rhs) const {
    return !algo::RnullStr28_Lt(const_cast<algo::RnullStr28&>(rhs),const_cast<algo::RnullStr28&>(*this));
}

// --- algo.RnullStr28..GeOp
inline bool algo::RnullStr28::operator >=(const algo::RnullStr28 &rhs) const {
    return !algo::RnullStr28_Lt(const_cast<algo::RnullStr28&>(*this),const_cast<algo::RnullStr28&>(rhs));
}

// --- algo.RnullStr28..Lt
inline bool algo::RnullStr28_Lt(algo::RnullStr28& lhs, algo::RnullStr28& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr28..Cmp
inline i32 algo::RnullStr28_Cmp(algo::RnullStr28& lhs, algo::RnullStr28& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr28..Init
// Set all fields to initial values.
inline void algo::RnullStr28_Init(algo::RnullStr28& parent) {
    memset(parent.ch, 0, 28);
}

// --- algo.RnullStr28..Eq
inline bool algo::RnullStr28_Eq(algo::RnullStr28& lhs, algo::RnullStr28& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u32*)(lhs.ch+24) == *(u32*)(rhs.ch+24);
    return retval;
}

// --- algo.RnullStr28..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr28_Update(algo::RnullStr28 &lhs, algo::RnullStr28& rhs) {
    bool ret = !RnullStr28_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr28..EqOpAryptr
inline bool algo::RnullStr28::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr28..AssignOp
inline algo::RnullStr28& algo::RnullStr28::operator =(const algo::RnullStr28 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr28));
    return *this;
}

// --- algo.RnullStr28..Ctor
inline  algo::RnullStr28::RnullStr28() {
    algo::RnullStr28_Init(*this);
}

// --- algo.RnullStr28..CopyCtor
inline  algo::RnullStr28::RnullStr28(const algo::RnullStr28 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr28));
}

// --- algo.RnullStr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr3.ch.HashStrptr
inline u32 algo::RnullStr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr3.ch.Init
inline void algo::ch_Init(algo::RnullStr3 &parent) {
    memset(parent.ch, 0, 3);
}

// --- algo.RnullStr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::RnullStr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.RnullStr3.ch.N
inline int algo::ch_N(const algo::RnullStr3& parent) {
    u64 ret;
    ret = 3;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr3.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr3::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr3.ch.CtorStrptr
inline  algo::RnullStr3::RnullStr3(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr3.ch.Cast
inline  algo::RnullStr3::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr3..EqOp
inline bool algo::RnullStr3::operator ==(const algo::RnullStr3 &rhs) const {
    return algo::RnullStr3_Eq(const_cast<algo::RnullStr3&>(*this),const_cast<algo::RnullStr3&>(rhs));
}

// --- algo.RnullStr3..NeOp
inline bool algo::RnullStr3::operator !=(const algo::RnullStr3 &rhs) const {
    return !algo::RnullStr3_Eq(const_cast<algo::RnullStr3&>(*this),const_cast<algo::RnullStr3&>(rhs));
}

// --- algo.RnullStr3..LtOp
inline bool algo::RnullStr3::operator <(const algo::RnullStr3 &rhs) const {
    return algo::RnullStr3_Lt(const_cast<algo::RnullStr3&>(*this),const_cast<algo::RnullStr3&>(rhs));
}

// --- algo.RnullStr3..GtOp
inline bool algo::RnullStr3::operator >(const algo::RnullStr3 &rhs) const {
    return algo::RnullStr3_Lt(const_cast<algo::RnullStr3&>(rhs),const_cast<algo::RnullStr3&>(*this));
}

// --- algo.RnullStr3..LeOp
inline bool algo::RnullStr3::operator <=(const algo::RnullStr3 &rhs) const {
    return !algo::RnullStr3_Lt(const_cast<algo::RnullStr3&>(rhs),const_cast<algo::RnullStr3&>(*this));
}

// --- algo.RnullStr3..GeOp
inline bool algo::RnullStr3::operator >=(const algo::RnullStr3 &rhs) const {
    return !algo::RnullStr3_Lt(const_cast<algo::RnullStr3&>(*this),const_cast<algo::RnullStr3&>(rhs));
}

// --- algo.RnullStr3..Lt
inline bool algo::RnullStr3_Lt(algo::RnullStr3 lhs, algo::RnullStr3 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr3..Cmp
inline i32 algo::RnullStr3_Cmp(algo::RnullStr3 lhs, algo::RnullStr3 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr3..Init
// Set all fields to initial values.
inline void algo::RnullStr3_Init(algo::RnullStr3& parent) {
    memset(parent.ch, 0, 3);
}

// --- algo.RnullStr3..Eq
inline bool algo::RnullStr3_Eq(algo::RnullStr3 lhs, algo::RnullStr3 rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+2) == *(u8*)(rhs.ch+2);
    return retval;
}

// --- algo.RnullStr3..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr3_Update(algo::RnullStr3 &lhs, algo::RnullStr3 rhs) {
    bool ret = !RnullStr3_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr3..EqOpAryptr
inline bool algo::RnullStr3::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr3..AssignOp
inline algo::RnullStr3& algo::RnullStr3::operator =(const algo::RnullStr3 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr3));
    return *this;
}

// --- algo.RnullStr3..Ctor
inline  algo::RnullStr3::RnullStr3() {
    algo::RnullStr3_Init(*this);
}

// --- algo.RnullStr3..CopyCtor
inline  algo::RnullStr3::RnullStr3(const algo::RnullStr3 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr3));
}

// --- algo.RnullStr30.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr30& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr30.ch.HashStrptr
inline u32 algo::RnullStr30_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr30.ch.Init
inline void algo::ch_Init(algo::RnullStr30 &parent) {
    memset(parent.ch, 0, 30);
}

// --- algo.RnullStr30.ch.Max
// always return constant 30
inline int algo::ch_Max(algo::RnullStr30& parent) {
    (void)parent;
    return 30;
}

// --- algo.RnullStr30.ch.N
inline int algo::ch_N(const algo::RnullStr30& parent) {
    u64 ret;
    ret = 30;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr30.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr30::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr30.ch.CtorStrptr
inline  algo::RnullStr30::RnullStr30(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr30.ch.Cast
inline  algo::RnullStr30::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr30..Lt
inline bool algo::RnullStr30_Lt(algo::RnullStr30 lhs, algo::RnullStr30 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr30..Cmp
inline i32 algo::RnullStr30_Cmp(algo::RnullStr30 lhs, algo::RnullStr30 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr30..Init
// Set all fields to initial values.
inline void algo::RnullStr30_Init(algo::RnullStr30& parent) {
    memset(parent.ch, 0, 30);
}

// --- algo.RnullStr30..Eq
inline bool algo::RnullStr30_Eq(algo::RnullStr30 lhs, algo::RnullStr30 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u32*)(lhs.ch+24) == *(u32*)(rhs.ch+24)
    &&*(u16*)(lhs.ch+28) == *(u16*)(rhs.ch+28);
    return retval;
}

// --- algo.RnullStr30..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr30_Update(algo::RnullStr30 &lhs, algo::RnullStr30 rhs) {
    bool ret = !RnullStr30_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr30..EqOpAryptr
inline bool algo::RnullStr30::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr30..AssignOp
inline algo::RnullStr30& algo::RnullStr30::operator =(const algo::RnullStr30 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr30));
    return *this;
}

// --- algo.RnullStr30..Ctor
inline  algo::RnullStr30::RnullStr30() {
    algo::RnullStr30_Init(*this);
}

// --- algo.RnullStr30..CopyCtor
inline  algo::RnullStr30::RnullStr30(const algo::RnullStr30 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr30));
}

// --- algo.RnullStr32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr32.ch.HashStrptr
inline u32 algo::RnullStr32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr32.ch.Init
inline void algo::ch_Init(algo::RnullStr32 &parent) {
    memset(parent.ch, 0, 32);
}

// --- algo.RnullStr32.ch.Max
// always return constant 32
inline int algo::ch_Max(algo::RnullStr32& parent) {
    (void)parent;
    return 32;
}

// --- algo.RnullStr32.ch.N
inline int algo::ch_N(const algo::RnullStr32& parent) {
    u64 ret;
    ret = 32;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr32.ch.CtorStrptr
inline  algo::RnullStr32::RnullStr32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr32.ch.Cast
inline  algo::RnullStr32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr32..EqOp
inline bool algo::RnullStr32::operator ==(const algo::RnullStr32 &rhs) const {
    return algo::RnullStr32_Eq(const_cast<algo::RnullStr32&>(*this),const_cast<algo::RnullStr32&>(rhs));
}

// --- algo.RnullStr32..NeOp
inline bool algo::RnullStr32::operator !=(const algo::RnullStr32 &rhs) const {
    return !algo::RnullStr32_Eq(const_cast<algo::RnullStr32&>(*this),const_cast<algo::RnullStr32&>(rhs));
}

// --- algo.RnullStr32..LtOp
inline bool algo::RnullStr32::operator <(const algo::RnullStr32 &rhs) const {
    return algo::RnullStr32_Lt(const_cast<algo::RnullStr32&>(*this),const_cast<algo::RnullStr32&>(rhs));
}

// --- algo.RnullStr32..GtOp
inline bool algo::RnullStr32::operator >(const algo::RnullStr32 &rhs) const {
    return algo::RnullStr32_Lt(const_cast<algo::RnullStr32&>(rhs),const_cast<algo::RnullStr32&>(*this));
}

// --- algo.RnullStr32..LeOp
inline bool algo::RnullStr32::operator <=(const algo::RnullStr32 &rhs) const {
    return !algo::RnullStr32_Lt(const_cast<algo::RnullStr32&>(rhs),const_cast<algo::RnullStr32&>(*this));
}

// --- algo.RnullStr32..GeOp
inline bool algo::RnullStr32::operator >=(const algo::RnullStr32 &rhs) const {
    return !algo::RnullStr32_Lt(const_cast<algo::RnullStr32&>(*this),const_cast<algo::RnullStr32&>(rhs));
}

// --- algo.RnullStr32..Lt
inline bool algo::RnullStr32_Lt(algo::RnullStr32 lhs, algo::RnullStr32 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr32..Cmp
inline i32 algo::RnullStr32_Cmp(algo::RnullStr32 lhs, algo::RnullStr32 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr32..Init
// Set all fields to initial values.
inline void algo::RnullStr32_Init(algo::RnullStr32& parent) {
    memset(parent.ch, 0, 32);
}

// --- algo.RnullStr32..Eq
inline bool algo::RnullStr32_Eq(algo::RnullStr32 lhs, algo::RnullStr32 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24);
    return retval;
}

// --- algo.RnullStr32..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr32_Update(algo::RnullStr32 &lhs, algo::RnullStr32 rhs) {
    bool ret = !RnullStr32_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr32..EqOpAryptr
inline bool algo::RnullStr32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr32..AssignOp
inline algo::RnullStr32& algo::RnullStr32::operator =(const algo::RnullStr32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr32));
    return *this;
}

// --- algo.RnullStr32..Ctor
inline  algo::RnullStr32::RnullStr32() {
    algo::RnullStr32_Init(*this);
}

// --- algo.RnullStr32..CopyCtor
inline  algo::RnullStr32::RnullStr32(const algo::RnullStr32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr32));
}

// --- algo.RnullStr33.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr33& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr33.ch.HashStrptr
inline u32 algo::RnullStr33_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr33.ch.Init
inline void algo::ch_Init(algo::RnullStr33 &parent) {
    memset(parent.ch, 0, 33);
}

// --- algo.RnullStr33.ch.Max
// always return constant 33
inline int algo::ch_Max(algo::RnullStr33& parent) {
    (void)parent;
    return 33;
}

// --- algo.RnullStr33.ch.N
inline int algo::ch_N(const algo::RnullStr33& parent) {
    u64 ret;
    ret = 33;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr33.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr33::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr33.ch.CtorStrptr
inline  algo::RnullStr33::RnullStr33(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr33.ch.Cast
inline  algo::RnullStr33::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr33..EqOp
inline bool algo::RnullStr33::operator ==(const algo::RnullStr33 &rhs) const {
    return algo::RnullStr33_Eq(const_cast<algo::RnullStr33&>(*this),const_cast<algo::RnullStr33&>(rhs));
}

// --- algo.RnullStr33..NeOp
inline bool algo::RnullStr33::operator !=(const algo::RnullStr33 &rhs) const {
    return !algo::RnullStr33_Eq(const_cast<algo::RnullStr33&>(*this),const_cast<algo::RnullStr33&>(rhs));
}

// --- algo.RnullStr33..LtOp
inline bool algo::RnullStr33::operator <(const algo::RnullStr33 &rhs) const {
    return algo::RnullStr33_Lt(const_cast<algo::RnullStr33&>(*this),const_cast<algo::RnullStr33&>(rhs));
}

// --- algo.RnullStr33..GtOp
inline bool algo::RnullStr33::operator >(const algo::RnullStr33 &rhs) const {
    return algo::RnullStr33_Lt(const_cast<algo::RnullStr33&>(rhs),const_cast<algo::RnullStr33&>(*this));
}

// --- algo.RnullStr33..LeOp
inline bool algo::RnullStr33::operator <=(const algo::RnullStr33 &rhs) const {
    return !algo::RnullStr33_Lt(const_cast<algo::RnullStr33&>(rhs),const_cast<algo::RnullStr33&>(*this));
}

// --- algo.RnullStr33..GeOp
inline bool algo::RnullStr33::operator >=(const algo::RnullStr33 &rhs) const {
    return !algo::RnullStr33_Lt(const_cast<algo::RnullStr33&>(*this),const_cast<algo::RnullStr33&>(rhs));
}

// --- algo.RnullStr33..Lt
inline bool algo::RnullStr33_Lt(algo::RnullStr33& lhs, algo::RnullStr33& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr33..Cmp
inline i32 algo::RnullStr33_Cmp(algo::RnullStr33& lhs, algo::RnullStr33& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr33..Init
// Set all fields to initial values.
inline void algo::RnullStr33_Init(algo::RnullStr33& parent) {
    memset(parent.ch, 0, 33);
}

// --- algo.RnullStr33..Eq
inline bool algo::RnullStr33_Eq(algo::RnullStr33& lhs, algo::RnullStr33& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u8*)(lhs.ch+32) == *(u8*)(rhs.ch+32);
    return retval;
}

// --- algo.RnullStr33..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr33_Update(algo::RnullStr33 &lhs, algo::RnullStr33& rhs) {
    bool ret = !RnullStr33_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr33..EqOpAryptr
inline bool algo::RnullStr33::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr33..AssignOp
inline algo::RnullStr33& algo::RnullStr33::operator =(const algo::RnullStr33 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr33));
    return *this;
}

// --- algo.RnullStr33..Ctor
inline  algo::RnullStr33::RnullStr33() {
    algo::RnullStr33_Init(*this);
}

// --- algo.RnullStr33..CopyCtor
inline  algo::RnullStr33::RnullStr33(const algo::RnullStr33 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr33));
}

// --- algo.RnullStr35.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr35& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr35.ch.HashStrptr
inline u32 algo::RnullStr35_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr35.ch.Init
inline void algo::ch_Init(algo::RnullStr35 &parent) {
    memset(parent.ch, 0, 35);
}

// --- algo.RnullStr35.ch.Max
// always return constant 35
inline int algo::ch_Max(algo::RnullStr35& parent) {
    (void)parent;
    return 35;
}

// --- algo.RnullStr35.ch.N
inline int algo::ch_N(const algo::RnullStr35& parent) {
    u64 ret;
    ret = 35;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr35.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr35::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr35.ch.CtorStrptr
inline  algo::RnullStr35::RnullStr35(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr35.ch.Cast
inline  algo::RnullStr35::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr35..EqOp
inline bool algo::RnullStr35::operator ==(const algo::RnullStr35 &rhs) const {
    return algo::RnullStr35_Eq(const_cast<algo::RnullStr35&>(*this),const_cast<algo::RnullStr35&>(rhs));
}

// --- algo.RnullStr35..NeOp
inline bool algo::RnullStr35::operator !=(const algo::RnullStr35 &rhs) const {
    return !algo::RnullStr35_Eq(const_cast<algo::RnullStr35&>(*this),const_cast<algo::RnullStr35&>(rhs));
}

// --- algo.RnullStr35..LtOp
inline bool algo::RnullStr35::operator <(const algo::RnullStr35 &rhs) const {
    return algo::RnullStr35_Lt(const_cast<algo::RnullStr35&>(*this),const_cast<algo::RnullStr35&>(rhs));
}

// --- algo.RnullStr35..GtOp
inline bool algo::RnullStr35::operator >(const algo::RnullStr35 &rhs) const {
    return algo::RnullStr35_Lt(const_cast<algo::RnullStr35&>(rhs),const_cast<algo::RnullStr35&>(*this));
}

// --- algo.RnullStr35..LeOp
inline bool algo::RnullStr35::operator <=(const algo::RnullStr35 &rhs) const {
    return !algo::RnullStr35_Lt(const_cast<algo::RnullStr35&>(rhs),const_cast<algo::RnullStr35&>(*this));
}

// --- algo.RnullStr35..GeOp
inline bool algo::RnullStr35::operator >=(const algo::RnullStr35 &rhs) const {
    return !algo::RnullStr35_Lt(const_cast<algo::RnullStr35&>(*this),const_cast<algo::RnullStr35&>(rhs));
}

// --- algo.RnullStr35..Lt
inline bool algo::RnullStr35_Lt(algo::RnullStr35& lhs, algo::RnullStr35& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr35..Cmp
inline i32 algo::RnullStr35_Cmp(algo::RnullStr35& lhs, algo::RnullStr35& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr35..Init
// Set all fields to initial values.
inline void algo::RnullStr35_Init(algo::RnullStr35& parent) {
    memset(parent.ch, 0, 35);
}

// --- algo.RnullStr35..Eq
inline bool algo::RnullStr35_Eq(algo::RnullStr35& lhs, algo::RnullStr35& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u16*)(lhs.ch+32) == *(u16*)(rhs.ch+32)
    &&*(u8*)(lhs.ch+34) == *(u8*)(rhs.ch+34);
    return retval;
}

// --- algo.RnullStr35..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr35_Update(algo::RnullStr35 &lhs, algo::RnullStr35& rhs) {
    bool ret = !RnullStr35_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr35..EqOpAryptr
inline bool algo::RnullStr35::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr35..AssignOp
inline algo::RnullStr35& algo::RnullStr35::operator =(const algo::RnullStr35 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr35));
    return *this;
}

// --- algo.RnullStr35..Ctor
inline  algo::RnullStr35::RnullStr35() {
    algo::RnullStr35_Init(*this);
}

// --- algo.RnullStr35..CopyCtor
inline  algo::RnullStr35::RnullStr35(const algo::RnullStr35 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr35));
}

// --- algo.RnullStr36.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr36& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr36.ch.HashStrptr
inline u32 algo::RnullStr36_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr36.ch.Init
inline void algo::ch_Init(algo::RnullStr36 &parent) {
    memset(parent.ch, 0, 36);
}

// --- algo.RnullStr36.ch.Max
// always return constant 36
inline int algo::ch_Max(algo::RnullStr36& parent) {
    (void)parent;
    return 36;
}

// --- algo.RnullStr36.ch.N
inline int algo::ch_N(const algo::RnullStr36& parent) {
    u64 ret;
    ret = 36;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr36.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr36::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr36.ch.CtorStrptr
inline  algo::RnullStr36::RnullStr36(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr36.ch.Cast
inline  algo::RnullStr36::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr36..EqOp
inline bool algo::RnullStr36::operator ==(const algo::RnullStr36 &rhs) const {
    return algo::RnullStr36_Eq(const_cast<algo::RnullStr36&>(*this),const_cast<algo::RnullStr36&>(rhs));
}

// --- algo.RnullStr36..NeOp
inline bool algo::RnullStr36::operator !=(const algo::RnullStr36 &rhs) const {
    return !algo::RnullStr36_Eq(const_cast<algo::RnullStr36&>(*this),const_cast<algo::RnullStr36&>(rhs));
}

// --- algo.RnullStr36..LtOp
inline bool algo::RnullStr36::operator <(const algo::RnullStr36 &rhs) const {
    return algo::RnullStr36_Lt(const_cast<algo::RnullStr36&>(*this),const_cast<algo::RnullStr36&>(rhs));
}

// --- algo.RnullStr36..GtOp
inline bool algo::RnullStr36::operator >(const algo::RnullStr36 &rhs) const {
    return algo::RnullStr36_Lt(const_cast<algo::RnullStr36&>(rhs),const_cast<algo::RnullStr36&>(*this));
}

// --- algo.RnullStr36..LeOp
inline bool algo::RnullStr36::operator <=(const algo::RnullStr36 &rhs) const {
    return !algo::RnullStr36_Lt(const_cast<algo::RnullStr36&>(rhs),const_cast<algo::RnullStr36&>(*this));
}

// --- algo.RnullStr36..GeOp
inline bool algo::RnullStr36::operator >=(const algo::RnullStr36 &rhs) const {
    return !algo::RnullStr36_Lt(const_cast<algo::RnullStr36&>(*this),const_cast<algo::RnullStr36&>(rhs));
}

// --- algo.RnullStr36..Lt
inline bool algo::RnullStr36_Lt(algo::RnullStr36& lhs, algo::RnullStr36& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr36..Cmp
inline i32 algo::RnullStr36_Cmp(algo::RnullStr36& lhs, algo::RnullStr36& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr36..Init
// Set all fields to initial values.
inline void algo::RnullStr36_Init(algo::RnullStr36& parent) {
    memset(parent.ch, 0, 36);
}

// --- algo.RnullStr36..Eq
inline bool algo::RnullStr36_Eq(algo::RnullStr36& lhs, algo::RnullStr36& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u32*)(lhs.ch+32) == *(u32*)(rhs.ch+32);
    return retval;
}

// --- algo.RnullStr36..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr36_Update(algo::RnullStr36 &lhs, algo::RnullStr36& rhs) {
    bool ret = !RnullStr36_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr36..EqOpAryptr
inline bool algo::RnullStr36::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr36..AssignOp
inline algo::RnullStr36& algo::RnullStr36::operator =(const algo::RnullStr36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr36));
    return *this;
}

// --- algo.RnullStr36..Ctor
inline  algo::RnullStr36::RnullStr36() {
    algo::RnullStr36_Init(*this);
}

// --- algo.RnullStr36..CopyCtor
inline  algo::RnullStr36::RnullStr36(const algo::RnullStr36 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr36));
}

// --- algo.RnullStr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr4.ch.HashStrptr
inline u32 algo::RnullStr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr4.ch.Init
inline void algo::ch_Init(algo::RnullStr4 &parent) {
    memset(parent.ch, 0, 4);
}

// --- algo.RnullStr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::RnullStr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.RnullStr4.ch.N
inline int algo::ch_N(const algo::RnullStr4& parent) {
    u64 ret;
    ret = 4;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr4.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr4::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr4.ch.CtorStrptr
inline  algo::RnullStr4::RnullStr4(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr4.ch.Cast
inline  algo::RnullStr4::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr4..Lt
inline bool algo::RnullStr4_Lt(algo::RnullStr4 lhs, algo::RnullStr4 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr4..Cmp
inline i32 algo::RnullStr4_Cmp(algo::RnullStr4 lhs, algo::RnullStr4 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr4..Init
// Set all fields to initial values.
inline void algo::RnullStr4_Init(algo::RnullStr4& parent) {
    memset(parent.ch, 0, 4);
}

// --- algo.RnullStr4..Eq
inline bool algo::RnullStr4_Eq(algo::RnullStr4 lhs, algo::RnullStr4 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0);
    return retval;
}

// --- algo.RnullStr4..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr4_Update(algo::RnullStr4 &lhs, algo::RnullStr4 rhs) {
    bool ret = !RnullStr4_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr4..EqOpAryptr
inline bool algo::RnullStr4::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr4..AssignOp
inline algo::RnullStr4& algo::RnullStr4::operator =(const algo::RnullStr4 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr4));
    return *this;
}

// --- algo.RnullStr4..Ctor
inline  algo::RnullStr4::RnullStr4() {
    algo::RnullStr4_Init(*this);
}

// --- algo.RnullStr4..CopyCtor
inline  algo::RnullStr4::RnullStr4(const algo::RnullStr4 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr4));
}

// --- algo.RnullStr40.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr40& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr40.ch.HashStrptr
inline u32 algo::RnullStr40_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr40.ch.Init
inline void algo::ch_Init(algo::RnullStr40 &parent) {
    memset(parent.ch, 0, 40);
}

// --- algo.RnullStr40.ch.Max
// always return constant 40
inline int algo::ch_Max(algo::RnullStr40& parent) {
    (void)parent;
    return 40;
}

// --- algo.RnullStr40.ch.N
inline int algo::ch_N(const algo::RnullStr40& parent) {
    u64 ret;
    ret = 40;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr40.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr40::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr40.ch.CtorStrptr
inline  algo::RnullStr40::RnullStr40(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr40.ch.Cast
inline  algo::RnullStr40::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr40..EqOp
inline bool algo::RnullStr40::operator ==(const algo::RnullStr40 &rhs) const {
    return algo::RnullStr40_Eq(const_cast<algo::RnullStr40&>(*this),const_cast<algo::RnullStr40&>(rhs));
}

// --- algo.RnullStr40..NeOp
inline bool algo::RnullStr40::operator !=(const algo::RnullStr40 &rhs) const {
    return !algo::RnullStr40_Eq(const_cast<algo::RnullStr40&>(*this),const_cast<algo::RnullStr40&>(rhs));
}

// --- algo.RnullStr40..LtOp
inline bool algo::RnullStr40::operator <(const algo::RnullStr40 &rhs) const {
    return algo::RnullStr40_Lt(const_cast<algo::RnullStr40&>(*this),const_cast<algo::RnullStr40&>(rhs));
}

// --- algo.RnullStr40..GtOp
inline bool algo::RnullStr40::operator >(const algo::RnullStr40 &rhs) const {
    return algo::RnullStr40_Lt(const_cast<algo::RnullStr40&>(rhs),const_cast<algo::RnullStr40&>(*this));
}

// --- algo.RnullStr40..LeOp
inline bool algo::RnullStr40::operator <=(const algo::RnullStr40 &rhs) const {
    return !algo::RnullStr40_Lt(const_cast<algo::RnullStr40&>(rhs),const_cast<algo::RnullStr40&>(*this));
}

// --- algo.RnullStr40..GeOp
inline bool algo::RnullStr40::operator >=(const algo::RnullStr40 &rhs) const {
    return !algo::RnullStr40_Lt(const_cast<algo::RnullStr40&>(*this),const_cast<algo::RnullStr40&>(rhs));
}

// --- algo.RnullStr40..Lt
inline bool algo::RnullStr40_Lt(algo::RnullStr40& lhs, algo::RnullStr40& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr40..Cmp
inline i32 algo::RnullStr40_Cmp(algo::RnullStr40& lhs, algo::RnullStr40& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr40..Init
// Set all fields to initial values.
inline void algo::RnullStr40_Init(algo::RnullStr40& parent) {
    memset(parent.ch, 0, 40);
}

// --- algo.RnullStr40..Eq
inline bool algo::RnullStr40_Eq(algo::RnullStr40& lhs, algo::RnullStr40& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32);
    return retval;
}

// --- algo.RnullStr40..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr40_Update(algo::RnullStr40 &lhs, algo::RnullStr40& rhs) {
    bool ret = !RnullStr40_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr40..EqOpAryptr
inline bool algo::RnullStr40::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr40..AssignOp
inline algo::RnullStr40& algo::RnullStr40::operator =(const algo::RnullStr40 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr40));
    return *this;
}

// --- algo.RnullStr40..Ctor
inline  algo::RnullStr40::RnullStr40() {
    algo::RnullStr40_Init(*this);
}

// --- algo.RnullStr40..CopyCtor
inline  algo::RnullStr40::RnullStr40(const algo::RnullStr40 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr40));
}

// --- algo.RnullStr41.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr41& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr41.ch.HashStrptr
inline u32 algo::RnullStr41_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr41.ch.Init
inline void algo::ch_Init(algo::RnullStr41 &parent) {
    memset(parent.ch, 0, 41);
}

// --- algo.RnullStr41.ch.Max
// always return constant 41
inline int algo::ch_Max(algo::RnullStr41& parent) {
    (void)parent;
    return 41;
}

// --- algo.RnullStr41.ch.N
inline int algo::ch_N(const algo::RnullStr41& parent) {
    u64 ret;
    ret = 41;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr41.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr41::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr41.ch.CtorStrptr
inline  algo::RnullStr41::RnullStr41(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr41.ch.Cast
inline  algo::RnullStr41::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr41..EqOp
inline bool algo::RnullStr41::operator ==(const algo::RnullStr41 &rhs) const {
    return algo::RnullStr41_Eq(const_cast<algo::RnullStr41&>(*this),const_cast<algo::RnullStr41&>(rhs));
}

// --- algo.RnullStr41..NeOp
inline bool algo::RnullStr41::operator !=(const algo::RnullStr41 &rhs) const {
    return !algo::RnullStr41_Eq(const_cast<algo::RnullStr41&>(*this),const_cast<algo::RnullStr41&>(rhs));
}

// --- algo.RnullStr41..LtOp
inline bool algo::RnullStr41::operator <(const algo::RnullStr41 &rhs) const {
    return algo::RnullStr41_Lt(const_cast<algo::RnullStr41&>(*this),const_cast<algo::RnullStr41&>(rhs));
}

// --- algo.RnullStr41..GtOp
inline bool algo::RnullStr41::operator >(const algo::RnullStr41 &rhs) const {
    return algo::RnullStr41_Lt(const_cast<algo::RnullStr41&>(rhs),const_cast<algo::RnullStr41&>(*this));
}

// --- algo.RnullStr41..LeOp
inline bool algo::RnullStr41::operator <=(const algo::RnullStr41 &rhs) const {
    return !algo::RnullStr41_Lt(const_cast<algo::RnullStr41&>(rhs),const_cast<algo::RnullStr41&>(*this));
}

// --- algo.RnullStr41..GeOp
inline bool algo::RnullStr41::operator >=(const algo::RnullStr41 &rhs) const {
    return !algo::RnullStr41_Lt(const_cast<algo::RnullStr41&>(*this),const_cast<algo::RnullStr41&>(rhs));
}

// --- algo.RnullStr41..Lt
inline bool algo::RnullStr41_Lt(algo::RnullStr41& lhs, algo::RnullStr41& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr41..Cmp
inline i32 algo::RnullStr41_Cmp(algo::RnullStr41& lhs, algo::RnullStr41& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr41..Init
// Set all fields to initial values.
inline void algo::RnullStr41_Init(algo::RnullStr41& parent) {
    memset(parent.ch, 0, 41);
}

// --- algo.RnullStr41..Eq
inline bool algo::RnullStr41_Eq(algo::RnullStr41& lhs, algo::RnullStr41& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u8*)(lhs.ch+40) == *(u8*)(rhs.ch+40);
    return retval;
}

// --- algo.RnullStr41..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr41_Update(algo::RnullStr41 &lhs, algo::RnullStr41& rhs) {
    bool ret = !RnullStr41_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr41..EqOpAryptr
inline bool algo::RnullStr41::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr41..AssignOp
inline algo::RnullStr41& algo::RnullStr41::operator =(const algo::RnullStr41 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr41));
    return *this;
}

// --- algo.RnullStr41..Ctor
inline  algo::RnullStr41::RnullStr41() {
    algo::RnullStr41_Init(*this);
}

// --- algo.RnullStr41..CopyCtor
inline  algo::RnullStr41::RnullStr41(const algo::RnullStr41 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr41));
}

// --- algo.RnullStr43.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr43& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr43.ch.HashStrptr
inline u32 algo::RnullStr43_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr43.ch.Init
inline void algo::ch_Init(algo::RnullStr43 &parent) {
    memset(parent.ch, 0, 43);
}

// --- algo.RnullStr43.ch.Max
// always return constant 43
inline int algo::ch_Max(algo::RnullStr43& parent) {
    (void)parent;
    return 43;
}

// --- algo.RnullStr43.ch.N
inline int algo::ch_N(const algo::RnullStr43& parent) {
    u64 ret;
    ret = 43;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr43.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr43::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr43.ch.CtorStrptr
inline  algo::RnullStr43::RnullStr43(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr43.ch.Cast
inline  algo::RnullStr43::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr43..Lt
inline bool algo::RnullStr43_Lt(algo::RnullStr43& lhs, algo::RnullStr43& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr43..Cmp
inline i32 algo::RnullStr43_Cmp(algo::RnullStr43& lhs, algo::RnullStr43& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr43..Init
// Set all fields to initial values.
inline void algo::RnullStr43_Init(algo::RnullStr43& parent) {
    memset(parent.ch, 0, 43);
}

// --- algo.RnullStr43..Eq
inline bool algo::RnullStr43_Eq(algo::RnullStr43& lhs, algo::RnullStr43& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u16*)(lhs.ch+40) == *(u16*)(rhs.ch+40)
    &&*(u8*)(lhs.ch+42) == *(u8*)(rhs.ch+42);
    return retval;
}

// --- algo.RnullStr43..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr43_Update(algo::RnullStr43 &lhs, algo::RnullStr43& rhs) {
    bool ret = !RnullStr43_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr43..EqOpAryptr
inline bool algo::RnullStr43::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr43..AssignOp
inline algo::RnullStr43& algo::RnullStr43::operator =(const algo::RnullStr43 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr43));
    return *this;
}

// --- algo.RnullStr43..Ctor
inline  algo::RnullStr43::RnullStr43() {
    algo::RnullStr43_Init(*this);
}

// --- algo.RnullStr43..CopyCtor
inline  algo::RnullStr43::RnullStr43(const algo::RnullStr43 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr43));
}

// --- algo.RnullStr44.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr44& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr44.ch.HashStrptr
inline u32 algo::RnullStr44_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr44.ch.Init
inline void algo::ch_Init(algo::RnullStr44 &parent) {
    memset(parent.ch, 0, 44);
}

// --- algo.RnullStr44.ch.Max
// always return constant 44
inline int algo::ch_Max(algo::RnullStr44& parent) {
    (void)parent;
    return 44;
}

// --- algo.RnullStr44.ch.N
inline int algo::ch_N(const algo::RnullStr44& parent) {
    u64 ret;
    ret = 44;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr44.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr44::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr44.ch.CtorStrptr
inline  algo::RnullStr44::RnullStr44(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr44.ch.Cast
inline  algo::RnullStr44::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr44..Lt
inline bool algo::RnullStr44_Lt(algo::RnullStr44& lhs, algo::RnullStr44& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr44..Cmp
inline i32 algo::RnullStr44_Cmp(algo::RnullStr44& lhs, algo::RnullStr44& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr44..Init
// Set all fields to initial values.
inline void algo::RnullStr44_Init(algo::RnullStr44& parent) {
    memset(parent.ch, 0, 44);
}

// --- algo.RnullStr44..Eq
inline bool algo::RnullStr44_Eq(algo::RnullStr44& lhs, algo::RnullStr44& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u32*)(lhs.ch+40) == *(u32*)(rhs.ch+40);
    return retval;
}

// --- algo.RnullStr44..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr44_Update(algo::RnullStr44 &lhs, algo::RnullStr44& rhs) {
    bool ret = !RnullStr44_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr44..EqOpAryptr
inline bool algo::RnullStr44::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr44..AssignOp
inline algo::RnullStr44& algo::RnullStr44::operator =(const algo::RnullStr44 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr44));
    return *this;
}

// --- algo.RnullStr44..Ctor
inline  algo::RnullStr44::RnullStr44() {
    algo::RnullStr44_Init(*this);
}

// --- algo.RnullStr44..CopyCtor
inline  algo::RnullStr44::RnullStr44(const algo::RnullStr44 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr44));
}

// --- algo.RnullStr48.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr48& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr48.ch.HashStrptr
inline u32 algo::RnullStr48_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr48.ch.Init
inline void algo::ch_Init(algo::RnullStr48 &parent) {
    memset(parent.ch, 0, 48);
}

// --- algo.RnullStr48.ch.Max
// always return constant 48
inline int algo::ch_Max(algo::RnullStr48& parent) {
    (void)parent;
    return 48;
}

// --- algo.RnullStr48.ch.N
inline int algo::ch_N(const algo::RnullStr48& parent) {
    u64 ret;
    ret = 48;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr48.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr48::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr48.ch.CtorStrptr
inline  algo::RnullStr48::RnullStr48(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr48.ch.Cast
inline  algo::RnullStr48::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr48..Lt
inline bool algo::RnullStr48_Lt(algo::RnullStr48& lhs, algo::RnullStr48& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr48..Cmp
inline i32 algo::RnullStr48_Cmp(algo::RnullStr48& lhs, algo::RnullStr48& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr48..Init
// Set all fields to initial values.
inline void algo::RnullStr48_Init(algo::RnullStr48& parent) {
    memset(parent.ch, 0, 48);
}

// --- algo.RnullStr48..Eq
inline bool algo::RnullStr48_Eq(algo::RnullStr48& lhs, algo::RnullStr48& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40);
    return retval;
}

// --- algo.RnullStr48..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr48_Update(algo::RnullStr48 &lhs, algo::RnullStr48& rhs) {
    bool ret = !RnullStr48_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr48..EqOpAryptr
inline bool algo::RnullStr48::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr48..AssignOp
inline algo::RnullStr48& algo::RnullStr48::operator =(const algo::RnullStr48 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr48));
    return *this;
}

// --- algo.RnullStr48..Ctor
inline  algo::RnullStr48::RnullStr48() {
    algo::RnullStr48_Init(*this);
}

// --- algo.RnullStr48..CopyCtor
inline  algo::RnullStr48::RnullStr48(const algo::RnullStr48 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr48));
}

// --- algo.RnullStr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr5.ch.HashStrptr
inline u32 algo::RnullStr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr5.ch.Init
inline void algo::ch_Init(algo::RnullStr5 &parent) {
    memset(parent.ch, 0, 5);
}

// --- algo.RnullStr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::RnullStr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.RnullStr5.ch.N
inline int algo::ch_N(const algo::RnullStr5& parent) {
    u64 ret;
    ret = 5;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr5.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr5::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr5.ch.CtorStrptr
inline  algo::RnullStr5::RnullStr5(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr5.ch.Cast
inline  algo::RnullStr5::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr5..Lt
inline bool algo::RnullStr5_Lt(algo::RnullStr5 lhs, algo::RnullStr5 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr5..Cmp
inline i32 algo::RnullStr5_Cmp(algo::RnullStr5 lhs, algo::RnullStr5 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr5..Init
// Set all fields to initial values.
inline void algo::RnullStr5_Init(algo::RnullStr5& parent) {
    memset(parent.ch, 0, 5);
}

// --- algo.RnullStr5..Eq
inline bool algo::RnullStr5_Eq(algo::RnullStr5 lhs, algo::RnullStr5 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+4) == *(u8*)(rhs.ch+4);
    return retval;
}

// --- algo.RnullStr5..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr5_Update(algo::RnullStr5 &lhs, algo::RnullStr5 rhs) {
    bool ret = !RnullStr5_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr5..EqOpAryptr
inline bool algo::RnullStr5::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr5..AssignOp
inline algo::RnullStr5& algo::RnullStr5::operator =(const algo::RnullStr5 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr5));
    return *this;
}

// --- algo.RnullStr5..Ctor
inline  algo::RnullStr5::RnullStr5() {
    algo::RnullStr5_Init(*this);
}

// --- algo.RnullStr5..CopyCtor
inline  algo::RnullStr5::RnullStr5(const algo::RnullStr5 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr5));
}

// --- algo.RnullStr50.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr50& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr50.ch.HashStrptr
inline u32 algo::RnullStr50_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr50.ch.Init
inline void algo::ch_Init(algo::RnullStr50 &parent) {
    memset(parent.ch, 0, 50);
}

// --- algo.RnullStr50.ch.Max
// always return constant 50
inline int algo::ch_Max(algo::RnullStr50& parent) {
    (void)parent;
    return 50;
}

// --- algo.RnullStr50.ch.N
inline int algo::ch_N(const algo::RnullStr50& parent) {
    u64 ret;
    ret = 50;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr50.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr50::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr50.ch.CtorStrptr
inline  algo::RnullStr50::RnullStr50(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr50.ch.Cast
inline  algo::RnullStr50::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr50..Lt
inline bool algo::RnullStr50_Lt(algo::RnullStr50& lhs, algo::RnullStr50& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr50..Cmp
inline i32 algo::RnullStr50_Cmp(algo::RnullStr50& lhs, algo::RnullStr50& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr50..Init
// Set all fields to initial values.
inline void algo::RnullStr50_Init(algo::RnullStr50& parent) {
    memset(parent.ch, 0, 50);
}

// --- algo.RnullStr50..Eq
inline bool algo::RnullStr50_Eq(algo::RnullStr50& lhs, algo::RnullStr50& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u16*)(lhs.ch+48) == *(u16*)(rhs.ch+48);
    return retval;
}

// --- algo.RnullStr50..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr50_Update(algo::RnullStr50 &lhs, algo::RnullStr50& rhs) {
    bool ret = !RnullStr50_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr50..EqOpAryptr
inline bool algo::RnullStr50::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr50..AssignOp
inline algo::RnullStr50& algo::RnullStr50::operator =(const algo::RnullStr50 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr50));
    return *this;
}

// --- algo.RnullStr50..Ctor
inline  algo::RnullStr50::RnullStr50() {
    algo::RnullStr50_Init(*this);
}

// --- algo.RnullStr50..CopyCtor
inline  algo::RnullStr50::RnullStr50(const algo::RnullStr50 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr50));
}

// --- algo.RnullStr54.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr54& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr54.ch.HashStrptr
inline u32 algo::RnullStr54_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr54.ch.Init
inline void algo::ch_Init(algo::RnullStr54 &parent) {
    memset(parent.ch, 0, 54);
}

// --- algo.RnullStr54.ch.Max
// always return constant 54
inline int algo::ch_Max(algo::RnullStr54& parent) {
    (void)parent;
    return 54;
}

// --- algo.RnullStr54.ch.N
inline int algo::ch_N(const algo::RnullStr54& parent) {
    u64 ret;
    ret = 54;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr54.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr54::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr54.ch.CtorStrptr
inline  algo::RnullStr54::RnullStr54(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr54.ch.Cast
inline  algo::RnullStr54::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr54..EqOp
inline bool algo::RnullStr54::operator ==(const algo::RnullStr54 &rhs) const {
    return algo::RnullStr54_Eq(const_cast<algo::RnullStr54&>(*this),const_cast<algo::RnullStr54&>(rhs));
}

// --- algo.RnullStr54..NeOp
inline bool algo::RnullStr54::operator !=(const algo::RnullStr54 &rhs) const {
    return !algo::RnullStr54_Eq(const_cast<algo::RnullStr54&>(*this),const_cast<algo::RnullStr54&>(rhs));
}

// --- algo.RnullStr54..LtOp
inline bool algo::RnullStr54::operator <(const algo::RnullStr54 &rhs) const {
    return algo::RnullStr54_Lt(const_cast<algo::RnullStr54&>(*this),const_cast<algo::RnullStr54&>(rhs));
}

// --- algo.RnullStr54..GtOp
inline bool algo::RnullStr54::operator >(const algo::RnullStr54 &rhs) const {
    return algo::RnullStr54_Lt(const_cast<algo::RnullStr54&>(rhs),const_cast<algo::RnullStr54&>(*this));
}

// --- algo.RnullStr54..LeOp
inline bool algo::RnullStr54::operator <=(const algo::RnullStr54 &rhs) const {
    return !algo::RnullStr54_Lt(const_cast<algo::RnullStr54&>(rhs),const_cast<algo::RnullStr54&>(*this));
}

// --- algo.RnullStr54..GeOp
inline bool algo::RnullStr54::operator >=(const algo::RnullStr54 &rhs) const {
    return !algo::RnullStr54_Lt(const_cast<algo::RnullStr54&>(*this),const_cast<algo::RnullStr54&>(rhs));
}

// --- algo.RnullStr54..Lt
inline bool algo::RnullStr54_Lt(algo::RnullStr54& lhs, algo::RnullStr54& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr54..Cmp
inline i32 algo::RnullStr54_Cmp(algo::RnullStr54& lhs, algo::RnullStr54& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr54..Init
// Set all fields to initial values.
inline void algo::RnullStr54_Init(algo::RnullStr54& parent) {
    memset(parent.ch, 0, 54);
}

// --- algo.RnullStr54..Eq
inline bool algo::RnullStr54_Eq(algo::RnullStr54& lhs, algo::RnullStr54& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u32*)(lhs.ch+48) == *(u32*)(rhs.ch+48)
    &&*(u16*)(lhs.ch+52) == *(u16*)(rhs.ch+52);
    return retval;
}

// --- algo.RnullStr54..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr54_Update(algo::RnullStr54 &lhs, algo::RnullStr54& rhs) {
    bool ret = !RnullStr54_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr54..EqOpAryptr
inline bool algo::RnullStr54::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr54..AssignOp
inline algo::RnullStr54& algo::RnullStr54::operator =(const algo::RnullStr54 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr54));
    return *this;
}

// --- algo.RnullStr54..Ctor
inline  algo::RnullStr54::RnullStr54() {
    algo::RnullStr54_Init(*this);
}

// --- algo.RnullStr54..CopyCtor
inline  algo::RnullStr54::RnullStr54(const algo::RnullStr54 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr54));
}

// --- algo.RnullStr55.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr55& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr55.ch.HashStrptr
inline u32 algo::RnullStr55_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr55.ch.Init
inline void algo::ch_Init(algo::RnullStr55 &parent) {
    memset(parent.ch, 0, 55);
}

// --- algo.RnullStr55.ch.Max
// always return constant 55
inline int algo::ch_Max(algo::RnullStr55& parent) {
    (void)parent;
    return 55;
}

// --- algo.RnullStr55.ch.N
inline int algo::ch_N(const algo::RnullStr55& parent) {
    u64 ret;
    ret = 55;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr55.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr55::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr55.ch.CtorStrptr
inline  algo::RnullStr55::RnullStr55(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr55.ch.Cast
inline  algo::RnullStr55::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr55..Lt
inline bool algo::RnullStr55_Lt(algo::RnullStr55& lhs, algo::RnullStr55& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr55..Cmp
inline i32 algo::RnullStr55_Cmp(algo::RnullStr55& lhs, algo::RnullStr55& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr55..Init
// Set all fields to initial values.
inline void algo::RnullStr55_Init(algo::RnullStr55& parent) {
    memset(parent.ch, 0, 55);
}

// --- algo.RnullStr55..Eq
inline bool algo::RnullStr55_Eq(algo::RnullStr55& lhs, algo::RnullStr55& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u32*)(lhs.ch+48) == *(u32*)(rhs.ch+48)
    &&*(u16*)(lhs.ch+52) == *(u16*)(rhs.ch+52)
    &&*(u8*)(lhs.ch+54) == *(u8*)(rhs.ch+54);
    return retval;
}

// --- algo.RnullStr55..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr55_Update(algo::RnullStr55 &lhs, algo::RnullStr55& rhs) {
    bool ret = !RnullStr55_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr55..EqOpAryptr
inline bool algo::RnullStr55::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr55..AssignOp
inline algo::RnullStr55& algo::RnullStr55::operator =(const algo::RnullStr55 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr55));
    return *this;
}

// --- algo.RnullStr55..Ctor
inline  algo::RnullStr55::RnullStr55() {
    algo::RnullStr55_Init(*this);
}

// --- algo.RnullStr55..CopyCtor
inline  algo::RnullStr55::RnullStr55(const algo::RnullStr55 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr55));
}

// --- algo.RnullStr6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr6.ch.HashStrptr
inline u32 algo::RnullStr6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr6.ch.Init
inline void algo::ch_Init(algo::RnullStr6 &parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::RnullStr6& parent) {
    (void)parent;
    return 6;
}

// --- algo.RnullStr6.ch.N
inline int algo::ch_N(const algo::RnullStr6& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr6.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr6::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr6.ch.CtorStrptr
inline  algo::RnullStr6::RnullStr6(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr6.ch.Cast
inline  algo::RnullStr6::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr6..EqOp
inline bool algo::RnullStr6::operator ==(const algo::RnullStr6 &rhs) const {
    return algo::RnullStr6_Eq(const_cast<algo::RnullStr6&>(*this),const_cast<algo::RnullStr6&>(rhs));
}

// --- algo.RnullStr6..NeOp
inline bool algo::RnullStr6::operator !=(const algo::RnullStr6 &rhs) const {
    return !algo::RnullStr6_Eq(const_cast<algo::RnullStr6&>(*this),const_cast<algo::RnullStr6&>(rhs));
}

// --- algo.RnullStr6..LtOp
inline bool algo::RnullStr6::operator <(const algo::RnullStr6 &rhs) const {
    return algo::RnullStr6_Lt(const_cast<algo::RnullStr6&>(*this),const_cast<algo::RnullStr6&>(rhs));
}

// --- algo.RnullStr6..GtOp
inline bool algo::RnullStr6::operator >(const algo::RnullStr6 &rhs) const {
    return algo::RnullStr6_Lt(const_cast<algo::RnullStr6&>(rhs),const_cast<algo::RnullStr6&>(*this));
}

// --- algo.RnullStr6..LeOp
inline bool algo::RnullStr6::operator <=(const algo::RnullStr6 &rhs) const {
    return !algo::RnullStr6_Lt(const_cast<algo::RnullStr6&>(rhs),const_cast<algo::RnullStr6&>(*this));
}

// --- algo.RnullStr6..GeOp
inline bool algo::RnullStr6::operator >=(const algo::RnullStr6 &rhs) const {
    return !algo::RnullStr6_Lt(const_cast<algo::RnullStr6&>(*this),const_cast<algo::RnullStr6&>(rhs));
}

// --- algo.RnullStr6..Lt
inline bool algo::RnullStr6_Lt(algo::RnullStr6 lhs, algo::RnullStr6 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr6..Cmp
inline i32 algo::RnullStr6_Cmp(algo::RnullStr6 lhs, algo::RnullStr6 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr6..Init
// Set all fields to initial values.
inline void algo::RnullStr6_Init(algo::RnullStr6& parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6..Eq
inline bool algo::RnullStr6_Eq(algo::RnullStr6 lhs, algo::RnullStr6 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4);
    return retval;
}

// --- algo.RnullStr6..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr6_Update(algo::RnullStr6 &lhs, algo::RnullStr6 rhs) {
    bool ret = !RnullStr6_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr6..EqOpAryptr
inline bool algo::RnullStr6::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr6..AssignOp
inline algo::RnullStr6& algo::RnullStr6::operator =(const algo::RnullStr6 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr6));
    return *this;
}

// --- algo.RnullStr6..Ctor
inline  algo::RnullStr6::RnullStr6() {
    algo::RnullStr6_Init(*this);
}

// --- algo.RnullStr6..CopyCtor
inline  algo::RnullStr6::RnullStr6(const algo::RnullStr6 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr6));
}

// --- algo.RnullStr60.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr60& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr60.ch.HashStrptr
inline u32 algo::RnullStr60_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr60.ch.Init
inline void algo::ch_Init(algo::RnullStr60 &parent) {
    memset(parent.ch, 0, 60);
}

// --- algo.RnullStr60.ch.Max
// always return constant 60
inline int algo::ch_Max(algo::RnullStr60& parent) {
    (void)parent;
    return 60;
}

// --- algo.RnullStr60.ch.N
inline int algo::ch_N(const algo::RnullStr60& parent) {
    u64 ret;
    ret = 60;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr60.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr60::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr60.ch.CtorStrptr
inline  algo::RnullStr60::RnullStr60(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr60.ch.Cast
inline  algo::RnullStr60::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr60..EqOp
inline bool algo::RnullStr60::operator ==(const algo::RnullStr60 &rhs) const {
    return algo::RnullStr60_Eq(const_cast<algo::RnullStr60&>(*this),const_cast<algo::RnullStr60&>(rhs));
}

// --- algo.RnullStr60..NeOp
inline bool algo::RnullStr60::operator !=(const algo::RnullStr60 &rhs) const {
    return !algo::RnullStr60_Eq(const_cast<algo::RnullStr60&>(*this),const_cast<algo::RnullStr60&>(rhs));
}

// --- algo.RnullStr60..LtOp
inline bool algo::RnullStr60::operator <(const algo::RnullStr60 &rhs) const {
    return algo::RnullStr60_Lt(const_cast<algo::RnullStr60&>(*this),const_cast<algo::RnullStr60&>(rhs));
}

// --- algo.RnullStr60..GtOp
inline bool algo::RnullStr60::operator >(const algo::RnullStr60 &rhs) const {
    return algo::RnullStr60_Lt(const_cast<algo::RnullStr60&>(rhs),const_cast<algo::RnullStr60&>(*this));
}

// --- algo.RnullStr60..LeOp
inline bool algo::RnullStr60::operator <=(const algo::RnullStr60 &rhs) const {
    return !algo::RnullStr60_Lt(const_cast<algo::RnullStr60&>(rhs),const_cast<algo::RnullStr60&>(*this));
}

// --- algo.RnullStr60..GeOp
inline bool algo::RnullStr60::operator >=(const algo::RnullStr60 &rhs) const {
    return !algo::RnullStr60_Lt(const_cast<algo::RnullStr60&>(*this),const_cast<algo::RnullStr60&>(rhs));
}

// --- algo.RnullStr60..Lt
inline bool algo::RnullStr60_Lt(algo::RnullStr60& lhs, algo::RnullStr60& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr60..Cmp
inline i32 algo::RnullStr60_Cmp(algo::RnullStr60& lhs, algo::RnullStr60& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr60..Init
// Set all fields to initial values.
inline void algo::RnullStr60_Init(algo::RnullStr60& parent) {
    memset(parent.ch, 0, 60);
}

// --- algo.RnullStr60..Eq
inline bool algo::RnullStr60_Eq(algo::RnullStr60& lhs, algo::RnullStr60& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u32*)(lhs.ch+56) == *(u32*)(rhs.ch+56);
    return retval;
}

// --- algo.RnullStr60..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr60_Update(algo::RnullStr60 &lhs, algo::RnullStr60& rhs) {
    bool ret = !RnullStr60_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr60..EqOpAryptr
inline bool algo::RnullStr60::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr60..AssignOp
inline algo::RnullStr60& algo::RnullStr60::operator =(const algo::RnullStr60 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr60));
    return *this;
}

// --- algo.RnullStr60..Ctor
inline  algo::RnullStr60::RnullStr60() {
    algo::RnullStr60_Init(*this);
}

// --- algo.RnullStr60..CopyCtor
inline  algo::RnullStr60::RnullStr60(const algo::RnullStr60 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr60));
}

// --- algo.RnullStr62.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr62& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr62.ch.HashStrptr
inline u32 algo::RnullStr62_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr62.ch.Init
inline void algo::ch_Init(algo::RnullStr62 &parent) {
    memset(parent.ch, 0, 62);
}

// --- algo.RnullStr62.ch.Max
// always return constant 62
inline int algo::ch_Max(algo::RnullStr62& parent) {
    (void)parent;
    return 62;
}

// --- algo.RnullStr62.ch.N
inline int algo::ch_N(const algo::RnullStr62& parent) {
    u64 ret;
    ret = 62;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr62.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr62::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr62.ch.CtorStrptr
inline  algo::RnullStr62::RnullStr62(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr62.ch.Cast
inline  algo::RnullStr62::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr62..EqOp
inline bool algo::RnullStr62::operator ==(const algo::RnullStr62 &rhs) const {
    return algo::RnullStr62_Eq(const_cast<algo::RnullStr62&>(*this),const_cast<algo::RnullStr62&>(rhs));
}

// --- algo.RnullStr62..NeOp
inline bool algo::RnullStr62::operator !=(const algo::RnullStr62 &rhs) const {
    return !algo::RnullStr62_Eq(const_cast<algo::RnullStr62&>(*this),const_cast<algo::RnullStr62&>(rhs));
}

// --- algo.RnullStr62..LtOp
inline bool algo::RnullStr62::operator <(const algo::RnullStr62 &rhs) const {
    return algo::RnullStr62_Lt(const_cast<algo::RnullStr62&>(*this),const_cast<algo::RnullStr62&>(rhs));
}

// --- algo.RnullStr62..GtOp
inline bool algo::RnullStr62::operator >(const algo::RnullStr62 &rhs) const {
    return algo::RnullStr62_Lt(const_cast<algo::RnullStr62&>(rhs),const_cast<algo::RnullStr62&>(*this));
}

// --- algo.RnullStr62..LeOp
inline bool algo::RnullStr62::operator <=(const algo::RnullStr62 &rhs) const {
    return !algo::RnullStr62_Lt(const_cast<algo::RnullStr62&>(rhs),const_cast<algo::RnullStr62&>(*this));
}

// --- algo.RnullStr62..GeOp
inline bool algo::RnullStr62::operator >=(const algo::RnullStr62 &rhs) const {
    return !algo::RnullStr62_Lt(const_cast<algo::RnullStr62&>(*this),const_cast<algo::RnullStr62&>(rhs));
}

// --- algo.RnullStr62..Lt
inline bool algo::RnullStr62_Lt(algo::RnullStr62& lhs, algo::RnullStr62& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr62..Cmp
inline i32 algo::RnullStr62_Cmp(algo::RnullStr62& lhs, algo::RnullStr62& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr62..Init
// Set all fields to initial values.
inline void algo::RnullStr62_Init(algo::RnullStr62& parent) {
    memset(parent.ch, 0, 62);
}

// --- algo.RnullStr62..Eq
inline bool algo::RnullStr62_Eq(algo::RnullStr62& lhs, algo::RnullStr62& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u32*)(lhs.ch+56) == *(u32*)(rhs.ch+56)
    &&*(u16*)(lhs.ch+60) == *(u16*)(rhs.ch+60);
    return retval;
}

// --- algo.RnullStr62..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr62_Update(algo::RnullStr62 &lhs, algo::RnullStr62& rhs) {
    bool ret = !RnullStr62_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr62..EqOpAryptr
inline bool algo::RnullStr62::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr62..AssignOp
inline algo::RnullStr62& algo::RnullStr62::operator =(const algo::RnullStr62 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr62));
    return *this;
}

// --- algo.RnullStr62..Ctor
inline  algo::RnullStr62::RnullStr62() {
    algo::RnullStr62_Init(*this);
}

// --- algo.RnullStr62..CopyCtor
inline  algo::RnullStr62::RnullStr62(const algo::RnullStr62 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr62));
}

// --- algo.RnullStr66.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr66& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr66.ch.HashStrptr
inline u32 algo::RnullStr66_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr66.ch.Init
inline void algo::ch_Init(algo::RnullStr66 &parent) {
    memset(parent.ch, 0, 66);
}

// --- algo.RnullStr66.ch.Max
// always return constant 66
inline int algo::ch_Max(algo::RnullStr66& parent) {
    (void)parent;
    return 66;
}

// --- algo.RnullStr66.ch.N
inline int algo::ch_N(const algo::RnullStr66& parent) {
    u64 ret;
    ret = 66;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr66.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr66::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr66.ch.CtorStrptr
inline  algo::RnullStr66::RnullStr66(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr66.ch.Cast
inline  algo::RnullStr66::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr66..Lt
inline bool algo::RnullStr66_Lt(algo::RnullStr66& lhs, algo::RnullStr66& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr66..Cmp
inline i32 algo::RnullStr66_Cmp(algo::RnullStr66& lhs, algo::RnullStr66& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr66..Init
// Set all fields to initial values.
inline void algo::RnullStr66_Init(algo::RnullStr66& parent) {
    memset(parent.ch, 0, 66);
}

// --- algo.RnullStr66..Eq
inline bool algo::RnullStr66_Eq(algo::RnullStr66& lhs, algo::RnullStr66& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56)
    &&*(u16*)(lhs.ch+64) == *(u16*)(rhs.ch+64);
    return retval;
}

// --- algo.RnullStr66..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr66_Update(algo::RnullStr66 &lhs, algo::RnullStr66& rhs) {
    bool ret = !RnullStr66_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr66..EqOpAryptr
inline bool algo::RnullStr66::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr66..AssignOp
inline algo::RnullStr66& algo::RnullStr66::operator =(const algo::RnullStr66 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr66));
    return *this;
}

// --- algo.RnullStr66..Ctor
inline  algo::RnullStr66::RnullStr66() {
    algo::RnullStr66_Init(*this);
}

// --- algo.RnullStr66..CopyCtor
inline  algo::RnullStr66::RnullStr66(const algo::RnullStr66 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr66));
}

// --- algo.RnullStr6_U32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr6_U32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr6_U32.ch.HashStrptr
inline u32 algo::RnullStr6_U32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr6_U32.ch.Init
inline void algo::ch_Init(algo::RnullStr6_U32 &parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6_U32.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::RnullStr6_U32& parent) {
    (void)parent;
    return 6;
}

// --- algo.RnullStr6_U32.ch.N
inline int algo::ch_N(const algo::RnullStr6_U32& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr6_U32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr6_U32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr6_U32.ch.CtorStrptr
inline  algo::RnullStr6_U32::RnullStr6_U32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr6_U32.ch.Cast
inline  algo::RnullStr6_U32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr6_U32..EqOp
inline bool algo::RnullStr6_U32::operator ==(const algo::RnullStr6_U32 &rhs) const {
    return algo::RnullStr6_U32_Eq(const_cast<algo::RnullStr6_U32&>(*this),const_cast<algo::RnullStr6_U32&>(rhs));
}

// --- algo.RnullStr6_U32..NeOp
inline bool algo::RnullStr6_U32::operator !=(const algo::RnullStr6_U32 &rhs) const {
    return !algo::RnullStr6_U32_Eq(const_cast<algo::RnullStr6_U32&>(*this),const_cast<algo::RnullStr6_U32&>(rhs));
}

// --- algo.RnullStr6_U32..Cmp
inline i32 algo::RnullStr6_U32_Cmp(algo::RnullStr6_U32& lhs, algo::RnullStr6_U32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr6_U32..Init
// Set all fields to initial values.
inline void algo::RnullStr6_U32_Init(algo::RnullStr6_U32& parent) {
    memset(parent.ch, 0, 6);
}

// --- algo.RnullStr6_U32..Eq
inline bool algo::RnullStr6_U32_Eq(algo::RnullStr6_U32& lhs, algo::RnullStr6_U32& rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4);
    return retval;
}

// --- algo.RnullStr6_U32..EqOpAryptr
inline bool algo::RnullStr6_U32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr6_U32..AssignOp
inline algo::RnullStr6_U32& algo::RnullStr6_U32::operator =(const algo::RnullStr6_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr6_U32));
    return *this;
}

// --- algo.RnullStr6_U32..Ctor
inline  algo::RnullStr6_U32::RnullStr6_U32() {
    algo::RnullStr6_U32_Init(*this);
}

// --- algo.RnullStr6_U32..CopyCtor
inline  algo::RnullStr6_U32::RnullStr6_U32(const algo::RnullStr6_U32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr6_U32));
}

// --- algo.RnullStr7.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr7& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr7.ch.HashStrptr
inline u32 algo::RnullStr7_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr7.ch.Init
inline void algo::ch_Init(algo::RnullStr7 &parent) {
    memset(parent.ch, 0, 7);
}

// --- algo.RnullStr7.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::RnullStr7& parent) {
    (void)parent;
    return 7;
}

// --- algo.RnullStr7.ch.N
inline int algo::ch_N(const algo::RnullStr7& parent) {
    u64 ret;
    ret = 7;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr7.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr7::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr7.ch.CtorStrptr
inline  algo::RnullStr7::RnullStr7(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr7.ch.Cast
inline  algo::RnullStr7::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr7..EqOp
inline bool algo::RnullStr7::operator ==(const algo::RnullStr7 &rhs) const {
    return algo::RnullStr7_Eq(const_cast<algo::RnullStr7&>(*this),const_cast<algo::RnullStr7&>(rhs));
}

// --- algo.RnullStr7..NeOp
inline bool algo::RnullStr7::operator !=(const algo::RnullStr7 &rhs) const {
    return !algo::RnullStr7_Eq(const_cast<algo::RnullStr7&>(*this),const_cast<algo::RnullStr7&>(rhs));
}

// --- algo.RnullStr7..LtOp
inline bool algo::RnullStr7::operator <(const algo::RnullStr7 &rhs) const {
    return algo::RnullStr7_Lt(const_cast<algo::RnullStr7&>(*this),const_cast<algo::RnullStr7&>(rhs));
}

// --- algo.RnullStr7..GtOp
inline bool algo::RnullStr7::operator >(const algo::RnullStr7 &rhs) const {
    return algo::RnullStr7_Lt(const_cast<algo::RnullStr7&>(rhs),const_cast<algo::RnullStr7&>(*this));
}

// --- algo.RnullStr7..LeOp
inline bool algo::RnullStr7::operator <=(const algo::RnullStr7 &rhs) const {
    return !algo::RnullStr7_Lt(const_cast<algo::RnullStr7&>(rhs),const_cast<algo::RnullStr7&>(*this));
}

// --- algo.RnullStr7..GeOp
inline bool algo::RnullStr7::operator >=(const algo::RnullStr7 &rhs) const {
    return !algo::RnullStr7_Lt(const_cast<algo::RnullStr7&>(*this),const_cast<algo::RnullStr7&>(rhs));
}

// --- algo.RnullStr7..Lt
inline bool algo::RnullStr7_Lt(algo::RnullStr7 lhs, algo::RnullStr7 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr7..Cmp
inline i32 algo::RnullStr7_Cmp(algo::RnullStr7 lhs, algo::RnullStr7 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr7..Init
// Set all fields to initial values.
inline void algo::RnullStr7_Init(algo::RnullStr7& parent) {
    memset(parent.ch, 0, 7);
}

// --- algo.RnullStr7..Eq
inline bool algo::RnullStr7_Eq(algo::RnullStr7 lhs, algo::RnullStr7 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4)
    &&*(u8*)(lhs.ch+6) == *(u8*)(rhs.ch+6);
    return retval;
}

// --- algo.RnullStr7..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr7_Update(algo::RnullStr7 &lhs, algo::RnullStr7 rhs) {
    bool ret = !RnullStr7_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr7..EqOpAryptr
inline bool algo::RnullStr7::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr7..AssignOp
inline algo::RnullStr7& algo::RnullStr7::operator =(const algo::RnullStr7 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr7));
    return *this;
}

// --- algo.RnullStr7..Ctor
inline  algo::RnullStr7::RnullStr7() {
    algo::RnullStr7_Init(*this);
}

// --- algo.RnullStr7..CopyCtor
inline  algo::RnullStr7::RnullStr7(const algo::RnullStr7 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr7));
}

// --- algo.RnullStr8.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr8& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr8.ch.HashStrptr
inline u32 algo::RnullStr8_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr8.ch.Init
inline void algo::ch_Init(algo::RnullStr8 &parent) {
    memset(parent.ch, 0, 8);
}

// --- algo.RnullStr8.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::RnullStr8& parent) {
    (void)parent;
    return 8;
}

// --- algo.RnullStr8.ch.N
inline int algo::ch_N(const algo::RnullStr8& parent) {
    u64 ret;
    ret = 8;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr8.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr8::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr8.ch.CtorStrptr
inline  algo::RnullStr8::RnullStr8(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr8.ch.Cast
inline  algo::RnullStr8::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr8..Lt
inline bool algo::RnullStr8_Lt(algo::RnullStr8 lhs, algo::RnullStr8 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr8..Cmp
inline i32 algo::RnullStr8_Cmp(algo::RnullStr8 lhs, algo::RnullStr8 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr8..Init
// Set all fields to initial values.
inline void algo::RnullStr8_Init(algo::RnullStr8& parent) {
    memset(parent.ch, 0, 8);
}

// --- algo.RnullStr8..Eq
inline bool algo::RnullStr8_Eq(algo::RnullStr8 lhs, algo::RnullStr8 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0);
    return retval;
}

// --- algo.RnullStr8..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr8_Update(algo::RnullStr8 &lhs, algo::RnullStr8 rhs) {
    bool ret = !RnullStr8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr8..EqOpAryptr
inline bool algo::RnullStr8::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr8..AssignOp
inline algo::RnullStr8& algo::RnullStr8::operator =(const algo::RnullStr8 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr8));
    return *this;
}

// --- algo.RnullStr8..Ctor
inline  algo::RnullStr8::RnullStr8() {
    algo::RnullStr8_Init(*this);
}

// --- algo.RnullStr8..CopyCtor
inline  algo::RnullStr8::RnullStr8(const algo::RnullStr8 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr8));
}

// --- algo.RnullStr80.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr80& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr80.ch.HashStrptr
inline u32 algo::RnullStr80_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr80.ch.Init
inline void algo::ch_Init(algo::RnullStr80 &parent) {
    memset(parent.ch, 0, 80);
}

// --- algo.RnullStr80.ch.Max
// always return constant 80
inline int algo::ch_Max(algo::RnullStr80& parent) {
    (void)parent;
    return 80;
}

// --- algo.RnullStr80.ch.N
inline int algo::ch_N(const algo::RnullStr80& parent) {
    u64 ret;
    ret = 80;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr80.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr80::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr80.ch.CtorStrptr
inline  algo::RnullStr80::RnullStr80(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr80.ch.Cast
inline  algo::RnullStr80::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr80..Lt
inline bool algo::RnullStr80_Lt(algo::RnullStr80& lhs, algo::RnullStr80& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr80..Cmp
inline i32 algo::RnullStr80_Cmp(algo::RnullStr80& lhs, algo::RnullStr80& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr80..Init
// Set all fields to initial values.
inline void algo::RnullStr80_Init(algo::RnullStr80& parent) {
    memset(parent.ch, 0, 80);
}

// --- algo.RnullStr80..Eq
inline bool algo::RnullStr80_Eq(algo::RnullStr80& lhs, algo::RnullStr80& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56)
    &&*(u64*)(lhs.ch+64) == *(u64*)(rhs.ch+64)
    &&*(u64*)(lhs.ch+72) == *(u64*)(rhs.ch+72);
    return retval;
}

// --- algo.RnullStr80..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr80_Update(algo::RnullStr80 &lhs, algo::RnullStr80& rhs) {
    bool ret = !RnullStr80_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr80..EqOpAryptr
inline bool algo::RnullStr80::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr80..AssignOp
inline algo::RnullStr80& algo::RnullStr80::operator =(const algo::RnullStr80 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr80));
    return *this;
}

// --- algo.RnullStr80..Ctor
inline  algo::RnullStr80::RnullStr80() {
    algo::RnullStr80_Init(*this);
}

// --- algo.RnullStr80..CopyCtor
inline  algo::RnullStr80::RnullStr80(const algo::RnullStr80 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr80));
}

// --- algo.RnullStr9.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RnullStr9& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RnullStr9.ch.HashStrptr
inline u32 algo::RnullStr9_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RnullStr9.ch.Init
inline void algo::ch_Init(algo::RnullStr9 &parent) {
    memset(parent.ch, 0, 9);
}

// --- algo.RnullStr9.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::RnullStr9& parent) {
    (void)parent;
    return 9;
}

// --- algo.RnullStr9.ch.N
inline int algo::ch_N(const algo::RnullStr9& parent) {
    u64 ret;
    ret = 9;
    while (ret>0 && parent.ch[ret-1]==u8(0)) {
        ret--;
    }
    return int(ret);
}

// --- algo.RnullStr9.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RnullStr9::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RnullStr9.ch.CtorStrptr
inline  algo::RnullStr9::RnullStr9(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RnullStr9.ch.Cast
inline  algo::RnullStr9::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RnullStr9..EqOp
inline bool algo::RnullStr9::operator ==(const algo::RnullStr9 &rhs) const {
    return algo::RnullStr9_Eq(const_cast<algo::RnullStr9&>(*this),const_cast<algo::RnullStr9&>(rhs));
}

// --- algo.RnullStr9..NeOp
inline bool algo::RnullStr9::operator !=(const algo::RnullStr9 &rhs) const {
    return !algo::RnullStr9_Eq(const_cast<algo::RnullStr9&>(*this),const_cast<algo::RnullStr9&>(rhs));
}

// --- algo.RnullStr9..LtOp
inline bool algo::RnullStr9::operator <(const algo::RnullStr9 &rhs) const {
    return algo::RnullStr9_Lt(const_cast<algo::RnullStr9&>(*this),const_cast<algo::RnullStr9&>(rhs));
}

// --- algo.RnullStr9..GtOp
inline bool algo::RnullStr9::operator >(const algo::RnullStr9 &rhs) const {
    return algo::RnullStr9_Lt(const_cast<algo::RnullStr9&>(rhs),const_cast<algo::RnullStr9&>(*this));
}

// --- algo.RnullStr9..LeOp
inline bool algo::RnullStr9::operator <=(const algo::RnullStr9 &rhs) const {
    return !algo::RnullStr9_Lt(const_cast<algo::RnullStr9&>(rhs),const_cast<algo::RnullStr9&>(*this));
}

// --- algo.RnullStr9..GeOp
inline bool algo::RnullStr9::operator >=(const algo::RnullStr9 &rhs) const {
    return !algo::RnullStr9_Lt(const_cast<algo::RnullStr9&>(*this),const_cast<algo::RnullStr9&>(rhs));
}

// --- algo.RnullStr9..Lt
inline bool algo::RnullStr9_Lt(algo::RnullStr9& lhs, algo::RnullStr9& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RnullStr9..Cmp
inline i32 algo::RnullStr9_Cmp(algo::RnullStr9& lhs, algo::RnullStr9& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RnullStr9..Init
// Set all fields to initial values.
inline void algo::RnullStr9_Init(algo::RnullStr9& parent) {
    memset(parent.ch, 0, 9);
}

// --- algo.RnullStr9..Eq
inline bool algo::RnullStr9_Eq(algo::RnullStr9& lhs, algo::RnullStr9& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+8) == *(u8*)(rhs.ch+8);
    return retval;
}

// --- algo.RnullStr9..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RnullStr9_Update(algo::RnullStr9 &lhs, algo::RnullStr9& rhs) {
    bool ret = !RnullStr9_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RnullStr9..EqOpAryptr
inline bool algo::RnullStr9::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RnullStr9..AssignOp
inline algo::RnullStr9& algo::RnullStr9::operator =(const algo::RnullStr9 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr9));
    return *this;
}

// --- algo.RnullStr9..Ctor
inline  algo::RnullStr9::RnullStr9() {
    algo::RnullStr9_Init(*this);
}

// --- algo.RnullStr9..CopyCtor
inline  algo::RnullStr9::RnullStr9(const algo::RnullStr9 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RnullStr9));
}

// --- algo.RspaceStr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr10.ch.HashStrptr
inline u32 algo::RspaceStr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr10.ch.Init
inline void algo::ch_Init(algo::RspaceStr10 &parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.RspaceStr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::RspaceStr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.RspaceStr10.ch.N
inline int algo::ch_N(const algo::RspaceStr10& parent) {
    u64 ret;
    ret = 10;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr10.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr10::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr10.ch.CtorStrptr
inline  algo::RspaceStr10::RspaceStr10(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr10.ch.Cast
inline  algo::RspaceStr10::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr10..EqOp
inline bool algo::RspaceStr10::operator ==(const algo::RspaceStr10 &rhs) const {
    return algo::RspaceStr10_Eq(const_cast<algo::RspaceStr10&>(*this),const_cast<algo::RspaceStr10&>(rhs));
}

// --- algo.RspaceStr10..NeOp
inline bool algo::RspaceStr10::operator !=(const algo::RspaceStr10 &rhs) const {
    return !algo::RspaceStr10_Eq(const_cast<algo::RspaceStr10&>(*this),const_cast<algo::RspaceStr10&>(rhs));
}

// --- algo.RspaceStr10..Cmp
inline i32 algo::RspaceStr10_Cmp(algo::RspaceStr10 lhs, algo::RspaceStr10 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr10..Init
// Set all fields to initial values.
inline void algo::RspaceStr10_Init(algo::RspaceStr10& parent) {
    memset(parent.ch, ' ', 10);
}

// --- algo.RspaceStr10..Eq
inline bool algo::RspaceStr10_Eq(algo::RspaceStr10 lhs, algo::RspaceStr10 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8);
    return retval;
}

// --- algo.RspaceStr10..EqOpAryptr
inline bool algo::RspaceStr10::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr10..AssignOp
inline algo::RspaceStr10& algo::RspaceStr10::operator =(const algo::RspaceStr10 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr10));
    return *this;
}

// --- algo.RspaceStr10..Ctor
inline  algo::RspaceStr10::RspaceStr10() {
    algo::RspaceStr10_Init(*this);
}

// --- algo.RspaceStr10..CopyCtor
inline  algo::RspaceStr10::RspaceStr10(const algo::RspaceStr10 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr10));
}

// --- algo.RspaceStr100.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr100& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr100.ch.HashStrptr
inline u32 algo::RspaceStr100_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr100.ch.Init
inline void algo::ch_Init(algo::RspaceStr100 &parent) {
    memset(parent.ch, ' ', 100);
}

// --- algo.RspaceStr100.ch.Max
// always return constant 100
inline int algo::ch_Max(algo::RspaceStr100& parent) {
    (void)parent;
    return 100;
}

// --- algo.RspaceStr100.ch.N
inline int algo::ch_N(const algo::RspaceStr100& parent) {
    u64 ret;
    ret = 100;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr100.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr100::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr100.ch.CtorStrptr
inline  algo::RspaceStr100::RspaceStr100(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr100.ch.Cast
inline  algo::RspaceStr100::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr100..EqOp
inline bool algo::RspaceStr100::operator ==(const algo::RspaceStr100 &rhs) const {
    return algo::RspaceStr100_Eq(const_cast<algo::RspaceStr100&>(*this),const_cast<algo::RspaceStr100&>(rhs));
}

// --- algo.RspaceStr100..NeOp
inline bool algo::RspaceStr100::operator !=(const algo::RspaceStr100 &rhs) const {
    return !algo::RspaceStr100_Eq(const_cast<algo::RspaceStr100&>(*this),const_cast<algo::RspaceStr100&>(rhs));
}

// --- algo.RspaceStr100..Cmp
inline i32 algo::RspaceStr100_Cmp(algo::RspaceStr100& lhs, algo::RspaceStr100& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr100..Init
// Set all fields to initial values.
inline void algo::RspaceStr100_Init(algo::RspaceStr100& parent) {
    memset(parent.ch, ' ', 100);
}

// --- algo.RspaceStr100..Eq
inline bool algo::RspaceStr100_Eq(algo::RspaceStr100& lhs, algo::RspaceStr100& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56)
    &&*(u64*)(lhs.ch+64) == *(u64*)(rhs.ch+64)
    &&*(u64*)(lhs.ch+72) == *(u64*)(rhs.ch+72)
    &&*(u64*)(lhs.ch+80) == *(u64*)(rhs.ch+80)
    &&*(u64*)(lhs.ch+88) == *(u64*)(rhs.ch+88)
    &&*(u32*)(lhs.ch+96) == *(u32*)(rhs.ch+96);
    return retval;
}

// --- algo.RspaceStr100..EqOpAryptr
inline bool algo::RspaceStr100::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr100..AssignOp
inline algo::RspaceStr100& algo::RspaceStr100::operator =(const algo::RspaceStr100 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr100));
    return *this;
}

// --- algo.RspaceStr100..Ctor
inline  algo::RspaceStr100::RspaceStr100() {
    algo::RspaceStr100_Init(*this);
}

// --- algo.RspaceStr100..CopyCtor
inline  algo::RspaceStr100::RspaceStr100(const algo::RspaceStr100 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr100));
}

// --- algo.RspaceStr11.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr11& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr11.ch.HashStrptr
inline u32 algo::RspaceStr11_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr11.ch.Init
inline void algo::ch_Init(algo::RspaceStr11 &parent) {
    memset(parent.ch, ' ', 11);
}

// --- algo.RspaceStr11.ch.Max
// always return constant 11
inline int algo::ch_Max(algo::RspaceStr11& parent) {
    (void)parent;
    return 11;
}

// --- algo.RspaceStr11.ch.N
inline int algo::ch_N(const algo::RspaceStr11& parent) {
    u64 ret;
    ret = 11;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr11.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr11::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr11.ch.CtorStrptr
inline  algo::RspaceStr11::RspaceStr11(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr11.ch.Cast
inline  algo::RspaceStr11::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr11..EqOp
inline bool algo::RspaceStr11::operator ==(const algo::RspaceStr11 &rhs) const {
    return algo::RspaceStr11_Eq(const_cast<algo::RspaceStr11&>(*this),const_cast<algo::RspaceStr11&>(rhs));
}

// --- algo.RspaceStr11..NeOp
inline bool algo::RspaceStr11::operator !=(const algo::RspaceStr11 &rhs) const {
    return !algo::RspaceStr11_Eq(const_cast<algo::RspaceStr11&>(*this),const_cast<algo::RspaceStr11&>(rhs));
}

// --- algo.RspaceStr11..Cmp
inline i32 algo::RspaceStr11_Cmp(algo::RspaceStr11& lhs, algo::RspaceStr11& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr11..Init
// Set all fields to initial values.
inline void algo::RspaceStr11_Init(algo::RspaceStr11& parent) {
    memset(parent.ch, ' ', 11);
}

// --- algo.RspaceStr11..Eq
inline bool algo::RspaceStr11_Eq(algo::RspaceStr11& lhs, algo::RspaceStr11& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+8) == *(u16*)(rhs.ch+8)
    &&*(u8*)(lhs.ch+10) == *(u8*)(rhs.ch+10);
    return retval;
}

// --- algo.RspaceStr11..EqOpAryptr
inline bool algo::RspaceStr11::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr11..AssignOp
inline algo::RspaceStr11& algo::RspaceStr11::operator =(const algo::RspaceStr11 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr11));
    return *this;
}

// --- algo.RspaceStr11..Ctor
inline  algo::RspaceStr11::RspaceStr11() {
    algo::RspaceStr11_Init(*this);
}

// --- algo.RspaceStr11..CopyCtor
inline  algo::RspaceStr11::RspaceStr11(const algo::RspaceStr11 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr11));
}

// --- algo.RspaceStr12.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr12& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr12.ch.HashStrptr
inline u32 algo::RspaceStr12_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr12.ch.Init
inline void algo::ch_Init(algo::RspaceStr12 &parent) {
    memset(parent.ch, ' ', 12);
}

// --- algo.RspaceStr12.ch.Max
// always return constant 12
inline int algo::ch_Max(algo::RspaceStr12& parent) {
    (void)parent;
    return 12;
}

// --- algo.RspaceStr12.ch.N
inline int algo::ch_N(const algo::RspaceStr12& parent) {
    u64 ret;
    ret = 12;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr12.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr12::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr12.ch.CtorStrptr
inline  algo::RspaceStr12::RspaceStr12(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr12.ch.Cast
inline  algo::RspaceStr12::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr12..EqOp
inline bool algo::RspaceStr12::operator ==(const algo::RspaceStr12 &rhs) const {
    return algo::RspaceStr12_Eq(const_cast<algo::RspaceStr12&>(*this),const_cast<algo::RspaceStr12&>(rhs));
}

// --- algo.RspaceStr12..NeOp
inline bool algo::RspaceStr12::operator !=(const algo::RspaceStr12 &rhs) const {
    return !algo::RspaceStr12_Eq(const_cast<algo::RspaceStr12&>(*this),const_cast<algo::RspaceStr12&>(rhs));
}

// --- algo.RspaceStr12..Cmp
inline i32 algo::RspaceStr12_Cmp(algo::RspaceStr12 lhs, algo::RspaceStr12 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr12..Init
// Set all fields to initial values.
inline void algo::RspaceStr12_Init(algo::RspaceStr12& parent) {
    memset(parent.ch, ' ', 12);
}

// --- algo.RspaceStr12..Eq
inline bool algo::RspaceStr12_Eq(algo::RspaceStr12 lhs, algo::RspaceStr12 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8);
    return retval;
}

// --- algo.RspaceStr12..EqOpAryptr
inline bool algo::RspaceStr12::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr12..AssignOp
inline algo::RspaceStr12& algo::RspaceStr12::operator =(const algo::RspaceStr12 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr12));
    return *this;
}

// --- algo.RspaceStr12..Ctor
inline  algo::RspaceStr12::RspaceStr12() {
    algo::RspaceStr12_Init(*this);
}

// --- algo.RspaceStr12..CopyCtor
inline  algo::RspaceStr12::RspaceStr12(const algo::RspaceStr12 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr12));
}

// --- algo.RspaceStr128.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr128& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr128.ch.HashStrptr
inline u32 algo::RspaceStr128_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr128.ch.Init
inline void algo::ch_Init(algo::RspaceStr128 &parent) {
    memset(parent.ch, ' ', 128);
}

// --- algo.RspaceStr128.ch.Max
// always return constant 128
inline int algo::ch_Max(algo::RspaceStr128& parent) {
    (void)parent;
    return 128;
}

// --- algo.RspaceStr128.ch.N
inline int algo::ch_N(const algo::RspaceStr128& parent) {
    u64 ret;
    ret = 128;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr128.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr128::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr128.ch.CtorStrptr
inline  algo::RspaceStr128::RspaceStr128(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr128.ch.Cast
inline  algo::RspaceStr128::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr128..EqOp
inline bool algo::RspaceStr128::operator ==(const algo::RspaceStr128 &rhs) const {
    return algo::RspaceStr128_Eq(const_cast<algo::RspaceStr128&>(*this),const_cast<algo::RspaceStr128&>(rhs));
}

// --- algo.RspaceStr128..NeOp
inline bool algo::RspaceStr128::operator !=(const algo::RspaceStr128 &rhs) const {
    return !algo::RspaceStr128_Eq(const_cast<algo::RspaceStr128&>(*this),const_cast<algo::RspaceStr128&>(rhs));
}

// --- algo.RspaceStr128..Cmp
inline i32 algo::RspaceStr128_Cmp(algo::RspaceStr128 lhs, algo::RspaceStr128 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr128..Init
// Set all fields to initial values.
inline void algo::RspaceStr128_Init(algo::RspaceStr128& parent) {
    memset(parent.ch, ' ', 128);
}

// --- algo.RspaceStr128..Eq
inline bool algo::RspaceStr128_Eq(algo::RspaceStr128 lhs, algo::RspaceStr128 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56)
    &&*(u64*)(lhs.ch+64) == *(u64*)(rhs.ch+64)
    &&*(u64*)(lhs.ch+72) == *(u64*)(rhs.ch+72)
    &&*(u64*)(lhs.ch+80) == *(u64*)(rhs.ch+80)
    &&*(u64*)(lhs.ch+88) == *(u64*)(rhs.ch+88)
    &&*(u64*)(lhs.ch+96) == *(u64*)(rhs.ch+96)
    &&*(u64*)(lhs.ch+104) == *(u64*)(rhs.ch+104)
    &&*(u64*)(lhs.ch+112) == *(u64*)(rhs.ch+112)
    &&*(u64*)(lhs.ch+120) == *(u64*)(rhs.ch+120);
    return retval;
}

// --- algo.RspaceStr128..EqOpAryptr
inline bool algo::RspaceStr128::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr128..AssignOp
inline algo::RspaceStr128& algo::RspaceStr128::operator =(const algo::RspaceStr128 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr128));
    return *this;
}

// --- algo.RspaceStr128..Ctor
inline  algo::RspaceStr128::RspaceStr128() {
    algo::RspaceStr128_Init(*this);
}

// --- algo.RspaceStr128..CopyCtor
inline  algo::RspaceStr128::RspaceStr128(const algo::RspaceStr128 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr128));
}

// --- algo.RspaceStr14.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr14& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr14.ch.HashStrptr
inline u32 algo::RspaceStr14_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr14.ch.Init
inline void algo::ch_Init(algo::RspaceStr14 &parent) {
    memset(parent.ch, ' ', 14);
}

// --- algo.RspaceStr14.ch.Max
// always return constant 14
inline int algo::ch_Max(algo::RspaceStr14& parent) {
    (void)parent;
    return 14;
}

// --- algo.RspaceStr14.ch.N
inline int algo::ch_N(const algo::RspaceStr14& parent) {
    u64 ret;
    ret = 14;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr14.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr14::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr14.ch.CtorStrptr
inline  algo::RspaceStr14::RspaceStr14(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr14.ch.Cast
inline  algo::RspaceStr14::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr14..EqOp
inline bool algo::RspaceStr14::operator ==(const algo::RspaceStr14 &rhs) const {
    return algo::RspaceStr14_Eq(const_cast<algo::RspaceStr14&>(*this),const_cast<algo::RspaceStr14&>(rhs));
}

// --- algo.RspaceStr14..NeOp
inline bool algo::RspaceStr14::operator !=(const algo::RspaceStr14 &rhs) const {
    return !algo::RspaceStr14_Eq(const_cast<algo::RspaceStr14&>(*this),const_cast<algo::RspaceStr14&>(rhs));
}

// --- algo.RspaceStr14..Cmp
inline i32 algo::RspaceStr14_Cmp(algo::RspaceStr14 lhs, algo::RspaceStr14 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr14..Init
// Set all fields to initial values.
inline void algo::RspaceStr14_Init(algo::RspaceStr14& parent) {
    memset(parent.ch, ' ', 14);
}

// --- algo.RspaceStr14..Eq
inline bool algo::RspaceStr14_Eq(algo::RspaceStr14 lhs, algo::RspaceStr14 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+12) == *(u16*)(rhs.ch+12);
    return retval;
}

// --- algo.RspaceStr14..EqOpAryptr
inline bool algo::RspaceStr14::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr14..AssignOp
inline algo::RspaceStr14& algo::RspaceStr14::operator =(const algo::RspaceStr14 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr14));
    return *this;
}

// --- algo.RspaceStr14..Ctor
inline  algo::RspaceStr14::RspaceStr14() {
    algo::RspaceStr14_Init(*this);
}

// --- algo.RspaceStr14..CopyCtor
inline  algo::RspaceStr14::RspaceStr14(const algo::RspaceStr14 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr14));
}

// --- algo.RspaceStr15.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr15& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr15.ch.HashStrptr
inline u32 algo::RspaceStr15_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr15.ch.Init
inline void algo::ch_Init(algo::RspaceStr15 &parent) {
    memset(parent.ch, ' ', 15);
}

// --- algo.RspaceStr15.ch.Max
// always return constant 15
inline int algo::ch_Max(algo::RspaceStr15& parent) {
    (void)parent;
    return 15;
}

// --- algo.RspaceStr15.ch.N
inline int algo::ch_N(const algo::RspaceStr15& parent) {
    u64 ret;
    ret = 15;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr15.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr15::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr15.ch.CtorStrptr
inline  algo::RspaceStr15::RspaceStr15(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr15.ch.Cast
inline  algo::RspaceStr15::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr15..EqOp
inline bool algo::RspaceStr15::operator ==(const algo::RspaceStr15 &rhs) const {
    return algo::RspaceStr15_Eq(const_cast<algo::RspaceStr15&>(*this),const_cast<algo::RspaceStr15&>(rhs));
}

// --- algo.RspaceStr15..NeOp
inline bool algo::RspaceStr15::operator !=(const algo::RspaceStr15 &rhs) const {
    return !algo::RspaceStr15_Eq(const_cast<algo::RspaceStr15&>(*this),const_cast<algo::RspaceStr15&>(rhs));
}

// --- algo.RspaceStr15..Cmp
inline i32 algo::RspaceStr15_Cmp(algo::RspaceStr15 lhs, algo::RspaceStr15 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr15..Init
// Set all fields to initial values.
inline void algo::RspaceStr15_Init(algo::RspaceStr15& parent) {
    memset(parent.ch, ' ', 15);
}

// --- algo.RspaceStr15..Eq
inline bool algo::RspaceStr15_Eq(algo::RspaceStr15 lhs, algo::RspaceStr15 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u32*)(lhs.ch+8) == *(u32*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+12) == *(u16*)(rhs.ch+12)
    &&*(u8*)(lhs.ch+14) == *(u8*)(rhs.ch+14);
    return retval;
}

// --- algo.RspaceStr15..EqOpAryptr
inline bool algo::RspaceStr15::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr15..AssignOp
inline algo::RspaceStr15& algo::RspaceStr15::operator =(const algo::RspaceStr15 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr15));
    return *this;
}

// --- algo.RspaceStr15..Ctor
inline  algo::RspaceStr15::RspaceStr15() {
    algo::RspaceStr15_Init(*this);
}

// --- algo.RspaceStr15..CopyCtor
inline  algo::RspaceStr15::RspaceStr15(const algo::RspaceStr15 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr15));
}

// --- algo.RspaceStr16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr16.ch.HashStrptr
inline u32 algo::RspaceStr16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr16.ch.Init
inline void algo::ch_Init(algo::RspaceStr16 &parent) {
    memset(parent.ch, ' ', 16);
}

// --- algo.RspaceStr16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::RspaceStr16& parent) {
    (void)parent;
    return 16;
}

// --- algo.RspaceStr16.ch.N
inline int algo::ch_N(const algo::RspaceStr16& parent) {
    u64 ret;
    ret = 16;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr16.ch.CtorStrptr
inline  algo::RspaceStr16::RspaceStr16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr16.ch.Cast
inline  algo::RspaceStr16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr16..Lt
inline bool algo::RspaceStr16_Lt(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr16..Cmp
inline i32 algo::RspaceStr16_Cmp(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr16..Init
// Set all fields to initial values.
inline void algo::RspaceStr16_Init(algo::RspaceStr16& parent) {
    memset(parent.ch, ' ', 16);
}

// --- algo.RspaceStr16..Eq
inline bool algo::RspaceStr16_Eq(algo::RspaceStr16 lhs, algo::RspaceStr16 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8);
    return retval;
}

// --- algo.RspaceStr16..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr16_Update(algo::RspaceStr16 &lhs, algo::RspaceStr16 rhs) {
    bool ret = !RspaceStr16_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr16..EqOpAryptr
inline bool algo::RspaceStr16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr16..AssignOp
inline algo::RspaceStr16& algo::RspaceStr16::operator =(const algo::RspaceStr16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr16));
    return *this;
}

// --- algo.RspaceStr16..Ctor
inline  algo::RspaceStr16::RspaceStr16() {
    algo::RspaceStr16_Init(*this);
}

// --- algo.RspaceStr16..CopyCtor
inline  algo::RspaceStr16::RspaceStr16(const algo::RspaceStr16 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr16));
}

// --- algo.RspaceStr18.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr18& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr18.ch.HashStrptr
inline u32 algo::RspaceStr18_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr18.ch.Init
inline void algo::ch_Init(algo::RspaceStr18 &parent) {
    memset(parent.ch, ' ', 18);
}

// --- algo.RspaceStr18.ch.Max
// always return constant 18
inline int algo::ch_Max(algo::RspaceStr18& parent) {
    (void)parent;
    return 18;
}

// --- algo.RspaceStr18.ch.N
inline int algo::ch_N(const algo::RspaceStr18& parent) {
    u64 ret;
    ret = 18;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr18.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr18::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr18.ch.CtorStrptr
inline  algo::RspaceStr18::RspaceStr18(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr18.ch.Cast
inline  algo::RspaceStr18::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr18..EqOp
inline bool algo::RspaceStr18::operator ==(const algo::RspaceStr18 &rhs) const {
    return algo::RspaceStr18_Eq(const_cast<algo::RspaceStr18&>(*this),const_cast<algo::RspaceStr18&>(rhs));
}

// --- algo.RspaceStr18..NeOp
inline bool algo::RspaceStr18::operator !=(const algo::RspaceStr18 &rhs) const {
    return !algo::RspaceStr18_Eq(const_cast<algo::RspaceStr18&>(*this),const_cast<algo::RspaceStr18&>(rhs));
}

// --- algo.RspaceStr18..Cmp
inline i32 algo::RspaceStr18_Cmp(algo::RspaceStr18 lhs, algo::RspaceStr18 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr18..Init
// Set all fields to initial values.
inline void algo::RspaceStr18_Init(algo::RspaceStr18& parent) {
    memset(parent.ch, ' ', 18);
}

// --- algo.RspaceStr18..Eq
inline bool algo::RspaceStr18_Eq(algo::RspaceStr18 lhs, algo::RspaceStr18 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u16*)(lhs.ch+16) == *(u16*)(rhs.ch+16);
    return retval;
}

// --- algo.RspaceStr18..EqOpAryptr
inline bool algo::RspaceStr18::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr18..AssignOp
inline algo::RspaceStr18& algo::RspaceStr18::operator =(const algo::RspaceStr18 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr18));
    return *this;
}

// --- algo.RspaceStr18..Ctor
inline  algo::RspaceStr18::RspaceStr18() {
    algo::RspaceStr18_Init(*this);
}

// --- algo.RspaceStr18..CopyCtor
inline  algo::RspaceStr18::RspaceStr18(const algo::RspaceStr18 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr18));
}

// --- algo.RspaceStr2.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr2& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr2.ch.HashStrptr
inline u32 algo::RspaceStr2_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr2.ch.Init
inline void algo::ch_Init(algo::RspaceStr2 &parent) {
    memset(parent.ch, ' ', 2);
}

// --- algo.RspaceStr2.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::RspaceStr2& parent) {
    (void)parent;
    return 2;
}

// --- algo.RspaceStr2.ch.N
inline int algo::ch_N(const algo::RspaceStr2& parent) {
    u64 ret;
    ret = 2;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr2.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr2::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr2.ch.CtorStrptr
inline  algo::RspaceStr2::RspaceStr2(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr2.ch.Cast
inline  algo::RspaceStr2::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr2..EqOp
inline bool algo::RspaceStr2::operator ==(const algo::RspaceStr2 &rhs) const {
    return algo::RspaceStr2_Eq(const_cast<algo::RspaceStr2&>(*this),const_cast<algo::RspaceStr2&>(rhs));
}

// --- algo.RspaceStr2..NeOp
inline bool algo::RspaceStr2::operator !=(const algo::RspaceStr2 &rhs) const {
    return !algo::RspaceStr2_Eq(const_cast<algo::RspaceStr2&>(*this),const_cast<algo::RspaceStr2&>(rhs));
}

// --- algo.RspaceStr2..Cmp
inline i32 algo::RspaceStr2_Cmp(algo::RspaceStr2 lhs, algo::RspaceStr2 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr2..Init
// Set all fields to initial values.
inline void algo::RspaceStr2_Init(algo::RspaceStr2& parent) {
    memset(parent.ch, ' ', 2);
}

// --- algo.RspaceStr2..Eq
inline bool algo::RspaceStr2_Eq(algo::RspaceStr2 lhs, algo::RspaceStr2 rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0);
    return retval;
}

// --- algo.RspaceStr2..EqOpAryptr
inline bool algo::RspaceStr2::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr2..AssignOp
inline algo::RspaceStr2& algo::RspaceStr2::operator =(const algo::RspaceStr2 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr2));
    return *this;
}

// --- algo.RspaceStr2..Ctor
inline  algo::RspaceStr2::RspaceStr2() {
    algo::RspaceStr2_Init(*this);
}

// --- algo.RspaceStr2..CopyCtor
inline  algo::RspaceStr2::RspaceStr2(const algo::RspaceStr2 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr2));
}

// --- algo.RspaceStr20.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr20& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr20.ch.HashStrptr
inline u32 algo::RspaceStr20_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr20.ch.Init
inline void algo::ch_Init(algo::RspaceStr20 &parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.RspaceStr20.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::RspaceStr20& parent) {
    (void)parent;
    return 20;
}

// --- algo.RspaceStr20.ch.N
inline int algo::ch_N(const algo::RspaceStr20& parent) {
    u64 ret;
    ret = 20;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr20.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr20::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr20.ch.CtorStrptr
inline  algo::RspaceStr20::RspaceStr20(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr20.ch.Cast
inline  algo::RspaceStr20::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr20..EqOp
inline bool algo::RspaceStr20::operator ==(const algo::RspaceStr20 &rhs) const {
    return algo::RspaceStr20_Eq(const_cast<algo::RspaceStr20&>(*this),const_cast<algo::RspaceStr20&>(rhs));
}

// --- algo.RspaceStr20..NeOp
inline bool algo::RspaceStr20::operator !=(const algo::RspaceStr20 &rhs) const {
    return !algo::RspaceStr20_Eq(const_cast<algo::RspaceStr20&>(*this),const_cast<algo::RspaceStr20&>(rhs));
}

// --- algo.RspaceStr20..Cmp
inline i32 algo::RspaceStr20_Cmp(algo::RspaceStr20 lhs, algo::RspaceStr20 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr20..Init
// Set all fields to initial values.
inline void algo::RspaceStr20_Init(algo::RspaceStr20& parent) {
    memset(parent.ch, ' ', 20);
}

// --- algo.RspaceStr20..Eq
inline bool algo::RspaceStr20_Eq(algo::RspaceStr20 lhs, algo::RspaceStr20 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16);
    return retval;
}

// --- algo.RspaceStr20..EqOpAryptr
inline bool algo::RspaceStr20::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr20..AssignOp
inline algo::RspaceStr20& algo::RspaceStr20::operator =(const algo::RspaceStr20 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr20));
    return *this;
}

// --- algo.RspaceStr20..Ctor
inline  algo::RspaceStr20::RspaceStr20() {
    algo::RspaceStr20_Init(*this);
}

// --- algo.RspaceStr20..CopyCtor
inline  algo::RspaceStr20::RspaceStr20(const algo::RspaceStr20 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr20));
}

// --- algo.RspaceStr200.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr200& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr200.ch.HashStrptr
inline u32 algo::RspaceStr200_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr200.ch.Init
inline void algo::ch_Init(algo::RspaceStr200 &parent) {
    memset(parent.ch, ' ', 200);
}

// --- algo.RspaceStr200.ch.Max
// always return constant 200
inline int algo::ch_Max(algo::RspaceStr200& parent) {
    (void)parent;
    return 200;
}

// --- algo.RspaceStr200.ch.N
inline int algo::ch_N(const algo::RspaceStr200& parent) {
    u64 ret;
    ret = 200;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr200.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr200::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr200.ch.CtorStrptr
inline  algo::RspaceStr200::RspaceStr200(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr200.ch.Cast
inline  algo::RspaceStr200::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr200..EqOp
inline bool algo::RspaceStr200::operator ==(const algo::RspaceStr200 &rhs) const {
    return algo::RspaceStr200_Eq(const_cast<algo::RspaceStr200&>(*this),const_cast<algo::RspaceStr200&>(rhs));
}

// --- algo.RspaceStr200..NeOp
inline bool algo::RspaceStr200::operator !=(const algo::RspaceStr200 &rhs) const {
    return !algo::RspaceStr200_Eq(const_cast<algo::RspaceStr200&>(*this),const_cast<algo::RspaceStr200&>(rhs));
}

// --- algo.RspaceStr200..Cmp
inline i32 algo::RspaceStr200_Cmp(algo::RspaceStr200& lhs, algo::RspaceStr200& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr200..Init
// Set all fields to initial values.
inline void algo::RspaceStr200_Init(algo::RspaceStr200& parent) {
    memset(parent.ch, ' ', 200);
}

// --- algo.RspaceStr200..Eq
inline bool algo::RspaceStr200_Eq(algo::RspaceStr200& lhs, algo::RspaceStr200& rhs) {
    bool retval = true;
    for (int i=0; i<25 && retval; i++) {
        retval = ((u64*)lhs.ch)[i] == ((u64*)rhs.ch)[i];
    }
    return retval;
}

// --- algo.RspaceStr200..EqOpAryptr
inline bool algo::RspaceStr200::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr200..AssignOp
inline algo::RspaceStr200& algo::RspaceStr200::operator =(const algo::RspaceStr200 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr200));
    return *this;
}

// --- algo.RspaceStr200..Ctor
inline  algo::RspaceStr200::RspaceStr200() {
    algo::RspaceStr200_Init(*this);
}

// --- algo.RspaceStr200..CopyCtor
inline  algo::RspaceStr200::RspaceStr200(const algo::RspaceStr200 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr200));
}

// --- algo.RspaceStr21.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr21& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr21.ch.HashStrptr
inline u32 algo::RspaceStr21_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr21.ch.Init
inline void algo::ch_Init(algo::RspaceStr21 &parent) {
    memset(parent.ch, ' ', 21);
}

// --- algo.RspaceStr21.ch.Max
// always return constant 21
inline int algo::ch_Max(algo::RspaceStr21& parent) {
    (void)parent;
    return 21;
}

// --- algo.RspaceStr21.ch.N
inline int algo::ch_N(const algo::RspaceStr21& parent) {
    u64 ret;
    ret = 21;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr21.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr21::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr21.ch.CtorStrptr
inline  algo::RspaceStr21::RspaceStr21(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr21.ch.Cast
inline  algo::RspaceStr21::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr21..EqOp
inline bool algo::RspaceStr21::operator ==(const algo::RspaceStr21 &rhs) const {
    return algo::RspaceStr21_Eq(const_cast<algo::RspaceStr21&>(*this),const_cast<algo::RspaceStr21&>(rhs));
}

// --- algo.RspaceStr21..NeOp
inline bool algo::RspaceStr21::operator !=(const algo::RspaceStr21 &rhs) const {
    return !algo::RspaceStr21_Eq(const_cast<algo::RspaceStr21&>(*this),const_cast<algo::RspaceStr21&>(rhs));
}

// --- algo.RspaceStr21..Cmp
inline i32 algo::RspaceStr21_Cmp(algo::RspaceStr21& lhs, algo::RspaceStr21& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr21..Init
// Set all fields to initial values.
inline void algo::RspaceStr21_Init(algo::RspaceStr21& parent) {
    memset(parent.ch, ' ', 21);
}

// --- algo.RspaceStr21..Eq
inline bool algo::RspaceStr21_Eq(algo::RspaceStr21& lhs, algo::RspaceStr21& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u32*)(lhs.ch+16) == *(u32*)(rhs.ch+16)
    &&*(u8*)(lhs.ch+20) == *(u8*)(rhs.ch+20);
    return retval;
}

// --- algo.RspaceStr21..EqOpAryptr
inline bool algo::RspaceStr21::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr21..AssignOp
inline algo::RspaceStr21& algo::RspaceStr21::operator =(const algo::RspaceStr21 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr21));
    return *this;
}

// --- algo.RspaceStr21..Ctor
inline  algo::RspaceStr21::RspaceStr21() {
    algo::RspaceStr21_Init(*this);
}

// --- algo.RspaceStr21..CopyCtor
inline  algo::RspaceStr21::RspaceStr21(const algo::RspaceStr21 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr21));
}

// --- algo.RspaceStr24.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr24& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr24.ch.HashStrptr
inline u32 algo::RspaceStr24_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr24.ch.Init
inline void algo::ch_Init(algo::RspaceStr24 &parent) {
    memset(parent.ch, ' ', 24);
}

// --- algo.RspaceStr24.ch.Max
// always return constant 24
inline int algo::ch_Max(algo::RspaceStr24& parent) {
    (void)parent;
    return 24;
}

// --- algo.RspaceStr24.ch.N
inline int algo::ch_N(const algo::RspaceStr24& parent) {
    u64 ret;
    ret = 24;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr24.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr24::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr24.ch.CtorStrptr
inline  algo::RspaceStr24::RspaceStr24(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr24.ch.Cast
inline  algo::RspaceStr24::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr24..Lt
inline bool algo::RspaceStr24_Lt(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr24..Cmp
inline i32 algo::RspaceStr24_Cmp(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr24..Init
// Set all fields to initial values.
inline void algo::RspaceStr24_Init(algo::RspaceStr24& parent) {
    memset(parent.ch, ' ', 24);
}

// --- algo.RspaceStr24..Eq
inline bool algo::RspaceStr24_Eq(algo::RspaceStr24 lhs, algo::RspaceStr24 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16);
    return retval;
}

// --- algo.RspaceStr24..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr24_Update(algo::RspaceStr24 &lhs, algo::RspaceStr24 rhs) {
    bool ret = !RspaceStr24_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr24..EqOpAryptr
inline bool algo::RspaceStr24::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr24..AssignOp
inline algo::RspaceStr24& algo::RspaceStr24::operator =(const algo::RspaceStr24 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr24));
    return *this;
}

// --- algo.RspaceStr24..Ctor
inline  algo::RspaceStr24::RspaceStr24() {
    algo::RspaceStr24_Init(*this);
}

// --- algo.RspaceStr24..CopyCtor
inline  algo::RspaceStr24::RspaceStr24(const algo::RspaceStr24 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr24));
}

// --- algo.RspaceStr240.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr240& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr240.ch.HashStrptr
inline u32 algo::RspaceStr240_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr240.ch.Init
inline void algo::ch_Init(algo::RspaceStr240 &parent) {
    memset(parent.ch, ' ', 240);
}

// --- algo.RspaceStr240.ch.Max
// always return constant 240
inline int algo::ch_Max(algo::RspaceStr240& parent) {
    (void)parent;
    return 240;
}

// --- algo.RspaceStr240.ch.N
inline int algo::ch_N(const algo::RspaceStr240& parent) {
    u64 ret;
    ret = 240;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr240.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr240::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr240.ch.CtorStrptr
inline  algo::RspaceStr240::RspaceStr240(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr240.ch.Cast
inline  algo::RspaceStr240::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr240..EqOp
inline bool algo::RspaceStr240::operator ==(const algo::RspaceStr240 &rhs) const {
    return algo::RspaceStr240_Eq(const_cast<algo::RspaceStr240&>(*this),const_cast<algo::RspaceStr240&>(rhs));
}

// --- algo.RspaceStr240..NeOp
inline bool algo::RspaceStr240::operator !=(const algo::RspaceStr240 &rhs) const {
    return !algo::RspaceStr240_Eq(const_cast<algo::RspaceStr240&>(*this),const_cast<algo::RspaceStr240&>(rhs));
}

// --- algo.RspaceStr240..Cmp
inline i32 algo::RspaceStr240_Cmp(algo::RspaceStr240& lhs, algo::RspaceStr240& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr240..Init
// Set all fields to initial values.
inline void algo::RspaceStr240_Init(algo::RspaceStr240& parent) {
    memset(parent.ch, ' ', 240);
}

// --- algo.RspaceStr240..Eq
inline bool algo::RspaceStr240_Eq(algo::RspaceStr240& lhs, algo::RspaceStr240& rhs) {
    bool retval = true;
    for (int i=0; i<30 && retval; i++) {
        retval = ((u64*)lhs.ch)[i] == ((u64*)rhs.ch)[i];
    }
    return retval;
}

// --- algo.RspaceStr240..EqOpAryptr
inline bool algo::RspaceStr240::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr240..AssignOp
inline algo::RspaceStr240& algo::RspaceStr240::operator =(const algo::RspaceStr240 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr240));
    return *this;
}

// --- algo.RspaceStr240..Ctor
inline  algo::RspaceStr240::RspaceStr240() {
    algo::RspaceStr240_Init(*this);
}

// --- algo.RspaceStr240..CopyCtor
inline  algo::RspaceStr240::RspaceStr240(const algo::RspaceStr240 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr240));
}

// --- algo.RspaceStr25.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr25& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr25.ch.HashStrptr
inline u32 algo::RspaceStr25_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr25.ch.Init
inline void algo::ch_Init(algo::RspaceStr25 &parent) {
    memset(parent.ch, ' ', 25);
}

// --- algo.RspaceStr25.ch.Max
// always return constant 25
inline int algo::ch_Max(algo::RspaceStr25& parent) {
    (void)parent;
    return 25;
}

// --- algo.RspaceStr25.ch.N
inline int algo::ch_N(const algo::RspaceStr25& parent) {
    u64 ret;
    ret = 25;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr25.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr25::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr25.ch.CtorStrptr
inline  algo::RspaceStr25::RspaceStr25(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr25.ch.Cast
inline  algo::RspaceStr25::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr25..Lt
inline bool algo::RspaceStr25_Lt(algo::RspaceStr25 lhs, algo::RspaceStr25 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr25..Cmp
inline i32 algo::RspaceStr25_Cmp(algo::RspaceStr25 lhs, algo::RspaceStr25 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr25..Init
// Set all fields to initial values.
inline void algo::RspaceStr25_Init(algo::RspaceStr25& parent) {
    memset(parent.ch, ' ', 25);
}

// --- algo.RspaceStr25..Eq
inline bool algo::RspaceStr25_Eq(algo::RspaceStr25 lhs, algo::RspaceStr25 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u8*)(lhs.ch+24) == *(u8*)(rhs.ch+24);
    return retval;
}

// --- algo.RspaceStr25..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr25_Update(algo::RspaceStr25 &lhs, algo::RspaceStr25 rhs) {
    bool ret = !RspaceStr25_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr25..EqOpAryptr
inline bool algo::RspaceStr25::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr25..AssignOp
inline algo::RspaceStr25& algo::RspaceStr25::operator =(const algo::RspaceStr25 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr25));
    return *this;
}

// --- algo.RspaceStr25..Ctor
inline  algo::RspaceStr25::RspaceStr25() {
    algo::RspaceStr25_Init(*this);
}

// --- algo.RspaceStr25..CopyCtor
inline  algo::RspaceStr25::RspaceStr25(const algo::RspaceStr25 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr25));
}

// --- algo.RspaceStr26.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr26& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr26.ch.HashStrptr
inline u32 algo::RspaceStr26_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr26.ch.Init
inline void algo::ch_Init(algo::RspaceStr26 &parent) {
    memset(parent.ch, ' ', 26);
}

// --- algo.RspaceStr26.ch.Max
// always return constant 26
inline int algo::ch_Max(algo::RspaceStr26& parent) {
    (void)parent;
    return 26;
}

// --- algo.RspaceStr26.ch.N
inline int algo::ch_N(const algo::RspaceStr26& parent) {
    u64 ret;
    ret = 26;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr26.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr26::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr26.ch.CtorStrptr
inline  algo::RspaceStr26::RspaceStr26(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr26.ch.Cast
inline  algo::RspaceStr26::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr26..EqOp
inline bool algo::RspaceStr26::operator ==(const algo::RspaceStr26 &rhs) const {
    return algo::RspaceStr26_Eq(const_cast<algo::RspaceStr26&>(*this),const_cast<algo::RspaceStr26&>(rhs));
}

// --- algo.RspaceStr26..NeOp
inline bool algo::RspaceStr26::operator !=(const algo::RspaceStr26 &rhs) const {
    return !algo::RspaceStr26_Eq(const_cast<algo::RspaceStr26&>(*this),const_cast<algo::RspaceStr26&>(rhs));
}

// --- algo.RspaceStr26..Cmp
inline i32 algo::RspaceStr26_Cmp(algo::RspaceStr26& lhs, algo::RspaceStr26& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr26..Init
// Set all fields to initial values.
inline void algo::RspaceStr26_Init(algo::RspaceStr26& parent) {
    memset(parent.ch, ' ', 26);
}

// --- algo.RspaceStr26..Eq
inline bool algo::RspaceStr26_Eq(algo::RspaceStr26& lhs, algo::RspaceStr26& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u16*)(lhs.ch+24) == *(u16*)(rhs.ch+24);
    return retval;
}

// --- algo.RspaceStr26..EqOpAryptr
inline bool algo::RspaceStr26::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr26..AssignOp
inline algo::RspaceStr26& algo::RspaceStr26::operator =(const algo::RspaceStr26 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr26));
    return *this;
}

// --- algo.RspaceStr26..Ctor
inline  algo::RspaceStr26::RspaceStr26() {
    algo::RspaceStr26_Init(*this);
}

// --- algo.RspaceStr26..CopyCtor
inline  algo::RspaceStr26::RspaceStr26(const algo::RspaceStr26 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr26));
}

// --- algo.RspaceStr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr3.ch.HashStrptr
inline u32 algo::RspaceStr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr3.ch.Init
inline void algo::ch_Init(algo::RspaceStr3 &parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.RspaceStr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::RspaceStr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.RspaceStr3.ch.N
inline int algo::ch_N(const algo::RspaceStr3& parent) {
    u64 ret;
    ret = 3;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr3.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr3::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr3.ch.CtorStrptr
inline  algo::RspaceStr3::RspaceStr3(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr3.ch.Cast
inline  algo::RspaceStr3::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr3..EqOp
inline bool algo::RspaceStr3::operator ==(const algo::RspaceStr3 &rhs) const {
    return algo::RspaceStr3_Eq(const_cast<algo::RspaceStr3&>(*this),const_cast<algo::RspaceStr3&>(rhs));
}

// --- algo.RspaceStr3..NeOp
inline bool algo::RspaceStr3::operator !=(const algo::RspaceStr3 &rhs) const {
    return !algo::RspaceStr3_Eq(const_cast<algo::RspaceStr3&>(*this),const_cast<algo::RspaceStr3&>(rhs));
}

// --- algo.RspaceStr3..Cmp
inline i32 algo::RspaceStr3_Cmp(algo::RspaceStr3 lhs, algo::RspaceStr3 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr3..Init
// Set all fields to initial values.
inline void algo::RspaceStr3_Init(algo::RspaceStr3& parent) {
    memset(parent.ch, ' ', 3);
}

// --- algo.RspaceStr3..Eq
inline bool algo::RspaceStr3_Eq(algo::RspaceStr3 lhs, algo::RspaceStr3 rhs) {
    bool retval = true;
    retval = retval
    &&*(u16*)(lhs.ch+0) == *(u16*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+2) == *(u8*)(rhs.ch+2);
    return retval;
}

// --- algo.RspaceStr3..EqOpAryptr
inline bool algo::RspaceStr3::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr3..AssignOp
inline algo::RspaceStr3& algo::RspaceStr3::operator =(const algo::RspaceStr3 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr3));
    return *this;
}

// --- algo.RspaceStr3..Ctor
inline  algo::RspaceStr3::RspaceStr3() {
    algo::RspaceStr3_Init(*this);
}

// --- algo.RspaceStr3..CopyCtor
inline  algo::RspaceStr3::RspaceStr3(const algo::RspaceStr3 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr3));
}

// --- algo.RspaceStr31.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr31& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr31.ch.HashStrptr
inline u32 algo::RspaceStr31_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr31.ch.Init
inline void algo::ch_Init(algo::RspaceStr31 &parent) {
    memset(parent.ch, ' ', 31);
}

// --- algo.RspaceStr31.ch.Max
// always return constant 31
inline int algo::ch_Max(algo::RspaceStr31& parent) {
    (void)parent;
    return 31;
}

// --- algo.RspaceStr31.ch.N
inline int algo::ch_N(const algo::RspaceStr31& parent) {
    u64 ret;
    ret = 31;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr31.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr31::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr31.ch.CtorStrptr
inline  algo::RspaceStr31::RspaceStr31(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr31.ch.Cast
inline  algo::RspaceStr31::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr31..EqOp
inline bool algo::RspaceStr31::operator ==(const algo::RspaceStr31 &rhs) const {
    return algo::RspaceStr31_Eq(const_cast<algo::RspaceStr31&>(*this),const_cast<algo::RspaceStr31&>(rhs));
}

// --- algo.RspaceStr31..NeOp
inline bool algo::RspaceStr31::operator !=(const algo::RspaceStr31 &rhs) const {
    return !algo::RspaceStr31_Eq(const_cast<algo::RspaceStr31&>(*this),const_cast<algo::RspaceStr31&>(rhs));
}

// --- algo.RspaceStr31..Cmp
inline i32 algo::RspaceStr31_Cmp(algo::RspaceStr31& lhs, algo::RspaceStr31& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr31..Init
// Set all fields to initial values.
inline void algo::RspaceStr31_Init(algo::RspaceStr31& parent) {
    memset(parent.ch, ' ', 31);
}

// --- algo.RspaceStr31..Eq
inline bool algo::RspaceStr31_Eq(algo::RspaceStr31& lhs, algo::RspaceStr31& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u32*)(lhs.ch+24) == *(u32*)(rhs.ch+24)
    &&*(u16*)(lhs.ch+28) == *(u16*)(rhs.ch+28)
    &&*(u8*)(lhs.ch+30) == *(u8*)(rhs.ch+30);
    return retval;
}

// --- algo.RspaceStr31..EqOpAryptr
inline bool algo::RspaceStr31::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr31..AssignOp
inline algo::RspaceStr31& algo::RspaceStr31::operator =(const algo::RspaceStr31 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr31));
    return *this;
}

// --- algo.RspaceStr31..Ctor
inline  algo::RspaceStr31::RspaceStr31() {
    algo::RspaceStr31_Init(*this);
}

// --- algo.RspaceStr31..CopyCtor
inline  algo::RspaceStr31::RspaceStr31(const algo::RspaceStr31 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr31));
}

// --- algo.RspaceStr32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr32.ch.HashStrptr
inline u32 algo::RspaceStr32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr32.ch.Init
inline void algo::ch_Init(algo::RspaceStr32 &parent) {
    memset(parent.ch, ' ', 32);
}

// --- algo.RspaceStr32.ch.Max
// always return constant 32
inline int algo::ch_Max(algo::RspaceStr32& parent) {
    (void)parent;
    return 32;
}

// --- algo.RspaceStr32.ch.N
inline int algo::ch_N(const algo::RspaceStr32& parent) {
    u64 ret;
    ret = 32;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr32.ch.CtorStrptr
inline  algo::RspaceStr32::RspaceStr32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr32.ch.Cast
inline  algo::RspaceStr32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr32..EqOp
inline bool algo::RspaceStr32::operator ==(const algo::RspaceStr32 &rhs) const {
    return algo::RspaceStr32_Eq(const_cast<algo::RspaceStr32&>(*this),const_cast<algo::RspaceStr32&>(rhs));
}

// --- algo.RspaceStr32..NeOp
inline bool algo::RspaceStr32::operator !=(const algo::RspaceStr32 &rhs) const {
    return !algo::RspaceStr32_Eq(const_cast<algo::RspaceStr32&>(*this),const_cast<algo::RspaceStr32&>(rhs));
}

// --- algo.RspaceStr32..Cmp
inline i32 algo::RspaceStr32_Cmp(algo::RspaceStr32 lhs, algo::RspaceStr32 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr32..Init
// Set all fields to initial values.
inline void algo::RspaceStr32_Init(algo::RspaceStr32& parent) {
    memset(parent.ch, ' ', 32);
}

// --- algo.RspaceStr32..Eq
inline bool algo::RspaceStr32_Eq(algo::RspaceStr32 lhs, algo::RspaceStr32 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24);
    return retval;
}

// --- algo.RspaceStr32..EqOpAryptr
inline bool algo::RspaceStr32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr32..AssignOp
inline algo::RspaceStr32& algo::RspaceStr32::operator =(const algo::RspaceStr32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr32));
    return *this;
}

// --- algo.RspaceStr32..Ctor
inline  algo::RspaceStr32::RspaceStr32() {
    algo::RspaceStr32_Init(*this);
}

// --- algo.RspaceStr32..CopyCtor
inline  algo::RspaceStr32::RspaceStr32(const algo::RspaceStr32 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr32));
}

// --- algo.RspaceStr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr4.ch.HashStrptr
inline u32 algo::RspaceStr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr4.ch.Init
inline void algo::ch_Init(algo::RspaceStr4 &parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.RspaceStr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::RspaceStr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.RspaceStr4.ch.N
inline int algo::ch_N(const algo::RspaceStr4& parent) {
    u64 ret;
    ret = 4;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr4.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr4::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr4.ch.CtorStrptr
inline  algo::RspaceStr4::RspaceStr4(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr4.ch.Cast
inline  algo::RspaceStr4::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr4..EqOp
inline bool algo::RspaceStr4::operator ==(const algo::RspaceStr4 &rhs) const {
    return algo::RspaceStr4_Eq(const_cast<algo::RspaceStr4&>(*this),const_cast<algo::RspaceStr4&>(rhs));
}

// --- algo.RspaceStr4..NeOp
inline bool algo::RspaceStr4::operator !=(const algo::RspaceStr4 &rhs) const {
    return !algo::RspaceStr4_Eq(const_cast<algo::RspaceStr4&>(*this),const_cast<algo::RspaceStr4&>(rhs));
}

// --- algo.RspaceStr4..Cmp
inline i32 algo::RspaceStr4_Cmp(algo::RspaceStr4 lhs, algo::RspaceStr4 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr4..Init
// Set all fields to initial values.
inline void algo::RspaceStr4_Init(algo::RspaceStr4& parent) {
    memset(parent.ch, ' ', 4);
}

// --- algo.RspaceStr4..Eq
inline bool algo::RspaceStr4_Eq(algo::RspaceStr4 lhs, algo::RspaceStr4 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0);
    return retval;
}

// --- algo.RspaceStr4..EqOpAryptr
inline bool algo::RspaceStr4::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr4..AssignOp
inline algo::RspaceStr4& algo::RspaceStr4::operator =(const algo::RspaceStr4 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr4));
    return *this;
}

// --- algo.RspaceStr4..Ctor
inline  algo::RspaceStr4::RspaceStr4() {
    algo::RspaceStr4_Init(*this);
}

// --- algo.RspaceStr4..CopyCtor
inline  algo::RspaceStr4::RspaceStr4(const algo::RspaceStr4 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr4));
}

// --- algo.RspaceStr40.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr40& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr40.ch.HashStrptr
inline u32 algo::RspaceStr40_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr40.ch.Init
inline void algo::ch_Init(algo::RspaceStr40 &parent) {
    memset(parent.ch, ' ', 40);
}

// --- algo.RspaceStr40.ch.Max
// always return constant 40
inline int algo::ch_Max(algo::RspaceStr40& parent) {
    (void)parent;
    return 40;
}

// --- algo.RspaceStr40.ch.N
inline int algo::ch_N(const algo::RspaceStr40& parent) {
    u64 ret;
    ret = 40;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr40.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr40::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr40.ch.CtorStrptr
inline  algo::RspaceStr40::RspaceStr40(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr40.ch.Cast
inline  algo::RspaceStr40::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr40..Cmp
inline i32 algo::RspaceStr40_Cmp(algo::RspaceStr40 lhs, algo::RspaceStr40 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr40..Init
// Set all fields to initial values.
inline void algo::RspaceStr40_Init(algo::RspaceStr40& parent) {
    memset(parent.ch, ' ', 40);
}

// --- algo.RspaceStr40..Eq
inline bool algo::RspaceStr40_Eq(algo::RspaceStr40 lhs, algo::RspaceStr40 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32);
    return retval;
}

// --- algo.RspaceStr40..EqOpAryptr
inline bool algo::RspaceStr40::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr40..AssignOp
inline algo::RspaceStr40& algo::RspaceStr40::operator =(const algo::RspaceStr40 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr40));
    return *this;
}

// --- algo.RspaceStr40..Ctor
inline  algo::RspaceStr40::RspaceStr40() {
    algo::RspaceStr40_Init(*this);
}

// --- algo.RspaceStr40..CopyCtor
inline  algo::RspaceStr40::RspaceStr40(const algo::RspaceStr40 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr40));
}

// --- algo.RspaceStr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr5.ch.HashStrptr
inline u32 algo::RspaceStr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr5.ch.Init
inline void algo::ch_Init(algo::RspaceStr5 &parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.RspaceStr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::RspaceStr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.RspaceStr5.ch.N
inline int algo::ch_N(const algo::RspaceStr5& parent) {
    u64 ret;
    ret = 5;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr5.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr5::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr5.ch.CtorStrptr
inline  algo::RspaceStr5::RspaceStr5(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr5.ch.Cast
inline  algo::RspaceStr5::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr5..EqOp
inline bool algo::RspaceStr5::operator ==(const algo::RspaceStr5 &rhs) const {
    return algo::RspaceStr5_Eq(const_cast<algo::RspaceStr5&>(*this),const_cast<algo::RspaceStr5&>(rhs));
}

// --- algo.RspaceStr5..NeOp
inline bool algo::RspaceStr5::operator !=(const algo::RspaceStr5 &rhs) const {
    return !algo::RspaceStr5_Eq(const_cast<algo::RspaceStr5&>(*this),const_cast<algo::RspaceStr5&>(rhs));
}

// --- algo.RspaceStr5..Cmp
inline i32 algo::RspaceStr5_Cmp(algo::RspaceStr5 lhs, algo::RspaceStr5 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr5..Init
// Set all fields to initial values.
inline void algo::RspaceStr5_Init(algo::RspaceStr5& parent) {
    memset(parent.ch, ' ', 5);
}

// --- algo.RspaceStr5..Eq
inline bool algo::RspaceStr5_Eq(algo::RspaceStr5 lhs, algo::RspaceStr5 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+4) == *(u8*)(rhs.ch+4);
    return retval;
}

// --- algo.RspaceStr5..EqOpAryptr
inline bool algo::RspaceStr5::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr5..AssignOp
inline algo::RspaceStr5& algo::RspaceStr5::operator =(const algo::RspaceStr5 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr5));
    return *this;
}

// --- algo.RspaceStr5..Ctor
inline  algo::RspaceStr5::RspaceStr5() {
    algo::RspaceStr5_Init(*this);
}

// --- algo.RspaceStr5..CopyCtor
inline  algo::RspaceStr5::RspaceStr5(const algo::RspaceStr5 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr5));
}

// --- algo.RspaceStr50.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr50& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr50.ch.HashStrptr
inline u32 algo::RspaceStr50_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr50.ch.Init
inline void algo::ch_Init(algo::RspaceStr50 &parent) {
    memset(parent.ch, ' ', 50);
}

// --- algo.RspaceStr50.ch.Max
// always return constant 50
inline int algo::ch_Max(algo::RspaceStr50& parent) {
    (void)parent;
    return 50;
}

// --- algo.RspaceStr50.ch.N
inline int algo::ch_N(const algo::RspaceStr50& parent) {
    u64 ret;
    ret = 50;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr50.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr50::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr50.ch.CtorStrptr
inline  algo::RspaceStr50::RspaceStr50(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr50.ch.Cast
inline  algo::RspaceStr50::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr50..EqOp
inline bool algo::RspaceStr50::operator ==(const algo::RspaceStr50 &rhs) const {
    return algo::RspaceStr50_Eq(const_cast<algo::RspaceStr50&>(*this),const_cast<algo::RspaceStr50&>(rhs));
}

// --- algo.RspaceStr50..NeOp
inline bool algo::RspaceStr50::operator !=(const algo::RspaceStr50 &rhs) const {
    return !algo::RspaceStr50_Eq(const_cast<algo::RspaceStr50&>(*this),const_cast<algo::RspaceStr50&>(rhs));
}

// --- algo.RspaceStr50..Cmp
inline i32 algo::RspaceStr50_Cmp(algo::RspaceStr50 lhs, algo::RspaceStr50 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr50..Init
// Set all fields to initial values.
inline void algo::RspaceStr50_Init(algo::RspaceStr50& parent) {
    memset(parent.ch, ' ', 50);
}

// --- algo.RspaceStr50..Eq
inline bool algo::RspaceStr50_Eq(algo::RspaceStr50 lhs, algo::RspaceStr50 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u16*)(lhs.ch+48) == *(u16*)(rhs.ch+48);
    return retval;
}

// --- algo.RspaceStr50..EqOpAryptr
inline bool algo::RspaceStr50::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr50..AssignOp
inline algo::RspaceStr50& algo::RspaceStr50::operator =(const algo::RspaceStr50 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr50));
    return *this;
}

// --- algo.RspaceStr50..Ctor
inline  algo::RspaceStr50::RspaceStr50() {
    algo::RspaceStr50_Init(*this);
}

// --- algo.RspaceStr50..CopyCtor
inline  algo::RspaceStr50::RspaceStr50(const algo::RspaceStr50 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr50));
}

// --- algo.RspaceStr6.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr6& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr6.ch.HashStrptr
inline u32 algo::RspaceStr6_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr6.ch.Init
inline void algo::ch_Init(algo::RspaceStr6 &parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.RspaceStr6.ch.Max
// always return constant 6
inline int algo::ch_Max(algo::RspaceStr6& parent) {
    (void)parent;
    return 6;
}

// --- algo.RspaceStr6.ch.N
inline int algo::ch_N(const algo::RspaceStr6& parent) {
    u64 ret;
    ret = 6;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr6.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr6::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr6.ch.CtorStrptr
inline  algo::RspaceStr6::RspaceStr6(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr6.ch.Cast
inline  algo::RspaceStr6::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr6..EqOp
inline bool algo::RspaceStr6::operator ==(const algo::RspaceStr6 &rhs) const {
    return algo::RspaceStr6_Eq(const_cast<algo::RspaceStr6&>(*this),const_cast<algo::RspaceStr6&>(rhs));
}

// --- algo.RspaceStr6..NeOp
inline bool algo::RspaceStr6::operator !=(const algo::RspaceStr6 &rhs) const {
    return !algo::RspaceStr6_Eq(const_cast<algo::RspaceStr6&>(*this),const_cast<algo::RspaceStr6&>(rhs));
}

// --- algo.RspaceStr6..LtOp
inline bool algo::RspaceStr6::operator <(const algo::RspaceStr6 &rhs) const {
    return algo::RspaceStr6_Lt(const_cast<algo::RspaceStr6&>(*this),const_cast<algo::RspaceStr6&>(rhs));
}

// --- algo.RspaceStr6..GtOp
inline bool algo::RspaceStr6::operator >(const algo::RspaceStr6 &rhs) const {
    return algo::RspaceStr6_Lt(const_cast<algo::RspaceStr6&>(rhs),const_cast<algo::RspaceStr6&>(*this));
}

// --- algo.RspaceStr6..LeOp
inline bool algo::RspaceStr6::operator <=(const algo::RspaceStr6 &rhs) const {
    return !algo::RspaceStr6_Lt(const_cast<algo::RspaceStr6&>(rhs),const_cast<algo::RspaceStr6&>(*this));
}

// --- algo.RspaceStr6..GeOp
inline bool algo::RspaceStr6::operator >=(const algo::RspaceStr6 &rhs) const {
    return !algo::RspaceStr6_Lt(const_cast<algo::RspaceStr6&>(*this),const_cast<algo::RspaceStr6&>(rhs));
}

// --- algo.RspaceStr6..Lt
inline bool algo::RspaceStr6_Lt(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr6..Cmp
inline i32 algo::RspaceStr6_Cmp(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr6..Init
// Set all fields to initial values.
inline void algo::RspaceStr6_Init(algo::RspaceStr6& parent) {
    memset(parent.ch, ' ', 6);
}

// --- algo.RspaceStr6..Eq
inline bool algo::RspaceStr6_Eq(algo::RspaceStr6 lhs, algo::RspaceStr6 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4);
    return retval;
}

// --- algo.RspaceStr6..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr6_Update(algo::RspaceStr6 &lhs, algo::RspaceStr6 rhs) {
    bool ret = !RspaceStr6_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr6..EqOpAryptr
inline bool algo::RspaceStr6::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr6..AssignOp
inline algo::RspaceStr6& algo::RspaceStr6::operator =(const algo::RspaceStr6 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr6));
    return *this;
}

// --- algo.RspaceStr6..Ctor
inline  algo::RspaceStr6::RspaceStr6() {
    algo::RspaceStr6_Init(*this);
}

// --- algo.RspaceStr6..CopyCtor
inline  algo::RspaceStr6::RspaceStr6(const algo::RspaceStr6 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr6));
}

// --- algo.RspaceStr64.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr64& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr64.ch.HashStrptr
inline u32 algo::RspaceStr64_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr64.ch.Init
inline void algo::ch_Init(algo::RspaceStr64 &parent) {
    memset(parent.ch, ' ', 64);
}

// --- algo.RspaceStr64.ch.Max
// always return constant 64
inline int algo::ch_Max(algo::RspaceStr64& parent) {
    (void)parent;
    return 64;
}

// --- algo.RspaceStr64.ch.N
inline int algo::ch_N(const algo::RspaceStr64& parent) {
    u64 ret;
    ret = 64;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr64.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr64::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr64.ch.CtorStrptr
inline  algo::RspaceStr64::RspaceStr64(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr64.ch.Cast
inline  algo::RspaceStr64::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr64..EqOp
inline bool algo::RspaceStr64::operator ==(const algo::RspaceStr64 &rhs) const {
    return algo::RspaceStr64_Eq(const_cast<algo::RspaceStr64&>(*this),const_cast<algo::RspaceStr64&>(rhs));
}

// --- algo.RspaceStr64..NeOp
inline bool algo::RspaceStr64::operator !=(const algo::RspaceStr64 &rhs) const {
    return !algo::RspaceStr64_Eq(const_cast<algo::RspaceStr64&>(*this),const_cast<algo::RspaceStr64&>(rhs));
}

// --- algo.RspaceStr64..Cmp
inline i32 algo::RspaceStr64_Cmp(algo::RspaceStr64& lhs, algo::RspaceStr64& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr64..Init
// Set all fields to initial values.
inline void algo::RspaceStr64_Init(algo::RspaceStr64& parent) {
    memset(parent.ch, ' ', 64);
}

// --- algo.RspaceStr64..Eq
inline bool algo::RspaceStr64_Eq(algo::RspaceStr64& lhs, algo::RspaceStr64& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56);
    return retval;
}

// --- algo.RspaceStr64..EqOpAryptr
inline bool algo::RspaceStr64::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr64..AssignOp
inline algo::RspaceStr64& algo::RspaceStr64::operator =(const algo::RspaceStr64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr64));
    return *this;
}

// --- algo.RspaceStr64..Ctor
inline  algo::RspaceStr64::RspaceStr64() {
    algo::RspaceStr64_Init(*this);
}

// --- algo.RspaceStr64..CopyCtor
inline  algo::RspaceStr64::RspaceStr64(const algo::RspaceStr64 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr64));
}

// --- algo.RspaceStr7.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr7& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr7.ch.HashStrptr
inline u32 algo::RspaceStr7_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr7.ch.Init
inline void algo::ch_Init(algo::RspaceStr7 &parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.RspaceStr7.ch.Max
// always return constant 7
inline int algo::ch_Max(algo::RspaceStr7& parent) {
    (void)parent;
    return 7;
}

// --- algo.RspaceStr7.ch.N
inline int algo::ch_N(const algo::RspaceStr7& parent) {
    u64 ret;
    ret = 7;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr7.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr7::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr7.ch.CtorStrptr
inline  algo::RspaceStr7::RspaceStr7(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr7.ch.Cast
inline  algo::RspaceStr7::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr7..EqOp
inline bool algo::RspaceStr7::operator ==(const algo::RspaceStr7 &rhs) const {
    return algo::RspaceStr7_Eq(const_cast<algo::RspaceStr7&>(*this),const_cast<algo::RspaceStr7&>(rhs));
}

// --- algo.RspaceStr7..NeOp
inline bool algo::RspaceStr7::operator !=(const algo::RspaceStr7 &rhs) const {
    return !algo::RspaceStr7_Eq(const_cast<algo::RspaceStr7&>(*this),const_cast<algo::RspaceStr7&>(rhs));
}

// --- algo.RspaceStr7..Cmp
inline i32 algo::RspaceStr7_Cmp(algo::RspaceStr7 lhs, algo::RspaceStr7 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr7..Init
// Set all fields to initial values.
inline void algo::RspaceStr7_Init(algo::RspaceStr7& parent) {
    memset(parent.ch, ' ', 7);
}

// --- algo.RspaceStr7..Eq
inline bool algo::RspaceStr7_Eq(algo::RspaceStr7 lhs, algo::RspaceStr7 rhs) {
    bool retval = true;
    retval = retval
    &&*(u32*)(lhs.ch+0) == *(u32*)(rhs.ch+0)
    &&*(u16*)(lhs.ch+4) == *(u16*)(rhs.ch+4)
    &&*(u8*)(lhs.ch+6) == *(u8*)(rhs.ch+6);
    return retval;
}

// --- algo.RspaceStr7..EqOpAryptr
inline bool algo::RspaceStr7::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr7..AssignOp
inline algo::RspaceStr7& algo::RspaceStr7::operator =(const algo::RspaceStr7 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr7));
    return *this;
}

// --- algo.RspaceStr7..Ctor
inline  algo::RspaceStr7::RspaceStr7() {
    algo::RspaceStr7_Init(*this);
}

// --- algo.RspaceStr7..CopyCtor
inline  algo::RspaceStr7::RspaceStr7(const algo::RspaceStr7 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr7));
}

// --- algo.RspaceStr75.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr75& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr75.ch.HashStrptr
inline u32 algo::RspaceStr75_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr75.ch.Init
inline void algo::ch_Init(algo::RspaceStr75 &parent) {
    memset(parent.ch, ' ', 75);
}

// --- algo.RspaceStr75.ch.Max
// always return constant 75
inline int algo::ch_Max(algo::RspaceStr75& parent) {
    (void)parent;
    return 75;
}

// --- algo.RspaceStr75.ch.N
inline int algo::ch_N(const algo::RspaceStr75& parent) {
    u64 ret;
    ret = 75;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr75.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr75::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr75.ch.CtorStrptr
inline  algo::RspaceStr75::RspaceStr75(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr75.ch.Cast
inline  algo::RspaceStr75::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr75..EqOp
inline bool algo::RspaceStr75::operator ==(const algo::RspaceStr75 &rhs) const {
    return algo::RspaceStr75_Eq(const_cast<algo::RspaceStr75&>(*this),const_cast<algo::RspaceStr75&>(rhs));
}

// --- algo.RspaceStr75..NeOp
inline bool algo::RspaceStr75::operator !=(const algo::RspaceStr75 &rhs) const {
    return !algo::RspaceStr75_Eq(const_cast<algo::RspaceStr75&>(*this),const_cast<algo::RspaceStr75&>(rhs));
}

// --- algo.RspaceStr75..Cmp
inline i32 algo::RspaceStr75_Cmp(algo::RspaceStr75 lhs, algo::RspaceStr75 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr75..Init
// Set all fields to initial values.
inline void algo::RspaceStr75_Init(algo::RspaceStr75& parent) {
    memset(parent.ch, ' ', 75);
}

// --- algo.RspaceStr75..Eq
inline bool algo::RspaceStr75_Eq(algo::RspaceStr75 lhs, algo::RspaceStr75 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u64*)(lhs.ch+8) == *(u64*)(rhs.ch+8)
    &&*(u64*)(lhs.ch+16) == *(u64*)(rhs.ch+16)
    &&*(u64*)(lhs.ch+24) == *(u64*)(rhs.ch+24)
    &&*(u64*)(lhs.ch+32) == *(u64*)(rhs.ch+32)
    &&*(u64*)(lhs.ch+40) == *(u64*)(rhs.ch+40)
    &&*(u64*)(lhs.ch+48) == *(u64*)(rhs.ch+48)
    &&*(u64*)(lhs.ch+56) == *(u64*)(rhs.ch+56)
    &&*(u64*)(lhs.ch+64) == *(u64*)(rhs.ch+64)
    &&*(u16*)(lhs.ch+72) == *(u16*)(rhs.ch+72)
    &&*(u8*)(lhs.ch+74) == *(u8*)(rhs.ch+74);
    return retval;
}

// --- algo.RspaceStr75..EqOpAryptr
inline bool algo::RspaceStr75::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr75..AssignOp
inline algo::RspaceStr75& algo::RspaceStr75::operator =(const algo::RspaceStr75 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr75));
    return *this;
}

// --- algo.RspaceStr75..Ctor
inline  algo::RspaceStr75::RspaceStr75() {
    algo::RspaceStr75_Init(*this);
}

// --- algo.RspaceStr75..CopyCtor
inline  algo::RspaceStr75::RspaceStr75(const algo::RspaceStr75 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr75));
}

// --- algo.RspaceStr8.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr8& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr8.ch.HashStrptr
inline u32 algo::RspaceStr8_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr8.ch.Init
inline void algo::ch_Init(algo::RspaceStr8 &parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.RspaceStr8.ch.Max
// always return constant 8
inline int algo::ch_Max(algo::RspaceStr8& parent) {
    (void)parent;
    return 8;
}

// --- algo.RspaceStr8.ch.N
inline int algo::ch_N(const algo::RspaceStr8& parent) {
    u64 ret;
    ret = 8;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr8.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr8::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr8.ch.CtorStrptr
inline  algo::RspaceStr8::RspaceStr8(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr8.ch.Cast
inline  algo::RspaceStr8::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr8..Lt
inline bool algo::RspaceStr8_Lt(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.RspaceStr8..Cmp
inline i32 algo::RspaceStr8_Cmp(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr8..Init
// Set all fields to initial values.
inline void algo::RspaceStr8_Init(algo::RspaceStr8& parent) {
    memset(parent.ch, ' ', 8);
}

// --- algo.RspaceStr8..Eq
inline bool algo::RspaceStr8_Eq(algo::RspaceStr8 lhs, algo::RspaceStr8 rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0);
    return retval;
}

// --- algo.RspaceStr8..Update
// Set value. Return true if new value is different from old value.
inline bool algo::RspaceStr8_Update(algo::RspaceStr8 &lhs, algo::RspaceStr8 rhs) {
    bool ret = !RspaceStr8_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.RspaceStr8..EqOpAryptr
inline bool algo::RspaceStr8::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr8..AssignOp
inline algo::RspaceStr8& algo::RspaceStr8::operator =(const algo::RspaceStr8 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr8));
    return *this;
}

// --- algo.RspaceStr8..Ctor
inline  algo::RspaceStr8::RspaceStr8() {
    algo::RspaceStr8_Init(*this);
}

// --- algo.RspaceStr8..CopyCtor
inline  algo::RspaceStr8::RspaceStr8(const algo::RspaceStr8 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr8));
}

// --- algo.RspaceStr9.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::RspaceStr9& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.RspaceStr9.ch.HashStrptr
inline u32 algo::RspaceStr9_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.RspaceStr9.ch.Init
inline void algo::ch_Init(algo::RspaceStr9 &parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.RspaceStr9.ch.Max
// always return constant 9
inline int algo::ch_Max(algo::RspaceStr9& parent) {
    (void)parent;
    return 9;
}

// --- algo.RspaceStr9.ch.N
inline int algo::ch_N(const algo::RspaceStr9& parent) {
    u64 ret;
    ret = 9;
    while (ret>0 && parent.ch[ret-1]==u8(' ')) {
        ret--;
    }
    return int(ret);
}

// --- algo.RspaceStr9.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::RspaceStr9::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.RspaceStr9.ch.CtorStrptr
inline  algo::RspaceStr9::RspaceStr9(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.RspaceStr9.ch.Cast
inline  algo::RspaceStr9::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.RspaceStr9..EqOp
inline bool algo::RspaceStr9::operator ==(const algo::RspaceStr9 &rhs) const {
    return algo::RspaceStr9_Eq(const_cast<algo::RspaceStr9&>(*this),const_cast<algo::RspaceStr9&>(rhs));
}

// --- algo.RspaceStr9..NeOp
inline bool algo::RspaceStr9::operator !=(const algo::RspaceStr9 &rhs) const {
    return !algo::RspaceStr9_Eq(const_cast<algo::RspaceStr9&>(*this),const_cast<algo::RspaceStr9&>(rhs));
}

// --- algo.RspaceStr9..Cmp
inline i32 algo::RspaceStr9_Cmp(algo::RspaceStr9& lhs, algo::RspaceStr9& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.RspaceStr9..Init
// Set all fields to initial values.
inline void algo::RspaceStr9_Init(algo::RspaceStr9& parent) {
    memset(parent.ch, ' ', 9);
}

// --- algo.RspaceStr9..Eq
inline bool algo::RspaceStr9_Eq(algo::RspaceStr9& lhs, algo::RspaceStr9& rhs) {
    bool retval = true;
    retval = retval
    &&*(u64*)(lhs.ch+0) == *(u64*)(rhs.ch+0)
    &&*(u8*)(lhs.ch+8) == *(u8*)(rhs.ch+8);
    return retval;
}

// --- algo.RspaceStr9..EqOpAryptr
inline bool algo::RspaceStr9::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.RspaceStr9..AssignOp
inline algo::RspaceStr9& algo::RspaceStr9::operator =(const algo::RspaceStr9 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr9));
    return *this;
}

// --- algo.RspaceStr9..Ctor
inline  algo::RspaceStr9::RspaceStr9() {
    algo::RspaceStr9_Init(*this);
}

// --- algo.RspaceStr9..CopyCtor
inline  algo::RspaceStr9::RspaceStr9(const algo::RspaceStr9 &rhs) {
    // type is plaindata, with no holes, copying as memory
    memcpy(this,&rhs,sizeof(algo::RspaceStr9));
}

// --- algo.SchedTime.value.Cast
inline  algo::SchedTime::operator u64() const {
    return u64((*this).value);
}

// --- algo.SchedTime..Lt
inline bool algo::SchedTime_Lt(algo::SchedTime lhs, algo::SchedTime rhs) {
    return u64_Lt(lhs.value, rhs.value);
}

// --- algo.SchedTime..Cmp
inline i32 algo::SchedTime_Cmp(algo::SchedTime lhs, algo::SchedTime rhs) {
    i32 retval = 0;
    retval = u64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.SchedTime..Init
// Set all fields to initial values.
inline void algo::SchedTime_Init(algo::SchedTime& parent) {
    parent.value = u64(0);
}

// --- algo.SchedTime..Eq
inline bool algo::SchedTime_Eq(algo::SchedTime lhs, algo::SchedTime rhs) {
    bool retval = true;
    retval = u64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.SchedTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::SchedTime_Update(algo::SchedTime &lhs, algo::SchedTime rhs) {
    bool ret = !SchedTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.SchedTime..Ctor
inline  algo::SchedTime::SchedTime() {
    algo::SchedTime_Init(*this);
}

// --- algo.SchedTime..FieldwiseCtor
inline  algo::SchedTime::SchedTime(u64 in_value)
    : value(in_value)
 {
}

// --- algo.SeqType.value.Cast
inline  algo::SeqType::operator u64() const {
    return u64((*this).value);
}

// --- algo.SeqType..Hash
inline u32 algo::SeqType_Hash(u32 prev, algo::SeqType rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.SeqType..Lt
inline bool algo::SeqType_Lt(algo::SeqType lhs, algo::SeqType rhs) {
    return u64_Lt(lhs.value, rhs.value);
}

// --- algo.SeqType..Cmp
inline i32 algo::SeqType_Cmp(algo::SeqType lhs, algo::SeqType rhs) {
    i32 retval = 0;
    retval = u64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.SeqType..Init
// Set all fields to initial values.
inline void algo::SeqType_Init(algo::SeqType& parent) {
    parent.value = u64(0);
}

// --- algo.SeqType..Eq
inline bool algo::SeqType_Eq(algo::SeqType lhs, algo::SeqType rhs) {
    bool retval = true;
    retval = u64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.SeqType..Update
// Set value. Return true if new value is different from old value.
inline bool algo::SeqType_Update(algo::SeqType &lhs, algo::SeqType rhs) {
    bool ret = !SeqType_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.SeqType..Ctor
inline  algo::SeqType::SeqType() {
    algo::SeqType_Init(*this);
}

// --- algo.SeqType..FieldwiseCtor
inline  algo::SeqType::SeqType(u64 in_value)
    : value(in_value)
 {
}

// --- algo.Sha1sig.sha1sig.Fill
// Set all elements of fixed array to value RHS
inline void algo::sha1sig_Fill(algo::Sha1sig& parent, const u8 &rhs) {
    for (int i = 0; i < 20; i++) {
        parent.sha1sig_elems[i] = rhs;
    }
}

// --- algo.Sha1sig.sha1sig.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::sha1sig_Find(algo::Sha1sig& parent, u64 t) {
    u64 idx = t;
    u64 lim = 20;
    return idx < lim ? parent.sha1sig_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Sha1sig.sha1sig.Getary
// Access fixed array sha1sig as aryptr.
inline algo::aryptr<u8> algo::sha1sig_Getary(algo::Sha1sig& parent) {
    return algo::aryptr<u8>(parent.sha1sig_elems, 20);
}

// --- algo.Sha1sig.sha1sig.Max
// Return max number of items in the array
inline i32 algo::sha1sig_Max(algo::Sha1sig& parent) {
    (void)parent;
    return 20;
}

// --- algo.Sha1sig.sha1sig.N
// Return number of items in the array
inline i32 algo::sha1sig_N(const algo::Sha1sig& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 20;
}

// --- algo.Sha1sig.sha1sig.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::sha1sig_Setary(algo::Sha1sig& parent, const algo::aryptr<u8> &rhs) {
    int n = i32_Min(20, rhs.n_elems);
    memcpy(parent.sha1sig_elems, rhs.elems, sizeof(u8)*n);
}

// --- algo.Sha1sig.sha1sig.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u8& algo::sha1sig_qFind(algo::Sha1sig& parent, u64 t) {
    return parent.sha1sig_elems[u64(t)];
}

// --- algo.Sha1sig.sha1sig_curs.Reset
// cursor points to valid item
inline void algo::Sha1sig_sha1sig_curs_Reset(Sha1sig_sha1sig_curs &curs, algo::Sha1sig &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Sha1sig.sha1sig_curs.ValidQ
// cursor points to valid item
inline bool algo::Sha1sig_sha1sig_curs_ValidQ(Sha1sig_sha1sig_curs &curs) {
    return u64(curs.index) < u64(20);
}

// --- algo.Sha1sig.sha1sig_curs.Next
// proceed to next item
inline void algo::Sha1sig_sha1sig_curs_Next(Sha1sig_sha1sig_curs &curs) {
    curs.index++;
}

// --- algo.Sha1sig.sha1sig_curs.Access
// item access
inline u8& algo::Sha1sig_sha1sig_curs_Access(Sha1sig_sha1sig_curs &curs) {
    return sha1sig_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Sha1sig..EqOp
inline bool algo::Sha1sig::operator ==(const algo::Sha1sig &rhs) const {
    return algo::Sha1sig_Eq(const_cast<algo::Sha1sig&>(*this),const_cast<algo::Sha1sig&>(rhs));
}

// --- algo.Sha1sig..NeOp
inline bool algo::Sha1sig::operator !=(const algo::Sha1sig &rhs) const {
    return !algo::Sha1sig_Eq(const_cast<algo::Sha1sig&>(*this),const_cast<algo::Sha1sig&>(rhs));
}

// --- algo.Sha1sig..LtOp
inline bool algo::Sha1sig::operator <(const algo::Sha1sig &rhs) const {
    return algo::Sha1sig_Lt(const_cast<algo::Sha1sig&>(*this),const_cast<algo::Sha1sig&>(rhs));
}

// --- algo.Sha1sig..GtOp
inline bool algo::Sha1sig::operator >(const algo::Sha1sig &rhs) const {
    return algo::Sha1sig_Lt(const_cast<algo::Sha1sig&>(rhs),const_cast<algo::Sha1sig&>(*this));
}

// --- algo.Sha1sig..LeOp
inline bool algo::Sha1sig::operator <=(const algo::Sha1sig &rhs) const {
    return !algo::Sha1sig_Lt(const_cast<algo::Sha1sig&>(rhs),const_cast<algo::Sha1sig&>(*this));
}

// --- algo.Sha1sig..GeOp
inline bool algo::Sha1sig::operator >=(const algo::Sha1sig &rhs) const {
    return !algo::Sha1sig_Lt(const_cast<algo::Sha1sig&>(*this),const_cast<algo::Sha1sig&>(rhs));
}

// --- algo.Sha1sig..Lt
inline bool algo::Sha1sig_Lt(algo::Sha1sig& lhs, algo::Sha1sig& rhs) {
    return sha1sig_Cmp(lhs,rhs) < 0;
}

// --- algo.Sha1sig..Cmp
inline i32 algo::Sha1sig_Cmp(algo::Sha1sig& lhs, algo::Sha1sig& rhs) {
    i32 retval = 0;
    retval = sha1sig_Cmp(lhs,rhs);
    return retval;
}

// --- algo.Sha1sig..Init
// Set all fields to initial values.
inline void algo::Sha1sig_Init(algo::Sha1sig& parent) {
    for (int i = 0; i < 20; i++) {
        parent.sha1sig_elems[i] = 0;
    }
}

// --- algo.Sha1sig..Eq
inline bool algo::Sha1sig_Eq(algo::Sha1sig& lhs, algo::Sha1sig& rhs) {
    bool retval = true;
    retval = sha1sig_Eq(lhs,rhs);
    return retval;
}

// --- algo.Sha1sig..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Sha1sig_Update(algo::Sha1sig &lhs, algo::Sha1sig& rhs) {
    bool ret = !Sha1sig_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Sha1sig..Ctor
inline  algo::Sha1sig::Sha1sig() {
    algo::Sha1sig_Init(*this);
}

// --- algo.Smallstr1.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr1& parent, char c) {
    if (parent.n_ch < 1) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr1.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr1& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 1) {
        n_new = 1 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr1.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr1& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr1.ch.HashStrptr
inline u32 algo::Smallstr1_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr1.ch.Init
inline void algo::ch_Init(algo::Smallstr1 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr1.ch.Max
// always return constant 1
inline int algo::ch_Max(algo::Smallstr1& parent) {
    (void)parent;
    return 1;
}

// --- algo.Smallstr1.ch.N
inline int algo::ch_N(const algo::Smallstr1& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr1.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr1::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr1.ch.CtorStrptr
inline  algo::Smallstr1::Smallstr1(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr1.ch.Cast
inline  algo::Smallstr1::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr1..EqOp
inline bool algo::Smallstr1::operator ==(const algo::Smallstr1 &rhs) const {
    return algo::Smallstr1_Eq(const_cast<algo::Smallstr1&>(*this),const_cast<algo::Smallstr1&>(rhs));
}

// --- algo.Smallstr1..NeOp
inline bool algo::Smallstr1::operator !=(const algo::Smallstr1 &rhs) const {
    return !algo::Smallstr1_Eq(const_cast<algo::Smallstr1&>(*this),const_cast<algo::Smallstr1&>(rhs));
}

// --- algo.Smallstr1..Cmp
inline i32 algo::Smallstr1_Cmp(algo::Smallstr1& lhs, algo::Smallstr1& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr1..Init
// Set all fields to initial values.
inline void algo::Smallstr1_Init(algo::Smallstr1& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr1..Eq
inline bool algo::Smallstr1_Eq(algo::Smallstr1& lhs, algo::Smallstr1& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr1..EqOpAryptr
inline bool algo::Smallstr1::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr1..AssignOp
inline algo::Smallstr1& algo::Smallstr1::operator =(const algo::Smallstr1 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr1..Ctor
inline  algo::Smallstr1::Smallstr1() {
    algo::Smallstr1_Init(*this);
}

// --- algo.Smallstr1..CopyCtor
inline  algo::Smallstr1::Smallstr1(const algo::Smallstr1 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr10.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr10& parent, char c) {
    if (parent.n_ch < 10) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr10.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr10& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 10) {
        n_new = 10 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr10.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr10& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr10.ch.HashStrptr
inline u32 algo::Smallstr10_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr10.ch.Init
inline void algo::ch_Init(algo::Smallstr10 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr10.ch.Max
// always return constant 10
inline int algo::ch_Max(algo::Smallstr10& parent) {
    (void)parent;
    return 10;
}

// --- algo.Smallstr10.ch.N
inline int algo::ch_N(const algo::Smallstr10& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr10.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr10::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr10.ch.CtorStrptr
inline  algo::Smallstr10::Smallstr10(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr10.ch.Cast
inline  algo::Smallstr10::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr10..EqOp
inline bool algo::Smallstr10::operator ==(const algo::Smallstr10 &rhs) const {
    return algo::Smallstr10_Eq(const_cast<algo::Smallstr10&>(*this),const_cast<algo::Smallstr10&>(rhs));
}

// --- algo.Smallstr10..NeOp
inline bool algo::Smallstr10::operator !=(const algo::Smallstr10 &rhs) const {
    return !algo::Smallstr10_Eq(const_cast<algo::Smallstr10&>(*this),const_cast<algo::Smallstr10&>(rhs));
}

// --- algo.Smallstr10..Cmp
inline i32 algo::Smallstr10_Cmp(algo::Smallstr10& lhs, algo::Smallstr10& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr10..Init
// Set all fields to initial values.
inline void algo::Smallstr10_Init(algo::Smallstr10& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr10..Eq
inline bool algo::Smallstr10_Eq(algo::Smallstr10& lhs, algo::Smallstr10& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr10..EqOpAryptr
inline bool algo::Smallstr10::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr10..AssignOp
inline algo::Smallstr10& algo::Smallstr10::operator =(const algo::Smallstr10 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr10..Ctor
inline  algo::Smallstr10::Smallstr10() {
    algo::Smallstr10_Init(*this);
}

// --- algo.Smallstr10..CopyCtor
inline  algo::Smallstr10::Smallstr10(const algo::Smallstr10 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr16.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr16& parent, char c) {
    if (parent.n_ch < 16) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr16.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr16& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 16) {
        n_new = 16 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr16.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr16& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr16.ch.HashStrptr
inline u32 algo::Smallstr16_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr16.ch.Init
inline void algo::ch_Init(algo::Smallstr16 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr16.ch.Max
// always return constant 16
inline int algo::ch_Max(algo::Smallstr16& parent) {
    (void)parent;
    return 16;
}

// --- algo.Smallstr16.ch.N
inline int algo::ch_N(const algo::Smallstr16& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr16.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr16::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr16.ch.CtorStrptr
inline  algo::Smallstr16::Smallstr16(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr16.ch.Cast
inline  algo::Smallstr16::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr16..EqOp
inline bool algo::Smallstr16::operator ==(const algo::Smallstr16 &rhs) const {
    return algo::Smallstr16_Eq(const_cast<algo::Smallstr16&>(*this),const_cast<algo::Smallstr16&>(rhs));
}

// --- algo.Smallstr16..NeOp
inline bool algo::Smallstr16::operator !=(const algo::Smallstr16 &rhs) const {
    return !algo::Smallstr16_Eq(const_cast<algo::Smallstr16&>(*this),const_cast<algo::Smallstr16&>(rhs));
}

// --- algo.Smallstr16..Cmp
inline i32 algo::Smallstr16_Cmp(algo::Smallstr16& lhs, algo::Smallstr16& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr16..Init
// Set all fields to initial values.
inline void algo::Smallstr16_Init(algo::Smallstr16& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr16..Eq
inline bool algo::Smallstr16_Eq(algo::Smallstr16& lhs, algo::Smallstr16& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr16..EqOpAryptr
inline bool algo::Smallstr16::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr16..AssignOp
inline algo::Smallstr16& algo::Smallstr16::operator =(const algo::Smallstr16 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr16..Ctor
inline  algo::Smallstr16::Smallstr16() {
    algo::Smallstr16_Init(*this);
}

// --- algo.Smallstr16..CopyCtor
inline  algo::Smallstr16::Smallstr16(const algo::Smallstr16 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr2.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr2& parent, char c) {
    if (parent.n_ch < 2) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr2.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr2& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 2) {
        n_new = 2 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr2.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr2& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr2.ch.HashStrptr
inline u32 algo::Smallstr2_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr2.ch.Init
inline void algo::ch_Init(algo::Smallstr2 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr2.ch.Max
// always return constant 2
inline int algo::ch_Max(algo::Smallstr2& parent) {
    (void)parent;
    return 2;
}

// --- algo.Smallstr2.ch.N
inline int algo::ch_N(const algo::Smallstr2& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr2.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr2::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr2.ch.CtorStrptr
inline  algo::Smallstr2::Smallstr2(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr2.ch.Cast
inline  algo::Smallstr2::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr2..EqOp
inline bool algo::Smallstr2::operator ==(const algo::Smallstr2 &rhs) const {
    return algo::Smallstr2_Eq(const_cast<algo::Smallstr2&>(*this),const_cast<algo::Smallstr2&>(rhs));
}

// --- algo.Smallstr2..NeOp
inline bool algo::Smallstr2::operator !=(const algo::Smallstr2 &rhs) const {
    return !algo::Smallstr2_Eq(const_cast<algo::Smallstr2&>(*this),const_cast<algo::Smallstr2&>(rhs));
}

// --- algo.Smallstr2..Cmp
inline i32 algo::Smallstr2_Cmp(algo::Smallstr2& lhs, algo::Smallstr2& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr2..Init
// Set all fields to initial values.
inline void algo::Smallstr2_Init(algo::Smallstr2& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr2..Eq
inline bool algo::Smallstr2_Eq(algo::Smallstr2& lhs, algo::Smallstr2& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr2..EqOpAryptr
inline bool algo::Smallstr2::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr2..AssignOp
inline algo::Smallstr2& algo::Smallstr2::operator =(const algo::Smallstr2 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr2..Ctor
inline  algo::Smallstr2::Smallstr2() {
    algo::Smallstr2_Init(*this);
}

// --- algo.Smallstr2..CopyCtor
inline  algo::Smallstr2::Smallstr2(const algo::Smallstr2 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr20.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr20& parent, char c) {
    if (parent.n_ch < 20) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr20.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr20& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 20) {
        n_new = 20 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr20.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr20& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr20.ch.HashStrptr
inline u32 algo::Smallstr20_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr20.ch.Init
inline void algo::ch_Init(algo::Smallstr20 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr20.ch.Max
// always return constant 20
inline int algo::ch_Max(algo::Smallstr20& parent) {
    (void)parent;
    return 20;
}

// --- algo.Smallstr20.ch.N
inline int algo::ch_N(const algo::Smallstr20& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr20.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr20::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr20.ch.CtorStrptr
inline  algo::Smallstr20::Smallstr20(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr20.ch.Cast
inline  algo::Smallstr20::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr20..EqOp
inline bool algo::Smallstr20::operator ==(const algo::Smallstr20 &rhs) const {
    return algo::Smallstr20_Eq(const_cast<algo::Smallstr20&>(*this),const_cast<algo::Smallstr20&>(rhs));
}

// --- algo.Smallstr20..NeOp
inline bool algo::Smallstr20::operator !=(const algo::Smallstr20 &rhs) const {
    return !algo::Smallstr20_Eq(const_cast<algo::Smallstr20&>(*this),const_cast<algo::Smallstr20&>(rhs));
}

// --- algo.Smallstr20..LtOp
inline bool algo::Smallstr20::operator <(const algo::Smallstr20 &rhs) const {
    return algo::Smallstr20_Lt(const_cast<algo::Smallstr20&>(*this),const_cast<algo::Smallstr20&>(rhs));
}

// --- algo.Smallstr20..GtOp
inline bool algo::Smallstr20::operator >(const algo::Smallstr20 &rhs) const {
    return algo::Smallstr20_Lt(const_cast<algo::Smallstr20&>(rhs),const_cast<algo::Smallstr20&>(*this));
}

// --- algo.Smallstr20..LeOp
inline bool algo::Smallstr20::operator <=(const algo::Smallstr20 &rhs) const {
    return !algo::Smallstr20_Lt(const_cast<algo::Smallstr20&>(rhs),const_cast<algo::Smallstr20&>(*this));
}

// --- algo.Smallstr20..GeOp
inline bool algo::Smallstr20::operator >=(const algo::Smallstr20 &rhs) const {
    return !algo::Smallstr20_Lt(const_cast<algo::Smallstr20&>(*this),const_cast<algo::Smallstr20&>(rhs));
}

// --- algo.Smallstr20..Lt
inline bool algo::Smallstr20_Lt(algo::Smallstr20& lhs, algo::Smallstr20& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.Smallstr20..Cmp
inline i32 algo::Smallstr20_Cmp(algo::Smallstr20& lhs, algo::Smallstr20& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr20..Init
// Set all fields to initial values.
inline void algo::Smallstr20_Init(algo::Smallstr20& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr20..Eq
inline bool algo::Smallstr20_Eq(algo::Smallstr20& lhs, algo::Smallstr20& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr20..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Smallstr20_Update(algo::Smallstr20 &lhs, algo::Smallstr20& rhs) {
    bool ret = !Smallstr20_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Smallstr20..EqOpAryptr
inline bool algo::Smallstr20::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr20..AssignOp
inline algo::Smallstr20& algo::Smallstr20::operator =(const algo::Smallstr20 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr20..Ctor
inline  algo::Smallstr20::Smallstr20() {
    algo::Smallstr20_Init(*this);
}

// --- algo.Smallstr20..CopyCtor
inline  algo::Smallstr20::Smallstr20(const algo::Smallstr20 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr200.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr200& parent, char c) {
    if (parent.n_ch < 200) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr200.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr200& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 200) {
        n_new = 200 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr200.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr200& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr200.ch.HashStrptr
inline u32 algo::Smallstr200_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr200.ch.Init
inline void algo::ch_Init(algo::Smallstr200 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr200.ch.Max
// always return constant 200
inline int algo::ch_Max(algo::Smallstr200& parent) {
    (void)parent;
    return 200;
}

// --- algo.Smallstr200.ch.N
inline int algo::ch_N(const algo::Smallstr200& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr200.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr200::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr200.ch.CtorStrptr
inline  algo::Smallstr200::Smallstr200(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr200.ch.Cast
inline  algo::Smallstr200::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr200..EqOp
inline bool algo::Smallstr200::operator ==(const algo::Smallstr200 &rhs) const {
    return algo::Smallstr200_Eq(const_cast<algo::Smallstr200&>(*this),const_cast<algo::Smallstr200&>(rhs));
}

// --- algo.Smallstr200..NeOp
inline bool algo::Smallstr200::operator !=(const algo::Smallstr200 &rhs) const {
    return !algo::Smallstr200_Eq(const_cast<algo::Smallstr200&>(*this),const_cast<algo::Smallstr200&>(rhs));
}

// --- algo.Smallstr200..Cmp
inline i32 algo::Smallstr200_Cmp(algo::Smallstr200& lhs, algo::Smallstr200& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr200..Init
// Set all fields to initial values.
inline void algo::Smallstr200_Init(algo::Smallstr200& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr200..Eq
inline bool algo::Smallstr200_Eq(algo::Smallstr200& lhs, algo::Smallstr200& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr200..EqOpAryptr
inline bool algo::Smallstr200::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr200..AssignOp
inline algo::Smallstr200& algo::Smallstr200::operator =(const algo::Smallstr200 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr200..Ctor
inline  algo::Smallstr200::Smallstr200() {
    algo::Smallstr200_Init(*this);
}

// --- algo.Smallstr200..CopyCtor
inline  algo::Smallstr200::Smallstr200(const algo::Smallstr200 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr25.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr25& parent, char c) {
    if (parent.n_ch < 25) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr25.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr25& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 25) {
        n_new = 25 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr25.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr25& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr25.ch.HashStrptr
inline u32 algo::Smallstr25_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr25.ch.Init
inline void algo::ch_Init(algo::Smallstr25 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr25.ch.Max
// always return constant 25
inline int algo::ch_Max(algo::Smallstr25& parent) {
    (void)parent;
    return 25;
}

// --- algo.Smallstr25.ch.N
inline int algo::ch_N(const algo::Smallstr25& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr25.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr25::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr25.ch.CtorStrptr
inline  algo::Smallstr25::Smallstr25(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr25.ch.Cast
inline  algo::Smallstr25::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr25..EqOp
inline bool algo::Smallstr25::operator ==(const algo::Smallstr25 &rhs) const {
    return algo::Smallstr25_Eq(const_cast<algo::Smallstr25&>(*this),const_cast<algo::Smallstr25&>(rhs));
}

// --- algo.Smallstr25..NeOp
inline bool algo::Smallstr25::operator !=(const algo::Smallstr25 &rhs) const {
    return !algo::Smallstr25_Eq(const_cast<algo::Smallstr25&>(*this),const_cast<algo::Smallstr25&>(rhs));
}

// --- algo.Smallstr25..Cmp
inline i32 algo::Smallstr25_Cmp(algo::Smallstr25& lhs, algo::Smallstr25& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr25..Init
// Set all fields to initial values.
inline void algo::Smallstr25_Init(algo::Smallstr25& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr25..Eq
inline bool algo::Smallstr25_Eq(algo::Smallstr25& lhs, algo::Smallstr25& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr25..EqOpAryptr
inline bool algo::Smallstr25::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr25..AssignOp
inline algo::Smallstr25& algo::Smallstr25::operator =(const algo::Smallstr25 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr25..Ctor
inline  algo::Smallstr25::Smallstr25() {
    algo::Smallstr25_Init(*this);
}

// --- algo.Smallstr25..CopyCtor
inline  algo::Smallstr25::Smallstr25(const algo::Smallstr25 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr3.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr3& parent, char c) {
    if (parent.n_ch < 3) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr3.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr3& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 3) {
        n_new = 3 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr3.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr3& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr3.ch.HashStrptr
inline u32 algo::Smallstr3_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr3.ch.Init
inline void algo::ch_Init(algo::Smallstr3 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr3.ch.Max
// always return constant 3
inline int algo::ch_Max(algo::Smallstr3& parent) {
    (void)parent;
    return 3;
}

// --- algo.Smallstr3.ch.N
inline int algo::ch_N(const algo::Smallstr3& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr3.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr3::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr3.ch.CtorStrptr
inline  algo::Smallstr3::Smallstr3(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr3.ch.Cast
inline  algo::Smallstr3::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr3..EqOp
inline bool algo::Smallstr3::operator ==(const algo::Smallstr3 &rhs) const {
    return algo::Smallstr3_Eq(const_cast<algo::Smallstr3&>(*this),const_cast<algo::Smallstr3&>(rhs));
}

// --- algo.Smallstr3..NeOp
inline bool algo::Smallstr3::operator !=(const algo::Smallstr3 &rhs) const {
    return !algo::Smallstr3_Eq(const_cast<algo::Smallstr3&>(*this),const_cast<algo::Smallstr3&>(rhs));
}

// --- algo.Smallstr3..Cmp
inline i32 algo::Smallstr3_Cmp(algo::Smallstr3& lhs, algo::Smallstr3& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr3..Init
// Set all fields to initial values.
inline void algo::Smallstr3_Init(algo::Smallstr3& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr3..Eq
inline bool algo::Smallstr3_Eq(algo::Smallstr3& lhs, algo::Smallstr3& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr3..EqOpAryptr
inline bool algo::Smallstr3::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr3..AssignOp
inline algo::Smallstr3& algo::Smallstr3::operator =(const algo::Smallstr3 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr3..Ctor
inline  algo::Smallstr3::Smallstr3() {
    algo::Smallstr3_Init(*this);
}

// --- algo.Smallstr3..CopyCtor
inline  algo::Smallstr3::Smallstr3(const algo::Smallstr3 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr30.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr30& parent, char c) {
    if (parent.n_ch < 30) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr30.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr30& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 30) {
        n_new = 30 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr30.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr30& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr30.ch.HashStrptr
inline u32 algo::Smallstr30_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr30.ch.Init
inline void algo::ch_Init(algo::Smallstr30 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr30.ch.Max
// always return constant 30
inline int algo::ch_Max(algo::Smallstr30& parent) {
    (void)parent;
    return 30;
}

// --- algo.Smallstr30.ch.N
inline int algo::ch_N(const algo::Smallstr30& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr30.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr30::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr30.ch.CtorStrptr
inline  algo::Smallstr30::Smallstr30(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr30.ch.Cast
inline  algo::Smallstr30::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr30..EqOp
inline bool algo::Smallstr30::operator ==(const algo::Smallstr30 &rhs) const {
    return algo::Smallstr30_Eq(const_cast<algo::Smallstr30&>(*this),const_cast<algo::Smallstr30&>(rhs));
}

// --- algo.Smallstr30..NeOp
inline bool algo::Smallstr30::operator !=(const algo::Smallstr30 &rhs) const {
    return !algo::Smallstr30_Eq(const_cast<algo::Smallstr30&>(*this),const_cast<algo::Smallstr30&>(rhs));
}

// --- algo.Smallstr30..LtOp
inline bool algo::Smallstr30::operator <(const algo::Smallstr30 &rhs) const {
    return algo::Smallstr30_Lt(const_cast<algo::Smallstr30&>(*this),const_cast<algo::Smallstr30&>(rhs));
}

// --- algo.Smallstr30..GtOp
inline bool algo::Smallstr30::operator >(const algo::Smallstr30 &rhs) const {
    return algo::Smallstr30_Lt(const_cast<algo::Smallstr30&>(rhs),const_cast<algo::Smallstr30&>(*this));
}

// --- algo.Smallstr30..LeOp
inline bool algo::Smallstr30::operator <=(const algo::Smallstr30 &rhs) const {
    return !algo::Smallstr30_Lt(const_cast<algo::Smallstr30&>(rhs),const_cast<algo::Smallstr30&>(*this));
}

// --- algo.Smallstr30..GeOp
inline bool algo::Smallstr30::operator >=(const algo::Smallstr30 &rhs) const {
    return !algo::Smallstr30_Lt(const_cast<algo::Smallstr30&>(*this),const_cast<algo::Smallstr30&>(rhs));
}

// --- algo.Smallstr30..Lt
inline bool algo::Smallstr30_Lt(algo::Smallstr30& lhs, algo::Smallstr30& rhs) {
    return algo::strptr_Lt(ch_Getary(lhs), ch_Getary(rhs));
}

// --- algo.Smallstr30..Cmp
inline i32 algo::Smallstr30_Cmp(algo::Smallstr30& lhs, algo::Smallstr30& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr30..Init
// Set all fields to initial values.
inline void algo::Smallstr30_Init(algo::Smallstr30& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr30..Eq
inline bool algo::Smallstr30_Eq(algo::Smallstr30& lhs, algo::Smallstr30& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr30..Update
// Set value. Return true if new value is different from old value.
inline bool algo::Smallstr30_Update(algo::Smallstr30 &lhs, algo::Smallstr30& rhs) {
    bool ret = !Smallstr30_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.Smallstr30..EqOpAryptr
inline bool algo::Smallstr30::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr30..AssignOp
inline algo::Smallstr30& algo::Smallstr30::operator =(const algo::Smallstr30 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr30..Ctor
inline  algo::Smallstr30::Smallstr30() {
    algo::Smallstr30_Init(*this);
}

// --- algo.Smallstr30..CopyCtor
inline  algo::Smallstr30::Smallstr30(const algo::Smallstr30 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr32.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr32& parent, char c) {
    if (parent.n_ch < 32) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr32.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr32& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 32) {
        n_new = 32 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr32.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr32& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr32.ch.HashStrptr
inline u32 algo::Smallstr32_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr32.ch.Init
inline void algo::ch_Init(algo::Smallstr32 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr32.ch.Max
// always return constant 32
inline int algo::ch_Max(algo::Smallstr32& parent) {
    (void)parent;
    return 32;
}

// --- algo.Smallstr32.ch.N
inline int algo::ch_N(const algo::Smallstr32& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr32.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr32::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr32.ch.CtorStrptr
inline  algo::Smallstr32::Smallstr32(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr32.ch.Cast
inline  algo::Smallstr32::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr32..EqOp
inline bool algo::Smallstr32::operator ==(const algo::Smallstr32 &rhs) const {
    return algo::Smallstr32_Eq(const_cast<algo::Smallstr32&>(*this),const_cast<algo::Smallstr32&>(rhs));
}

// --- algo.Smallstr32..NeOp
inline bool algo::Smallstr32::operator !=(const algo::Smallstr32 &rhs) const {
    return !algo::Smallstr32_Eq(const_cast<algo::Smallstr32&>(*this),const_cast<algo::Smallstr32&>(rhs));
}

// --- algo.Smallstr32..Cmp
inline i32 algo::Smallstr32_Cmp(algo::Smallstr32& lhs, algo::Smallstr32& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr32..Init
// Set all fields to initial values.
inline void algo::Smallstr32_Init(algo::Smallstr32& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr32..Eq
inline bool algo::Smallstr32_Eq(algo::Smallstr32& lhs, algo::Smallstr32& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr32..EqOpAryptr
inline bool algo::Smallstr32::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr32..AssignOp
inline algo::Smallstr32& algo::Smallstr32::operator =(const algo::Smallstr32 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr32..Ctor
inline  algo::Smallstr32::Smallstr32() {
    algo::Smallstr32_Init(*this);
}

// --- algo.Smallstr32..CopyCtor
inline  algo::Smallstr32::Smallstr32(const algo::Smallstr32 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr4.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr4& parent, char c) {
    if (parent.n_ch < 4) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr4.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr4& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 4) {
        n_new = 4 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr4.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr4& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr4.ch.HashStrptr
inline u32 algo::Smallstr4_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr4.ch.Init
inline void algo::ch_Init(algo::Smallstr4 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr4.ch.Max
// always return constant 4
inline int algo::ch_Max(algo::Smallstr4& parent) {
    (void)parent;
    return 4;
}

// --- algo.Smallstr4.ch.N
inline int algo::ch_N(const algo::Smallstr4& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr4.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr4::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr4.ch.CtorStrptr
inline  algo::Smallstr4::Smallstr4(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr4.ch.Cast
inline  algo::Smallstr4::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr4..EqOp
inline bool algo::Smallstr4::operator ==(const algo::Smallstr4 &rhs) const {
    return algo::Smallstr4_Eq(const_cast<algo::Smallstr4&>(*this),const_cast<algo::Smallstr4&>(rhs));
}

// --- algo.Smallstr4..NeOp
inline bool algo::Smallstr4::operator !=(const algo::Smallstr4 &rhs) const {
    return !algo::Smallstr4_Eq(const_cast<algo::Smallstr4&>(*this),const_cast<algo::Smallstr4&>(rhs));
}

// --- algo.Smallstr4..Cmp
inline i32 algo::Smallstr4_Cmp(algo::Smallstr4& lhs, algo::Smallstr4& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr4..Init
// Set all fields to initial values.
inline void algo::Smallstr4_Init(algo::Smallstr4& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr4..Eq
inline bool algo::Smallstr4_Eq(algo::Smallstr4& lhs, algo::Smallstr4& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr4..EqOpAryptr
inline bool algo::Smallstr4::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr4..AssignOp
inline algo::Smallstr4& algo::Smallstr4::operator =(const algo::Smallstr4 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr4..Ctor
inline  algo::Smallstr4::Smallstr4() {
    algo::Smallstr4_Init(*this);
}

// --- algo.Smallstr4..CopyCtor
inline  algo::Smallstr4::Smallstr4(const algo::Smallstr4 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr40.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr40& parent, char c) {
    if (parent.n_ch < 40) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr40.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr40& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 40) {
        n_new = 40 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr40.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr40& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr40.ch.HashStrptr
inline u32 algo::Smallstr40_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr40.ch.Init
inline void algo::ch_Init(algo::Smallstr40 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr40.ch.Max
// always return constant 40
inline int algo::ch_Max(algo::Smallstr40& parent) {
    (void)parent;
    return 40;
}

// --- algo.Smallstr40.ch.N
inline int algo::ch_N(const algo::Smallstr40& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr40.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr40::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr40.ch.CtorStrptr
inline  algo::Smallstr40::Smallstr40(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr40.ch.Cast
inline  algo::Smallstr40::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr40..EqOp
inline bool algo::Smallstr40::operator ==(const algo::Smallstr40 &rhs) const {
    return algo::Smallstr40_Eq(const_cast<algo::Smallstr40&>(*this),const_cast<algo::Smallstr40&>(rhs));
}

// --- algo.Smallstr40..NeOp
inline bool algo::Smallstr40::operator !=(const algo::Smallstr40 &rhs) const {
    return !algo::Smallstr40_Eq(const_cast<algo::Smallstr40&>(*this),const_cast<algo::Smallstr40&>(rhs));
}

// --- algo.Smallstr40..Cmp
inline i32 algo::Smallstr40_Cmp(algo::Smallstr40& lhs, algo::Smallstr40& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr40..Init
// Set all fields to initial values.
inline void algo::Smallstr40_Init(algo::Smallstr40& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr40..Eq
inline bool algo::Smallstr40_Eq(algo::Smallstr40& lhs, algo::Smallstr40& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr40..EqOpAryptr
inline bool algo::Smallstr40::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr40..AssignOp
inline algo::Smallstr40& algo::Smallstr40::operator =(const algo::Smallstr40 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr40..Ctor
inline  algo::Smallstr40::Smallstr40() {
    algo::Smallstr40_Init(*this);
}

// --- algo.Smallstr40..CopyCtor
inline  algo::Smallstr40::Smallstr40(const algo::Smallstr40 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.Smallstr5.ch.Add
// Append character to string.
// If there is no space for an extra character, do nothing.
inline void algo::ch_Add(algo::Smallstr5& parent, char c) {
    if (parent.n_ch < 5) {
        parent.ch[parent.n_ch++] = c;
    }
}

// --- algo.Smallstr5.ch.AddStrptr
// Append string to this string.
// If there is no space for an extra character, trim.
// If there is no space left, dump core in debug mode.
inline void algo::ch_AddStrptr(algo::Smallstr5& parent, algo::strptr str) {
    int n_new = str.n_elems;
    if (parent.n_ch + n_new > 5) {
        n_new = 5 - parent.n_ch;
    }
    memcpy(parent.ch + parent.n_ch, str.elems, n_new);
    parent.n_ch = u8(parent.n_ch + n_new);
}

// --- algo.Smallstr5.ch.Getary
// Access string as array of chars
inline algo::aryptr<char> algo::ch_Getary(const algo::Smallstr5& parent) {
    int len = ch_N(parent);
    algo::aryptr<char> ret((char*)parent.ch, len);
    return ret;
}

// --- algo.Smallstr5.ch.HashStrptr
inline u32 algo::Smallstr5_Hash(u32 prev, const algo::strptr &str) {
    return algo::CRC32Step(prev, (u8*)str.elems, str.n_elems);
}

// --- algo.Smallstr5.ch.Init
inline void algo::ch_Init(algo::Smallstr5 &parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr5.ch.Max
// always return constant 5
inline int algo::ch_Max(algo::Smallstr5& parent) {
    (void)parent;
    return 5;
}

// --- algo.Smallstr5.ch.N
inline int algo::ch_N(const algo::Smallstr5& parent) {
    u64 ret;
    ret = parent.n_ch;
    return int(ret);
}

// --- algo.Smallstr5.ch.AssignStrptr
// Copy from strptr (operator=)
inline void algo::Smallstr5::operator =(const algo::strptr &str) {
    ch_SetStrptr(*this, str);
}

// --- algo.Smallstr5.ch.CtorStrptr
inline  algo::Smallstr5::Smallstr5(const algo::strptr &rhs) {
    ch_SetStrptr(*this, rhs);
}

// --- algo.Smallstr5.ch.Cast
inline  algo::Smallstr5::operator algo::strptr() const {
    return ch_Getary(*this);
}

// --- algo.Smallstr5..EqOp
inline bool algo::Smallstr5::operator ==(const algo::Smallstr5 &rhs) const {
    return algo::Smallstr5_Eq(const_cast<algo::Smallstr5&>(*this),const_cast<algo::Smallstr5&>(rhs));
}

// --- algo.Smallstr5..NeOp
inline bool algo::Smallstr5::operator !=(const algo::Smallstr5 &rhs) const {
    return !algo::Smallstr5_Eq(const_cast<algo::Smallstr5&>(*this),const_cast<algo::Smallstr5&>(rhs));
}

// --- algo.Smallstr5..Cmp
inline i32 algo::Smallstr5_Cmp(algo::Smallstr5& lhs, algo::Smallstr5& rhs) {
    i32 retval = 0;
    retval = algo::strptr_Cmp(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr5..Init
// Set all fields to initial values.
inline void algo::Smallstr5_Init(algo::Smallstr5& parent) {
    parent.n_ch = 0;
}

// --- algo.Smallstr5..Eq
inline bool algo::Smallstr5_Eq(algo::Smallstr5& lhs, algo::Smallstr5& rhs) {
    bool retval = true;
    retval = algo::strptr_Eq(ch_Getary(lhs), ch_Getary(rhs));
    return retval;
}

// --- algo.Smallstr5..EqOpAryptr
inline bool algo::Smallstr5::operator ==(const algo::aryptr<char> &rhs) const {
    return algo::strptr_Eq(ch_Getary(*this), rhs);
}

// --- algo.Smallstr5..AssignOp
inline algo::Smallstr5& algo::Smallstr5::operator =(const algo::Smallstr5 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
    return *this;
}

// --- algo.Smallstr5..Ctor
inline  algo::Smallstr5::Smallstr5() {
    algo::Smallstr5_Init(*this);
}

// --- algo.Smallstr5..CopyCtor
inline  algo::Smallstr5::Smallstr5(const algo::Smallstr5 &rhs) {
    memcpy(ch, rhs.ch, rhs.n_ch);
    n_ch = rhs.n_ch;
}

// --- algo.StringAry.ary.EmptyQ
// Return true if index is empty
inline bool algo::ary_EmptyQ(algo::StringAry& parent) {
    return parent.ary_n == 0;
}

// --- algo.StringAry.ary.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* algo::ary_Find(algo::StringAry& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- algo.StringAry.ary.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> algo::ary_Getary(const algo::StringAry& parent) {
    return algo::aryptr<algo::cstring>(parent.ary_elems, parent.ary_n);
}

// --- algo.StringAry.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* algo::ary_Last(algo::StringAry& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- algo.StringAry.ary.AssignAryptr
// Copy from aryptr (operator=)
inline void algo::StringAry::operator =(const algo::aryptr<algo::cstring> &rhs) {
    ary_Setary(*this, rhs);
}

// --- algo.StringAry.ary.CtorAryptr
inline  algo::StringAry::StringAry(const algo::aryptr<algo::cstring> &rhs) {
    ary_elems 	= 0; // (algo.StringAry.ary)
    ary_n     	= 0; // (algo.StringAry.ary)
    ary_max   	= 0; // (algo.StringAry.ary)
    ary_Addary(*this, rhs);
}

// --- algo.StringAry.ary.Max
// Return max. number of items in the array
inline i32 algo::ary_Max(algo::StringAry& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- algo.StringAry.ary.N
// Return number of items in the array
inline i32 algo::ary_N(const algo::StringAry& parent) {
    return parent.ary_n;
}

// --- algo.StringAry.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ary_Reserve(algo::StringAry& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- algo.StringAry.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& algo::ary_qFind(algo::StringAry& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- algo.StringAry.ary.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& algo::ary_qLast(algo::StringAry& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- algo.StringAry.ary.rowid_Get
// Return row id of specified element
inline u64 algo::ary_rowid_Get(algo::StringAry& parent, algo::cstring &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- algo.StringAry.ary.Cast
inline  algo::StringAry::operator algo::aryptr<algo::cstring>() const {
    return ary_Getary(*this);
}

// --- algo.StringAry.ary_curs.Next
// proceed to next item
inline void algo::StringAry_ary_curs_Next(StringAry_ary_curs &curs) {
    curs.index++;
}

// --- algo.StringAry.ary_curs.Reset
inline void algo::StringAry_ary_curs_Reset(StringAry_ary_curs &curs, algo::StringAry &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- algo.StringAry.ary_curs.ValidQ
// cursor points to valid item
inline bool algo::StringAry_ary_curs_ValidQ(StringAry_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.StringAry.ary_curs.Access
// item access
inline algo::cstring& algo::StringAry_ary_curs_Access(StringAry_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.StringAry..Init
// Set all fields to initial values.
inline void algo::StringAry_Init(algo::StringAry& parent) {
    parent.ary_elems 	= 0; // (algo.StringAry.ary)
    parent.ary_n     	= 0; // (algo.StringAry.ary)
    parent.ary_max   	= 0; // (algo.StringAry.ary)
}

// --- algo.StringAry..Ctor
inline  algo::StringAry::StringAry() {
    algo::StringAry_Init(*this);
}

// --- algo.StringAry..Dtor
inline  algo::StringAry::~StringAry() {
    algo::StringAry_Uninit(*this);
}

// --- algo.TermStyle.value.GetEnum
// Get value of field as enum type
inline algo_TermStyleEnum algo::value_GetEnum(const algo::TermStyle& parent) {
    return algo_TermStyleEnum(parent.value);
}

// --- algo.TermStyle.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::TermStyle& parent, algo_TermStyleEnum rhs) {
    parent.value = u32(rhs);
}

// --- algo.TermStyle.value.Cast
inline  algo::TermStyle::operator algo_TermStyleEnum() const {
    return algo_TermStyleEnum((*this).value);
}

// --- algo.TermStyle..Init
// Set all fields to initial values.
inline void algo::TermStyle_Init(algo::TermStyle& parent) {
    parent.value = u32(0);
}

// --- algo.TermStyle..Ctor
inline  algo::TermStyle::TermStyle() {
    algo::TermStyle_Init(*this);
}

// --- algo.TermStyle..FieldwiseCtor
inline  algo::TermStyle::TermStyle(u32 in_value)
    : value(in_value)
 {
}

// --- algo.TermStyle..EnumCtor
inline  algo::TermStyle::TermStyle(algo_TermStyleEnum arg) {
    this->value = u32(arg);
}

// --- algo.TextJust.value.GetEnum
// Get value of field as enum type
inline algo_TextJustEnum algo::value_GetEnum(const algo::TextJust& parent) {
    return algo_TextJustEnum(parent.value);
}

// --- algo.TextJust.value.SetEnum
// Set value of field from enum type.
inline void algo::value_SetEnum(algo::TextJust& parent, algo_TextJustEnum rhs) {
    parent.value = i32(rhs);
}

// --- algo.TextJust.value.Cast
inline  algo::TextJust::operator algo_TextJustEnum() const {
    return algo_TextJustEnum((*this).value);
}

// --- algo.TextJust..Init
// Set all fields to initial values.
inline void algo::TextJust_Init(algo::TextJust& parent) {
    parent.value = i32(0);
}

// --- algo.TextJust..Ctor
inline  algo::TextJust::TextJust() {
    algo::TextJust_Init(*this);
}

// --- algo.TextJust..FieldwiseCtor
inline  algo::TextJust::TextJust(i32 in_value)
    : value(in_value)
 {
}

// --- algo.TextJust..EnumCtor
inline  algo::TextJust::TextJust(algo_TextJustEnum arg) {
    this->value = i32(arg);
}

// --- algo.TstampCache..Ctor
inline  algo::TstampCache::TstampCache() {
    algo::TstampCache_Init(*this);
}

// --- algo.Tuple.attrs.EmptyQ
// Return true if index is empty
inline bool algo::attrs_EmptyQ(algo::Tuple& parent) {
    return parent.attrs_n == 0;
}

// --- algo.Tuple.attrs.Find
// Look up row by row id. Return NULL if out of range
inline algo::Attr* algo::attrs_Find(algo::Tuple& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.attrs_n;
    if (idx >= lim) return NULL;
    return parent.attrs_elems + idx;
}

// --- algo.Tuple.attrs.Getary
// Return array pointer by value
inline algo::aryptr<algo::Attr> algo::attrs_Getary(const algo::Tuple& parent) {
    return algo::aryptr<algo::Attr>(parent.attrs_elems, parent.attrs_n);
}

// --- algo.Tuple.attrs.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::Attr* algo::attrs_Last(algo::Tuple& parent) {
    return attrs_Find(parent, u64(parent.attrs_n-1));
}

// --- algo.Tuple.attrs.Max
// Return max. number of items in the array
inline i32 algo::attrs_Max(algo::Tuple& parent) {
    (void)parent;
    return parent.attrs_max;
}

// --- algo.Tuple.attrs.N
// Return number of items in the array
inline i32 algo::attrs_N(const algo::Tuple& parent) {
    return parent.attrs_n;
}

// --- algo.Tuple.attrs.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::attrs_Reserve(algo::Tuple& parent, int n) {
    u32 new_n = parent.attrs_n + n;
    if (UNLIKELY(new_n > parent.attrs_max)) {
        attrs_AbsReserve(parent, new_n);
    }
}

// --- algo.Tuple.attrs.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::Attr& algo::attrs_qFind(algo::Tuple& parent, u64 t) {
    return parent.attrs_elems[t];
}

// --- algo.Tuple.attrs.qLast
// Return reference to last element of array. No bounds checking
inline algo::Attr& algo::attrs_qLast(algo::Tuple& parent) {
    return attrs_qFind(parent, u64(parent.attrs_n-1));
}

// --- algo.Tuple.attrs.rowid_Get
// Return row id of specified element
inline u64 algo::attrs_rowid_Get(algo::Tuple& parent, algo::Attr &elem) {
    u64 id = &elem - parent.attrs_elems;
    return u64(id);
}

// --- algo.Tuple.attrs_curs.Next
// proceed to next item
inline void algo::Tuple_attrs_curs_Next(Tuple_attrs_curs &curs) {
    curs.index++;
}

// --- algo.Tuple.attrs_curs.Reset
inline void algo::Tuple_attrs_curs_Reset(Tuple_attrs_curs &curs, algo::Tuple &parent) {
    curs.elems = parent.attrs_elems;
    curs.n_elems = parent.attrs_n;
    curs.index = 0;
}

// --- algo.Tuple.attrs_curs.ValidQ
// cursor points to valid item
inline bool algo::Tuple_attrs_curs_ValidQ(Tuple_attrs_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.Tuple.attrs_curs.Access
// item access
inline algo::Attr& algo::Tuple_attrs_curs_Access(Tuple_attrs_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.Tuple..EqOp
inline bool algo::Tuple::operator ==(const algo::Tuple &rhs) const {
    return algo::Tuple_Eq(const_cast<algo::Tuple&>(*this),const_cast<algo::Tuple&>(rhs));
}

// --- algo.Tuple..NeOp
inline bool algo::Tuple::operator !=(const algo::Tuple &rhs) const {
    return !algo::Tuple_Eq(const_cast<algo::Tuple&>(*this),const_cast<algo::Tuple&>(rhs));
}

// --- algo.Tuple..Cmp
inline i32 algo::Tuple_Cmp(algo::Tuple& lhs, algo::Tuple& rhs) {
    i32 retval = 0;
    retval = attrs_Cmp(lhs,rhs);
    if (retval != 0) {
        return retval;
    }
    retval = algo::Attr_Cmp(lhs.head, rhs.head);
    return retval;
}

// --- algo.Tuple..Init
// Set all fields to initial values.
inline void algo::Tuple_Init(algo::Tuple& parent) {
    parent.attrs_elems 	= 0; // (algo.Tuple.attrs)
    parent.attrs_n     	= 0; // (algo.Tuple.attrs)
    parent.attrs_max   	= 0; // (algo.Tuple.attrs)
}

// --- algo.Tuple..Eq
inline bool algo::Tuple_Eq(algo::Tuple& lhs, algo::Tuple& rhs) {
    bool retval = true;
    retval = attrs_Eq(lhs,rhs);
    if (!retval) {
        return false;
    }
    retval = algo::Attr_Eq(lhs.head, rhs.head);
    return retval;
}

// --- algo.Tuple..Ctor
inline  algo::Tuple::Tuple() {
    algo::Tuple_Init(*this);
}

// --- algo.Tuple..Dtor
inline  algo::Tuple::~Tuple() {
    algo::Tuple_Uninit(*this);
}

// --- algo.U16Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U16Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U16Dec2.value.GetDouble
inline double algo::value_GetDouble(const algo::U16Dec2& parent) {
    double ret;
    ret = parent.value / double(100);
    return ret;
}

// --- algo.U16Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline u16 algo::value_GetInt(const algo::U16Dec2& parent) {
    u16 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.U16Dec2.value.GetScale
// Return constant 100
inline u16 algo::U16Dec2_GetScale() {
    return 100;
}

// --- algo.U16Dec2.value.Cast
inline  algo::U16Dec2::operator u16() const {
    return u16((*this).value);
}

// --- algo.U16Dec2..Hash
inline u32 algo::U16Dec2_Hash(u32 prev, algo::U16Dec2 rhs) {
    prev = u16_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U16Dec2..Init
// Set all fields to initial values.
inline void algo::U16Dec2_Init(algo::U16Dec2& parent) {
    parent.value = u16(0);
}

// --- algo.U16Dec2..Ctor
inline  algo::U16Dec2::U16Dec2() {
    algo::U16Dec2_Init(*this);
}

// --- algo.U16Dec2..FieldwiseCtor
inline  algo::U16Dec2::U16Dec2(u16 in_value)
    : value(in_value)
 {
}

// --- algo.U32Dec1.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec1& parent, double val) {
    double intval = val * 10 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec1.value.GetDouble
inline double algo::value_GetDouble(const algo::U32Dec1& parent) {
    double ret;
    ret = parent.value / double(10);
    return ret;
}

// --- algo.U32Dec1.value.GetInt
// Return integer portion (divide number by 10)
inline u32 algo::value_GetInt(const algo::U32Dec1& parent) {
    u32 ret;
    ret = parent.value / 10;
    return ret;
}

// --- algo.U32Dec1.value.GetScale
// Return constant 10
inline u32 algo::U32Dec1_GetScale() {
    return 10;
}

// --- algo.U32Dec1.value.Cast
inline  algo::U32Dec1::operator u32() const {
    return u32((*this).value);
}

// --- algo.U32Dec1..Hash
inline u32 algo::U32Dec1_Hash(u32 prev, algo::U32Dec1 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec1..Init
// Set all fields to initial values.
inline void algo::U32Dec1_Init(algo::U32Dec1& parent) {
    parent.value = u32(0);
}

// --- algo.U32Dec1..Ctor
inline  algo::U32Dec1::U32Dec1() {
    algo::U32Dec1_Init(*this);
}

// --- algo.U32Dec1..FieldwiseCtor
inline  algo::U32Dec1::U32Dec1(u32 in_value)
    : value(in_value)
 {
}

// --- algo.U32Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec2.value.GetDouble
inline double algo::value_GetDouble(const algo::U32Dec2& parent) {
    double ret;
    ret = parent.value / double(100);
    return ret;
}

// --- algo.U32Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline u32 algo::value_GetInt(const algo::U32Dec2& parent) {
    u32 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.U32Dec2.value.GetScale
// Return constant 100
inline u32 algo::U32Dec2_GetScale() {
    return 100;
}

// --- algo.U32Dec2.value.Cast
inline  algo::U32Dec2::operator u32() const {
    return u32((*this).value);
}

// --- algo.U32Dec2..Hash
inline u32 algo::U32Dec2_Hash(u32 prev, algo::U32Dec2 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec2..Init
// Set all fields to initial values.
inline void algo::U32Dec2_Init(algo::U32Dec2& parent) {
    parent.value = u32(0);
}

// --- algo.U32Dec2..Ctor
inline  algo::U32Dec2::U32Dec2() {
    algo::U32Dec2_Init(*this);
}

// --- algo.U32Dec2..FieldwiseCtor
inline  algo::U32Dec2::U32Dec2(u32 in_value)
    : value(in_value)
 {
}

// --- algo.U32Dec3.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec3& parent, double val) {
    double intval = val * 1000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec3.value.GetDouble
inline double algo::value_GetDouble(const algo::U32Dec3& parent) {
    double ret;
    ret = parent.value / double(1000);
    return ret;
}

// --- algo.U32Dec3.value.GetInt
// Return integer portion (divide number by 1000)
inline u32 algo::value_GetInt(const algo::U32Dec3& parent) {
    u32 ret;
    ret = parent.value / 1000;
    return ret;
}

// --- algo.U32Dec3.value.GetScale
// Return constant 1000
inline u32 algo::U32Dec3_GetScale() {
    return 1000;
}

// --- algo.U32Dec3.value.Cast
inline  algo::U32Dec3::operator u32() const {
    return u32((*this).value);
}

// --- algo.U32Dec3..Hash
inline u32 algo::U32Dec3_Hash(u32 prev, algo::U32Dec3 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec3..Init
// Set all fields to initial values.
inline void algo::U32Dec3_Init(algo::U32Dec3& parent) {
    parent.value = u32(0);
}

// --- algo.U32Dec3..Ctor
inline  algo::U32Dec3::U32Dec3() {
    algo::U32Dec3_Init(*this);
}

// --- algo.U32Dec3..FieldwiseCtor
inline  algo::U32Dec3::U32Dec3(u32 in_value)
    : value(in_value)
 {
}

// --- algo.U32Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec4.value.GetDouble
inline double algo::value_GetDouble(const algo::U32Dec4& parent) {
    double ret;
    ret = parent.value / double(10000);
    return ret;
}

// --- algo.U32Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline u32 algo::value_GetInt(const algo::U32Dec4& parent) {
    u32 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.U32Dec4.value.GetScale
// Return constant 10000
inline u32 algo::U32Dec4_GetScale() {
    return 10000;
}

// --- algo.U32Dec4.value.Cast
inline  algo::U32Dec4::operator u32() const {
    return u32((*this).value);
}

// --- algo.U32Dec4..Hash
inline u32 algo::U32Dec4_Hash(u32 prev, algo::U32Dec4 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec4..Init
// Set all fields to initial values.
inline void algo::U32Dec4_Init(algo::U32Dec4& parent) {
    parent.value = u32(0);
}

// --- algo.U32Dec4..Ctor
inline  algo::U32Dec4::U32Dec4() {
    algo::U32Dec4_Init(*this);
}

// --- algo.U32Dec4..FieldwiseCtor
inline  algo::U32Dec4::U32Dec4(u32 in_value)
    : value(in_value)
 {
}

// --- algo.U32Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U32Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U32Dec5.value.GetDouble
inline double algo::value_GetDouble(const algo::U32Dec5& parent) {
    double ret;
    ret = parent.value / double(100000);
    return ret;
}

// --- algo.U32Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline u32 algo::value_GetInt(const algo::U32Dec5& parent) {
    u32 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.U32Dec5.value.GetScale
// Return constant 100000
inline u32 algo::U32Dec5_GetScale() {
    return 100000;
}

// --- algo.U32Dec5.value.Cast
inline  algo::U32Dec5::operator u32() const {
    return u32((*this).value);
}

// --- algo.U32Dec5..Hash
inline u32 algo::U32Dec5_Hash(u32 prev, algo::U32Dec5 rhs) {
    prev = u32_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U32Dec5..Init
// Set all fields to initial values.
inline void algo::U32Dec5_Init(algo::U32Dec5& parent) {
    parent.value = u32(0);
}

// --- algo.U32Dec5..Ctor
inline  algo::U32Dec5::U32Dec5() {
    algo::U32Dec5_Init(*this);
}

// --- algo.U32Dec5..FieldwiseCtor
inline  algo::U32Dec5::U32Dec5(u32 in_value)
    : value(in_value)
 {
}

// --- algo.U64Ary.ary.EmptyQ
// Return true if index is empty
inline bool algo::ary_EmptyQ(algo::U64Ary& parent) {
    return parent.ary_n == 0;
}

// --- algo.U64Ary.ary.Find
// Look up row by row id. Return NULL if out of range
inline u64* algo::ary_Find(algo::U64Ary& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- algo.U64Ary.ary.Getary
// Return array pointer by value
inline algo::aryptr<u64> algo::ary_Getary(const algo::U64Ary& parent) {
    return algo::aryptr<u64>(parent.ary_elems, parent.ary_n);
}

// --- algo.U64Ary.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u64* algo::ary_Last(algo::U64Ary& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- algo.U64Ary.ary.AssignAryptr
// Copy from aryptr (operator=)
inline void algo::U64Ary::operator =(const algo::aryptr<u64> &rhs) {
    ary_Setary(*this, rhs);
}

// --- algo.U64Ary.ary.CtorAryptr
inline  algo::U64Ary::U64Ary(const algo::aryptr<u64> &rhs) {
    ary_elems 	= 0; // (algo.U64Ary.ary)
    ary_n     	= 0; // (algo.U64Ary.ary)
    ary_max   	= 0; // (algo.U64Ary.ary)
    ary_Addary(*this, rhs);
}

// --- algo.U64Ary.ary.Max
// Return max. number of items in the array
inline i32 algo::ary_Max(algo::U64Ary& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- algo.U64Ary.ary.N
// Return number of items in the array
inline i32 algo::ary_N(const algo::U64Ary& parent) {
    return parent.ary_n;
}

// --- algo.U64Ary.ary.RemoveAll
inline void algo::ary_RemoveAll(algo::U64Ary& parent) {
    parent.ary_n = 0;
}

// --- algo.U64Ary.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo::ary_Reserve(algo::U64Ary& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- algo.U64Ary.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u64& algo::ary_qFind(algo::U64Ary& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- algo.U64Ary.ary.qLast
// Return reference to last element of array. No bounds checking
inline u64& algo::ary_qLast(algo::U64Ary& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- algo.U64Ary.ary.rowid_Get
// Return row id of specified element
inline u64 algo::ary_rowid_Get(algo::U64Ary& parent, u64 &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- algo.U64Ary.ary_curs.Next
// proceed to next item
inline void algo::U64Ary_ary_curs_Next(U64Ary_ary_curs &curs) {
    curs.index++;
}

// --- algo.U64Ary.ary_curs.Reset
inline void algo::U64Ary_ary_curs_Reset(U64Ary_ary_curs &curs, algo::U64Ary &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- algo.U64Ary.ary_curs.ValidQ
// cursor points to valid item
inline bool algo::U64Ary_ary_curs_ValidQ(U64Ary_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo.U64Ary.ary_curs.Access
// item access
inline u64& algo::U64Ary_ary_curs_Access(U64Ary_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo.U64Ary..Init
// Set all fields to initial values.
inline void algo::U64Ary_Init(algo::U64Ary& parent) {
    parent.ary_elems 	= 0; // (algo.U64Ary.ary)
    parent.ary_n     	= 0; // (algo.U64Ary.ary)
    parent.ary_max   	= 0; // (algo.U64Ary.ary)
}

// --- algo.U64Ary..Ctor
inline  algo::U64Ary::U64Ary() {
    algo::U64Ary_Init(*this);
}

// --- algo.U64Ary..Dtor
inline  algo::U64Ary::~U64Ary() {
    algo::U64Ary_Uninit(*this);
}

// --- algo.U64Dec10.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec10& parent, double val) {
    double intval = val * 10000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec10.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec10& parent) {
    double ret;
    ret = parent.value / double(10000000000);
    return ret;
}

// --- algo.U64Dec10.value.GetInt
// Return integer portion (divide number by 10000000000)
inline u64 algo::value_GetInt(const algo::U64Dec10& parent) {
    u64 ret;
    ret = parent.value / 10000000000;
    return ret;
}

// --- algo.U64Dec10.value.GetScale
// Return constant 10000000000
inline u64 algo::U64Dec10_GetScale() {
    return 10000000000;
}

// --- algo.U64Dec10.value.Cast
inline  algo::U64Dec10::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec10..Hash
inline u32 algo::U64Dec10_Hash(u32 prev, algo::U64Dec10 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec10..Init
// Set all fields to initial values.
inline void algo::U64Dec10_Init(algo::U64Dec10& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec10..Ctor
inline  algo::U64Dec10::U64Dec10() {
    algo::U64Dec10_Init(*this);
}

// --- algo.U64Dec10..FieldwiseCtor
inline  algo::U64Dec10::U64Dec10(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec2.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec2& parent, double val) {
    double intval = val * 100 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec2.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec2& parent) {
    double ret;
    ret = parent.value / double(100);
    return ret;
}

// --- algo.U64Dec2.value.GetInt
// Return integer portion (divide number by 100)
inline u64 algo::value_GetInt(const algo::U64Dec2& parent) {
    u64 ret;
    ret = parent.value / 100;
    return ret;
}

// --- algo.U64Dec2.value.GetScale
// Return constant 100
inline u64 algo::U64Dec2_GetScale() {
    return 100;
}

// --- algo.U64Dec2.value.Cast
inline  algo::U64Dec2::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec2..Hash
inline u32 algo::U64Dec2_Hash(u32 prev, algo::U64Dec2 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec2..Init
// Set all fields to initial values.
inline void algo::U64Dec2_Init(algo::U64Dec2& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec2..Ctor
inline  algo::U64Dec2::U64Dec2() {
    algo::U64Dec2_Init(*this);
}

// --- algo.U64Dec2..FieldwiseCtor
inline  algo::U64Dec2::U64Dec2(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec4.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec4& parent, double val) {
    double intval = val * 10000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec4.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec4& parent) {
    double ret;
    ret = parent.value / double(10000);
    return ret;
}

// --- algo.U64Dec4.value.GetInt
// Return integer portion (divide number by 10000)
inline u64 algo::value_GetInt(const algo::U64Dec4& parent) {
    u64 ret;
    ret = parent.value / 10000;
    return ret;
}

// --- algo.U64Dec4.value.GetScale
// Return constant 10000
inline u64 algo::U64Dec4_GetScale() {
    return 10000;
}

// --- algo.U64Dec4.value.Cast
inline  algo::U64Dec4::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec4..Hash
inline u32 algo::U64Dec4_Hash(u32 prev, algo::U64Dec4 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec4..Init
// Set all fields to initial values.
inline void algo::U64Dec4_Init(algo::U64Dec4& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec4..Ctor
inline  algo::U64Dec4::U64Dec4() {
    algo::U64Dec4_Init(*this);
}

// --- algo.U64Dec4..FieldwiseCtor
inline  algo::U64Dec4::U64Dec4(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec5.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec5& parent, double val) {
    double intval = val * 100000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec5.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec5& parent) {
    double ret;
    ret = parent.value / double(100000);
    return ret;
}

// --- algo.U64Dec5.value.GetInt
// Return integer portion (divide number by 100000)
inline u64 algo::value_GetInt(const algo::U64Dec5& parent) {
    u64 ret;
    ret = parent.value / 100000;
    return ret;
}

// --- algo.U64Dec5.value.GetScale
// Return constant 100000
inline u64 algo::U64Dec5_GetScale() {
    return 100000;
}

// --- algo.U64Dec5.value.Cast
inline  algo::U64Dec5::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec5..Hash
inline u32 algo::U64Dec5_Hash(u32 prev, algo::U64Dec5 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec5..Init
// Set all fields to initial values.
inline void algo::U64Dec5_Init(algo::U64Dec5& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec5..Ctor
inline  algo::U64Dec5::U64Dec5() {
    algo::U64Dec5_Init(*this);
}

// --- algo.U64Dec5..FieldwiseCtor
inline  algo::U64Dec5::U64Dec5(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec6.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec6& parent, double val) {
    double intval = val * 1000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec6.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec6& parent) {
    double ret;
    ret = parent.value / double(1000000);
    return ret;
}

// --- algo.U64Dec6.value.GetInt
// Return integer portion (divide number by 1000000)
inline u64 algo::value_GetInt(const algo::U64Dec6& parent) {
    u64 ret;
    ret = parent.value / 1000000;
    return ret;
}

// --- algo.U64Dec6.value.GetScale
// Return constant 1000000
inline u64 algo::U64Dec6_GetScale() {
    return 1000000;
}

// --- algo.U64Dec6.value.Cast
inline  algo::U64Dec6::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec6..Hash
inline u32 algo::U64Dec6_Hash(u32 prev, algo::U64Dec6 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec6..Init
// Set all fields to initial values.
inline void algo::U64Dec6_Init(algo::U64Dec6& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec6..Ctor
inline  algo::U64Dec6::U64Dec6() {
    algo::U64Dec6_Init(*this);
}

// --- algo.U64Dec6..FieldwiseCtor
inline  algo::U64Dec6::U64Dec6(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec7.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec7& parent, double val) {
    double intval = val * 10000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec7.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec7& parent) {
    double ret;
    ret = parent.value / double(10000000);
    return ret;
}

// --- algo.U64Dec7.value.GetInt
// Return integer portion (divide number by 10000000)
inline u64 algo::value_GetInt(const algo::U64Dec7& parent) {
    u64 ret;
    ret = parent.value / 10000000;
    return ret;
}

// --- algo.U64Dec7.value.GetScale
// Return constant 10000000
inline u64 algo::U64Dec7_GetScale() {
    return 10000000;
}

// --- algo.U64Dec7.value.Cast
inline  algo::U64Dec7::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec7..Hash
inline u32 algo::U64Dec7_Hash(u32 prev, algo::U64Dec7 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec7..Init
// Set all fields to initial values.
inline void algo::U64Dec7_Init(algo::U64Dec7& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec7..Ctor
inline  algo::U64Dec7::U64Dec7() {
    algo::U64Dec7_Init(*this);
}

// --- algo.U64Dec7..FieldwiseCtor
inline  algo::U64Dec7::U64Dec7(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec8.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec8& parent, double val) {
    double intval = val * 100000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec8.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec8& parent) {
    double ret;
    ret = parent.value / double(100000000);
    return ret;
}

// --- algo.U64Dec8.value.GetInt
// Return integer portion (divide number by 100000000)
inline u64 algo::value_GetInt(const algo::U64Dec8& parent) {
    u64 ret;
    ret = parent.value / 100000000;
    return ret;
}

// --- algo.U64Dec8.value.GetScale
// Return constant 100000000
inline u64 algo::U64Dec8_GetScale() {
    return 100000000;
}

// --- algo.U64Dec8..Hash
inline u32 algo::U64Dec8_Hash(u32 prev, algo::U64Dec8 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec8..Init
// Set all fields to initial values.
inline void algo::U64Dec8_Init(algo::U64Dec8& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec8..Ctor
inline  algo::U64Dec8::U64Dec8() {
    algo::U64Dec8_Init(*this);
}

// --- algo.U64Dec8..FieldwiseCtor
inline  algo::U64Dec8::U64Dec8(u64 in_value)
    : value(in_value)
 {
}

// --- algo.U64Dec9.value.qSetDouble
// Set value of field value.
// The value is rounded to the nearest integer.
// This ensures that truncation of a near-integer value does not occur.
// Example: 1.3 cannot be represented exactly as a double, the actual
// stored value will be 1.29999999. when we apply C truncation,
// we want to end up with 1.3, not 1.2.
inline void algo::value_qSetDouble(algo::U64Dec9& parent, double val) {
    double intval = val * 1000000000 + (val > 0 ? 0.5 : -0.5);
    // set underlying field.
    parent.value = intval;
}

// --- algo.U64Dec9.value.GetDouble
inline double algo::value_GetDouble(const algo::U64Dec9& parent) {
    double ret;
    ret = parent.value / double(1000000000);
    return ret;
}

// --- algo.U64Dec9.value.GetInt
// Return integer portion (divide number by 1000000000)
inline u64 algo::value_GetInt(const algo::U64Dec9& parent) {
    u64 ret;
    ret = parent.value / 1000000000;
    return ret;
}

// --- algo.U64Dec9.value.GetScale
// Return constant 1000000000
inline u64 algo::U64Dec9_GetScale() {
    return 1000000000;
}

// --- algo.U64Dec9.value.Cast
inline  algo::U64Dec9::operator u64() const {
    return u64((*this).value);
}

// --- algo.U64Dec9..Hash
inline u32 algo::U64Dec9_Hash(u32 prev, algo::U64Dec9 rhs) {
    prev = u64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.U64Dec9..Init
// Set all fields to initial values.
inline void algo::U64Dec9_Init(algo::U64Dec9& parent) {
    parent.value = u64(0);
}

// --- algo.U64Dec9..Ctor
inline  algo::U64Dec9::U64Dec9() {
    algo::U64Dec9_Init(*this);
}

// --- algo.U64Dec9..FieldwiseCtor
inline  algo::U64Dec9::U64Dec9(u64 in_value)
    : value(in_value)
 {
}

// --- algo.URL..Init
// Set all fields to initial values.
inline void algo::URL_Init(algo::URL& parent) {
    parent.port = i32(-1);
    parent.source_addr_host = u32(0);
}

// --- algo.URL..Ctor
inline  algo::URL::URL() {
    algo::URL_Init(*this);
}

// --- algo.URL..FieldwiseCtor
inline  algo::URL::URL(const algo::strptr& in_protocol, const algo::strptr& in_username, const algo::strptr& in_password, const algo::strptr& in_server, const algo::strptr& in_dir, i32 in_port, u32 in_source_addr_host, const algo::strptr& in_host)
    : protocol(in_protocol)
    , username(in_username)
    , password(in_password)
    , server(in_server)
    , dir(in_dir)
    , port(in_port)
    , source_addr_host(in_source_addr_host)
    , host(in_host)
 {
}

// --- algo.UnDiff..Hash
inline u32 algo::UnDiff_Hash(u32 prev, algo::UnDiff rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnDiff..EqOp
inline bool algo::UnDiff::operator ==(const algo::UnDiff &rhs) const {
    return algo::UnDiff_Eq(const_cast<algo::UnDiff&>(*this),const_cast<algo::UnDiff&>(rhs));
}

// --- algo.UnDiff..NeOp
inline bool algo::UnDiff::operator !=(const algo::UnDiff &rhs) const {
    return !algo::UnDiff_Eq(const_cast<algo::UnDiff&>(*this),const_cast<algo::UnDiff&>(rhs));
}

// --- algo.UnDiff..LtOp
inline bool algo::UnDiff::operator <(const algo::UnDiff &rhs) const {
    return algo::UnDiff_Lt(const_cast<algo::UnDiff&>(*this),const_cast<algo::UnDiff&>(rhs));
}

// --- algo.UnDiff..GtOp
inline bool algo::UnDiff::operator >(const algo::UnDiff &rhs) const {
    return algo::UnDiff_Lt(const_cast<algo::UnDiff&>(rhs),const_cast<algo::UnDiff&>(*this));
}

// --- algo.UnDiff..LeOp
inline bool algo::UnDiff::operator <=(const algo::UnDiff &rhs) const {
    return !algo::UnDiff_Lt(const_cast<algo::UnDiff&>(rhs),const_cast<algo::UnDiff&>(*this));
}

// --- algo.UnDiff..GeOp
inline bool algo::UnDiff::operator >=(const algo::UnDiff &rhs) const {
    return !algo::UnDiff_Lt(const_cast<algo::UnDiff&>(*this),const_cast<algo::UnDiff&>(rhs));
}

// --- algo.UnDiff..Lt
inline bool algo::UnDiff_Lt(algo::UnDiff lhs, algo::UnDiff rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnDiff..Cmp
inline i32 algo::UnDiff_Cmp(algo::UnDiff lhs, algo::UnDiff rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnDiff..Init
// Set all fields to initial values.
inline void algo::UnDiff_Init(algo::UnDiff& parent) {
    parent.value = i64(0);
}

// --- algo.UnDiff..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnDiff_UpdateMax(algo::UnDiff &lhs, algo::UnDiff rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnDiff..Min
// Return the lesser of two values
inline algo::UnDiff algo::UnDiff_Min(algo::UnDiff lhs, algo::UnDiff rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnDiff..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnDiff_UpdateMin(algo::UnDiff &lhs, algo::UnDiff rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnDiff..Max
// Return the greater of two values
inline algo::UnDiff algo::UnDiff_Max(algo::UnDiff lhs, algo::UnDiff rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnDiff..Eq
inline bool algo::UnDiff_Eq(algo::UnDiff lhs, algo::UnDiff rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnDiff..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnDiff_Update(algo::UnDiff &lhs, algo::UnDiff rhs) {
    bool ret = !UnDiff_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.UnDiff..Ctor
inline  algo::UnDiff::UnDiff() {
    algo::UnDiff_Init(*this);
}

// --- algo.UnDiff..FieldwiseCtor
inline  algo::UnDiff::UnDiff(i64 in_value)
    : value(in_value)
 {
}

// --- algo.UnixDiff..Hash
inline u32 algo::UnixDiff_Hash(u32 prev, algo::UnixDiff rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnixDiff..EqOp
inline bool algo::UnixDiff::operator ==(const algo::UnixDiff &rhs) const {
    return algo::UnixDiff_Eq(const_cast<algo::UnixDiff&>(*this),const_cast<algo::UnixDiff&>(rhs));
}

// --- algo.UnixDiff..NeOp
inline bool algo::UnixDiff::operator !=(const algo::UnixDiff &rhs) const {
    return !algo::UnixDiff_Eq(const_cast<algo::UnixDiff&>(*this),const_cast<algo::UnixDiff&>(rhs));
}

// --- algo.UnixDiff..LtOp
inline bool algo::UnixDiff::operator <(const algo::UnixDiff &rhs) const {
    return algo::UnixDiff_Lt(const_cast<algo::UnixDiff&>(*this),const_cast<algo::UnixDiff&>(rhs));
}

// --- algo.UnixDiff..GtOp
inline bool algo::UnixDiff::operator >(const algo::UnixDiff &rhs) const {
    return algo::UnixDiff_Lt(const_cast<algo::UnixDiff&>(rhs),const_cast<algo::UnixDiff&>(*this));
}

// --- algo.UnixDiff..LeOp
inline bool algo::UnixDiff::operator <=(const algo::UnixDiff &rhs) const {
    return !algo::UnixDiff_Lt(const_cast<algo::UnixDiff&>(rhs),const_cast<algo::UnixDiff&>(*this));
}

// --- algo.UnixDiff..GeOp
inline bool algo::UnixDiff::operator >=(const algo::UnixDiff &rhs) const {
    return !algo::UnixDiff_Lt(const_cast<algo::UnixDiff&>(*this),const_cast<algo::UnixDiff&>(rhs));
}

// --- algo.UnixDiff..Lt
inline bool algo::UnixDiff_Lt(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnixDiff..Cmp
inline i32 algo::UnixDiff_Cmp(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixDiff..Init
// Set all fields to initial values.
inline void algo::UnixDiff_Init(algo::UnixDiff& parent) {
    parent.value = i64(0);
}

// --- algo.UnixDiff..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnixDiff_UpdateMax(algo::UnixDiff &lhs, algo::UnixDiff rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixDiff..Min
// Return the lesser of two values
inline algo::UnixDiff algo::UnixDiff_Min(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnixDiff..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnixDiff_UpdateMin(algo::UnixDiff &lhs, algo::UnixDiff rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixDiff..Max
// Return the greater of two values
inline algo::UnixDiff algo::UnixDiff_Max(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnixDiff..Eq
inline bool algo::UnixDiff_Eq(algo::UnixDiff lhs, algo::UnixDiff rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixDiff..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnixDiff_Update(algo::UnixDiff &lhs, algo::UnixDiff rhs) {
    bool ret = !UnixDiff_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.UnixDiff..Ctor
inline  algo::UnixDiff::UnixDiff() {
    algo::UnixDiff_Init(*this);
}

// --- algo.UnixDiff..FieldwiseCtor
inline  algo::UnixDiff::UnixDiff(i64 in_value)
    : value(in_value)
 {
}

// --- algo.UnixTime..Hash
inline u32 algo::UnixTime_Hash(u32 prev, algo::UnixTime rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.UnixTime..EqOp
inline bool algo::UnixTime::operator ==(const algo::UnixTime &rhs) const {
    return algo::UnixTime_Eq(const_cast<algo::UnixTime&>(*this),const_cast<algo::UnixTime&>(rhs));
}

// --- algo.UnixTime..NeOp
inline bool algo::UnixTime::operator !=(const algo::UnixTime &rhs) const {
    return !algo::UnixTime_Eq(const_cast<algo::UnixTime&>(*this),const_cast<algo::UnixTime&>(rhs));
}

// --- algo.UnixTime..LtOp
inline bool algo::UnixTime::operator <(const algo::UnixTime &rhs) const {
    return algo::UnixTime_Lt(const_cast<algo::UnixTime&>(*this),const_cast<algo::UnixTime&>(rhs));
}

// --- algo.UnixTime..GtOp
inline bool algo::UnixTime::operator >(const algo::UnixTime &rhs) const {
    return algo::UnixTime_Lt(const_cast<algo::UnixTime&>(rhs),const_cast<algo::UnixTime&>(*this));
}

// --- algo.UnixTime..LeOp
inline bool algo::UnixTime::operator <=(const algo::UnixTime &rhs) const {
    return !algo::UnixTime_Lt(const_cast<algo::UnixTime&>(rhs),const_cast<algo::UnixTime&>(*this));
}

// --- algo.UnixTime..GeOp
inline bool algo::UnixTime::operator >=(const algo::UnixTime &rhs) const {
    return !algo::UnixTime_Lt(const_cast<algo::UnixTime&>(*this),const_cast<algo::UnixTime&>(rhs));
}

// --- algo.UnixTime..Lt
inline bool algo::UnixTime_Lt(algo::UnixTime lhs, algo::UnixTime rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.UnixTime..Cmp
inline i32 algo::UnixTime_Cmp(algo::UnixTime lhs, algo::UnixTime rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixTime..Init
// Set all fields to initial values.
inline void algo::UnixTime_Init(algo::UnixTime& parent) {
    parent.value = i64(0);
}

// --- algo.UnixTime..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::UnixTime_UpdateMax(algo::UnixTime &lhs, algo::UnixTime rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixTime..Min
// Return the lesser of two values
inline algo::UnixTime algo::UnixTime_Min(algo::UnixTime lhs, algo::UnixTime rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.UnixTime..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::UnixTime_UpdateMin(algo::UnixTime &lhs, algo::UnixTime rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.UnixTime..Max
// Return the greater of two values
inline algo::UnixTime algo::UnixTime_Max(algo::UnixTime lhs, algo::UnixTime rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.UnixTime..Eq
inline bool algo::UnixTime_Eq(algo::UnixTime lhs, algo::UnixTime rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.UnixTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::UnixTime_Update(algo::UnixTime &lhs, algo::UnixTime rhs) {
    bool ret = !UnixTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.UnixTime..Ctor
inline  algo::UnixTime::UnixTime() {
    algo::UnixTime_Init(*this);
}

// --- algo.UnixTime..FieldwiseCtor
inline  algo::UnixTime::UnixTime(i64 in_value)
    : value(in_value)
 {
}

// --- algo.Uuid.value.Fill
// Set all elements of fixed array to value RHS
inline void algo::value_Fill(algo::Uuid& parent, const u8 &rhs) {
    for (int i = 0; i < 16; i++) {
        parent.value_elems[i] = rhs;
    }
}

// --- algo.Uuid.value.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo::value_Find(algo::Uuid& parent, u64 t) {
    u64 idx = t;
    u64 lim = 16;
    return idx < lim ? parent.value_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo.Uuid.value.Getary
// Access fixed array value as aryptr.
inline algo::aryptr<u8> algo::value_Getary(algo::Uuid& parent) {
    return algo::aryptr<u8>(parent.value_elems, 16);
}

// --- algo.Uuid.value.Max
// Return max number of items in the array
inline i32 algo::value_Max(algo::Uuid& parent) {
    (void)parent;
    return 16;
}

// --- algo.Uuid.value.N
// Return number of items in the array
inline i32 algo::value_N(const algo::Uuid& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return 16;
}

// --- algo.Uuid.value.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo::value_Setary(algo::Uuid& parent, const algo::aryptr<u8> &rhs) {
    int n = i32_Min(16, rhs.n_elems);
    memcpy(parent.value_elems, rhs.elems, sizeof(u8)*n);
}

// --- algo.Uuid.value.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u8& algo::value_qFind(algo::Uuid& parent, u64 t) {
    return parent.value_elems[u64(t)];
}

// --- algo.Uuid.value_curs.Reset
// cursor points to valid item
inline void algo::Uuid_value_curs_Reset(Uuid_value_curs &curs, algo::Uuid &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo.Uuid.value_curs.ValidQ
// cursor points to valid item
inline bool algo::Uuid_value_curs_ValidQ(Uuid_value_curs &curs) {
    return u64(curs.index) < u64(16);
}

// --- algo.Uuid.value_curs.Next
// proceed to next item
inline void algo::Uuid_value_curs_Next(Uuid_value_curs &curs) {
    curs.index++;
}

// --- algo.Uuid.value_curs.Access
// item access
inline u8& algo::Uuid_value_curs_Access(Uuid_value_curs &curs) {
    return value_qFind((*curs.parent), u64(curs.index));
}

// --- algo.Uuid..Hash
inline u32 algo::Uuid_Hash(u32 prev, const algo::Uuid& rhs) {
    frep_(i,16) prev = u8_Hash(prev, rhs.value_elems[i]);
    return prev;
}

// --- algo.Uuid..EqOp
inline bool algo::Uuid::operator ==(const algo::Uuid &rhs) const {
    return algo::Uuid_Eq(const_cast<algo::Uuid&>(*this),const_cast<algo::Uuid&>(rhs));
}

// --- algo.Uuid..NeOp
inline bool algo::Uuid::operator !=(const algo::Uuid &rhs) const {
    return !algo::Uuid_Eq(const_cast<algo::Uuid&>(*this),const_cast<algo::Uuid&>(rhs));
}

// --- algo.Uuid..Cmp
inline i32 algo::Uuid_Cmp(algo::Uuid& lhs, algo::Uuid& rhs) {
    i32 retval = 0;
    retval = value_Cmp(lhs,rhs);
    return retval;
}

// --- algo.Uuid..Init
// Set all fields to initial values.
inline void algo::Uuid_Init(algo::Uuid& parent) {
    for (int i = 0; i < 16; i++) {
        parent.value_elems[i] = 0;
    }
}

// --- algo.Uuid..Eq
inline bool algo::Uuid_Eq(algo::Uuid& lhs, algo::Uuid& rhs) {
    bool retval = true;
    retval = value_Eq(lhs,rhs);
    return retval;
}

// --- algo.Uuid..Ctor
inline  algo::Uuid::Uuid() {
    algo::Uuid_Init(*this);
}

// --- algo.WDiff..Hash
inline u32 algo::WDiff_Hash(u32 prev, algo::WDiff rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.WDiff..EqOp
inline bool algo::WDiff::operator ==(const algo::WDiff &rhs) const {
    return algo::WDiff_Eq(const_cast<algo::WDiff&>(*this),const_cast<algo::WDiff&>(rhs));
}

// --- algo.WDiff..NeOp
inline bool algo::WDiff::operator !=(const algo::WDiff &rhs) const {
    return !algo::WDiff_Eq(const_cast<algo::WDiff&>(*this),const_cast<algo::WDiff&>(rhs));
}

// --- algo.WDiff..LtOp
inline bool algo::WDiff::operator <(const algo::WDiff &rhs) const {
    return algo::WDiff_Lt(const_cast<algo::WDiff&>(*this),const_cast<algo::WDiff&>(rhs));
}

// --- algo.WDiff..GtOp
inline bool algo::WDiff::operator >(const algo::WDiff &rhs) const {
    return algo::WDiff_Lt(const_cast<algo::WDiff&>(rhs),const_cast<algo::WDiff&>(*this));
}

// --- algo.WDiff..LeOp
inline bool algo::WDiff::operator <=(const algo::WDiff &rhs) const {
    return !algo::WDiff_Lt(const_cast<algo::WDiff&>(rhs),const_cast<algo::WDiff&>(*this));
}

// --- algo.WDiff..GeOp
inline bool algo::WDiff::operator >=(const algo::WDiff &rhs) const {
    return !algo::WDiff_Lt(const_cast<algo::WDiff&>(*this),const_cast<algo::WDiff&>(rhs));
}

// --- algo.WDiff..Lt
inline bool algo::WDiff_Lt(algo::WDiff lhs, algo::WDiff rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.WDiff..Cmp
inline i32 algo::WDiff_Cmp(algo::WDiff lhs, algo::WDiff rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.WDiff..Init
// Set all fields to initial values.
inline void algo::WDiff_Init(algo::WDiff& parent) {
    parent.value = i64(0);
}

// --- algo.WDiff..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::WDiff_UpdateMax(algo::WDiff &lhs, algo::WDiff rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.WDiff..Min
// Return the lesser of two values
inline algo::WDiff algo::WDiff_Min(algo::WDiff lhs, algo::WDiff rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.WDiff..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::WDiff_UpdateMin(algo::WDiff &lhs, algo::WDiff rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.WDiff..Max
// Return the greater of two values
inline algo::WDiff algo::WDiff_Max(algo::WDiff lhs, algo::WDiff rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.WDiff..Eq
inline bool algo::WDiff_Eq(algo::WDiff lhs, algo::WDiff rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.WDiff..Update
// Set value. Return true if new value is different from old value.
inline bool algo::WDiff_Update(algo::WDiff &lhs, algo::WDiff rhs) {
    bool ret = !WDiff_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.WDiff..Ctor
inline  algo::WDiff::WDiff() {
    algo::WDiff_Init(*this);
}

// --- algo.WDiff..FieldwiseCtor
inline  algo::WDiff::WDiff(i64 in_value)
    : value(in_value)
 {
}

// --- algo.WTime..Hash
inline u32 algo::WTime_Hash(u32 prev, algo::WTime rhs) {
    prev = i64_Hash(prev, rhs.value);
    return prev;
}

// --- algo.WTime..EqOp
inline bool algo::WTime::operator ==(const algo::WTime &rhs) const {
    return algo::WTime_Eq(const_cast<algo::WTime&>(*this),const_cast<algo::WTime&>(rhs));
}

// --- algo.WTime..NeOp
inline bool algo::WTime::operator !=(const algo::WTime &rhs) const {
    return !algo::WTime_Eq(const_cast<algo::WTime&>(*this),const_cast<algo::WTime&>(rhs));
}

// --- algo.WTime..LtOp
inline bool algo::WTime::operator <(const algo::WTime &rhs) const {
    return algo::WTime_Lt(const_cast<algo::WTime&>(*this),const_cast<algo::WTime&>(rhs));
}

// --- algo.WTime..GtOp
inline bool algo::WTime::operator >(const algo::WTime &rhs) const {
    return algo::WTime_Lt(const_cast<algo::WTime&>(rhs),const_cast<algo::WTime&>(*this));
}

// --- algo.WTime..LeOp
inline bool algo::WTime::operator <=(const algo::WTime &rhs) const {
    return !algo::WTime_Lt(const_cast<algo::WTime&>(rhs),const_cast<algo::WTime&>(*this));
}

// --- algo.WTime..GeOp
inline bool algo::WTime::operator >=(const algo::WTime &rhs) const {
    return !algo::WTime_Lt(const_cast<algo::WTime&>(*this),const_cast<algo::WTime&>(rhs));
}

// --- algo.WTime..Lt
inline bool algo::WTime_Lt(algo::WTime lhs, algo::WTime rhs) {
    return i64_Lt(lhs.value, rhs.value);
}

// --- algo.WTime..Cmp
inline i32 algo::WTime_Cmp(algo::WTime lhs, algo::WTime rhs) {
    i32 retval = 0;
    retval = i64_Cmp(lhs.value, rhs.value);
    return retval;
}

// --- algo.WTime..Init
// Set all fields to initial values.
inline void algo::WTime_Init(algo::WTime& parent) {
    parent.value = i64(0);
}

// --- algo.WTime..UpdateMax
// Attempt to make LHS bigger. Return true if it was changed
inline bool algo::WTime_UpdateMax(algo::WTime &lhs, algo::WTime rhs) {
    bool retval = lhs < rhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.WTime..Min
// Return the lesser of two values
inline algo::WTime algo::WTime_Min(algo::WTime lhs, algo::WTime rhs) {
    return lhs < rhs ? lhs : rhs;
}

// --- algo.WTime..UpdateMin
// Attempt to make LHS smaller. Return true if it was changed
inline bool algo::WTime_UpdateMin(algo::WTime &lhs, algo::WTime rhs) {
    bool retval = rhs < lhs;
    if (retval) {
        lhs = rhs;
    }
    return retval;
}

// --- algo.WTime..Max
// Return the greater of two values
inline algo::WTime algo::WTime_Max(algo::WTime lhs, algo::WTime rhs) {
    return rhs < lhs ? lhs : rhs;
}

// --- algo.WTime..Eq
inline bool algo::WTime_Eq(algo::WTime lhs, algo::WTime rhs) {
    bool retval = true;
    retval = i64_Eq(lhs.value, rhs.value);
    return retval;
}

// --- algo.WTime..Update
// Set value. Return true if new value is different from old value.
inline bool algo::WTime_Update(algo::WTime &lhs, algo::WTime rhs) {
    bool ret = !WTime_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.WTime..Ctor
inline  algo::WTime::WTime() {
    algo::WTime_Init(*this);
}

// --- algo.WTime..FieldwiseCtor
inline  algo::WTime::WTime(i64 in_value)
    : value(in_value)
 {
}

// --- algo.i32_Range..Hash
inline u32 algo::i32_Range_Hash(u32 prev, const algo::i32_Range& rhs) {
    prev = i32_Hash(prev, rhs.beg);
    prev = i32_Hash(prev, rhs.end);
    return prev;
}

// --- algo.i32_Range..EqOp
inline bool algo::i32_Range::operator ==(const algo::i32_Range &rhs) const {
    return algo::i32_Range_Eq(const_cast<algo::i32_Range&>(*this),const_cast<algo::i32_Range&>(rhs));
}

// --- algo.i32_Range..NeOp
inline bool algo::i32_Range::operator !=(const algo::i32_Range &rhs) const {
    return !algo::i32_Range_Eq(const_cast<algo::i32_Range&>(*this),const_cast<algo::i32_Range&>(rhs));
}

// --- algo.i32_Range..LtOp
inline bool algo::i32_Range::operator <(const algo::i32_Range &rhs) const {
    return algo::i32_Range_Lt(const_cast<algo::i32_Range&>(*this),const_cast<algo::i32_Range&>(rhs));
}

// --- algo.i32_Range..GtOp
inline bool algo::i32_Range::operator >(const algo::i32_Range &rhs) const {
    return algo::i32_Range_Lt(const_cast<algo::i32_Range&>(rhs),const_cast<algo::i32_Range&>(*this));
}

// --- algo.i32_Range..LeOp
inline bool algo::i32_Range::operator <=(const algo::i32_Range &rhs) const {
    return !algo::i32_Range_Lt(const_cast<algo::i32_Range&>(rhs),const_cast<algo::i32_Range&>(*this));
}

// --- algo.i32_Range..GeOp
inline bool algo::i32_Range::operator >=(const algo::i32_Range &rhs) const {
    return !algo::i32_Range_Lt(const_cast<algo::i32_Range&>(*this),const_cast<algo::i32_Range&>(rhs));
}

// --- algo.i32_Range..Lt
inline bool algo::i32_Range_Lt(algo::i32_Range& lhs, algo::i32_Range& rhs) {
    return i32_Range_Cmp(lhs,rhs) < 0;
}

// --- algo.i32_Range..Cmp
inline i32 algo::i32_Range_Cmp(algo::i32_Range& lhs, algo::i32_Range& rhs) {
    i32 retval = 0;
    retval = i32_Cmp(lhs.beg, rhs.beg);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.end, rhs.end);
    return retval;
}

// --- algo.i32_Range..Init
// Set all fields to initial values.
inline void algo::i32_Range_Init(algo::i32_Range& parent) {
    parent.beg = i32(0);
    parent.end = i32(0);
}

// --- algo.i32_Range..Eq
inline bool algo::i32_Range_Eq(algo::i32_Range& lhs, algo::i32_Range& rhs) {
    bool retval = true;
    retval = i32_Eq(lhs.beg, rhs.beg);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.end, rhs.end);
    return retval;
}

// --- algo.i32_Range..Update
// Set value. Return true if new value is different from old value.
inline bool algo::i32_Range_Update(algo::i32_Range &lhs, algo::i32_Range& rhs) {
    bool ret = !i32_Range_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}

// --- algo.i32_Range..Ctor
inline  algo::i32_Range::i32_Range() {
    algo::i32_Range_Init(*this);
}

// --- algo.i32_Range..FieldwiseCtor
inline  algo::i32_Range::i32_Range(i32 in_beg, i32 in_end)
    : beg(in_beg)
    , end(in_end)
 {
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Attr &row) {// cfmt:algo.Attr.String
    algo::Attr_Print(const_cast<algo::Attr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Bool &row) {// cfmt:algo.Bool.String
    algo::Bool_Print(const_cast<algo::Bool&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Comment &row) {// cfmt:algo.Comment.String
    algo::Comment_Print(const_cast<algo::Comment&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::CppExpr &row) {// cfmt:algo.CppExpr.String
    algo::CppExpr_Print(const_cast<algo::CppExpr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnTime &row) {// cfmt:algo.UnTime.String
    algo::UnTime_Print(const_cast<algo::UnTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Decimal &row) {// cfmt:algo.Decimal.String
    algo::Decimal_Print(const_cast<algo::Decimal&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::DryrunQ &row) {// cfmt:algo.DryrunQ.String
    algo::DryrunQ_Print(const_cast<algo::DryrunQ&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::EchoQ &row) {// cfmt:algo.EchoQ.String
    algo::EchoQ_Print(const_cast<algo::EchoQ&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Errcode &row) {// cfmt:algo.Errcode.String
    algo::Errcode_Print(const_cast<algo::Errcode&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::FailokQ &row) {// cfmt:algo.FailokQ.String
    algo::FailokQ_Print(const_cast<algo::FailokQ&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::FieldId &row) {// cfmt:algo.FieldId.String
    algo::FieldId_Print(const_cast<algo::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Fildes &row) {// cfmt:algo.Fildes.String
    algo::Fildes_Print(const_cast<algo::Fildes&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::FileFlags &row) {// cfmt:algo.FileFlags.String
    algo::FileFlags_Print(const_cast<algo::FileFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec1 &row) {// cfmt:algo.I32Dec1.String
    algo::I32Dec1_Print(const_cast<algo::I32Dec1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec2 &row) {// cfmt:algo.I32Dec2.String
    algo::I32Dec2_Print(const_cast<algo::I32Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec3 &row) {// cfmt:algo.I32Dec3.String
    algo::I32Dec3_Print(const_cast<algo::I32Dec3&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec4 &row) {// cfmt:algo.I32Dec4.String
    algo::I32Dec4_Print(const_cast<algo::I32Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I32Dec5 &row) {// cfmt:algo.I32Dec5.String
    algo::I32Dec5_Print(const_cast<algo::I32Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec1 &row) {// cfmt:algo.I64Dec1.String
    algo::I64Dec1_Print(const_cast<algo::I64Dec1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec10 &row) {// cfmt:algo.I64Dec10.String
    algo::I64Dec10_Print(const_cast<algo::I64Dec10&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec2 &row) {// cfmt:algo.I64Dec2.String
    algo::I64Dec2_Print(const_cast<algo::I64Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec3 &row) {// cfmt:algo.I64Dec3.String
    algo::I64Dec3_Print(const_cast<algo::I64Dec3&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec4 &row) {// cfmt:algo.I64Dec4.String
    algo::I64Dec4_Print(const_cast<algo::I64Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec5 &row) {// cfmt:algo.I64Dec5.String
    algo::I64Dec5_Print(const_cast<algo::I64Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec6 &row) {// cfmt:algo.I64Dec6.String
    algo::I64Dec6_Print(const_cast<algo::I64Dec6&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec7 &row) {// cfmt:algo.I64Dec7.String
    algo::I64Dec7_Print(const_cast<algo::I64Dec7&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec8 &row) {// cfmt:algo.I64Dec8.String
    algo::I64Dec8_Print(const_cast<algo::I64Dec8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::I64Dec9 &row) {// cfmt:algo.I64Dec9.String
    algo::I64Dec9_Print(const_cast<algo::I64Dec9&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::IOEvtFlags &row) {// cfmt:algo.IOEvtFlags.String
    algo::IOEvtFlags_Print(const_cast<algo::IOEvtFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Imdb &row) {// cfmt:algo.Imdb.String
    algo::Imdb_Print(const_cast<algo::Imdb&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::ImrowPtr &row) {// cfmt:algo.ImrowPtr.String
    algo::ImrowPtr_Print(const_cast<algo::ImrowPtr&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Imtable &row) {// cfmt:algo.Imtable.String
    algo::Imtable_Print(const_cast<algo::Imtable&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Ipmask &row) {// cfmt:algo.Ipmask.String
    algo::Ipmask_Print(const_cast<algo::Ipmask&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Md5Digest &row) {// cfmt:algo.Md5Digest.String
    algo::Md5Digest_Print(const_cast<algo::Md5Digest&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Month &row) {// cfmt:algo.Month.String
    algo::Month_Print(const_cast<algo::Month&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::NumParseFlags &row) {// cfmt:algo.NumParseFlags.String
    algo::NumParseFlags_Print(const_cast<algo::NumParseFlags&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::SchedTime &row) {// cfmt:algo.SchedTime.String
    algo::SchedTime_Print(const_cast<algo::SchedTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::SeqType &row) {// cfmt:algo.SeqType.String
    algo::SeqType_Print(const_cast<algo::SeqType&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Sha1sig &row) {// cfmt:algo.Sha1sig.String
    algo::Sha1sig_Print(const_cast<algo::Sha1sig&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::StringAry &row) {// cfmt:algo.StringAry.String
    algo::StringAry_Print(const_cast<algo::StringAry&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::TermStyle &row) {// cfmt:algo.TermStyle.String
    algo::TermStyle_Print(const_cast<algo::TermStyle&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::TextJust &row) {// cfmt:algo.TextJust.String
    algo::TextJust_Print(const_cast<algo::TextJust&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Tuple &row) {// cfmt:algo.Tuple.String
    algo::Tuple_Print(const_cast<algo::Tuple&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U16Dec2 &row) {// cfmt:algo.U16Dec2.String
    algo::U16Dec2_Print(const_cast<algo::U16Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec1 &row) {// cfmt:algo.U32Dec1.String
    algo::U32Dec1_Print(const_cast<algo::U32Dec1&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec2 &row) {// cfmt:algo.U32Dec2.String
    algo::U32Dec2_Print(const_cast<algo::U32Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec3 &row) {// cfmt:algo.U32Dec3.String
    algo::U32Dec3_Print(const_cast<algo::U32Dec3&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec4 &row) {// cfmt:algo.U32Dec4.String
    algo::U32Dec4_Print(const_cast<algo::U32Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U32Dec5 &row) {// cfmt:algo.U32Dec5.String
    algo::U32Dec5_Print(const_cast<algo::U32Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec10 &row) {// cfmt:algo.U64Dec10.String
    algo::U64Dec10_Print(const_cast<algo::U64Dec10&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec2 &row) {// cfmt:algo.U64Dec2.String
    algo::U64Dec2_Print(const_cast<algo::U64Dec2&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec4 &row) {// cfmt:algo.U64Dec4.String
    algo::U64Dec4_Print(const_cast<algo::U64Dec4&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec5 &row) {// cfmt:algo.U64Dec5.String
    algo::U64Dec5_Print(const_cast<algo::U64Dec5&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec6 &row) {// cfmt:algo.U64Dec6.String
    algo::U64Dec6_Print(const_cast<algo::U64Dec6&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec7 &row) {// cfmt:algo.U64Dec7.String
    algo::U64Dec7_Print(const_cast<algo::U64Dec7&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec8 &row) {// cfmt:algo.U64Dec8.String
    algo::U64Dec8_Print(const_cast<algo::U64Dec8&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::U64Dec9 &row) {// cfmt:algo.U64Dec9.String
    algo::U64Dec9_Print(const_cast<algo::U64Dec9&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::URL &row) {// cfmt:algo.URL.String
    algo::URL_Print(const_cast<algo::URL&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnDiff &row) {// cfmt:algo.UnDiff.String
    algo::UnDiff_Print(const_cast<algo::UnDiff&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnixDiff &row) {// cfmt:algo.UnixDiff.String
    algo::UnixDiff_Print(const_cast<algo::UnixDiff&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::UnixTime &row) {// cfmt:algo.UnixTime.String
    algo::UnixTime_Print(const_cast<algo::UnixTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::Uuid &row) {// cfmt:algo.Uuid.String
    algo::Uuid_Print(const_cast<algo::Uuid&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::WDiff &row) {// cfmt:algo.WDiff.String
    algo::WDiff_Print(const_cast<algo::WDiff&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::WTime &row) {// cfmt:algo.WTime.String
    algo::WTime_Print(const_cast<algo::WTime&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo::i32_Range &row) {// cfmt:algo.i32_Range.String
    algo::i32_Range_Print(const_cast<algo::i32_Range&>(row), str);
    return str;
}
