//
// include/gen/command_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
//#pragma endinclude
inline command::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline command::FieldId::FieldId(command_FieldIdEnum arg) { this->value = i32(arg); }
inline command::FieldId::FieldId() {
    command::FieldId_Init(*this);
}


// --- command.FieldId.value.GetEnum
// Get value of field as enum type
inline command_FieldIdEnum command::value_GetEnum(const command::FieldId& parent) {
    return command_FieldIdEnum(parent.value);
}

// --- command.FieldId.value.SetEnum
// Set value of field from enum type.
inline void command::value_SetEnum(command::FieldId& parent, command_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- command.FieldId.value.Cast
inline command::FieldId::operator command_FieldIdEnum () const {
    return command_FieldIdEnum((*this).value);
}

// --- command.FieldId..Init
// Set all fields to initial values.
inline void command::FieldId_Init(command::FieldId& parent) {
    parent.value = i32(-1);
}
inline command::abt::abt() {
    command::abt_Init(*this);
}


// --- command.abt.cache.GetEnum
// Get value of field as enum type
inline command_abt_cache_Enum command::cache_GetEnum(const command::abt& parent) {
    return command_abt_cache_Enum(parent.cache);
}

// --- command.abt.cache.SetEnum
// Set value of field from enum type.
inline void command::cache_SetEnum(command::abt& parent, command_abt_cache_Enum rhs) {
    parent.cache = u8(rhs);
}
inline command::abt_md::abt_md() {
    command::abt_md_Init(*this);
}

inline command::abt_md_proc::abt_md_proc() {
    command::abt_md_proc_Init(*this);
}

inline command::abt_md_proc::~abt_md_proc() {
    command::abt_md_proc_Uninit(*this);
}


// --- command.abt_md_proc..Init
// Set all fields to initial values.
inline void command::abt_md_proc_Init(command::abt_md_proc& parent) {
    parent.path = algo::strptr("bin/abt_md");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::abt_proc::abt_proc() {
    command::abt_proc_Init(*this);
}

inline command::abt_proc::~abt_proc() {
    command::abt_proc_Uninit(*this);
}


// --- command.abt_proc..Init
// Set all fields to initial values.
inline void command::abt_proc_Init(command::abt_proc& parent) {
    parent.path = algo::strptr("bin/abt");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::acr::acr() {
    command::acr_Init(*this);
}

inline command::acr::~acr() {
    command::acr_Uninit(*this);
}


// --- command.acr.where.EmptyQ
// Return true if index is empty
inline bool command::where_EmptyQ(command::acr& parent) {
    return parent.where_n == 0;
}

// --- command.acr.where.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::where_Find(command::acr& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.where_n;
    if (idx >= lim) return NULL;
    return parent.where_elems + idx;
}

// --- command.acr.where.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::where_Getary(const command::acr& parent) {
    return algo::aryptr<algo::cstring>(parent.where_elems, parent.where_n);
}

// --- command.acr.where.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::where_Last(command::acr& parent) {
    return where_Find(parent, u64(parent.where_n-1));
}

// --- command.acr.where.Max
// Return max. number of items in the array
inline i32 command::where_Max(command::acr& parent) {
    (void)parent;
    return parent.where_max;
}

// --- command.acr.where.N
// Return number of items in the array
inline i32 command::where_N(const command::acr& parent) {
    return parent.where_n;
}

// --- command.acr.where.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::where_Reserve(command::acr& parent, int n) {
    u32 new_n = parent.where_n + n;
    if (UNLIKELY(new_n > parent.where_max)) {
        where_AbsReserve(parent, new_n);
    }
}

// --- command.acr.where.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::where_qFind(command::acr& parent, u64 t) {
    return parent.where_elems[t];
}

// --- command.acr.where.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::where_qLast(command::acr& parent) {
    return where_qFind(parent, u64(parent.where_n-1));
}

// --- command.acr.where.rowid_Get
// Return row id of specified element
inline u64 command::where_rowid_Get(command::acr& parent, algo::cstring &elem) {
    u64 id = &elem - parent.where_elems;
    return u64(id);
}

// --- command.acr.field.EmptyQ
// Return true if index is empty
inline bool command::field_EmptyQ(command::acr& parent) {
    return parent.field_n == 0;
}

// --- command.acr.field.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::field_Find(command::acr& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.field_n;
    if (idx >= lim) return NULL;
    return parent.field_elems + idx;
}

// --- command.acr.field.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::field_Getary(const command::acr& parent) {
    return algo::aryptr<algo::cstring>(parent.field_elems, parent.field_n);
}

// --- command.acr.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::field_Last(command::acr& parent) {
    return field_Find(parent, u64(parent.field_n-1));
}

// --- command.acr.field.Max
// Return max. number of items in the array
inline i32 command::field_Max(command::acr& parent) {
    (void)parent;
    return parent.field_max;
}

// --- command.acr.field.N
// Return number of items in the array
inline i32 command::field_N(const command::acr& parent) {
    return parent.field_n;
}

// --- command.acr.field.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::field_Reserve(command::acr& parent, int n) {
    u32 new_n = parent.field_n + n;
    if (UNLIKELY(new_n > parent.field_max)) {
        field_AbsReserve(parent, new_n);
    }
}

// --- command.acr.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::field_qFind(command::acr& parent, u64 t) {
    return parent.field_elems[t];
}

// --- command.acr.field.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::field_qLast(command::acr& parent) {
    return field_qFind(parent, u64(parent.field_n-1));
}

// --- command.acr.field.rowid_Get
// Return row id of specified element
inline u64 command::field_rowid_Get(command::acr& parent, algo::cstring &elem) {
    u64 id = &elem - parent.field_elems;
    return u64(id);
}

// --- command.acr.where_curs.Next
// proceed to next item
inline void command::acr_where_curs_Next(acr_where_curs &curs) {
    curs.index++;
}

// --- command.acr.where_curs.Reset
inline void command::acr_where_curs_Reset(acr_where_curs &curs, command::acr &parent) {
    curs.elems = parent.where_elems;
    curs.n_elems = parent.where_n;
    curs.index = 0;
}

// --- command.acr.where_curs.ValidQ
// cursor points to valid item
inline bool command::acr_where_curs_ValidQ(acr_where_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.acr.where_curs.Access
// item access
inline algo::cstring& command::acr_where_curs_Access(acr_where_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.acr.field_curs.Next
// proceed to next item
inline void command::acr_field_curs_Next(acr_field_curs &curs) {
    curs.index++;
}

// --- command.acr.field_curs.Reset
inline void command::acr_field_curs_Reset(acr_field_curs &curs, command::acr &parent) {
    curs.elems = parent.field_elems;
    curs.n_elems = parent.field_n;
    curs.index = 0;
}

// --- command.acr.field_curs.ValidQ
// cursor points to valid item
inline bool command::acr_field_curs_ValidQ(acr_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.acr.field_curs.Access
// item access
inline algo::cstring& command::acr_field_curs_Access(acr_field_curs &curs) {
    return curs.elems[curs.index];
}
inline command::acr_compl::acr_compl() {
    command::acr_compl_Init(*this);
}


// --- command.acr_compl..Init
// Set all fields to initial values.
inline void command::acr_compl_Init(command::acr_compl& parent) {
    parent.data = algo::strptr("data");
    parent.schema = algo::strptr("data");
    parent.line = algo::strptr("");
    parent.point = algo::strptr("");
    parent.type = algo::strptr("9");
    parent.install = bool(false);
    parent.debug_log = algo::strptr("");
}
inline command::acr_compl_proc::acr_compl_proc() {
    command::acr_compl_proc_Init(*this);
}

inline command::acr_compl_proc::~acr_compl_proc() {
    command::acr_compl_proc_Uninit(*this);
}


// --- command.acr_compl_proc..Init
// Set all fields to initial values.
inline void command::acr_compl_proc_Init(command::acr_compl_proc& parent) {
    parent.path = algo::strptr("bin/acr_compl");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::acr_dm::acr_dm() {
    command::acr_dm_Init(*this);
}

inline command::acr_dm::~acr_dm() {
    command::acr_dm_Uninit(*this);
}


// --- command.acr_dm.arg.EmptyQ
// Return true if index is empty
inline bool command::arg_EmptyQ(command::acr_dm& parent) {
    return parent.arg_n == 0;
}

// --- command.acr_dm.arg.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::arg_Find(command::acr_dm& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.arg_n;
    if (idx >= lim) return NULL;
    return parent.arg_elems + idx;
}

// --- command.acr_dm.arg.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::arg_Getary(const command::acr_dm& parent) {
    return algo::aryptr<algo::cstring>(parent.arg_elems, parent.arg_n);
}

// --- command.acr_dm.arg.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::arg_Last(command::acr_dm& parent) {
    return arg_Find(parent, u64(parent.arg_n-1));
}

// --- command.acr_dm.arg.Max
// Return max. number of items in the array
inline i32 command::arg_Max(command::acr_dm& parent) {
    (void)parent;
    return parent.arg_max;
}

// --- command.acr_dm.arg.N
// Return number of items in the array
inline i32 command::arg_N(const command::acr_dm& parent) {
    return parent.arg_n;
}

// --- command.acr_dm.arg.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::arg_Reserve(command::acr_dm& parent, int n) {
    u32 new_n = parent.arg_n + n;
    if (UNLIKELY(new_n > parent.arg_max)) {
        arg_AbsReserve(parent, new_n);
    }
}

// --- command.acr_dm.arg.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::arg_qFind(command::acr_dm& parent, u64 t) {
    return parent.arg_elems[t];
}

// --- command.acr_dm.arg.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::arg_qLast(command::acr_dm& parent) {
    return arg_qFind(parent, u64(parent.arg_n-1));
}

// --- command.acr_dm.arg.rowid_Get
// Return row id of specified element
inline u64 command::arg_rowid_Get(command::acr_dm& parent, algo::cstring &elem) {
    u64 id = &elem - parent.arg_elems;
    return u64(id);
}

// --- command.acr_dm.arg_curs.Next
// proceed to next item
inline void command::acr_dm_arg_curs_Next(acr_dm_arg_curs &curs) {
    curs.index++;
}

// --- command.acr_dm.arg_curs.Reset
inline void command::acr_dm_arg_curs_Reset(acr_dm_arg_curs &curs, command::acr_dm &parent) {
    curs.elems = parent.arg_elems;
    curs.n_elems = parent.arg_n;
    curs.index = 0;
}

// --- command.acr_dm.arg_curs.ValidQ
// cursor points to valid item
inline bool command::acr_dm_arg_curs_ValidQ(acr_dm_arg_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.acr_dm.arg_curs.Access
// item access
inline algo::cstring& command::acr_dm_arg_curs_Access(acr_dm_arg_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.acr_dm..Init
// Set all fields to initial values.
inline void command::acr_dm_Init(command::acr_dm& parent) {
    parent.in = algo::strptr("data");
    parent.arg_elems 	= 0; // (command.acr_dm.arg)
    parent.arg_n     	= 0; // (command.acr_dm.arg)
    parent.arg_max   	= 0; // (command.acr_dm.arg)
    parent.write_ours = bool(false);
    parent.msize = u8(7);
    parent.rowid = bool(false);
}
inline command::acr_dm_proc::acr_dm_proc() {
    command::acr_dm_proc_Init(*this);
}

inline command::acr_dm_proc::~acr_dm_proc() {
    command::acr_dm_proc_Uninit(*this);
}


// --- command.acr_dm_proc..Init
// Set all fields to initial values.
inline void command::acr_dm_proc_Init(command::acr_dm_proc& parent) {
    parent.path = algo::strptr("bin/acr_dm");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::acr_ed::acr_ed() {
    command::acr_ed_Init(*this);
}

inline command::acr_ed_proc::acr_ed_proc() {
    command::acr_ed_proc_Init(*this);
}

inline command::acr_ed_proc::~acr_ed_proc() {
    command::acr_ed_proc_Uninit(*this);
}


// --- command.acr_ed_proc..Init
// Set all fields to initial values.
inline void command::acr_ed_proc_Init(command::acr_ed_proc& parent) {
    parent.path = algo::strptr("bin/acr_ed");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::acr_in::acr_in() {
    command::acr_in_Init(*this);
}

inline command::acr_in_proc::acr_in_proc() {
    command::acr_in_proc_Init(*this);
}

inline command::acr_in_proc::~acr_in_proc() {
    command::acr_in_proc_Uninit(*this);
}


// --- command.acr_in_proc..Init
// Set all fields to initial values.
inline void command::acr_in_proc_Init(command::acr_in_proc& parent) {
    parent.path = algo::strptr("bin/acr_in");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::acr_my::acr_my() {
    command::acr_my_Init(*this);
}

inline command::acr_my_proc::acr_my_proc() {
    command::acr_my_proc_Init(*this);
}

inline command::acr_my_proc::~acr_my_proc() {
    command::acr_my_proc_Uninit(*this);
}


// --- command.acr_my_proc..Init
// Set all fields to initial values.
inline void command::acr_my_proc_Init(command::acr_my_proc& parent) {
    parent.path = algo::strptr("bin/acr_my");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::acr_proc::acr_proc() {
    command::acr_proc_Init(*this);
}

inline command::acr_proc::~acr_proc() {
    command::acr_proc_Uninit(*this);
}


// --- command.acr_proc..Init
// Set all fields to initial values.
inline void command::acr_proc_Init(command::acr_proc& parent) {
    parent.path = algo::strptr("bin/acr");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::amc::amc() {
    command::amc_Init(*this);
}

inline command::amc_gc::amc_gc() {
    command::amc_gc_Init(*this);
}

inline command::amc_gc_proc::amc_gc_proc() {
    command::amc_gc_proc_Init(*this);
}

inline command::amc_gc_proc::~amc_gc_proc() {
    command::amc_gc_proc_Uninit(*this);
}


// --- command.amc_gc_proc..Init
// Set all fields to initial values.
inline void command::amc_gc_proc_Init(command::amc_gc_proc& parent) {
    parent.path = algo::strptr("bin/amc_gc");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::amc_proc::amc_proc() {
    command::amc_proc_Init(*this);
}

inline command::amc_proc::~amc_proc() {
    command::amc_proc_Uninit(*this);
}


// --- command.amc_proc..Init
// Set all fields to initial values.
inline void command::amc_proc_Init(command::amc_proc& parent) {
    parent.path = algo::strptr("bin/amc");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::amc_vis::amc_vis() {
    command::amc_vis_Init(*this);
}

inline command::amc_vis_proc::amc_vis_proc() {
    command::amc_vis_proc_Init(*this);
}

inline command::amc_vis_proc::~amc_vis_proc() {
    command::amc_vis_proc_Uninit(*this);
}


// --- command.amc_vis_proc..Init
// Set all fields to initial values.
inline void command::amc_vis_proc_Init(command::amc_vis_proc& parent) {
    parent.path = algo::strptr("bin/amc_vis");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::ams_cat::ams_cat() {
    command::ams_cat_Init(*this);
}


// --- command.ams_cat..Init
// Set all fields to initial values.
inline void command::ams_cat_Init(command::ams_cat& parent) {
    parent.in = algo::strptr("data");
}
inline command::ams_cat_proc::ams_cat_proc() {
    command::ams_cat_proc_Init(*this);
}

inline command::ams_cat_proc::~ams_cat_proc() {
    command::ams_cat_proc_Uninit(*this);
}


// --- command.ams_cat_proc..Init
// Set all fields to initial values.
inline void command::ams_cat_proc_Init(command::ams_cat_proc& parent) {
    parent.path = algo::strptr("bin/ams_cat");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::ams_sendtest::ams_sendtest() {
    command::ams_sendtest_Init(*this);
}

inline command::ams_sendtest_proc::ams_sendtest_proc() {
    command::ams_sendtest_proc_Init(*this);
}

inline command::ams_sendtest_proc::~ams_sendtest_proc() {
    command::ams_sendtest_proc_Uninit(*this);
}


// --- command.ams_sendtest_proc..Init
// Set all fields to initial values.
inline void command::ams_sendtest_proc_Init(command::ams_sendtest_proc& parent) {
    parent.path = algo::strptr("bin/ams_sendtest");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::apm::apm() {
    command::apm_Init(*this);
}

inline command::apm_proc::apm_proc() {
    command::apm_proc_Init(*this);
}

inline command::apm_proc::~apm_proc() {
    command::apm_proc_Uninit(*this);
}


// --- command.apm_proc..Init
// Set all fields to initial values.
inline void command::apm_proc_Init(command::apm_proc& parent) {
    parent.path = algo::strptr("bin/apm");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::aqlite::aqlite() {
    command::aqlite_Init(*this);
}


// --- command.aqlite..Init
// Set all fields to initial values.
inline void command::aqlite_Init(command::aqlite& parent) {
    parent.in = algo::strptr("data");
    parent.data = algo::strptr("data");
}
inline command::aqlite_proc::aqlite_proc() {
    command::aqlite_proc_Init(*this);
}

inline command::aqlite_proc::~aqlite_proc() {
    command::aqlite_proc_Uninit(*this);
}


// --- command.aqlite_proc..Init
// Set all fields to initial values.
inline void command::aqlite_proc_Init(command::aqlite_proc& parent) {
    parent.path = algo::strptr("bin/aqlite");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_amc::atf_amc() {
    command::atf_amc_Init(*this);
}

inline command::atf_amc_proc::atf_amc_proc() {
    command::atf_amc_proc_Init(*this);
}

inline command::atf_amc_proc::~atf_amc_proc() {
    command::atf_amc_proc_Uninit(*this);
}


// --- command.atf_amc_proc..Init
// Set all fields to initial values.
inline void command::atf_amc_proc_Init(command::atf_amc_proc& parent) {
    parent.path = algo::strptr("bin/atf_amc");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_ci::atf_ci() {
    command::atf_ci_Init(*this);
}

inline command::atf_ci_proc::atf_ci_proc() {
    command::atf_ci_proc_Init(*this);
}

inline command::atf_ci_proc::~atf_ci_proc() {
    command::atf_ci_proc_Uninit(*this);
}


// --- command.atf_ci_proc..Init
// Set all fields to initial values.
inline void command::atf_ci_proc_Init(command::atf_ci_proc& parent) {
    parent.path = algo::strptr("bin/atf_ci");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_cmdline::atf_cmdline() {
    command::atf_cmdline_Init(*this);
}

inline command::atf_cmdline::~atf_cmdline() {
    command::atf_cmdline_Uninit(*this);
}


// --- command.atf_cmdline.mstr.EmptyQ
// Return true if index is empty
inline bool command::mstr_EmptyQ(command::atf_cmdline& parent) {
    return parent.mstr_n == 0;
}

// --- command.atf_cmdline.mstr.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::mstr_Find(command::atf_cmdline& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.mstr_n;
    if (idx >= lim) return NULL;
    return parent.mstr_elems + idx;
}

// --- command.atf_cmdline.mstr.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::mstr_Getary(const command::atf_cmdline& parent) {
    return algo::aryptr<algo::cstring>(parent.mstr_elems, parent.mstr_n);
}

// --- command.atf_cmdline.mstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::mstr_Last(command::atf_cmdline& parent) {
    return mstr_Find(parent, u64(parent.mstr_n-1));
}

// --- command.atf_cmdline.mstr.Max
// Return max. number of items in the array
inline i32 command::mstr_Max(command::atf_cmdline& parent) {
    (void)parent;
    return parent.mstr_max;
}

// --- command.atf_cmdline.mstr.N
// Return number of items in the array
inline i32 command::mstr_N(const command::atf_cmdline& parent) {
    return parent.mstr_n;
}

// --- command.atf_cmdline.mstr.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::mstr_Reserve(command::atf_cmdline& parent, int n) {
    u32 new_n = parent.mstr_n + n;
    if (UNLIKELY(new_n > parent.mstr_max)) {
        mstr_AbsReserve(parent, new_n);
    }
}

// --- command.atf_cmdline.mstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::mstr_qFind(command::atf_cmdline& parent, u64 t) {
    return parent.mstr_elems[t];
}

// --- command.atf_cmdline.mstr.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::mstr_qLast(command::atf_cmdline& parent) {
    return mstr_qFind(parent, u64(parent.mstr_n-1));
}

// --- command.atf_cmdline.mstr.rowid_Get
// Return row id of specified element
inline u64 command::mstr_rowid_Get(command::atf_cmdline& parent, algo::cstring &elem) {
    u64 id = &elem - parent.mstr_elems;
    return u64(id);
}

// --- command.atf_cmdline.mnum.EmptyQ
// Return true if index is empty
inline bool command::mnum_EmptyQ(command::atf_cmdline& parent) {
    return parent.mnum_n == 0;
}

// --- command.atf_cmdline.mnum.Find
// Look up row by row id. Return NULL if out of range
inline i32* command::mnum_Find(command::atf_cmdline& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.mnum_n;
    if (idx >= lim) return NULL;
    return parent.mnum_elems + idx;
}

// --- command.atf_cmdline.mnum.Getary
// Return array pointer by value
inline algo::aryptr<i32> command::mnum_Getary(const command::atf_cmdline& parent) {
    return algo::aryptr<i32>(parent.mnum_elems, parent.mnum_n);
}

// --- command.atf_cmdline.mnum.Last
// Return pointer to last element of array, or NULL if array is empty
inline i32* command::mnum_Last(command::atf_cmdline& parent) {
    return mnum_Find(parent, u64(parent.mnum_n-1));
}

// --- command.atf_cmdline.mnum.Max
// Return max. number of items in the array
inline i32 command::mnum_Max(command::atf_cmdline& parent) {
    (void)parent;
    return parent.mnum_max;
}

// --- command.atf_cmdline.mnum.N
// Return number of items in the array
inline i32 command::mnum_N(const command::atf_cmdline& parent) {
    return parent.mnum_n;
}

// --- command.atf_cmdline.mnum.RemoveAll
inline void command::mnum_RemoveAll(command::atf_cmdline& parent) {
    parent.mnum_n = 0;
}

// --- command.atf_cmdline.mnum.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::mnum_Reserve(command::atf_cmdline& parent, int n) {
    u32 new_n = parent.mnum_n + n;
    if (UNLIKELY(new_n > parent.mnum_max)) {
        mnum_AbsReserve(parent, new_n);
    }
}

// --- command.atf_cmdline.mnum.qFind
// 'quick' Access row by row id. No bounds checking.
inline i32& command::mnum_qFind(command::atf_cmdline& parent, u64 t) {
    return parent.mnum_elems[t];
}

// --- command.atf_cmdline.mnum.qLast
// Return reference to last element of array. No bounds checking
inline i32& command::mnum_qLast(command::atf_cmdline& parent) {
    return mnum_qFind(parent, u64(parent.mnum_n-1));
}

// --- command.atf_cmdline.mnum.rowid_Get
// Return row id of specified element
inline u64 command::mnum_rowid_Get(command::atf_cmdline& parent, i32 &elem) {
    u64 id = &elem - parent.mnum_elems;
    return u64(id);
}

// --- command.atf_cmdline.mdbl.EmptyQ
// Return true if index is empty
inline bool command::mdbl_EmptyQ(command::atf_cmdline& parent) {
    return parent.mdbl_n == 0;
}

// --- command.atf_cmdline.mdbl.Find
// Look up row by row id. Return NULL if out of range
inline double* command::mdbl_Find(command::atf_cmdline& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.mdbl_n;
    if (idx >= lim) return NULL;
    return parent.mdbl_elems + idx;
}

// --- command.atf_cmdline.mdbl.Getary
// Return array pointer by value
inline algo::aryptr<double> command::mdbl_Getary(const command::atf_cmdline& parent) {
    return algo::aryptr<double>(parent.mdbl_elems, parent.mdbl_n);
}

// --- command.atf_cmdline.mdbl.Last
// Return pointer to last element of array, or NULL if array is empty
inline double* command::mdbl_Last(command::atf_cmdline& parent) {
    return mdbl_Find(parent, u64(parent.mdbl_n-1));
}

// --- command.atf_cmdline.mdbl.Max
// Return max. number of items in the array
inline i32 command::mdbl_Max(command::atf_cmdline& parent) {
    (void)parent;
    return parent.mdbl_max;
}

// --- command.atf_cmdline.mdbl.N
// Return number of items in the array
inline i32 command::mdbl_N(const command::atf_cmdline& parent) {
    return parent.mdbl_n;
}

// --- command.atf_cmdline.mdbl.RemoveAll
inline void command::mdbl_RemoveAll(command::atf_cmdline& parent) {
    parent.mdbl_n = 0;
}

// --- command.atf_cmdline.mdbl.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::mdbl_Reserve(command::atf_cmdline& parent, int n) {
    u32 new_n = parent.mdbl_n + n;
    if (UNLIKELY(new_n > parent.mdbl_max)) {
        mdbl_AbsReserve(parent, new_n);
    }
}

// --- command.atf_cmdline.mdbl.qFind
// 'quick' Access row by row id. No bounds checking.
inline double& command::mdbl_qFind(command::atf_cmdline& parent, u64 t) {
    return parent.mdbl_elems[t];
}

// --- command.atf_cmdline.mdbl.qLast
// Return reference to last element of array. No bounds checking
inline double& command::mdbl_qLast(command::atf_cmdline& parent) {
    return mdbl_qFind(parent, u64(parent.mdbl_n-1));
}

// --- command.atf_cmdline.mdbl.rowid_Get
// Return row id of specified element
inline u64 command::mdbl_rowid_Get(command::atf_cmdline& parent, double &elem) {
    u64 id = &elem - parent.mdbl_elems;
    return u64(id);
}

// --- command.atf_cmdline.amnum.EmptyQ
// Return true if index is empty
inline bool command::amnum_EmptyQ(command::atf_cmdline& parent) {
    return parent.amnum_n == 0;
}

// --- command.atf_cmdline.amnum.Find
// Look up row by row id. Return NULL if out of range
inline i32* command::amnum_Find(command::atf_cmdline& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.amnum_n;
    if (idx >= lim) return NULL;
    return parent.amnum_elems + idx;
}

// --- command.atf_cmdline.amnum.Getary
// Return array pointer by value
inline algo::aryptr<i32> command::amnum_Getary(const command::atf_cmdline& parent) {
    return algo::aryptr<i32>(parent.amnum_elems, parent.amnum_n);
}

// --- command.atf_cmdline.amnum.Last
// Return pointer to last element of array, or NULL if array is empty
inline i32* command::amnum_Last(command::atf_cmdline& parent) {
    return amnum_Find(parent, u64(parent.amnum_n-1));
}

// --- command.atf_cmdline.amnum.Max
// Return max. number of items in the array
inline i32 command::amnum_Max(command::atf_cmdline& parent) {
    (void)parent;
    return parent.amnum_max;
}

// --- command.atf_cmdline.amnum.N
// Return number of items in the array
inline i32 command::amnum_N(const command::atf_cmdline& parent) {
    return parent.amnum_n;
}

// --- command.atf_cmdline.amnum.RemoveAll
inline void command::amnum_RemoveAll(command::atf_cmdline& parent) {
    parent.amnum_n = 0;
}

// --- command.atf_cmdline.amnum.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::amnum_Reserve(command::atf_cmdline& parent, int n) {
    u32 new_n = parent.amnum_n + n;
    if (UNLIKELY(new_n > parent.amnum_max)) {
        amnum_AbsReserve(parent, new_n);
    }
}

// --- command.atf_cmdline.amnum.qFind
// 'quick' Access row by row id. No bounds checking.
inline i32& command::amnum_qFind(command::atf_cmdline& parent, u64 t) {
    return parent.amnum_elems[t];
}

// --- command.atf_cmdline.amnum.qLast
// Return reference to last element of array. No bounds checking
inline i32& command::amnum_qLast(command::atf_cmdline& parent) {
    return amnum_qFind(parent, u64(parent.amnum_n-1));
}

// --- command.atf_cmdline.amnum.rowid_Get
// Return row id of specified element
inline u64 command::amnum_rowid_Get(command::atf_cmdline& parent, i32 &elem) {
    u64 id = &elem - parent.amnum_elems;
    return u64(id);
}

// --- command.atf_cmdline.fconst.GetEnum
// Get value of field as enum type
inline command_atf_cmdline_fconst_Enum command::fconst_GetEnum(const command::atf_cmdline& parent) {
    return command_atf_cmdline_fconst_Enum(parent.fconst);
}

// --- command.atf_cmdline.fconst.SetEnum
// Set value of field from enum type.
inline void command::fconst_SetEnum(command::atf_cmdline& parent, command_atf_cmdline_fconst_Enum rhs) {
    parent.fconst = u8(rhs);
}

// --- command.atf_cmdline.mstr_curs.Next
// proceed to next item
inline void command::atf_cmdline_mstr_curs_Next(atf_cmdline_mstr_curs &curs) {
    curs.index++;
}

// --- command.atf_cmdline.mstr_curs.Reset
inline void command::atf_cmdline_mstr_curs_Reset(atf_cmdline_mstr_curs &curs, command::atf_cmdline &parent) {
    curs.elems = parent.mstr_elems;
    curs.n_elems = parent.mstr_n;
    curs.index = 0;
}

// --- command.atf_cmdline.mstr_curs.ValidQ
// cursor points to valid item
inline bool command::atf_cmdline_mstr_curs_ValidQ(atf_cmdline_mstr_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.atf_cmdline.mstr_curs.Access
// item access
inline algo::cstring& command::atf_cmdline_mstr_curs_Access(atf_cmdline_mstr_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.atf_cmdline.mnum_curs.Next
// proceed to next item
inline void command::atf_cmdline_mnum_curs_Next(atf_cmdline_mnum_curs &curs) {
    curs.index++;
}

// --- command.atf_cmdline.mnum_curs.Reset
inline void command::atf_cmdline_mnum_curs_Reset(atf_cmdline_mnum_curs &curs, command::atf_cmdline &parent) {
    curs.elems = parent.mnum_elems;
    curs.n_elems = parent.mnum_n;
    curs.index = 0;
}

// --- command.atf_cmdline.mnum_curs.ValidQ
// cursor points to valid item
inline bool command::atf_cmdline_mnum_curs_ValidQ(atf_cmdline_mnum_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.atf_cmdline.mnum_curs.Access
// item access
inline i32& command::atf_cmdline_mnum_curs_Access(atf_cmdline_mnum_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.atf_cmdline.mdbl_curs.Next
// proceed to next item
inline void command::atf_cmdline_mdbl_curs_Next(atf_cmdline_mdbl_curs &curs) {
    curs.index++;
}

// --- command.atf_cmdline.mdbl_curs.Reset
inline void command::atf_cmdline_mdbl_curs_Reset(atf_cmdline_mdbl_curs &curs, command::atf_cmdline &parent) {
    curs.elems = parent.mdbl_elems;
    curs.n_elems = parent.mdbl_n;
    curs.index = 0;
}

// --- command.atf_cmdline.mdbl_curs.ValidQ
// cursor points to valid item
inline bool command::atf_cmdline_mdbl_curs_ValidQ(atf_cmdline_mdbl_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.atf_cmdline.mdbl_curs.Access
// item access
inline double& command::atf_cmdline_mdbl_curs_Access(atf_cmdline_mdbl_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.atf_cmdline.amnum_curs.Next
// proceed to next item
inline void command::atf_cmdline_amnum_curs_Next(atf_cmdline_amnum_curs &curs) {
    curs.index++;
}

// --- command.atf_cmdline.amnum_curs.Reset
inline void command::atf_cmdline_amnum_curs_Reset(atf_cmdline_amnum_curs &curs, command::atf_cmdline &parent) {
    curs.elems = parent.amnum_elems;
    curs.n_elems = parent.amnum_n;
    curs.index = 0;
}

// --- command.atf_cmdline.amnum_curs.ValidQ
// cursor points to valid item
inline bool command::atf_cmdline_amnum_curs_ValidQ(atf_cmdline_amnum_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.atf_cmdline.amnum_curs.Access
// item access
inline i32& command::atf_cmdline_amnum_curs_Access(atf_cmdline_amnum_curs &curs) {
    return curs.elems[curs.index];
}
inline command::atf_cmdline_proc::atf_cmdline_proc() {
    command::atf_cmdline_proc_Init(*this);
}

inline command::atf_cmdline_proc::~atf_cmdline_proc() {
    command::atf_cmdline_proc_Uninit(*this);
}


// --- command.atf_cmdline_proc..Init
// Set all fields to initial values.
inline void command::atf_cmdline_proc_Init(command::atf_cmdline_proc& parent) {
    parent.path = algo::strptr("bin/atf_cmdline");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_comp::atf_comp() {
    command::atf_comp_Init(*this);
}

inline command::atf_comp_proc::atf_comp_proc() {
    command::atf_comp_proc_Init(*this);
}

inline command::atf_comp_proc::~atf_comp_proc() {
    command::atf_comp_proc_Uninit(*this);
}


// --- command.atf_comp_proc..Init
// Set all fields to initial values.
inline void command::atf_comp_proc_Init(command::atf_comp_proc& parent) {
    parent.path = algo::strptr("bin/atf_comp");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_cov::atf_cov() {
    command::atf_cov_Init(*this);
}

inline command::atf_cov_proc::atf_cov_proc() {
    command::atf_cov_proc_Init(*this);
}

inline command::atf_cov_proc::~atf_cov_proc() {
    command::atf_cov_proc_Uninit(*this);
}


// --- command.atf_cov_proc..Init
// Set all fields to initial values.
inline void command::atf_cov_proc_Init(command::atf_cov_proc& parent) {
    parent.path = algo::strptr("bin/atf_cov");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_fuzz::atf_fuzz() {
    command::atf_fuzz_Init(*this);
}

inline command::atf_fuzz_proc::atf_fuzz_proc() {
    command::atf_fuzz_proc_Init(*this);
}

inline command::atf_fuzz_proc::~atf_fuzz_proc() {
    command::atf_fuzz_proc_Uninit(*this);
}


// --- command.atf_fuzz_proc..Init
// Set all fields to initial values.
inline void command::atf_fuzz_proc_Init(command::atf_fuzz_proc& parent) {
    parent.path = algo::strptr("bin/atf_fuzz");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_gcli::atf_gcli() {
    command::atf_gcli_Init(*this);
}

inline command::atf_gcli_proc::atf_gcli_proc() {
    command::atf_gcli_proc_Init(*this);
}

inline command::atf_gcli_proc::~atf_gcli_proc() {
    command::atf_gcli_proc_Uninit(*this);
}


// --- command.atf_gcli_proc..Init
// Set all fields to initial values.
inline void command::atf_gcli_proc_Init(command::atf_gcli_proc& parent) {
    parent.path = algo::strptr("bin/atf_gcli");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_nrun::atf_nrun() {
    command::atf_nrun_Init(*this);
}


// --- command.atf_nrun..Init
// Set all fields to initial values.
inline void command::atf_nrun_Init(command::atf_nrun& parent) {
    parent.in = algo::strptr("data");
    parent.maxjobs = i32(2);
    parent.ncmd = i32(6);
}
inline command::atf_nrun_proc::atf_nrun_proc() {
    command::atf_nrun_proc_Init(*this);
}

inline command::atf_nrun_proc::~atf_nrun_proc() {
    command::atf_nrun_proc_Uninit(*this);
}


// --- command.atf_nrun_proc..Init
// Set all fields to initial values.
inline void command::atf_nrun_proc_Init(command::atf_nrun_proc& parent) {
    parent.path = algo::strptr("bin/atf_nrun");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::atf_unit::atf_unit() {
    command::atf_unit_Init(*this);
}

inline command::atf_unit_proc::atf_unit_proc() {
    command::atf_unit_proc_Init(*this);
}

inline command::atf_unit_proc::~atf_unit_proc() {
    command::atf_unit_proc_Uninit(*this);
}


// --- command.atf_unit_proc..Init
// Set all fields to initial values.
inline void command::atf_unit_proc_Init(command::atf_unit_proc& parent) {
    parent.path = algo::strptr("bin/atf_unit");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::bash::bash() {
    command::bash_Init(*this);
}


// --- command.bash..Init
// Set all fields to initial values.
inline void command::bash_Init(command::bash& parent) {
    parent.c = algo::strptr("");
}
inline command::bash2html::bash2html() {
    command::bash2html_Init(*this);
}


// --- command.bash2html..Init
// Set all fields to initial values.
inline void command::bash2html_Init(command::bash2html& parent) {
    parent.in = algo::strptr("data");
    parent.test = bool(false);
}
inline command::bash2html_proc::bash2html_proc() {
    command::bash2html_proc_Init(*this);
}

inline command::bash2html_proc::~bash2html_proc() {
    command::bash2html_proc_Uninit(*this);
}


// --- command.bash2html_proc..Init
// Set all fields to initial values.
inline void command::bash2html_proc_Init(command::bash2html_proc& parent) {
    parent.path = algo::strptr("bin/bash2html");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::bash_proc::bash_proc() {
    command::bash_proc_Init(*this);
}

inline command::bash_proc::~bash_proc() {
    command::bash_proc_Uninit(*this);
}


// --- command.bash_proc..Init
// Set all fields to initial values.
inline void command::bash_proc_Init(command::bash_proc& parent) {
    parent.path = algo::strptr("bash");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::gcache::gcache() {
    command::gcache_Init(*this);
}

inline command::gcache::~gcache() {
    command::gcache_Uninit(*this);
}


// --- command.gcache.cmd.EmptyQ
// Return true if index is empty
inline bool command::cmd_EmptyQ(command::gcache& parent) {
    return parent.cmd_n == 0;
}

// --- command.gcache.cmd.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::cmd_Find(command::gcache& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.cmd_n;
    if (idx >= lim) return NULL;
    return parent.cmd_elems + idx;
}

// --- command.gcache.cmd.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::cmd_Getary(const command::gcache& parent) {
    return algo::aryptr<algo::cstring>(parent.cmd_elems, parent.cmd_n);
}

// --- command.gcache.cmd.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::cmd_Last(command::gcache& parent) {
    return cmd_Find(parent, u64(parent.cmd_n-1));
}

// --- command.gcache.cmd.Max
// Return max. number of items in the array
inline i32 command::cmd_Max(command::gcache& parent) {
    (void)parent;
    return parent.cmd_max;
}

// --- command.gcache.cmd.N
// Return number of items in the array
inline i32 command::cmd_N(const command::gcache& parent) {
    return parent.cmd_n;
}

// --- command.gcache.cmd.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::cmd_Reserve(command::gcache& parent, int n) {
    u32 new_n = parent.cmd_n + n;
    if (UNLIKELY(new_n > parent.cmd_max)) {
        cmd_AbsReserve(parent, new_n);
    }
}

// --- command.gcache.cmd.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::cmd_qFind(command::gcache& parent, u64 t) {
    return parent.cmd_elems[t];
}

// --- command.gcache.cmd.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::cmd_qLast(command::gcache& parent) {
    return cmd_qFind(parent, u64(parent.cmd_n-1));
}

// --- command.gcache.cmd.rowid_Get
// Return row id of specified element
inline u64 command::cmd_rowid_Get(command::gcache& parent, algo::cstring &elem) {
    u64 id = &elem - parent.cmd_elems;
    return u64(id);
}

// --- command.gcache.cmd_curs.Next
// proceed to next item
inline void command::gcache_cmd_curs_Next(gcache_cmd_curs &curs) {
    curs.index++;
}

// --- command.gcache.cmd_curs.Reset
inline void command::gcache_cmd_curs_Reset(gcache_cmd_curs &curs, command::gcache &parent) {
    curs.elems = parent.cmd_elems;
    curs.n_elems = parent.cmd_n;
    curs.index = 0;
}

// --- command.gcache.cmd_curs.ValidQ
// cursor points to valid item
inline bool command::gcache_cmd_curs_ValidQ(gcache_cmd_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.gcache.cmd_curs.Access
// item access
inline algo::cstring& command::gcache_cmd_curs_Access(gcache_cmd_curs &curs) {
    return curs.elems[curs.index];
}
inline command::gcache_proc::gcache_proc() {
    command::gcache_proc_Init(*this);
}

inline command::gcache_proc::~gcache_proc() {
    command::gcache_proc_Uninit(*this);
}


// --- command.gcache_proc..Init
// Set all fields to initial values.
inline void command::gcache_proc_Init(command::gcache_proc& parent) {
    parent.path = algo::strptr("bin/gcache");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::gcli::gcli() {
    command::gcli_Init(*this);
}

inline command::gcli::~gcli() {
    command::gcli_Uninit(*this);
}


// --- command.gcli.fields.EmptyQ
// Return true if index is empty
inline bool command::fields_EmptyQ(command::gcli& parent) {
    return parent.fields_n == 0;
}

// --- command.gcli.fields.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::fields_Find(command::gcli& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.fields_n;
    if (idx >= lim) return NULL;
    return parent.fields_elems + idx;
}

// --- command.gcli.fields.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::fields_Getary(const command::gcli& parent) {
    return algo::aryptr<algo::cstring>(parent.fields_elems, parent.fields_n);
}

// --- command.gcli.fields.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::fields_Last(command::gcli& parent) {
    return fields_Find(parent, u64(parent.fields_n-1));
}

// --- command.gcli.fields.Max
// Return max. number of items in the array
inline i32 command::fields_Max(command::gcli& parent) {
    (void)parent;
    return parent.fields_max;
}

// --- command.gcli.fields.N
// Return number of items in the array
inline i32 command::fields_N(const command::gcli& parent) {
    return parent.fields_n;
}

// --- command.gcli.fields.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::fields_Reserve(command::gcli& parent, int n) {
    u32 new_n = parent.fields_n + n;
    if (UNLIKELY(new_n > parent.fields_max)) {
        fields_AbsReserve(parent, new_n);
    }
}

// --- command.gcli.fields.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::fields_qFind(command::gcli& parent, u64 t) {
    return parent.fields_elems[t];
}

// --- command.gcli.fields.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::fields_qLast(command::gcli& parent) {
    return fields_qFind(parent, u64(parent.fields_n-1));
}

// --- command.gcli.fields.rowid_Get
// Return row id of specified element
inline u64 command::fields_rowid_Get(command::gcli& parent, algo::cstring &elem) {
    u64 id = &elem - parent.fields_elems;
    return u64(id);
}

// --- command.gcli.fields_curs.Next
// proceed to next item
inline void command::gcli_fields_curs_Next(gcli_fields_curs &curs) {
    curs.index++;
}

// --- command.gcli.fields_curs.Reset
inline void command::gcli_fields_curs_Reset(gcli_fields_curs &curs, command::gcli &parent) {
    curs.elems = parent.fields_elems;
    curs.n_elems = parent.fields_n;
    curs.index = 0;
}

// --- command.gcli.fields_curs.ValidQ
// cursor points to valid item
inline bool command::gcli_fields_curs_ValidQ(gcli_fields_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.gcli.fields_curs.Access
// item access
inline algo::cstring& command::gcli_fields_curs_Access(gcli_fields_curs &curs) {
    return curs.elems[curs.index];
}
inline command::gcli_proc::gcli_proc() {
    command::gcli_proc_Init(*this);
}

inline command::gcli_proc::~gcli_proc() {
    command::gcli_proc_Uninit(*this);
}


// --- command.gcli_proc..Init
// Set all fields to initial values.
inline void command::gcli_proc_Init(command::gcli_proc& parent) {
    parent.path = algo::strptr("bin/gcli");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::mdbg::mdbg() {
    command::mdbg_Init(*this);
}

inline command::mdbg::~mdbg() {
    command::mdbg_Uninit(*this);
}


// --- command.mdbg.args.EmptyQ
// Return true if index is empty
inline bool command::args_EmptyQ(command::mdbg& parent) {
    return parent.args_n == 0;
}

// --- command.mdbg.args.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::args_Find(command::mdbg& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.args_n;
    if (idx >= lim) return NULL;
    return parent.args_elems + idx;
}

// --- command.mdbg.args.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::args_Getary(const command::mdbg& parent) {
    return algo::aryptr<algo::cstring>(parent.args_elems, parent.args_n);
}

// --- command.mdbg.args.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::args_Last(command::mdbg& parent) {
    return args_Find(parent, u64(parent.args_n-1));
}

// --- command.mdbg.args.Max
// Return max. number of items in the array
inline i32 command::args_Max(command::mdbg& parent) {
    (void)parent;
    return parent.args_max;
}

// --- command.mdbg.args.N
// Return number of items in the array
inline i32 command::args_N(const command::mdbg& parent) {
    return parent.args_n;
}

// --- command.mdbg.args.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::args_Reserve(command::mdbg& parent, int n) {
    u32 new_n = parent.args_n + n;
    if (UNLIKELY(new_n > parent.args_max)) {
        args_AbsReserve(parent, new_n);
    }
}

// --- command.mdbg.args.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::args_qFind(command::mdbg& parent, u64 t) {
    return parent.args_elems[t];
}

// --- command.mdbg.args.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::args_qLast(command::mdbg& parent) {
    return args_qFind(parent, u64(parent.args_n-1));
}

// --- command.mdbg.args.rowid_Get
// Return row id of specified element
inline u64 command::args_rowid_Get(command::mdbg& parent, algo::cstring &elem) {
    u64 id = &elem - parent.args_elems;
    return u64(id);
}

// --- command.mdbg.b.EmptyQ
// Return true if index is empty
inline bool command::b_EmptyQ(command::mdbg& parent) {
    return parent.b_n == 0;
}

// --- command.mdbg.b.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::b_Find(command::mdbg& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.b_n;
    if (idx >= lim) return NULL;
    return parent.b_elems + idx;
}

// --- command.mdbg.b.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::b_Getary(const command::mdbg& parent) {
    return algo::aryptr<algo::cstring>(parent.b_elems, parent.b_n);
}

// --- command.mdbg.b.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::b_Last(command::mdbg& parent) {
    return b_Find(parent, u64(parent.b_n-1));
}

// --- command.mdbg.b.Max
// Return max. number of items in the array
inline i32 command::b_Max(command::mdbg& parent) {
    (void)parent;
    return parent.b_max;
}

// --- command.mdbg.b.N
// Return number of items in the array
inline i32 command::b_N(const command::mdbg& parent) {
    return parent.b_n;
}

// --- command.mdbg.b.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::b_Reserve(command::mdbg& parent, int n) {
    u32 new_n = parent.b_n + n;
    if (UNLIKELY(new_n > parent.b_max)) {
        b_AbsReserve(parent, new_n);
    }
}

// --- command.mdbg.b.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::b_qFind(command::mdbg& parent, u64 t) {
    return parent.b_elems[t];
}

// --- command.mdbg.b.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::b_qLast(command::mdbg& parent) {
    return b_qFind(parent, u64(parent.b_n-1));
}

// --- command.mdbg.b.rowid_Get
// Return row id of specified element
inline u64 command::b_rowid_Get(command::mdbg& parent, algo::cstring &elem) {
    u64 id = &elem - parent.b_elems;
    return u64(id);
}

// --- command.mdbg.args_curs.Next
// proceed to next item
inline void command::mdbg_args_curs_Next(mdbg_args_curs &curs) {
    curs.index++;
}

// --- command.mdbg.args_curs.Reset
inline void command::mdbg_args_curs_Reset(mdbg_args_curs &curs, command::mdbg &parent) {
    curs.elems = parent.args_elems;
    curs.n_elems = parent.args_n;
    curs.index = 0;
}

// --- command.mdbg.args_curs.ValidQ
// cursor points to valid item
inline bool command::mdbg_args_curs_ValidQ(mdbg_args_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.mdbg.args_curs.Access
// item access
inline algo::cstring& command::mdbg_args_curs_Access(mdbg_args_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.mdbg.b_curs.Next
// proceed to next item
inline void command::mdbg_b_curs_Next(mdbg_b_curs &curs) {
    curs.index++;
}

// --- command.mdbg.b_curs.Reset
inline void command::mdbg_b_curs_Reset(mdbg_b_curs &curs, command::mdbg &parent) {
    curs.elems = parent.b_elems;
    curs.n_elems = parent.b_n;
    curs.index = 0;
}

// --- command.mdbg.b_curs.ValidQ
// cursor points to valid item
inline bool command::mdbg_b_curs_ValidQ(mdbg_b_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.mdbg.b_curs.Access
// item access
inline algo::cstring& command::mdbg_b_curs_Access(mdbg_b_curs &curs) {
    return curs.elems[curs.index];
}
inline command::mdbg_proc::mdbg_proc() {
    command::mdbg_proc_Init(*this);
}

inline command::mdbg_proc::~mdbg_proc() {
    command::mdbg_proc_Uninit(*this);
}


// --- command.mdbg_proc..Init
// Set all fields to initial values.
inline void command::mdbg_proc_Init(command::mdbg_proc& parent) {
    parent.path = algo::strptr("bin/mdbg");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::mysql2ssim::mysql2ssim() {
    command::mysql2ssim_Init(*this);
}


// --- command.mysql2ssim..Init
// Set all fields to initial values.
inline void command::mysql2ssim_Init(command::mysql2ssim& parent) {
    parent.writessimfile = bool(false);
    parent.tables = algo::strptr("");
    parent.schema = bool(false);
    parent.in = algo::strptr("data");
    parent.pretty = bool(false);
    parent.nologo = bool(false);
    parent.baddbok = bool(false);
}
inline command::mysql2ssim_proc::mysql2ssim_proc() {
    command::mysql2ssim_proc_Init(*this);
}

inline command::mysql2ssim_proc::~mysql2ssim_proc() {
    command::mysql2ssim_proc_Uninit(*this);
}


// --- command.mysql2ssim_proc..Init
// Set all fields to initial values.
inline void command::mysql2ssim_proc_Init(command::mysql2ssim_proc& parent) {
    parent.path = algo::strptr("bin/mysql2ssim");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::orgfile::orgfile() {
    command::orgfile_Init(*this);
}

inline command::orgfile_proc::orgfile_proc() {
    command::orgfile_proc_Init(*this);
}

inline command::orgfile_proc::~orgfile_proc() {
    command::orgfile_proc_Uninit(*this);
}


// --- command.orgfile_proc..Init
// Set all fields to initial values.
inline void command::orgfile_proc_Init(command::orgfile_proc& parent) {
    parent.path = algo::strptr("bin/orgfile");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::samp_regx::samp_regx() {
    command::samp_regx_Init(*this);
}


// --- command.samp_regx.style.GetEnum
// Get value of field as enum type
inline command_samp_regx_style_Enum command::style_GetEnum(const command::samp_regx& parent) {
    return command_samp_regx_style_Enum(parent.style);
}

// --- command.samp_regx.style.SetEnum
// Set value of field from enum type.
inline void command::style_SetEnum(command::samp_regx& parent, command_samp_regx_style_Enum rhs) {
    parent.style = u8(rhs);
}

// --- command.samp_regx..Init
// Set all fields to initial values.
inline void command::samp_regx_Init(command::samp_regx& parent) {
    parent.in = algo::strptr("data");
    parent.style = u8(0);
    parent.match = bool(false);
    parent.string = algo::strptr("");
    parent.show = bool(false);
}
inline command::samp_regx_proc::samp_regx_proc() {
    command::samp_regx_proc_Init(*this);
}

inline command::samp_regx_proc::~samp_regx_proc() {
    command::samp_regx_proc_Uninit(*this);
}


// --- command.samp_regx_proc..Init
// Set all fields to initial values.
inline void command::samp_regx_proc_Init(command::samp_regx_proc& parent) {
    parent.path = algo::strptr("bin/samp_regx");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::sandbox::sandbox() {
    command::sandbox_Init(*this);
}

inline command::sandbox::~sandbox() {
    command::sandbox_Uninit(*this);
}


// --- command.sandbox.cmd.EmptyQ
// Return true if index is empty
inline bool command::cmd_EmptyQ(command::sandbox& parent) {
    return parent.cmd_n == 0;
}

// --- command.sandbox.cmd.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::cmd_Find(command::sandbox& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.cmd_n;
    if (idx >= lim) return NULL;
    return parent.cmd_elems + idx;
}

// --- command.sandbox.cmd.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::cmd_Getary(const command::sandbox& parent) {
    return algo::aryptr<algo::cstring>(parent.cmd_elems, parent.cmd_n);
}

// --- command.sandbox.cmd.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::cmd_Last(command::sandbox& parent) {
    return cmd_Find(parent, u64(parent.cmd_n-1));
}

// --- command.sandbox.cmd.Max
// Return max. number of items in the array
inline i32 command::cmd_Max(command::sandbox& parent) {
    (void)parent;
    return parent.cmd_max;
}

// --- command.sandbox.cmd.N
// Return number of items in the array
inline i32 command::cmd_N(const command::sandbox& parent) {
    return parent.cmd_n;
}

// --- command.sandbox.cmd.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::cmd_Reserve(command::sandbox& parent, int n) {
    u32 new_n = parent.cmd_n + n;
    if (UNLIKELY(new_n > parent.cmd_max)) {
        cmd_AbsReserve(parent, new_n);
    }
}

// --- command.sandbox.cmd.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::cmd_qFind(command::sandbox& parent, u64 t) {
    return parent.cmd_elems[t];
}

// --- command.sandbox.cmd.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::cmd_qLast(command::sandbox& parent) {
    return cmd_qFind(parent, u64(parent.cmd_n-1));
}

// --- command.sandbox.cmd.rowid_Get
// Return row id of specified element
inline u64 command::cmd_rowid_Get(command::sandbox& parent, algo::cstring &elem) {
    u64 id = &elem - parent.cmd_elems;
    return u64(id);
}

// --- command.sandbox.files.EmptyQ
// Return true if index is empty
inline bool command::files_EmptyQ(command::sandbox& parent) {
    return parent.files_n == 0;
}

// --- command.sandbox.files.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::files_Find(command::sandbox& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.files_n;
    if (idx >= lim) return NULL;
    return parent.files_elems + idx;
}

// --- command.sandbox.files.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::files_Getary(const command::sandbox& parent) {
    return algo::aryptr<algo::cstring>(parent.files_elems, parent.files_n);
}

// --- command.sandbox.files.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::files_Last(command::sandbox& parent) {
    return files_Find(parent, u64(parent.files_n-1));
}

// --- command.sandbox.files.Max
// Return max. number of items in the array
inline i32 command::files_Max(command::sandbox& parent) {
    (void)parent;
    return parent.files_max;
}

// --- command.sandbox.files.N
// Return number of items in the array
inline i32 command::files_N(const command::sandbox& parent) {
    return parent.files_n;
}

// --- command.sandbox.files.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::files_Reserve(command::sandbox& parent, int n) {
    u32 new_n = parent.files_n + n;
    if (UNLIKELY(new_n > parent.files_max)) {
        files_AbsReserve(parent, new_n);
    }
}

// --- command.sandbox.files.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::files_qFind(command::sandbox& parent, u64 t) {
    return parent.files_elems[t];
}

// --- command.sandbox.files.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::files_qLast(command::sandbox& parent) {
    return files_qFind(parent, u64(parent.files_n-1));
}

// --- command.sandbox.files.rowid_Get
// Return row id of specified element
inline u64 command::files_rowid_Get(command::sandbox& parent, algo::cstring &elem) {
    u64 id = &elem - parent.files_elems;
    return u64(id);
}

// --- command.sandbox.cmd_curs.Next
// proceed to next item
inline void command::sandbox_cmd_curs_Next(sandbox_cmd_curs &curs) {
    curs.index++;
}

// --- command.sandbox.cmd_curs.Reset
inline void command::sandbox_cmd_curs_Reset(sandbox_cmd_curs &curs, command::sandbox &parent) {
    curs.elems = parent.cmd_elems;
    curs.n_elems = parent.cmd_n;
    curs.index = 0;
}

// --- command.sandbox.cmd_curs.ValidQ
// cursor points to valid item
inline bool command::sandbox_cmd_curs_ValidQ(sandbox_cmd_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.sandbox.cmd_curs.Access
// item access
inline algo::cstring& command::sandbox_cmd_curs_Access(sandbox_cmd_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.sandbox.files_curs.Next
// proceed to next item
inline void command::sandbox_files_curs_Next(sandbox_files_curs &curs) {
    curs.index++;
}

// --- command.sandbox.files_curs.Reset
inline void command::sandbox_files_curs_Reset(sandbox_files_curs &curs, command::sandbox &parent) {
    curs.elems = parent.files_elems;
    curs.n_elems = parent.files_n;
    curs.index = 0;
}

// --- command.sandbox.files_curs.ValidQ
// cursor points to valid item
inline bool command::sandbox_files_curs_ValidQ(sandbox_files_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.sandbox.files_curs.Access
// item access
inline algo::cstring& command::sandbox_files_curs_Access(sandbox_files_curs &curs) {
    return curs.elems[curs.index];
}
inline command::sandbox_proc::sandbox_proc() {
    command::sandbox_proc_Init(*this);
}

inline command::sandbox_proc::~sandbox_proc() {
    command::sandbox_proc_Uninit(*this);
}


// --- command.sandbox_proc..Init
// Set all fields to initial values.
inline void command::sandbox_proc_Init(command::sandbox_proc& parent) {
    parent.path = algo::strptr("bin/sandbox");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::src_func::src_func() {
    command::src_func_Init(*this);
}

inline command::src_func_proc::src_func_proc() {
    command::src_func_proc_Init(*this);
}

inline command::src_func_proc::~src_func_proc() {
    command::src_func_proc_Uninit(*this);
}


// --- command.src_func_proc..Init
// Set all fields to initial values.
inline void command::src_func_proc_Init(command::src_func_proc& parent) {
    parent.path = algo::strptr("bin/src_func");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::src_hdr::src_hdr() {
    command::src_hdr_Init(*this);
}

inline command::src_hdr_proc::src_hdr_proc() {
    command::src_hdr_proc_Init(*this);
}

inline command::src_hdr_proc::~src_hdr_proc() {
    command::src_hdr_proc_Uninit(*this);
}


// --- command.src_hdr_proc..Init
// Set all fields to initial values.
inline void command::src_hdr_proc_Init(command::src_hdr_proc& parent) {
    parent.path = algo::strptr("bin/src_hdr");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::src_lim::src_lim() {
    command::src_lim_Init(*this);
}

inline command::src_lim_proc::src_lim_proc() {
    command::src_lim_proc_Init(*this);
}

inline command::src_lim_proc::~src_lim_proc() {
    command::src_lim_proc_Uninit(*this);
}


// --- command.src_lim_proc..Init
// Set all fields to initial values.
inline void command::src_lim_proc_Init(command::src_lim_proc& parent) {
    parent.path = algo::strptr("bin/src_lim");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::ssim2csv::ssim2csv() {
    command::ssim2csv_Init(*this);
}


// --- command.ssim2csv..Init
// Set all fields to initial values.
inline void command::ssim2csv_Init(command::ssim2csv& parent) {
    parent.expand = algo::strptr("");
    parent.ignoreQuote = bool(false);
}
inline command::ssim2csv_proc::ssim2csv_proc() {
    command::ssim2csv_proc_Init(*this);
}

inline command::ssim2csv_proc::~ssim2csv_proc() {
    command::ssim2csv_proc_Uninit(*this);
}


// --- command.ssim2csv_proc..Init
// Set all fields to initial values.
inline void command::ssim2csv_proc_Init(command::ssim2csv_proc& parent) {
    parent.path = algo::strptr("bin/ssim2csv");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::ssim2mysql::ssim2mysql() {
    command::ssim2mysql_Init(*this);
}

inline command::ssim2mysql_proc::ssim2mysql_proc() {
    command::ssim2mysql_proc_Init(*this);
}

inline command::ssim2mysql_proc::~ssim2mysql_proc() {
    command::ssim2mysql_proc_Uninit(*this);
}


// --- command.ssim2mysql_proc..Init
// Set all fields to initial values.
inline void command::ssim2mysql_proc_Init(command::ssim2mysql_proc& parent) {
    parent.path = algo::strptr("bin/ssim2mysql");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::ssimfilt::ssimfilt() {
    command::ssimfilt_Init(*this);
}

inline command::ssimfilt::~ssimfilt() {
    command::ssimfilt_Uninit(*this);
}


// --- command.ssimfilt.match.EmptyQ
// Return true if index is empty
inline bool command::match_EmptyQ(command::ssimfilt& parent) {
    return parent.match_n == 0;
}

// --- command.ssimfilt.match.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::match_Find(command::ssimfilt& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.match_n;
    if (idx >= lim) return NULL;
    return parent.match_elems + idx;
}

// --- command.ssimfilt.match.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::match_Getary(const command::ssimfilt& parent) {
    return algo::aryptr<algo::cstring>(parent.match_elems, parent.match_n);
}

// --- command.ssimfilt.match.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::match_Last(command::ssimfilt& parent) {
    return match_Find(parent, u64(parent.match_n-1));
}

// --- command.ssimfilt.match.Max
// Return max. number of items in the array
inline i32 command::match_Max(command::ssimfilt& parent) {
    (void)parent;
    return parent.match_max;
}

// --- command.ssimfilt.match.N
// Return number of items in the array
inline i32 command::match_N(const command::ssimfilt& parent) {
    return parent.match_n;
}

// --- command.ssimfilt.match.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::match_Reserve(command::ssimfilt& parent, int n) {
    u32 new_n = parent.match_n + n;
    if (UNLIKELY(new_n > parent.match_max)) {
        match_AbsReserve(parent, new_n);
    }
}

// --- command.ssimfilt.match.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::match_qFind(command::ssimfilt& parent, u64 t) {
    return parent.match_elems[t];
}

// --- command.ssimfilt.match.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::match_qLast(command::ssimfilt& parent) {
    return match_qFind(parent, u64(parent.match_n-1));
}

// --- command.ssimfilt.match.rowid_Get
// Return row id of specified element
inline u64 command::match_rowid_Get(command::ssimfilt& parent, algo::cstring &elem) {
    u64 id = &elem - parent.match_elems;
    return u64(id);
}

// --- command.ssimfilt.field.EmptyQ
// Return true if index is empty
inline bool command::field_EmptyQ(command::ssimfilt& parent) {
    return parent.field_n == 0;
}

// --- command.ssimfilt.field.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* command::field_Find(command::ssimfilt& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.field_n;
    if (idx >= lim) return NULL;
    return parent.field_elems + idx;
}

// --- command.ssimfilt.field.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> command::field_Getary(const command::ssimfilt& parent) {
    return algo::aryptr<algo::cstring>(parent.field_elems, parent.field_n);
}

// --- command.ssimfilt.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* command::field_Last(command::ssimfilt& parent) {
    return field_Find(parent, u64(parent.field_n-1));
}

// --- command.ssimfilt.field.Max
// Return max. number of items in the array
inline i32 command::field_Max(command::ssimfilt& parent) {
    (void)parent;
    return parent.field_max;
}

// --- command.ssimfilt.field.N
// Return number of items in the array
inline i32 command::field_N(const command::ssimfilt& parent) {
    return parent.field_n;
}

// --- command.ssimfilt.field.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void command::field_Reserve(command::ssimfilt& parent, int n) {
    u32 new_n = parent.field_n + n;
    if (UNLIKELY(new_n > parent.field_max)) {
        field_AbsReserve(parent, new_n);
    }
}

// --- command.ssimfilt.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& command::field_qFind(command::ssimfilt& parent, u64 t) {
    return parent.field_elems[t];
}

// --- command.ssimfilt.field.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& command::field_qLast(command::ssimfilt& parent) {
    return field_qFind(parent, u64(parent.field_n-1));
}

// --- command.ssimfilt.field.rowid_Get
// Return row id of specified element
inline u64 command::field_rowid_Get(command::ssimfilt& parent, algo::cstring &elem) {
    u64 id = &elem - parent.field_elems;
    return u64(id);
}

// --- command.ssimfilt.format.GetEnum
// Get value of field as enum type
inline command_ssimfilt_format_Enum command::format_GetEnum(const command::ssimfilt& parent) {
    return command_ssimfilt_format_Enum(parent.format);
}

// --- command.ssimfilt.format.SetEnum
// Set value of field from enum type.
inline void command::format_SetEnum(command::ssimfilt& parent, command_ssimfilt_format_Enum rhs) {
    parent.format = u8(rhs);
}

// --- command.ssimfilt.match_curs.Next
// proceed to next item
inline void command::ssimfilt_match_curs_Next(ssimfilt_match_curs &curs) {
    curs.index++;
}

// --- command.ssimfilt.match_curs.Reset
inline void command::ssimfilt_match_curs_Reset(ssimfilt_match_curs &curs, command::ssimfilt &parent) {
    curs.elems = parent.match_elems;
    curs.n_elems = parent.match_n;
    curs.index = 0;
}

// --- command.ssimfilt.match_curs.ValidQ
// cursor points to valid item
inline bool command::ssimfilt_match_curs_ValidQ(ssimfilt_match_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.ssimfilt.match_curs.Access
// item access
inline algo::cstring& command::ssimfilt_match_curs_Access(ssimfilt_match_curs &curs) {
    return curs.elems[curs.index];
}

// --- command.ssimfilt.field_curs.Next
// proceed to next item
inline void command::ssimfilt_field_curs_Next(ssimfilt_field_curs &curs) {
    curs.index++;
}

// --- command.ssimfilt.field_curs.Reset
inline void command::ssimfilt_field_curs_Reset(ssimfilt_field_curs &curs, command::ssimfilt &parent) {
    curs.elems = parent.field_elems;
    curs.n_elems = parent.field_n;
    curs.index = 0;
}

// --- command.ssimfilt.field_curs.ValidQ
// cursor points to valid item
inline bool command::ssimfilt_field_curs_ValidQ(ssimfilt_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- command.ssimfilt.field_curs.Access
// item access
inline algo::cstring& command::ssimfilt_field_curs_Access(ssimfilt_field_curs &curs) {
    return curs.elems[curs.index];
}
inline command::ssimfilt_proc::ssimfilt_proc() {
    command::ssimfilt_proc_Init(*this);
}

inline command::ssimfilt_proc::~ssimfilt_proc() {
    command::ssimfilt_proc_Uninit(*this);
}


// --- command.ssimfilt_proc..Init
// Set all fields to initial values.
inline void command::ssimfilt_proc_Init(command::ssimfilt_proc& parent) {
    parent.path = algo::strptr("bin/ssimfilt");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::strconv::strconv() {
    command::strconv_Init(*this);
}


// --- command.strconv..Init
// Set all fields to initial values.
inline void command::strconv_Init(command::strconv& parent) {
    parent.tocamelcase = bool(false);
    parent.tolowerunder = bool(false);
    parent.in = algo::strptr("data");
    parent.pathcomp = algo::strptr("");
}
inline command::strconv_proc::strconv_proc() {
    command::strconv_proc_Init(*this);
}

inline command::strconv_proc::~strconv_proc() {
    command::strconv_proc_Uninit(*this);
}


// --- command.strconv_proc..Init
// Set all fields to initial values.
inline void command::strconv_proc_Init(command::strconv_proc& parent) {
    parent.path = algo::strptr("bin/strconv");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}
inline command::sv2ssim::sv2ssim() {
    command::sv2ssim_Init(*this);
}

inline command::sv2ssim_proc::sv2ssim_proc() {
    command::sv2ssim_proc_Init(*this);
}

inline command::sv2ssim_proc::~sv2ssim_proc() {
    command::sv2ssim_proc_Uninit(*this);
}


// --- command.sv2ssim_proc..Init
// Set all fields to initial values.
inline void command::sv2ssim_proc_Init(command::sv2ssim_proc& parent) {
    parent.path = algo::strptr("bin/sv2ssim");
    parent.pid = pid_t(0);
    parent.timeout = i32(0);
    parent.status = i32(0);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const command::FieldId &row) {// cfmt:command.FieldId.String
    command::FieldId_Print(const_cast<command::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const command::acr_compl &row) {// cfmt:command.acr_compl.String
    command::acr_compl_Print(const_cast<command::acr_compl&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const command::gcache &row) {// cfmt:command.gcache.String
    command::gcache_Print(const_cast<command::gcache&>(row), str);
    return str;
}
