//
// include/gen/atf_unit_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/report_gen.h"
#include "include/gen/atf_gen.h"
#include "include/gen/atfdb_gen.h"
#include "include/gen/algo_lib_gen.h"
//#pragma endinclude

// --- atf_unit_FieldIdEnum

enum atf_unit_FieldIdEnum {            // atf_unit.FieldId.value
     atf_unit_FieldId_val        = 0
    ,atf_unit_FieldId_str_fld1   = 1
    ,atf_unit_FieldId_dbl_fld1   = 2
    ,atf_unit_FieldId_xyz        = 3
    ,atf_unit_FieldId_test       = 4
    ,atf_unit_FieldId_value      = 5
    ,atf_unit_FieldId_test2      = 6
    ,atf_unit_FieldId_abc        = 7
    ,atf_unit_FieldId_x          = 8
    ,atf_unit_FieldId_y          = 9
    ,atf_unit_FieldId_z          = 10
    ,atf_unit_FieldId_typea      = 11
    ,atf_unit_FieldId_j          = 12
};

enum { atf_unit_FieldIdEnum_N = 13 };

namespace atf_unit { struct FUnittest; }
namespace atfdb { struct Unittest; }
namespace atf_unit { struct Bitset; }
namespace atf_unit { struct Cstr; }
namespace atf_unit { struct Dbl; }
namespace atf_unit { struct TestArgtuple1; }
namespace atf_unit { struct trace; }
namespace atf_unit { struct FDb; }
namespace atf_unit { struct FNumber; }
namespace atf_unit { struct FPerfSort; }
namespace atf_unit { struct FTestrun; }
namespace atf_unit { struct FieldId; }
namespace atf_unit { struct ShStream; }
namespace atf_unit { struct ShStreamAry; }
namespace atf_unit { struct TypeA; }
namespace atf_unit { struct TypeB; }
namespace atf_unit { struct TestJson; }
namespace atf_unit { struct Bitset_fld1_curs; }
namespace atf_unit { struct _db_tr_number_curs; }
namespace atf_unit { struct _db_unittest_curs; }
namespace atf_unit { struct _db_ind_unittest_curs; }
namespace atf_unit { struct _db_ind_testrun_curs; }
namespace atf_unit { struct _db_testrun_curs; }
namespace atf_unit { struct FPerfSort_orig_curs; }
namespace atf_unit { struct FPerfSort_sorted_curs; }
namespace atf_unit { struct FPerfSort_index_curs; }
namespace atf_unit { struct ShStreamAry_shstream_curs; }
namespace atf_unit {
    typedef i32 TypeAPkey;
}//pkey typedefs
namespace atf_unit {
extern const char *atf_unit_help;
extern const char *atf_unit_syntax;
extern FDb _db;
typedef void (*unittest_step_hook)();

// --- atf_unit.Bitset
struct Bitset { // atf_unit.Bitset: Test bitset
    u16    fld1_elems[4];   //   0  fixed array
    u8     fld8;            //   0  Bitset field
    u64    fld64;           //   0  Bitset field
    u128   fld128;          //   0  Bitset field 128 bits
    Bitset();
};

// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  fld1_Nbits(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 fld1_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 fld1_GetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 fld1_BitsEmptyQ(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  fld1_Sum1s(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 fld1_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 fld1_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld1_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 fld1_SetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld1_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 fld1_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 fld1_ClearBitsAll(atf_unit::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 fld1_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 fld1_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  fld1_Sup(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Set all elements of fixed array to value RHS
void                 fld1_Fill(atf_unit::Bitset& parent, const u16 &rhs) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
u16*                 fld1_Find(atf_unit::Bitset& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Access fixed array fld1 as aryptr.
algo::aryptr<u16>    fld1_Getary(atf_unit::Bitset& parent) __attribute__((nothrow));
// Return max number of items in the array
i32                  fld1_Max(atf_unit::Bitset& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  fld1_N(const atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Set contents of fixed array to RHS; Input length is trimmed as necessary
void                 fld1_Setary(atf_unit::Bitset& parent, const algo::aryptr<u16> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
u16&                 fld1_qFind(atf_unit::Bitset& parent, u64 t) __attribute__((nothrow));

// Return constant 1
int                  fld8_N(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
u8&                  fld8_qFind(atf_unit::Bitset& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  fld8_Nbits(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 fld8_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 fld8_GetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 fld8_BitsEmptyQ(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  fld8_Sum1s(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 fld8_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 fld8_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld8_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 fld8_SetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld8_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 fld8_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 fld8_ClearBitsAll(atf_unit::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 fld8_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 fld8_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  fld8_Sup(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));

// Return constant 1
int                  fld64_N(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
u64&                 fld64_qFind(atf_unit::Bitset& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  fld64_Nbits(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 fld64_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 fld64_GetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 fld64_BitsEmptyQ(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  fld64_Sum1s(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 fld64_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 fld64_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld64_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 fld64_SetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld64_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 fld64_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 fld64_ClearBitsAll(atf_unit::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 fld64_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 fld64_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Return smallest number N such that indexes of all 1 bits are below N
i32                  fld64_Sup(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));

// Return constant 1
int                  fld128_N(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Access value
u128&                fld128_qFind(atf_unit::Bitset& parent, int) __attribute__((__warn_unused_result__, nothrow));
// Get max # of bits in the bitset
// Return max. number of bits supported by array
int                  fld128_Nbits(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
bool                 fld128_qGetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
bool                 fld128_GetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((__warn_unused_result__, nothrow));
// Check if all the bits in the bitset are equal to zero
bool                 fld128_BitsEmptyQ(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
u64                  fld128_Sum1s(atf_unit::Bitset& parent) __attribute__((__warn_unused_result__, nothrow));
// Clear bit # BIT_IDX in bit set. No bounds checking
void                 fld128_qClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
void                 fld128_ClearBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld128_qSetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
void                 fld128_SetBit(atf_unit::Bitset& parent, u32 bit_idx) __attribute__((nothrow));
// Set bit # BIT_IDX in bit set. No bounds checking
void                 fld128_qSetBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Or bit # BIT_IDX in bit set. No bounds checking
void                 fld128_qOrBitVal(atf_unit::Bitset& parent, u32 bit_idx, bool val) __attribute__((nothrow));
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
void                 fld128_ClearBitsAll(atf_unit::Bitset& parent) __attribute__((nothrow));
// Zero in PARENT any bits that are set in RHS.
void                 fld128_ClearBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
void                 fld128_OrBits(atf_unit::Bitset& parent, atf_unit::Bitset &rhs) __attribute__((nothrow));

// cursor points to valid item
void                 Bitset_fld1_curs_Reset(Bitset_fld1_curs &curs, atf_unit::Bitset &parent);
// cursor points to valid item
bool                 Bitset_fld1_curs_ValidQ(Bitset_fld1_curs &curs);
// proceed to next item
void                 Bitset_fld1_curs_Next(Bitset_fld1_curs &curs);
// item access
u16&                 Bitset_fld1_curs_Access(Bitset_fld1_curs &curs);
// Set all fields to initial values.
void                 Bitset_Init(atf_unit::Bitset& parent);

// --- atf_unit.Cstr
struct Cstr { // atf_unit.Cstr
    algo::cstring   val;   //
    inline operator algo::strptr() const;
    explicit Cstr(const algo::strptr&            in_val);
    Cstr();
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 val_Lt(atf_unit::Cstr& parent, atf_unit::Cstr &rhs) __attribute__((nothrow));
// Compare two fields.
i32                  val_Cmp(atf_unit::Cstr& parent, atf_unit::Cstr &rhs) __attribute__((nothrow));

u32                  Cstr_Hash(u32 prev, const atf_unit::Cstr & rhs) __attribute__((nothrow));
bool                 Cstr_Lt(atf_unit::Cstr & lhs, atf_unit::Cstr & rhs) __attribute__((nothrow));
i32                  Cstr_Cmp(atf_unit::Cstr & lhs, atf_unit::Cstr & rhs) __attribute__((nothrow));
bool                 Cstr_Eq(const atf_unit::Cstr & lhs,const atf_unit::Cstr & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Cstr_Update(atf_unit::Cstr &lhs, atf_unit::Cstr & rhs) __attribute__((nothrow));
// Create JSON representation of atf_unit::Cstr under PARENT node -- cprint:atf_unit.Cstr.Json
lib_json::FNode *    Cstr_FmtJson(atf_unit::Cstr & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_unit.Dbl
// create: atf_unit.FPerfSort.orig (Tary)
// create: atf_unit.FPerfSort.sorted (Tary)
struct Dbl { // atf_unit.Dbl
    double   val;   //   0.0
    inline operator double() const;
    explicit Dbl(double                         in_val);
    bool operator ==(const atf_unit::Dbl &rhs) const;
    bool operator <(const atf_unit::Dbl &rhs) const;
    Dbl();
};

u32                  Dbl_Hash(u32 prev, atf_unit::Dbl rhs) __attribute__((nothrow));
// Read fields of atf_unit::Dbl from an ascii string.
// The format of the string is the format of the atf_unit::Dbl's only field
bool                 Dbl_ReadStrptrMaybe(atf_unit::Dbl &parent, algo::strptr in_str);
bool                 Dbl_Lt(atf_unit::Dbl lhs, atf_unit::Dbl rhs) __attribute__((nothrow));
i32                  Dbl_Cmp(atf_unit::Dbl lhs, atf_unit::Dbl rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Dbl_Init(atf_unit::Dbl& orig);
bool                 Dbl_Eq(atf_unit::Dbl lhs, atf_unit::Dbl rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Dbl_Update(atf_unit::Dbl &lhs, atf_unit::Dbl rhs) __attribute__((nothrow));
// print string representation of atf_unit::Dbl to string LHS, no header -- cprint:atf_unit.Dbl.String
void                 Dbl_Print(atf_unit::Dbl row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of atf_unit::Dbl under PARENT node -- cprint:atf_unit.Dbl.Json
lib_json::FNode *    Dbl_FmtJson(atf_unit::Dbl row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_unit.TestArgtuple1
struct TestArgtuple1 { // atf_unit.TestArgtuple1
    algo::cstring   str_fld1;   //
    double          dbl_fld1;   //   0.0
    i32             xyz;        //   0
    double          test;       //   0
    algo::cstring   value;      //   ""
    i32             test2;      //   0
    algo::cstring   abc;        //   ""
    bool            x;          //   false
    bool            y;          //   false
    bool            z;          //   true
    TestArgtuple1();
};

bool                 TestArgtuple1_ReadFieldMaybe(atf_unit::TestArgtuple1 &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_unit::TestArgtuple1 from an ascii string.
// The format of the string is an ssim Tuple
bool                 TestArgtuple1_ReadStrptrMaybe(atf_unit::TestArgtuple1 &parent, algo::strptr in_str);
// Read fields of atf_unit::TestArgtuple1 from attributes of ascii tuple TUPLE
bool                 TestArgtuple1_ReadTupleMaybe(atf_unit::TestArgtuple1 &parent, algo::Tuple &tuple) __attribute__((nothrow));
// Set all fields to initial values.
void                 TestArgtuple1_Init(atf_unit::TestArgtuple1& parent);
// print string representation of atf_unit::TestArgtuple1 to string LHS, no header -- cprint:atf_unit.TestArgtuple1.String
void                 TestArgtuple1_Print(atf_unit::TestArgtuple1 & row, algo::cstring &str) __attribute__((nothrow));
algo::strptr         TestArgtuple1_GetAnon(atf_unit::TestArgtuple1 &parent, i32 idx) __attribute__((nothrow));

// --- atf_unit.trace
#pragma pack(push,1)
struct trace { // atf_unit.trace
    trace();
};
#pragma pack(pop)

// print string representation of atf_unit::trace to string LHS, no header -- cprint:atf_unit.trace.String
void                 trace_Print(atf_unit::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_unit.FDb
// create: atf_unit.FDb._db (Global)
struct FDb { // atf_unit.FDb
    u32                       number_blocksize;             // # bytes per block
    atf_unit::FNumber*        number_free;                  //
    atf_unit::FNumber*        tr_number_root;               // Root of the tree
    i32                       tr_number_n;                  // number of elements in the tree
    atf_unit::FUnittest*      unittest_lary[32];            // level array
    i32                       unittest_n;                   // number of elements in array
    atf_unit::FUnittest**     ind_unittest_buckets_elems;   // pointer to bucket array
    i32                       ind_unittest_buckets_n;       // number of elements in bucket array
    i32                       ind_unittest_n;               // number of elements in the hash table
    command::atf_unit         cmdline;                      //
    algo::cstring             curdir;                       //
    atf_unit::FUnittest*      c_test;                       // Currently running test. optional pointer
    algo::Smallstr100         cur_teststep;                 //
    report::atf_unit          report;                       //
    atf_unit::TestArgtuple1   cmdline2;                     //
    u64                       perf_cycle_budget;            //   0
    atf_unit::FTestrun**      ind_testrun_buckets_elems;    // pointer to bucket array
    i32                       ind_testrun_buckets_n;        // number of elements in bucket array
    i32                       ind_testrun_n;                // number of elements in the hash table
    atf_unit::FTestrun*       testrun_lary[32];             // level array
    i32                       testrun_n;                    // number of elements in array
    algo::cstring             acr_ed_path;                  //   "bin/acr_ed"  path for executable
    command::acr_ed           acr_ed_cmd;                   // command line for child process
    algo::cstring             acr_ed_stdin;                 // redirect for stdin
    algo::cstring             acr_ed_stdout;                // redirect for stdout
    algo::cstring             acr_ed_stderr;                // redirect for stderr
    pid_t                     acr_ed_pid;                   //   0  pid of running child process
    i32                       acr_ed_timeout;               //   0  optional timeout for child process
    i32                       acr_ed_status;                //   0  last exit status of child process
    atf_unit::trace           trace;                        //
};

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_unit::FNumber&   number_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_unit::FNumber*   number_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 number_Delete(atf_unit::FNumber &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                number_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 number_FreeMem(atf_unit::FNumber &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  number_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  number_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 number_XrefMaybe(atf_unit::FNumber &row);

// Return true if index is empty
bool                 tr_number_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
atf_unit::FNumber*   tr_number_FirstImpl(atf_unit::FNumber* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the first(smallest) element in the tree
atf_unit::FNumber*   tr_number_First() __attribute__((__warn_unused_result__, nothrow));
// Return true if row is in the tree, false otherwise
bool                 tr_number_InTreeQ(atf_unit::FNumber& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
void                 tr_number_InsertImpl(atf_unit::FNumber* parent, atf_unit::FNumber& row) __attribute__((nothrow));
// Insert row into the tree. If row is already in the tree, do nothing.
void                 tr_number_Insert(atf_unit::FNumber& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 tr_number_Remove(atf_unit::FNumber& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 tr_number_RemoveAll() __attribute__((nothrow));
// If the tree is empty, return NULL. Otherwise unlink and return pointer to first element.
void                 tr_number_RemoveFirst() __attribute__((nothrow));
i32                  tr_number_Balance(atf_unit::FNumber& row) __attribute__((nothrow));
// Recalculate depth and keep rebalancing if needed
atf_unit::FNumber*   tr_number_Propagate(atf_unit::FNumber& pnode) __attribute__((nothrow));
// Rebalances the node if needed.
void                 tr_number_Rebalance(atf_unit::FNumber& node) __attribute__((nothrow));
atf_unit::FNumber*   tr_number_Next(atf_unit::FNumber& node) __attribute__((__warn_unused_result__, nothrow));
atf_unit::FNumber*   tr_number_Prev(atf_unit::FNumber& node) __attribute__((__warn_unused_result__, nothrow));
atf_unit::FNumber*   tr_number_LastImpl(atf_unit::FNumber* root) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to the last(largest) element in tree
atf_unit::FNumber*   tr_number_Last() __attribute__((__warn_unused_result__, nothrow));
// Empty the index. (rows may be deleted if cascdel)
void                 tr_number_RemoveAllImpl(atf_unit::FNumber* root, bool del) __attribute__((nothrow));
// Reinsert a row with modified key(Reheap semantics)
void                 tr_number_Reinsert(atf_unit::FNumber& node) __attribute__((nothrow));
// Find the first element that is greater or equal to a sortfld value
atf_unit::FNumber*   tr_number_FirstGe(const i32& val) __attribute__((nothrow));
// Find the last element that is smaller or equal to a sortfld value
atf_unit::FNumber*   tr_number_LastLt(const i32& val) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_unit::FUnittest& unittest_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_unit::FUnittest* unittest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_unit::FUnittest* unittest_InsertMaybe(const atfdb::Unittest &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                unittest_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 unittest_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_unit::FUnittest* unittest_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_unit::FUnittest* unittest_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  unittest_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 unittest_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 unittest_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_unit::FUnittest& unittest_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 unittest_XrefMaybe(atf_unit::FUnittest &row);

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Return true if hash is empty
bool                 ind_unittest_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_unit::FUnittest* ind_unittest_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_unit::FUnittest& ind_unittest_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
atf_unit::FUnittest& ind_unittest_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_unittest_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_unittest_InsertMaybe(atf_unit::FUnittest& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_unittest_Remove(atf_unit::FUnittest& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_unittest_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_testrun_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
atf_unit::FTestrun*  ind_testrun_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
atf_unit::FTestrun&  ind_testrun_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_testrun_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_testrun_InsertMaybe(atf_unit::FTestrun& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_testrun_Remove(atf_unit::FTestrun& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_testrun_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
atf_unit::FTestrun&  testrun_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
atf_unit::FTestrun*  testrun_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
atf_unit::FTestrun*  testrun_InsertMaybe(const atf::Testrun &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                testrun_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 testrun_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_unit::FTestrun*  testrun_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_unit::FTestrun*  testrun_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  testrun_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 testrun_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 testrun_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_unit::FTestrun&  testrun_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 testrun_XrefMaybe(atf_unit::FTestrun &row);

// Start subprocess
// If subprocess already running, do nothing. Otherwise, start it
int                  acr_ed_Start() __attribute__((nothrow));
// Kill subprocess and wait
void                 acr_ed_Kill();
// Wait for subprocess to return
void                 acr_ed_Wait() __attribute__((nothrow));
// Start + Wait
// Execute subprocess and return exit code
int                  acr_ed_Exec() __attribute__((nothrow));
// Start + Wait, throw exception on error
// Execute subprocess; throw human-readable exception on error
void                 acr_ed_ExecX();
// Call execv()
// Call execv with specified parameters -- cprint:acr_ed.Argv
int                  acr_ed_Execv() __attribute__((nothrow));
algo::tempstr        acr_ed_ToCmdline() __attribute__((nothrow));

// cursor points to valid item
void                 _db_tr_number_curs_Reset(_db_tr_number_curs &curs, atf_unit::FDb& );
// cursor points to valid item
bool                 _db_tr_number_curs_ValidQ(_db_tr_number_curs &curs);
// proceed to next item
void                 _db_tr_number_curs_Next(_db_tr_number_curs &curs);
// item access
atf_unit::FNumber&   _db_tr_number_curs_Access(_db_tr_number_curs &curs);
// cursor points to valid item
void                 _db_unittest_curs_Reset(_db_unittest_curs &curs, atf_unit::FDb &parent);
// cursor points to valid item
bool                 _db_unittest_curs_ValidQ(_db_unittest_curs &curs);
// proceed to next item
void                 _db_unittest_curs_Next(_db_unittest_curs &curs);
// item access
atf_unit::FUnittest& _db_unittest_curs_Access(_db_unittest_curs &curs);
// cursor points to valid item
void                 _db_testrun_curs_Reset(_db_testrun_curs &curs, atf_unit::FDb &parent);
// cursor points to valid item
bool                 _db_testrun_curs_ValidQ(_db_testrun_curs &curs);
// proceed to next item
void                 _db_testrun_curs_Next(_db_testrun_curs &curs);
// item access
atf_unit::FTestrun&  _db_testrun_curs_Access(_db_testrun_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- atf_unit.FNumber
// create: atf_unit.FDb.number (Tpool)
// global access: tr_number (Atree)
struct FNumber { // atf_unit.FNumber
    atf_unit::FNumber*   number_next;       // Pointer to next free element int tpool
    atf_unit::FNumber*   tr_number_up;      // pointer to parent
    atf_unit::FNumber*   tr_number_left;    // Left child
    atf_unit::FNumber*   tr_number_right;   // Right child
    i32                  tr_number_depth;   // Depth
    i32                  num;               //   0
private:
    friend atf_unit::FNumber&   number_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_unit::FNumber*   number_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 number_Delete(atf_unit::FNumber &row) __attribute__((nothrow));
    FNumber();
    ~FNumber();
    FNumber(const FNumber&){ /*disallow copy constructor */}
    void operator =(const FNumber&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FNumber_Init(atf_unit::FNumber& number);
void                 FNumber_Uninit(atf_unit::FNumber& number) __attribute__((nothrow));

// --- atf_unit.FPerfSort
struct FPerfSort { // atf_unit.FPerfSort: Function to test double sorting
    atf_unit::Dbl*   orig_elems;     // pointer to elements
    u32              orig_n;         // number of elements in array
    u32              orig_max;       // max. capacity of array before realloc
    atf_unit::Dbl*   sorted_elems;   // pointer to elements
    u32              sorted_n;       // number of elements in array
    u32              sorted_max;     // max. capacity of array before realloc
    i32*             index_elems;    // pointer to elements
    u32              index_n;        // number of elements in array
    u32              index_max;      // max. capacity of array before realloc
    FPerfSort();
    ~FPerfSort();
private:
    // reftype of atf_unit.FPerfSort.orig prohibits copy
    // reftype of atf_unit.FPerfSort.sorted prohibits copy
    // reftype of atf_unit.FPerfSort.index prohibits copy
    // ... and several other reasons
    FPerfSort(const FPerfSort&){ /*disallow copy constructor */}
    void operator =(const FPerfSort&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_unit::Dbl&       orig_Alloc(atf_unit::FPerfSort& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_unit::Dbl&       orig_AllocAt(atf_unit::FPerfSort& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_unit::Dbl> orig_AllocN(atf_unit::FPerfSort& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 orig_EmptyQ(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_unit::Dbl*       orig_Find(atf_unit::FPerfSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_unit::Dbl> orig_Getary(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_unit::Dbl*       orig_Last(atf_unit::FPerfSort& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  orig_Max(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  orig_N(const atf_unit::FPerfSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 orig_Remove(atf_unit::FPerfSort& parent, u32 i) __attribute__((nothrow));
void                 orig_RemoveAll(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 orig_RemoveLast(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 orig_Reserve(atf_unit::FPerfSort& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 orig_AbsReserve(atf_unit::FPerfSort& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 orig_Setary(atf_unit::FPerfSort& parent, atf_unit::FPerfSort &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_unit::Dbl&       orig_qFind(atf_unit::FPerfSort& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
atf_unit::Dbl&       orig_qLast(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  orig_rowid_Get(atf_unit::FPerfSort& parent, atf_unit::Dbl &elem) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 orig_XrefMaybe(atf_unit::Dbl &row);

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
algo::aryptr<atf_unit::Dbl> sorted_Addary(atf_unit::FPerfSort& parent, algo::aryptr<atf_unit::Dbl> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_unit::Dbl&       sorted_Alloc(atf_unit::FPerfSort& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_unit::Dbl&       sorted_AllocAt(atf_unit::FPerfSort& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_unit::Dbl> sorted_AllocN(atf_unit::FPerfSort& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 sorted_EmptyQ(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_unit::Dbl*       sorted_Find(atf_unit::FPerfSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_unit::Dbl> sorted_Getary(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_unit::Dbl*       sorted_Last(atf_unit::FPerfSort& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  sorted_Max(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  sorted_N(const atf_unit::FPerfSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 sorted_Remove(atf_unit::FPerfSort& parent, u32 i) __attribute__((nothrow));
void                 sorted_RemoveAll(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 sorted_RemoveLast(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 sorted_Reserve(atf_unit::FPerfSort& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 sorted_AbsReserve(atf_unit::FPerfSort& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 sorted_Setary(atf_unit::FPerfSort& parent, atf_unit::FPerfSort &rhs) __attribute__((nothrow));
// Copy specified array into sorted, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
void                 sorted_Setary(atf_unit::FPerfSort& parent, const algo::aryptr<atf_unit::Dbl> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_unit::Dbl&       sorted_qFind(atf_unit::FPerfSort& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
atf_unit::Dbl&       sorted_qLast(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  sorted_rowid_Get(atf_unit::FPerfSort& parent, atf_unit::Dbl &elem) __attribute__((nothrow));
// Verify whether array is sorted
bool                 sorted_SortedQ(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Insertion sort
void                 sorted_InsertionSort(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Heap sort
void                 sorted_HeapSort(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Quick sort
void                 sorted_QuickSort(atf_unit::FPerfSort& parent) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
i32&                 index_Alloc(atf_unit::FPerfSort& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
i32&                 index_AllocAt(atf_unit::FPerfSort& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<i32>    index_AllocN(atf_unit::FPerfSort& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 index_EmptyQ(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
i32*                 index_Find(atf_unit::FPerfSort& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<i32>    index_Getary(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
i32*                 index_Last(atf_unit::FPerfSort& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  index_Max(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  index_N(const atf_unit::FPerfSort& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 index_Remove(atf_unit::FPerfSort& parent, u32 i) __attribute__((nothrow));
void                 index_RemoveAll(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 index_RemoveLast(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 index_Reserve(atf_unit::FPerfSort& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 index_AbsReserve(atf_unit::FPerfSort& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 index_Setary(atf_unit::FPerfSort& parent, atf_unit::FPerfSort &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
i32&                 index_qFind(atf_unit::FPerfSort& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
i32&                 index_qLast(atf_unit::FPerfSort& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  index_rowid_Get(atf_unit::FPerfSort& parent, i32 &elem) __attribute__((nothrow));

// proceed to next item
void                 FPerfSort_orig_curs_Next(FPerfSort_orig_curs &curs);
void                 FPerfSort_orig_curs_Reset(FPerfSort_orig_curs &curs, atf_unit::FPerfSort &parent);
// cursor points to valid item
bool                 FPerfSort_orig_curs_ValidQ(FPerfSort_orig_curs &curs);
// item access
atf_unit::Dbl&       FPerfSort_orig_curs_Access(FPerfSort_orig_curs &curs);
// proceed to next item
void                 FPerfSort_sorted_curs_Next(FPerfSort_sorted_curs &curs);
void                 FPerfSort_sorted_curs_Reset(FPerfSort_sorted_curs &curs, atf_unit::FPerfSort &parent);
// cursor points to valid item
bool                 FPerfSort_sorted_curs_ValidQ(FPerfSort_sorted_curs &curs);
// item access
atf_unit::Dbl&       FPerfSort_sorted_curs_Access(FPerfSort_sorted_curs &curs);
// proceed to next item
void                 FPerfSort_index_curs_Next(FPerfSort_index_curs &curs);
void                 FPerfSort_index_curs_Reset(FPerfSort_index_curs &curs, atf_unit::FPerfSort &parent);
// cursor points to valid item
bool                 FPerfSort_index_curs_ValidQ(FPerfSort_index_curs &curs);
// item access
i32&                 FPerfSort_index_curs_Access(FPerfSort_index_curs &curs);
// Set all fields to initial values.
void                 FPerfSort_Init(atf_unit::FPerfSort& parent);
void                 FPerfSort_Uninit(atf_unit::FPerfSort& parent) __attribute__((nothrow));

// --- atf_unit.FTestrun
// create: atf_unit.FDb.testrun (Lary)
// global access: ind_testrun (Thash)
// access: atf_unit.FUnittest.c_testrun (Ptr)
struct FTestrun { // atf_unit.FTestrun
    atf_unit::FTestrun*    ind_testrun_next;   // hash next
    algo::Smallstr50       testrun;            // Test name
    atf::Testresult        testresult;         //   0  Result
    u64                    n_step;             //   0  Number of sub-steps
    u64                    n_cmp;              //   0  Number of comparisons made during test
    algo::cstring          comment;            // Testcase comment
    atf_unit::FUnittest*   p_test;             // reference to parent row
private:
    friend atf_unit::FTestrun&  testrun_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_unit::FTestrun*  testrun_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 testrun_RemoveAll() __attribute__((nothrow));
    friend void                 testrun_RemoveLast() __attribute__((nothrow));
    FTestrun();
    ~FTestrun();
    FTestrun(const FTestrun&){ /*disallow copy constructor */}
    void operator =(const FTestrun&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 testrun_CopyOut(atf_unit::FTestrun &row, atf::Testrun &out) __attribute__((nothrow));
// Copy fields in to row
void                 testrun_CopyIn(atf_unit::FTestrun &row, atf::Testrun &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTestrun_Init(atf_unit::FTestrun& testrun);
void                 FTestrun_Uninit(atf_unit::FTestrun& testrun) __attribute__((nothrow));
// print string representation of atf_unit::FTestrun to string LHS, no header -- cprint:atf_unit.FTestrun.String
void                 FTestrun_Print(atf_unit::FTestrun & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_unit.FUnittest
// create: atf_unit.FDb.unittest (Lary)
// global access: ind_unittest (Thash)
// global access: c_test (Ptr)
// access: atf_unit.FTestrun.p_test (Upptr)
struct FUnittest { // atf_unit.FUnittest: Test function
    atf_unit::FUnittest*           ind_unittest_next;   // hash next
    algo::Smallstr50               unittest;            //
    algo::Comment                  comment;             //
    bool                           select;              //   false  Select test for running?
    atf_unit::unittest_step_hook   step;                //   NULL  Pointer to a function
    atf_unit::FTestrun*            c_testrun;           // optional pointer
private:
    friend atf_unit::FUnittest& unittest_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_unit::FUnittest* unittest_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 unittest_RemoveAll() __attribute__((nothrow));
    friend void                 unittest_RemoveLast() __attribute__((nothrow));
    FUnittest();
    ~FUnittest();
    FUnittest(const FUnittest&){ /*disallow copy constructor */}
    void operator =(const FUnittest&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 unittest_CopyOut(atf_unit::FUnittest &row, atfdb::Unittest &out) __attribute__((nothrow));
// Copy fields in to row
void                 unittest_CopyIn(atf_unit::FUnittest &row, atfdb::Unittest &in) __attribute__((nothrow));

algo::Smallstr16     target_Get(atf_unit::FUnittest& unittest) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     testname_Get(atf_unit::FUnittest& unittest) __attribute__((__warn_unused_result__, nothrow));

// Invoke function by pointer
void                 step_Call(atf_unit::FUnittest& unittest) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_testrun_InsertMaybe(atf_unit::FUnittest& unittest, atf_unit::FTestrun& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_testrun_Remove(atf_unit::FUnittest& unittest, atf_unit::FTestrun& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FUnittest_Init(atf_unit::FUnittest& unittest);
void                 FUnittest_Uninit(atf_unit::FUnittest& unittest) __attribute__((nothrow));
// print string representation of atf_unit::FUnittest to string LHS, no header -- cprint:atf_unit.FUnittest.String
void                 FUnittest_Print(atf_unit::FUnittest & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_unit.FieldId
#pragma pack(push,1)
struct FieldId { // atf_unit.FieldId: Field read helper
    i32   value;   //   -1
    inline operator atf_unit_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(atf_unit_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
atf_unit_FieldIdEnum value_GetEnum(const atf_unit::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(atf_unit::FieldId& parent, atf_unit_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const atf_unit::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const atf_unit::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(atf_unit::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(atf_unit::FieldId& parent, algo::strptr rhs, atf_unit_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(atf_unit::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_unit::FieldId from an ascii string.
// The format of the string is the format of the atf_unit::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(atf_unit::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(atf_unit::FieldId& parent);
// print string representation of atf_unit::FieldId to string LHS, no header -- cprint:atf_unit.FieldId.String
void                 FieldId_Print(atf_unit::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- atf_unit.ShStream
// create: atf_unit.ShStreamAry.shstream (Tary)
struct ShStream { // atf_unit.ShStream
    algo_lib::ShStream   shstream;   //
    ShStream();
private:
    // value field atf_unit.ShStream.shstream is not copiable
    ShStream(const ShStream&){ /*disallow copy constructor */}
    void operator =(const ShStream&){ /*disallow direct assignment */}
};


// --- atf_unit.ShStreamAry
struct ShStreamAry { // atf_unit.ShStreamAry
    atf_unit::ShStream*   shstream_elems;   // pointer to elements
    u32                   shstream_n;       // number of elements in array
    u32                   shstream_max;     // max. capacity of array before realloc
    ShStreamAry();
    ~ShStreamAry();
private:
    // value field atf_unit.ShStreamAry.shstream is not copiable
    // reftype of atf_unit.ShStreamAry.shstream prohibits copy
    ShStreamAry(const ShStreamAry&){ /*disallow copy constructor */}
    void operator =(const ShStreamAry&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
atf_unit::ShStream&  shstream_Alloc(atf_unit::ShStreamAry& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
atf_unit::ShStream&  shstream_AllocAt(atf_unit::ShStreamAry& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<atf_unit::ShStream> shstream_AllocN(atf_unit::ShStreamAry& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 shstream_EmptyQ(atf_unit::ShStreamAry& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
atf_unit::ShStream*  shstream_Find(atf_unit::ShStreamAry& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<atf_unit::ShStream> shstream_Getary(atf_unit::ShStreamAry& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
atf_unit::ShStream*  shstream_Last(atf_unit::ShStreamAry& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  shstream_Max(atf_unit::ShStreamAry& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  shstream_N(const atf_unit::ShStreamAry& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 shstream_Remove(atf_unit::ShStreamAry& parent, u32 i) __attribute__((nothrow));
void                 shstream_RemoveAll(atf_unit::ShStreamAry& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 shstream_RemoveLast(atf_unit::ShStreamAry& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 shstream_Reserve(atf_unit::ShStreamAry& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 shstream_AbsReserve(atf_unit::ShStreamAry& parent, int n) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
atf_unit::ShStream&  shstream_qFind(atf_unit::ShStreamAry& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
atf_unit::ShStream&  shstream_qLast(atf_unit::ShStreamAry& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  shstream_rowid_Get(atf_unit::ShStreamAry& parent, atf_unit::ShStream &elem) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 shstream_XrefMaybe(atf_unit::ShStream &row);

// proceed to next item
void                 ShStreamAry_shstream_curs_Next(ShStreamAry_shstream_curs &curs);
void                 ShStreamAry_shstream_curs_Reset(ShStreamAry_shstream_curs &curs, atf_unit::ShStreamAry &parent);
// cursor points to valid item
bool                 ShStreamAry_shstream_curs_ValidQ(ShStreamAry_shstream_curs &curs);
// item access
atf_unit::ShStream&  ShStreamAry_shstream_curs_Access(ShStreamAry_shstream_curs &curs);
// Set all fields to initial values.
void                 ShStreamAry_Init(atf_unit::ShStreamAry& parent);
void                 ShStreamAry_Uninit(atf_unit::ShStreamAry& parent) __attribute__((nothrow));

// --- atf_unit.TypeA
struct TypeA { // atf_unit.TypeA
    i32   typea;   //   0
    bool operator ==(const atf_unit::TypeA &rhs) const;
    bool operator <(const atf_unit::TypeA &rhs) const;
    TypeA();
};

u32                  TypeA_Hash(u32 prev, const atf_unit::TypeA & rhs) __attribute__((nothrow));
// Read fields of atf_unit::TypeA from an ascii string.
// The format of the string is the format of the atf_unit::TypeA's only field
bool                 TypeA_ReadStrptrMaybe(atf_unit::TypeA &parent, algo::strptr in_str);
bool                 TypeA_Lt(atf_unit::TypeA & lhs, atf_unit::TypeA & rhs) __attribute__((nothrow));
i32                  TypeA_Cmp(atf_unit::TypeA & lhs, atf_unit::TypeA & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeA_Init(atf_unit::TypeA& parent);
bool                 TypeA_Eq(const atf_unit::TypeA & lhs,const atf_unit::TypeA & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeA_Update(atf_unit::TypeA &lhs, atf_unit::TypeA & rhs) __attribute__((nothrow));
// print string representation of atf_unit::TypeA to string LHS, no header -- cprint:atf_unit.TypeA.String
void                 TypeA_Print(atf_unit::TypeA & row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of atf_unit::TypeA under PARENT node -- cprint:atf_unit.TypeA.Json
lib_json::FNode *    TypeA_FmtJson(atf_unit::TypeA & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_unit.TypeB
struct TypeB { // atf_unit.TypeB
    i32   typea;   //   0
    i32   j;       //   0
    bool operator ==(const atf_unit::TypeB &rhs) const;
    bool operator <(const atf_unit::TypeB &rhs) const;
    TypeB();
};

u32                  TypeB_Hash(u32 prev, const atf_unit::TypeB & rhs) __attribute__((nothrow));
bool                 TypeB_ReadFieldMaybe(atf_unit::TypeB &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of atf_unit::TypeB from an ascii string.
// The format of the string is an ssim Tuple
bool                 TypeB_ReadStrptrMaybe(atf_unit::TypeB &parent, algo::strptr in_str);
bool                 TypeB_Lt(atf_unit::TypeB & lhs, atf_unit::TypeB & rhs) __attribute__((nothrow));
i32                  TypeB_Cmp(atf_unit::TypeB & lhs, atf_unit::TypeB & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 TypeB_Init(atf_unit::TypeB& parent);
bool                 TypeB_Eq(const atf_unit::TypeB & lhs,const atf_unit::TypeB & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 TypeB_Update(atf_unit::TypeB &lhs, atf_unit::TypeB & rhs) __attribute__((nothrow));
// print string representation of atf_unit::TypeB to string LHS, no header -- cprint:atf_unit.TypeB.String
void                 TypeB_Print(atf_unit::TypeB & row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of atf_unit::TypeB under PARENT node -- cprint:atf_unit.TypeB.Json
lib_json::FNode *    TypeB_FmtJson(atf_unit::TypeB & row, lib_json::FNode *parent) __attribute__((nothrow));

// --- atf_unit.TestJson
struct TestJson { // atf_unit.TestJson
    bool              fld_bool;       //   false
    u8                fld_u8;         //   0
    i8                fld_i8;         //   0
    u16               fld_u16;        //   0
    i16               fld_i16;        //   0
    u32               fld_u32;        //   0
    i32               fld_i32;        //   0
    u64               fld_u64;        //   0
    i64               fld_i64;        //   0
    float             fld_float;      //   0.f
    double            fld_double;     //   0.0
    char              fld_char;       //   0
    algo::strptr      fld_strptr;     //
    algo::cstring     fld_cstring;    //
    atf_unit::TypeA   fld_atftypea;   // wrapped integer
    atf_unit::Cstr    fld_atfcstr;    // wrapped cstring
    atf_unit::Dbl     fld_atfdbl;     // wrapped double
    atf_unit::TypeB   fld_atftypeb;   // wrapped complex type
    TestJson();
};

// Set all fields to initial values.
void                 TestJson_Init(atf_unit::TestJson& parent);
// print string representation of atf_unit::TestJson to string LHS, no header -- cprint:atf_unit.TestJson.String
void                 TestJson_Print(atf_unit::TestJson & row, algo::cstring &str) __attribute__((nothrow));
// Create JSON representation of atf_unit::TestJson under PARENT node -- cprint:atf_unit.TestJson.Json
lib_json::FNode *    TestJson_FmtJson(atf_unit::TestJson & row, lib_json::FNode *parent) __attribute__((nothrow));

struct Bitset_fld1_curs {// cursor
    typedef u16 ChildType;
    int index;
    atf_unit::Bitset *parent;
    Bitset_fld1_curs() { parent=NULL; index=0; }
};


struct _db_tr_number_curs {// cursor
    typedef atf_unit::FNumber ChildType;
    atf_unit::FNumber* row;
    _db_tr_number_curs() {
        row = NULL;
    }
};


struct _db_unittest_curs {// cursor
    typedef atf_unit::FUnittest ChildType;
    atf_unit::FDb *parent;
    i64 index;
    _db_unittest_curs(){ parent=NULL; index=0; }
};


struct _db_testrun_curs {// cursor
    typedef atf_unit::FTestrun ChildType;
    atf_unit::FDb *parent;
    i64 index;
    _db_testrun_curs(){ parent=NULL; index=0; }
};


struct FPerfSort_orig_curs {// cursor
    typedef atf_unit::Dbl ChildType;
    atf_unit::Dbl* elems;
    int n_elems;
    int index;
    FPerfSort_orig_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FPerfSort_sorted_curs {// cursor
    typedef atf_unit::Dbl ChildType;
    atf_unit::Dbl* elems;
    int n_elems;
    int index;
    FPerfSort_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FPerfSort_index_curs {// cursor
    typedef i32 ChildType;
    i32* elems;
    int n_elems;
    int index;
    FPerfSort_index_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ShStreamAry_shstream_curs {// cursor
    typedef atf_unit::ShStream ChildType;
    atf_unit::ShStream* elems;
    int n_elems;
    int index;
    ShStreamAry_shstream_curs() { elems=NULL; n_elems=0; index=0; }
};

// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Check1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Del1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Field1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Fldfunc1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Insert1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Insert2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Merge1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Meta1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Read1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Read2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Read3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Read5();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Regx1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Replace1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Rowid1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Unused1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Write1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Write2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Xref1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_acr_Xref2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Abs();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Aligned();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Argtuple2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Argtuple_ReadArgv();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Argtuple_ReadStrptr();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_AvlvsMap();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_CSVTokens();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_CString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_CaseConversion();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Ceiling();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Charset();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_CheckIpmask();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_CheckShiftMask();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Clipped();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Cmp();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Datecache();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_DayName();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_DirBeg();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_DoTestRounding();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_FileLine_curs();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_FileToString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_FmtBufDec();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_I32Dec3Fmt();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_IntPrice();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Interlocked();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Keyval();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Lockfile();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_MinMax();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_NToh();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_NextSep();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_OrderID();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseHex1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseHex2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseNumber();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseNumber_Overflow1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseNumber_Overflow2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseNumber_Overflow3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseOct1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseOct3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseURL1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ParseUnTime();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PerfIntrinsics();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PerfMinMaxAvg();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PerfParseDouble();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PerfParseNum();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PerfSort();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PerfTruncVsFtol();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PopCnt1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PopCnt2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintBash();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintCppQuoted();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintDoubleWithCommas();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintHex();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintPad();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintSsim();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintTime();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_PrintWithCommas();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ReadLine();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_ReadModuleId();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Regx();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RegxReadTwice();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RegxReadTwice2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RegxShortCircuit();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RemDirRecurse();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RemDirRecurse1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RemDirRecurse2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RemDirRecurse3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_RemDirRecurse4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Replscope();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_SchedTime();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Sleep();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Smallstr();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Strfind();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_StringCase();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_StringFind();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_StringIter();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_StringSubrange();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_StringToFile();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_SubstringIndex();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_SysEval();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Tabulate();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Tempfile();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestBitSet();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestFbitset();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestFbitset2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestFbitset3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestFbitset4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestStringFmt();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestStringFmt2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TestStringFmt3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TimeConstants();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TimeConversion();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_TrimZerosRight();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Tuple();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Tuple1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_Tuple2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_U128PrintHex();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_UnescapeC();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_strptr_Eq();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_algo_lib_test_strptr();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_amc_Unit();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_exec_Dependency();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_exec_Parallel1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_exec_Timeout();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_exec_TooManyFds();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArrayAll();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArrayEmptyArray();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArrayEmptyObject();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArraySimpleNumber();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArraySimpleString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArrayTokenFalse();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArrayTokenNull();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ArrayTokenTrue();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_CtrlCharEscape();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_Empty();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_EmptyArray();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_Emptyobject();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorArrayColon();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorArrayComma1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorArrayComma2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorArrayComma3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorArrayComma4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadNumber();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadString1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadString2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadString3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadToken1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadToken2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString5();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString6();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBadUString7();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBareColon();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBareComma();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBareValuesWithColon();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBareValuesWithComma();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch10();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch11();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch12();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch13();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch14();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch5();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch6();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch7();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch8();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorBrMismatch9();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectColon1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectColon2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectColon3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectColon4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectColon5();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectComma1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectComma2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectComma3();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectComma4();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectDupField();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ErrorObjectNoValue();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_Object();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_TypeA();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_bool_false();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_bool_true();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_char();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_double_prec();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_float_prec();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i16_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i16_min();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i32_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i32_min();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i64_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i64_min();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i8_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_i8_min();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u16_0();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u16_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u32_0();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u32_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u64_0();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u64_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u8_0();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_FmtJson_u8_max();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberCombined1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberCombined2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberDecimal();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberExponent1();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberExponent2();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberManyDigits();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_NumberZero();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldAll();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldEmptyArray();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldEmptyObject();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldSimpleNumber();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldSimpleString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldTokenFalse();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldTokenNull();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_ObjFieldTokenTrue();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_SecString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_SimpleNumber();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_SimpleString();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_StringEmpty();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_StringWithEscapes();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_TokenFalse();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_TokenNull();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_TokenTrue();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_json_Typical();
// User-implemented function from gstatic:atf_unit.FDb.unittest
void                 unittest_lib_sql_Main();
int                  main(int argc, char **argv);
} // end namespace atf_unit
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::Dbl &row);// cfmt:atf_unit.Dbl.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::TestArgtuple1 &row);// cfmt:atf_unit.TestArgtuple1.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::trace &row);// cfmt:atf_unit.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::FTestrun &row);// cfmt:atf_unit.FTestrun.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::FUnittest &row);// cfmt:atf_unit.FUnittest.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::FieldId &row);// cfmt:atf_unit.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::TypeA &row);// cfmt:atf_unit.TypeA.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::TypeB &row);// cfmt:atf_unit.TypeB.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_unit::TestJson &row);// cfmt:atf_unit.TestJson.String
}
