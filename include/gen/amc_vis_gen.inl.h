//
// include/gen/amc_vis_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
//#pragma endinclude
inline amc_vis::FCtype::FCtype() {
    amc_vis::FCtype_Init(*this);
}

inline amc_vis::FCtype::~FCtype() {
    amc_vis::FCtype_Uninit(*this);
}


// --- amc_vis.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool amc_vis::c_field_EmptyQ(amc_vis::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- amc_vis.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FField* amc_vis::c_field_Find(amc_vis::FCtype& ctype, u32 t) {
    amc_vis::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- amc_vis.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<amc_vis::FField*> amc_vis::c_field_Getary(amc_vis::FCtype& ctype) {
    return algo::aryptr<amc_vis::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- amc_vis.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 amc_vis::c_field_N(const amc_vis::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- amc_vis.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc_vis::c_field_RemoveAll(amc_vis::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_elems[i]->ctype_c_field_in_ary = false;
    }
    ctype.c_field_n = 0;
}

// --- amc_vis.FCtype.c_field_curs.Reset
inline void amc_vis::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, amc_vis::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- amc_vis.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc_vis.FCtype.c_field_curs.Next
// proceed to next item
inline void amc_vis::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- amc_vis.FCtype.c_field_curs.Access
// item access
inline amc_vis::FField& amc_vis::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc_vis.FCtype..Init
// Set all fields to initial values.
inline void amc_vis::FCtype_Init(amc_vis::FCtype& ctype) {
    ctype.p_base = NULL;
    ctype.c_field_elems = NULL; // (amc_vis.FCtype.c_field)
    ctype.c_field_n = 0; // (amc_vis.FCtype.c_field)
    ctype.c_field_max = 0; // (amc_vis.FCtype.c_field)
    ctype.mm_id = i32(0);
    ctype.isinput = bool(false);
    ctype.ind_ctype_next = (amc_vis::FCtype*)-1; // (amc_vis.FDb.ind_ctype) not-in-hash
    ctype.zd_select_next = (amc_vis::FCtype*)-1; // (amc_vis.FDb.zd_select) not-in-list
    ctype.zd_select_prev = NULL; // (amc_vis.FDb.zd_select)
}
inline amc_vis::trace::trace() {
}


// --- amc_vis.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool amc_vis::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- amc_vis.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FCtype* amc_vis::ctype_Find(u64 t) {
    amc_vis::FCtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ctype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::FCtype* amc_vis::ctype_Last() {
    return ctype_Find(u64(_db.ctype_n-1));
}

// --- amc_vis.FDb.ctype.N
// Return number of items in the pool
inline i32 amc_vis::ctype_N() {
    return _db.ctype_n;
}

// --- amc_vis.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::FCtype& amc_vis::ctype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- amc_vis.FDb.field.EmptyQ
// Return true if index is empty
inline bool amc_vis::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- amc_vis.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FField* amc_vis::field_Find(u64 t) {
    amc_vis::FField *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.field_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::FField* amc_vis::field_Last() {
    return field_Find(u64(_db.field_n-1));
}

// --- amc_vis.FDb.field.N
// Return number of items in the pool
inline i32 amc_vis::field_N() {
    return _db.field_n;
}

// --- amc_vis.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::FField& amc_vis::field_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- amc_vis.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool amc_vis::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- amc_vis.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 amc_vis::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- amc_vis.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool amc_vis::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- amc_vis.FDb.ind_field.N
// Return number of items in the hash
inline i32 amc_vis::ind_field_N() {
    return _db.ind_field_n;
}

// --- amc_vis.FDb.node.EmptyQ
// Return true if index is empty
inline bool amc_vis::node_EmptyQ() {
    return _db.node_n == 0;
}

// --- amc_vis.FDb.node.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FNode* amc_vis::node_Find(i32 t) {
    amc_vis::FNode *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.node_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.node_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.node.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::FNode* amc_vis::node_Last() {
    return node_Find(i32(_db.node_n-1));
}

// --- amc_vis.FDb.node.N
// Return number of items in the pool
inline i32 amc_vis::node_N() {
    return _db.node_n;
}

// --- amc_vis.FDb.node.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::FNode& amc_vis::node_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.node_lary[bsr][index];
}

// --- amc_vis.FDb.ind_node.EmptyQ
// Return true if hash is empty
inline bool amc_vis::ind_node_EmptyQ() {
    return _db.ind_node_n == 0;
}

// --- amc_vis.FDb.ind_node.N
// Return number of items in the hash
inline i32 amc_vis::ind_node_N() {
    return _db.ind_node_n;
}

// --- amc_vis.FDb.link.EmptyQ
// Return true if index is empty
inline bool amc_vis::link_EmptyQ() {
    return _db.link_n == 0;
}

// --- amc_vis.FDb.link.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::Link* amc_vis::link_Find(u64 t) {
    amc_vis::Link *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.link_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.link_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.link.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::Link* amc_vis::link_Last() {
    return link_Find(u64(_db.link_n-1));
}

// --- amc_vis.FDb.link.N
// Return number of items in the pool
inline i32 amc_vis::link_N() {
    return _db.link_n;
}

// --- amc_vis.FDb.link.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::Link& amc_vis::link_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.link_lary[bsr][index];
}

// --- amc_vis.FDb.ind_link.EmptyQ
// Return true if hash is empty
inline bool amc_vis::ind_link_EmptyQ() {
    return _db.ind_link_n == 0;
}

// --- amc_vis.FDb.ind_link.N
// Return number of items in the hash
inline i32 amc_vis::ind_link_N() {
    return _db.ind_link_n;
}

// --- amc_vis.FDb.linkdep.EmptyQ
// Return true if index is empty
inline bool amc_vis::linkdep_EmptyQ() {
    return _db.linkdep_n == 0;
}

// --- amc_vis.FDb.linkdep.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::Linkdep* amc_vis::linkdep_Find(i32 t) {
    amc_vis::Linkdep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.linkdep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.linkdep_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.linkdep.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::Linkdep* amc_vis::linkdep_Last() {
    return linkdep_Find(i32(_db.linkdep_n-1));
}

// --- amc_vis.FDb.linkdep.N
// Return number of items in the pool
inline i32 amc_vis::linkdep_N() {
    return _db.linkdep_n;
}

// --- amc_vis.FDb.linkdep.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::Linkdep& amc_vis::linkdep_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.linkdep_lary[bsr][index];
}

// --- amc_vis.FDb.c_linklist.EmptyQ
// Return true if index is empty
inline bool amc_vis::c_linklist_EmptyQ() {
    return _db.c_linklist_n == 0;
}

// --- amc_vis.FDb.c_linklist.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::Link* amc_vis::c_linklist_Find(u32 t) {
    amc_vis::Link *retval = NULL;
    u64 idx = t;
    u64 lim = _db.c_linklist_n;
    if (idx < lim) {
        retval = _db.c_linklist_elems[idx];
    }
    return retval;
}

// --- amc_vis.FDb.c_linklist.Getary
// Return array of pointers
inline algo::aryptr<amc_vis::Link*> amc_vis::c_linklist_Getary() {
    return algo::aryptr<amc_vis::Link*>(_db.c_linklist_elems, _db.c_linklist_n);
}

// --- amc_vis.FDb.c_linklist.N
// Return number of items in the pointer array
inline i32 amc_vis::c_linklist_N() {
    return _db.c_linklist_n;
}

// --- amc_vis.FDb.c_linklist.RemoveAll
// Empty the index. (The rows are not deleted)
inline void amc_vis::c_linklist_RemoveAll() {
    for (u32 i = 0; i < _db.c_linklist_n; i++) {
        // mark all elements as not-in-array
        _db.c_linklist_elems[i]->_db_c_linklist_in_ary = false;
    }
    _db.c_linklist_n = 0;
}

// --- amc_vis.FDb.bh_node.EmptyQ
// Return true if index is empty
inline bool amc_vis::bh_node_EmptyQ() {
    return _db.bh_node_n == 0;
}

// --- amc_vis.FDb.bh_node.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::FNode* amc_vis::bh_node_First() {
    amc_vis::FNode *row = NULL;
    if (_db.bh_node_n > 0) {
        row = _db.bh_node_elems[0];
    }
    return row;
}

// --- amc_vis.FDb.bh_node.InBheapQ
// Return true if row is in index, false otherwise
inline bool amc_vis::bh_node_InBheapQ(amc_vis::FNode& row) {
    bool result = false;
    result = row.bh_node_idx != -1;
    return result;
}

// --- amc_vis.FDb.bh_node.N
// Return number of items in the heap
inline i32 amc_vis::bh_node_N() {
    return _db.bh_node_n;
}

// --- amc_vis.FDb.bh_link.EmptyQ
// Return true if index is empty
inline bool amc_vis::bh_link_EmptyQ() {
    return _db.bh_link_n == 0;
}

// --- amc_vis.FDb.bh_link.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::Link* amc_vis::bh_link_First() {
    amc_vis::Link *row = NULL;
    if (_db.bh_link_n > 0) {
        row = _db.bh_link_elems[0];
    }
    return row;
}

// --- amc_vis.FDb.bh_link.InBheapQ
// Return true if row is in index, false otherwise
inline bool amc_vis::bh_link_InBheapQ(amc_vis::Link& row) {
    bool result = false;
    result = row.bh_link_idx != -1;
    return result;
}

// --- amc_vis.FDb.bh_link.N
// Return number of items in the heap
inline i32 amc_vis::bh_link_N() {
    return _db.bh_link_n;
}

// --- amc_vis.FDb.reftype.EmptyQ
// Return true if index is empty
inline bool amc_vis::reftype_EmptyQ() {
    return _db.reftype_n == 0;
}

// --- amc_vis.FDb.reftype.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FReftype* amc_vis::reftype_Find(u64 t) {
    amc_vis::FReftype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.reftype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.reftype_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.reftype.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::FReftype* amc_vis::reftype_Last() {
    return reftype_Find(u64(_db.reftype_n-1));
}

// --- amc_vis.FDb.reftype.N
// Return number of items in the pool
inline i32 amc_vis::reftype_N() {
    return _db.reftype_n;
}

// --- amc_vis.FDb.reftype.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::FReftype& amc_vis::reftype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.reftype_lary[bsr][index];
}

// --- amc_vis.FDb.ind_reftype.EmptyQ
// Return true if hash is empty
inline bool amc_vis::ind_reftype_EmptyQ() {
    return _db.ind_reftype_n == 0;
}

// --- amc_vis.FDb.ind_reftype.N
// Return number of items in the hash
inline i32 amc_vis::ind_reftype_N() {
    return _db.ind_reftype_n;
}

// --- amc_vis.FDb.nodedep.EmptyQ
// Return true if index is empty
inline bool amc_vis::nodedep_EmptyQ() {
    return _db.nodedep_n == 0;
}

// --- amc_vis.FDb.nodedep.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FNodedep* amc_vis::nodedep_Find(i32 t) {
    amc_vis::FNodedep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nodedep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nodedep_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.nodedep.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::FNodedep* amc_vis::nodedep_Last() {
    return nodedep_Find(i32(_db.nodedep_n-1));
}

// --- amc_vis.FDb.nodedep.N
// Return number of items in the pool
inline i32 amc_vis::nodedep_N() {
    return _db.nodedep_n;
}

// --- amc_vis.FDb.nodedep.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::FNodedep& amc_vis::nodedep_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nodedep_lary[bsr][index];
}

// --- amc_vis.FDb.outrow.EmptyQ
// Return true if index is empty
inline bool amc_vis::outrow_EmptyQ() {
    return _db.outrow_n == 0;
}

// --- amc_vis.FDb.outrow.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::Outrow* amc_vis::outrow_Find(i32 t) {
    amc_vis::Outrow *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.outrow_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.outrow_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.outrow.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::Outrow* amc_vis::outrow_Last() {
    return outrow_Find(i32(_db.outrow_n-1));
}

// --- amc_vis.FDb.outrow.N
// Return number of items in the pool
inline i32 amc_vis::outrow_N() {
    return _db.outrow_n;
}

// --- amc_vis.FDb.outrow.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::Outrow& amc_vis::outrow_qFind(i32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.outrow_lary[bsr][index];
}

// --- amc_vis.FDb.zd_select.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_select_EmptyQ() {
    return _db.zd_select_head == NULL;
}

// --- amc_vis.FDb.zd_select.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::FCtype* amc_vis::zd_select_First() {
    amc_vis::FCtype *row = NULL;
    row = _db.zd_select_head;
    return row;
}

// --- amc_vis.FDb.zd_select.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_select_InLlistQ(amc_vis::FCtype& row) {
    bool result = false;
    result = !(row.zd_select_next == (amc_vis::FCtype*)-1);
    return result;
}

// --- amc_vis.FDb.zd_select.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::FCtype* amc_vis::zd_select_Last() {
    amc_vis::FCtype *row = NULL;
    row = _db.zd_select_tail;
    return row;
}

// --- amc_vis.FDb.zd_select.N
// Return number of items in the linked list
inline i32 amc_vis::zd_select_N() {
    return _db.zd_select_n;
}

// --- amc_vis.FDb.zd_select.Next
// Return pointer to next element in the list
inline amc_vis::FCtype* amc_vis::zd_select_Next(amc_vis::FCtype &row) {
    return row.zd_select_next;
}

// --- amc_vis.FDb.zd_select.Prev
// Return pointer to previous element in the list
inline amc_vis::FCtype* amc_vis::zd_select_Prev(amc_vis::FCtype &row) {
    return row.zd_select_prev;
}

// --- amc_vis.FDb.zd_select.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::FCtype& amc_vis::zd_select_qLast() {
    amc_vis::FCtype *row = NULL;
    row = _db.zd_select_tail;
    return *row;
}

// --- amc_vis.FDb.finput.EmptyQ
// Return true if index is empty
inline bool amc_vis::finput_EmptyQ() {
    return _db.finput_n == 0;
}

// --- amc_vis.FDb.finput.Find
// Look up row by row id. Return NULL if out of range
inline amc_vis::FFinput* amc_vis::finput_Find(u64 t) {
    amc_vis::FFinput *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.finput_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.finput_lary[bsr][index];
    }
    return retval;
}

// --- amc_vis.FDb.finput.Last
// Return pointer to last element of array, or NULL if array is empty
inline amc_vis::FFinput* amc_vis::finput_Last() {
    return finput_Find(u64(_db.finput_n-1));
}

// --- amc_vis.FDb.finput.N
// Return number of items in the pool
inline i32 amc_vis::finput_N() {
    return _db.finput_n;
}

// --- amc_vis.FDb.finput.qFind
// 'quick' Access row by row id. No bounds checking.
inline amc_vis::FFinput& amc_vis::finput_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.finput_lary[bsr][index];
}

// --- amc_vis.FDb.ctype_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_ctype_curs_Reset(_db_ctype_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- amc_vis.FDb.ctype_curs.Next
// proceed to next item
inline void amc_vis::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.ctype_curs.Access
// item access
inline amc_vis::FCtype& amc_vis::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(u64(curs.index));
}

// --- amc_vis.FDb.field_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_field_curs_Reset(_db_field_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- amc_vis.FDb.field_curs.Next
// proceed to next item
inline void amc_vis::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.field_curs.Access
// item access
inline amc_vis::FField& amc_vis::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u64(curs.index));
}

// --- amc_vis.FDb.node_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_node_curs_Reset(_db_node_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.node_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_node_curs_ValidQ(_db_node_curs &curs) {
    return curs.index < _db.node_n;
}

// --- amc_vis.FDb.node_curs.Next
// proceed to next item
inline void amc_vis::_db_node_curs_Next(_db_node_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.node_curs.Access
// item access
inline amc_vis::FNode& amc_vis::_db_node_curs_Access(_db_node_curs &curs) {
    return node_qFind(i32(curs.index));
}

// --- amc_vis.FDb.link_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_link_curs_Reset(_db_link_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.link_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_link_curs_ValidQ(_db_link_curs &curs) {
    return curs.index < _db.link_n;
}

// --- amc_vis.FDb.link_curs.Next
// proceed to next item
inline void amc_vis::_db_link_curs_Next(_db_link_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.link_curs.Access
// item access
inline amc_vis::Link& amc_vis::_db_link_curs_Access(_db_link_curs &curs) {
    return link_qFind(u64(curs.index));
}

// --- amc_vis.FDb.linkdep_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_linkdep_curs_Reset(_db_linkdep_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.linkdep_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_linkdep_curs_ValidQ(_db_linkdep_curs &curs) {
    return curs.index < _db.linkdep_n;
}

// --- amc_vis.FDb.linkdep_curs.Next
// proceed to next item
inline void amc_vis::_db_linkdep_curs_Next(_db_linkdep_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.linkdep_curs.Access
// item access
inline amc_vis::Linkdep& amc_vis::_db_linkdep_curs_Access(_db_linkdep_curs &curs) {
    return linkdep_qFind(i32(curs.index));
}

// --- amc_vis.FDb.c_linklist_curs.Reset
inline void amc_vis::_db_c_linklist_curs_Reset(_db_c_linklist_curs &curs, amc_vis::FDb &parent) {
    curs.elems = parent.c_linklist_elems;
    curs.n_elems = parent.c_linklist_n;
    curs.index = 0;
}

// --- amc_vis.FDb.c_linklist_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_c_linklist_curs_ValidQ(_db_c_linklist_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc_vis.FDb.c_linklist_curs.Next
// proceed to next item
inline void amc_vis::_db_c_linklist_curs_Next(_db_c_linklist_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.c_linklist_curs.Access
// item access
inline amc_vis::Link& amc_vis::_db_c_linklist_curs_Access(_db_c_linklist_curs &curs) {
    return *curs.elems[curs.index];
}

// --- amc_vis.FDb.bh_node_curs.Access
// Access current element. If not more elements, return NULL
inline amc_vis::FNode& amc_vis::_db_bh_node_curs_Access(_db_bh_node_curs &curs) {
    return *curs.temp_elems[0];
}

// --- amc_vis.FDb.bh_node_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool amc_vis::_db_bh_node_curs_ValidQ(_db_bh_node_curs &curs) {
    return curs.temp_n > 0;
}

// --- amc_vis.FDb.bh_link_curs.Access
// Access current element. If not more elements, return NULL
inline amc_vis::Link& amc_vis::_db_bh_link_curs_Access(_db_bh_link_curs &curs) {
    return *curs.temp_elems[0];
}

// --- amc_vis.FDb.bh_link_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool amc_vis::_db_bh_link_curs_ValidQ(_db_bh_link_curs &curs) {
    return curs.temp_n > 0;
}

// --- amc_vis.FDb.reftype_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_reftype_curs_Reset(_db_reftype_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.reftype_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_reftype_curs_ValidQ(_db_reftype_curs &curs) {
    return curs.index < _db.reftype_n;
}

// --- amc_vis.FDb.reftype_curs.Next
// proceed to next item
inline void amc_vis::_db_reftype_curs_Next(_db_reftype_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.reftype_curs.Access
// item access
inline amc_vis::FReftype& amc_vis::_db_reftype_curs_Access(_db_reftype_curs &curs) {
    return reftype_qFind(u64(curs.index));
}

// --- amc_vis.FDb.nodedep_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_nodedep_curs_Reset(_db_nodedep_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.nodedep_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_nodedep_curs_ValidQ(_db_nodedep_curs &curs) {
    return curs.index < _db.nodedep_n;
}

// --- amc_vis.FDb.nodedep_curs.Next
// proceed to next item
inline void amc_vis::_db_nodedep_curs_Next(_db_nodedep_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.nodedep_curs.Access
// item access
inline amc_vis::FNodedep& amc_vis::_db_nodedep_curs_Access(_db_nodedep_curs &curs) {
    return nodedep_qFind(i32(curs.index));
}

// --- amc_vis.FDb.outrow_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_outrow_curs_Reset(_db_outrow_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.outrow_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_outrow_curs_ValidQ(_db_outrow_curs &curs) {
    return curs.index < _db.outrow_n;
}

// --- amc_vis.FDb.outrow_curs.Next
// proceed to next item
inline void amc_vis::_db_outrow_curs_Next(_db_outrow_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.outrow_curs.Access
// item access
inline amc_vis::Outrow& amc_vis::_db_outrow_curs_Access(_db_outrow_curs &curs) {
    return outrow_qFind(i32(curs.index));
}

// --- amc_vis.FDb.zd_select_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_zd_select_curs_Reset(_db_zd_select_curs &curs, amc_vis::FDb &parent) {
    curs.row = parent.zd_select_head;
}

// --- amc_vis.FDb.zd_select_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_zd_select_curs_ValidQ(_db_zd_select_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.FDb.zd_select_curs.Next
// proceed to next item
inline void amc_vis::_db_zd_select_curs_Next(_db_zd_select_curs &curs) {
    curs.row = (*curs.row).zd_select_next;
}

// --- amc_vis.FDb.zd_select_curs.Access
// item access
inline amc_vis::FCtype& amc_vis::_db_zd_select_curs_Access(_db_zd_select_curs &curs) {
    return *curs.row;
}

// --- amc_vis.FDb.finput_curs.Reset
// cursor points to valid item
inline void amc_vis::_db_finput_curs_Reset(_db_finput_curs &curs, amc_vis::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- amc_vis.FDb.finput_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::_db_finput_curs_ValidQ(_db_finput_curs &curs) {
    return curs.index < _db.finput_n;
}

// --- amc_vis.FDb.finput_curs.Next
// proceed to next item
inline void amc_vis::_db_finput_curs_Next(_db_finput_curs &curs) {
    curs.index++;
}

// --- amc_vis.FDb.finput_curs.Access
// item access
inline amc_vis::FFinput& amc_vis::_db_finput_curs_Access(_db_finput_curs &curs) {
    return finput_qFind(u64(curs.index));
}
inline amc_vis::FField::FField() {
    amc_vis::FField_Init(*this);
}

inline amc_vis::FField::~FField() {
    amc_vis::FField_Uninit(*this);
}


// --- amc_vis.FField.c_finput.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool amc_vis::c_finput_InsertMaybe(amc_vis::FField& field, amc_vis::FFinput& row) {
    amc_vis::FFinput* ptr = field.c_finput;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_finput = &row;
    }
    return retval;
}

// --- amc_vis.FField.c_finput.Remove
// Remove element from index. If element is not in index, do nothing.
inline void amc_vis::c_finput_Remove(amc_vis::FField& field, amc_vis::FFinput& row) {
    amc_vis::FFinput *ptr = field.c_finput;
    if (LIKELY(ptr == &row)) {
        field.c_finput = NULL;
    }
}
inline amc_vis::FFinput::FFinput() {
    amc_vis::FFinput_Init(*this);
}

inline amc_vis::FFinput::~FFinput() {
    amc_vis::FFinput_Uninit(*this);
}


// --- amc_vis.FFinput..Init
// Set all fields to initial values.
inline void amc_vis::FFinput_Init(amc_vis::FFinput& finput) {
    finput.extrn = bool(false);
    finput.update = bool(false);
    finput.strict = bool(true);
}
inline amc_vis::Nodekey::Nodekey(u32                            in_n_ct_in
        ,i32                            in_idx
        ,i32                            in_prev_xpos)
    : n_ct_in(in_n_ct_in)
    , idx(in_idx)
    , prev_xpos(in_prev_xpos)
{
}

inline bool amc_vis::Nodekey::operator ==(const amc_vis::Nodekey &rhs) const {
    return amc_vis::Nodekey_Eq(const_cast<amc_vis::Nodekey&>(*this),const_cast<amc_vis::Nodekey&>(rhs));
}

inline bool amc_vis::Nodekey::operator !=(const amc_vis::Nodekey &rhs) const {
    return !amc_vis::Nodekey_Eq(const_cast<amc_vis::Nodekey&>(*this),const_cast<amc_vis::Nodekey&>(rhs));
}

inline bool amc_vis::Nodekey::operator <(const amc_vis::Nodekey &rhs) const {
    return amc_vis::Nodekey_Lt(const_cast<amc_vis::Nodekey&>(*this),const_cast<amc_vis::Nodekey&>(rhs));
}
inline amc_vis::Nodekey::Nodekey() {
    amc_vis::Nodekey_Init(*this);
}


// --- amc_vis.Nodekey..Hash
inline u32 amc_vis::Nodekey_Hash(u32 prev, amc_vis::Nodekey rhs) {
    prev = u32_Hash(prev, rhs.n_ct_in);
    prev = i32_Hash(prev, rhs.idx);
    prev = i32_Hash(prev, rhs.prev_xpos);
    return prev;
}

// --- amc_vis.Nodekey..Lt
inline bool amc_vis::Nodekey_Lt(amc_vis::Nodekey lhs, amc_vis::Nodekey rhs) {
    return Nodekey_Cmp(lhs,rhs) < 0;
}

// --- amc_vis.Nodekey..Cmp
inline i32 amc_vis::Nodekey_Cmp(amc_vis::Nodekey lhs, amc_vis::Nodekey rhs) {
    i32 retval = 0;
    retval = u32_Cmp(lhs.n_ct_in, rhs.n_ct_in);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.idx, rhs.idx);
    if (retval != 0) {
        return retval;
    }
    retval = i32_Cmp(lhs.prev_xpos, rhs.prev_xpos);
    return retval;
}

// --- amc_vis.Nodekey..Init
// Set all fields to initial values.
inline void amc_vis::Nodekey_Init(amc_vis::Nodekey& parent) {
    parent.n_ct_in = u32(0);
    parent.idx = i32(0);
    parent.prev_xpos = i32(99999999);
}

// --- amc_vis.Nodekey..Eq
inline bool amc_vis::Nodekey_Eq(amc_vis::Nodekey lhs, amc_vis::Nodekey rhs) {
    bool retval = true;
    retval = u32_Eq(lhs.n_ct_in, rhs.n_ct_in);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.idx, rhs.idx);
    if (!retval) {
        return false;
    }
    retval = i32_Eq(lhs.prev_xpos, rhs.prev_xpos);
    return retval;
}

// --- amc_vis.Nodekey..Update
// Set value. Return true if new value is different from old value.
inline bool amc_vis::Nodekey_Update(amc_vis::Nodekey &lhs, amc_vis::Nodekey rhs) {
    bool ret = !Nodekey_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline amc_vis::FNode::FNode() {
    amc_vis::FNode_Init(*this);
}

inline amc_vis::FNode::~FNode() {
    amc_vis::FNode_Uninit(*this);
}


// --- amc_vis.FNode.nodekey.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool amc_vis::nodekey_Lt(amc_vis::FNode& node, amc_vis::FNode &rhs) {
    return amc_vis::Nodekey_Lt(node.nodekey,rhs.nodekey);
}

// --- amc_vis.FNode.nodekey.Cmp
// Compare two fields.
inline i32 amc_vis::nodekey_Cmp(amc_vis::FNode& node, amc_vis::FNode &rhs) {
    i32 retval = 0;
    retval = amc_vis::Nodekey_Cmp(node.nodekey, rhs.nodekey);
    return retval;
}

// --- amc_vis.FNode.zd_nodedep_out.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_nodedep_out_EmptyQ(amc_vis::FNode& node) {
    return node.zd_nodedep_out_head == NULL;
}

// --- amc_vis.FNode.zd_nodedep_out.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::FNodedep* amc_vis::zd_nodedep_out_First(amc_vis::FNode& node) {
    amc_vis::FNodedep *row = NULL;
    row = node.zd_nodedep_out_head;
    return row;
}

// --- amc_vis.FNode.zd_nodedep_out.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_nodedep_out_InLlistQ(amc_vis::FNodedep& row) {
    bool result = false;
    result = !(row.zd_nodedep_out_next == (amc_vis::FNodedep*)-1);
    return result;
}

// --- amc_vis.FNode.zd_nodedep_out.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::FNodedep* amc_vis::zd_nodedep_out_Last(amc_vis::FNode& node) {
    amc_vis::FNodedep *row = NULL;
    row = node.zd_nodedep_out_tail;
    return row;
}

// --- amc_vis.FNode.zd_nodedep_out.Next
// Return pointer to next element in the list
inline amc_vis::FNodedep* amc_vis::zd_nodedep_out_Next(amc_vis::FNodedep &row) {
    return row.zd_nodedep_out_next;
}

// --- amc_vis.FNode.zd_nodedep_out.Prev
// Return pointer to previous element in the list
inline amc_vis::FNodedep* amc_vis::zd_nodedep_out_Prev(amc_vis::FNodedep &row) {
    return row.zd_nodedep_out_prev;
}

// --- amc_vis.FNode.zd_nodedep_out.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::FNodedep& amc_vis::zd_nodedep_out_qLast(amc_vis::FNode& node) {
    amc_vis::FNodedep *row = NULL;
    row = node.zd_nodedep_out_tail;
    return *row;
}

// --- amc_vis.FNode.zd_nodedep_in.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_nodedep_in_EmptyQ(amc_vis::FNode& node) {
    return node.zd_nodedep_in_head == NULL;
}

// --- amc_vis.FNode.zd_nodedep_in.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::FNodedep* amc_vis::zd_nodedep_in_First(amc_vis::FNode& node) {
    amc_vis::FNodedep *row = NULL;
    row = node.zd_nodedep_in_head;
    return row;
}

// --- amc_vis.FNode.zd_nodedep_in.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_nodedep_in_InLlistQ(amc_vis::FNodedep& row) {
    bool result = false;
    result = !(row.zd_nodedep_in_next == (amc_vis::FNodedep*)-1);
    return result;
}

// --- amc_vis.FNode.zd_nodedep_in.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::FNodedep* amc_vis::zd_nodedep_in_Last(amc_vis::FNode& node) {
    amc_vis::FNodedep *row = NULL;
    row = node.zd_nodedep_in_tail;
    return row;
}

// --- amc_vis.FNode.zd_nodedep_in.N
// Return number of items in the linked list
inline i32 amc_vis::zd_nodedep_in_N(const amc_vis::FNode& node) {
    return node.zd_nodedep_in_n;
}

// --- amc_vis.FNode.zd_nodedep_in.Next
// Return pointer to next element in the list
inline amc_vis::FNodedep* amc_vis::zd_nodedep_in_Next(amc_vis::FNodedep &row) {
    return row.zd_nodedep_in_next;
}

// --- amc_vis.FNode.zd_nodedep_in.Prev
// Return pointer to previous element in the list
inline amc_vis::FNodedep* amc_vis::zd_nodedep_in_Prev(amc_vis::FNodedep &row) {
    return row.zd_nodedep_in_prev;
}

// --- amc_vis.FNode.zd_nodedep_in.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::FNodedep& amc_vis::zd_nodedep_in_qLast(amc_vis::FNode& node) {
    amc_vis::FNodedep *row = NULL;
    row = node.zd_nodedep_in_tail;
    return *row;
}

// --- amc_vis.FNode.zd_link_out.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_link_out_EmptyQ(amc_vis::FNode& node) {
    return node.zd_link_out_head == NULL;
}

// --- amc_vis.FNode.zd_link_out.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::Link* amc_vis::zd_link_out_First(amc_vis::FNode& node) {
    amc_vis::Link *row = NULL;
    row = node.zd_link_out_head;
    return row;
}

// --- amc_vis.FNode.zd_link_out.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_link_out_InLlistQ(amc_vis::Link& row) {
    bool result = false;
    result = !(row.zd_link_out_next == (amc_vis::Link*)-1);
    return result;
}

// --- amc_vis.FNode.zd_link_out.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::Link* amc_vis::zd_link_out_Last(amc_vis::FNode& node) {
    amc_vis::Link *row = NULL;
    row = node.zd_link_out_tail;
    return row;
}

// --- amc_vis.FNode.zd_link_out.N
// Return number of items in the linked list
inline i32 amc_vis::zd_link_out_N(const amc_vis::FNode& node) {
    return node.zd_link_out_n;
}

// --- amc_vis.FNode.zd_link_out.Next
// Return pointer to next element in the list
inline amc_vis::Link* amc_vis::zd_link_out_Next(amc_vis::Link &row) {
    return row.zd_link_out_next;
}

// --- amc_vis.FNode.zd_link_out.Prev
// Return pointer to previous element in the list
inline amc_vis::Link* amc_vis::zd_link_out_Prev(amc_vis::Link &row) {
    return row.zd_link_out_prev;
}

// --- amc_vis.FNode.zd_link_out.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::Link& amc_vis::zd_link_out_qLast(amc_vis::FNode& node) {
    amc_vis::Link *row = NULL;
    row = node.zd_link_out_tail;
    return *row;
}

// --- amc_vis.FNode.zd_link_in.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_link_in_EmptyQ(amc_vis::FNode& node) {
    return node.zd_link_in_head == NULL;
}

// --- amc_vis.FNode.zd_link_in.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::Link* amc_vis::zd_link_in_First(amc_vis::FNode& node) {
    amc_vis::Link *row = NULL;
    row = node.zd_link_in_head;
    return row;
}

// --- amc_vis.FNode.zd_link_in.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_link_in_InLlistQ(amc_vis::Link& row) {
    bool result = false;
    result = !(row.zd_link_in_next == (amc_vis::Link*)-1);
    return result;
}

// --- amc_vis.FNode.zd_link_in.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::Link* amc_vis::zd_link_in_Last(amc_vis::FNode& node) {
    amc_vis::Link *row = NULL;
    row = node.zd_link_in_tail;
    return row;
}

// --- amc_vis.FNode.zd_link_in.N
// Return number of items in the linked list
inline i32 amc_vis::zd_link_in_N(const amc_vis::FNode& node) {
    return node.zd_link_in_n;
}

// --- amc_vis.FNode.zd_link_in.Next
// Return pointer to next element in the list
inline amc_vis::Link* amc_vis::zd_link_in_Next(amc_vis::Link &row) {
    return row.zd_link_in_next;
}

// --- amc_vis.FNode.zd_link_in.Prev
// Return pointer to previous element in the list
inline amc_vis::Link* amc_vis::zd_link_in_Prev(amc_vis::Link &row) {
    return row.zd_link_in_prev;
}

// --- amc_vis.FNode.zd_link_in.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::Link& amc_vis::zd_link_in_qLast(amc_vis::FNode& node) {
    amc_vis::Link *row = NULL;
    row = node.zd_link_in_tail;
    return *row;
}

// --- amc_vis.FNode.zd_nodedep_out_curs.Reset
// cursor points to valid item
inline void amc_vis::node_zd_nodedep_out_curs_Reset(node_zd_nodedep_out_curs &curs, amc_vis::FNode &parent) {
    curs.row = parent.zd_nodedep_out_head;
}

// --- amc_vis.FNode.zd_nodedep_out_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::node_zd_nodedep_out_curs_ValidQ(node_zd_nodedep_out_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.FNode.zd_nodedep_out_curs.Next
// proceed to next item
inline void amc_vis::node_zd_nodedep_out_curs_Next(node_zd_nodedep_out_curs &curs) {
    curs.row = (*curs.row).zd_nodedep_out_next;
}

// --- amc_vis.FNode.zd_nodedep_out_curs.Access
// item access
inline amc_vis::FNodedep& amc_vis::node_zd_nodedep_out_curs_Access(node_zd_nodedep_out_curs &curs) {
    return *curs.row;
}

// --- amc_vis.FNode.zd_nodedep_in_curs.Reset
// cursor points to valid item
inline void amc_vis::node_zd_nodedep_in_curs_Reset(node_zd_nodedep_in_curs &curs, amc_vis::FNode &parent) {
    curs.row = parent.zd_nodedep_in_head;
}

// --- amc_vis.FNode.zd_nodedep_in_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::node_zd_nodedep_in_curs_ValidQ(node_zd_nodedep_in_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.FNode.zd_nodedep_in_curs.Next
// proceed to next item
inline void amc_vis::node_zd_nodedep_in_curs_Next(node_zd_nodedep_in_curs &curs) {
    curs.row = (*curs.row).zd_nodedep_in_next;
}

// --- amc_vis.FNode.zd_nodedep_in_curs.Access
// item access
inline amc_vis::FNodedep& amc_vis::node_zd_nodedep_in_curs_Access(node_zd_nodedep_in_curs &curs) {
    return *curs.row;
}

// --- amc_vis.FNode.zd_link_out_curs.Reset
// cursor points to valid item
inline void amc_vis::node_zd_link_out_curs_Reset(node_zd_link_out_curs &curs, amc_vis::FNode &parent) {
    curs.row = parent.zd_link_out_head;
}

// --- amc_vis.FNode.zd_link_out_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::node_zd_link_out_curs_ValidQ(node_zd_link_out_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.FNode.zd_link_out_curs.Next
// proceed to next item
inline void amc_vis::node_zd_link_out_curs_Next(node_zd_link_out_curs &curs) {
    curs.row = (*curs.row).zd_link_out_next;
}

// --- amc_vis.FNode.zd_link_out_curs.Access
// item access
inline amc_vis::Link& amc_vis::node_zd_link_out_curs_Access(node_zd_link_out_curs &curs) {
    return *curs.row;
}

// --- amc_vis.FNode.zd_link_in_curs.Reset
// cursor points to valid item
inline void amc_vis::node_zd_link_in_curs_Reset(node_zd_link_in_curs &curs, amc_vis::FNode &parent) {
    curs.row = parent.zd_link_in_head;
}

// --- amc_vis.FNode.zd_link_in_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::node_zd_link_in_curs_ValidQ(node_zd_link_in_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.FNode.zd_link_in_curs.Next
// proceed to next item
inline void amc_vis::node_zd_link_in_curs_Next(node_zd_link_in_curs &curs) {
    curs.row = (*curs.row).zd_link_in_next;
}

// --- amc_vis.FNode.zd_link_in_curs.Access
// item access
inline amc_vis::Link& amc_vis::node_zd_link_in_curs_Access(node_zd_link_in_curs &curs) {
    return *curs.row;
}
inline amc_vis::FNodedep::FNodedep(i32                            in_row
        ,i32                            in_rowid
        ,bool                           in_up
        ,bool                           in_inst
        ,amc_vis::FNode*                in_p_node1
        ,amc_vis::FNode*                in_p_node2
        ,const algo::strptr&            in_name
        ,const algo::strptr&            in_reftype)
    : row(in_row)
    , rowid(in_rowid)
    , up(in_up)
    , inst(in_inst)
    , p_node1(in_p_node1)
    , p_node2(in_p_node2)
    , name(in_name)
    , reftype(in_reftype)
{
}
inline amc_vis::FNodedep::FNodedep() {
    amc_vis::FNodedep_Init(*this);
}

inline amc_vis::FNodedep::~FNodedep() {
    amc_vis::FNodedep_Uninit(*this);
}


// --- amc_vis.FNodedep..Init
// Set all fields to initial values.
inline void amc_vis::FNodedep_Init(amc_vis::FNodedep& nodedep) {
    nodedep.row = i32(0);
    nodedep.rowid = i32(0);
    nodedep.up = bool(false);
    nodedep.inst = bool(false);
    nodedep.p_node1 = NULL;
    nodedep.p_node2 = NULL;
    nodedep.zd_nodedep_out_next = (amc_vis::FNodedep*)-1; // (amc_vis.FNode.zd_nodedep_out) not-in-list
    nodedep.zd_nodedep_out_prev = NULL; // (amc_vis.FNode.zd_nodedep_out)
    nodedep.zd_nodedep_in_next = (amc_vis::FNodedep*)-1; // (amc_vis.FNode.zd_nodedep_in) not-in-list
    nodedep.zd_nodedep_in_prev = NULL; // (amc_vis.FNode.zd_nodedep_in)
}
inline amc_vis::FReftype::FReftype() {
    amc_vis::FReftype_Init(*this);
}

inline amc_vis::FReftype::~FReftype() {
    amc_vis::FReftype_Uninit(*this);
}

inline amc_vis::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline amc_vis::FieldId::FieldId(amc_vis_FieldIdEnum arg) { this->value = i32(arg); }
inline amc_vis::FieldId::FieldId() {
    amc_vis::FieldId_Init(*this);
}


// --- amc_vis.FieldId.value.GetEnum
// Get value of field as enum type
inline amc_vis_FieldIdEnum amc_vis::value_GetEnum(const amc_vis::FieldId& parent) {
    return amc_vis_FieldIdEnum(parent.value);
}

// --- amc_vis.FieldId.value.SetEnum
// Set value of field from enum type.
inline void amc_vis::value_SetEnum(amc_vis::FieldId& parent, amc_vis_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- amc_vis.FieldId.value.Cast
inline amc_vis::FieldId::operator amc_vis_FieldIdEnum () const {
    return amc_vis_FieldIdEnum((*this).value);
}

// --- amc_vis.FieldId..Init
// Set all fields to initial values.
inline void amc_vis::FieldId_Init(amc_vis::FieldId& parent) {
    parent.value = i32(-1);
}
inline amc_vis::Linkkey::Linkkey(u32                            in_n_link_in
        ,i32                            in_samecol
        ,i32                            in_colweight
        ,i32                            in_topbot)
    : n_link_in(in_n_link_in)
    , samecol(in_samecol)
    , colweight(in_colweight)
    , topbot(in_topbot)
{
}

inline bool amc_vis::Linkkey::operator ==(const amc_vis::Linkkey &rhs) const {
    return amc_vis::Linkkey_Eq(const_cast<amc_vis::Linkkey&>(*this),const_cast<amc_vis::Linkkey&>(rhs));
}

inline bool amc_vis::Linkkey::operator !=(const amc_vis::Linkkey &rhs) const {
    return !amc_vis::Linkkey_Eq(const_cast<amc_vis::Linkkey&>(*this),const_cast<amc_vis::Linkkey&>(rhs));
}

inline bool amc_vis::Linkkey::operator <(const amc_vis::Linkkey &rhs) const {
    return amc_vis::Linkkey_Lt(const_cast<amc_vis::Linkkey&>(*this),const_cast<amc_vis::Linkkey&>(rhs));
}
inline amc_vis::Linkkey::Linkkey() {
    amc_vis::Linkkey_Init(*this);
}


// --- amc_vis.Linkkey..Hash
inline u32 amc_vis::Linkkey_Hash(u32 prev, amc_vis::Linkkey rhs) {
    prev = u32_Hash(prev, rhs.n_link_in);
    prev = i32_Hash(prev, rhs.samecol);
    prev = i32_Hash(prev, rhs.colweight);
    prev = i32_Hash(prev, rhs.topbot);
    return prev;
}

// --- amc_vis.Linkkey..Lt
inline bool amc_vis::Linkkey_Lt(amc_vis::Linkkey lhs, amc_vis::Linkkey rhs) {
    return Linkkey_Cmp(lhs,rhs) < 0;
}

// --- amc_vis.Linkkey..Init
// Set all fields to initial values.
inline void amc_vis::Linkkey_Init(amc_vis::Linkkey& parent) {
    parent.n_link_in = u32(0);
    parent.samecol = i32(0);
    parent.colweight = i32(0);
    parent.topbot = i32(0);
}

// --- amc_vis.Linkkey..Update
// Set value. Return true if new value is different from old value.
inline bool amc_vis::Linkkey_Update(amc_vis::Linkkey &lhs, amc_vis::Linkkey rhs) {
    bool ret = !Linkkey_Eq(lhs, rhs); // compare values
    if (ret) {
        lhs = rhs; // update
    }
    return ret;
}
inline amc_vis::Link::Link() {
    amc_vis::Link_Init(*this);
}

inline amc_vis::Link::~Link() {
    amc_vis::Link_Uninit(*this);
}


// --- amc_vis.Link.linkkey.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool amc_vis::linkkey_Lt(amc_vis::Link& link, amc_vis::Link &rhs) {
    return amc_vis::Linkkey_Lt(link.linkkey,rhs.linkkey);
}

// --- amc_vis.Link.linkkey.Cmp
// Compare two fields.
inline i32 amc_vis::linkkey_Cmp(amc_vis::Link& link, amc_vis::Link &rhs) {
    i32 retval = 0;
    retval = amc_vis::Linkkey_Cmp(link.linkkey, rhs.linkkey);
    return retval;
}

// --- amc_vis.Link.zd_linkdep_out.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_linkdep_out_EmptyQ(amc_vis::Link& link) {
    return link.zd_linkdep_out_head == NULL;
}

// --- amc_vis.Link.zd_linkdep_out.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::Linkdep* amc_vis::zd_linkdep_out_First(amc_vis::Link& link) {
    amc_vis::Linkdep *row = NULL;
    row = link.zd_linkdep_out_head;
    return row;
}

// --- amc_vis.Link.zd_linkdep_out.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_linkdep_out_InLlistQ(amc_vis::Linkdep& row) {
    bool result = false;
    result = !(row.zd_linkdep_out_next == (amc_vis::Linkdep*)-1);
    return result;
}

// --- amc_vis.Link.zd_linkdep_out.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::Linkdep* amc_vis::zd_linkdep_out_Last(amc_vis::Link& link) {
    amc_vis::Linkdep *row = NULL;
    row = link.zd_linkdep_out_tail;
    return row;
}

// --- amc_vis.Link.zd_linkdep_out.Next
// Return pointer to next element in the list
inline amc_vis::Linkdep* amc_vis::zd_linkdep_out_Next(amc_vis::Linkdep &row) {
    return row.zd_linkdep_out_next;
}

// --- amc_vis.Link.zd_linkdep_out.Prev
// Return pointer to previous element in the list
inline amc_vis::Linkdep* amc_vis::zd_linkdep_out_Prev(amc_vis::Linkdep &row) {
    return row.zd_linkdep_out_prev;
}

// --- amc_vis.Link.zd_linkdep_out.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::Linkdep& amc_vis::zd_linkdep_out_qLast(amc_vis::Link& link) {
    amc_vis::Linkdep *row = NULL;
    row = link.zd_linkdep_out_tail;
    return *row;
}

// --- amc_vis.Link.zd_linkdep_in.EmptyQ
// Return true if index is empty
inline bool amc_vis::zd_linkdep_in_EmptyQ(amc_vis::Link& link) {
    return link.zd_linkdep_in_head == NULL;
}

// --- amc_vis.Link.zd_linkdep_in.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline amc_vis::Linkdep* amc_vis::zd_linkdep_in_First(amc_vis::Link& link) {
    amc_vis::Linkdep *row = NULL;
    row = link.zd_linkdep_in_head;
    return row;
}

// --- amc_vis.Link.zd_linkdep_in.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool amc_vis::zd_linkdep_in_InLlistQ(amc_vis::Linkdep& row) {
    bool result = false;
    result = !(row.zd_linkdep_in_next == (amc_vis::Linkdep*)-1);
    return result;
}

// --- amc_vis.Link.zd_linkdep_in.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline amc_vis::Linkdep* amc_vis::zd_linkdep_in_Last(amc_vis::Link& link) {
    amc_vis::Linkdep *row = NULL;
    row = link.zd_linkdep_in_tail;
    return row;
}

// --- amc_vis.Link.zd_linkdep_in.Next
// Return pointer to next element in the list
inline amc_vis::Linkdep* amc_vis::zd_linkdep_in_Next(amc_vis::Linkdep &row) {
    return row.zd_linkdep_in_next;
}

// --- amc_vis.Link.zd_linkdep_in.Prev
// Return pointer to previous element in the list
inline amc_vis::Linkdep* amc_vis::zd_linkdep_in_Prev(amc_vis::Linkdep &row) {
    return row.zd_linkdep_in_prev;
}

// --- amc_vis.Link.zd_linkdep_in.qLast
// Return reference to last element in the index. No bounds checking.
inline amc_vis::Linkdep& amc_vis::zd_linkdep_in_qLast(amc_vis::Link& link) {
    amc_vis::Linkdep *row = NULL;
    row = link.zd_linkdep_in_tail;
    return *row;
}

// --- amc_vis.Link.zd_linkdep_out_curs.Reset
// cursor points to valid item
inline void amc_vis::link_zd_linkdep_out_curs_Reset(link_zd_linkdep_out_curs &curs, amc_vis::Link &parent) {
    curs.row = parent.zd_linkdep_out_head;
}

// --- amc_vis.Link.zd_linkdep_out_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::link_zd_linkdep_out_curs_ValidQ(link_zd_linkdep_out_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.Link.zd_linkdep_out_curs.Next
// proceed to next item
inline void amc_vis::link_zd_linkdep_out_curs_Next(link_zd_linkdep_out_curs &curs) {
    curs.row = (*curs.row).zd_linkdep_out_next;
}

// --- amc_vis.Link.zd_linkdep_out_curs.Access
// item access
inline amc_vis::Linkdep& amc_vis::link_zd_linkdep_out_curs_Access(link_zd_linkdep_out_curs &curs) {
    return *curs.row;
}

// --- amc_vis.Link.zd_linkdep_in_curs.Reset
// cursor points to valid item
inline void amc_vis::link_zd_linkdep_in_curs_Reset(link_zd_linkdep_in_curs &curs, amc_vis::Link &parent) {
    curs.row = parent.zd_linkdep_in_head;
}

// --- amc_vis.Link.zd_linkdep_in_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::link_zd_linkdep_in_curs_ValidQ(link_zd_linkdep_in_curs &curs) {
    return curs.row != NULL;
}

// --- amc_vis.Link.zd_linkdep_in_curs.Next
// proceed to next item
inline void amc_vis::link_zd_linkdep_in_curs_Next(link_zd_linkdep_in_curs &curs) {
    curs.row = (*curs.row).zd_linkdep_in_next;
}

// --- amc_vis.Link.zd_linkdep_in_curs.Access
// item access
inline amc_vis::Linkdep& amc_vis::link_zd_linkdep_in_curs_Access(link_zd_linkdep_in_curs &curs) {
    return *curs.row;
}
inline amc_vis::Linkdep::Linkdep(i32                            in_row
        ,i32                            in_rowid
        ,bool                           in_up
        ,bool                           in_inst
        ,amc_vis::Link*                 in_p_link_from
        ,amc_vis::Link*                 in_p_link_to)
    : row(in_row)
    , rowid(in_rowid)
    , up(in_up)
    , inst(in_inst)
    , p_link_from(in_p_link_from)
    , p_link_to(in_p_link_to)
{
}
inline amc_vis::Linkdep::Linkdep() {
    amc_vis::Linkdep_Init(*this);
}

inline amc_vis::Linkdep::~Linkdep() {
    amc_vis::Linkdep_Uninit(*this);
}


// --- amc_vis.Linkdep..Init
// Set all fields to initial values.
inline void amc_vis::Linkdep_Init(amc_vis::Linkdep& linkdep) {
    linkdep.row = i32(0);
    linkdep.rowid = i32(0);
    linkdep.up = bool(false);
    linkdep.inst = bool(false);
    linkdep.p_link_from = NULL;
    linkdep.p_link_to = NULL;
    linkdep.zd_linkdep_out_next = (amc_vis::Linkdep*)-1; // (amc_vis.Link.zd_linkdep_out) not-in-list
    linkdep.zd_linkdep_out_prev = NULL; // (amc_vis.Link.zd_linkdep_out)
    linkdep.zd_linkdep_in_next = (amc_vis::Linkdep*)-1; // (amc_vis.Link.zd_linkdep_in) not-in-list
    linkdep.zd_linkdep_in_prev = NULL; // (amc_vis.Link.zd_linkdep_in)
}
inline amc_vis::Outrow::Outrow() {
    amc_vis::Outrow_Init(*this);
}

inline amc_vis::Outrow::~Outrow() {
    amc_vis::Outrow_Uninit(*this);
}


// --- amc_vis.Outrow.text.EmptyQ
// Return true if index is empty
inline bool amc_vis::text_EmptyQ(amc_vis::Outrow& outrow) {
    return outrow.text_n == 0;
}

// --- amc_vis.Outrow.text.Find
// Look up row by row id. Return NULL if out of range
inline u8* amc_vis::text_Find(amc_vis::Outrow& outrow, u64 t) {
    u64 idx = t;
    u64 lim = outrow.text_n;
    if (idx >= lim) return NULL;
    return outrow.text_elems + idx;
}

// --- amc_vis.Outrow.text.Getary
// Return array pointer by value
inline algo::aryptr<u8> amc_vis::text_Getary(amc_vis::Outrow& outrow) {
    return algo::aryptr<u8>(outrow.text_elems, outrow.text_n);
}

// --- amc_vis.Outrow.text.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* amc_vis::text_Last(amc_vis::Outrow& outrow) {
    return text_Find(outrow, u64(outrow.text_n-1));
}

// --- amc_vis.Outrow.text.Max
// Return max. number of items in the array
inline i32 amc_vis::text_Max(amc_vis::Outrow& outrow) {
    (void)outrow;
    return outrow.text_max;
}

// --- amc_vis.Outrow.text.N
// Return number of items in the array
inline i32 amc_vis::text_N(const amc_vis::Outrow& outrow) {
    return outrow.text_n;
}

// --- amc_vis.Outrow.text.RemoveAll
inline void amc_vis::text_RemoveAll(amc_vis::Outrow& outrow) {
    outrow.text_n = 0;
}

// --- amc_vis.Outrow.text.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void amc_vis::text_Reserve(amc_vis::Outrow& outrow, int n) {
    u32 new_n = outrow.text_n + n;
    if (UNLIKELY(new_n > outrow.text_max)) {
        text_AbsReserve(outrow, new_n);
    }
}

// --- amc_vis.Outrow.text.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& amc_vis::text_qFind(amc_vis::Outrow& outrow, u64 t) {
    return outrow.text_elems[t];
}

// --- amc_vis.Outrow.text.qLast
// Return reference to last element of array. No bounds checking
inline u8& amc_vis::text_qLast(amc_vis::Outrow& outrow) {
    return text_qFind(outrow, u64(outrow.text_n-1));
}

// --- amc_vis.Outrow.text.rowid_Get
// Return row id of specified element
inline u64 amc_vis::text_rowid_Get(amc_vis::Outrow& outrow, u8 &elem) {
    u64 id = &elem - outrow.text_elems;
    return u64(id);
}

// --- amc_vis.Outrow.text_curs.Next
// proceed to next item
inline void amc_vis::outrow_text_curs_Next(outrow_text_curs &curs) {
    curs.index++;
}

// --- amc_vis.Outrow.text_curs.Reset
inline void amc_vis::outrow_text_curs_Reset(outrow_text_curs &curs, amc_vis::Outrow &parent) {
    curs.elems = parent.text_elems;
    curs.n_elems = parent.text_n;
    curs.index = 0;
}

// --- amc_vis.Outrow.text_curs.ValidQ
// cursor points to valid item
inline bool amc_vis::outrow_text_curs_ValidQ(outrow_text_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- amc_vis.Outrow.text_curs.Access
// item access
inline u8& amc_vis::outrow_text_curs_Access(outrow_text_curs &curs) {
    return curs.elems[curs.index];
}

// --- amc_vis.Outrow..Init
// Set all fields to initial values.
inline void amc_vis::Outrow_Init(amc_vis::Outrow& outrow) {
    outrow.rowid = i32(0);
    outrow.text_elems 	= 0; // (amc_vis.Outrow.text)
    outrow.text_n     	= 0; // (amc_vis.Outrow.text)
    outrow.text_max   	= 0; // (amc_vis.Outrow.text)
}
inline amc_vis::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline amc_vis::TableId::TableId(amc_vis_TableIdEnum arg) { this->value = i32(arg); }
inline amc_vis::TableId::TableId() {
    amc_vis::TableId_Init(*this);
}


// --- amc_vis.TableId.value.GetEnum
// Get value of field as enum type
inline amc_vis_TableIdEnum amc_vis::value_GetEnum(const amc_vis::TableId& parent) {
    return amc_vis_TableIdEnum(parent.value);
}

// --- amc_vis.TableId.value.SetEnum
// Set value of field from enum type.
inline void amc_vis::value_SetEnum(amc_vis::TableId& parent, amc_vis_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- amc_vis.TableId.value.Cast
inline amc_vis::TableId::operator amc_vis_TableIdEnum () const {
    return amc_vis_TableIdEnum((*this).value);
}

// --- amc_vis.TableId..Init
// Set all fields to initial values.
inline void amc_vis::TableId_Init(amc_vis::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::trace &row) {// cfmt:amc_vis.trace.String
    amc_vis::trace_Print(const_cast<amc_vis::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::Nodekey &row) {// cfmt:amc_vis.Nodekey.String
    amc_vis::Nodekey_Print(const_cast<amc_vis::Nodekey&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::FieldId &row) {// cfmt:amc_vis.FieldId.String
    amc_vis::FieldId_Print(const_cast<amc_vis::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::Linkkey &row) {// cfmt:amc_vis.Linkkey.String
    amc_vis::Linkkey_Print(const_cast<amc_vis::Linkkey&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::Link &row) {// cfmt:amc_vis.Link.String
    amc_vis::Link_Print(const_cast<amc_vis::Link&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::Linkdep &row) {// cfmt:amc_vis.Linkdep.String
    amc_vis::Linkdep_Print(const_cast<amc_vis::Linkdep&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::Outrow &row) {// cfmt:amc_vis.Outrow.String
    amc_vis::Outrow_Print(const_cast<amc_vis::Outrow&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const amc_vis::TableId &row) {// cfmt:amc_vis.TableId.String
    amc_vis::TableId_Print(const_cast<amc_vis::TableId&>(row), str);
    return str;
}
