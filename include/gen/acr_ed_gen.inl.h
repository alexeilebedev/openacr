//
// include/gen/acr_ed_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.inl.h"
//#pragma endinclude
inline acr_ed::FCstr::FCstr() {
    acr_ed::FCstr_Init(*this);
}

inline acr_ed::FCstr::~FCstr() {
    acr_ed::FCstr_Uninit(*this);
}


// --- acr_ed.FCstr..Init
// Set all fields to initial values.
inline void acr_ed::FCstr_Init(acr_ed::FCstr& cstr) {
    cstr.strequiv = bool(false);
}
inline acr_ed::FCtype::FCtype() {
    acr_ed::FCtype_Init(*this);
}

inline acr_ed::FCtype::~FCtype() {
    acr_ed::FCtype_Uninit(*this);
}


// --- acr_ed.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool acr_ed::c_field_EmptyQ(acr_ed::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- acr_ed.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FField* acr_ed::c_field_Find(acr_ed::FCtype& ctype, u32 t) {
    acr_ed::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- acr_ed.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<acr_ed::FField*> acr_ed::c_field_Getary(acr_ed::FCtype& ctype) {
    return algo::aryptr<acr_ed::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- acr_ed.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 acr_ed::c_field_N(const acr_ed::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- acr_ed.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr_ed::c_field_RemoveAll(acr_ed::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_elems[i]->ctype_c_field_in_ary = false;
    }
    ctype.c_field_n = 0;
}

// --- acr_ed.FCtype.c_cstr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_cstr_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCstr& row) {
    acr_ed::FCstr* ptr = ctype.c_cstr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cstr = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_cstr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_cstr_Remove(acr_ed::FCtype& ctype, acr_ed::FCstr& row) {
    acr_ed::FCstr *ptr = ctype.c_cstr;
    if (LIKELY(ptr == &row)) {
        ctype.c_cstr = NULL;
    }
}

// --- acr_ed.FCtype.c_ssimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_ssimfile_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) {
    acr_ed::FSsimfile* ptr = ctype.c_ssimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ssimfile = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_ssimfile_Remove(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) {
    acr_ed::FSsimfile *ptr = ctype.c_ssimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_ssimfile = NULL;
    }
}

// --- acr_ed.FCtype.c_field_curs.Reset
inline void acr_ed::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr_ed::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- acr_ed.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr_ed.FCtype.c_field_curs.Next
// proceed to next item
inline void acr_ed::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- acr_ed.FCtype.c_field_curs.Access
// item access
inline acr_ed::FField& acr_ed::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr_ed.FCtype..Init
// Set all fields to initial values.
inline void acr_ed::FCtype_Init(acr_ed::FCtype& ctype) {
    ctype.c_field_elems = NULL; // (acr_ed.FCtype.c_field)
    ctype.c_field_n = 0; // (acr_ed.FCtype.c_field)
    ctype.c_field_max = 0; // (acr_ed.FCtype.c_field)
    ctype.c_cstr = NULL;
    ctype.p_ns = NULL;
    ctype.c_ssimfile = NULL;
    ctype.ind_ctype_next = (acr_ed::FCtype*)-1; // (acr_ed.FDb.ind_ctype) not-in-hash
}
inline acr_ed::trace::trace() {
}


// --- acr_ed.FDb.ns.EmptyQ
// Return true if index is empty
inline bool acr_ed::ns_EmptyQ() {
    return _db.ns_n == 0;
}

// --- acr_ed.FDb.ns.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FNs* acr_ed::ns_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FNs *retval = NULL;
    if (LIKELY(x <= u64(_db.ns_n))) {
        retval = &_db.ns_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.ns.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FNs* acr_ed::ns_Last() {
    return ns_Find(u64(_db.ns_n-1));
}

// --- acr_ed.FDb.ns.N
// Return number of items in the pool
inline i32 acr_ed::ns_N() {
    return _db.ns_n;
}

// --- acr_ed.FDb.ns.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FNs& acr_ed::ns_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ns_lary[bsr][index];
}

// --- acr_ed.FDb.ind_ns.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_ns_EmptyQ() {
    return _db.ind_ns_n == 0;
}

// --- acr_ed.FDb.ind_ns.N
// Return number of items in the hash
inline i32 acr_ed::ind_ns_N() {
    return _db.ind_ns_n;
}

// --- acr_ed.FDb.field.EmptyQ
// Return true if index is empty
inline bool acr_ed::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- acr_ed.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FField* acr_ed::field_Find(u32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FField *retval = NULL;
    if (LIKELY(x <= u64(_db.field_n))) {
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FField* acr_ed::field_Last() {
    return field_Find(u32(_db.field_n-1));
}

// --- acr_ed.FDb.field.N
// Return number of items in the pool
inline i32 acr_ed::field_N() {
    return _db.field_n;
}

// --- acr_ed.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FField& acr_ed::field_qFind(u32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- acr_ed.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- acr_ed.FDb.ind_field.N
// Return number of items in the hash
inline i32 acr_ed::ind_field_N() {
    return _db.ind_field_n;
}

// --- acr_ed.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool acr_ed::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- acr_ed.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCtype* acr_ed::ctype_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FCtype *retval = NULL;
    if (LIKELY(x <= u64(_db.ctype_n))) {
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FCtype* acr_ed::ctype_Last() {
    return ctype_Find(u64(_db.ctype_n-1));
}

// --- acr_ed.FDb.ctype.N
// Return number of items in the pool
inline i32 acr_ed::ctype_N() {
    return _db.ctype_n;
}

// --- acr_ed.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FCtype& acr_ed::ctype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- acr_ed.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- acr_ed.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 acr_ed::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- acr_ed.FDb.ssimfile.EmptyQ
// Return true if index is empty
inline bool acr_ed::ssimfile_EmptyQ() {
    return _db.ssimfile_n == 0;
}

// --- acr_ed.FDb.ssimfile.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FSsimfile* acr_ed::ssimfile_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FSsimfile *retval = NULL;
    if (LIKELY(x <= u64(_db.ssimfile_n))) {
        retval = &_db.ssimfile_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.ssimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FSsimfile* acr_ed::ssimfile_Last() {
    return ssimfile_Find(u64(_db.ssimfile_n-1));
}

// --- acr_ed.FDb.ssimfile.N
// Return number of items in the pool
inline i32 acr_ed::ssimfile_N() {
    return _db.ssimfile_n;
}

// --- acr_ed.FDb.ssimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FSsimfile& acr_ed::ssimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimfile_lary[bsr][index];
}

// --- acr_ed.FDb.ind_ssimfile.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_ssimfile_EmptyQ() {
    return _db.ind_ssimfile_n == 0;
}

// --- acr_ed.FDb.ind_ssimfile.N
// Return number of items in the hash
inline i32 acr_ed::ind_ssimfile_N() {
    return _db.ind_ssimfile_n;
}

// --- acr_ed.FDb.cstr.EmptyQ
// Return true if index is empty
inline bool acr_ed::cstr_EmptyQ() {
    return _db.cstr_n == 0;
}

// --- acr_ed.FDb.cstr.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCstr* acr_ed::cstr_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FCstr *retval = NULL;
    if (LIKELY(x <= u64(_db.cstr_n))) {
        retval = &_db.cstr_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.cstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FCstr* acr_ed::cstr_Last() {
    return cstr_Find(u64(_db.cstr_n-1));
}

// --- acr_ed.FDb.cstr.N
// Return number of items in the pool
inline i32 acr_ed::cstr_N() {
    return _db.cstr_n;
}

// --- acr_ed.FDb.cstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FCstr& acr_ed::cstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cstr_lary[bsr][index];
}

// --- acr_ed.FDb.vis.EmptyQ
// Return true if index is empty
inline bool acr_ed::vis_EmptyQ() {
    return _db.vis_n == 0;
}

// --- acr_ed.FDb.vis.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* acr_ed::vis_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.vis_n;
    if (idx >= lim) return NULL;
    return _db.vis_elems + idx;
}

// --- acr_ed.FDb.vis.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> acr_ed::vis_Getary() {
    return algo::aryptr<algo::cstring>(_db.vis_elems, _db.vis_n);
}

// --- acr_ed.FDb.vis.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* acr_ed::vis_Last() {
    return vis_Find(u64(_db.vis_n-1));
}

// --- acr_ed.FDb.vis.Max
// Return max. number of items in the array
inline i32 acr_ed::vis_Max() {
    return _db.vis_max;
}

// --- acr_ed.FDb.vis.N
// Return number of items in the array
inline i32 acr_ed::vis_N() {
    return _db.vis_n;
}

// --- acr_ed.FDb.vis.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void acr_ed::vis_Reserve(int n) {
    u32 new_n = _db.vis_n + n;
    if (UNLIKELY(new_n > _db.vis_max)) {
        vis_AbsReserve(new_n);
    }
}

// --- acr_ed.FDb.vis.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& acr_ed::vis_qFind(u64 t) {
    return _db.vis_elems[t];
}

// --- acr_ed.FDb.vis.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& acr_ed::vis_qLast() {
    return vis_qFind(u64(_db.vis_n-1));
}

// --- acr_ed.FDb.vis.rowid_Get
// Return row id of specified element
inline u64 acr_ed::vis_rowid_Get(algo::cstring &elem) {
    u64 id = &elem - _db.vis_elems;
    return u64(id);
}

// --- acr_ed.FDb.listtype.EmptyQ
// Return true if index is empty
inline bool acr_ed::listtype_EmptyQ() {
    return _db.listtype_n == 0;
}

// --- acr_ed.FDb.listtype.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FListtype* acr_ed::listtype_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FListtype *retval = NULL;
    if (LIKELY(x <= u64(_db.listtype_n))) {
        retval = &_db.listtype_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.listtype.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FListtype* acr_ed::listtype_Last() {
    return listtype_Find(u64(_db.listtype_n-1));
}

// --- acr_ed.FDb.listtype.N
// Return number of items in the pool
inline i32 acr_ed::listtype_N() {
    return _db.listtype_n;
}

// --- acr_ed.FDb.listtype.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FListtype& acr_ed::listtype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.listtype_lary[bsr][index];
}

// --- acr_ed.FDb.ind_listtype.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_listtype_EmptyQ() {
    return _db.ind_listtype_n == 0;
}

// --- acr_ed.FDb.ind_listtype.N
// Return number of items in the hash
inline i32 acr_ed::ind_listtype_N() {
    return _db.ind_listtype_n;
}

// --- acr_ed.FDb.fprefix.EmptyQ
// Return true if index is empty
inline bool acr_ed::fprefix_EmptyQ() {
    return _db.fprefix_n == 0;
}

// --- acr_ed.FDb.fprefix.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FFprefix* acr_ed::fprefix_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FFprefix *retval = NULL;
    if (LIKELY(x <= u64(_db.fprefix_n))) {
        retval = &_db.fprefix_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.fprefix.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FFprefix* acr_ed::fprefix_Last() {
    return fprefix_Find(u64(_db.fprefix_n-1));
}

// --- acr_ed.FDb.fprefix.N
// Return number of items in the pool
inline i32 acr_ed::fprefix_N() {
    return _db.fprefix_n;
}

// --- acr_ed.FDb.fprefix.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FFprefix& acr_ed::fprefix_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fprefix_lary[bsr][index];
}

// --- acr_ed.FDb.ind_fprefix.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_fprefix_EmptyQ() {
    return _db.ind_fprefix_n == 0;
}

// --- acr_ed.FDb.ind_fprefix.N
// Return number of items in the hash
inline i32 acr_ed::ind_fprefix_N() {
    return _db.ind_fprefix_n;
}

// --- acr_ed.FDb.target.EmptyQ
// Return true if index is empty
inline bool acr_ed::target_EmptyQ() {
    return _db.target_n == 0;
}

// --- acr_ed.FDb.target.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FTarget* acr_ed::target_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FTarget *retval = NULL;
    if (LIKELY(x <= u64(_db.target_n))) {
        retval = &_db.target_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.target.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FTarget* acr_ed::target_Last() {
    return target_Find(u64(_db.target_n-1));
}

// --- acr_ed.FDb.target.N
// Return number of items in the pool
inline i32 acr_ed::target_N() {
    return _db.target_n;
}

// --- acr_ed.FDb.target.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FTarget& acr_ed::target_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.target_lary[bsr][index];
}

// --- acr_ed.FDb.ind_target.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_target_EmptyQ() {
    return _db.ind_target_n == 0;
}

// --- acr_ed.FDb.ind_target.N
// Return number of items in the hash
inline i32 acr_ed::ind_target_N() {
    return _db.ind_target_n;
}

// --- acr_ed.FDb.targsrc.EmptyQ
// Return true if index is empty
inline bool acr_ed::targsrc_EmptyQ() {
    return _db.targsrc_n == 0;
}

// --- acr_ed.FDb.targsrc.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FTargsrc* acr_ed::targsrc_Find(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    acr_ed::FTargsrc *retval = NULL;
    if (LIKELY(x <= u64(_db.targsrc_n))) {
        retval = &_db.targsrc_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.targsrc.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FTargsrc* acr_ed::targsrc_Last() {
    return targsrc_Find(u64(_db.targsrc_n-1));
}

// --- acr_ed.FDb.targsrc.N
// Return number of items in the pool
inline i32 acr_ed::targsrc_N() {
    return _db.targsrc_n;
}

// --- acr_ed.FDb.targsrc.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FTargsrc& acr_ed::targsrc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targsrc_lary[bsr][index];
}

// --- acr_ed.FDb.ns_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_ns_curs_Reset(_db_ns_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.ns_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_ns_curs_ValidQ(_db_ns_curs &curs) {
    return curs.index < _db.ns_n;
}

// --- acr_ed.FDb.ns_curs.Next
// proceed to next item
inline void acr_ed::_db_ns_curs_Next(_db_ns_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.ns_curs.Access
// item access
inline acr_ed::FNs& acr_ed::_db_ns_curs_Access(_db_ns_curs &curs) {
    return ns_qFind(u64(curs.index));
}

// --- acr_ed.FDb.field_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_field_curs_Reset(_db_field_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- acr_ed.FDb.field_curs.Next
// proceed to next item
inline void acr_ed::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.field_curs.Access
// item access
inline acr_ed::FField& acr_ed::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u32(curs.index));
}

// --- acr_ed.FDb.ctype_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_ctype_curs_Reset(_db_ctype_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- acr_ed.FDb.ctype_curs.Next
// proceed to next item
inline void acr_ed::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.ctype_curs.Access
// item access
inline acr_ed::FCtype& acr_ed::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(u64(curs.index));
}

// --- acr_ed.FDb.ssimfile_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.ssimfile_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) {
    return curs.index < _db.ssimfile_n;
}

// --- acr_ed.FDb.ssimfile_curs.Next
// proceed to next item
inline void acr_ed::_db_ssimfile_curs_Next(_db_ssimfile_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.ssimfile_curs.Access
// item access
inline acr_ed::FSsimfile& acr_ed::_db_ssimfile_curs_Access(_db_ssimfile_curs &curs) {
    return ssimfile_qFind(u64(curs.index));
}

// --- acr_ed.FDb.cstr_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_cstr_curs_Reset(_db_cstr_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.cstr_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_cstr_curs_ValidQ(_db_cstr_curs &curs) {
    return curs.index < _db.cstr_n;
}

// --- acr_ed.FDb.cstr_curs.Next
// proceed to next item
inline void acr_ed::_db_cstr_curs_Next(_db_cstr_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.cstr_curs.Access
// item access
inline acr_ed::FCstr& acr_ed::_db_cstr_curs_Access(_db_cstr_curs &curs) {
    return cstr_qFind(u64(curs.index));
}

// --- acr_ed.FDb.vis_curs.Next
// proceed to next item
inline void acr_ed::_db_vis_curs_Next(_db_vis_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.vis_curs.Reset
inline void acr_ed::_db_vis_curs_Reset(_db_vis_curs &curs, acr_ed::FDb &parent) {
    curs.elems = parent.vis_elems;
    curs.n_elems = parent.vis_n;
    curs.index = 0;
}

// --- acr_ed.FDb.vis_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_vis_curs_ValidQ(_db_vis_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr_ed.FDb.vis_curs.Access
// item access
inline algo::cstring& acr_ed::_db_vis_curs_Access(_db_vis_curs &curs) {
    return curs.elems[curs.index];
}

// --- acr_ed.FDb.listtype_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_listtype_curs_Reset(_db_listtype_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.listtype_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_listtype_curs_ValidQ(_db_listtype_curs &curs) {
    return curs.index < _db.listtype_n;
}

// --- acr_ed.FDb.listtype_curs.Next
// proceed to next item
inline void acr_ed::_db_listtype_curs_Next(_db_listtype_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.listtype_curs.Access
// item access
inline acr_ed::FListtype& acr_ed::_db_listtype_curs_Access(_db_listtype_curs &curs) {
    return listtype_qFind(u64(curs.index));
}

// --- acr_ed.FDb.fprefix_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_fprefix_curs_Reset(_db_fprefix_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.fprefix_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_fprefix_curs_ValidQ(_db_fprefix_curs &curs) {
    return curs.index < _db.fprefix_n;
}

// --- acr_ed.FDb.fprefix_curs.Next
// proceed to next item
inline void acr_ed::_db_fprefix_curs_Next(_db_fprefix_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.fprefix_curs.Access
// item access
inline acr_ed::FFprefix& acr_ed::_db_fprefix_curs_Access(_db_fprefix_curs &curs) {
    return fprefix_qFind(u64(curs.index));
}

// --- acr_ed.FDb.target_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_target_curs_Reset(_db_target_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.target_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_target_curs_ValidQ(_db_target_curs &curs) {
    return curs.index < _db.target_n;
}

// --- acr_ed.FDb.target_curs.Next
// proceed to next item
inline void acr_ed::_db_target_curs_Next(_db_target_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.target_curs.Access
// item access
inline acr_ed::FTarget& acr_ed::_db_target_curs_Access(_db_target_curs &curs) {
    return target_qFind(u64(curs.index));
}

// --- acr_ed.FDb.targsrc_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_targsrc_curs_Reset(_db_targsrc_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.targsrc_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_targsrc_curs_ValidQ(_db_targsrc_curs &curs) {
    return curs.index < _db.targsrc_n;
}

// --- acr_ed.FDb.targsrc_curs.Next
// proceed to next item
inline void acr_ed::_db_targsrc_curs_Next(_db_targsrc_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.targsrc_curs.Access
// item access
inline acr_ed::FTargsrc& acr_ed::_db_targsrc_curs_Access(_db_targsrc_curs &curs) {
    return targsrc_qFind(u64(curs.index));
}
inline acr_ed::FField::FField() {
    acr_ed::FField_Init(*this);
}

inline acr_ed::FField::~FField() {
    acr_ed::FField_Uninit(*this);
}

inline acr_ed::FFprefix::FFprefix() {
    acr_ed::FFprefix_Init(*this);
}

inline acr_ed::FFprefix::~FFprefix() {
    acr_ed::FFprefix_Uninit(*this);
}


// --- acr_ed.FFprefix..Init
// Set all fields to initial values.
inline void acr_ed::FFprefix_Init(acr_ed::FFprefix& fprefix) {
    fprefix.ind_fprefix_next = (acr_ed::FFprefix*)-1; // (acr_ed.FDb.ind_fprefix) not-in-hash
}
inline acr_ed::FListtype::FListtype() {
    acr_ed::FListtype_Init(*this);
}

inline acr_ed::FListtype::~FListtype() {
    acr_ed::FListtype_Uninit(*this);
}


// --- acr_ed.FListtype..Init
// Set all fields to initial values.
inline void acr_ed::FListtype_Init(acr_ed::FListtype& listtype) {
    listtype.circular = bool(false);
    listtype.haveprev = bool(false);
    listtype.instail = bool(false);
    listtype.ind_listtype_next = (acr_ed::FListtype*)-1; // (acr_ed.FDb.ind_listtype) not-in-hash
}
inline acr_ed::FNs::FNs() {
    acr_ed::FNs_Init(*this);
}

inline acr_ed::FNs::~FNs() {
    acr_ed::FNs_Uninit(*this);
}


// --- acr_ed.FNs..Init
// Set all fields to initial values.
inline void acr_ed::FNs_Init(acr_ed::FNs& ns) {
    ns.ind_ns_next = (acr_ed::FNs*)-1; // (acr_ed.FDb.ind_ns) not-in-hash
}
inline acr_ed::FSsimfile::FSsimfile() {
    acr_ed::FSsimfile_Init(*this);
}

inline acr_ed::FSsimfile::~FSsimfile() {
    acr_ed::FSsimfile_Uninit(*this);
}


// --- acr_ed.FSsimfile..Init
// Set all fields to initial values.
inline void acr_ed::FSsimfile_Init(acr_ed::FSsimfile& ssimfile) {
    ssimfile.p_ctype = NULL;
    ssimfile.ind_ssimfile_next = (acr_ed::FSsimfile*)-1; // (acr_ed.FDb.ind_ssimfile) not-in-hash
}
inline acr_ed::FTarget::FTarget() {
    acr_ed::FTarget_Init(*this);
}

inline acr_ed::FTarget::~FTarget() {
    acr_ed::FTarget_Uninit(*this);
}


// --- acr_ed.FTarget..Init
// Set all fields to initial values.
inline void acr_ed::FTarget_Init(acr_ed::FTarget& target) {
    target.score = u32(0);
    target.ind_target_next = (acr_ed::FTarget*)-1; // (acr_ed.FDb.ind_target) not-in-hash
}
inline acr_ed::FTargsrc::FTargsrc() {
    acr_ed::FTargsrc_Init(*this);
}


// --- acr_ed.FTargsrc..Init
// Set all fields to initial values.
inline void acr_ed::FTargsrc_Init(acr_ed::FTargsrc& targsrc) {
    targsrc.p_target = NULL;
}
inline acr_ed::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline acr_ed::FieldId::FieldId(acr_ed_FieldIdEnum arg) { this->value = i32(arg); }
inline acr_ed::FieldId::FieldId() {
    acr_ed::FieldId_Init(*this);
}


// --- acr_ed.FieldId.value.GetEnum
// Get value of field as enum type
inline acr_ed_FieldIdEnum acr_ed::value_GetEnum(const acr_ed::FieldId& parent) {
    return acr_ed_FieldIdEnum(parent.value);
}

// --- acr_ed.FieldId.value.SetEnum
// Set value of field from enum type.
inline void acr_ed::value_SetEnum(acr_ed::FieldId& parent, acr_ed_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr_ed.FieldId.value.Cast
inline acr_ed::FieldId::operator acr_ed_FieldIdEnum () const {
    return acr_ed_FieldIdEnum((*this).value);
}

// --- acr_ed.FieldId..Init
// Set all fields to initial values.
inline void acr_ed::FieldId_Init(acr_ed::FieldId& parent) {
    parent.value = i32(-1);
}
inline acr_ed::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline acr_ed::TableId::TableId(acr_ed_TableIdEnum arg) { this->value = i32(arg); }
inline acr_ed::TableId::TableId() {
    acr_ed::TableId_Init(*this);
}


// --- acr_ed.TableId.value.GetEnum
// Get value of field as enum type
inline acr_ed_TableIdEnum acr_ed::value_GetEnum(const acr_ed::TableId& parent) {
    return acr_ed_TableIdEnum(parent.value);
}

// --- acr_ed.TableId.value.SetEnum
// Set value of field from enum type.
inline void acr_ed::value_SetEnum(acr_ed::TableId& parent, acr_ed_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr_ed.TableId.value.Cast
inline acr_ed::TableId::operator acr_ed_TableIdEnum () const {
    return acr_ed_TableIdEnum((*this).value);
}

// --- acr_ed.TableId..Init
// Set all fields to initial values.
inline void acr_ed::TableId_Init(acr_ed::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_ed::trace &row) {// cfmt:acr_ed.trace.String
    acr_ed::trace_Print(const_cast<acr_ed::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_ed::FieldId &row) {// cfmt:acr_ed.FieldId.String
    acr_ed::FieldId_Print(const_cast<acr_ed::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_ed::TableId &row) {// cfmt:acr_ed.TableId.String
    acr_ed::TableId_Print(const_cast<acr_ed::TableId&>(row), str);
    return str;
}
