//
// include/gen/acr_ed_gen.inl.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.inl.h"
//#pragma endinclude
inline acr_ed::FCfmt::FCfmt() {
    acr_ed::FCfmt_Init(*this);
}

inline acr_ed::FCfmt::~FCfmt() {
    acr_ed::FCfmt_Uninit(*this);
}


// --- acr_ed.FCfmt..Init
// Set all fields to initial values.
inline void acr_ed::FCfmt_Init(acr_ed::FCfmt& cfmt) {
    cfmt.read = bool(false);
    cfmt.print = bool(false);
    cfmt.genop = bool(false);
}
inline acr_ed::FCpptype::FCpptype() {
    acr_ed::FCpptype_Init(*this);
}

inline acr_ed::FCpptype::~FCpptype() {
    acr_ed::FCpptype_Uninit(*this);
}


// --- acr_ed.FCpptype..Init
// Set all fields to initial values.
inline void acr_ed::FCpptype_Init(acr_ed::FCpptype& cpptype) {
    cpptype.ctor = bool(false);
    cpptype.dtor = bool(true);
    cpptype.cheap_copy = bool(false);
}
inline acr_ed::FCstr::FCstr() {
    acr_ed::FCstr_Init(*this);
}

inline acr_ed::FCstr::~FCstr() {
    acr_ed::FCstr_Uninit(*this);
}


// --- acr_ed.FCstr..Init
// Set all fields to initial values.
inline void acr_ed::FCstr_Init(acr_ed::FCstr& cstr) {
    cstr.strequiv = bool(false);
}
inline acr_ed::FCtype::FCtype() {
    acr_ed::FCtype_Init(*this);
}

inline acr_ed::FCtype::~FCtype() {
    acr_ed::FCtype_Uninit(*this);
}


// --- acr_ed.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool acr_ed::c_field_EmptyQ(acr_ed::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- acr_ed.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FField* acr_ed::c_field_Find(acr_ed::FCtype& ctype, u32 t) {
    acr_ed::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- acr_ed.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<acr_ed::FField*> acr_ed::c_field_Getary(acr_ed::FCtype& ctype) {
    return algo::aryptr<acr_ed::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- acr_ed.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 acr_ed::c_field_N(const acr_ed::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- acr_ed.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr_ed::c_field_RemoveAll(acr_ed::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_elems[i]->ctype_c_field_in_ary = false;
    }
    ctype.c_field_n = 0;
}

// --- acr_ed.FCtype.c_cstr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_cstr_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCstr& row) {
    acr_ed::FCstr* ptr = ctype.c_cstr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cstr = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_cstr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_cstr_Remove(acr_ed::FCtype& ctype, acr_ed::FCstr& row) {
    acr_ed::FCstr *ptr = ctype.c_cstr;
    if (LIKELY(ptr == &row)) {
        ctype.c_cstr = NULL;
    }
}

// --- acr_ed.FCtype.c_ssimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_ssimfile_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) {
    acr_ed::FSsimfile* ptr = ctype.c_ssimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ssimfile = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_ssimfile_Remove(acr_ed::FCtype& ctype, acr_ed::FSsimfile& row) {
    acr_ed::FSsimfile *ptr = ctype.c_ssimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_ssimfile = NULL;
    }
}

// --- acr_ed.FCtype.c_pack.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_pack_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FPack& row) {
    acr_ed::FPack* ptr = ctype.c_pack;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_pack = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_pack.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_pack_Remove(acr_ed::FCtype& ctype, acr_ed::FPack& row) {
    acr_ed::FPack *ptr = ctype.c_pack;
    if (LIKELY(ptr == &row)) {
        ctype.c_pack = NULL;
    }
}

// --- acr_ed.FCtype.c_typefld.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_typefld_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FTypefld& row) {
    acr_ed::FTypefld* ptr = ctype.c_typefld;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_typefld = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_typefld.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_typefld_Remove(acr_ed::FCtype& ctype, acr_ed::FTypefld& row) {
    acr_ed::FTypefld *ptr = ctype.c_typefld;
    if (LIKELY(ptr == &row)) {
        ctype.c_typefld = NULL;
    }
}

// --- acr_ed.FCtype.c_cpptype.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool acr_ed::c_cpptype_InsertMaybe(acr_ed::FCtype& ctype, acr_ed::FCpptype& row) {
    acr_ed::FCpptype* ptr = ctype.c_cpptype;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_cpptype = &row;
    }
    return retval;
}

// --- acr_ed.FCtype.c_cpptype.Remove
// Remove element from index. If element is not in index, do nothing.
inline void acr_ed::c_cpptype_Remove(acr_ed::FCtype& ctype, acr_ed::FCpptype& row) {
    acr_ed::FCpptype *ptr = ctype.c_cpptype;
    if (LIKELY(ptr == &row)) {
        ctype.c_cpptype = NULL;
    }
}

// --- acr_ed.FCtype.c_cfmt.EmptyQ
// Return true if index is empty
inline bool acr_ed::c_cfmt_EmptyQ(acr_ed::FCtype& ctype) {
    return ctype.c_cfmt_n == 0;
}

// --- acr_ed.FCtype.c_cfmt.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCfmt* acr_ed::c_cfmt_Find(acr_ed::FCtype& ctype, u32 t) {
    acr_ed::FCfmt *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_cfmt_n;
    if (idx < lim) {
        retval = ctype.c_cfmt_elems[idx];
    }
    return retval;
}

// --- acr_ed.FCtype.c_cfmt.Getary
// Return array of pointers
inline algo::aryptr<acr_ed::FCfmt*> acr_ed::c_cfmt_Getary(acr_ed::FCtype& ctype) {
    return algo::aryptr<acr_ed::FCfmt*>(ctype.c_cfmt_elems, ctype.c_cfmt_n);
}

// --- acr_ed.FCtype.c_cfmt.N
// Return number of items in the pointer array
inline i32 acr_ed::c_cfmt_N(const acr_ed::FCtype& ctype) {
    return ctype.c_cfmt_n;
}

// --- acr_ed.FCtype.c_cfmt.RemoveAll
// Empty the index. (The rows are not deleted)
inline void acr_ed::c_cfmt_RemoveAll(acr_ed::FCtype& ctype) {
    ctype.c_cfmt_n = 0;
}

// --- acr_ed.FCtype.c_field_curs.Reset
inline void acr_ed::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, acr_ed::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- acr_ed.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr_ed.FCtype.c_field_curs.Next
// proceed to next item
inline void acr_ed::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- acr_ed.FCtype.c_field_curs.Access
// item access
inline acr_ed::FField& acr_ed::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- acr_ed.FCtype.c_cfmt_curs.Reset
inline void acr_ed::ctype_c_cfmt_curs_Reset(ctype_c_cfmt_curs &curs, acr_ed::FCtype &parent) {
    curs.elems = parent.c_cfmt_elems;
    curs.n_elems = parent.c_cfmt_n;
    curs.index = 0;
}

// --- acr_ed.FCtype.c_cfmt_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::ctype_c_cfmt_curs_ValidQ(ctype_c_cfmt_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr_ed.FCtype.c_cfmt_curs.Next
// proceed to next item
inline void acr_ed::ctype_c_cfmt_curs_Next(ctype_c_cfmt_curs &curs) {
    curs.index++;
}

// --- acr_ed.FCtype.c_cfmt_curs.Access
// item access
inline acr_ed::FCfmt& acr_ed::ctype_c_cfmt_curs_Access(ctype_c_cfmt_curs &curs) {
    return *curs.elems[curs.index];
}
inline acr_ed::trace::trace() {
}


// --- acr_ed.FDb.ns.EmptyQ
// Return true if index is empty
inline bool acr_ed::ns_EmptyQ() {
    return _db.ns_n == 0;
}

// --- acr_ed.FDb.ns.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FNs* acr_ed::ns_Find(u64 t) {
    acr_ed::FNs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ns_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ns_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.ns.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FNs* acr_ed::ns_Last() {
    return ns_Find(u64(_db.ns_n-1));
}

// --- acr_ed.FDb.ns.N
// Return number of items in the pool
inline i32 acr_ed::ns_N() {
    return _db.ns_n;
}

// --- acr_ed.FDb.ns.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FNs& acr_ed::ns_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ns_lary[bsr][index];
}

// --- acr_ed.FDb.ind_ns.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_ns_EmptyQ() {
    return _db.ind_ns_n == 0;
}

// --- acr_ed.FDb.ind_ns.N
// Return number of items in the hash
inline i32 acr_ed::ind_ns_N() {
    return _db.ind_ns_n;
}

// --- acr_ed.FDb.field.EmptyQ
// Return true if index is empty
inline bool acr_ed::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- acr_ed.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FField* acr_ed::field_Find(u32 t) {
    acr_ed::FField *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.field_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FField* acr_ed::field_Last() {
    return field_Find(u32(_db.field_n-1));
}

// --- acr_ed.FDb.field.N
// Return number of items in the pool
inline i32 acr_ed::field_N() {
    return _db.field_n;
}

// --- acr_ed.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FField& acr_ed::field_qFind(u32 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- acr_ed.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- acr_ed.FDb.ind_field.N
// Return number of items in the hash
inline i32 acr_ed::ind_field_N() {
    return _db.ind_field_n;
}

// --- acr_ed.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool acr_ed::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- acr_ed.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCtype* acr_ed::ctype_Find(u64 t) {
    acr_ed::FCtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ctype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FCtype* acr_ed::ctype_Last() {
    return ctype_Find(u64(_db.ctype_n-1));
}

// --- acr_ed.FDb.ctype.N
// Return number of items in the pool
inline i32 acr_ed::ctype_N() {
    return _db.ctype_n;
}

// --- acr_ed.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FCtype& acr_ed::ctype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- acr_ed.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- acr_ed.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 acr_ed::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- acr_ed.FDb.ssimfile.EmptyQ
// Return true if index is empty
inline bool acr_ed::ssimfile_EmptyQ() {
    return _db.ssimfile_n == 0;
}

// --- acr_ed.FDb.ssimfile.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FSsimfile* acr_ed::ssimfile_Find(u64 t) {
    acr_ed::FSsimfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ssimfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ssimfile_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.ssimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FSsimfile* acr_ed::ssimfile_Last() {
    return ssimfile_Find(u64(_db.ssimfile_n-1));
}

// --- acr_ed.FDb.ssimfile.N
// Return number of items in the pool
inline i32 acr_ed::ssimfile_N() {
    return _db.ssimfile_n;
}

// --- acr_ed.FDb.ssimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FSsimfile& acr_ed::ssimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimfile_lary[bsr][index];
}

// --- acr_ed.FDb.ind_ssimfile.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_ssimfile_EmptyQ() {
    return _db.ind_ssimfile_n == 0;
}

// --- acr_ed.FDb.ind_ssimfile.N
// Return number of items in the hash
inline i32 acr_ed::ind_ssimfile_N() {
    return _db.ind_ssimfile_n;
}

// --- acr_ed.FDb.cstr.EmptyQ
// Return true if index is empty
inline bool acr_ed::cstr_EmptyQ() {
    return _db.cstr_n == 0;
}

// --- acr_ed.FDb.cstr.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCstr* acr_ed::cstr_Find(u64 t) {
    acr_ed::FCstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cstr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cstr_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.cstr.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FCstr* acr_ed::cstr_Last() {
    return cstr_Find(u64(_db.cstr_n-1));
}

// --- acr_ed.FDb.cstr.N
// Return number of items in the pool
inline i32 acr_ed::cstr_N() {
    return _db.cstr_n;
}

// --- acr_ed.FDb.cstr.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FCstr& acr_ed::cstr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cstr_lary[bsr][index];
}

// --- acr_ed.FDb.vis.EmptyQ
// Return true if index is empty
inline bool acr_ed::vis_EmptyQ() {
    return _db.vis_n == 0;
}

// --- acr_ed.FDb.vis.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* acr_ed::vis_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.vis_n;
    if (idx >= lim) return NULL;
    return _db.vis_elems + idx;
}

// --- acr_ed.FDb.vis.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> acr_ed::vis_Getary() {
    return algo::aryptr<algo::cstring>(_db.vis_elems, _db.vis_n);
}

// --- acr_ed.FDb.vis.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* acr_ed::vis_Last() {
    return vis_Find(u64(_db.vis_n-1));
}

// --- acr_ed.FDb.vis.Max
// Return max. number of items in the array
inline i32 acr_ed::vis_Max() {
    return _db.vis_max;
}

// --- acr_ed.FDb.vis.N
// Return number of items in the array
inline i32 acr_ed::vis_N() {
    return _db.vis_n;
}

// --- acr_ed.FDb.vis.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void acr_ed::vis_Reserve(int n) {
    u32 new_n = _db.vis_n + n;
    if (UNLIKELY(new_n > _db.vis_max)) {
        vis_AbsReserve(new_n);
    }
}

// --- acr_ed.FDb.vis.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& acr_ed::vis_qFind(u64 t) {
    return _db.vis_elems[t];
}

// --- acr_ed.FDb.vis.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& acr_ed::vis_qLast() {
    return vis_qFind(u64(_db.vis_n-1));
}

// --- acr_ed.FDb.vis.rowid_Get
// Return row id of specified element
inline u64 acr_ed::vis_rowid_Get(algo::cstring &elem) {
    u64 id = &elem - _db.vis_elems;
    return u64(id);
}

// --- acr_ed.FDb.listtype.EmptyQ
// Return true if index is empty
inline bool acr_ed::listtype_EmptyQ() {
    return _db.listtype_n == 0;
}

// --- acr_ed.FDb.listtype.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FListtype* acr_ed::listtype_Find(u64 t) {
    acr_ed::FListtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.listtype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.listtype_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.listtype.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FListtype* acr_ed::listtype_Last() {
    return listtype_Find(u64(_db.listtype_n-1));
}

// --- acr_ed.FDb.listtype.N
// Return number of items in the pool
inline i32 acr_ed::listtype_N() {
    return _db.listtype_n;
}

// --- acr_ed.FDb.listtype.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FListtype& acr_ed::listtype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.listtype_lary[bsr][index];
}

// --- acr_ed.FDb.ind_listtype.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_listtype_EmptyQ() {
    return _db.ind_listtype_n == 0;
}

// --- acr_ed.FDb.ind_listtype.N
// Return number of items in the hash
inline i32 acr_ed::ind_listtype_N() {
    return _db.ind_listtype_n;
}

// --- acr_ed.FDb.fprefix.EmptyQ
// Return true if index is empty
inline bool acr_ed::fprefix_EmptyQ() {
    return _db.fprefix_n == 0;
}

// --- acr_ed.FDb.fprefix.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FFprefix* acr_ed::fprefix_Find(u64 t) {
    acr_ed::FFprefix *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fprefix_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fprefix_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.fprefix.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FFprefix* acr_ed::fprefix_Last() {
    return fprefix_Find(u64(_db.fprefix_n-1));
}

// --- acr_ed.FDb.fprefix.N
// Return number of items in the pool
inline i32 acr_ed::fprefix_N() {
    return _db.fprefix_n;
}

// --- acr_ed.FDb.fprefix.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FFprefix& acr_ed::fprefix_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fprefix_lary[bsr][index];
}

// --- acr_ed.FDb.ind_fprefix.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_fprefix_EmptyQ() {
    return _db.ind_fprefix_n == 0;
}

// --- acr_ed.FDb.ind_fprefix.N
// Return number of items in the hash
inline i32 acr_ed::ind_fprefix_N() {
    return _db.ind_fprefix_n;
}

// --- acr_ed.FDb.target.EmptyQ
// Return true if index is empty
inline bool acr_ed::target_EmptyQ() {
    return _db.target_n == 0;
}

// --- acr_ed.FDb.target.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FTarget* acr_ed::target_Find(u64 t) {
    acr_ed::FTarget *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.target_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.target_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.target.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FTarget* acr_ed::target_Last() {
    return target_Find(u64(_db.target_n-1));
}

// --- acr_ed.FDb.target.N
// Return number of items in the pool
inline i32 acr_ed::target_N() {
    return _db.target_n;
}

// --- acr_ed.FDb.target.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FTarget& acr_ed::target_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.target_lary[bsr][index];
}

// --- acr_ed.FDb.ind_target.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_target_EmptyQ() {
    return _db.ind_target_n == 0;
}

// --- acr_ed.FDb.ind_target.N
// Return number of items in the hash
inline i32 acr_ed::ind_target_N() {
    return _db.ind_target_n;
}

// --- acr_ed.FDb.targsrc.EmptyQ
// Return true if index is empty
inline bool acr_ed::targsrc_EmptyQ() {
    return _db.targsrc_n == 0;
}

// --- acr_ed.FDb.targsrc.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FTargsrc* acr_ed::targsrc_Find(u64 t) {
    acr_ed::FTargsrc *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.targsrc_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.targsrc_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.targsrc.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FTargsrc* acr_ed::targsrc_Last() {
    return targsrc_Find(u64(_db.targsrc_n-1));
}

// --- acr_ed.FDb.targsrc.N
// Return number of items in the pool
inline i32 acr_ed::targsrc_N() {
    return _db.targsrc_n;
}

// --- acr_ed.FDb.targsrc.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FTargsrc& acr_ed::targsrc_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.targsrc_lary[bsr][index];
}

// --- acr_ed.FDb.sandbox.EmptyQ
// Return true if index is empty
inline bool acr_ed::sandbox_EmptyQ() {
    return _db.sandbox_n == 0;
}

// --- acr_ed.FDb.sandbox.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FSandbox* acr_ed::sandbox_Find(u64 t) {
    acr_ed::FSandbox *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.sandbox_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.sandbox_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.sandbox.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FSandbox* acr_ed::sandbox_Last() {
    return sandbox_Find(u64(_db.sandbox_n-1));
}

// --- acr_ed.FDb.sandbox.N
// Return number of items in the pool
inline i32 acr_ed::sandbox_N() {
    return _db.sandbox_n;
}

// --- acr_ed.FDb.sandbox.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FSandbox& acr_ed::sandbox_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.sandbox_lary[bsr][index];
}

// --- acr_ed.FDb.pack.EmptyQ
// Return true if index is empty
inline bool acr_ed::pack_EmptyQ() {
    return _db.pack_n == 0;
}

// --- acr_ed.FDb.pack.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FPack* acr_ed::pack_Find(u64 t) {
    acr_ed::FPack *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.pack_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.pack_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.pack.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FPack* acr_ed::pack_Last() {
    return pack_Find(u64(_db.pack_n-1));
}

// --- acr_ed.FDb.pack.N
// Return number of items in the pool
inline i32 acr_ed::pack_N() {
    return _db.pack_n;
}

// --- acr_ed.FDb.pack.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FPack& acr_ed::pack_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.pack_lary[bsr][index];
}

// --- acr_ed.FDb.typefld.EmptyQ
// Return true if index is empty
inline bool acr_ed::typefld_EmptyQ() {
    return _db.typefld_n == 0;
}

// --- acr_ed.FDb.typefld.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FTypefld* acr_ed::typefld_Find(u64 t) {
    acr_ed::FTypefld *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.typefld_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.typefld_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.typefld.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FTypefld* acr_ed::typefld_Last() {
    return typefld_Find(u64(_db.typefld_n-1));
}

// --- acr_ed.FDb.typefld.N
// Return number of items in the pool
inline i32 acr_ed::typefld_N() {
    return _db.typefld_n;
}

// --- acr_ed.FDb.typefld.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FTypefld& acr_ed::typefld_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.typefld_lary[bsr][index];
}

// --- acr_ed.FDb.cpptype.EmptyQ
// Return true if index is empty
inline bool acr_ed::cpptype_EmptyQ() {
    return _db.cpptype_n == 0;
}

// --- acr_ed.FDb.cpptype.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCpptype* acr_ed::cpptype_Find(u64 t) {
    acr_ed::FCpptype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cpptype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cpptype_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.cpptype.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FCpptype* acr_ed::cpptype_Last() {
    return cpptype_Find(u64(_db.cpptype_n-1));
}

// --- acr_ed.FDb.cpptype.N
// Return number of items in the pool
inline i32 acr_ed::cpptype_N() {
    return _db.cpptype_n;
}

// --- acr_ed.FDb.cpptype.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FCpptype& acr_ed::cpptype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cpptype_lary[bsr][index];
}

// --- acr_ed.FDb.cfmt.EmptyQ
// Return true if index is empty
inline bool acr_ed::cfmt_EmptyQ() {
    return _db.cfmt_n == 0;
}

// --- acr_ed.FDb.cfmt.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FCfmt* acr_ed::cfmt_Find(u64 t) {
    acr_ed::FCfmt *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.cfmt_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.cfmt_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.cfmt.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FCfmt* acr_ed::cfmt_Last() {
    return cfmt_Find(u64(_db.cfmt_n-1));
}

// --- acr_ed.FDb.cfmt.N
// Return number of items in the pool
inline i32 acr_ed::cfmt_N() {
    return _db.cfmt_n;
}

// --- acr_ed.FDb.cfmt.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FCfmt& acr_ed::cfmt_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.cfmt_lary[bsr][index];
}

// --- acr_ed.FDb.nsdb.EmptyQ
// Return true if index is empty
inline bool acr_ed::nsdb_EmptyQ() {
    return _db.nsdb_n == 0;
}

// --- acr_ed.FDb.nsdb.Find
// Look up row by row id. Return NULL if out of range
inline acr_ed::FNsdb* acr_ed::nsdb_Find(u64 t) {
    acr_ed::FNsdb *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.nsdb_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.nsdb_lary[bsr][index];
    }
    return retval;
}

// --- acr_ed.FDb.nsdb.Last
// Return pointer to last element of array, or NULL if array is empty
inline acr_ed::FNsdb* acr_ed::nsdb_Last() {
    return nsdb_Find(u64(_db.nsdb_n-1));
}

// --- acr_ed.FDb.nsdb.N
// Return number of items in the pool
inline i32 acr_ed::nsdb_N() {
    return _db.nsdb_n;
}

// --- acr_ed.FDb.nsdb.qFind
// 'quick' Access row by row id. No bounds checking.
inline acr_ed::FNsdb& acr_ed::nsdb_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.nsdb_lary[bsr][index];
}

// --- acr_ed.FDb.ind_nsdb.EmptyQ
// Return true if hash is empty
inline bool acr_ed::ind_nsdb_EmptyQ() {
    return _db.ind_nsdb_n == 0;
}

// --- acr_ed.FDb.ind_nsdb.N
// Return number of items in the hash
inline i32 acr_ed::ind_nsdb_N() {
    return _db.ind_nsdb_n;
}

// --- acr_ed.FDb.ns_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_ns_curs_Reset(_db_ns_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.ns_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_ns_curs_ValidQ(_db_ns_curs &curs) {
    return curs.index < _db.ns_n;
}

// --- acr_ed.FDb.ns_curs.Next
// proceed to next item
inline void acr_ed::_db_ns_curs_Next(_db_ns_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.ns_curs.Access
// item access
inline acr_ed::FNs& acr_ed::_db_ns_curs_Access(_db_ns_curs &curs) {
    return ns_qFind(u64(curs.index));
}

// --- acr_ed.FDb.field_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_field_curs_Reset(_db_field_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- acr_ed.FDb.field_curs.Next
// proceed to next item
inline void acr_ed::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.field_curs.Access
// item access
inline acr_ed::FField& acr_ed::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u32(curs.index));
}

// --- acr_ed.FDb.ctype_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_ctype_curs_Reset(_db_ctype_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- acr_ed.FDb.ctype_curs.Next
// proceed to next item
inline void acr_ed::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.ctype_curs.Access
// item access
inline acr_ed::FCtype& acr_ed::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(u64(curs.index));
}

// --- acr_ed.FDb.ssimfile_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.ssimfile_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) {
    return curs.index < _db.ssimfile_n;
}

// --- acr_ed.FDb.ssimfile_curs.Next
// proceed to next item
inline void acr_ed::_db_ssimfile_curs_Next(_db_ssimfile_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.ssimfile_curs.Access
// item access
inline acr_ed::FSsimfile& acr_ed::_db_ssimfile_curs_Access(_db_ssimfile_curs &curs) {
    return ssimfile_qFind(u64(curs.index));
}

// --- acr_ed.FDb.cstr_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_cstr_curs_Reset(_db_cstr_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.cstr_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_cstr_curs_ValidQ(_db_cstr_curs &curs) {
    return curs.index < _db.cstr_n;
}

// --- acr_ed.FDb.cstr_curs.Next
// proceed to next item
inline void acr_ed::_db_cstr_curs_Next(_db_cstr_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.cstr_curs.Access
// item access
inline acr_ed::FCstr& acr_ed::_db_cstr_curs_Access(_db_cstr_curs &curs) {
    return cstr_qFind(u64(curs.index));
}

// --- acr_ed.FDb.vis_curs.Next
// proceed to next item
inline void acr_ed::_db_vis_curs_Next(_db_vis_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.vis_curs.Reset
inline void acr_ed::_db_vis_curs_Reset(_db_vis_curs &curs, acr_ed::FDb &parent) {
    curs.elems = parent.vis_elems;
    curs.n_elems = parent.vis_n;
    curs.index = 0;
}

// --- acr_ed.FDb.vis_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_vis_curs_ValidQ(_db_vis_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- acr_ed.FDb.vis_curs.Access
// item access
inline algo::cstring& acr_ed::_db_vis_curs_Access(_db_vis_curs &curs) {
    return curs.elems[curs.index];
}

// --- acr_ed.FDb.listtype_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_listtype_curs_Reset(_db_listtype_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.listtype_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_listtype_curs_ValidQ(_db_listtype_curs &curs) {
    return curs.index < _db.listtype_n;
}

// --- acr_ed.FDb.listtype_curs.Next
// proceed to next item
inline void acr_ed::_db_listtype_curs_Next(_db_listtype_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.listtype_curs.Access
// item access
inline acr_ed::FListtype& acr_ed::_db_listtype_curs_Access(_db_listtype_curs &curs) {
    return listtype_qFind(u64(curs.index));
}

// --- acr_ed.FDb.fprefix_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_fprefix_curs_Reset(_db_fprefix_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.fprefix_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_fprefix_curs_ValidQ(_db_fprefix_curs &curs) {
    return curs.index < _db.fprefix_n;
}

// --- acr_ed.FDb.fprefix_curs.Next
// proceed to next item
inline void acr_ed::_db_fprefix_curs_Next(_db_fprefix_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.fprefix_curs.Access
// item access
inline acr_ed::FFprefix& acr_ed::_db_fprefix_curs_Access(_db_fprefix_curs &curs) {
    return fprefix_qFind(u64(curs.index));
}

// --- acr_ed.FDb.target_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_target_curs_Reset(_db_target_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.target_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_target_curs_ValidQ(_db_target_curs &curs) {
    return curs.index < _db.target_n;
}

// --- acr_ed.FDb.target_curs.Next
// proceed to next item
inline void acr_ed::_db_target_curs_Next(_db_target_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.target_curs.Access
// item access
inline acr_ed::FTarget& acr_ed::_db_target_curs_Access(_db_target_curs &curs) {
    return target_qFind(u64(curs.index));
}

// --- acr_ed.FDb.targsrc_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_targsrc_curs_Reset(_db_targsrc_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.targsrc_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_targsrc_curs_ValidQ(_db_targsrc_curs &curs) {
    return curs.index < _db.targsrc_n;
}

// --- acr_ed.FDb.targsrc_curs.Next
// proceed to next item
inline void acr_ed::_db_targsrc_curs_Next(_db_targsrc_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.targsrc_curs.Access
// item access
inline acr_ed::FTargsrc& acr_ed::_db_targsrc_curs_Access(_db_targsrc_curs &curs) {
    return targsrc_qFind(u64(curs.index));
}

// --- acr_ed.FDb.sandbox_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_sandbox_curs_Reset(_db_sandbox_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.sandbox_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_sandbox_curs_ValidQ(_db_sandbox_curs &curs) {
    return curs.index < _db.sandbox_n;
}

// --- acr_ed.FDb.sandbox_curs.Next
// proceed to next item
inline void acr_ed::_db_sandbox_curs_Next(_db_sandbox_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.sandbox_curs.Access
// item access
inline acr_ed::FSandbox& acr_ed::_db_sandbox_curs_Access(_db_sandbox_curs &curs) {
    return sandbox_qFind(u64(curs.index));
}

// --- acr_ed.FDb.pack_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_pack_curs_Reset(_db_pack_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.pack_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_pack_curs_ValidQ(_db_pack_curs &curs) {
    return curs.index < _db.pack_n;
}

// --- acr_ed.FDb.pack_curs.Next
// proceed to next item
inline void acr_ed::_db_pack_curs_Next(_db_pack_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.pack_curs.Access
// item access
inline acr_ed::FPack& acr_ed::_db_pack_curs_Access(_db_pack_curs &curs) {
    return pack_qFind(u64(curs.index));
}

// --- acr_ed.FDb.typefld_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_typefld_curs_Reset(_db_typefld_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.typefld_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_typefld_curs_ValidQ(_db_typefld_curs &curs) {
    return curs.index < _db.typefld_n;
}

// --- acr_ed.FDb.typefld_curs.Next
// proceed to next item
inline void acr_ed::_db_typefld_curs_Next(_db_typefld_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.typefld_curs.Access
// item access
inline acr_ed::FTypefld& acr_ed::_db_typefld_curs_Access(_db_typefld_curs &curs) {
    return typefld_qFind(u64(curs.index));
}

// --- acr_ed.FDb.cpptype_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_cpptype_curs_Reset(_db_cpptype_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.cpptype_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_cpptype_curs_ValidQ(_db_cpptype_curs &curs) {
    return curs.index < _db.cpptype_n;
}

// --- acr_ed.FDb.cpptype_curs.Next
// proceed to next item
inline void acr_ed::_db_cpptype_curs_Next(_db_cpptype_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.cpptype_curs.Access
// item access
inline acr_ed::FCpptype& acr_ed::_db_cpptype_curs_Access(_db_cpptype_curs &curs) {
    return cpptype_qFind(u64(curs.index));
}

// --- acr_ed.FDb.cfmt_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_cfmt_curs_Reset(_db_cfmt_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.cfmt_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_cfmt_curs_ValidQ(_db_cfmt_curs &curs) {
    return curs.index < _db.cfmt_n;
}

// --- acr_ed.FDb.cfmt_curs.Next
// proceed to next item
inline void acr_ed::_db_cfmt_curs_Next(_db_cfmt_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.cfmt_curs.Access
// item access
inline acr_ed::FCfmt& acr_ed::_db_cfmt_curs_Access(_db_cfmt_curs &curs) {
    return cfmt_qFind(u64(curs.index));
}

// --- acr_ed.FDb.nsdb_curs.Reset
// cursor points to valid item
inline void acr_ed::_db_nsdb_curs_Reset(_db_nsdb_curs &curs, acr_ed::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- acr_ed.FDb.nsdb_curs.ValidQ
// cursor points to valid item
inline bool acr_ed::_db_nsdb_curs_ValidQ(_db_nsdb_curs &curs) {
    return curs.index < _db.nsdb_n;
}

// --- acr_ed.FDb.nsdb_curs.Next
// proceed to next item
inline void acr_ed::_db_nsdb_curs_Next(_db_nsdb_curs &curs) {
    curs.index++;
}

// --- acr_ed.FDb.nsdb_curs.Access
// item access
inline acr_ed::FNsdb& acr_ed::_db_nsdb_curs_Access(_db_nsdb_curs &curs) {
    return nsdb_qFind(u64(curs.index));
}
inline acr_ed::FField::FField() {
    acr_ed::FField_Init(*this);
}

inline acr_ed::FField::~FField() {
    acr_ed::FField_Uninit(*this);
}

inline acr_ed::FFprefix::FFprefix() {
    acr_ed::FFprefix_Init(*this);
}

inline acr_ed::FFprefix::~FFprefix() {
    acr_ed::FFprefix_Uninit(*this);
}


// --- acr_ed.FFprefix..Init
// Set all fields to initial values.
inline void acr_ed::FFprefix_Init(acr_ed::FFprefix& fprefix) {
    fprefix.ind_fprefix_next = (acr_ed::FFprefix*)-1; // (acr_ed.FDb.ind_fprefix) not-in-hash
}
inline acr_ed::FListtype::FListtype() {
    acr_ed::FListtype_Init(*this);
}

inline acr_ed::FListtype::~FListtype() {
    acr_ed::FListtype_Uninit(*this);
}


// --- acr_ed.FListtype..Init
// Set all fields to initial values.
inline void acr_ed::FListtype_Init(acr_ed::FListtype& listtype) {
    listtype.circular = bool(false);
    listtype.haveprev = bool(false);
    listtype.instail = bool(false);
    listtype.ind_listtype_next = (acr_ed::FListtype*)-1; // (acr_ed.FDb.ind_listtype) not-in-hash
}
inline acr_ed::FNs::FNs() {
    acr_ed::FNs_Init(*this);
}

inline acr_ed::FNs::~FNs() {
    acr_ed::FNs_Uninit(*this);
}


// --- acr_ed.FNs..Init
// Set all fields to initial values.
inline void acr_ed::FNs_Init(acr_ed::FNs& ns) {
    ns.ind_ns_next = (acr_ed::FNs*)-1; // (acr_ed.FDb.ind_ns) not-in-hash
}
inline acr_ed::FNsdb::FNsdb() {
    acr_ed::FNsdb_Init(*this);
}

inline acr_ed::FNsdb::~FNsdb() {
    acr_ed::FNsdb_Uninit(*this);
}


// --- acr_ed.FNsdb..Init
// Set all fields to initial values.
inline void acr_ed::FNsdb_Init(acr_ed::FNsdb& nsdb) {
    nsdb.ind_nsdb_next = (acr_ed::FNsdb*)-1; // (acr_ed.FDb.ind_nsdb) not-in-hash
}
inline acr_ed::FPack::FPack() {
}

inline acr_ed::FPack::~FPack() {
    acr_ed::FPack_Uninit(*this);
}

inline acr_ed::FSandbox::FSandbox() {
}

inline acr_ed::FSsimfile::FSsimfile() {
    acr_ed::FSsimfile_Init(*this);
}

inline acr_ed::FSsimfile::~FSsimfile() {
    acr_ed::FSsimfile_Uninit(*this);
}


// --- acr_ed.FSsimfile..Init
// Set all fields to initial values.
inline void acr_ed::FSsimfile_Init(acr_ed::FSsimfile& ssimfile) {
    ssimfile.p_ctype = NULL;
    ssimfile.ind_ssimfile_next = (acr_ed::FSsimfile*)-1; // (acr_ed.FDb.ind_ssimfile) not-in-hash
}
inline acr_ed::FTarget::FTarget() {
    acr_ed::FTarget_Init(*this);
}

inline acr_ed::FTarget::~FTarget() {
    acr_ed::FTarget_Uninit(*this);
}


// --- acr_ed.FTarget..Init
// Set all fields to initial values.
inline void acr_ed::FTarget_Init(acr_ed::FTarget& target) {
    target.compat = algo::strptr("Linux-%.%-%");
    target.score = u32(0);
    target.ind_target_next = (acr_ed::FTarget*)-1; // (acr_ed.FDb.ind_target) not-in-hash
}
inline acr_ed::FTargsrc::FTargsrc() {
    acr_ed::FTargsrc_Init(*this);
}


// --- acr_ed.FTargsrc..Init
// Set all fields to initial values.
inline void acr_ed::FTargsrc_Init(acr_ed::FTargsrc& targsrc) {
    targsrc.p_target = NULL;
}
inline acr_ed::FTypefld::FTypefld() {
}

inline acr_ed::FTypefld::~FTypefld() {
    acr_ed::FTypefld_Uninit(*this);
}

inline acr_ed::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline acr_ed::FieldId::FieldId(acr_ed_FieldIdEnum arg) { this->value = i32(arg); }
inline acr_ed::FieldId::FieldId() {
    acr_ed::FieldId_Init(*this);
}


// --- acr_ed.FieldId.value.GetEnum
// Get value of field as enum type
inline acr_ed_FieldIdEnum acr_ed::value_GetEnum(const acr_ed::FieldId& parent) {
    return acr_ed_FieldIdEnum(parent.value);
}

// --- acr_ed.FieldId.value.SetEnum
// Set value of field from enum type.
inline void acr_ed::value_SetEnum(acr_ed::FieldId& parent, acr_ed_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr_ed.FieldId.value.Cast
inline acr_ed::FieldId::operator acr_ed_FieldIdEnum () const {
    return acr_ed_FieldIdEnum((*this).value);
}

// --- acr_ed.FieldId..Init
// Set all fields to initial values.
inline void acr_ed::FieldId_Init(acr_ed::FieldId& parent) {
    parent.value = i32(-1);
}
inline acr_ed::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline acr_ed::TableId::TableId(acr_ed_TableIdEnum arg) { this->value = i32(arg); }
inline acr_ed::TableId::TableId() {
    acr_ed::TableId_Init(*this);
}


// --- acr_ed.TableId.value.GetEnum
// Get value of field as enum type
inline acr_ed_TableIdEnum acr_ed::value_GetEnum(const acr_ed::TableId& parent) {
    return acr_ed_TableIdEnum(parent.value);
}

// --- acr_ed.TableId.value.SetEnum
// Set value of field from enum type.
inline void acr_ed::value_SetEnum(acr_ed::TableId& parent, acr_ed_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- acr_ed.TableId.value.Cast
inline acr_ed::TableId::operator acr_ed_TableIdEnum () const {
    return acr_ed_TableIdEnum((*this).value);
}

// --- acr_ed.TableId..Init
// Set all fields to initial values.
inline void acr_ed::TableId_Init(acr_ed::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_ed::trace &row) {// cfmt:acr_ed.trace.String
    acr_ed::trace_Print(const_cast<acr_ed::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_ed::FieldId &row) {// cfmt:acr_ed.FieldId.String
    acr_ed::FieldId_Print(const_cast<acr_ed::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const acr_ed::TableId &row) {// cfmt:acr_ed.TableId.String
    acr_ed::TableId_Print(const_cast<acr_ed::TableId&>(row), str);
    return str;
}
