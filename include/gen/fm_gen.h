//
// include/gen/fm_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//


#pragma once
#include "include/gen/ams_gen.h"
#include "include/gen/algo_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- fm_Flag_value_Enum

enum fm_Flag_value_Enum {            // fm.Flag.value
     fm_Flag_value_cleared   = 'C'   // Cleared alarm
    ,fm_Flag_value_raised    = 'R'   // Raised alarm
};

enum { fm_Flag_value_Enum_N = 2 };


// --- fm_Severity_value_Enum

enum fm_Severity_value_Enum {             // fm.Severity.value
     fm_Severity_value_critical   = '0'   // Service-affecting fault, immediate attention
    ,fm_Severity_value_major      = '1'   // Service-affecting fault, urgent attention
    ,fm_Severity_value_minor      = '2'   // Non-service affecting fault, need attention
};

enum { fm_Severity_value_Enum_N = 3 };


// --- fm_FieldIdEnum

enum fm_FieldIdEnum {                   // fm.FieldId.value
     fm_FieldId_base              = 0
    ,fm_FieldId_type              = 1
    ,fm_FieldId_length            = 2
    ,fm_FieldId_code              = 3
    ,fm_FieldId_objtype           = 4
    ,fm_FieldId_objinst           = 5
    ,fm_FieldId_flag              = 6
    ,fm_FieldId_severity          = 7
    ,fm_FieldId_n_occurred        = 8
    ,fm_FieldId_first_time        = 9
    ,fm_FieldId_last_time         = 10
    ,fm_FieldId_clear_time        = 11
    ,fm_FieldId_update_time       = 12
    ,fm_FieldId_objtype_summary   = 13
    ,fm_FieldId_summary           = 14
    ,fm_FieldId_description       = 15
    ,fm_FieldId_source            = 16
    ,fm_FieldId_ch                = 17
    ,fm_FieldId_value             = 18
};

enum { fm_FieldIdEnum_N = 19 };

namespace fm { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace fm { // gen:ns_field
} // gen:ns_field
// gen:ns_fwddecl2
namespace fm { struct Code; }
namespace fm { struct Objtype; }
namespace fm { struct Objinst; }
namespace fm { struct Flag; }
namespace fm { struct Severity; }
namespace fm { struct Summary; }
namespace fm { struct Description; }
namespace fm { struct Source; }
namespace fm { struct FieldId; }
namespace fm { struct Protocol; }
namespace fm { // gen:ns_print_struct

// --- fm.Code
#pragma pack(push,1)
struct Code { // fm.Code
    enum { ch_max = 32 };
    u8 ch[32];
    inline operator algo::strptr() const;
    bool operator ==(const fm::Code &rhs) const;
    bool operator !=(const fm::Code &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const fm::Code& parent) __attribute__((nothrow));
    Code(const fm::Code &rhs) __attribute__((nothrow));
    Code(const algo::strptr &rhs) __attribute__((nothrow));
    Code();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const fm::Code& parent) __attribute__((nothrow));
u32                  Code_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(fm::Code &parent) __attribute__((nothrow));
// always return constant 32
int                  ch_Max(fm::Code& parent) __attribute__((nothrow));
int                  ch_N(const fm::Code& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(fm::Code& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(fm::Code& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(fm::Code& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Code_Hash(u32 prev, const fm::Code & rhs) __attribute__((nothrow));
// Read fields of fm::Code from an ascii string.
// The format of the string is the format of the fm::Code's only field
bool                 Code_ReadStrptrMaybe(fm::Code &parent, algo::strptr in_str);
i32                  Code_Cmp(fm::Code & lhs, fm::Code & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Code_Init(fm::Code& parent);
bool                 Code_Eq(const fm::Code & lhs,const fm::Code & rhs) __attribute__((nothrow));
bool                 Code_EqStrptr(fm::Code & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of fm::Code to string LHS, no header -- cprint:fm.Code.String
void                 Code_Print(fm::Code & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Objtype
#pragma pack(push,1)
struct Objtype { // fm.Objtype
    enum { ch_max = 15 };
    u8 ch[15];
    inline operator algo::strptr() const;
    bool operator ==(const fm::Objtype &rhs) const;
    bool operator !=(const fm::Objtype &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const fm::Objtype& parent) __attribute__((nothrow));
    Objtype(const fm::Objtype &rhs) __attribute__((nothrow));
    Objtype(const algo::strptr &rhs) __attribute__((nothrow));
    Objtype();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const fm::Objtype& parent) __attribute__((nothrow));
u32                  Objtype_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(fm::Objtype &parent) __attribute__((nothrow));
// always return constant 15
int                  ch_Max(fm::Objtype& parent) __attribute__((nothrow));
int                  ch_N(const fm::Objtype& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(fm::Objtype& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(fm::Objtype& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(fm::Objtype& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Objtype_Hash(u32 prev, const fm::Objtype & rhs) __attribute__((nothrow));
// Read fields of fm::Objtype from an ascii string.
// The format of the string is the format of the fm::Objtype's only field
bool                 Objtype_ReadStrptrMaybe(fm::Objtype &parent, algo::strptr in_str);
i32                  Objtype_Cmp(fm::Objtype & lhs, fm::Objtype & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Objtype_Init(fm::Objtype& parent);
bool                 Objtype_Eq(const fm::Objtype & lhs,const fm::Objtype & rhs) __attribute__((nothrow));
bool                 Objtype_EqStrptr(fm::Objtype & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of fm::Objtype to string LHS, no header -- cprint:fm.Objtype.String
void                 Objtype_Print(fm::Objtype & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Objinst
#pragma pack(push,1)
struct Objinst { // fm.Objinst
    enum { ch_max = 79 };
    u8 ch[79];
    inline operator algo::strptr() const;
    bool operator ==(const fm::Objinst &rhs) const;
    bool operator !=(const fm::Objinst &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const fm::Objinst& parent) __attribute__((nothrow));
    Objinst(const fm::Objinst &rhs) __attribute__((nothrow));
    Objinst(const algo::strptr &rhs) __attribute__((nothrow));
    Objinst();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const fm::Objinst& parent) __attribute__((nothrow));
u32                  Objinst_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(fm::Objinst &parent) __attribute__((nothrow));
// always return constant 79
int                  ch_Max(fm::Objinst& parent) __attribute__((nothrow));
int                  ch_N(const fm::Objinst& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(fm::Objinst& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(fm::Objinst& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(fm::Objinst& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Objinst_Hash(u32 prev, const fm::Objinst & rhs) __attribute__((nothrow));
// Read fields of fm::Objinst from an ascii string.
// The format of the string is the format of the fm::Objinst's only field
bool                 Objinst_ReadStrptrMaybe(fm::Objinst &parent, algo::strptr in_str);
i32                  Objinst_Cmp(fm::Objinst & lhs, fm::Objinst & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Objinst_Init(fm::Objinst& parent);
bool                 Objinst_Eq(const fm::Objinst & lhs,const fm::Objinst & rhs) __attribute__((nothrow));
bool                 Objinst_EqStrptr(fm::Objinst & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of fm::Objinst to string LHS, no header -- cprint:fm.Objinst.String
void                 Objinst_Print(fm::Objinst & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Flag
#pragma pack(push,1)
struct Flag { // fm.Flag
    char   value;   //   'C'
    Flag();
};
#pragma pack(pop)

// Get value of field as enum type
fm_Flag_value_Enum   value_GetEnum(const fm::Flag& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(fm::Flag& parent, fm_Flag_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const fm::Flag& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const fm::Flag& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(fm::Flag& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(fm::Flag& parent, algo::strptr rhs, fm_Flag_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(fm::Flag& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of fm::Flag from an ascii string.
// The format of the string is the format of the fm::Flag's only field
bool                 Flag_ReadStrptrMaybe(fm::Flag &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 Flag_Init(fm::Flag& parent);
// print string representation of fm::Flag to string LHS, no header -- cprint:fm.Flag.String
void                 Flag_Print(fm::Flag row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Severity
#pragma pack(push,1)
struct Severity { // fm.Severity
    char   value;   //   '1'
    bool operator ==(const fm::Severity &rhs) const;
    bool operator !=(const fm::Severity &rhs) const;
    bool operator <(const fm::Severity &rhs) const;
    bool operator >(const fm::Severity &rhs) const;
    bool operator <=(const fm::Severity &rhs) const;
    bool operator >=(const fm::Severity &rhs) const;
    bool operator ==(fm_Severity_value_Enum rhs) const;
    Severity();
};
#pragma pack(pop)

// Get value of field as enum type
fm_Severity_value_Enum value_GetEnum(const fm::Severity& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(fm::Severity& parent, fm_Severity_value_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const fm::Severity& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const fm::Severity& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(fm::Severity& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(fm::Severity& parent, algo::strptr rhs, fm_Severity_value_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(fm::Severity& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of fm::Severity from an ascii string.
// The format of the string is the format of the fm::Severity's only field
bool                 Severity_ReadStrptrMaybe(fm::Severity &parent, algo::strptr in_str);
bool                 Severity_Lt(fm::Severity lhs, fm::Severity rhs) __attribute__((nothrow));
i32                  Severity_Cmp(fm::Severity lhs, fm::Severity rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Severity_Init(fm::Severity& parent);
// Attempt to make LHS bigger. Return true if it was changed
bool                 Severity_UpdateMax(fm::Severity &lhs, fm::Severity rhs) __attribute__((nothrow));
// Return the lesser of two values
fm::Severity         Severity_Min(fm::Severity lhs, fm::Severity rhs) __attribute__((nothrow));
// Attempt to make LHS smaller. Return true if it was changed
bool                 Severity_UpdateMin(fm::Severity &lhs, fm::Severity rhs) __attribute__((nothrow));
// Return the greater of two values
fm::Severity         Severity_Max(fm::Severity lhs, fm::Severity rhs) __attribute__((nothrow));
bool                 Severity_Eq(fm::Severity lhs, fm::Severity rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Severity_Update(fm::Severity &lhs, fm::Severity rhs) __attribute__((nothrow));
// print string representation of fm::Severity to string LHS, no header -- cprint:fm.Severity.String
void                 Severity_Print(fm::Severity row, algo::cstring &str) __attribute__((nothrow));
// define enum comparison operator to avoid ambiguity
bool                 Severity_EqEnum(fm::Severity lhs, fm_Severity_value_Enum rhs) __attribute__((nothrow));

// --- fm.Summary
#pragma pack(push,1)
struct Summary { // fm.Summary
    enum { ch_max = 64 };
    u8 ch[64];
    inline operator algo::strptr() const;
    bool operator ==(const fm::Summary &rhs) const;
    bool operator !=(const fm::Summary &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const fm::Summary& parent) __attribute__((nothrow));
    Summary(const fm::Summary &rhs) __attribute__((nothrow));
    Summary(const algo::strptr &rhs) __attribute__((nothrow));
    Summary();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const fm::Summary& parent) __attribute__((nothrow));
u32                  Summary_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(fm::Summary &parent) __attribute__((nothrow));
// always return constant 64
int                  ch_Max(fm::Summary& parent) __attribute__((nothrow));
int                  ch_N(const fm::Summary& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(fm::Summary& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(fm::Summary& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(fm::Summary& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Summary_Hash(u32 prev, const fm::Summary & rhs) __attribute__((nothrow));
// Read fields of fm::Summary from an ascii string.
// The format of the string is the format of the fm::Summary's only field
bool                 Summary_ReadStrptrMaybe(fm::Summary &parent, algo::strptr in_str);
i32                  Summary_Cmp(fm::Summary & lhs, fm::Summary & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Summary_Init(fm::Summary& parent);
bool                 Summary_Eq(const fm::Summary & lhs,const fm::Summary & rhs) __attribute__((nothrow));
bool                 Summary_EqStrptr(fm::Summary & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of fm::Summary to string LHS, no header -- cprint:fm.Summary.String
void                 Summary_Print(fm::Summary & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Description
#pragma pack(push,1)
struct Description { // fm.Description
    enum { ch_max = 128 };
    u8 ch[128];
    inline operator algo::strptr() const;
    bool operator ==(const fm::Description &rhs) const;
    bool operator !=(const fm::Description &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const fm::Description& parent) __attribute__((nothrow));
    Description(const fm::Description &rhs) __attribute__((nothrow));
    Description(const algo::strptr &rhs) __attribute__((nothrow));
    Description();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const fm::Description& parent) __attribute__((nothrow));
u32                  Description_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(fm::Description &parent) __attribute__((nothrow));
// always return constant 128
int                  ch_Max(fm::Description& parent) __attribute__((nothrow));
int                  ch_N(const fm::Description& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(fm::Description& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(fm::Description& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(fm::Description& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Description_Hash(u32 prev, const fm::Description & rhs) __attribute__((nothrow));
// Read fields of fm::Description from an ascii string.
// The format of the string is the format of the fm::Description's only field
bool                 Description_ReadStrptrMaybe(fm::Description &parent, algo::strptr in_str);
i32                  Description_Cmp(fm::Description & lhs, fm::Description & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Description_Init(fm::Description& parent);
bool                 Description_Eq(const fm::Description & lhs,const fm::Description & rhs) __attribute__((nothrow));
bool                 Description_EqStrptr(fm::Description & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of fm::Description to string LHS, no header -- cprint:fm.Description.String
void                 Description_Print(fm::Description & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Source
#pragma pack(push,1)
struct Source { // fm.Source
    enum { ch_max = 32 };
    u8 ch[32];
    inline operator algo::strptr() const;
    bool operator ==(const fm::Source &rhs) const;
    bool operator !=(const fm::Source &rhs) const;
    bool operator ==(const algo::strptr &rhs) const;
    // Copy from strptr (operator=)
    void                 operator =(const algo::strptr &str) __attribute__((nothrow));
    // Copy from same type
    // Copy value from RHS.
    void                 operator =(const fm::Source& parent) __attribute__((nothrow));
    Source(const fm::Source &rhs) __attribute__((nothrow));
    Source(const algo::strptr &rhs) __attribute__((nothrow));
    Source();
};
#pragma pack(pop)

// Access string as array of chars
algo::aryptr<char>   ch_Getary(const fm::Source& parent) __attribute__((nothrow));
u32                  Source_Hash(u32 prev, const algo::strptr &str);
void                 ch_Init(fm::Source &parent) __attribute__((nothrow));
// always return constant 32
int                  ch_Max(fm::Source& parent) __attribute__((nothrow));
int                  ch_N(const fm::Source& parent) __attribute__((__warn_unused_result__, nothrow, pure));
void                 ch_Print(fm::Source& parent, algo::cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 ch_ReadStrptrMaybe(fm::Source& parent, algo::strptr rhs) __attribute__((nothrow));
// Copy from strptr, clipping length
// Set string to the value provided by RHS.
// If RHS is too large, it is silently clipped.
void                 ch_SetStrptr(fm::Source& parent, const algo::strptr &rhs) __attribute__((nothrow));

u32                  Source_Hash(u32 prev, const fm::Source & rhs) __attribute__((nothrow));
// Read fields of fm::Source from an ascii string.
// The format of the string is the format of the fm::Source's only field
bool                 Source_ReadStrptrMaybe(fm::Source &parent, algo::strptr in_str);
i32                  Source_Cmp(fm::Source & lhs, fm::Source & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Source_Init(fm::Source& parent);
bool                 Source_Eq(const fm::Source & lhs,const fm::Source & rhs) __attribute__((nothrow));
bool                 Source_EqStrptr(fm::Source & lhs, const algo::strptr &rhs) __attribute__((nothrow));
// print string representation of fm::Source to string LHS, no header -- cprint:fm.Source.String
void                 Source_Print(fm::Source & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.AlarmMsg
#pragma pack(push,1)
struct AlarmMsg { // fm.AlarmMsg
    u32               type;              //   17
    u32               length;            //   ssizeof(parent) + (0)
    fm::Code          code;              // Alarm code
    fm::Objtype       objtype;           // Alarmed object type
    fm::Objinst       objinst;           // Alarmed object instance
    fm::Flag          flag;              // Flag: raised or cleared
    fm::Severity      severity;          // Perceived severity
    i32               n_occurred;        //   0  How many times the alarm occurred since first_time
    algo::UnTime      first_time;        // Time of first occurrence
    algo::UnTime      last_time;         // Time of last occurrence
    algo::UnTime      clear_time;        // Time when the alarm has beed cleared (only for cleared alarms
    algo::UnTime      update_time;       // Time of last update
    fm::Summary       objtype_summary;   // Object type explained
    fm::Summary       summary;           // Alarm summary from inventory
    fm::Description   description;       // Alarm message from object
    fm::Source        source;            // Subsystem where detected
    AlarmMsg();
};
#pragma pack(pop)

// Copy fields out of row
void                 parent_CopyOut(fm::AlarmMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of AlarmMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of AlarmMsg.
// If not successful, quietly return NULL.
fm::AlarmMsg*        AlarmMsg_Castdown(ams::MsgHeader &hdr);
ams::MsgHeader&      Castbase(fm::AlarmMsg& parent);

bool                 AlarmMsg_ReadFieldMaybe(fm::AlarmMsg &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of fm::AlarmMsg from an ascii string.
// The format of the string is an ssim Tuple
bool                 AlarmMsg_ReadStrptrMaybe(fm::AlarmMsg &parent, algo::strptr in_str);
// Message length (uses length field)
i32                  GetMsgLength(const fm::AlarmMsg& row) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
algo::memptr         GetMsgMemptr(const fm::AlarmMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
void                 AlarmMsg_Init(fm::AlarmMsg& parent);
// print string representation of fm::AlarmMsg to string LHS, no header -- cprint:fm.AlarmMsg.String
void                 AlarmMsg_Print(fm::AlarmMsg & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.FieldId
#pragma pack(push,1)
struct FieldId { // fm.FieldId: Field read helper
    i32   value;   //   -1
    inline operator fm_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(fm_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
fm_FieldIdEnum       value_GetEnum(const fm::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(fm::FieldId& parent, fm_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const fm::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const fm::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(fm::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(fm::FieldId& parent, algo::strptr rhs, fm_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(fm::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of fm::FieldId from an ascii string.
// The format of the string is the format of the fm::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(fm::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(fm::FieldId& parent);
// print string representation of fm::FieldId to string LHS, no header -- cprint:fm.FieldId.String
void                 FieldId_Print(fm::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- fm.Protocol
// access: fm.Protocol.proto (Protocol)
#pragma pack(push,1)
struct Protocol { // fm.Protocol: amc-generated struct for internal purposes
    Protocol();
};
#pragma pack(pop)

void                 StaticCheck();

} // gen:ns_print_struct
namespace fm { // gen:ns_func
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const fm::Flag &row);// cfmt:fm.Flag.String
inline algo::cstring &operator <<(algo::cstring &str, const fm::Severity &row);// cfmt:fm.Severity.String
inline algo::cstring &operator <<(algo::cstring &str, const fm::AlarmMsg &row);// cfmt:fm.AlarmMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const fm::FieldId &row);// cfmt:fm.FieldId.String
}
