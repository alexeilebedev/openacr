//
// include/gen/ams_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/ietf_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- ams_FieldIdEnum

enum ams_FieldIdEnum {                  // ams.FieldId.value
     ams_FieldId_base             = 0
    ,ams_FieldId_type             = 1
    ,ams_FieldId_length           = 2
    ,ams_FieldId_text             = 3
    ,ams_FieldId_proc_id          = 4
    ,ams_FieldId_payload          = 5
    ,ams_FieldId_tstamp           = 6
    ,ams_FieldId_logcat           = 7
    ,ams_FieldId_proc             = 8
    ,ams_FieldId_value            = 9
    ,ams_FieldId_proctype         = 10
    ,ams_FieldId_nodeidx          = 11
    ,ams_FieldId_procidx          = 12
    ,ams_FieldId_signal           = 13
    ,ams_FieldId_until            = 14
    ,ams_FieldId_pty              = 15
    ,ams_FieldId_cmd              = 16
    ,ams_FieldId_status           = 17
    ,ams_FieldId_remove_topmost   = 18
    ,ams_FieldId_pathname         = 19
    ,ams_FieldId_write            = 20
    ,ams_FieldId_read             = 21
    ,ams_FieldId_nonblock         = 22
    ,ams_FieldId_write_err        = 23
    ,ams_FieldId_shmember         = 24
    ,ams_FieldId_off              = 25
    ,ams_FieldId_wbudget          = 26
    ,ams_FieldId_shmtype          = 27
    ,ams_FieldId_index            = 28
    ,ams_FieldId_r                = 29
    ,ams_FieldId_w                = 30
    ,ams_FieldId_shm_id           = 31
    ,ams_FieldId_flags            = 32
};

enum { ams_FieldIdEnum_N = 33 };


// --- ams_ProctypeEnum

enum ams_ProctypeEnum {                // ams.Proctype.value
     ams_Proctype_               = 0   // No process
    ,ams_Proctype_ams_sendtest   = 5   // Ams testing
};

enum { ams_ProctypeEnum_N = 2 };


// --- ams_MsgHeader_type_Enum

enum ams_MsgHeader_type_Enum {                         // ams.MsgHeader.type
     ams_MsgHeader_type_ams_ExpectMsg          = 395   // Pause reading until some output is produced
    ,ams_MsgHeader_type_ams_InputLineMsg       = 22    // Unrecognized input line
    ,ams_MsgHeader_type_ams_LogMsg             = 6     // Log message
    ,ams_MsgHeader_type_ams_MsgBlock           = 1     // A block of messages from ams commit file
    ,ams_MsgHeader_type_ams_ProcEofMsg         = 703   // EOF from/to a process
    ,ams_MsgHeader_type_ams_ProcKillMsg        = 704   // Kill process
    ,ams_MsgHeader_type_ams_ProcMsg            = 701   // Message from/to a process
    ,ams_MsgHeader_type_ams_ProcReadMsg        = 702   // Read process output
    ,ams_MsgHeader_type_ams_ProcStartMsg       = 700   // Start process
    ,ams_MsgHeader_type_ams_ProcStatusMsg      = 705   // Process status
    ,ams_MsgHeader_type_ams_RemDirRecurseMsg   = 633   // Message sent to process to terminate it
    ,ams_MsgHeader_type_ams_ShmHbMsg           = 3     // Shm heartbeat
    ,ams_MsgHeader_type_ams_Shmmsg             = 10    // Sequenced message on a shm
    ,ams_MsgHeader_type_ams_TerminateMsg       = 352   // Message sent to process to terminate it
    ,ams_MsgHeader_type_ams_UdpFrame           = 2     // sniffer-captured ethernet frame
    ,ams_MsgHeader_type_fm_AlarmMsg            = 17
    ,ams_MsgHeader_type_ws_CloseMsg            = 504
    ,ams_MsgHeader_type_ws_ConnectMsg          = 502
    ,ams_MsgHeader_type_ws_DataMsg             = 503
    ,ams_MsgHeader_type_ws_ServerStartMsg      = 500
    ,ams_MsgHeader_type_ws_ServerStopMsg       = 501
};

enum { ams_MsgHeader_type_Enum_N = 21 };


// --- ams_MsgHeaderMsgsCaseEnum

enum ams_MsgHeaderMsgsCaseEnum {                         // ams.MsgHeaderMsgsCase.value
     ams_MsgHeaderMsgsCase_ams_ExpectMsg          = 395
    ,ams_MsgHeaderMsgsCase_ams_InputLineMsg       = 22
    ,ams_MsgHeaderMsgsCase_ams_LogMsg             = 6
    ,ams_MsgHeaderMsgsCase_ams_MsgBlock           = 1
    ,ams_MsgHeaderMsgsCase_ams_ProcEofMsg         = 703
    ,ams_MsgHeaderMsgsCase_ams_ProcKillMsg        = 704
    ,ams_MsgHeaderMsgsCase_ams_ProcMsg            = 701
    ,ams_MsgHeaderMsgsCase_ams_ProcReadMsg        = 702
    ,ams_MsgHeaderMsgsCase_ams_ProcStartMsg       = 700
    ,ams_MsgHeaderMsgsCase_ams_ProcStatusMsg      = 705
    ,ams_MsgHeaderMsgsCase_ams_RemDirRecurseMsg   = 633
    ,ams_MsgHeaderMsgsCase_ams_ShmHbMsg           = 3
    ,ams_MsgHeaderMsgsCase_ams_Shmmsg             = 10
    ,ams_MsgHeaderMsgsCase_ams_TerminateMsg       = 352
    ,ams_MsgHeaderMsgsCase_ams_UdpFrame           = 2
    ,ams_MsgHeaderMsgsCase_fm_AlarmMsg            = 17
    ,ams_MsgHeaderMsgsCase_ws_CloseMsg            = 504
    ,ams_MsgHeaderMsgsCase_ws_ConnectMsg          = 502
    ,ams_MsgHeaderMsgsCase_ws_DataMsg             = 503
    ,ams_MsgHeaderMsgsCase_ws_ServerStartMsg      = 500
    ,ams_MsgHeaderMsgsCase_ws_ServerStopMsg       = 501
};

enum { ams_MsgHeaderMsgsCaseEnum_N = 21 };


// --- ams_ShmFlagsEnum

enum ams_ShmFlagsEnum {                // ams.ShmFlags.value
     ams_ShmFlags_write       = 0x2    // ams.ShmFlags.write
    ,ams_ShmFlags_read        = 0x4    // ams.ShmFlags.read
    ,ams_ShmFlags_nonblock    = 0x8    // ams.ShmFlags.nonblock
    ,ams_ShmFlags_write_err   = 0x40   // ams.ShmFlags.write_err
};

enum { ams_ShmFlagsEnum_N = 4 };


// --- ams_ShmtypeEnum

enum ams_ShmtypeEnum {        // ams.Shmtype.value
     ams_Shmtype_ctl    = 1   // AMS control messages
    ,ams_Shmtype_log    = 9   // Log messages
    ,ams_Shmtype_out    = 2   // Log messages, alarms
};

enum { ams_ShmtypeEnum_N = 3 };


// --- ams_ShmemberFlagsEnum

enum ams_ShmemberFlagsEnum {          // ams.ShmemberFlags.value
     ams_ShmemberFlags_r      = 0x1   // ams.ShmemberFlags.r
    ,ams_ShmemberFlags_w      = 0x2   // ams.ShmemberFlags.w
};

enum { ams_ShmemberFlagsEnum_N = 2 };

namespace ams { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace ams { // gen:ns_tclass_field
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace ams { struct MsgHeader; }
namespace ams { struct ExpectMsg; }
namespace ams { struct InputLineMsg; }
namespace ams { struct LogMsg; }
namespace ams { struct MsgBlock; }
namespace ams { struct ProcEofMsg; }
namespace ams { struct ProcKillMsg; }
namespace ams { struct ProcMsg; }
namespace ams { struct ProcReadMsg; }
namespace ams { struct ProcStartMsg; }
namespace ams { struct ProcStatusMsg; }
namespace ams { struct RemDirRecurseMsg; }
namespace ams { struct ShmHbMsg; }
namespace ams { struct Shmmsg; }
namespace ams { struct TerminateMsg; }
namespace ams { struct UdpFrame; }
namespace fm { struct AlarmMsg; }
namespace ws { struct CloseMsg; }
namespace ws { struct ConnectMsg; }
namespace ws { struct DataMsg; }
namespace ws { struct ServerStartMsg; }
namespace ws { struct ServerStopMsg; }
namespace ams { struct ProcId; }
namespace ietf { struct Ipv4; }
namespace ams { struct ExpectMsg_text_curs; }
namespace ams { struct InputLineMsg_payload_curs; }
namespace ams { struct LogMsg_logcat_curs; }
namespace ams { struct LogMsg_text_curs; }
namespace ams { struct MsgBlock_messages_curs; }
namespace ams { struct ProcMsg_payload_curs; }
namespace ams { struct ProcReadMsg_until_curs; }
namespace ams { struct ProcStartMsg_cmd_curs; }
namespace ams { struct RemDirRecurseMsg_pathname_curs; }
namespace ams { struct UdpFrame_payload_curs; }
namespace ams { struct FieldId; }
namespace ams { struct Proctype; }
namespace ams { struct MsgHeaderMsgsCase; }
namespace ams { struct MsgHeader_curs; }
namespace ams { struct ShmFlags; }
namespace ams { struct Shmtype; }
namespace ams { struct ShmId; }
namespace ams { struct ShmemberFlags; }
namespace ams { struct ShmemberId; }
namespace ams { // gen:ns_size_enums

// sizes types appearing as Opt or Varlen; these need to be here
// to allow inline implementations of _Get functions and avoid
// a circular dependency between headers
enum {
    sizeof_ams_MsgHeader = 8
};
} // gen:ns_size_enums
namespace ams { // gen:ns_print_struct

// --- ams.ExpectMsg
#pragma pack(push,1)
struct ExpectMsg { // ams.ExpectMsg: Pause reading until some output is produced
    u32   type;     //   395
    u32   length;   //   ssizeof(parent) + (0)
    // var-length field ams.ExpectMsg.text starts here. access it with text_Addr
    // func:ams.ExpectMsg..Ctor
    inline               ExpectMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ExpectMsg.base.CopyOut
void                 parent_CopyOut(ams::ExpectMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ExpectMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ExpectMsg.
// If not successful, quietly return NULL.
// func:ams.ExpectMsg.base.Castdown
inline ams::ExpectMsg* ExpectMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ExpectMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ExpectMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.ExpectMsg.text.Getary
algo::aryptr<char>   text_Getary(ams::ExpectMsg& parent) __attribute__((nothrow));
// func:ams.ExpectMsg.text.Addr
char*                text_Addr(ams::ExpectMsg& parent);
// Return number of elements in varlen field
// func:ams.ExpectMsg.text.N
inline u32           text_N(const ams::ExpectMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.ExpectMsg.text.ReadStrptrMaybe
bool                 text_ReadStrptrMaybe(ams::ExpectMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert text to a string.
// Array is printed as a regular string.
// func:ams.ExpectMsg.text.Print
void                 text_Print(ams::ExpectMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.ExpectMsg.text_curs.Reset
inline void          ExpectMsg_text_curs_Reset(ExpectMsg_text_curs &curs, ams::ExpectMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.ExpectMsg.text_curs.ValidQ
inline bool          ExpectMsg_text_curs_ValidQ(ExpectMsg_text_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.ExpectMsg.text_curs.Next
inline void          ExpectMsg_text_curs_Next(ExpectMsg_text_curs &curs) __attribute__((nothrow));
// item access
// func:ams.ExpectMsg.text_curs.Access
inline char&         ExpectMsg_text_curs_Access(ExpectMsg_text_curs &curs) __attribute__((nothrow));
// func:ams.ExpectMsg..ReadFieldMaybe
bool                 ExpectMsg_ReadFieldMaybe(ams::ExpectMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ExpectMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ExpectMsg..ReadStrptrMaybe
bool                 ExpectMsg_ReadStrptrMaybe(ams::ExpectMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ExpectMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ExpectMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ExpectMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ExpectMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ExpectMsg..Init
inline void          ExpectMsg_Init(ams::ExpectMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ExpectMsg.String  printfmt:Tuple
// func:ams.ExpectMsg..Print
void                 ExpectMsg_Print(ams::ExpectMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.FieldId
#pragma pack(push,1)
struct FieldId { // ams.FieldId: Field read helper
    i32   value;   //   -1
    // func:ams.FieldId.value.Cast
    inline               operator ams_FieldIdEnum() const __attribute__((nothrow));
    // func:ams.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:ams.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:ams.FieldId..EnumCtor
    inline               FieldId(ams_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.FieldId.value.GetEnum
inline ams_FieldIdEnum value_GetEnum(const ams::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.FieldId.value.SetEnum
inline void          value_SetEnum(ams::FieldId& parent, ams_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.FieldId.value.ToCstr
const char*          value_ToCstr(const ams::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.FieldId.value.Print
void                 value_Print(const ams::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.FieldId.value.SetStrptr
void                 value_SetStrptr(ams::FieldId& parent, algo::strptr rhs, ams_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of ams::FieldId from an ascii string.
// The format of the string is the format of the ams::FieldId's only field
// func:ams.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(ams::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.FieldId..Init
inline void          FieldId_Init(ams::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:ams.FieldId.String  printfmt:Raw
// func:ams.FieldId..Print
void                 FieldId_Print(ams::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.Proctype
// create: ams.ProcId.proctype (Bitfld)
#pragma pack(push,1)
struct Proctype { // ams.Proctype
    u8   value;   //   0
    // func:ams.Proctype..EqOp
    inline bool          operator ==(const ams::Proctype &rhs) const __attribute__((nothrow));
    // func:ams.Proctype..NeOp
    inline bool          operator !=(const ams::Proctype &rhs) const __attribute__((nothrow));
    // define enum comparison operator to avoid ambiguity
    // func:ams.Proctype..EqEnum
    inline bool          operator ==(ams_ProctypeEnum rhs) const __attribute__((nothrow));
    // func:ams.Proctype..Ctor
    inline               Proctype() __attribute__((nothrow));
    // func:ams.Proctype..FieldwiseCtor
    explicit inline               Proctype(u8 in_value) __attribute__((nothrow));
    // func:ams.Proctype..EnumCtor
    inline               Proctype(ams_ProctypeEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.Proctype.value.GetEnum
inline ams_ProctypeEnum value_GetEnum(const ams::Proctype& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.Proctype.value.SetEnum
inline void          value_SetEnum(ams::Proctype& parent, ams_ProctypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.Proctype.value.ToCstr
const char*          value_ToCstr(const ams::Proctype& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.Proctype.value.Print
void                 value_Print(const ams::Proctype& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.Proctype.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::Proctype& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.Proctype.value.SetStrptr
void                 value_SetStrptr(ams::Proctype& parent, algo::strptr rhs, ams_ProctypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.Proctype.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::Proctype& parent, algo::strptr rhs) __attribute__((nothrow));

// func:ams.Proctype..Hash
inline u32           Proctype_Hash(u32 prev, ams::Proctype rhs) __attribute__((nothrow));
// Read fields of ams::Proctype from an ascii string.
// The format of the string is the format of the ams::Proctype's only field
// func:ams.Proctype..ReadStrptrMaybe
bool                 Proctype_ReadStrptrMaybe(ams::Proctype &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.Proctype..Cmp
inline i32           Proctype_Cmp(ams::Proctype lhs, ams::Proctype rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.Proctype..Init
inline void          Proctype_Init(ams::Proctype& parent);
// func:ams.Proctype..Eq
inline bool          Proctype_Eq(ams::Proctype lhs, ams::Proctype rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.Proctype.String  printfmt:Raw
// func:ams.Proctype..Print
void                 Proctype_Print(ams::Proctype row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcId
#pragma pack(push,1)
struct ProcId { // ams.ProcId: Process ID within topology: type, node index, process index, e.g. proc-0-0
    u32   value;   //   0  Process type
    // func:ams.ProcId..EqOp
    inline bool          operator ==(const ams::ProcId &rhs) const __attribute__((nothrow));
    // func:ams.ProcId..NeOp
    inline bool          operator !=(const ams::ProcId &rhs) const __attribute__((nothrow));
    // func:ams.ProcId..Ctor
    inline               ProcId() __attribute__((nothrow));
    // func:ams.ProcId..FieldwiseCtor
    explicit inline               ProcId(u32 in_value) __attribute__((nothrow));
};
#pragma pack(pop)

// Retrieve bitfield from value of field value
//    8 bits starting at bit 24.
// func:ams.ProcId.proctype.Get
inline ams::Proctype proctype_Get(const ams::ProcId& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    8 bits starting at bit 24.
// func:ams.ProcId.proctype.Set
inline void          proctype_Set(ams::ProcId& parent, ams::Proctype rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    8 bits starting at bit 8.
// func:ams.ProcId.nodeidx.Get
inline u8            nodeidx_Get(const ams::ProcId& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    8 bits starting at bit 8.
// func:ams.ProcId.nodeidx.Set
inline void          nodeidx_Set(ams::ProcId& parent, u8 rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    4 bits starting at bit 0.
// func:ams.ProcId.procidx.Get
inline u8            procidx_Get(const ams::ProcId& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    4 bits starting at bit 0.
// func:ams.ProcId.procidx.Set
inline void          procidx_Set(ams::ProcId& parent, u8 rhs) __attribute__((nothrow));

// func:ams.ProcId..Hash
inline u32           ProcId_Hash(u32 prev, ams::ProcId rhs) __attribute__((nothrow));
// func:ams.ProcId..ReadFieldMaybe
bool                 ProcId_ReadFieldMaybe(ams::ProcId& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcId from an ascii string.
// The format of the string is a string with separated values
// func:ams.ProcId..ReadStrptrMaybe
bool                 ProcId_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.ProcId..Cmp
inline i32           ProcId_Cmp(ams::ProcId lhs, ams::ProcId rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcId..Init
inline void          ProcId_Init(ams::ProcId& parent);
// func:ams.ProcId..Eq
inline bool          ProcId_Eq(ams::ProcId lhs, ams::ProcId rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.ProcId.String  printfmt:Sep
// func:ams.ProcId..Print
void                 ProcId_Print(ams::ProcId row, algo::cstring& str) __attribute__((nothrow));

// --- ams.InputLineMsg
#pragma pack(push,1)
struct InputLineMsg { // ams.InputLineMsg: Unrecognized input line
    u32           type;      //   22
    u32           length;    //   ssizeof(parent) + (0)
    ams::ProcId   proc_id;   // Target process
    // var-length field ams.InputLineMsg.payload starts here. access it with payload_Addr
    // func:ams.InputLineMsg..Ctor
    inline               InputLineMsg() __attribute__((nothrow));
    // func:ams.InputLineMsg..FieldwiseCtor
    explicit inline               InputLineMsg(ams::ProcId in_proc_id) __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.InputLineMsg.base.CopyOut
void                 parent_CopyOut(ams::InputLineMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of InputLineMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of InputLineMsg.
// If not successful, quietly return NULL.
// func:ams.InputLineMsg.base.Castdown
inline ams::InputLineMsg* InputLineMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.InputLineMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::InputLineMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.InputLineMsg.payload.Getary
algo::aryptr<char>   payload_Getary(ams::InputLineMsg& parent) __attribute__((nothrow));
// func:ams.InputLineMsg.payload.Addr
char*                payload_Addr(ams::InputLineMsg& parent);
// Return number of elements in varlen field
// func:ams.InputLineMsg.payload.N
inline u32           payload_N(const ams::InputLineMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.InputLineMsg.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(ams::InputLineMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert payload to a string.
// Array is printed as a regular string.
// func:ams.InputLineMsg.payload.Print
void                 payload_Print(ams::InputLineMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.InputLineMsg.payload_curs.Reset
inline void          InputLineMsg_payload_curs_Reset(InputLineMsg_payload_curs &curs, ams::InputLineMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.InputLineMsg.payload_curs.ValidQ
inline bool          InputLineMsg_payload_curs_ValidQ(InputLineMsg_payload_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.InputLineMsg.payload_curs.Next
inline void          InputLineMsg_payload_curs_Next(InputLineMsg_payload_curs &curs) __attribute__((nothrow));
// item access
// func:ams.InputLineMsg.payload_curs.Access
inline char&         InputLineMsg_payload_curs_Access(InputLineMsg_payload_curs &curs) __attribute__((nothrow));
// func:ams.InputLineMsg..ReadFieldMaybe
bool                 InputLineMsg_ReadFieldMaybe(ams::InputLineMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::InputLineMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.InputLineMsg..ReadStrptrMaybe
bool                 InputLineMsg_ReadStrptrMaybe(ams::InputLineMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.InputLineMsg..GetMsgLength
inline i32           GetMsgLength(const ams::InputLineMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.InputLineMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::InputLineMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.InputLineMsg..Init
inline void          InputLineMsg_Init(ams::InputLineMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.InputLineMsg.String  printfmt:Tuple
// func:ams.InputLineMsg..Print
void                 InputLineMsg_Print(ams::InputLineMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.LogMsg
#pragma pack(push,1)
struct LogMsg { // ams.LogMsg: Log message
    u32               type;         //   6
    u32               length;       //   ssizeof(parent) + (0)
    ams::ProcId       proc_id;      //
    algo::SchedTime   tstamp;       // Local timestamp
    u32               logcat_end;   // end of logcat field
    // var-length field ams.LogMsg.logcat starts here. access it with logcat_Addr
    // var-length field ams.LogMsg.text starts here. access it with text_Addr
    // func:ams.LogMsg..Ctor
    inline               LogMsg() __attribute__((nothrow));
    // func:ams.LogMsg..FieldwiseCtor
    explicit inline               LogMsg(ams::ProcId in_proc_id, algo::SchedTime in_tstamp) __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.LogMsg.base.CopyOut
void                 parent_CopyOut(ams::LogMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of LogMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of LogMsg.
// If not successful, quietly return NULL.
// func:ams.LogMsg.base.Castdown
inline ams::LogMsg*  LogMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.LogMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::LogMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.LogMsg.logcat.Getary
algo::aryptr<char>   logcat_Getary(ams::LogMsg& parent) __attribute__((nothrow));
// func:ams.LogMsg.logcat.Addr
char*                logcat_Addr(ams::LogMsg& parent);
// Return number of elements in varlen field
// func:ams.LogMsg.logcat.N
inline u32           logcat_N(const ams::LogMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.LogMsg.logcat.ReadStrptrMaybe
bool                 logcat_ReadStrptrMaybe(ams::LogMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert logcat to a string.
// Array is printed as a regular string.
// func:ams.LogMsg.logcat.Print
void                 logcat_Print(ams::LogMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.LogMsg.text.Getary
algo::aryptr<char>   text_Getary(ams::LogMsg& parent) __attribute__((nothrow));
// func:ams.LogMsg.text.Addr
char*                text_Addr(ams::LogMsg& parent);
// Return number of elements in varlen field
// func:ams.LogMsg.text.N
inline u32           text_N(const ams::LogMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.LogMsg.text.ReadStrptrMaybe
bool                 text_ReadStrptrMaybe(ams::LogMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert text to a string.
// Array is printed as a regular string.
// func:ams.LogMsg.text.Print
void                 text_Print(ams::LogMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.LogMsg.logcat_curs.Reset
inline void          LogMsg_logcat_curs_Reset(LogMsg_logcat_curs &curs, ams::LogMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.LogMsg.logcat_curs.ValidQ
inline bool          LogMsg_logcat_curs_ValidQ(LogMsg_logcat_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.LogMsg.logcat_curs.Next
inline void          LogMsg_logcat_curs_Next(LogMsg_logcat_curs &curs) __attribute__((nothrow));
// item access
// func:ams.LogMsg.logcat_curs.Access
inline char&         LogMsg_logcat_curs_Access(LogMsg_logcat_curs &curs) __attribute__((nothrow));
// func:ams.LogMsg.text_curs.Reset
inline void          LogMsg_text_curs_Reset(LogMsg_text_curs &curs, ams::LogMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.LogMsg.text_curs.ValidQ
inline bool          LogMsg_text_curs_ValidQ(LogMsg_text_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.LogMsg.text_curs.Next
inline void          LogMsg_text_curs_Next(LogMsg_text_curs &curs) __attribute__((nothrow));
// item access
// func:ams.LogMsg.text_curs.Access
inline char&         LogMsg_text_curs_Access(LogMsg_text_curs &curs) __attribute__((nothrow));
// func:ams.LogMsg..ReadFieldMaybe
bool                 LogMsg_ReadFieldMaybe(ams::LogMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::LogMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.LogMsg..ReadStrptrMaybe
bool                 LogMsg_ReadStrptrMaybe(ams::LogMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.LogMsg..GetMsgLength
inline i32           GetMsgLength(const ams::LogMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.LogMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::LogMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.LogMsg..Init
inline void          LogMsg_Init(ams::LogMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.LogMsg.String  printfmt:Tuple
// func:ams.LogMsg..Print
void                 LogMsg_Print(ams::LogMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.MsgBlock
#pragma pack(push,1)
struct MsgBlock { // ams.MsgBlock: A block of messages from ams commit file
    u32   type;              //   1
    u32   length;            //   ssizeof(parent) + (0)
    u64   first_seqno;       //   0  First sequence number
    u32   n_messages;        //   0  Number of messages
    u32   original_length;   //   0  Original (uncompressed length) of messages
    // var-length field ams.MsgBlock.messages starts here. access it with messages_Addr
    // func:ams.MsgBlock..Ctor
    inline               MsgBlock() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.MsgBlock.header.CopyOut
void                 parent_CopyOut(ams::MsgBlock &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of MsgBlock by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgBlock.
// If not successful, quietly return NULL.
// func:ams.MsgBlock.header.Castdown
inline ams::MsgBlock* MsgBlock_Castdown(ams::MsgHeader &hdr);
// func:ams.MsgBlock.header.Castbase
inline ams::MsgHeader& Castbase(ams::MsgBlock& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.MsgBlock.messages.Getary
algo::aryptr<u8>     messages_Getary(ams::MsgBlock& parent) __attribute__((nothrow));
// func:ams.MsgBlock.messages.Addr
u8*                  messages_Addr(ams::MsgBlock& parent);
// Return number of elements in varlen field
// func:ams.MsgBlock.messages.N
inline u32           messages_N(const ams::MsgBlock& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert messages to a string.
// Array is printed as a regular string.
// func:ams.MsgBlock.messages.Print
void                 messages_Print(ams::MsgBlock& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.MsgBlock.messages_curs.Reset
inline void          MsgBlock_messages_curs_Reset(MsgBlock_messages_curs &curs, ams::MsgBlock &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.MsgBlock.messages_curs.ValidQ
inline bool          MsgBlock_messages_curs_ValidQ(MsgBlock_messages_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.MsgBlock.messages_curs.Next
inline void          MsgBlock_messages_curs_Next(MsgBlock_messages_curs &curs) __attribute__((nothrow));
// item access
// func:ams.MsgBlock.messages_curs.Access
inline u8&           MsgBlock_messages_curs_Access(MsgBlock_messages_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.MsgBlock..GetMsgLength
inline i32           GetMsgLength(const ams::MsgBlock& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.MsgBlock..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::MsgBlock& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgBlock..Init
inline void          MsgBlock_Init(ams::MsgBlock& parent);
// print string representation of ROW to string STR
// cfmt:ams.MsgBlock.String  printfmt:Tuple
// func:ams.MsgBlock..Print
void                 MsgBlock_Print(ams::MsgBlock& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.MsgHeader
// create: ams.Shmmsg.payload (Opt)
// access: ams.ExpectMsg.base (Base)
// access: ams.InputLineMsg.base (Base)
// access: ams.LogMsg.base (Base)
// access: ams.MsgBlock.header (Base)
// access: ams.ProcEofMsg.base (Base)
// access: ams.ProcKillMsg.base (Base)
// access: ams.ProcMsg.base (Base)
// access: ams.ProcReadMsg.base (Base)
// access: ams.ProcStartMsg.base (Base)
// access: ams.ProcStatusMsg.base (Base)
// access: ams.RemDirRecurseMsg.base (Base)
// access: ams.ShmHbMsg.base (Base)
// access: ams.Shmmsg.base (Base)
// access: ams.TerminateMsg.base (Base)
// access: ams.UdpFrame.header (Base)
// access: ams.MsgHeader_curs.msg (Ptr)
#pragma pack(push,1)
struct MsgHeader { // ams.MsgHeader
    u32   type;     //   0
    u32   length;   //   0
    // func:ams.MsgHeader..Ctor
    inline               MsgHeader() __attribute__((nothrow));
    // func:ams.MsgHeader..FieldwiseCtor
    explicit inline               MsgHeader(u32 in_type, u32 in_length) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.MsgHeader.type.GetEnum
inline ams_MsgHeader_type_Enum type_GetEnum(const ams::MsgHeader& payload) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.MsgHeader.type.SetEnum
inline void          type_SetEnum(ams::MsgHeader& payload, ams_MsgHeader_type_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.MsgHeader.type.ToCstr
const char*          type_ToCstr(const ams::MsgHeader& payload) __attribute__((nothrow));
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
// func:ams.MsgHeader.type.Print
void                 type_Print(const ams::MsgHeader& payload, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.MsgHeader.type.SetStrptrMaybe
bool                 type_SetStrptrMaybe(ams::MsgHeader& payload, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.MsgHeader.type.SetStrptr
void                 type_SetStrptr(ams::MsgHeader& payload, algo::strptr rhs, ams_MsgHeader_type_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.MsgHeader.type.ReadStrptrMaybe
bool                 type_ReadStrptrMaybe(ams::MsgHeader& payload, algo::strptr rhs) __attribute__((nothrow));

// func:ams.MsgHeader..ReadFieldMaybe
bool                 MsgHeader_ReadFieldMaybe(ams::MsgHeader& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.MsgHeader..ReadStrptrMaybe
bool                 MsgHeader_ReadStrptrMaybe(ams::MsgHeader &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.MsgHeader..GetMsgLength
inline i32           GetMsgLength(const ams::MsgHeader& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.MsgHeader..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::MsgHeader& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgHeader..Init
inline void          MsgHeader_Init(ams::MsgHeader& payload);
// print string representation of ROW to string STR
// cfmt:ams.MsgHeader.String  printfmt:Tuple
// func:ams.MsgHeader..Print
void                 MsgHeader_Print(ams::MsgHeader& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.MsgHeaderMsgsCase
#pragma pack(push,1)
struct MsgHeaderMsgsCase { // ams.MsgHeaderMsgsCase: Enum for dispatch ams.MsgHeaderMsgs
    u32   value;   //   0
    // func:ams.MsgHeaderMsgsCase.value.Cast
    inline               operator ams_MsgHeaderMsgsCaseEnum() const __attribute__((nothrow));
    // func:ams.MsgHeaderMsgsCase..Ctor
    inline               MsgHeaderMsgsCase() __attribute__((nothrow));
    // func:ams.MsgHeaderMsgsCase..FieldwiseCtor
    explicit inline               MsgHeaderMsgsCase(u32 in_value) __attribute__((nothrow));
    // func:ams.MsgHeaderMsgsCase..EnumCtor
    inline               MsgHeaderMsgsCase(ams_MsgHeaderMsgsCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.MsgHeaderMsgsCase.value.GetEnum
inline ams_MsgHeaderMsgsCaseEnum value_GetEnum(const ams::MsgHeaderMsgsCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.MsgHeaderMsgsCase.value.SetEnum
inline void          value_SetEnum(ams::MsgHeaderMsgsCase& parent, ams_MsgHeaderMsgsCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.MsgHeaderMsgsCase.value.ToCstr
const char*          value_ToCstr(const ams::MsgHeaderMsgsCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.MsgHeaderMsgsCase.value.Print
void                 value_Print(const ams::MsgHeaderMsgsCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.MsgHeaderMsgsCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.MsgHeaderMsgsCase.value.SetStrptr
void                 value_SetStrptr(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs, ams_MsgHeaderMsgsCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.MsgHeaderMsgsCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of ams::MsgHeaderMsgsCase from an ascii string.
// The format of the string is the format of the ams::MsgHeaderMsgsCase's only field
// func:ams.MsgHeaderMsgsCase..ReadStrptrMaybe
bool                 MsgHeaderMsgsCase_ReadStrptrMaybe(ams::MsgHeaderMsgsCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgHeaderMsgsCase..Init
inline void          MsgHeaderMsgsCase_Init(ams::MsgHeaderMsgsCase& parent);

// --- ams.MsgHeader_curs
#pragma pack(push,1)
struct MsgHeader_curs { // ams.MsgHeader_curs: Cursor for scanning messages in a memptr
    typedef ams::MsgHeader *ChildType;
    ams::MsgHeader*   msg;      // Pointer to current message. optional pointer
    u8*               bytes;    // Beginning of region. optional pointer
    i32               limit;    //   0  # Of bytes in the region
    i32               msglen;   //   0  Length of current message (if any)
    // func:ams.MsgHeader_curs..Ctor
    inline               MsgHeader_curs() __attribute__((nothrow));
};
#pragma pack(pop)

// func:ams.MsgHeader_curs..ValidQ
inline bool          MsgHeader_curs_ValidQ(ams::MsgHeader_curs& curs) __attribute__((nothrow));
// func:ams.MsgHeader_curs..Reset
inline void          MsgHeader_curs_Reset(ams::MsgHeader_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:ams.MsgHeader_curs..Access
inline ams::MsgHeader*& MsgHeader_curs_Access(ams::MsgHeader_curs& curs) __attribute__((nothrow));
// func:ams.MsgHeader_curs..Next
inline void          MsgHeader_curs_Next(ams::MsgHeader_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgHeader_curs..Init
inline void          MsgHeader_curs_Init(ams::MsgHeader_curs& parent);

// --- ams.ProcEofMsg
#pragma pack(push,1)
struct ProcEofMsg { // ams.ProcEofMsg: EOF from/to a process
    u32                type;     //   703
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   proc;     //
    // func:ams.ProcEofMsg..Ctor
    inline               ProcEofMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcEofMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcEofMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcEofMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcEofMsg.
// If not successful, quietly return NULL.
// func:ams.ProcEofMsg.base.Castdown
inline ams::ProcEofMsg* ProcEofMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcEofMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ProcEofMsg& parent);

// func:ams.ProcEofMsg..ReadFieldMaybe
bool                 ProcEofMsg_ReadFieldMaybe(ams::ProcEofMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcEofMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcEofMsg..ReadStrptrMaybe
bool                 ProcEofMsg_ReadStrptrMaybe(ams::ProcEofMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcEofMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ProcEofMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcEofMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ProcEofMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcEofMsg..Init
inline void          ProcEofMsg_Init(ams::ProcEofMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcEofMsg.String  printfmt:Tuple
// func:ams.ProcEofMsg..Print
void                 ProcEofMsg_Print(ams::ProcEofMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcKillMsg
#pragma pack(push,1)
struct ProcKillMsg { // ams.ProcKillMsg: Kill process
    u32                type;     //   704
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   proc;     //
    i32                signal;   //   15
    // func:ams.ProcKillMsg..Ctor
    inline               ProcKillMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcKillMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcKillMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcKillMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcKillMsg.
// If not successful, quietly return NULL.
// func:ams.ProcKillMsg.base.Castdown
inline ams::ProcKillMsg* ProcKillMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcKillMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ProcKillMsg& parent);

// func:ams.ProcKillMsg..ReadFieldMaybe
bool                 ProcKillMsg_ReadFieldMaybe(ams::ProcKillMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcKillMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcKillMsg..ReadStrptrMaybe
bool                 ProcKillMsg_ReadStrptrMaybe(ams::ProcKillMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcKillMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ProcKillMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcKillMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ProcKillMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcKillMsg..Init
inline void          ProcKillMsg_Init(ams::ProcKillMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcKillMsg.String  printfmt:Tuple
// func:ams.ProcKillMsg..Print
void                 ProcKillMsg_Print(ams::ProcKillMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcMsg
#pragma pack(push,1)
struct ProcMsg { // ams.ProcMsg: Message from/to a process
    u32                type;     //   701
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   proc;     //
    // var-length field ams.ProcMsg.payload starts here. access it with payload_Addr
    // func:ams.ProcMsg..Ctor
    inline               ProcMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcMsg.
// If not successful, quietly return NULL.
// func:ams.ProcMsg.base.Castdown
inline ams::ProcMsg* ProcMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ProcMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.ProcMsg.payload.Getary
algo::aryptr<char>   payload_Getary(ams::ProcMsg& parent) __attribute__((nothrow));
// func:ams.ProcMsg.payload.Addr
char*                payload_Addr(ams::ProcMsg& parent);
// Return number of elements in varlen field
// func:ams.ProcMsg.payload.N
inline u32           payload_N(const ams::ProcMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.ProcMsg.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(ams::ProcMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert payload to a string.
// Array is printed as a regular string.
// func:ams.ProcMsg.payload.Print
void                 payload_Print(ams::ProcMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.ProcMsg.payload_curs.Reset
inline void          ProcMsg_payload_curs_Reset(ProcMsg_payload_curs &curs, ams::ProcMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.ProcMsg.payload_curs.ValidQ
inline bool          ProcMsg_payload_curs_ValidQ(ProcMsg_payload_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.ProcMsg.payload_curs.Next
inline void          ProcMsg_payload_curs_Next(ProcMsg_payload_curs &curs) __attribute__((nothrow));
// item access
// func:ams.ProcMsg.payload_curs.Access
inline char&         ProcMsg_payload_curs_Access(ProcMsg_payload_curs &curs) __attribute__((nothrow));
// func:ams.ProcMsg..ReadFieldMaybe
bool                 ProcMsg_ReadFieldMaybe(ams::ProcMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ProcMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcMsg..ReadStrptrMaybe
bool                 ProcMsg_ReadStrptrMaybe(ams::ProcMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ProcMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ProcMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcMsg..Init
inline void          ProcMsg_Init(ams::ProcMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcMsg.String  printfmt:Tuple
// func:ams.ProcMsg..Print
void                 ProcMsg_Print(ams::ProcMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcReadMsg
#pragma pack(push,1)
struct ProcReadMsg { // ams.ProcReadMsg: Read process output
    u32                type;     //   702
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   proc;     //
    // var-length field ams.ProcReadMsg.until starts here. access it with until_Addr
    // func:ams.ProcReadMsg..Ctor
    inline               ProcReadMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcReadMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcReadMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcReadMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcReadMsg.
// If not successful, quietly return NULL.
// func:ams.ProcReadMsg.base.Castdown
inline ams::ProcReadMsg* ProcReadMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcReadMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ProcReadMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.ProcReadMsg.until.Getary
algo::aryptr<char>   until_Getary(ams::ProcReadMsg& parent) __attribute__((nothrow));
// func:ams.ProcReadMsg.until.Addr
char*                until_Addr(ams::ProcReadMsg& parent);
// Return number of elements in varlen field
// func:ams.ProcReadMsg.until.N
inline u32           until_N(const ams::ProcReadMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.ProcReadMsg.until.ReadStrptrMaybe
bool                 until_ReadStrptrMaybe(ams::ProcReadMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert until to a string.
// Array is printed as a regular string.
// func:ams.ProcReadMsg.until.Print
void                 until_Print(ams::ProcReadMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.ProcReadMsg.until_curs.Reset
inline void          ProcReadMsg_until_curs_Reset(ProcReadMsg_until_curs &curs, ams::ProcReadMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.ProcReadMsg.until_curs.ValidQ
inline bool          ProcReadMsg_until_curs_ValidQ(ProcReadMsg_until_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.ProcReadMsg.until_curs.Next
inline void          ProcReadMsg_until_curs_Next(ProcReadMsg_until_curs &curs) __attribute__((nothrow));
// item access
// func:ams.ProcReadMsg.until_curs.Access
inline char&         ProcReadMsg_until_curs_Access(ProcReadMsg_until_curs &curs) __attribute__((nothrow));
// func:ams.ProcReadMsg..ReadFieldMaybe
bool                 ProcReadMsg_ReadFieldMaybe(ams::ProcReadMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ProcReadMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcReadMsg..ReadStrptrMaybe
bool                 ProcReadMsg_ReadStrptrMaybe(ams::ProcReadMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcReadMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ProcReadMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcReadMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ProcReadMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcReadMsg..Init
inline void          ProcReadMsg_Init(ams::ProcReadMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcReadMsg.String  printfmt:Tuple
// func:ams.ProcReadMsg..Print
void                 ProcReadMsg_Print(ams::ProcReadMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcStartMsg
#pragma pack(push,1)
struct ProcStartMsg { // ams.ProcStartMsg: Start process
    u32                type;     //   700
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   proc;     //
    bool               pty;      //   false
    // var-length field ams.ProcStartMsg.cmd starts here. access it with cmd_Addr
    // func:ams.ProcStartMsg..Ctor
    inline               ProcStartMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcStartMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcStartMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcStartMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcStartMsg.
// If not successful, quietly return NULL.
// func:ams.ProcStartMsg.base.Castdown
inline ams::ProcStartMsg* ProcStartMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcStartMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ProcStartMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.ProcStartMsg.cmd.Getary
algo::aryptr<char>   cmd_Getary(ams::ProcStartMsg& parent) __attribute__((nothrow));
// func:ams.ProcStartMsg.cmd.Addr
char*                cmd_Addr(ams::ProcStartMsg& parent);
// Return number of elements in varlen field
// func:ams.ProcStartMsg.cmd.N
inline u32           cmd_N(const ams::ProcStartMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.ProcStartMsg.cmd.ReadStrptrMaybe
bool                 cmd_ReadStrptrMaybe(ams::ProcStartMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert cmd to a string.
// Array is printed as a regular string.
// func:ams.ProcStartMsg.cmd.Print
void                 cmd_Print(ams::ProcStartMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.ProcStartMsg.cmd_curs.Reset
inline void          ProcStartMsg_cmd_curs_Reset(ProcStartMsg_cmd_curs &curs, ams::ProcStartMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.ProcStartMsg.cmd_curs.ValidQ
inline bool          ProcStartMsg_cmd_curs_ValidQ(ProcStartMsg_cmd_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.ProcStartMsg.cmd_curs.Next
inline void          ProcStartMsg_cmd_curs_Next(ProcStartMsg_cmd_curs &curs) __attribute__((nothrow));
// item access
// func:ams.ProcStartMsg.cmd_curs.Access
inline char&         ProcStartMsg_cmd_curs_Access(ProcStartMsg_cmd_curs &curs) __attribute__((nothrow));
// func:ams.ProcStartMsg..ReadFieldMaybe
bool                 ProcStartMsg_ReadFieldMaybe(ams::ProcStartMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ProcStartMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcStartMsg..ReadStrptrMaybe
bool                 ProcStartMsg_ReadStrptrMaybe(ams::ProcStartMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcStartMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ProcStartMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcStartMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ProcStartMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcStartMsg..Init
inline void          ProcStartMsg_Init(ams::ProcStartMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcStartMsg.String  printfmt:Tuple
// func:ams.ProcStartMsg..Print
void                 ProcStartMsg_Print(ams::ProcStartMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcStatusMsg
#pragma pack(push,1)
struct ProcStatusMsg { // ams.ProcStatusMsg: Process status
    u32                type;     //   705
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   proc;     //
    algo::RnullStr50   status;   //
    // func:ams.ProcStatusMsg..Ctor
    inline               ProcStatusMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcStatusMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcStatusMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcStatusMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcStatusMsg.
// If not successful, quietly return NULL.
// func:ams.ProcStatusMsg.base.Castdown
inline ams::ProcStatusMsg* ProcStatusMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcStatusMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ProcStatusMsg& parent);

// func:ams.ProcStatusMsg..ReadFieldMaybe
bool                 ProcStatusMsg_ReadFieldMaybe(ams::ProcStatusMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcStatusMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcStatusMsg..ReadStrptrMaybe
bool                 ProcStatusMsg_ReadStrptrMaybe(ams::ProcStatusMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcStatusMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ProcStatusMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcStatusMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ProcStatusMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcStatusMsg..Init
inline void          ProcStatusMsg_Init(ams::ProcStatusMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcStatusMsg.String  printfmt:Tuple
// func:ams.ProcStatusMsg..Print
void                 ProcStatusMsg_Print(ams::ProcStatusMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.RemDirRecurseMsg
#pragma pack(push,1)
struct RemDirRecurseMsg { // ams.RemDirRecurseMsg: Message sent to process to terminate it
    u32    type;             //   633
    u32    length;           //   ssizeof(parent) + (0)
    bool   remove_topmost;   //   false
    // var-length field ams.RemDirRecurseMsg.pathname starts here. access it with pathname_Addr
    // func:ams.RemDirRecurseMsg..Ctor
    inline               RemDirRecurseMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.RemDirRecurseMsg.base.CopyOut
void                 parent_CopyOut(ams::RemDirRecurseMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of RemDirRecurseMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of RemDirRecurseMsg.
// If not successful, quietly return NULL.
// func:ams.RemDirRecurseMsg.base.Castdown
inline ams::RemDirRecurseMsg* RemDirRecurseMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.RemDirRecurseMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::RemDirRecurseMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.RemDirRecurseMsg.pathname.Getary
algo::aryptr<char>   pathname_Getary(ams::RemDirRecurseMsg& parent) __attribute__((nothrow));
// func:ams.RemDirRecurseMsg.pathname.Addr
char*                pathname_Addr(ams::RemDirRecurseMsg& parent);
// Return number of elements in varlen field
// func:ams.RemDirRecurseMsg.pathname.N
inline u32           pathname_N(const ams::RemDirRecurseMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.RemDirRecurseMsg.pathname.ReadStrptrMaybe
bool                 pathname_ReadStrptrMaybe(ams::RemDirRecurseMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert pathname to a string.
// Array is printed as a regular string.
// func:ams.RemDirRecurseMsg.pathname.Print
void                 pathname_Print(ams::RemDirRecurseMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.RemDirRecurseMsg.pathname_curs.Reset
inline void          RemDirRecurseMsg_pathname_curs_Reset(RemDirRecurseMsg_pathname_curs &curs, ams::RemDirRecurseMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.RemDirRecurseMsg.pathname_curs.ValidQ
inline bool          RemDirRecurseMsg_pathname_curs_ValidQ(RemDirRecurseMsg_pathname_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.RemDirRecurseMsg.pathname_curs.Next
inline void          RemDirRecurseMsg_pathname_curs_Next(RemDirRecurseMsg_pathname_curs &curs) __attribute__((nothrow));
// item access
// func:ams.RemDirRecurseMsg.pathname_curs.Access
inline char&         RemDirRecurseMsg_pathname_curs_Access(RemDirRecurseMsg_pathname_curs &curs) __attribute__((nothrow));
// func:ams.RemDirRecurseMsg..ReadFieldMaybe
bool                 RemDirRecurseMsg_ReadFieldMaybe(ams::RemDirRecurseMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::RemDirRecurseMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.RemDirRecurseMsg..ReadStrptrMaybe
bool                 RemDirRecurseMsg_ReadStrptrMaybe(ams::RemDirRecurseMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.RemDirRecurseMsg..GetMsgLength
inline i32           GetMsgLength(const ams::RemDirRecurseMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.RemDirRecurseMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::RemDirRecurseMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.RemDirRecurseMsg..Init
inline void          RemDirRecurseMsg_Init(ams::RemDirRecurseMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.RemDirRecurseMsg.String  printfmt:Tuple
// func:ams.RemDirRecurseMsg..Print
void                 RemDirRecurseMsg_Print(ams::RemDirRecurseMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ShmFlags
#pragma pack(push,1)
struct ShmFlags { // ams.ShmFlags
    u8   value;   //   0
    // func:ams.ShmFlags..Ctor
    inline               ShmFlags() __attribute__((nothrow));
    // func:ams.ShmFlags..FieldwiseCtor
    explicit inline               ShmFlags(u8 in_value) __attribute__((nothrow));
    // func:ams.ShmFlags..EnumCtor
    inline               ShmFlags(ams_ShmFlagsEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
// func:ams.ShmFlags.write.Get
inline bool          write_Get(const ams::ShmFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
// func:ams.ShmFlags.write.Set
inline void          write_Set(ams::ShmFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
// func:ams.ShmFlags.read.Get
inline bool          read_Get(const ams::ShmFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
// func:ams.ShmFlags.read.Set
inline void          read_Set(ams::ShmFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
// func:ams.ShmFlags.nonblock.Get
inline bool          nonblock_Get(const ams::ShmFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
// func:ams.ShmFlags.nonblock.Set
inline void          nonblock_Set(ams::ShmFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
// func:ams.ShmFlags.write_err.Get
inline bool          write_err_Get(const ams::ShmFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
// func:ams.ShmFlags.write_err.Set
inline void          write_err_Set(ams::ShmFlags& parent, bool rhs) __attribute__((nothrow));

// func:ams.ShmFlags..ReadFieldMaybe
bool                 ShmFlags_ReadFieldMaybe(ams::ShmFlags& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ShmFlags from an ascii string.
// func:ams.ShmFlags..ReadStrptrMaybe
bool                 ShmFlags_ReadStrptrMaybe(ams::ShmFlags &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ShmFlags..Init
inline void          ShmFlags_Init(ams::ShmFlags& parent);
// print string representation of ROW to string STR
// cfmt:ams.ShmFlags.String  printfmt:Bitset
// func:ams.ShmFlags..Print
void                 ShmFlags_Print(ams::ShmFlags row, algo::cstring& str) __attribute__((nothrow));
// func:ams.ShmFlags..GetAnon
algo::strptr         ShmFlags_GetAnon(ams::ShmFlags &parent, i32 idx) __attribute__((nothrow));

// --- ams.Shmtype
#pragma pack(push,1)
struct Shmtype { // ams.Shmtype
    u8   value;   //   0
    // func:ams.Shmtype..EqOp
    inline bool          operator ==(const ams::Shmtype &rhs) const __attribute__((nothrow));
    // func:ams.Shmtype..NeOp
    inline bool          operator !=(const ams::Shmtype &rhs) const __attribute__((nothrow));
    // define enum comparison operator to avoid ambiguity
    // func:ams.Shmtype..EqEnum
    inline bool          operator ==(ams_ShmtypeEnum rhs) const __attribute__((nothrow));
    // func:ams.Shmtype..Ctor
    inline               Shmtype() __attribute__((nothrow));
    // func:ams.Shmtype..FieldwiseCtor
    explicit inline               Shmtype(u8 in_value) __attribute__((nothrow));
    // func:ams.Shmtype..EnumCtor
    inline               Shmtype(ams_ShmtypeEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.Shmtype.value.GetEnum
inline ams_ShmtypeEnum value_GetEnum(const ams::Shmtype& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.Shmtype.value.SetEnum
inline void          value_SetEnum(ams::Shmtype& parent, ams_ShmtypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.Shmtype.value.ToCstr
const char*          value_ToCstr(const ams::Shmtype& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.Shmtype.value.Print
void                 value_Print(const ams::Shmtype& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.Shmtype.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::Shmtype& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.Shmtype.value.SetStrptr
void                 value_SetStrptr(ams::Shmtype& parent, algo::strptr rhs, ams_ShmtypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.Shmtype.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::Shmtype& parent, algo::strptr rhs) __attribute__((nothrow));

// func:ams.Shmtype..Hash
inline u32           Shmtype_Hash(u32 prev, ams::Shmtype rhs) __attribute__((nothrow));
// Read fields of ams::Shmtype from an ascii string.
// The format of the string is the format of the ams::Shmtype's only field
// func:ams.Shmtype..ReadStrptrMaybe
bool                 Shmtype_ReadStrptrMaybe(ams::Shmtype &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.Shmtype..Cmp
inline i32           Shmtype_Cmp(ams::Shmtype lhs, ams::Shmtype rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.Shmtype..Init
inline void          Shmtype_Init(ams::Shmtype& parent);
// func:ams.Shmtype..Eq
inline bool          Shmtype_Eq(ams::Shmtype lhs, ams::Shmtype rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.Shmtype.String  printfmt:Raw
// func:ams.Shmtype..Print
void                 Shmtype_Print(ams::Shmtype row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ShmId
#pragma pack(push,1)
struct ShmId { // ams.ShmId: Host-unique stream ID. E.g. proc1-0.out-0
    ams::ProcId    proc_id;   // Writer process ID
    ams::Shmtype   shmtype;   // Stream type ID
    u8             index;     //   0  Stream index
    // func:ams.ShmId..EqOp
    inline bool          operator ==(const ams::ShmId &rhs) const __attribute__((nothrow));
    // func:ams.ShmId..NeOp
    inline bool          operator !=(const ams::ShmId &rhs) const __attribute__((nothrow));
    // func:ams.ShmId..Ctor
    inline               ShmId() __attribute__((nothrow));
    // func:ams.ShmId..FieldwiseCtor
    explicit inline               ShmId(ams::ProcId in_proc_id, ams::Shmtype in_shmtype, u8 in_index) __attribute__((nothrow));
};
#pragma pack(pop)

// func:ams.ShmId..Hash
inline u32           ShmId_Hash(u32 prev, ams::ShmId rhs) __attribute__((nothrow));
// func:ams.ShmId..ReadFieldMaybe
bool                 ShmId_ReadFieldMaybe(ams::ShmId& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ShmId from an ascii string.
// The format of the string is a string with separated values
// func:ams.ShmId..ReadStrptrMaybe
bool                 ShmId_ReadStrptrMaybe(ams::ShmId &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.ShmId..Cmp
inline i32           ShmId_Cmp(ams::ShmId lhs, ams::ShmId rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ShmId..Init
inline void          ShmId_Init(ams::ShmId& parent);
// func:ams.ShmId..Eq
inline bool          ShmId_Eq(ams::ShmId lhs, ams::ShmId rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.ShmId.String  printfmt:Sep
// func:ams.ShmId..Print
void                 ShmId_Print(ams::ShmId row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ShmemberFlags
#pragma pack(push,1)
struct ShmemberFlags { // ams.ShmemberFlags: Shm member flags
    u16   value;   //   0  Shm member flags
    // func:ams.ShmemberFlags..EqOp
    inline bool          operator ==(const ams::ShmemberFlags &rhs) const __attribute__((nothrow));
    // func:ams.ShmemberFlags..NeOp
    inline bool          operator !=(const ams::ShmemberFlags &rhs) const __attribute__((nothrow));
    // define enum comparison operator to avoid ambiguity
    // func:ams.ShmemberFlags..EqEnum
    inline bool          operator ==(ams_ShmemberFlagsEnum rhs) const __attribute__((nothrow));
    // func:ams.ShmemberFlags..Ctor
    inline               ShmemberFlags() __attribute__((nothrow));
    // func:ams.ShmemberFlags..FieldwiseCtor
    explicit inline               ShmemberFlags(u16 in_value) __attribute__((nothrow));
    // func:ams.ShmemberFlags..EnumCtor
    inline               ShmemberFlags(ams_ShmemberFlagsEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Retrieve bitfield from value of field value
//    1 bits starting at bit 0.
// func:ams.ShmemberFlags.r.Get
inline bool          r_Get(const ams::ShmemberFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 0.
// func:ams.ShmemberFlags.r.Set
inline void          r_Set(ams::ShmemberFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
// func:ams.ShmemberFlags.w.Get
inline bool          w_Get(const ams::ShmemberFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
// func:ams.ShmemberFlags.w.Set
inline void          w_Set(ams::ShmemberFlags& parent, bool rhs) __attribute__((nothrow));

// func:ams.ShmemberFlags..Hash
inline u32           ShmemberFlags_Hash(u32 prev, ams::ShmemberFlags rhs) __attribute__((nothrow));
// func:ams.ShmemberFlags..ReadFieldMaybe
bool                 ShmemberFlags_ReadFieldMaybe(ams::ShmemberFlags& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ShmemberFlags from an ascii string.
// func:ams.ShmemberFlags..ReadStrptrMaybe
bool                 ShmemberFlags_ReadStrptrMaybe(ams::ShmemberFlags &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.ShmemberFlags..Cmp
inline i32           ShmemberFlags_Cmp(ams::ShmemberFlags lhs, ams::ShmemberFlags rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ShmemberFlags..Init
inline void          ShmemberFlags_Init(ams::ShmemberFlags& parent);
// func:ams.ShmemberFlags..Eq
inline bool          ShmemberFlags_Eq(ams::ShmemberFlags lhs, ams::ShmemberFlags rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.ShmemberFlags.String  printfmt:Bitset
// func:ams.ShmemberFlags..Print
void                 ShmemberFlags_Print(ams::ShmemberFlags row, algo::cstring& str) __attribute__((nothrow));
// func:ams.ShmemberFlags..GetAnon
algo::strptr         ShmemberFlags_GetAnon(ams::ShmemberFlags &parent, i32 idx) __attribute__((nothrow));

// --- ams.ShmemberId
#pragma pack(push,1)
struct ShmemberId { // ams.ShmemberId: Shm/Process - member ID for AMS SHM
    ams::ShmId           shm_id;    // Stream ID
    ams::ProcId          proc_id;   // Process ID
    ams::ShmemberFlags   flags;     //   0
    // func:ams.ShmemberId..EqOp
    inline bool          operator ==(const ams::ShmemberId &rhs) const __attribute__((nothrow));
    // func:ams.ShmemberId..NeOp
    inline bool          operator !=(const ams::ShmemberId &rhs) const __attribute__((nothrow));
    // func:ams.ShmemberId..Ctor
    inline               ShmemberId() __attribute__((nothrow));
    // func:ams.ShmemberId..FieldwiseCtor
    explicit inline               ShmemberId(ams::ShmId in_shm_id, ams::ProcId in_proc_id, ams::ShmemberFlags in_flags) __attribute__((nothrow));
};
#pragma pack(pop)

// func:ams.ShmemberId..Hash
inline u32           ShmemberId_Hash(u32 prev, ams::ShmemberId rhs) __attribute__((nothrow));
// func:ams.ShmemberId..ReadFieldMaybe
bool                 ShmemberId_ReadFieldMaybe(ams::ShmemberId& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ShmemberId from an ascii string.
// The format of the string is a string with separated values
// func:ams.ShmemberId..ReadStrptrMaybe
bool                 ShmemberId_ReadStrptrMaybe(ams::ShmemberId &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.ShmemberId..Cmp
inline i32           ShmemberId_Cmp(ams::ShmemberId lhs, ams::ShmemberId rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ShmemberId..Init
inline void          ShmemberId_Init(ams::ShmemberId& parent);
// func:ams.ShmemberId..Eq
inline bool          ShmemberId_Eq(ams::ShmemberId lhs, ams::ShmemberId rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.ShmemberId.String  printfmt:Sep
// func:ams.ShmemberId..Print
void                 ShmemberId_Print(ams::ShmemberId row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ShmHbMsg
#pragma pack(push,1)
struct ShmHbMsg { // ams.ShmHbMsg: Shm heartbeat
    u32               type;       //   3
    u32               length;     //   ssizeof(parent) + (0)
    ams::ShmemberId   shmember;   // Primary key
    u64               off;        //   0  Read/write position
    u32               wbudget;    //   0  Max. offset for writing
    // func:ams.ShmHbMsg..Ctor
    inline               ShmHbMsg() __attribute__((nothrow));
    // func:ams.ShmHbMsg..FieldwiseCtor
    explicit inline               ShmHbMsg(ams::ShmemberId in_shmember, u64 in_off, u32 in_wbudget) __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ShmHbMsg.base.CopyOut
void                 parent_CopyOut(ams::ShmHbMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ShmHbMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ShmHbMsg.
// If not successful, quietly return NULL.
// func:ams.ShmHbMsg.base.Castdown
inline ams::ShmHbMsg* ShmHbMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ShmHbMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::ShmHbMsg& parent);

// func:ams.ShmHbMsg..ReadFieldMaybe
bool                 ShmHbMsg_ReadFieldMaybe(ams::ShmHbMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ShmHbMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ShmHbMsg..ReadStrptrMaybe
bool                 ShmHbMsg_ReadStrptrMaybe(ams::ShmHbMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ShmHbMsg..GetMsgLength
inline i32           GetMsgLength(const ams::ShmHbMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ShmHbMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::ShmHbMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ShmHbMsg..Init
inline void          ShmHbMsg_Init(ams::ShmHbMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ShmHbMsg.String  printfmt:Tuple
// func:ams.ShmHbMsg..Print
void                 ShmHbMsg_Print(ams::ShmHbMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.Shmmsg
#pragma pack(push,1)
struct Shmmsg { // ams.Shmmsg: Sequenced message on a shm
    u32                    type;        //   10
    u32                    length;      //   ssizeof(parent) + (0)
    ams::ShmId             shm_id;      //
    u64                    off;         //   0
    u64                    tstamp;      //   0
    // ams::MsgHeader      payload[];                                    optional field
    // func:ams.Shmmsg..Ctor
    inline               Shmmsg() __attribute__((nothrow));
    // func:ams.Shmmsg..FieldwiseCtor
    explicit inline               Shmmsg(ams::ShmId in_shm_id, u64 in_off, u64 in_tstamp) __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.Shmmsg.base.CopyOut
void                 parent_CopyOut(ams::Shmmsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of Shmmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Shmmsg.
// If not successful, quietly return NULL.
// func:ams.Shmmsg.base.Castdown
inline ams::Shmmsg*  Shmmsg_Castdown(ams::MsgHeader &hdr);
// func:ams.Shmmsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::Shmmsg& parent);

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
// func:ams.Shmmsg.payload.Get
inline ams::MsgHeader* payload_Get(ams::Shmmsg& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:ams.Shmmsg.payload.Getary
algo::aryptr<u8>     payload_Getary(ams::Shmmsg& parent) __attribute__((nothrow));
// func:ams.Shmmsg.payload.Print
void                 payload_Print(ams::Shmmsg& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.Shmmsg.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(ams::Shmmsg &parent, algo::strptr in_str) __attribute__((nothrow));

// func:ams.Shmmsg..ReadFieldMaybe
bool                 Shmmsg_ReadFieldMaybe(ams::Shmmsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::Shmmsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.Shmmsg..ReadStrptrMaybe
bool                 Shmmsg_ReadStrptrMaybe(ams::Shmmsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.Shmmsg..GetMsgLength
inline i32           GetMsgLength(const ams::Shmmsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.Shmmsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::Shmmsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.Shmmsg..Init
inline void          Shmmsg_Init(ams::Shmmsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.Shmmsg.String  printfmt:Tuple
// func:ams.Shmmsg..Print
void                 Shmmsg_Print(ams::Shmmsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.TerminateMsg
#pragma pack(push,1)
struct TerminateMsg { // ams.TerminateMsg: Message sent to process to terminate it
    u32   type;     //   352
    u32   length;   //   ssizeof(parent) + (0)
    // func:ams.TerminateMsg..Ctor
    inline               TerminateMsg() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.TerminateMsg.base.CopyOut
void                 parent_CopyOut(ams::TerminateMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of TerminateMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TerminateMsg.
// If not successful, quietly return NULL.
// func:ams.TerminateMsg.base.Castdown
inline ams::TerminateMsg* TerminateMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.TerminateMsg.base.Castbase
inline ams::MsgHeader& Castbase(ams::TerminateMsg& parent);

// func:ams.TerminateMsg..ReadFieldMaybe
bool                 TerminateMsg_ReadFieldMaybe(ams::TerminateMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::TerminateMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.TerminateMsg..ReadStrptrMaybe
bool                 TerminateMsg_ReadStrptrMaybe(ams::TerminateMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.TerminateMsg..GetMsgLength
inline i32           GetMsgLength(const ams::TerminateMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.TerminateMsg..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::TerminateMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.TerminateMsg..Init
inline void          TerminateMsg_Init(ams::TerminateMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.TerminateMsg.String  printfmt:Tuple
// func:ams.TerminateMsg..Print
void                 TerminateMsg_Print(ams::TerminateMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.UdpFrame
#pragma pack(push,1)
struct UdpFrame { // ams.UdpFrame: sniffer-captured ethernet frame
    u32            type;        //   2
    u32            length;      //   ssizeof(parent) + (0)
    algo::UnTime   timestamp;   // Timestamp
    ietf::Ipv4     src_ip;      // Source IP
    ietf::Ipv4     dst_ip;      // Destination IP
    u16            src_port;    //   0  Source UDP port
    u16            dst_port;    //   0  Destination UDP port
    // var-length field ams.UdpFrame.payload starts here. access it with payload_Addr
    // func:ams.UdpFrame..Ctor
    inline               UdpFrame() __attribute__((nothrow));
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.UdpFrame.header.CopyOut
void                 parent_CopyOut(ams::UdpFrame &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of UdpFrame by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of UdpFrame.
// If not successful, quietly return NULL.
// func:ams.UdpFrame.header.Castdown
inline ams::UdpFrame* UdpFrame_Castdown(ams::MsgHeader &hdr);
// func:ams.UdpFrame.header.Castbase
inline ams::MsgHeader& Castbase(ams::UdpFrame& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.UdpFrame.payload.Getary
algo::aryptr<u8>     payload_Getary(ams::UdpFrame& parent) __attribute__((nothrow));
// func:ams.UdpFrame.payload.Addr
u8*                  payload_Addr(ams::UdpFrame& parent);
// Return number of elements in varlen field
// func:ams.UdpFrame.payload.N
inline u32           payload_N(const ams::UdpFrame& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert payload to a string.
// Array is printed as a regular string.
// func:ams.UdpFrame.payload.Print
void                 payload_Print(ams::UdpFrame& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.UdpFrame.payload_curs.Reset
inline void          UdpFrame_payload_curs_Reset(UdpFrame_payload_curs &curs, ams::UdpFrame &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.UdpFrame.payload_curs.ValidQ
inline bool          UdpFrame_payload_curs_ValidQ(UdpFrame_payload_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.UdpFrame.payload_curs.Next
inline void          UdpFrame_payload_curs_Next(UdpFrame_payload_curs &curs) __attribute__((nothrow));
// item access
// func:ams.UdpFrame.payload_curs.Access
inline u8&           UdpFrame_payload_curs_Access(UdpFrame_payload_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.UdpFrame..GetMsgLength
inline i32           GetMsgLength(const ams::UdpFrame& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.UdpFrame..GetMsgMemptr
inline algo::memptr  GetMsgMemptr(const ams::UdpFrame& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.UdpFrame..Init
inline void          UdpFrame_Init(ams::UdpFrame& parent);
// print string representation of ROW to string STR
// cfmt:ams.UdpFrame.String  printfmt:Tuple
// func:ams.UdpFrame..Print
void                 UdpFrame_Print(ams::UdpFrame& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace ams { // gen:ns_curstext

struct ExpectMsg_text_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    ExpectMsg_text_curs() { ptr=NULL; length=0; index=0; }
};


struct InputLineMsg_payload_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    InputLineMsg_payload_curs() { ptr=NULL; length=0; index=0; }
};


struct LogMsg_logcat_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    LogMsg_logcat_curs() { ptr=NULL; length=0; index=0; }
};


struct LogMsg_text_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    LogMsg_text_curs() { ptr=NULL; length=0; index=0; }
};


struct MsgBlock_messages_curs {// cursor
    typedef u8 ChildType;
    u8 *ptr;
    int length;
    int index;
    MsgBlock_messages_curs() { ptr=NULL; length=0; index=0; }
};


struct ProcMsg_payload_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    ProcMsg_payload_curs() { ptr=NULL; length=0; index=0; }
};


struct ProcReadMsg_until_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    ProcReadMsg_until_curs() { ptr=NULL; length=0; index=0; }
};


struct ProcStartMsg_cmd_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    ProcStartMsg_cmd_curs() { ptr=NULL; length=0; index=0; }
};


struct RemDirRecurseMsg_pathname_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    RemDirRecurseMsg_pathname_curs() { ptr=NULL; length=0; index=0; }
};


struct UdpFrame_payload_curs {// cursor
    typedef u8 ChildType;
    u8 *ptr;
    int length;
    int index;
    UdpFrame_payload_curs() { ptr=NULL; length=0; index=0; }
};

} // gen:ns_curstext
namespace ams { // gen:ns_func
// func:ams...StaticCheck
void                 StaticCheck();
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
// func:ams.MsgHeaderMsgs..Print
bool                 MsgHeaderMsgs_Print(algo::cstring &str, ams::MsgHeader &msg, u32 msg_len);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:ams.MsgHeaderMsgs..ReadStrptr
ams::MsgHeaderMsgsCase MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:ams.MsgHeaderMsgs..ReadStrptrMaybe
bool                 MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Construct a new ams::LogMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...LogMsg_FmtByteAry
ams::LogMsg *        LogMsg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc_id, algo::SchedTime tstamp, algo::aryptr<char > logcat, algo::aryptr<char > text);
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...MsgBlock_FmtByteAry
ams::MsgBlock *      MsgBlock_FmtByteAry(algo::ByteAry &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages);
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:ams...MsgBlock_FmtMemptr
ams::MsgBlock *      MsgBlock_FmtMemptr(algo::memptr &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages);
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...UdpFrame_FmtByteAry
ams::UdpFrame *      UdpFrame_FmtByteAry(algo::ByteAry &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload);
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:ams...UdpFrame_FmtMemptr
ams::UdpFrame *      UdpFrame_FmtMemptr(algo::memptr &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload);
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const ams::ExpectMsg &row);// cfmt:ams.ExpectMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::FieldId &row);// cfmt:ams.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::Proctype &row);// cfmt:ams.Proctype.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcId &row);// cfmt:ams.ProcId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::InputLineMsg &row);// cfmt:ams.InputLineMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::LogMsg &row);// cfmt:ams.LogMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::MsgBlock &row);// cfmt:ams.MsgBlock.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::MsgHeader &row);// cfmt:ams.MsgHeader.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcEofMsg &row);// cfmt:ams.ProcEofMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcKillMsg &row);// cfmt:ams.ProcKillMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcMsg &row);// cfmt:ams.ProcMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcReadMsg &row);// cfmt:ams.ProcReadMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcStartMsg &row);// cfmt:ams.ProcStartMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcStatusMsg &row);// cfmt:ams.ProcStatusMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ShmFlags &row);// cfmt:ams.ShmFlags.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::Shmtype &row);// cfmt:ams.Shmtype.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ShmId &row);// cfmt:ams.ShmId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ShmemberFlags &row);// cfmt:ams.ShmemberFlags.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ShmemberId &row);// cfmt:ams.ShmemberId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ShmHbMsg &row);// cfmt:ams.ShmHbMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::Shmmsg &row);// cfmt:ams.Shmmsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::UdpFrame &row);// cfmt:ams.UdpFrame.String
}
