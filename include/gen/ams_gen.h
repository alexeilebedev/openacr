//
// include/gen/ams_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/ietf_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- ams_ProcTypeEnum

enum ams_ProcTypeEnum {           // ams.ProcType.value
     ams_ProcType_0         = 0   // No process
    ,ams_ProcType_amstest   = 5   // Ams testing
};

enum { ams_ProcTypeEnum_N = 2 };


// --- ams_StreamTypeEnum

enum ams_StreamTypeEnum {         // ams.StreamType.value
     ams_StreamType_0       = 0   // No stream
    ,ams_StreamType_ctl     = 1   // AMS control messages
    ,ams_StreamType_io      = 5   // Messages intended for file output
    ,ams_StreamType_out     = 2   // Log messages, alarms
    ,ams_StreamType_trace   = 6   // Trace messages
};

enum { ams_StreamTypeEnum_N = 5 };


// --- ams_FieldIdEnum

enum ams_FieldIdEnum {                 // ams.FieldId.value
     ams_FieldId_base            = 0
    ,ams_FieldId_type            = 1
    ,ams_FieldId_length          = 2
    ,ams_FieldId_updated_after   = 3
    ,ams_FieldId_stream_id       = 4
    ,ams_FieldId_proc_id         = 5
    ,ams_FieldId_text            = 6
    ,ams_FieldId_time            = 7
    ,ams_FieldId_payload         = 8
    ,ams_FieldId_logcat          = 9
    ,ams_FieldId_tstamp          = 10
    ,ams_FieldId_mode            = 11
    ,ams_FieldId_member          = 12
    ,ams_FieldId_pos             = 13
    ,ams_FieldId_data            = 14
    ,ams_FieldId_proc_type       = 15
    ,ams_FieldId_procidx         = 16
    ,ams_FieldId_value           = 17
    ,ams_FieldId_seqmsg_id       = 18
    ,ams_FieldId_tsc             = 19
    ,ams_FieldId_seq             = 20
    ,ams_FieldId_off             = 21
    ,ams_FieldId_write           = 22
    ,ams_FieldId_read            = 23
    ,ams_FieldId_nonblock        = 24
    ,ams_FieldId_trace_read      = 25
    ,ams_FieldId_trace_write     = 26
    ,ams_FieldId_write_err       = 27
    ,ams_FieldId_trace_text      = 28
    ,ams_FieldId_wbudget         = 29
    ,ams_FieldId_stream_type     = 30
    ,ams_FieldId_streamidx       = 31
    ,ams_FieldId_proc            = 32
    ,ams_FieldId_trace           = 33
    ,ams_FieldId_part            = 34
};

enum { ams_FieldIdEnum_N = 35 };


// --- ams_Member_mode_Enum

enum ams_Member_mode_Enum {       // ams.Member.mode
     ams_Member_mode_r       = 0
    ,ams_Member_mode_w       = 1
};

enum { ams_Member_mode_Enum_N = 2 };


// --- ams_MsgHeader_type_Enum

enum ams_MsgHeader_type_Enum {                           // ams.MsgHeader.type
     ams_MsgHeader_type_ams_AlarmSyncMsg         = 18
    ,ams_MsgHeader_type_ams_DfltStream           = 21    // Set default stream for subsequent messages
    ,ams_MsgHeader_type_ams_DumpStreamTableMsg   = 12    // Remove process from process group
    ,ams_MsgHeader_type_ams_ExpectMsg            = 395   // Pause reading until some output is produced
    ,ams_MsgHeader_type_ams_HeartbeatMsg         = 16
    ,ams_MsgHeader_type_ams_InputLineMsg         = 22    // Unrecognized input line
    ,ams_MsgHeader_type_ams_LogMsg               = 6     // Log message
    ,ams_MsgHeader_type_ams_MsgBlock             = 1     // A block of messages from ams commit file
    ,ams_MsgHeader_type_ams_OpenMsg              = 7     // Open stream for reading
    ,ams_MsgHeader_type_ams_PrlogMsg             = 229
    ,ams_MsgHeader_type_ams_ProcAddMsg           = 4     // Add process to process group
    ,ams_MsgHeader_type_ams_ProcRemoveMsg        = 5     // Remove process from process group
    ,ams_MsgHeader_type_ams_Seqmsg               = 10    // Sequenced stream message
    ,ams_MsgHeader_type_ams_SeqmsgTrace          = 11    // Message used to trace reading/writing seqmsgs
    ,ams_MsgHeader_type_ams_StreamHbMsg          = 3     // Stream heartbeat
    ,ams_MsgHeader_type_ams_TerminateMsg         = 352   // Message sent to process to terminate it
    ,ams_MsgHeader_type_ams_Trace2Msg            = 108   // Trace2 message
    ,ams_MsgHeader_type_ams_TraceInfo2Msg        = 109   // Trace info message
    ,ams_MsgHeader_type_ams_TraceInfoMsg         = 9     // Trace info message
    ,ams_MsgHeader_type_ams_TraceMsg             = 8     // Trace message
    ,ams_MsgHeader_type_ams_UdpFrame             = 2     // sniffer-captured ethernet frame
    ,ams_MsgHeader_type_fm_AlarmMsg              = 17
};

enum { ams_MsgHeader_type_Enum_N = 22 };


// --- ams_MsgHeaderMsgsCaseEnum

enum ams_MsgHeaderMsgsCaseEnum {                           // ams.MsgHeaderMsgsCase.value
     ams_MsgHeaderMsgsCase_ams_AlarmSyncMsg         = 18
    ,ams_MsgHeaderMsgsCase_ams_DfltStream           = 21
    ,ams_MsgHeaderMsgsCase_ams_DumpStreamTableMsg   = 12
    ,ams_MsgHeaderMsgsCase_ams_ExpectMsg            = 395
    ,ams_MsgHeaderMsgsCase_ams_HeartbeatMsg         = 16
    ,ams_MsgHeaderMsgsCase_ams_InputLineMsg         = 22
    ,ams_MsgHeaderMsgsCase_ams_LogMsg               = 6
    ,ams_MsgHeaderMsgsCase_ams_MsgBlock             = 1
    ,ams_MsgHeaderMsgsCase_ams_OpenMsg              = 7
    ,ams_MsgHeaderMsgsCase_ams_PrlogMsg             = 229
    ,ams_MsgHeaderMsgsCase_ams_ProcAddMsg           = 4
    ,ams_MsgHeaderMsgsCase_ams_ProcRemoveMsg        = 5
    ,ams_MsgHeaderMsgsCase_ams_Seqmsg               = 10
    ,ams_MsgHeaderMsgsCase_ams_SeqmsgTrace          = 11
    ,ams_MsgHeaderMsgsCase_ams_StreamHbMsg          = 3
    ,ams_MsgHeaderMsgsCase_ams_TerminateMsg         = 352
    ,ams_MsgHeaderMsgsCase_ams_Trace2Msg            = 108
    ,ams_MsgHeaderMsgsCase_ams_TraceInfo2Msg        = 109
    ,ams_MsgHeaderMsgsCase_ams_TraceInfoMsg         = 9
    ,ams_MsgHeaderMsgsCase_ams_TraceMsg             = 8
    ,ams_MsgHeaderMsgsCase_ams_UdpFrame             = 2
    ,ams_MsgHeaderMsgsCase_fm_AlarmMsg              = 17
};

enum { ams_MsgHeaderMsgsCaseEnum_N = 22 };


// --- ams_SeqmsgTrace_mode_Enum

enum ams_SeqmsgTrace_mode_Enum {       // ams.SeqmsgTrace.mode
     ams_SeqmsgTrace_mode_r       = 0
    ,ams_SeqmsgTrace_mode_w       = 1
};

enum { ams_SeqmsgTrace_mode_Enum_N = 2 };


// --- ams_StreamFlagsEnum

enum ams_StreamFlagsEnum {                        // ams.StreamFlags.value
     ams_StreamFlags_write         = (u8(1)<<1)   // ams.StreamFlags.write
    ,ams_StreamFlags_read          = (u8(1)<<2)   // ams.StreamFlags.read
    ,ams_StreamFlags_nonblock      = (u8(1)<<3)   // ams.StreamFlags.nonblock
    ,ams_StreamFlags_trace_read    = (u8(1)<<4)   // ams.StreamFlags.trace_read
    ,ams_StreamFlags_trace_write   = (u8(1)<<5)   // ams.StreamFlags.trace_write
    ,ams_StreamFlags_write_err     = (u8(1)<<6)   // ams.StreamFlags.write_err
    ,ams_StreamFlags_trace_text    = (u8(1)<<7)   // ams.StreamFlags.trace_text
};

enum { ams_StreamFlagsEnum_N = 7 };

namespace ams { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace ams { // gen:ns_tclass_field
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace ams { struct MsgHeader; }
namespace ams { struct AlarmSyncMsg; }
namespace ams { struct DfltStream; }
namespace ams { struct DumpStreamTableMsg; }
namespace ams { struct ExpectMsg; }
namespace ams { struct HeartbeatMsg; }
namespace ams { struct InputLineMsg; }
namespace ams { struct LogMsg; }
namespace ams { struct MsgBlock; }
namespace ams { struct OpenMsg; }
namespace ams { struct PrlogMsg; }
namespace ams { struct ProcAddMsg; }
namespace ams { struct ProcRemoveMsg; }
namespace ams { struct Seqmsg; }
namespace ams { struct SeqmsgTrace; }
namespace ams { struct StreamHbMsg; }
namespace ams { struct TerminateMsg; }
namespace ams { struct Trace2Msg; }
namespace ams { struct TraceInfo2Msg; }
namespace ams { struct TraceInfoMsg; }
namespace ams { struct TraceMsg; }
namespace ams { struct UdpFrame; }
namespace fm { struct AlarmMsg; }
namespace ams { struct ProcId; }
namespace ams { struct SeqmsgId; }
namespace ietf { struct Ipv4; }
namespace ams { struct ExpectMsg_text_curs; }
namespace ams { struct InputLineMsg_payload_curs; }
namespace ams { struct LogMsg_text_curs; }
namespace ams { struct MsgBlock_messages_curs; }
namespace ams { struct Trace2Msg_data_curs; }
namespace ams { struct TraceInfo2Msg_data_curs; }
namespace ams { struct TraceInfoMsg_data_curs; }
namespace ams { struct TraceMsg_data_curs; }
namespace ams { struct UdpFrame_payload_curs; }
namespace ams { struct ProcType; }
namespace ams { struct StreamType; }
namespace ams { struct StreamId; }
namespace ams { struct FieldId; }
namespace ams { struct Member; }
namespace ams { struct MsgHeaderMsgsCase; }
namespace ams { struct MsgHeader_curs; }
namespace ams { struct StreamPos; }
namespace ams { struct StreamFlags; }
namespace ams { // gen:ns_size_enums

// sizes types appearing as Opt or Varlen; these need to be here
// to allow inline implementations of _Get functions and avoid
// a circular dependency between headers
enum {
    sizeof_ams_MsgHeader = 8
};
} // gen:ns_size_enums
namespace ams { // gen:ns_print_struct

// --- ams.AlarmSyncMsg
#pragma pack(push,1)
struct AlarmSyncMsg { // ams.AlarmSyncMsg
    u32            type;            //   18
    u32            length;          //   ssizeof(parent) + (0)
    algo::UnTime   updated_after;   //
    explicit AlarmSyncMsg(algo::UnTime                   in_updated_after);
    AlarmSyncMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.AlarmSyncMsg.base.CopyOut
void                 parent_CopyOut(ams::AlarmSyncMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of AlarmSyncMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of AlarmSyncMsg.
// If not successful, quietly return NULL.
// func:ams.AlarmSyncMsg.base.Castdown
ams::AlarmSyncMsg*   AlarmSyncMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.AlarmSyncMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::AlarmSyncMsg& parent);

// func:ams.AlarmSyncMsg..ReadFieldMaybe
bool                 AlarmSyncMsg_ReadFieldMaybe(ams::AlarmSyncMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::AlarmSyncMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.AlarmSyncMsg..ReadStrptrMaybe
bool                 AlarmSyncMsg_ReadStrptrMaybe(ams::AlarmSyncMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.AlarmSyncMsg..GetMsgLength
i32                  GetMsgLength(const ams::AlarmSyncMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.AlarmSyncMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::AlarmSyncMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.AlarmSyncMsg..Init
void                 AlarmSyncMsg_Init(ams::AlarmSyncMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.AlarmSyncMsg.String  printfmt:Tuple
// func:ams.AlarmSyncMsg..Print
void                 AlarmSyncMsg_Print(ams::AlarmSyncMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcType
#pragma pack(push,1)
struct ProcType { // ams.ProcType: StreamID + Sequence number
    u8   value;   //   0
    explicit ProcType(u8                             in_value);
    ProcType(ams_ProcTypeEnum arg);
    bool operator ==(const ams::ProcType &rhs) const;
    bool operator !=(const ams::ProcType &rhs) const;
    bool operator ==(ams_ProcTypeEnum rhs) const;
    ProcType();
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.ProcType.value.GetEnum
ams_ProcTypeEnum     value_GetEnum(const ams::ProcType& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.ProcType.value.SetEnum
void                 value_SetEnum(ams::ProcType& parent, ams_ProcTypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.ProcType.value.ToCstr
const char*          value_ToCstr(const ams::ProcType& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.ProcType.value.Print
void                 value_Print(const ams::ProcType& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.ProcType.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::ProcType& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.ProcType.value.SetStrptr
void                 value_SetStrptr(ams::ProcType& parent, algo::strptr rhs, ams_ProcTypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.ProcType.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::ProcType& parent, algo::strptr rhs) __attribute__((nothrow));

// func:ams.ProcType..Hash
u32                  ProcType_Hash(u32 prev, ams::ProcType rhs) __attribute__((nothrow));
// Read fields of ams::ProcType from an ascii string.
// The format of the string is the format of the ams::ProcType's only field
// func:ams.ProcType..ReadStrptrMaybe
bool                 ProcType_ReadStrptrMaybe(ams::ProcType &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.ProcType..Cmp
i32                  ProcType_Cmp(ams::ProcType lhs, ams::ProcType rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcType..Init
void                 ProcType_Init(ams::ProcType& parent);
// func:ams.ProcType..Eq
bool                 ProcType_Eq(ams::ProcType lhs, ams::ProcType rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.ProcType.String  printfmt:Raw
// func:ams.ProcType..Print
void                 ProcType_Print(ams::ProcType row, algo::cstring& str) __attribute__((nothrow));
// define enum comparison operator to avoid ambiguity
// func:ams.ProcType..EqEnum
bool                 ProcType_EqEnum(ams::ProcType lhs, ams_ProcTypeEnum rhs) __attribute__((nothrow));

// --- ams.ProcId
#pragma pack(push,1)
struct ProcId { // ams.ProcId: Local process id, such as proc1-0, proc2-1 etc
    ams::ProcType   proc_type;   // Writer process ID
    u8              procidx;     //   0  Writer process index
    explicit ProcId(ams::ProcType                  in_proc_type
        ,u8                             in_procidx);
    bool operator ==(const ams::ProcId &rhs) const;
    bool operator !=(const ams::ProcId &rhs) const;
    ProcId();
};
#pragma pack(pop)

// func:ams.ProcId..Hash
u32                  ProcId_Hash(u32 prev, ams::ProcId rhs) __attribute__((nothrow));
// func:ams.ProcId..ReadFieldMaybe
bool                 ProcId_ReadFieldMaybe(ams::ProcId& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcId from an ascii string.
// The format of the string is a string with separated values
// func:ams.ProcId..ReadStrptrMaybe
bool                 ProcId_ReadStrptrMaybe(ams::ProcId &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.ProcId..Cmp
i32                  ProcId_Cmp(ams::ProcId lhs, ams::ProcId rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcId..Init
void                 ProcId_Init(ams::ProcId& parent);
// func:ams.ProcId..Eq
bool                 ProcId_Eq(ams::ProcId lhs, ams::ProcId rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.ProcId.String  printfmt:Sep
// func:ams.ProcId..Print
void                 ProcId_Print(ams::ProcId row, algo::cstring& str) __attribute__((nothrow));

// --- ams.StreamType
#pragma pack(push,1)
struct StreamType { // ams.StreamType: StreamID + Sequence number
    u8   value;   //   0
    explicit StreamType(u8                             in_value);
    StreamType(ams_StreamTypeEnum arg);
    bool operator ==(const ams::StreamType &rhs) const;
    bool operator !=(const ams::StreamType &rhs) const;
    bool operator ==(ams_StreamTypeEnum rhs) const;
    StreamType();
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.StreamType.value.GetEnum
ams_StreamTypeEnum   value_GetEnum(const ams::StreamType& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.StreamType.value.SetEnum
void                 value_SetEnum(ams::StreamType& parent, ams_StreamTypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.StreamType.value.ToCstr
const char*          value_ToCstr(const ams::StreamType& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.StreamType.value.Print
void                 value_Print(const ams::StreamType& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.StreamType.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::StreamType& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.StreamType.value.SetStrptr
void                 value_SetStrptr(ams::StreamType& parent, algo::strptr rhs, ams_StreamTypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.StreamType.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::StreamType& parent, algo::strptr rhs) __attribute__((nothrow));

// func:ams.StreamType..Hash
u32                  StreamType_Hash(u32 prev, ams::StreamType rhs) __attribute__((nothrow));
// Read fields of ams::StreamType from an ascii string.
// The format of the string is the format of the ams::StreamType's only field
// func:ams.StreamType..ReadStrptrMaybe
bool                 StreamType_ReadStrptrMaybe(ams::StreamType &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.StreamType..Cmp
i32                  StreamType_Cmp(ams::StreamType lhs, ams::StreamType rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.StreamType..Init
void                 StreamType_Init(ams::StreamType& parent);
// func:ams.StreamType..Eq
bool                 StreamType_Eq(ams::StreamType lhs, ams::StreamType rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.StreamType.String  printfmt:Raw
// func:ams.StreamType..Print
void                 StreamType_Print(ams::StreamType row, algo::cstring& str) __attribute__((nothrow));
// define enum comparison operator to avoid ambiguity
// func:ams.StreamType..EqEnum
bool                 StreamType_EqEnum(ams::StreamType lhs, ams_StreamTypeEnum rhs) __attribute__((nothrow));

// --- ams.StreamId
#pragma pack(push,1)
struct StreamId { // ams.StreamId: Host-unique stream ID. E.g. proc1-0.out-0
    ams::ProcId       proc_id;       // Writer process ID
    ams::StreamType   stream_type;   // Stream type ID
    u8                streamidx;     //   0  Stream index
    explicit StreamId(ams::ProcId                    in_proc_id
        ,ams::StreamType                in_stream_type
        ,u8                             in_streamidx);
    bool operator ==(const ams::StreamId &rhs) const;
    bool operator !=(const ams::StreamId &rhs) const;
    StreamId();
};
#pragma pack(pop)

// func:ams.StreamId..Hash
u32                  StreamId_Hash(u32 prev, ams::StreamId rhs) __attribute__((nothrow));
// func:ams.StreamId..ReadFieldMaybe
bool                 StreamId_ReadFieldMaybe(ams::StreamId& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::StreamId from an ascii string.
// The format of the string is a string with separated values
// func:ams.StreamId..ReadStrptrMaybe
bool                 StreamId_ReadStrptrMaybe(ams::StreamId &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.StreamId..Cmp
i32                  StreamId_Cmp(ams::StreamId lhs, ams::StreamId rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.StreamId..Init
void                 StreamId_Init(ams::StreamId& parent);
// func:ams.StreamId..Eq
bool                 StreamId_Eq(ams::StreamId lhs, ams::StreamId rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.StreamId.String  printfmt:Sep
// func:ams.StreamId..Print
void                 StreamId_Print(ams::StreamId row, algo::cstring& str) __attribute__((nothrow));

// --- ams.DfltStream
#pragma pack(push,1)
struct DfltStream { // ams.DfltStream: Set default stream for subsequent messages
    u32             type;        //   21
    u32             length;      //   ssizeof(parent) + (0)
    ams::StreamId   stream_id;   // Message ID
    explicit DfltStream(ams::StreamId                  in_stream_id);
    DfltStream();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.DfltStream.base.CopyOut
void                 parent_CopyOut(ams::DfltStream &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of DfltStream by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of DfltStream.
// If not successful, quietly return NULL.
// func:ams.DfltStream.base.Castdown
ams::DfltStream*     DfltStream_Castdown(ams::MsgHeader &hdr);
// func:ams.DfltStream.base.Castbase
ams::MsgHeader&      Castbase(ams::DfltStream& parent);

// func:ams.DfltStream..ReadFieldMaybe
bool                 DfltStream_ReadFieldMaybe(ams::DfltStream& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::DfltStream from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.DfltStream..ReadStrptrMaybe
bool                 DfltStream_ReadStrptrMaybe(ams::DfltStream &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.DfltStream..GetMsgLength
i32                  GetMsgLength(const ams::DfltStream& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.DfltStream..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::DfltStream& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.DfltStream..Init
void                 DfltStream_Init(ams::DfltStream& parent);
// print string representation of ROW to string STR
// cfmt:ams.DfltStream.String  printfmt:Tuple
// func:ams.DfltStream..Print
void                 DfltStream_Print(ams::DfltStream& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.DumpStreamTableMsg
#pragma pack(push,1)
struct DumpStreamTableMsg { // ams.DumpStreamTableMsg: Remove process from process group
    u32           type;      //   12
    u32           length;    //   ssizeof(parent) + (0)
    ams::ProcId   proc_id;   // Target process
    explicit DumpStreamTableMsg(ams::ProcId                    in_proc_id);
    DumpStreamTableMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.DumpStreamTableMsg.base.CopyOut
void                 parent_CopyOut(ams::DumpStreamTableMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of DumpStreamTableMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of DumpStreamTableMsg.
// If not successful, quietly return NULL.
// func:ams.DumpStreamTableMsg.base.Castdown
ams::DumpStreamTableMsg* DumpStreamTableMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.DumpStreamTableMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::DumpStreamTableMsg& parent);

// func:ams.DumpStreamTableMsg..ReadFieldMaybe
bool                 DumpStreamTableMsg_ReadFieldMaybe(ams::DumpStreamTableMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::DumpStreamTableMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.DumpStreamTableMsg..ReadStrptrMaybe
bool                 DumpStreamTableMsg_ReadStrptrMaybe(ams::DumpStreamTableMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.DumpStreamTableMsg..GetMsgLength
i32                  GetMsgLength(const ams::DumpStreamTableMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.DumpStreamTableMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::DumpStreamTableMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.DumpStreamTableMsg..Init
void                 DumpStreamTableMsg_Init(ams::DumpStreamTableMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.DumpStreamTableMsg.String  printfmt:Tuple
// func:ams.DumpStreamTableMsg..Print
void                 DumpStreamTableMsg_Print(ams::DumpStreamTableMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ExpectMsg
#pragma pack(push,1)
struct ExpectMsg { // ams.ExpectMsg: Pause reading until some output is produced
    u32   type;     //   395
    u32   length;   //   ssizeof(parent) + (0)
    // var-length field ams.ExpectMsg.text starts here. access it with text_Addr
    ExpectMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ExpectMsg.base.CopyOut
void                 parent_CopyOut(ams::ExpectMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ExpectMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ExpectMsg.
// If not successful, quietly return NULL.
// func:ams.ExpectMsg.base.Castdown
ams::ExpectMsg*      ExpectMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ExpectMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::ExpectMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.ExpectMsg.text.Getary
algo::aryptr<char>   text_Getary(ams::ExpectMsg& parent) __attribute__((nothrow));
// func:ams.ExpectMsg.text.Addr
char*                text_Addr(ams::ExpectMsg& parent);
// Return number of elements in varlen field
// func:ams.ExpectMsg.text.N
u32                  text_N(const ams::ExpectMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.ExpectMsg.text.ReadStrptrMaybe
bool                 text_ReadStrptrMaybe(ams::ExpectMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert text to a string.
// Array is printed as a regular string.
// func:ams.ExpectMsg.text.Print
void                 text_Print(ams::ExpectMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.ExpectMsg.text_curs.Reset
void                 ExpectMsg_text_curs_Reset(ExpectMsg_text_curs &curs, ams::ExpectMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.ExpectMsg.text_curs.ValidQ
bool                 ExpectMsg_text_curs_ValidQ(ExpectMsg_text_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.ExpectMsg.text_curs.Next
void                 ExpectMsg_text_curs_Next(ExpectMsg_text_curs &curs) __attribute__((nothrow));
// item access
// func:ams.ExpectMsg.text_curs.Access
char&                ExpectMsg_text_curs_Access(ExpectMsg_text_curs &curs) __attribute__((nothrow));
// func:ams.ExpectMsg..ReadFieldMaybe
bool                 ExpectMsg_ReadFieldMaybe(ams::ExpectMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::ExpectMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ExpectMsg..ReadStrptrMaybe
bool                 ExpectMsg_ReadStrptrMaybe(ams::ExpectMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ExpectMsg..GetMsgLength
i32                  GetMsgLength(const ams::ExpectMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ExpectMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::ExpectMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ExpectMsg..Init
void                 ExpectMsg_Init(ams::ExpectMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ExpectMsg.String  printfmt:Tuple
// func:ams.ExpectMsg..Print
void                 ExpectMsg_Print(ams::ExpectMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.FieldId
#pragma pack(push,1)
struct FieldId { // ams.FieldId: Field read helper
    i32   value;   //   -1
    inline operator ams_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(ams_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.FieldId.value.GetEnum
ams_FieldIdEnum      value_GetEnum(const ams::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.FieldId.value.SetEnum
void                 value_SetEnum(ams::FieldId& parent, ams_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.FieldId.value.ToCstr
const char*          value_ToCstr(const ams::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.FieldId.value.Print
void                 value_Print(const ams::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.FieldId.value.SetStrptr
void                 value_SetStrptr(ams::FieldId& parent, algo::strptr rhs, ams_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of ams::FieldId from an ascii string.
// The format of the string is the format of the ams::FieldId's only field
// func:ams.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(ams::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.FieldId..Init
void                 FieldId_Init(ams::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:ams.FieldId.String  printfmt:Raw
// func:ams.FieldId..Print
void                 FieldId_Print(ams::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.HeartbeatMsg
#pragma pack(push,1)
struct HeartbeatMsg { // ams.HeartbeatMsg
    u32            type;     //   16
    u32            length;   //   ssizeof(parent) + (0)
    algo::UnTime   time;     //
    explicit HeartbeatMsg(algo::UnTime                   in_time);
    HeartbeatMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.HeartbeatMsg.base.CopyOut
void                 parent_CopyOut(ams::HeartbeatMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of HeartbeatMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of HeartbeatMsg.
// If not successful, quietly return NULL.
// func:ams.HeartbeatMsg.base.Castdown
ams::HeartbeatMsg*   HeartbeatMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.HeartbeatMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::HeartbeatMsg& parent);

// func:ams.HeartbeatMsg..ReadFieldMaybe
bool                 HeartbeatMsg_ReadFieldMaybe(ams::HeartbeatMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::HeartbeatMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.HeartbeatMsg..ReadStrptrMaybe
bool                 HeartbeatMsg_ReadStrptrMaybe(ams::HeartbeatMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.HeartbeatMsg..GetMsgLength
i32                  GetMsgLength(const ams::HeartbeatMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.HeartbeatMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::HeartbeatMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.HeartbeatMsg..Init
void                 HeartbeatMsg_Init(ams::HeartbeatMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.HeartbeatMsg.String  printfmt:Tuple
// func:ams.HeartbeatMsg..Print
void                 HeartbeatMsg_Print(ams::HeartbeatMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.InputLineMsg
#pragma pack(push,1)
struct InputLineMsg { // ams.InputLineMsg: Unrecognized input line
    u32   type;     //   22
    u32   length;   //   ssizeof(parent) + (0)
    // var-length field ams.InputLineMsg.payload starts here. access it with payload_Addr
    InputLineMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.InputLineMsg.base.CopyOut
void                 parent_CopyOut(ams::InputLineMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of InputLineMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of InputLineMsg.
// If not successful, quietly return NULL.
// func:ams.InputLineMsg.base.Castdown
ams::InputLineMsg*   InputLineMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.InputLineMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::InputLineMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.InputLineMsg.payload.Getary
algo::aryptr<char>   payload_Getary(ams::InputLineMsg& parent) __attribute__((nothrow));
// func:ams.InputLineMsg.payload.Addr
char*                payload_Addr(ams::InputLineMsg& parent);
// Return number of elements in varlen field
// func:ams.InputLineMsg.payload.N
u32                  payload_N(const ams::InputLineMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.InputLineMsg.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(ams::InputLineMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert payload to a string.
// Array is printed as a regular string.
// func:ams.InputLineMsg.payload.Print
void                 payload_Print(ams::InputLineMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.InputLineMsg.payload_curs.Reset
void                 InputLineMsg_payload_curs_Reset(InputLineMsg_payload_curs &curs, ams::InputLineMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.InputLineMsg.payload_curs.ValidQ
bool                 InputLineMsg_payload_curs_ValidQ(InputLineMsg_payload_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.InputLineMsg.payload_curs.Next
void                 InputLineMsg_payload_curs_Next(InputLineMsg_payload_curs &curs) __attribute__((nothrow));
// item access
// func:ams.InputLineMsg.payload_curs.Access
char&                InputLineMsg_payload_curs_Access(InputLineMsg_payload_curs &curs) __attribute__((nothrow));
// func:ams.InputLineMsg..ReadFieldMaybe
bool                 InputLineMsg_ReadFieldMaybe(ams::InputLineMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::InputLineMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.InputLineMsg..ReadStrptrMaybe
bool                 InputLineMsg_ReadStrptrMaybe(ams::InputLineMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.InputLineMsg..GetMsgLength
i32                  GetMsgLength(const ams::InputLineMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.InputLineMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::InputLineMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.InputLineMsg..Init
void                 InputLineMsg_Init(ams::InputLineMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.InputLineMsg.String  printfmt:Tuple
// func:ams.InputLineMsg..Print
void                 InputLineMsg_Print(ams::InputLineMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.LogMsg
#pragma pack(push,1)
struct LogMsg { // ams.LogMsg: Log message
    u32                type;     //   6
    u32                length;   //   ssizeof(parent) + (0)
    algo::RnullStr50   logcat;   //
    algo::SchedTime    tstamp;   //
    // var-length field ams.LogMsg.text starts here. access it with text_Addr
    explicit LogMsg(const algo::strptr&            in_logcat
        ,algo::SchedTime                in_tstamp);
    LogMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.LogMsg.base.CopyOut
void                 parent_CopyOut(ams::LogMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of LogMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of LogMsg.
// If not successful, quietly return NULL.
// func:ams.LogMsg.base.Castdown
ams::LogMsg*         LogMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.LogMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::LogMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.LogMsg.text.Getary
algo::aryptr<char>   text_Getary(ams::LogMsg& parent) __attribute__((nothrow));
// func:ams.LogMsg.text.Addr
char*                text_Addr(ams::LogMsg& parent);
// Return number of elements in varlen field
// func:ams.LogMsg.text.N
u32                  text_N(const ams::LogMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.LogMsg.text.ReadStrptrMaybe
bool                 text_ReadStrptrMaybe(ams::LogMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert text to a string.
// Array is printed as a regular string.
// func:ams.LogMsg.text.Print
void                 text_Print(ams::LogMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.LogMsg.text_curs.Reset
void                 LogMsg_text_curs_Reset(LogMsg_text_curs &curs, ams::LogMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.LogMsg.text_curs.ValidQ
bool                 LogMsg_text_curs_ValidQ(LogMsg_text_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.LogMsg.text_curs.Next
void                 LogMsg_text_curs_Next(LogMsg_text_curs &curs) __attribute__((nothrow));
// item access
// func:ams.LogMsg.text_curs.Access
char&                LogMsg_text_curs_Access(LogMsg_text_curs &curs) __attribute__((nothrow));
// func:ams.LogMsg..ReadFieldMaybe
bool                 LogMsg_ReadFieldMaybe(ams::LogMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::LogMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.LogMsg..ReadStrptrMaybe
bool                 LogMsg_ReadStrptrMaybe(ams::LogMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.LogMsg..GetMsgLength
i32                  GetMsgLength(const ams::LogMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.LogMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::LogMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.LogMsg..Init
void                 LogMsg_Init(ams::LogMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.LogMsg.String  printfmt:Tuple
// func:ams.LogMsg..Print
void                 LogMsg_Print(ams::LogMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.Member
#pragma pack(push,1)
struct Member { // ams.Member: Process/Stream/Mode - primary key for reader/writer of stream
    ams::ProcId     proc_id;     // Proces ID
    ams::StreamId   stream_id;   // Stream ID
    u8              mode;        //   0  0=read, 1=write (2 or more =read)
    explicit Member(ams::ProcId                    in_proc_id
        ,ams::StreamId                  in_stream_id
        ,u8                             in_mode);
    bool operator ==(const ams::Member &rhs) const;
    bool operator !=(const ams::Member &rhs) const;
    Member();
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.Member.mode.GetEnum
ams_Member_mode_Enum mode_GetEnum(const ams::Member& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.Member.mode.SetEnum
void                 mode_SetEnum(ams::Member& parent, ams_Member_mode_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.Member.mode.ToCstr
const char*          mode_ToCstr(const ams::Member& parent) __attribute__((nothrow));
// Convert mode to a string. First, attempt conversion to a known string.
// If no string matches, print mode as a numeric value.
// func:ams.Member.mode.Print
void                 mode_Print(const ams::Member& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.Member.mode.SetStrptrMaybe
bool                 mode_SetStrptrMaybe(ams::Member& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.Member.mode.SetStrptr
void                 mode_SetStrptr(ams::Member& parent, algo::strptr rhs, ams_Member_mode_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.Member.mode.ReadStrptrMaybe
bool                 mode_ReadStrptrMaybe(ams::Member& parent, algo::strptr rhs) __attribute__((nothrow));

// func:ams.Member..Hash
u32                  Member_Hash(u32 prev, ams::Member rhs) __attribute__((nothrow));
// func:ams.Member..ReadFieldMaybe
bool                 Member_ReadFieldMaybe(ams::Member& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::Member from an ascii string.
// The format of the string is a string with separated values
// func:ams.Member..ReadStrptrMaybe
bool                 Member_ReadStrptrMaybe(ams::Member &parent, algo::strptr in_str) __attribute__((nothrow));
// func:ams.Member..Cmp
i32                  Member_Cmp(ams::Member lhs, ams::Member rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.Member..Init
void                 Member_Init(ams::Member& parent);
// func:ams.Member..Eq
bool                 Member_Eq(ams::Member lhs, ams::Member rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:ams.Member.String  printfmt:Sep
// func:ams.Member..Print
void                 Member_Print(ams::Member row, algo::cstring& str) __attribute__((nothrow));

// --- ams.MsgBlock
#pragma pack(push,1)
struct MsgBlock { // ams.MsgBlock: A block of messages from ams commit file
    u32   type;              //   1
    u32   length;            //   ssizeof(parent) + (0)
    u64   first_seqno;       //   0  First sequence number
    u32   n_messages;        //   0  Number of messages
    u32   original_length;   //   0  Original (uncompressed length) of messages
    // var-length field ams.MsgBlock.messages starts here. access it with messages_Addr
    MsgBlock();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.MsgBlock.header.CopyOut
void                 parent_CopyOut(ams::MsgBlock &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of MsgBlock by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of MsgBlock.
// If not successful, quietly return NULL.
// func:ams.MsgBlock.header.Castdown
ams::MsgBlock*       MsgBlock_Castdown(ams::MsgHeader &hdr);
// func:ams.MsgBlock.header.Castbase
ams::MsgHeader&      Castbase(ams::MsgBlock& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.MsgBlock.messages.Getary
algo::aryptr<u8>     messages_Getary(ams::MsgBlock& parent) __attribute__((nothrow));
// func:ams.MsgBlock.messages.Addr
u8*                  messages_Addr(ams::MsgBlock& parent);
// Return number of elements in varlen field
// func:ams.MsgBlock.messages.N
u32                  messages_N(const ams::MsgBlock& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert messages to a string.
// Array is printed as a regular string.
// func:ams.MsgBlock.messages.Print
void                 messages_Print(ams::MsgBlock& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.MsgBlock.messages_curs.Reset
void                 MsgBlock_messages_curs_Reset(MsgBlock_messages_curs &curs, ams::MsgBlock &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.MsgBlock.messages_curs.ValidQ
bool                 MsgBlock_messages_curs_ValidQ(MsgBlock_messages_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.MsgBlock.messages_curs.Next
void                 MsgBlock_messages_curs_Next(MsgBlock_messages_curs &curs) __attribute__((nothrow));
// item access
// func:ams.MsgBlock.messages_curs.Access
u8&                  MsgBlock_messages_curs_Access(MsgBlock_messages_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.MsgBlock..GetMsgLength
i32                  GetMsgLength(const ams::MsgBlock& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.MsgBlock..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::MsgBlock& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgBlock..Init
void                 MsgBlock_Init(ams::MsgBlock& parent);
// print string representation of ROW to string STR
// cfmt:ams.MsgBlock.String  printfmt:Tuple
// func:ams.MsgBlock..Print
void                 MsgBlock_Print(ams::MsgBlock& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.MsgHeader
// create: ams.PrlogMsg.data (Opt)
// create: ams.Seqmsg.payload (Opt)
// create: ams.SeqmsgTrace.payload (Opt)
// access: ams.AlarmSyncMsg.base (Base)
// access: ams.DfltStream.base (Base)
// access: ams.DumpStreamTableMsg.base (Base)
// access: ams.ExpectMsg.base (Base)
// access: ams.HeartbeatMsg.base (Base)
// access: ams.InputLineMsg.base (Base)
// access: ams.LogMsg.base (Base)
// access: ams.MsgBlock.header (Base)
// access: ams.OpenMsg.base (Base)
// access: ams.PrlogMsg.base (Base)
// access: ams.ProcAddMsg.base (Base)
// access: ams.ProcRemoveMsg.base (Base)
// access: ams.Seqmsg.base (Base)
// access: ams.SeqmsgTrace.base (Base)
// access: ams.StreamHbMsg.base (Base)
// access: ams.TerminateMsg.base (Base)
// access: ams.Trace2Msg.base (Base)
// access: ams.TraceInfo2Msg.base (Base)
// access: ams.TraceInfoMsg.base (Base)
// access: ams.TraceMsg.base (Base)
// access: ams.UdpFrame.header (Base)
// access: ams.MsgHeader_curs.msg (Ptr)
#pragma pack(push,1)
struct MsgHeader { // ams.MsgHeader
    u32   type;     //   0
    u32   length;   //   0
    explicit MsgHeader(u32                            in_type
        ,u32                            in_length);
    MsgHeader();
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.MsgHeader.type.GetEnum
ams_MsgHeader_type_Enum type_GetEnum(const ams::MsgHeader& data) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.MsgHeader.type.SetEnum
void                 type_SetEnum(ams::MsgHeader& data, ams_MsgHeader_type_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.MsgHeader.type.ToCstr
const char*          type_ToCstr(const ams::MsgHeader& data) __attribute__((nothrow));
// Convert type to a string. First, attempt conversion to a known string.
// If no string matches, print type as a numeric value.
// func:ams.MsgHeader.type.Print
void                 type_Print(const ams::MsgHeader& data, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.MsgHeader.type.SetStrptrMaybe
bool                 type_SetStrptrMaybe(ams::MsgHeader& data, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.MsgHeader.type.SetStrptr
void                 type_SetStrptr(ams::MsgHeader& data, algo::strptr rhs, ams_MsgHeader_type_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.MsgHeader.type.ReadStrptrMaybe
bool                 type_ReadStrptrMaybe(ams::MsgHeader& data, algo::strptr rhs) __attribute__((nothrow));

// func:ams.MsgHeader..ReadFieldMaybe
bool                 MsgHeader_ReadFieldMaybe(ams::MsgHeader& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::MsgHeader from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.MsgHeader..ReadStrptrMaybe
bool                 MsgHeader_ReadStrptrMaybe(ams::MsgHeader &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.MsgHeader..GetMsgLength
i32                  GetMsgLength(const ams::MsgHeader& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.MsgHeader..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::MsgHeader& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgHeader..Init
void                 MsgHeader_Init(ams::MsgHeader& data);
// print string representation of ROW to string STR
// cfmt:ams.MsgHeader.String  printfmt:Tuple
// func:ams.MsgHeader..Print
void                 MsgHeader_Print(ams::MsgHeader& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.MsgHeaderMsgsCase
#pragma pack(push,1)
struct MsgHeaderMsgsCase { // ams.MsgHeaderMsgsCase: Enum for dispatch ams.MsgHeaderMsgs
    u32   value;   //   0
    inline operator ams_MsgHeaderMsgsCaseEnum() const;
    explicit MsgHeaderMsgsCase(u32                            in_value);
    MsgHeaderMsgsCase(ams_MsgHeaderMsgsCaseEnum arg);
    MsgHeaderMsgsCase();
};
#pragma pack(pop)

// Get value of field as enum type
// func:ams.MsgHeaderMsgsCase.value.GetEnum
ams_MsgHeaderMsgsCaseEnum value_GetEnum(const ams::MsgHeaderMsgsCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.MsgHeaderMsgsCase.value.SetEnum
void                 value_SetEnum(ams::MsgHeaderMsgsCase& parent, ams_MsgHeaderMsgsCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.MsgHeaderMsgsCase.value.ToCstr
const char*          value_ToCstr(const ams::MsgHeaderMsgsCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:ams.MsgHeaderMsgsCase.value.Print
void                 value_Print(const ams::MsgHeaderMsgsCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.MsgHeaderMsgsCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.MsgHeaderMsgsCase.value.SetStrptr
void                 value_SetStrptr(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs, ams_MsgHeaderMsgsCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.MsgHeaderMsgsCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(ams::MsgHeaderMsgsCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of ams::MsgHeaderMsgsCase from an ascii string.
// The format of the string is the format of the ams::MsgHeaderMsgsCase's only field
// func:ams.MsgHeaderMsgsCase..ReadStrptrMaybe
bool                 MsgHeaderMsgsCase_ReadStrptrMaybe(ams::MsgHeaderMsgsCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgHeaderMsgsCase..Init
void                 MsgHeaderMsgsCase_Init(ams::MsgHeaderMsgsCase& parent);

// --- ams.MsgHeader_curs
#pragma pack(push,1)
struct MsgHeader_curs { // ams.MsgHeader_curs: Cursor for scanning messages in a memptr
    typedef ams::MsgHeader *ChildType;
    ams::MsgHeader*   msg;      // Pointer to current message. optional pointer
    u8*               bytes;    // Beginning of region. optional pointer
    i32               limit;    //   0  # Of bytes in the region
    i32               msglen;   //   0  Length of current message (if any)
    MsgHeader_curs();
};
#pragma pack(pop)

// func:ams.MsgHeader_curs..ValidQ
bool                 MsgHeader_curs_ValidQ(ams::MsgHeader_curs& curs) __attribute__((nothrow));
// func:ams.MsgHeader_curs..Reset
void                 MsgHeader_curs_Reset(ams::MsgHeader_curs& curs, algo::memptr buf) __attribute__((nothrow));
// func:ams.MsgHeader_curs..Access
ams::MsgHeader*&     MsgHeader_curs_Access(ams::MsgHeader_curs& curs) __attribute__((nothrow));
// func:ams.MsgHeader_curs..Next
void                 MsgHeader_curs_Next(ams::MsgHeader_curs& curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.MsgHeader_curs..Init
void                 MsgHeader_curs_Init(ams::MsgHeader_curs& parent);

// --- ams.StreamPos
#pragma pack(push,1)
struct StreamPos { // ams.StreamPos: Sequence,Offset
    u64   seq;   //   1
    u64   off;   //   0
    explicit StreamPos(u64                            in_seq
        ,u64                            in_off);
    StreamPos();
};
#pragma pack(pop)

// func:ams.StreamPos..ReadFieldMaybe
bool                 StreamPos_ReadFieldMaybe(ams::StreamPos& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::StreamPos from an ascii string.
// The format of the string is a string with separated values
// func:ams.StreamPos..ReadStrptrMaybe
bool                 StreamPos_ReadStrptrMaybe(ams::StreamPos &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.StreamPos..Init
void                 StreamPos_Init(ams::StreamPos& parent);
// print string representation of ROW to string STR
// cfmt:ams.StreamPos.String  printfmt:Sep
// func:ams.StreamPos..Print
void                 StreamPos_Print(ams::StreamPos row, algo::cstring& str) __attribute__((nothrow));

// --- ams.OpenMsg
#pragma pack(push,1)
struct OpenMsg { // ams.OpenMsg: Open stream for reading
    u32              type;     //   7
    u32              length;   //   ssizeof(parent) + (0)
    ams::Member      member;   // Target process_id and stream_id
    ams::StreamPos   pos;      // Start reading here
    explicit OpenMsg(ams::Member                    in_member
        ,ams::StreamPos                 in_pos);
    OpenMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.OpenMsg.base.CopyOut
void                 parent_CopyOut(ams::OpenMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of OpenMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of OpenMsg.
// If not successful, quietly return NULL.
// func:ams.OpenMsg.base.Castdown
ams::OpenMsg*        OpenMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.OpenMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::OpenMsg& parent);

// func:ams.OpenMsg..ReadFieldMaybe
bool                 OpenMsg_ReadFieldMaybe(ams::OpenMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::OpenMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.OpenMsg..ReadStrptrMaybe
bool                 OpenMsg_ReadStrptrMaybe(ams::OpenMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.OpenMsg..GetMsgLength
i32                  GetMsgLength(const ams::OpenMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.OpenMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::OpenMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.OpenMsg..Init
void                 OpenMsg_Init(ams::OpenMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.OpenMsg.String  printfmt:Tuple
// func:ams.OpenMsg..Print
void                 OpenMsg_Print(ams::OpenMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.PrlogMsg
#pragma pack(push,1)
struct PrlogMsg { // ams.PrlogMsg
    u32                    type;     //   229
    u32                    length;   //   ssizeof(parent) + (0)
    algo::RnullStr50       logcat;   //
    algo::SchedTime        tstamp;   //
    // ams::MsgHeader      data[];                                    optional field
    PrlogMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.PrlogMsg.base.CopyOut
void                 parent_CopyOut(ams::PrlogMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of PrlogMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of PrlogMsg.
// If not successful, quietly return NULL.
// func:ams.PrlogMsg.base.Castdown
ams::PrlogMsg*       PrlogMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.PrlogMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::PrlogMsg& parent);

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized data, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If data's length field value is too short, return NULL.
// If data's length field value extends past parent's allowed length, return NULL.
// func:ams.PrlogMsg.data.Get
ams::MsgHeader*      data_Get(ams::PrlogMsg& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:ams.PrlogMsg.data.Getary
algo::aryptr<u8>     data_Getary(ams::PrlogMsg& parent) __attribute__((nothrow));
// func:ams.PrlogMsg.data.Print
void                 data_Print(ams::PrlogMsg& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.PrlogMsg.data.ReadStrptrMaybe
bool                 data_ReadStrptrMaybe(ams::PrlogMsg &parent, algo::strptr in_str) __attribute__((nothrow));

// func:ams.PrlogMsg..ReadFieldMaybe
bool                 PrlogMsg_ReadFieldMaybe(ams::PrlogMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::PrlogMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.PrlogMsg..ReadStrptrMaybe
bool                 PrlogMsg_ReadStrptrMaybe(ams::PrlogMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.PrlogMsg..GetMsgLength
i32                  GetMsgLength(const ams::PrlogMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.PrlogMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::PrlogMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.PrlogMsg..Init
void                 PrlogMsg_Init(ams::PrlogMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.PrlogMsg.String  printfmt:Tuple
// func:ams.PrlogMsg..Print
void                 PrlogMsg_Print(ams::PrlogMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcAddMsg
#pragma pack(push,1)
struct ProcAddMsg { // ams.ProcAddMsg: Add process to process group
    u32           type;      //   4
    u32           length;    //   ssizeof(parent) + (0)
    ams::ProcId   proc_id;   // ID of process being added
    explicit ProcAddMsg(ams::ProcId                    in_proc_id);
    ProcAddMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcAddMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcAddMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcAddMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcAddMsg.
// If not successful, quietly return NULL.
// func:ams.ProcAddMsg.base.Castdown
ams::ProcAddMsg*     ProcAddMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcAddMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::ProcAddMsg& parent);

// func:ams.ProcAddMsg..ReadFieldMaybe
bool                 ProcAddMsg_ReadFieldMaybe(ams::ProcAddMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcAddMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcAddMsg..ReadStrptrMaybe
bool                 ProcAddMsg_ReadStrptrMaybe(ams::ProcAddMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcAddMsg..GetMsgLength
i32                  GetMsgLength(const ams::ProcAddMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcAddMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::ProcAddMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcAddMsg..Init
void                 ProcAddMsg_Init(ams::ProcAddMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcAddMsg.String  printfmt:Tuple
// func:ams.ProcAddMsg..Print
void                 ProcAddMsg_Print(ams::ProcAddMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.ProcRemoveMsg
#pragma pack(push,1)
struct ProcRemoveMsg { // ams.ProcRemoveMsg: Remove process from process group
    u32           type;      //   5
    u32           length;    //   ssizeof(parent) + (0)
    ams::ProcId   proc_id;   // ID of process being removed
    explicit ProcRemoveMsg(ams::ProcId                    in_proc_id);
    ProcRemoveMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.ProcRemoveMsg.base.CopyOut
void                 parent_CopyOut(ams::ProcRemoveMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of ProcRemoveMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of ProcRemoveMsg.
// If not successful, quietly return NULL.
// func:ams.ProcRemoveMsg.base.Castdown
ams::ProcRemoveMsg*  ProcRemoveMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.ProcRemoveMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::ProcRemoveMsg& parent);

// func:ams.ProcRemoveMsg..ReadFieldMaybe
bool                 ProcRemoveMsg_ReadFieldMaybe(ams::ProcRemoveMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::ProcRemoveMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.ProcRemoveMsg..ReadStrptrMaybe
bool                 ProcRemoveMsg_ReadStrptrMaybe(ams::ProcRemoveMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.ProcRemoveMsg..GetMsgLength
i32                  GetMsgLength(const ams::ProcRemoveMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.ProcRemoveMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::ProcRemoveMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.ProcRemoveMsg..Init
void                 ProcRemoveMsg_Init(ams::ProcRemoveMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.ProcRemoveMsg.String  printfmt:Tuple
// func:ams.ProcRemoveMsg..Print
void                 ProcRemoveMsg_Print(ams::ProcRemoveMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.SeqmsgId
#pragma pack(push,1)
struct SeqmsgId { // ams.SeqmsgId: StreamID + Sequence number, e.g. proc1-0.out-0@1
    ams::StreamId   stream_id;   //
    u64             seq;         //   1
    u32             off;         //   0
    explicit SeqmsgId(ams::StreamId                  in_stream_id
        ,u64                            in_seq
        ,u32                            in_off);
    SeqmsgId();
};
#pragma pack(pop)

// func:ams.SeqmsgId..ReadFieldMaybe
bool                 SeqmsgId_ReadFieldMaybe(ams::SeqmsgId& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::SeqmsgId from an ascii string.
// The format of the string is a string with separated values
// func:ams.SeqmsgId..ReadStrptrMaybe
bool                 SeqmsgId_ReadStrptrMaybe(ams::SeqmsgId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.SeqmsgId..Init
void                 SeqmsgId_Init(ams::SeqmsgId& parent);
// print string representation of ROW to string STR
// cfmt:ams.SeqmsgId.String  printfmt:Sep
// func:ams.SeqmsgId..Print
void                 SeqmsgId_Print(ams::SeqmsgId row, algo::cstring& str) __attribute__((nothrow));

// --- ams.Seqmsg
#pragma pack(push,1)
struct Seqmsg { // ams.Seqmsg: Sequenced stream message
    u32                    type;        //   10
    u32                    length;      //   ssizeof(parent) + (0)
    ams::SeqmsgId          seqmsg_id;   // Message ID
    u64                    tsc;         //   0  TSC of sender
    // ams::MsgHeader      payload[];                                    optional field
    explicit Seqmsg(ams::SeqmsgId                  in_seqmsg_id
        ,u64                            in_tsc);
    Seqmsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.Seqmsg.base.CopyOut
void                 parent_CopyOut(ams::Seqmsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of Seqmsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Seqmsg.
// If not successful, quietly return NULL.
// func:ams.Seqmsg.base.Castdown
ams::Seqmsg*         Seqmsg_Castdown(ams::MsgHeader &hdr);
// func:ams.Seqmsg.base.Castbase
ams::MsgHeader&      Castbase(ams::Seqmsg& parent);

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
// func:ams.Seqmsg.payload.Get
ams::MsgHeader*      payload_Get(ams::Seqmsg& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:ams.Seqmsg.payload.Getary
algo::aryptr<u8>     payload_Getary(ams::Seqmsg& parent) __attribute__((nothrow));
// func:ams.Seqmsg.payload.Print
void                 payload_Print(ams::Seqmsg& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.Seqmsg.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(ams::Seqmsg &parent, algo::strptr in_str) __attribute__((nothrow));

// func:ams.Seqmsg..ReadFieldMaybe
bool                 Seqmsg_ReadFieldMaybe(ams::Seqmsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::Seqmsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.Seqmsg..ReadStrptrMaybe
bool                 Seqmsg_ReadStrptrMaybe(ams::Seqmsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.Seqmsg..GetMsgLength
i32                  GetMsgLength(const ams::Seqmsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.Seqmsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::Seqmsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.Seqmsg..Init
void                 Seqmsg_Init(ams::Seqmsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.Seqmsg.String  printfmt:Tuple
// func:ams.Seqmsg..Print
void                 Seqmsg_Print(ams::Seqmsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.SeqmsgTrace
#pragma pack(push,1)
struct SeqmsgTrace { // ams.SeqmsgTrace: Message used to trace reading/writing seqmsgs
    u32                    type;        //   11
    u32                    length;      //   ssizeof(parent) + (0)
    ams::ProcId            proc_id;     // Proces ID
    u8                     mode;        //   0  0=read, 1=write (2 or more =read)
    ams::SeqmsgId          seqmsg_id;   // Message ID
    u64                    tsc;         //   0  TSC of sender
    // ams::MsgHeader      payload[];                                                 optional field
    explicit SeqmsgTrace(ams::ProcId                    in_proc_id
        ,u8                             in_mode
        ,ams::SeqmsgId                  in_seqmsg_id
        ,u64                            in_tsc);
    SeqmsgTrace();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.SeqmsgTrace.base.CopyOut
void                 parent_CopyOut(ams::SeqmsgTrace &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of SeqmsgTrace by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of SeqmsgTrace.
// If not successful, quietly return NULL.
// func:ams.SeqmsgTrace.base.Castdown
ams::SeqmsgTrace*    SeqmsgTrace_Castdown(ams::MsgHeader &hdr);
// func:ams.SeqmsgTrace.base.Castbase
ams::MsgHeader&      Castbase(ams::SeqmsgTrace& parent);

// Get value of field as enum type
// func:ams.SeqmsgTrace.mode.GetEnum
ams_SeqmsgTrace_mode_Enum mode_GetEnum(const ams::SeqmsgTrace& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:ams.SeqmsgTrace.mode.SetEnum
void                 mode_SetEnum(ams::SeqmsgTrace& parent, ams_SeqmsgTrace_mode_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:ams.SeqmsgTrace.mode.ToCstr
const char*          mode_ToCstr(const ams::SeqmsgTrace& parent) __attribute__((nothrow));
// Convert mode to a string. First, attempt conversion to a known string.
// If no string matches, print mode as a numeric value.
// func:ams.SeqmsgTrace.mode.Print
void                 mode_Print(const ams::SeqmsgTrace& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:ams.SeqmsgTrace.mode.SetStrptrMaybe
bool                 mode_SetStrptrMaybe(ams::SeqmsgTrace& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:ams.SeqmsgTrace.mode.SetStrptr
void                 mode_SetStrptr(ams::SeqmsgTrace& parent, algo::strptr rhs, ams_SeqmsgTrace_mode_Enum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.SeqmsgTrace.mode.ReadStrptrMaybe
bool                 mode_ReadStrptrMaybe(ams::SeqmsgTrace& parent, algo::strptr rhs) __attribute__((nothrow));

// Return pointer to optional last element (NULL if none)
// The parent's length field is assumed to have already been checked for validity.
// If the parent's lengthis too short to allow a full-sized payload, return NULL.
// Since the last element is itself variable-length, two more checks are applied:
// If payload's length field value is too short, return NULL.
// If payload's length field value extends past parent's allowed length, return NULL.
// func:ams.SeqmsgTrace.payload.Get
ams::MsgHeader*      payload_Get(ams::SeqmsgTrace& parent) __attribute__((__warn_unused_result__, nothrow));
// Access optional portion as an array of bytes
// func:ams.SeqmsgTrace.payload.Getary
algo::aryptr<u8>     payload_Getary(ams::SeqmsgTrace& parent) __attribute__((nothrow));
// func:ams.SeqmsgTrace.payload.Print
void                 payload_Print(ams::SeqmsgTrace& parent, cstring &out) __attribute__((nothrow));
// Convert string to field. Return success value
// func:ams.SeqmsgTrace.payload.ReadStrptrMaybe
bool                 payload_ReadStrptrMaybe(ams::SeqmsgTrace &parent, algo::strptr in_str) __attribute__((nothrow));

// func:ams.SeqmsgTrace..ReadFieldMaybe
bool                 SeqmsgTrace_ReadFieldMaybe(ams::SeqmsgTrace& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::SeqmsgTrace from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.SeqmsgTrace..ReadStrptrMaybe
bool                 SeqmsgTrace_ReadStrptrMaybe(ams::SeqmsgTrace &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.SeqmsgTrace..GetMsgLength
i32                  GetMsgLength(const ams::SeqmsgTrace& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.SeqmsgTrace..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::SeqmsgTrace& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.SeqmsgTrace..Init
void                 SeqmsgTrace_Init(ams::SeqmsgTrace& parent);
// print string representation of ROW to string STR
// cfmt:ams.SeqmsgTrace.String  printfmt:Tuple
// func:ams.SeqmsgTrace..Print
void                 SeqmsgTrace_Print(ams::SeqmsgTrace& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.StreamFlags
#pragma pack(push,1)
struct StreamFlags { // ams.StreamFlags
    u8   value;   //   0
    explicit StreamFlags(u8                             in_value);
    StreamFlags(ams_StreamFlagsEnum arg);
    StreamFlags();
};
#pragma pack(pop)

// Retrieve bitfield from value of field value
//    1 bits starting at bit 1.
// func:ams.StreamFlags.write.Get
bool                 write_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 1.
// func:ams.StreamFlags.write.Set
void                 write_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 2.
// func:ams.StreamFlags.read.Get
bool                 read_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 2.
// func:ams.StreamFlags.read.Set
void                 read_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 3.
// func:ams.StreamFlags.nonblock.Get
bool                 nonblock_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 3.
// func:ams.StreamFlags.nonblock.Set
void                 nonblock_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 4.
// func:ams.StreamFlags.trace_read.Get
bool                 trace_read_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 4.
// func:ams.StreamFlags.trace_read.Set
void                 trace_read_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 5.
// func:ams.StreamFlags.trace_write.Get
bool                 trace_write_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 5.
// func:ams.StreamFlags.trace_write.Set
void                 trace_write_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 6.
// func:ams.StreamFlags.write_err.Get
bool                 write_err_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 6.
// func:ams.StreamFlags.write_err.Set
void                 write_err_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// Retrieve bitfield from value of field value
//    1 bits starting at bit 7.
// func:ams.StreamFlags.trace_text.Get
bool                 trace_text_Get(const ams::StreamFlags& parent) __attribute__((__warn_unused_result__, nothrow));
// Set bitfield in value of field 'value'
//    1 bits starting at bit 7.
// func:ams.StreamFlags.trace_text.Set
void                 trace_text_Set(ams::StreamFlags& parent, bool rhs) __attribute__((nothrow));

// func:ams.StreamFlags..ReadFieldMaybe
bool                 StreamFlags_ReadFieldMaybe(ams::StreamFlags& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::StreamFlags from an ascii string.
// func:ams.StreamFlags..ReadStrptrMaybe
bool                 StreamFlags_ReadStrptrMaybe(ams::StreamFlags &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.StreamFlags..Init
void                 StreamFlags_Init(ams::StreamFlags& parent);
// print string representation of ROW to string STR
// cfmt:ams.StreamFlags.String  printfmt:Bitset
// func:ams.StreamFlags..Print
void                 StreamFlags_Print(ams::StreamFlags row, algo::cstring& str) __attribute__((nothrow));
// func:ams.StreamFlags..GetAnon
algo::strptr         StreamFlags_GetAnon(ams::StreamFlags &parent, i32 idx) __attribute__((nothrow));

// --- ams.StreamHbMsg
#pragma pack(push,1)
struct StreamHbMsg { // ams.StreamHbMsg: Stream heartbeat
    u32              type;      //   3
    u32              length;    //   ssizeof(parent) + (0)
    ams::Member      member;    // Primary key
    ams::StreamPos   pos;       // Read/write position
    u32              wbudget;   //   0  Max. offset for writing
    explicit StreamHbMsg(ams::Member                    in_member
        ,ams::StreamPos                 in_pos
        ,u32                            in_wbudget);
    StreamHbMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.StreamHbMsg.base.CopyOut
void                 parent_CopyOut(ams::StreamHbMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of StreamHbMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of StreamHbMsg.
// If not successful, quietly return NULL.
// func:ams.StreamHbMsg.base.Castdown
ams::StreamHbMsg*    StreamHbMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.StreamHbMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::StreamHbMsg& parent);

// func:ams.StreamHbMsg..ReadFieldMaybe
bool                 StreamHbMsg_ReadFieldMaybe(ams::StreamHbMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::StreamHbMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.StreamHbMsg..ReadStrptrMaybe
bool                 StreamHbMsg_ReadStrptrMaybe(ams::StreamHbMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.StreamHbMsg..GetMsgLength
i32                  GetMsgLength(const ams::StreamHbMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.StreamHbMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::StreamHbMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.StreamHbMsg..Init
void                 StreamHbMsg_Init(ams::StreamHbMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.StreamHbMsg.String  printfmt:Tuple
// func:ams.StreamHbMsg..Print
void                 StreamHbMsg_Print(ams::StreamHbMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.TerminateMsg
#pragma pack(push,1)
struct TerminateMsg { // ams.TerminateMsg: Message sent to process to terminate it
    u32   type;     //   352
    u32   length;   //   ssizeof(parent) + (0)
    TerminateMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.TerminateMsg.base.CopyOut
void                 parent_CopyOut(ams::TerminateMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of TerminateMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TerminateMsg.
// If not successful, quietly return NULL.
// func:ams.TerminateMsg.base.Castdown
ams::TerminateMsg*   TerminateMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.TerminateMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::TerminateMsg& parent);

// func:ams.TerminateMsg..ReadFieldMaybe
bool                 TerminateMsg_ReadFieldMaybe(ams::TerminateMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of ams::TerminateMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.TerminateMsg..ReadStrptrMaybe
bool                 TerminateMsg_ReadStrptrMaybe(ams::TerminateMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.TerminateMsg..GetMsgLength
i32                  GetMsgLength(const ams::TerminateMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.TerminateMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::TerminateMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.TerminateMsg..Init
void                 TerminateMsg_Init(ams::TerminateMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.TerminateMsg.String  printfmt:Tuple
// func:ams.TerminateMsg..Print
void                 TerminateMsg_Print(ams::TerminateMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.Trace2Msg
#pragma pack(push,1)
struct Trace2Msg { // ams.Trace2Msg: Trace2 message
    u32            type;     //   108
    u32            length;   //   ssizeof(parent) + (0)
    ams::ProcId    proc;     //
    u8             trace;    //   0
    algo::UnTime   tstamp;   //
    // var-length field ams.Trace2Msg.data starts here. access it with data_Addr
    explicit Trace2Msg(ams::ProcId                    in_proc
        ,u8                             in_trace
        ,algo::UnTime                   in_tstamp);
    Trace2Msg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.Trace2Msg.base.CopyOut
void                 parent_CopyOut(ams::Trace2Msg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of Trace2Msg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of Trace2Msg.
// If not successful, quietly return NULL.
// func:ams.Trace2Msg.base.Castdown
ams::Trace2Msg*      Trace2Msg_Castdown(ams::MsgHeader &hdr);
// func:ams.Trace2Msg.base.Castbase
ams::MsgHeader&      Castbase(ams::Trace2Msg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.Trace2Msg.data.Getary
algo::aryptr<u64>    data_Getary(ams::Trace2Msg& parent) __attribute__((nothrow));
// func:ams.Trace2Msg.data.Addr
u64*                 data_Addr(ams::Trace2Msg& parent);
// Return number of elements in varlen field
// func:ams.Trace2Msg.data.N
u32                  data_N(const ams::Trace2Msg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.Trace2Msg.data.ReadStrptrMaybe
bool                 data_ReadStrptrMaybe(ams::Trace2Msg& parent, algo::strptr in_str) __attribute__((nothrow));

// func:ams.Trace2Msg.data_curs.Reset
void                 Trace2Msg_data_curs_Reset(Trace2Msg_data_curs &curs, ams::Trace2Msg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.Trace2Msg.data_curs.ValidQ
bool                 Trace2Msg_data_curs_ValidQ(Trace2Msg_data_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.Trace2Msg.data_curs.Next
void                 Trace2Msg_data_curs_Next(Trace2Msg_data_curs &curs) __attribute__((nothrow));
// item access
// func:ams.Trace2Msg.data_curs.Access
u64&                 Trace2Msg_data_curs_Access(Trace2Msg_data_curs &curs) __attribute__((nothrow));
// func:ams.Trace2Msg..ReadFieldMaybe
bool                 Trace2Msg_ReadFieldMaybe(ams::Trace2Msg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::Trace2Msg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.Trace2Msg..ReadStrptrMaybe
bool                 Trace2Msg_ReadStrptrMaybe(ams::Trace2Msg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.Trace2Msg..GetMsgLength
i32                  GetMsgLength(const ams::Trace2Msg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.Trace2Msg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::Trace2Msg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.Trace2Msg..Init
void                 Trace2Msg_Init(ams::Trace2Msg& parent);
// print string representation of ROW to string STR
// cfmt:ams.Trace2Msg.String  printfmt:Tuple
// func:ams.Trace2Msg..Print
void                 Trace2Msg_Print(ams::Trace2Msg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.TraceInfo2Msg
#pragma pack(push,1)
struct TraceInfo2Msg { // ams.TraceInfo2Msg: Trace info message
    u32            type;     //   109
    u32            length;   //   ssizeof(parent) + (0)
    ams::ProcId    proc;     //
    u8             trace;    //   0
    algo::UnTime   tstamp;   //
    u8             part;     //   0
    // var-length field ams.TraceInfo2Msg.data starts here. access it with data_Addr
    explicit TraceInfo2Msg(ams::ProcId                    in_proc
        ,u8                             in_trace
        ,algo::UnTime                   in_tstamp
        ,u8                             in_part);
    TraceInfo2Msg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.TraceInfo2Msg.base.CopyOut
void                 parent_CopyOut(ams::TraceInfo2Msg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of TraceInfo2Msg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TraceInfo2Msg.
// If not successful, quietly return NULL.
// func:ams.TraceInfo2Msg.base.Castdown
ams::TraceInfo2Msg*  TraceInfo2Msg_Castdown(ams::MsgHeader &hdr);
// func:ams.TraceInfo2Msg.base.Castbase
ams::MsgHeader&      Castbase(ams::TraceInfo2Msg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.TraceInfo2Msg.data.Getary
algo::aryptr<char>   data_Getary(ams::TraceInfo2Msg& parent) __attribute__((nothrow));
// func:ams.TraceInfo2Msg.data.Addr
char*                data_Addr(ams::TraceInfo2Msg& parent);
// Return number of elements in varlen field
// func:ams.TraceInfo2Msg.data.N
u32                  data_N(const ams::TraceInfo2Msg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.TraceInfo2Msg.data.ReadStrptrMaybe
bool                 data_ReadStrptrMaybe(ams::TraceInfo2Msg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert data to a string.
// Array is printed as a regular string.
// func:ams.TraceInfo2Msg.data.Print
void                 data_Print(ams::TraceInfo2Msg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.TraceInfo2Msg.data_curs.Reset
void                 TraceInfo2Msg_data_curs_Reset(TraceInfo2Msg_data_curs &curs, ams::TraceInfo2Msg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.TraceInfo2Msg.data_curs.ValidQ
bool                 TraceInfo2Msg_data_curs_ValidQ(TraceInfo2Msg_data_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.TraceInfo2Msg.data_curs.Next
void                 TraceInfo2Msg_data_curs_Next(TraceInfo2Msg_data_curs &curs) __attribute__((nothrow));
// item access
// func:ams.TraceInfo2Msg.data_curs.Access
char&                TraceInfo2Msg_data_curs_Access(TraceInfo2Msg_data_curs &curs) __attribute__((nothrow));
// func:ams.TraceInfo2Msg..ReadFieldMaybe
bool                 TraceInfo2Msg_ReadFieldMaybe(ams::TraceInfo2Msg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::TraceInfo2Msg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.TraceInfo2Msg..ReadStrptrMaybe
bool                 TraceInfo2Msg_ReadStrptrMaybe(ams::TraceInfo2Msg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.TraceInfo2Msg..GetMsgLength
i32                  GetMsgLength(const ams::TraceInfo2Msg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.TraceInfo2Msg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::TraceInfo2Msg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.TraceInfo2Msg..Init
void                 TraceInfo2Msg_Init(ams::TraceInfo2Msg& parent);
// print string representation of ROW to string STR
// cfmt:ams.TraceInfo2Msg.String  printfmt:Tuple
// func:ams.TraceInfo2Msg..Print
void                 TraceInfo2Msg_Print(ams::TraceInfo2Msg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.TraceInfoMsg
#pragma pack(push,1)
struct TraceInfoMsg { // ams.TraceInfoMsg: Trace info message
    u32            type;     //   9
    u32            length;   //   ssizeof(parent) + (0)
    ams::ProcId    proc;     //
    algo::UnTime   tstamp;   //
    u8             part;     //   0
    // var-length field ams.TraceInfoMsg.data starts here. access it with data_Addr
    explicit TraceInfoMsg(ams::ProcId                    in_proc
        ,algo::UnTime                   in_tstamp
        ,u8                             in_part);
    TraceInfoMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.TraceInfoMsg.base.CopyOut
void                 parent_CopyOut(ams::TraceInfoMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of TraceInfoMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TraceInfoMsg.
// If not successful, quietly return NULL.
// func:ams.TraceInfoMsg.base.Castdown
ams::TraceInfoMsg*   TraceInfoMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.TraceInfoMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::TraceInfoMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.TraceInfoMsg.data.Getary
algo::aryptr<char>   data_Getary(ams::TraceInfoMsg& parent) __attribute__((nothrow));
// func:ams.TraceInfoMsg.data.Addr
char*                data_Addr(ams::TraceInfoMsg& parent);
// Return number of elements in varlen field
// func:ams.TraceInfoMsg.data.N
u32                  data_N(const ams::TraceInfoMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.TraceInfoMsg.data.ReadStrptrMaybe
bool                 data_ReadStrptrMaybe(ams::TraceInfoMsg& parent, algo::strptr in_str) __attribute__((nothrow));
// Convert data to a string.
// Array is printed as a regular string.
// func:ams.TraceInfoMsg.data.Print
void                 data_Print(ams::TraceInfoMsg& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.TraceInfoMsg.data_curs.Reset
void                 TraceInfoMsg_data_curs_Reset(TraceInfoMsg_data_curs &curs, ams::TraceInfoMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.TraceInfoMsg.data_curs.ValidQ
bool                 TraceInfoMsg_data_curs_ValidQ(TraceInfoMsg_data_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.TraceInfoMsg.data_curs.Next
void                 TraceInfoMsg_data_curs_Next(TraceInfoMsg_data_curs &curs) __attribute__((nothrow));
// item access
// func:ams.TraceInfoMsg.data_curs.Access
char&                TraceInfoMsg_data_curs_Access(TraceInfoMsg_data_curs &curs) __attribute__((nothrow));
// func:ams.TraceInfoMsg..ReadFieldMaybe
bool                 TraceInfoMsg_ReadFieldMaybe(ams::TraceInfoMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::TraceInfoMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.TraceInfoMsg..ReadStrptrMaybe
bool                 TraceInfoMsg_ReadStrptrMaybe(ams::TraceInfoMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.TraceInfoMsg..GetMsgLength
i32                  GetMsgLength(const ams::TraceInfoMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.TraceInfoMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::TraceInfoMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.TraceInfoMsg..Init
void                 TraceInfoMsg_Init(ams::TraceInfoMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.TraceInfoMsg.String  printfmt:Tuple
// func:ams.TraceInfoMsg..Print
void                 TraceInfoMsg_Print(ams::TraceInfoMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.TraceMsg
#pragma pack(push,1)
struct TraceMsg { // ams.TraceMsg: Trace message
    u32            type;     //   8
    u32            length;   //   ssizeof(parent) + (0)
    ams::ProcId    proc;     //
    algo::UnTime   tstamp;   //
    // var-length field ams.TraceMsg.data starts here. access it with data_Addr
    explicit TraceMsg(ams::ProcId                    in_proc
        ,algo::UnTime                   in_tstamp);
    TraceMsg();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.TraceMsg.base.CopyOut
void                 parent_CopyOut(ams::TraceMsg &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of TraceMsg by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of TraceMsg.
// If not successful, quietly return NULL.
// func:ams.TraceMsg.base.Castdown
ams::TraceMsg*       TraceMsg_Castdown(ams::MsgHeader &hdr);
// func:ams.TraceMsg.base.Castbase
ams::MsgHeader&      Castbase(ams::TraceMsg& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.TraceMsg.data.Getary
algo::aryptr<u64>    data_Getary(ams::TraceMsg& parent) __attribute__((nothrow));
// func:ams.TraceMsg.data.Addr
u64*                 data_Addr(ams::TraceMsg& parent);
// Return number of elements in varlen field
// func:ams.TraceMsg.data.N
u32                  data_N(const ams::TraceMsg& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert string to field. Return success value
// func:ams.TraceMsg.data.ReadStrptrMaybe
bool                 data_ReadStrptrMaybe(ams::TraceMsg& parent, algo::strptr in_str) __attribute__((nothrow));

// func:ams.TraceMsg.data_curs.Reset
void                 TraceMsg_data_curs_Reset(TraceMsg_data_curs &curs, ams::TraceMsg &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.TraceMsg.data_curs.ValidQ
bool                 TraceMsg_data_curs_ValidQ(TraceMsg_data_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.TraceMsg.data_curs.Next
void                 TraceMsg_data_curs_Next(TraceMsg_data_curs &curs) __attribute__((nothrow));
// item access
// func:ams.TraceMsg.data_curs.Access
u64&                 TraceMsg_data_curs_Access(TraceMsg_data_curs &curs) __attribute__((nothrow));
// func:ams.TraceMsg..ReadFieldMaybe
bool                 TraceMsg_ReadFieldMaybe(ams::TraceMsg& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Any varlen fields are returned in algo_lib::_db.varlenbuf if set
// Read fields of ams::TraceMsg from an ascii string.
// The format of the string is an ssim Tuple
// func:ams.TraceMsg..ReadStrptrMaybe
bool                 TraceMsg_ReadStrptrMaybe(ams::TraceMsg &parent, algo::strptr in_str) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.TraceMsg..GetMsgLength
i32                  GetMsgLength(const ams::TraceMsg& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.TraceMsg..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::TraceMsg& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.TraceMsg..Init
void                 TraceMsg_Init(ams::TraceMsg& parent);
// print string representation of ROW to string STR
// cfmt:ams.TraceMsg.String  printfmt:Tuple
// func:ams.TraceMsg..Print
void                 TraceMsg_Print(ams::TraceMsg& row, algo::cstring& str) __attribute__((nothrow));

// --- ams.UdpFrame
#pragma pack(push,1)
struct UdpFrame { // ams.UdpFrame: sniffer-captured ethernet frame
    u32            type;        //   2
    u32            length;      //   ssizeof(parent) + (0)
    algo::UnTime   timestamp;   // Timestamp
    ietf::Ipv4     src_ip;      // Source IP
    ietf::Ipv4     dst_ip;      // Destination IP
    u16            src_port;    //   0  Source UDP port
    u16            dst_port;    //   0  Destination UDP port
    // var-length field ams.UdpFrame.payload starts here. access it with payload_Addr
    UdpFrame();
};
#pragma pack(pop)

// Copy fields out of row
// func:ams.UdpFrame.header.CopyOut
void                 parent_CopyOut(ams::UdpFrame &row, ams::MsgHeader &out) __attribute__((nothrow));
// Check if ams::MsgHeader is an instance of UdpFrame by checking the type field
// If it is, return the pointer of target type.
// Additionally, check if the length field permits valid instance of UdpFrame.
// If not successful, quietly return NULL.
// func:ams.UdpFrame.header.Castdown
ams::UdpFrame*       UdpFrame_Castdown(ams::MsgHeader &hdr);
// func:ams.UdpFrame.header.Castbase
ams::MsgHeader&      Castbase(ams::UdpFrame& parent);

// Access var-length portion as an aryptr. Length is determined from one of the fields.
// func:ams.UdpFrame.payload.Getary
algo::aryptr<u8>     payload_Getary(ams::UdpFrame& parent) __attribute__((nothrow));
// func:ams.UdpFrame.payload.Addr
u8*                  payload_Addr(ams::UdpFrame& parent);
// Return number of elements in varlen field
// func:ams.UdpFrame.payload.N
u32                  payload_N(const ams::UdpFrame& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Convert payload to a string.
// Array is printed as a regular string.
// func:ams.UdpFrame.payload.Print
void                 payload_Print(ams::UdpFrame& parent, algo::cstring &rhs) __attribute__((nothrow));

// func:ams.UdpFrame.payload_curs.Reset
void                 UdpFrame_payload_curs_Reset(UdpFrame_payload_curs &curs, ams::UdpFrame &parent) __attribute__((nothrow));
// cursor points to valid item
// func:ams.UdpFrame.payload_curs.ValidQ
bool                 UdpFrame_payload_curs_ValidQ(UdpFrame_payload_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:ams.UdpFrame.payload_curs.Next
void                 UdpFrame_payload_curs_Next(UdpFrame_payload_curs &curs) __attribute__((nothrow));
// item access
// func:ams.UdpFrame.payload_curs.Access
u8&                  UdpFrame_payload_curs_Access(UdpFrame_payload_curs &curs) __attribute__((nothrow));
// Message length (uses length field)
// func:ams.UdpFrame..GetMsgLength
i32                  GetMsgLength(const ams::UdpFrame& parent) __attribute__((nothrow));
// Memptr encompassing the message (uses length field)
// func:ams.UdpFrame..GetMsgMemptr
algo::memptr         GetMsgMemptr(const ams::UdpFrame& row) __attribute__((nothrow));
// Set all fields to initial values.
// func:ams.UdpFrame..Init
void                 UdpFrame_Init(ams::UdpFrame& parent);
// print string representation of ROW to string STR
// cfmt:ams.UdpFrame.String  printfmt:Tuple
// func:ams.UdpFrame..Print
void                 UdpFrame_Print(ams::UdpFrame& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace ams { // gen:ns_curstext

struct ExpectMsg_text_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    ExpectMsg_text_curs() { ptr=NULL; length=0; index=0; }
};


struct InputLineMsg_payload_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    InputLineMsg_payload_curs() { ptr=NULL; length=0; index=0; }
};


struct LogMsg_text_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    LogMsg_text_curs() { ptr=NULL; length=0; index=0; }
};


struct MsgBlock_messages_curs {// cursor
    typedef u8 ChildType;
    u8 *ptr;
    int length;
    int index;
    MsgBlock_messages_curs() { ptr=NULL; length=0; index=0; }
};


struct Trace2Msg_data_curs {// cursor
    typedef u64 ChildType;
    u8 *ptr;
    int length;
    int index;
    Trace2Msg_data_curs() { ptr=NULL; length=0; index=0; }
};


struct TraceInfo2Msg_data_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    TraceInfo2Msg_data_curs() { ptr=NULL; length=0; index=0; }
};


struct TraceInfoMsg_data_curs {// cursor
    typedef char ChildType;
    u8 *ptr;
    int length;
    int index;
    TraceInfoMsg_data_curs() { ptr=NULL; length=0; index=0; }
};


struct TraceMsg_data_curs {// cursor
    typedef u64 ChildType;
    u8 *ptr;
    int length;
    int index;
    TraceMsg_data_curs() { ptr=NULL; length=0; index=0; }
};


struct UdpFrame_payload_curs {// cursor
    typedef u8 ChildType;
    u8 *ptr;
    int length;
    int index;
    UdpFrame_payload_curs() { ptr=NULL; length=0; index=0; }
};

} // gen:ns_curstext
namespace ams { // gen:ns_func
// func:ams...StaticCheck
void                 StaticCheck();
// Print message to STR. If message is too short for MSG_LEN, print nothing.
// MSG.LENGTH must have already been validated against msg_len.
// This function will additionally validate that sizeof(Msg) <= msg_len
// func:ams.MsgHeaderMsgs..Print
bool                 MsgHeaderMsgs_Print(algo::cstring &str, ams::MsgHeader &msg, u32 msg_len);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:ams.MsgHeaderMsgs..ReadStrptr
ams::MsgHeaderMsgsCase MsgHeaderMsgs_ReadStrptr(algo::strptr str, algo::ByteAry &buf);
// Parse ascii representation of message into binary, appending new data to BUF.
// func:ams.MsgHeaderMsgs..ReadStrptrMaybe
bool                 MsgHeaderMsgs_ReadStrptrMaybe(algo::strptr str, algo::ByteAry &buf);
// Construct a new ams::LogMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...LogMsg_FmtByteAry
ams::LogMsg *        LogMsg_FmtByteAry(algo::ByteAry &buf, const algo::strptr& logcat, algo::SchedTime tstamp, algo::aryptr<char > text);
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...MsgBlock_FmtByteAry
ams::MsgBlock *      MsgBlock_FmtByteAry(algo::ByteAry &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages);
// Construct a new ams::MsgBlock in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:ams...MsgBlock_FmtMemptr
ams::MsgBlock *      MsgBlock_FmtMemptr(algo::memptr &buf, u64 first_seqno, u32 n_messages, u32 original_length, algo::aryptr<u8 > messages);
// Construct a new ams::SeqmsgTrace in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...SeqmsgTrace_FmtByteAry
ams::SeqmsgTrace *   SeqmsgTrace_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc_id, u8 mode, ams::SeqmsgId seqmsg_id, u64 tsc, ams::MsgHeader* payload);
// Construct a new ams::Trace2Msg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...Trace2Msg_FmtByteAry
ams::Trace2Msg *     Trace2Msg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, u8 trace, algo::UnTime tstamp, algo::aryptr<u64 > data);
// Construct a new ams::TraceInfo2Msg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...TraceInfo2Msg_FmtByteAry
ams::TraceInfo2Msg * TraceInfo2Msg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, u8 trace, algo::UnTime tstamp, u8 part, algo::aryptr<char > data);
// Construct a new ams::TraceInfoMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...TraceInfoMsg_FmtByteAry
ams::TraceInfoMsg *  TraceInfoMsg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, algo::UnTime tstamp, u8 part, algo::aryptr<char > data);
// Construct a new ams::TraceMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...TraceMsg_FmtByteAry
ams::TraceMsg *      TraceMsg_FmtByteAry(algo::ByteAry &buf, ams::ProcId proc, algo::UnTime tstamp, algo::aryptr<u64 > data);
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:ams...UdpFrame_FmtByteAry
ams::UdpFrame *      UdpFrame_FmtByteAry(algo::ByteAry &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload);
// Construct a new ams::UdpFrame in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// After constructing, advance BUF appropriate number of bytes forward
// func:ams...UdpFrame_FmtMemptr
ams::UdpFrame *      UdpFrame_FmtMemptr(algo::memptr &buf, algo::UnTime timestamp, ietf::Ipv4 src_ip, ietf::Ipv4 dst_ip, u16 src_port, u16 dst_port, algo::aryptr<u8 > payload);
} // gen:ns_func
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const ams::AlarmSyncMsg &row);// cfmt:ams.AlarmSyncMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcId &row);// cfmt:ams.ProcId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::StreamType &row);// cfmt:ams.StreamType.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::StreamId &row);// cfmt:ams.StreamId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::DfltStream &row);// cfmt:ams.DfltStream.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::DumpStreamTableMsg &row);// cfmt:ams.DumpStreamTableMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ExpectMsg &row);// cfmt:ams.ExpectMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::FieldId &row);// cfmt:ams.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::HeartbeatMsg &row);// cfmt:ams.HeartbeatMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::InputLineMsg &row);// cfmt:ams.InputLineMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::Member &row);// cfmt:ams.Member.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::MsgBlock &row);// cfmt:ams.MsgBlock.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::MsgHeader &row);// cfmt:ams.MsgHeader.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::StreamPos &row);// cfmt:ams.StreamPos.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::OpenMsg &row);// cfmt:ams.OpenMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::PrlogMsg &row);// cfmt:ams.PrlogMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcAddMsg &row);// cfmt:ams.ProcAddMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::ProcRemoveMsg &row);// cfmt:ams.ProcRemoveMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::SeqmsgId &row);// cfmt:ams.SeqmsgId.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::Seqmsg &row);// cfmt:ams.Seqmsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::SeqmsgTrace &row);// cfmt:ams.SeqmsgTrace.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::StreamFlags &row);// cfmt:ams.StreamFlags.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::StreamHbMsg &row);// cfmt:ams.StreamHbMsg.String
inline algo::cstring &operator <<(algo::cstring &str, const ams::UdpFrame &row);// cfmt:ams.UdpFrame.String
}
