//
// include/gen/algo_lib_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.inl.h"
#include "include/gen/dmmeta_gen.inl.h"
//#pragma endinclude
static algo_lib::FLogcat &algo_lib_logcat_expect   = ((algo_lib::FLogcat*)algo_lib::_db.logcat_data)[0];
static algo_lib::FLogcat &algo_lib_logcat_stderr   = ((algo_lib::FLogcat*)algo_lib::_db.logcat_data)[1];
static algo_lib::FLogcat &algo_lib_logcat_stdout   = ((algo_lib::FLogcat*)algo_lib::_db.logcat_data)[2];
inline algo_lib::Bitset::Bitset() {
    algo_lib::Bitset_Init(*this);
}

inline algo_lib::Bitset::~Bitset() {
    algo_lib::Bitset_Uninit(*this);
}


// --- algo_lib.Bitset.ary.NBits
// Get max # of bits in the bitset
// Return max. number of bits supported by array
inline int algo_lib::ary_Nbits(algo_lib::Bitset& parent) {
    return ary_N(parent) * 64;
}

// --- algo_lib.Bitset.ary.qGetBit
// Retrieve value of bit #BIT_IDX in bit set. No bounds checking
inline bool algo_lib::ary_qGetBit(algo_lib::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ary_qFind(parent, elem_idx); // fetch element
    return bool((elem >> shift) & 1); // extract bit
}

// --- algo_lib.Bitset.ary.GetBit
// Retrieve value of bit #BIT_IDX in bit set. If bit index is out of bounds, return 0.
inline bool algo_lib::ary_GetBit(algo_lib::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    bool ret = false;
    u64 lim = ary_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ary_qFind(parent, elem_idx); // fetch element
        ret = (elem >> shift) & 1;                 // extract bit
    }
    return ret;
}

// --- algo_lib.Bitset.ary.BitsEmptyQ
// Check if all the bits in the bitset are equal to zero
inline bool algo_lib::ary_BitsEmptyQ(algo_lib::Bitset& parent) {
    bool retval = true;
    u64 n = ary_N(parent);
    for (u64 i = 0; i < n; i++) {
        if (ary_qFind(parent,i) != 0) {
            retval = false;
            break;
        }
    }
    return retval;
}

// --- algo_lib.Bitset.ary.Sum1s
inline u64 algo_lib::ary_Sum1s(algo_lib::Bitset& parent) {
    u64 sum = 0;
    u64 n = ary_N(parent);
    for (u64 i = 0; i < n; i++) {
        sum += algo::u64_Count1s(ary_qFind(parent, i));
    }
    return sum;
}

// --- algo_lib.Bitset.ary.qClearBit
// Clear bit # BIT_IDX in bit set. No bounds checking
inline void algo_lib::ary_qClearBit(algo_lib::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ary_qFind(parent, elem_idx); // fetch
    elem = elem & ~(u64(1) << shift); // clear bit
}

// --- algo_lib.Bitset.ary.ClearBit
// Clear bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing
inline void algo_lib::ary_ClearBit(algo_lib::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = ary_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ary_qFind(parent, elem_idx); // fetch
        elem = elem & ~(u64(1) << shift); // clear bit
    }
}

// --- algo_lib.Bitset.ary.qSetBit
// Set bit # BIT_IDX in bit set. No bounds checking
inline void algo_lib::ary_qSetBit(algo_lib::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ary_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(1) << shift); // set bit
}

// --- algo_lib.Bitset.ary.SetBit
// Set bit # BIT_IDX in bit set. If bit index is out of bounds, do nothing.
inline void algo_lib::ary_SetBit(algo_lib::Bitset& parent, u32 bit_idx) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 lim = ary_N(parent);
    if (elem_idx < lim) {
        u64 &elem = ary_qFind(parent, elem_idx); // fetch
        elem = elem | (u64(1) << shift); // set bit
    }
}

// --- algo_lib.Bitset.ary.qSetBitVal
// Set bit # BIT_IDX in bit set. No bounds checking
inline void algo_lib::ary_qSetBitVal(algo_lib::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ary_qFind(parent, elem_idx); // fetch
    elem = (elem & ~(u64(1) << shift)) | (u64(val) << shift); // insert new value
}

// --- algo_lib.Bitset.ary.qOrBitVal
// Or bit # BIT_IDX in bit set. No bounds checking
inline void algo_lib::ary_qOrBitVal(algo_lib::Bitset& parent, u32 bit_idx, bool val) {
    u64 elem_idx = bit_idx >> 6;
    u64 shift = bit_idx & 63;
    u64 &elem = ary_qFind(parent, elem_idx); // fetch
    elem = elem | (u64(val) << shift); // Or in val into elem
}

// --- algo_lib.Bitset.ary.ClearBitsAll
// Set all bits of array to zero.
// Note: this does not change what NBits will return.
inline void algo_lib::ary_ClearBitsAll(algo_lib::Bitset& parent) {
    u64 n = ary_N(parent);
    for (u64 i = 0; i < n; i++) {
        ary_qFind(parent, i) = 0;
    }
}

// --- algo_lib.Bitset.ary.ClearBits
// Zero in PARENT any bits that are set in RHS.
inline void algo_lib::ary_ClearBits(algo_lib::Bitset& parent, algo_lib::Bitset &rhs) {
    u64 n = u64_Min(ary_N(parent), ary_N(rhs));
    for (u64 i = 0; i < n; i++) {
        ary_qFind(parent, i) &= ~ary_qFind(rhs, i);
    }
}

// --- algo_lib.Bitset.ary.OrBits
// Set PARENT to union of two bitsets.
// (This function is not named Set.. to avoid triple entendre).
inline void algo_lib::ary_OrBits(algo_lib::Bitset& parent, algo_lib::Bitset &rhs) {
    u64 n = u64_Min(ary_N(parent), ary_N(rhs));
    for (u64 i = 0; i < n; i++) {
        ary_qFind(parent, i) |= ary_qFind(rhs, i);
    }
}

// --- algo_lib.Bitset.ary.Sup
// Return smallest number N such that indexes of all 1 bits are below N
inline i32 algo_lib::ary_Sup(algo_lib::Bitset& parent) {
    u64 lim = ary_N(parent);
    i32 ret = 0;
    for (int i = lim-1; i >= 0; i--) {
        u64 &val = ary_qFind(parent, i);
        if (val) {
            u32 bitidx = algo::u64_BitScanReverse(val) + 1;
            ret = i * 64 + bitidx;
            break;
        }
    }
    return ret;
}

// --- algo_lib.Bitset.ary.EmptyQ
// Return true if index is empty
inline bool algo_lib::ary_EmptyQ(algo_lib::Bitset& parent) {
    return parent.ary_n == 0;
}

// --- algo_lib.Bitset.ary.Find
// Look up row by row id. Return NULL if out of range
inline u64* algo_lib::ary_Find(algo_lib::Bitset& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.ary_n;
    if (idx >= lim) return NULL;
    return parent.ary_elems + idx;
}

// --- algo_lib.Bitset.ary.Getary
// Return array pointer by value
inline algo::aryptr<u64> algo_lib::ary_Getary(algo_lib::Bitset& parent) {
    return algo::aryptr<u64>(parent.ary_elems, parent.ary_n);
}

// --- algo_lib.Bitset.ary.Last
// Return pointer to last element of array, or NULL if array is empty
inline u64* algo_lib::ary_Last(algo_lib::Bitset& parent) {
    return ary_Find(parent, u64(parent.ary_n-1));
}

// --- algo_lib.Bitset.ary.Max
// Return max. number of items in the array
inline i32 algo_lib::ary_Max(algo_lib::Bitset& parent) {
    (void)parent;
    return parent.ary_max;
}

// --- algo_lib.Bitset.ary.N
// Return number of items in the array
inline i32 algo_lib::ary_N(const algo_lib::Bitset& parent) {
    return parent.ary_n;
}

// --- algo_lib.Bitset.ary.RemoveAll
inline void algo_lib::ary_RemoveAll(algo_lib::Bitset& parent) {
    parent.ary_n = 0;
}

// --- algo_lib.Bitset.ary.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::ary_Reserve(algo_lib::Bitset& parent, int n) {
    u32 new_n = parent.ary_n + n;
    if (UNLIKELY(new_n > parent.ary_max)) {
        ary_AbsReserve(parent, new_n);
    }
}

// --- algo_lib.Bitset.ary.qFind
// 'quick' Access row by row id. No bounds checking.
inline u64& algo_lib::ary_qFind(algo_lib::Bitset& parent, u64 t) {
    return parent.ary_elems[t];
}

// --- algo_lib.Bitset.ary.qLast
// Return reference to last element of array. No bounds checking
inline u64& algo_lib::ary_qLast(algo_lib::Bitset& parent) {
    return ary_qFind(parent, u64(parent.ary_n-1));
}

// --- algo_lib.Bitset.ary.rowid_Get
// Return row id of specified element
inline u64 algo_lib::ary_rowid_Get(algo_lib::Bitset& parent, u64 &elem) {
    u64 id = &elem - parent.ary_elems;
    return u64(id);
}

// --- algo_lib.Bitset.ary_bitcurs.ValidQ
// cursor points to valid item
inline bool algo_lib::Bitset_ary_bitcurs_ValidQ(Bitset_ary_bitcurs &curs) {
    return curs.bit < curs.n_elems*64;
}

// --- algo_lib.Bitset.ary_bitcurs.Access
// item access
inline int& algo_lib::Bitset_ary_bitcurs_Access(Bitset_ary_bitcurs &curs) {
    return curs.bit;
}

// --- algo_lib.Bitset.ary_curs.Next
// proceed to next item
inline void algo_lib::Bitset_ary_curs_Next(Bitset_ary_curs &curs) {
    curs.index++;
}

// --- algo_lib.Bitset.ary_curs.Reset
inline void algo_lib::Bitset_ary_curs_Reset(Bitset_ary_curs &curs, algo_lib::Bitset &parent) {
    curs.elems = parent.ary_elems;
    curs.n_elems = parent.ary_n;
    curs.index = 0;
}

// --- algo_lib.Bitset.ary_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::Bitset_ary_curs_ValidQ(Bitset_ary_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.Bitset.ary_curs.Access
// item access
inline u64& algo_lib::Bitset_ary_curs_Access(Bitset_ary_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.Bitset..Init
// Set all fields to initial values.
inline void algo_lib::Bitset_Init(algo_lib::Bitset& parent) {
    parent.ary_elems 	= 0; // (algo_lib.Bitset.ary)
    parent.ary_n     	= 0; // (algo_lib.Bitset.ary)
    parent.ary_max   	= 0; // (algo_lib.Bitset.ary)
}
inline algo_lib::Cmdline::Cmdline() {
    algo_lib::Cmdline_Init(*this);
}


// --- algo_lib.Cmdline.v.Get
// Alias: value is retrieved from verbose
inline u8 algo_lib::v_Get(const algo_lib::Cmdline& parent) {
    return parent.verbose;
}

// --- algo_lib.Cmdline.d.Get
// Alias: value is retrieved from debug
inline u8 algo_lib::d_Get(const algo_lib::Cmdline& parent) {
    return parent.debug;
}

// --- algo_lib.Cmdline.sig.Get
// Alias: value is retrieved from signature
inline bool algo_lib::sig_Get(const algo_lib::Cmdline& parent) {
    return parent.signature;
}

// --- algo_lib.Cmdline.h.Get
// Alias: value is retrieved from help
inline bool algo_lib::h_Get(const algo_lib::Cmdline& parent) {
    return parent.help;
}

// --- algo_lib.Cmdline..Init
// Set all fields to initial values.
inline void algo_lib::Cmdline_Init(algo_lib::Cmdline& parent) {
    parent.verbose = u8(0);
    parent.debug = u8(0);
    parent.help = bool(false);
    parent.version = bool(false);
    parent.signature = bool(false);
}
inline algo_lib::CsvParse::CsvParse(algo::strptr                   in_input
        ,char                           in_sep
        ,char                           in_quotechar1
        ,char                           in_quotechar2
        ,bool                           in_openquote)
    : input(in_input)
    , sep(in_sep)
    , quotechar1(in_quotechar1)
    , quotechar2(in_quotechar2)
    , openquote(in_openquote)
{
}
inline algo_lib::CsvParse::CsvParse() {
    algo_lib::CsvParse_Init(*this);
}

inline algo_lib::CsvParse::~CsvParse() {
    algo_lib::CsvParse_Uninit(*this);
}


// --- algo_lib.CsvParse.ary_tok.EmptyQ
// Return true if index is empty
inline bool algo_lib::ary_tok_EmptyQ(algo_lib::CsvParse& csvparse) {
    return csvparse.ary_tok_n == 0;
}

// --- algo_lib.CsvParse.ary_tok.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* algo_lib::ary_tok_Find(algo_lib::CsvParse& csvparse, u64 t) {
    u64 idx = t;
    u64 lim = csvparse.ary_tok_n;
    if (idx >= lim) return NULL;
    return csvparse.ary_tok_elems + idx;
}

// --- algo_lib.CsvParse.ary_tok.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> algo_lib::ary_tok_Getary(algo_lib::CsvParse& csvparse) {
    return algo::aryptr<algo::cstring>(csvparse.ary_tok_elems, csvparse.ary_tok_n);
}

// --- algo_lib.CsvParse.ary_tok.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* algo_lib::ary_tok_Last(algo_lib::CsvParse& csvparse) {
    return ary_tok_Find(csvparse, u64(csvparse.ary_tok_n-1));
}

// --- algo_lib.CsvParse.ary_tok.Max
// Return max. number of items in the array
inline i32 algo_lib::ary_tok_Max(algo_lib::CsvParse& csvparse) {
    (void)csvparse;
    return csvparse.ary_tok_max;
}

// --- algo_lib.CsvParse.ary_tok.N
// Return number of items in the array
inline i32 algo_lib::ary_tok_N(const algo_lib::CsvParse& csvparse) {
    return csvparse.ary_tok_n;
}

// --- algo_lib.CsvParse.ary_tok.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::ary_tok_Reserve(algo_lib::CsvParse& csvparse, int n) {
    u32 new_n = csvparse.ary_tok_n + n;
    if (UNLIKELY(new_n > csvparse.ary_tok_max)) {
        ary_tok_AbsReserve(csvparse, new_n);
    }
}

// --- algo_lib.CsvParse.ary_tok.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& algo_lib::ary_tok_qFind(algo_lib::CsvParse& csvparse, u64 t) {
    return csvparse.ary_tok_elems[t];
}

// --- algo_lib.CsvParse.ary_tok.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& algo_lib::ary_tok_qLast(algo_lib::CsvParse& csvparse) {
    return ary_tok_qFind(csvparse, u64(csvparse.ary_tok_n-1));
}

// --- algo_lib.CsvParse.ary_tok.rowid_Get
// Return row id of specified element
inline u64 algo_lib::ary_tok_rowid_Get(algo_lib::CsvParse& csvparse, algo::cstring &elem) {
    u64 id = &elem - csvparse.ary_tok_elems;
    return u64(id);
}

// --- algo_lib.CsvParse.ary_tok_curs.Next
// proceed to next item
inline void algo_lib::csvparse_ary_tok_curs_Next(csvparse_ary_tok_curs &curs) {
    curs.index++;
}

// --- algo_lib.CsvParse.ary_tok_curs.Reset
inline void algo_lib::csvparse_ary_tok_curs_Reset(csvparse_ary_tok_curs &curs, algo_lib::CsvParse &parent) {
    curs.elems = parent.ary_tok_elems;
    curs.n_elems = parent.ary_tok_n;
    curs.index = 0;
}

// --- algo_lib.CsvParse.ary_tok_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::csvparse_ary_tok_curs_ValidQ(csvparse_ary_tok_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.CsvParse.ary_tok_curs.Access
// item access
inline algo::cstring& algo_lib::csvparse_ary_tok_curs_Access(csvparse_ary_tok_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.CsvParse..Init
// Set all fields to initial values.
inline void algo_lib::CsvParse_Init(algo_lib::CsvParse& csvparse) {
    csvparse.sep = char(',');
    csvparse.quotechar1 = char('\"');
    csvparse.quotechar2 = char('\'');
    csvparse.ary_tok_elems 	= 0; // (algo_lib.CsvParse.ary_tok)
    csvparse.ary_tok_n     	= 0; // (algo_lib.CsvParse.ary_tok)
    csvparse.ary_tok_max   	= 0; // (algo_lib.CsvParse.ary_tok)
    csvparse.openquote = bool(true);
}
inline algo_lib::ErrorX::ErrorX(const algo::strptr&            in_str)
    : str(in_str)
{
}
inline algo_lib::ErrorX::ErrorX() {
}

inline algo_lib::FFildes::FFildes() {
}

inline algo_lib::FFildes::~FFildes() {
    algo_lib::FFildes_Uninit(*this);
}

inline algo_lib::FLockfile::FLockfile() {
}

inline algo_lib::FLockfile::~FLockfile() {
    algo_lib::FLockfile_Uninit(*this);
}

inline algo_lib::FTimehook::FTimehook() {
    algo_lib::FTimehook_Init(*this);
}

inline algo_lib::FTimehook::~FTimehook() {
    algo_lib::FTimehook_Uninit(*this);
}


// --- algo_lib.FTimehook.time.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool algo_lib::time_Lt(algo_lib::FTimehook& timehook, algo_lib::FTimehook &rhs) {
    return algo::SchedTime_Lt(timehook.time,rhs.time);
}

// --- algo_lib.FTimehook.time.Cmp
// Compare two fields.
inline i32 algo_lib::time_Cmp(algo_lib::FTimehook& timehook, algo_lib::FTimehook &rhs) {
    i32 retval = 0;
    retval = algo::SchedTime_Cmp(timehook.time, rhs.time);
    return retval;
}

// --- algo_lib.FTimehook.hook.Call
// Invoke function by pointer
inline void algo_lib::hook_Call(algo_lib::FTimehook& timehook, algo_lib::FTimehook& arg) {
    if (timehook.hook) {
        timehook.hook((void*)timehook.hook_ctx, arg);
    }
}

// --- algo_lib.FTimehook.hook.Set0
// Assign 0-argument hook with no context pointer
inline void algo_lib::hook_Set0(algo_lib::FTimehook& timehook, void (*fcn)() ) {
    timehook.hook_ctx = 0;
    timehook.hook = (algo_lib::timehook_hook_hook)fcn;
}

// --- algo_lib.FTimehook.hook.Set1
// Assign 1-argument hook with context pointer
template<class T> inline void algo_lib::hook_Set1(algo_lib::FTimehook& timehook, T& ctx, void (*fcn)(T&) ) {
    timehook.hook_ctx = (u64)&ctx;
    timehook.hook = (algo_lib::timehook_hook_hook)fcn;
}

// --- algo_lib.FTimehook.hook.Set2
// Assign 2-argument hook with context pointer
template<class T> inline void algo_lib::hook_Set2(algo_lib::FTimehook& timehook, T& ctx, void (*fcn)(T&, algo_lib::FTimehook& arg) ) {
    timehook.hook_ctx = (u64)&ctx;
    timehook.hook = (algo_lib::timehook_hook_hook)fcn;
}

// --- algo_lib.FTimehook..Init
// Set all fields to initial values.
inline void algo_lib::FTimehook_Init(algo_lib::FTimehook& timehook) {
    timehook.recurrent = bool(false);
    timehook.hook = NULL;
    timehook.hook_ctx = 0;
    timehook.bh_timehook_idx = -1; // (algo_lib.FDb.bh_timehook) not-in-heap
}
inline algo_lib::FImdb::FImdb() {
    algo_lib::FImdb_Init(*this);
}

inline algo_lib::FImdb::~FImdb() {
    algo_lib::FImdb_Uninit(*this);
}


// --- algo_lib.FImdb..Init
// Set all fields to initial values.
inline void algo_lib::FImdb_Init(algo_lib::FImdb& imdb) {
    memset(&imdb.InsertStrptrMaybe, 0, sizeof(imdb.InsertStrptrMaybe));
    memset(&imdb.Step, 0, sizeof(imdb.Step));
    memset(&imdb.MainLoop, 0, sizeof(imdb.MainLoop));
    memset(&imdb.GetTrace, 0, sizeof(imdb.GetTrace));
    imdb.ind_imdb_next = (algo_lib::FImdb*)-1; // (algo_lib.FDb.ind_imdb) not-in-hash
}
inline algo_lib::FLogcat::FLogcat() {
    algo_lib::FLogcat_Init(*this);
}

inline algo_lib::FLogcat::~FLogcat() {
    algo_lib::FLogcat_Uninit(*this);
}


// --- algo_lib.FLogcat..Init
// Set all fields to initial values.
inline void algo_lib::FLogcat_Init(algo_lib::FLogcat& logcat) {
    logcat.enabled = bool(false);
    logcat.builtin = bool(false);
    logcat.ind_logcat_next = (algo_lib::FLogcat*)-1; // (algo_lib.FDb.ind_logcat) not-in-hash
}
inline algo_lib::trace::trace() {
    algo_lib::trace_Init(*this);
}


// --- algo_lib.FDb.temp_strings.Fill
// Set all elements of fixed array to value RHS
inline void algo_lib::temp_strings_Fill(const algo::cstring &rhs) {
    for (int i = 0; i < 8; i++) {
        _db.temp_strings_elems[i] = rhs;
    }
}

// --- algo_lib.FDb.temp_strings.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* algo_lib::temp_strings_Find(u64 t) {
    u64 idx = t;
    u64 lim = 8;
    return idx < lim ? _db.temp_strings_elems + idx : NULL; // unsigned comparison with limit
}

// --- algo_lib.FDb.temp_strings.Getary
// Access fixed array temp_strings as aryptr.
inline algo::aryptr<algo::cstring> algo_lib::temp_strings_Getary() {
    return algo::aryptr<algo::cstring>(_db.temp_strings_elems, 8);
}

// --- algo_lib.FDb.temp_strings.Max
// Return max number of items in the array
inline i32 algo_lib::temp_strings_Max() {
    return 8;
}

// --- algo_lib.FDb.temp_strings.N
// Return number of items in the array
inline i32 algo_lib::temp_strings_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return 8;
}

// --- algo_lib.FDb.temp_strings.Setary
// Set contents of fixed array to RHS; Input length is trimmed as necessary
inline void algo_lib::temp_strings_Setary(const algo::aryptr<algo::cstring> &rhs) {
    int n = 8 < rhs.n_elems ? 8 : rhs.n_elems;
    for (int i = 0; i < n; i++) {
        _db.temp_strings_elems[i] = rhs[i];
    }
}

// --- algo_lib.FDb.temp_strings.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline algo::cstring& algo_lib::temp_strings_qFind(u64 t) {
    return _db.temp_strings_elems[t];
}

// --- algo_lib.FDb.ArgvIdent.Match
inline bool algo_lib::ArgvIdentQ(u32 ch) {
    return ch_GetBit(_db.ArgvIdent, ch);
}

// --- algo_lib.FDb.BashQuotesafe.Match
inline bool algo_lib::BashQuotesafeQ(u32 ch) {
    return ch_GetBit(_db.BashQuotesafe, ch);
}

// --- algo_lib.FDb.RegxSqlSpecial.Match
inline bool algo_lib::RegxSqlSpecialQ(u32 ch) {
    return ch_GetBit(_db.RegxSqlSpecial, ch);
}

// --- algo_lib.FDb.SsimBreakName.Match
inline bool algo_lib::SsimBreakNameQ(u32 ch) {
    return ch_GetBit(_db.SsimBreakName, ch);
}

// --- algo_lib.FDb.SsimBreakValue.Match
inline bool algo_lib::SsimBreakValueQ(u32 ch) {
    return ch_GetBit(_db.SsimBreakValue, ch);
}

// --- algo_lib.FDb.SsimQuotesafe.Match
inline bool algo_lib::SsimQuotesafeQ(u32 ch) {
    return ch_GetBit(_db.SsimQuotesafe, ch);
}

// --- algo_lib.FDb.imtable.EmptyQ
// Return true if index is empty
inline bool algo_lib::imtable_EmptyQ() {
    return _db.imtable_n == 0;
}

// --- algo_lib.FDb.imtable.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::FImtable* algo_lib::imtable_Find(u64 t) {
    algo_lib::FImtable *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.imtable_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.imtable_lary[bsr][index];
    }
    return retval;
}

// --- algo_lib.FDb.imtable.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo_lib::FImtable* algo_lib::imtable_Last() {
    return imtable_Find(u64(_db.imtable_n-1));
}

// --- algo_lib.FDb.imtable.N
// Return number of items in the pool
inline i32 algo_lib::imtable_N() {
    return _db.imtable_n;
}

// --- algo_lib.FDb.imtable.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo_lib::FImtable& algo_lib::imtable_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.imtable_lary[bsr][index];
}

// --- algo_lib.FDb.ind_imtable.EmptyQ
// Return true if hash is empty
inline bool algo_lib::ind_imtable_EmptyQ() {
    return _db.ind_imtable_n == 0;
}

// --- algo_lib.FDb.ind_imtable.N
// Return number of items in the hash
inline i32 algo_lib::ind_imtable_N() {
    return _db.ind_imtable_n;
}

// --- algo_lib.FDb.bh_timehook.EmptyQ
// Return true if index is empty
inline bool algo_lib::bh_timehook_EmptyQ() {
    return _db.bh_timehook_n == 0;
}

// --- algo_lib.FDb.bh_timehook.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline algo_lib::FTimehook* algo_lib::bh_timehook_First() {
    algo_lib::FTimehook *row = NULL;
    if (_db.bh_timehook_n > 0) {
        row = _db.bh_timehook_elems[0];
    }
    return row;
}

// --- algo_lib.FDb.bh_timehook.InBheapQ
// Return true if row is in index, false otherwise
inline bool algo_lib::bh_timehook_InBheapQ(algo_lib::FTimehook& row) {
    bool result = false;
    result = row.bh_timehook_idx != -1;
    return result;
}

// --- algo_lib.FDb.bh_timehook.N
// Return number of items in the heap
inline i32 algo_lib::bh_timehook_N() {
    return _db.bh_timehook_n;
}

// --- algo_lib.FDb.bh_timehook.Call
inline void algo_lib::bh_timehook_Call() {
    if (!algo_lib::bh_timehook_EmptyQ()) { // fstep:algo_lib.FDb.bh_timehook
        algo_lib::bh_timehook_Step(); // steptype:Callback: user calls call _UpdateCycles
    }
}

// --- algo_lib.FDb.dispsigcheck.EmptyQ
// Return true if index is empty
inline bool algo_lib::dispsigcheck_EmptyQ() {
    return _db.dispsigcheck_n == 0;
}

// --- algo_lib.FDb.dispsigcheck.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::FDispsigcheck* algo_lib::dispsigcheck_Find(u64 t) {
    algo_lib::FDispsigcheck *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.dispsigcheck_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.dispsigcheck_lary[bsr][index];
    }
    return retval;
}

// --- algo_lib.FDb.dispsigcheck.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo_lib::FDispsigcheck* algo_lib::dispsigcheck_Last() {
    return dispsigcheck_Find(u64(_db.dispsigcheck_n-1));
}

// --- algo_lib.FDb.dispsigcheck.N
// Return number of items in the pool
inline i32 algo_lib::dispsigcheck_N() {
    return _db.dispsigcheck_n;
}

// --- algo_lib.FDb.dispsigcheck.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo_lib::FDispsigcheck& algo_lib::dispsigcheck_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.dispsigcheck_lary[bsr][index];
}

// --- algo_lib.FDb.ind_dispsigcheck.EmptyQ
// Return true if hash is empty
inline bool algo_lib::ind_dispsigcheck_EmptyQ() {
    return _db.ind_dispsigcheck_n == 0;
}

// --- algo_lib.FDb.ind_dispsigcheck.N
// Return number of items in the hash
inline i32 algo_lib::ind_dispsigcheck_N() {
    return _db.ind_dispsigcheck_n;
}

// --- algo_lib.FDb.imdb.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* algo_lib::imdb_AllocMem() {
    void *row = reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data) + _db.imdb_n;
    if (_db.imdb_n == 32) row = NULL;
    if (row) _db.imdb_n++;
    return row;
}

// --- algo_lib.FDb.imdb.EmptyQ
// Return true if index is empty
inline bool algo_lib::imdb_EmptyQ() {
    return _db.imdb_n == 0;
}

// --- algo_lib.FDb.imdb.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::FImdb* algo_lib::imdb_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.imdb_n;
    return idx < lim ? reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data) + idx : NULL; // unsigned comparison with limit
}

// --- algo_lib.FDb.imdb.Getary
// Return array pointer by value
inline algo::aryptr<algo_lib::FImdb> algo_lib::imdb_Getary() {
    return algo::aryptr<algo_lib::FImdb>(reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data), _db.imdb_n);
}

// --- algo_lib.FDb.imdb.Max
// Return constant 32 -- max. number of items in the pool
inline i32 algo_lib::imdb_Max() {
    return 32;
}

// --- algo_lib.FDb.imdb.N
// Return number of items in the array
inline i32 algo_lib::imdb_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return _db.imdb_n;
}

// --- algo_lib.FDb.imdb.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline algo_lib::FImdb& algo_lib::imdb_qFind(u64 t) {
    u64 idx = t;
    return reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data)[idx];
}

// --- algo_lib.FDb.imdb.rowid_Get
// Compute row id of element given element's address
inline u64 algo_lib::imdb_rowid_Get(algo_lib::FImdb &row) {
    u64 ret = u64(&row - reinterpret_cast<algo_lib::FImdb*>(_db.imdb_data));
    return u64(ret);
}

// --- algo_lib.FDb.ind_imdb.EmptyQ
// Return true if hash is empty
inline bool algo_lib::ind_imdb_EmptyQ() {
    return _db.ind_imdb_n == 0;
}

// --- algo_lib.FDb.ind_imdb.N
// Return number of items in the hash
inline i32 algo_lib::ind_imdb_N() {
    return _db.ind_imdb_n;
}

// --- algo_lib.FDb.h_fatalerror.Call
// Invoke function by pointer
inline void algo_lib::h_fatalerror_Call() {
    if (_db.h_fatalerror) {
        _db.h_fatalerror((void*)_db.h_fatalerror_ctx);
    }
}

// --- algo_lib.FDb.h_fatalerror.Set0
// Assign 0-argument hook with no context pointer
inline void algo_lib::h_fatalerror_Set0(void (*fcn)() ) {
    _db.h_fatalerror_ctx = 0;
    _db.h_fatalerror = (algo_lib::_db_h_fatalerror_hook)fcn;
}

// --- algo_lib.FDb.h_fatalerror.Set1
// Assign 1-argument hook with context pointer
template<class T> inline void algo_lib::h_fatalerror_Set1(T& ctx, void (*fcn)(T&) ) {
    _db.h_fatalerror_ctx = (u64)&ctx;
    _db.h_fatalerror = (algo_lib::_db_h_fatalerror_hook)fcn;
}

// --- algo_lib.FDb.h_fatalerror.Set2
// Assign 2-argument hook with context pointer
template<class T> inline void algo_lib::h_fatalerror_Set2(T& ctx, void (*fcn)(T&) ) {
    _db.h_fatalerror_ctx = (u64)&ctx;
    _db.h_fatalerror = (algo_lib::_db_h_fatalerror_hook)fcn;
}

// --- algo_lib.FDb.giveup_time.Call
inline void algo_lib::giveup_time_Call() {
    algo_lib::giveup_time_Step();
}

// --- algo_lib.FDb.DigitChar.Match
inline bool algo_lib::DigitCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('0')) < u32(10);
    return ret;
}

// --- algo_lib.FDb.NewLineChar.Match
inline bool algo_lib::NewLineCharQ(u32 ch) {
    bool ret = false;
    ret |= ch == '\n';
    ret |= ch == '\r';
    return ret;
}

// --- algo_lib.FDb.WhiteChar.Match
inline bool algo_lib::WhiteCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('\t')) < u32(2);
    ret |= ch == '\r';
    ret |= ch == ' ';
    return ret;
}

// --- algo_lib.FDb.DirSep.Match
inline bool algo_lib::DirSepQ(u32 ch) {
    bool ret = false;
    ret |= ch == '/';
    ret |= ch == '\\';
    return ret;
}

// --- algo_lib.FDb.IdentChar.Match
inline bool algo_lib::IdentCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('0')) < u32(10);
    ret |= (ch - u32('A')) < u32(26);
    ret |= ch == '_';
    ret |= (ch - u32('a')) < u32(26);
    return ret;
}

// --- algo_lib.FDb.IdentStart.Match
inline bool algo_lib::IdentStartQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('A')) < u32(26);
    ret |= ch == '_';
    ret |= (ch - u32('a')) < u32(26);
    return ret;
}

// --- algo_lib.FDb.AlphaChar.Match
inline bool algo_lib::AlphaCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('A')) < u32(26);
    ret |= (ch - u32('a')) < u32(26);
    return ret;
}

// --- algo_lib.FDb.HexChar.Match
inline bool algo_lib::HexCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('0')) < u32(10);
    ret |= (ch - u32('A')) < u32(6);
    ret |= (ch - u32('a')) < u32(6);
    return ret;
}

// --- algo_lib.FDb.UpperChar.Match
inline bool algo_lib::UpperCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('A')) < u32(26);
    return ret;
}

// --- algo_lib.FDb.CmdLineNameBreak.Match
inline bool algo_lib::CmdLineNameBreakQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('\t')) < u32(2);
    ret |= ch == '\r';
    ret |= ch == ' ';
    ret |= (ch - u32('(')) < u32(2);
    ret |= ch == ':';
    ret |= ch == '[';
    ret |= ch == ']';
    ret |= ch == '{';
    ret |= ch == '}';
    return ret;
}

// --- algo_lib.FDb.CmdLineValueBreak.Match
inline bool algo_lib::CmdLineValueBreakQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('\t')) < u32(2);
    ret |= ch == '\r';
    ret |= ch == ' ';
    ret |= (ch - u32('(')) < u32(2);
    ret |= ch == '[';
    ret |= ch == ']';
    ret |= ch == '{';
    ret |= ch == '}';
    return ret;
}

// --- algo_lib.FDb.WordSeparator.Match
inline bool algo_lib::WordSeparatorQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('\t')) < u32(2);
    ret |= ch == '\r';
    ret |= (ch - u32(' ')) < u32(16);
    ret |= ch == ';';
    ret |= ch == '=';
    ret |= (ch - u32('?')) < u32(2);
    ret |= ch == '[';
    ret |= (ch - u32(']')) < u32(2);
    ret |= ch == '`';
    ret |= (ch - u32('{')) < u32(4);
    return ret;
}

// --- algo_lib.FDb.LowerChar.Match
inline bool algo_lib::LowerCharQ(u32 ch) {
    bool ret = false;
    ret |= (ch - u32('a')) < u32(26);
    return ret;
}

// --- algo_lib.FDb.Urlsafe.Match
inline bool algo_lib::UrlsafeQ(u32 ch) {
    return ch_GetBit(_db.Urlsafe, ch);
}

// --- algo_lib.FDb.logcat.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* algo_lib::logcat_AllocMem() {
    void *row = reinterpret_cast<algo_lib::FLogcat*>(_db.logcat_data) + _db.logcat_n;
    if (_db.logcat_n == 3) row = NULL;
    if (row) _db.logcat_n++;
    return row;
}

// --- algo_lib.FDb.logcat.EmptyQ
// Return true if index is empty
inline bool algo_lib::logcat_EmptyQ() {
    return _db.logcat_n == 0;
}

// --- algo_lib.FDb.logcat.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::FLogcat* algo_lib::logcat_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.logcat_n;
    return idx < lim ? reinterpret_cast<algo_lib::FLogcat*>(_db.logcat_data) + idx : NULL; // unsigned comparison with limit
}

// --- algo_lib.FDb.logcat.Getary
// Return array pointer by value
inline algo::aryptr<algo_lib::FLogcat> algo_lib::logcat_Getary() {
    return algo::aryptr<algo_lib::FLogcat>(reinterpret_cast<algo_lib::FLogcat*>(_db.logcat_data), _db.logcat_n);
}

// --- algo_lib.FDb.logcat.Max
// Return constant 3 -- max. number of items in the pool
inline i32 algo_lib::logcat_Max() {
    return 3;
}

// --- algo_lib.FDb.logcat.N
// Return number of items in the array
inline i32 algo_lib::logcat_N() {
    (void)_db;//only to avoid -Wunused-parameter
    return _db.logcat_n;
}

// --- algo_lib.FDb.logcat.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline algo_lib::FLogcat& algo_lib::logcat_qFind(u64 t) {
    u64 idx = t;
    return reinterpret_cast<algo_lib::FLogcat*>(_db.logcat_data)[idx];
}

// --- algo_lib.FDb.logcat.rowid_Get
// Compute row id of element given element's address
inline u64 algo_lib::logcat_rowid_Get(algo_lib::FLogcat &row) {
    u64 ret = u64(&row - reinterpret_cast<algo_lib::FLogcat*>(_db.logcat_data));
    return u64(ret);
}

// --- algo_lib.FDb.ind_logcat.EmptyQ
// Return true if hash is empty
inline bool algo_lib::ind_logcat_EmptyQ() {
    return _db.ind_logcat_n == 0;
}

// --- algo_lib.FDb.ind_logcat.N
// Return number of items in the hash
inline i32 algo_lib::ind_logcat_N() {
    return _db.ind_logcat_n;
}

// --- algo_lib.FDb.exec_args.EmptyQ
// Return true if index is empty
inline bool algo_lib::exec_args_EmptyQ() {
    return _db.exec_args_n == 0;
}

// --- algo_lib.FDb.exec_args.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* algo_lib::exec_args_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.exec_args_n;
    if (idx >= lim) return NULL;
    return _db.exec_args_elems + idx;
}

// --- algo_lib.FDb.exec_args.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> algo_lib::exec_args_Getary() {
    return algo::aryptr<algo::cstring>(_db.exec_args_elems, _db.exec_args_n);
}

// --- algo_lib.FDb.exec_args.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* algo_lib::exec_args_Last() {
    return exec_args_Find(u64(_db.exec_args_n-1));
}

// --- algo_lib.FDb.exec_args.Max
// Return max. number of items in the array
inline i32 algo_lib::exec_args_Max() {
    return _db.exec_args_max;
}

// --- algo_lib.FDb.exec_args.N
// Return number of items in the array
inline i32 algo_lib::exec_args_N() {
    return _db.exec_args_n;
}

// --- algo_lib.FDb.exec_args.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::exec_args_Reserve(int n) {
    u32 new_n = _db.exec_args_n + n;
    if (UNLIKELY(new_n > _db.exec_args_max)) {
        exec_args_AbsReserve(new_n);
    }
}

// --- algo_lib.FDb.exec_args.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& algo_lib::exec_args_qFind(u64 t) {
    return _db.exec_args_elems[t];
}

// --- algo_lib.FDb.exec_args.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& algo_lib::exec_args_qLast() {
    return exec_args_qFind(u64(_db.exec_args_n-1));
}

// --- algo_lib.FDb.exec_args.rowid_Get
// Return row id of specified element
inline u64 algo_lib::exec_args_rowid_Get(algo::cstring &elem) {
    u64 id = &elem - _db.exec_args_elems;
    return u64(id);
}

// --- algo_lib.FDb.dirstack.EmptyQ
// Return true if index is empty
inline bool algo_lib::dirstack_EmptyQ() {
    return _db.dirstack_n == 0;
}

// --- algo_lib.FDb.dirstack.Find
// Look up row by row id. Return NULL if out of range
inline algo::cstring* algo_lib::dirstack_Find(u64 t) {
    u64 idx = t;
    u64 lim = _db.dirstack_n;
    if (idx >= lim) return NULL;
    return _db.dirstack_elems + idx;
}

// --- algo_lib.FDb.dirstack.Getary
// Return array pointer by value
inline algo::aryptr<algo::cstring> algo_lib::dirstack_Getary() {
    return algo::aryptr<algo::cstring>(_db.dirstack_elems, _db.dirstack_n);
}

// --- algo_lib.FDb.dirstack.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::cstring* algo_lib::dirstack_Last() {
    return dirstack_Find(u64(_db.dirstack_n-1));
}

// --- algo_lib.FDb.dirstack.Max
// Return max. number of items in the array
inline i32 algo_lib::dirstack_Max() {
    return _db.dirstack_max;
}

// --- algo_lib.FDb.dirstack.N
// Return number of items in the array
inline i32 algo_lib::dirstack_N() {
    return _db.dirstack_n;
}

// --- algo_lib.FDb.dirstack.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::dirstack_Reserve(int n) {
    u32 new_n = _db.dirstack_n + n;
    if (UNLIKELY(new_n > _db.dirstack_max)) {
        dirstack_AbsReserve(new_n);
    }
}

// --- algo_lib.FDb.dirstack.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::cstring& algo_lib::dirstack_qFind(u64 t) {
    return _db.dirstack_elems[t];
}

// --- algo_lib.FDb.dirstack.qLast
// Return reference to last element of array. No bounds checking
inline algo::cstring& algo_lib::dirstack_qLast() {
    return dirstack_qFind(u64(_db.dirstack_n-1));
}

// --- algo_lib.FDb.dirstack.rowid_Get
// Return row id of specified element
inline u64 algo_lib::dirstack_rowid_Get(algo::cstring &elem) {
    u64 id = &elem - _db.dirstack_elems;
    return u64(id);
}

// --- algo_lib.FDb.temp_strings_curs.Reset
// cursor points to valid item
inline void algo_lib::_db_temp_strings_curs_Reset(_db_temp_strings_curs &curs, algo_lib::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo_lib.FDb.temp_strings_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_temp_strings_curs_ValidQ(_db_temp_strings_curs &curs) {
    return u64(curs.index) < u64(8);
}

// --- algo_lib.FDb.temp_strings_curs.Next
// proceed to next item
inline void algo_lib::_db_temp_strings_curs_Next(_db_temp_strings_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.temp_strings_curs.Access
// item access
inline algo::cstring& algo_lib::_db_temp_strings_curs_Access(_db_temp_strings_curs &curs) {
    return temp_strings_qFind(u64(curs.index));
}

// --- algo_lib.FDb.imtable_curs.Reset
// cursor points to valid item
inline void algo_lib::_db_imtable_curs_Reset(_db_imtable_curs &curs, algo_lib::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo_lib.FDb.imtable_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_imtable_curs_ValidQ(_db_imtable_curs &curs) {
    return curs.index < _db.imtable_n;
}

// --- algo_lib.FDb.imtable_curs.Next
// proceed to next item
inline void algo_lib::_db_imtable_curs_Next(_db_imtable_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.imtable_curs.Access
// item access
inline algo_lib::FImtable& algo_lib::_db_imtable_curs_Access(_db_imtable_curs &curs) {
    return imtable_qFind(u64(curs.index));
}

// --- algo_lib.FDb.bh_timehook_curs.Access
// Access current element. If not more elements, return NULL
inline algo_lib::FTimehook& algo_lib::_db_bh_timehook_curs_Access(_db_bh_timehook_curs &curs) {
    return *curs.temp_elems[0];
}

// --- algo_lib.FDb.bh_timehook_curs.ValidQ
// Return true if Access() will return non-NULL.
inline bool algo_lib::_db_bh_timehook_curs_ValidQ(_db_bh_timehook_curs &curs) {
    return curs.temp_n > 0;
}

// --- algo_lib.FDb.dispsigcheck_curs.Reset
// cursor points to valid item
inline void algo_lib::_db_dispsigcheck_curs_Reset(_db_dispsigcheck_curs &curs, algo_lib::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo_lib.FDb.dispsigcheck_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_dispsigcheck_curs_ValidQ(_db_dispsigcheck_curs &curs) {
    return curs.index < _db.dispsigcheck_n;
}

// --- algo_lib.FDb.dispsigcheck_curs.Next
// proceed to next item
inline void algo_lib::_db_dispsigcheck_curs_Next(_db_dispsigcheck_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.dispsigcheck_curs.Access
// item access
inline algo_lib::FDispsigcheck& algo_lib::_db_dispsigcheck_curs_Access(_db_dispsigcheck_curs &curs) {
    return dispsigcheck_qFind(u64(curs.index));
}

// --- algo_lib.FDb.imdb_curs.Reset
// cursor points to valid item
inline void algo_lib::_db_imdb_curs_Reset(_db_imdb_curs &curs, algo_lib::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo_lib.FDb.imdb_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_imdb_curs_ValidQ(_db_imdb_curs &curs) {
    return u64(curs.index) < u64(curs.parent->imdb_n);
}

// --- algo_lib.FDb.imdb_curs.Next
// proceed to next item
inline void algo_lib::_db_imdb_curs_Next(_db_imdb_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.imdb_curs.Access
// item access
inline algo_lib::FImdb& algo_lib::_db_imdb_curs_Access(_db_imdb_curs &curs) {
    return imdb_qFind(u64(curs.index));
}

// --- algo_lib.FDb.logcat_curs.Reset
// cursor points to valid item
inline void algo_lib::_db_logcat_curs_Reset(_db_logcat_curs &curs, algo_lib::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo_lib.FDb.logcat_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_logcat_curs_ValidQ(_db_logcat_curs &curs) {
    return u64(curs.index) < u64(curs.parent->logcat_n);
}

// --- algo_lib.FDb.logcat_curs.Next
// proceed to next item
inline void algo_lib::_db_logcat_curs_Next(_db_logcat_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.logcat_curs.Access
// item access
inline algo_lib::FLogcat& algo_lib::_db_logcat_curs_Access(_db_logcat_curs &curs) {
    return logcat_qFind(u64(curs.index));
}

// --- algo_lib.FDb.exec_args_curs.Next
// proceed to next item
inline void algo_lib::_db_exec_args_curs_Next(_db_exec_args_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.exec_args_curs.Reset
inline void algo_lib::_db_exec_args_curs_Reset(_db_exec_args_curs &curs, algo_lib::FDb &parent) {
    curs.elems = parent.exec_args_elems;
    curs.n_elems = parent.exec_args_n;
    curs.index = 0;
}

// --- algo_lib.FDb.exec_args_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_exec_args_curs_ValidQ(_db_exec_args_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.FDb.exec_args_curs.Access
// item access
inline algo::cstring& algo_lib::_db_exec_args_curs_Access(_db_exec_args_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.FDb.dirstack_curs.Next
// proceed to next item
inline void algo_lib::_db_dirstack_curs_Next(_db_dirstack_curs &curs) {
    curs.index++;
}

// --- algo_lib.FDb.dirstack_curs.Reset
inline void algo_lib::_db_dirstack_curs_Reset(_db_dirstack_curs &curs, algo_lib::FDb &parent) {
    curs.elems = parent.dirstack_elems;
    curs.n_elems = parent.dirstack_n;
    curs.index = 0;
}

// --- algo_lib.FDb.dirstack_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::_db_dirstack_curs_ValidQ(_db_dirstack_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.FDb.dirstack_curs.Access
// item access
inline algo::cstring& algo_lib::_db_dirstack_curs_Access(_db_dirstack_curs &curs) {
    return curs.elems[curs.index];
}
inline algo_lib::FDispsigcheck::FDispsigcheck() {
    algo_lib::FDispsigcheck_Init(*this);
}

inline algo_lib::FDispsigcheck::~FDispsigcheck() {
    algo_lib::FDispsigcheck_Uninit(*this);
}


// --- algo_lib.FDispsigcheck..Init
// Set all fields to initial values.
inline void algo_lib::FDispsigcheck_Init(algo_lib::FDispsigcheck& dispsigcheck) {
    dispsigcheck.ind_dispsigcheck_next = (algo_lib::FDispsigcheck*)-1; // (algo_lib.FDb.ind_dispsigcheck) not-in-hash
}
inline algo_lib::FImtable::FImtable() {
    algo_lib::FImtable_Init(*this);
}

inline algo_lib::FImtable::~FImtable() {
    algo_lib::FImtable_Uninit(*this);
}


// --- algo_lib.FImtable..Init
// Set all fields to initial values.
inline void algo_lib::FImtable_Init(algo_lib::FImtable& imtable) {
    memset(&imtable.c_RowidFind, 0, sizeof(imtable.c_RowidFind));
    memset(&imtable.XrefX, 0, sizeof(imtable.XrefX));
    memset(&imtable.NItems, 0, sizeof(imtable.NItems));
    memset(&imtable.Print, 0, sizeof(imtable.Print));
    imtable.size = i32(0);
    imtable.ind_imtable_next = (algo_lib::FImtable*)-1; // (algo_lib.FDb.ind_imtable) not-in-hash
}
inline algo_lib::FIohook::FIohook() {
    algo_lib::FIohook_Init(*this);
}

inline algo_lib::FIohook::~FIohook() {
    algo_lib::FIohook_Uninit(*this);
}


// --- algo_lib.FIohook.callback.Call
// Invoke function by pointer
inline void algo_lib::callback_Call(algo_lib::FIohook& iohook, algo_lib::FIohook& arg) {
    if (iohook.callback) {
        iohook.callback((void*)iohook.callback_ctx, arg);
    }
}

// --- algo_lib.FIohook.callback.Set0
// Assign 0-argument hook with no context pointer
inline void algo_lib::callback_Set0(algo_lib::FIohook& iohook, void (*fcn)() ) {
    iohook.callback_ctx = 0;
    iohook.callback = (algo_lib::iohook_callback_hook)fcn;
}

// --- algo_lib.FIohook.callback.Set1
// Assign 1-argument hook with context pointer
template<class T> inline void algo_lib::callback_Set1(algo_lib::FIohook& iohook, T& ctx, void (*fcn)(T&) ) {
    iohook.callback_ctx = (u64)&ctx;
    iohook.callback = (algo_lib::iohook_callback_hook)fcn;
}

// --- algo_lib.FIohook.callback.Set2
// Assign 2-argument hook with context pointer
template<class T> inline void algo_lib::callback_Set2(algo_lib::FIohook& iohook, T& ctx, void (*fcn)(T&, algo_lib::FIohook& arg) ) {
    iohook.callback_ctx = (u64)&ctx;
    iohook.callback = (algo_lib::iohook_callback_hook)fcn;
}

// --- algo_lib.FIohook..Init
// Set all fields to initial values.
inline void algo_lib::FIohook_Init(algo_lib::FIohook& iohook) {
    iohook.in_epoll = bool(false);
    iohook.nodelete = bool(false);
    iohook.callback = NULL;
    iohook.callback_ctx = 0;
}
inline algo_lib::FReplvar::FReplvar() {
    algo_lib::FReplvar_Init(*this);
}

inline algo_lib::FReplvar::~FReplvar() {
    algo_lib::FReplvar_Uninit(*this);
}


// --- algo_lib.FReplvar..Init
// Set all fields to initial values.
inline void algo_lib::FReplvar_Init(algo_lib::FReplvar& replvar) {
    replvar.p_replscope = NULL;
    replvar.nsubst = i32(0);
    replvar.replvar_next = (algo_lib::FReplvar*)-1; // (algo_lib.FDb.replvar) not-in-tpool's freelist
    replvar.ind_replvar_next = (algo_lib::FReplvar*)-1; // (algo_lib.Replscope.ind_replvar) not-in-hash
}
inline algo_lib::FTempfile::FTempfile() {
}

inline algo_lib::FTempfile::~FTempfile() {
    algo_lib::FTempfile_Uninit(*this);
}

inline algo_lib::FTxtcell::FTxtcell(algo_lib::FTxtrow*             in_p_txtrow
        ,algo::TextJust                 in_justify
        ,algo::TermStyle                in_style
        ,i32                            in_span
        ,i32                            in_width
        ,const algo::strptr&            in_text
        ,const algo::strptr&            in_rsep
        ,bool                           in_txtrow_c_txtcell_in_ary)
    : p_txtrow(in_p_txtrow)
    , justify(in_justify)
    , style(in_style)
    , span(in_span)
    , width(in_width)
    , text(in_text)
    , rsep(in_rsep)
    , txtrow_c_txtcell_in_ary(in_txtrow_c_txtcell_in_ary)
{
}
inline algo_lib::FTxtcell::FTxtcell() {
    algo_lib::FTxtcell_Init(*this);
}

inline algo_lib::FTxtcell::~FTxtcell() {
    algo_lib::FTxtcell_Uninit(*this);
}


// --- algo_lib.FTxtcell..Init
// Set all fields to initial values.
inline void algo_lib::FTxtcell_Init(algo_lib::FTxtcell& txtcell) {
    txtcell.p_txtrow = NULL;
    txtcell.justify = algo_TextJustEnum(algo_TextJust_j_left);
    txtcell.span = i32(1);
    txtcell.width = i32(0);
    txtcell.txtrow_c_txtcell_in_ary = bool(false);
    txtcell.txtcell_next = (algo_lib::FTxtcell*)-1; // (algo_lib.FDb.txtcell) not-in-tpool's freelist
}
inline algo_lib::FTxtrow::FTxtrow() {
    algo_lib::FTxtrow_Init(*this);
}

inline algo_lib::FTxtrow::~FTxtrow() {
    algo_lib::FTxtrow_Uninit(*this);
}


// --- algo_lib.FTxtrow.sortkey.Lt
// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
inline bool algo_lib::sortkey_Lt(algo_lib::FTxtrow& txtrow, algo_lib::FTxtrow &rhs) {
    return sortkey_Cmp(txtrow,rhs) < 0;
}

// --- algo_lib.FTxtrow.c_txtcell.EmptyQ
// Return true if index is empty
inline bool algo_lib::c_txtcell_EmptyQ(algo_lib::FTxtrow& txtrow) {
    return txtrow.c_txtcell_n == 0;
}

// --- algo_lib.FTxtrow.c_txtcell.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::FTxtcell* algo_lib::c_txtcell_Find(algo_lib::FTxtrow& txtrow, u32 t) {
    algo_lib::FTxtcell *retval = NULL;
    u64 idx = t;
    u64 lim = txtrow.c_txtcell_n;
    if (idx < lim) {
        retval = txtrow.c_txtcell_elems[idx];
    }
    return retval;
}

// --- algo_lib.FTxtrow.c_txtcell.Getary
// Return array of pointers
inline algo::aryptr<algo_lib::FTxtcell*> algo_lib::c_txtcell_Getary(algo_lib::FTxtrow& txtrow) {
    return algo::aryptr<algo_lib::FTxtcell*>(txtrow.c_txtcell_elems, txtrow.c_txtcell_n);
}

// --- algo_lib.FTxtrow.c_txtcell.N
// Return number of items in the pointer array
inline i32 algo_lib::c_txtcell_N(const algo_lib::FTxtrow& txtrow) {
    return txtrow.c_txtcell_n;
}

// --- algo_lib.FTxtrow.c_txtcell.RemoveAll
// Empty the index. (The rows are not deleted)
inline void algo_lib::c_txtcell_RemoveAll(algo_lib::FTxtrow& txtrow) {
    for (u32 i = 0; i < txtrow.c_txtcell_n; i++) {
        // mark all elements as not-in-array
        txtrow.c_txtcell_elems[i]->txtrow_c_txtcell_in_ary = false;
    }
    txtrow.c_txtcell_n = 0;
}

// --- algo_lib.FTxtrow.c_txtcell.qFind
// Return reference without bounds checking
inline algo_lib::FTxtcell& algo_lib::c_txtcell_qFind(algo_lib::FTxtrow& txtrow, u32 idx) {
    return *txtrow.c_txtcell_elems[idx];
}

// --- algo_lib.FTxtrow.c_txtcell.InAryQ
// True if row is in any ptrary instance
inline bool algo_lib::txtrow_c_txtcell_InAryQ(algo_lib::FTxtcell& row) {
    return row.txtrow_c_txtcell_in_ary;
}

// --- algo_lib.FTxtrow.c_txtcell.qLast
// Reference to last element without bounds checking
inline algo_lib::FTxtcell& algo_lib::c_txtcell_qLast(algo_lib::FTxtrow& txtrow) {
    return *txtrow.c_txtcell_elems[txtrow.c_txtcell_n-1];
}

// --- algo_lib.FTxtrow..Init
// Set all fields to initial values.
inline void algo_lib::FTxtrow_Init(algo_lib::FTxtrow& txtrow) {
    txtrow.p_txttbl = NULL;
    txtrow.select = bool(true);
    txtrow.ishdr = bool(false);
    txtrow.c_txtcell_elems = NULL; // (algo_lib.FTxtrow.c_txtcell)
    txtrow.c_txtcell_n = 0; // (algo_lib.FTxtrow.c_txtcell)
    txtrow.c_txtcell_max = 0; // (algo_lib.FTxtrow.c_txtcell)
    txtrow.txttbl_c_txtrow_in_ary = bool(false);
    txtrow.txtrow_next = (algo_lib::FTxtrow*)-1; // (algo_lib.FDb.txtrow) not-in-tpool's freelist
}

// --- algo_lib.FTxtrow.c_txtcell_curs.Reset
inline void algo_lib::txtrow_c_txtcell_curs_Reset(txtrow_c_txtcell_curs &curs, algo_lib::FTxtrow &parent) {
    curs.elems = parent.c_txtcell_elems;
    curs.n_elems = parent.c_txtcell_n;
    curs.index = 0;
}

// --- algo_lib.FTxtrow.c_txtcell_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::txtrow_c_txtcell_curs_ValidQ(txtrow_c_txtcell_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.FTxtrow.c_txtcell_curs.Next
// proceed to next item
inline void algo_lib::txtrow_c_txtcell_curs_Next(txtrow_c_txtcell_curs &curs) {
    curs.index++;
}

// --- algo_lib.FTxtrow.c_txtcell_curs.Access
// item access
inline algo_lib::FTxtcell& algo_lib::txtrow_c_txtcell_curs_Access(txtrow_c_txtcell_curs &curs) {
    return *curs.elems[curs.index];
}
inline algo_lib::FTxttbl::FTxttbl() {
    algo_lib::FTxttbl_Init(*this);
}

inline algo_lib::FTxttbl::~FTxttbl() {
    algo_lib::FTxttbl_Uninit(*this);
}


// --- algo_lib.FTxttbl.c_txtrow.EmptyQ
// Return true if index is empty
inline bool algo_lib::c_txtrow_EmptyQ(algo_lib::FTxttbl& txttbl) {
    return txttbl.c_txtrow_n == 0;
}

// --- algo_lib.FTxttbl.c_txtrow.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::FTxtrow* algo_lib::c_txtrow_Find(algo_lib::FTxttbl& txttbl, u32 t) {
    algo_lib::FTxtrow *retval = NULL;
    u64 idx = t;
    u64 lim = txttbl.c_txtrow_n;
    if (idx < lim) {
        retval = txttbl.c_txtrow_elems[idx];
    }
    return retval;
}

// --- algo_lib.FTxttbl.c_txtrow.Getary
// Return array of pointers
inline algo::aryptr<algo_lib::FTxtrow*> algo_lib::c_txtrow_Getary(algo_lib::FTxttbl& txttbl) {
    return algo::aryptr<algo_lib::FTxtrow*>(txttbl.c_txtrow_elems, txttbl.c_txtrow_n);
}

// --- algo_lib.FTxttbl.c_txtrow.N
// Return number of items in the pointer array
inline i32 algo_lib::c_txtrow_N(const algo_lib::FTxttbl& txttbl) {
    return txttbl.c_txtrow_n;
}

// --- algo_lib.FTxttbl.c_txtrow.RemoveAll
// Empty the index. (The rows are not deleted)
inline void algo_lib::c_txtrow_RemoveAll(algo_lib::FTxttbl& txttbl) {
    for (u32 i = 0; i < txttbl.c_txtrow_n; i++) {
        // mark all elements as not-in-array
        txttbl.c_txtrow_elems[i]->txttbl_c_txtrow_in_ary = false;
    }
    txttbl.c_txtrow_n = 0;
}

// --- algo_lib.FTxttbl.c_txtrow.qFind
// Return reference without bounds checking
inline algo_lib::FTxtrow& algo_lib::c_txtrow_qFind(algo_lib::FTxttbl& txttbl, u32 idx) {
    return *txttbl.c_txtrow_elems[idx];
}

// --- algo_lib.FTxttbl.c_txtrow.InAryQ
// True if row is in any ptrary instance
inline bool algo_lib::txttbl_c_txtrow_InAryQ(algo_lib::FTxtrow& row) {
    return row.txttbl_c_txtrow_in_ary;
}

// --- algo_lib.FTxttbl.c_txtrow.qLast
// Reference to last element without bounds checking
inline algo_lib::FTxtrow& algo_lib::c_txtrow_qLast(algo_lib::FTxttbl& txttbl) {
    return *txttbl.c_txtrow_elems[txttbl.c_txtrow_n-1];
}

// --- algo_lib.FTxttbl.c_txtrow_curs.Reset
inline void algo_lib::txttbl_c_txtrow_curs_Reset(txttbl_c_txtrow_curs &curs, algo_lib::FTxttbl &parent) {
    curs.elems = parent.c_txtrow_elems;
    curs.n_elems = parent.c_txtrow_n;
    curs.index = 0;
}

// --- algo_lib.FTxttbl.c_txtrow_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::txttbl_c_txtrow_curs_ValidQ(txttbl_c_txtrow_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.FTxttbl.c_txtrow_curs.Next
// proceed to next item
inline void algo_lib::txttbl_c_txtrow_curs_Next(txttbl_c_txtrow_curs &curs) {
    curs.index++;
}

// --- algo_lib.FTxttbl.c_txtrow_curs.Access
// item access
inline algo_lib::FTxtrow& algo_lib::txttbl_c_txtrow_curs_Access(txttbl_c_txtrow_curs &curs) {
    return *curs.elems[curs.index];
}

// --- algo_lib.FTxttbl..Init
// Set all fields to initial values.
inline void algo_lib::FTxttbl_Init(algo_lib::FTxttbl& txttbl) {
    txttbl.c_txtrow_elems = NULL; // (algo_lib.FTxttbl.c_txtrow)
    txttbl.c_txtrow_n = 0; // (algo_lib.FTxttbl.c_txtrow)
    txttbl.c_txtrow_max = 0; // (algo_lib.FTxttbl.c_txtrow)
    txttbl.col_space = i32(2);
    txttbl.hdr_row = i32(0);
    txttbl.normalized = bool(false);
}
inline algo_lib::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline algo_lib::FieldId::FieldId(algo_lib_FieldIdEnum arg) { this->value = i32(arg); }
inline algo_lib::FieldId::FieldId() {
    algo_lib::FieldId_Init(*this);
}


// --- algo_lib.FieldId.value.GetEnum
// Get value of field as enum type
inline algo_lib_FieldIdEnum algo_lib::value_GetEnum(const algo_lib::FieldId& parent) {
    return algo_lib_FieldIdEnum(parent.value);
}

// --- algo_lib.FieldId.value.SetEnum
// Set value of field from enum type.
inline void algo_lib::value_SetEnum(algo_lib::FieldId& parent, algo_lib_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- algo_lib.FieldId.value.Cast
inline algo_lib::FieldId::operator algo_lib_FieldIdEnum () const {
    return algo_lib_FieldIdEnum((*this).value);
}

// --- algo_lib.FieldId..Init
// Set all fields to initial values.
inline void algo_lib::FieldId_Init(algo_lib::FieldId& parent) {
    parent.value = i32(-1);
}
inline algo_lib::InTextFile::InTextFile() {
    algo_lib::InTextFile_Init(*this);
    // added because algo_lib.InTextFile.temp_buf (Inlary) does not need initialization
    // coverity[uninit_member]
}

inline algo_lib::InTextFile::~InTextFile() {
    algo_lib::InTextFile_Uninit(*this);
}


// --- algo_lib.InTextFile.temp_buf.AllocMem
// Allocate space for one element. If no memory available, return NULL.
inline void* algo_lib::temp_buf_AllocMem(algo_lib::InTextFile& parent) {
    void *row = reinterpret_cast<u8*>(parent.temp_buf_data) + parent.temp_buf_n;
    if (parent.temp_buf_n == 8192) row = NULL;
    if (row) parent.temp_buf_n++;
    return row;
}

// --- algo_lib.InTextFile.temp_buf.EmptyQ
// Return true if index is empty
inline bool algo_lib::temp_buf_EmptyQ(algo_lib::InTextFile& parent) {
    return parent.temp_buf_n == 0;
}

// --- algo_lib.InTextFile.temp_buf.Find
// Look up row by row id. Return NULL if out of range
inline u8* algo_lib::temp_buf_Find(algo_lib::InTextFile& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.temp_buf_n;
    return idx < lim ? reinterpret_cast<u8*>(parent.temp_buf_data) + idx : NULL; // unsigned comparison with limit
}

// --- algo_lib.InTextFile.temp_buf.Getary
// Return array pointer by value
inline algo::aryptr<u8> algo_lib::temp_buf_Getary(algo_lib::InTextFile& parent) {
    return algo::aryptr<u8>(reinterpret_cast<u8*>(parent.temp_buf_data), parent.temp_buf_n);
}

// --- algo_lib.InTextFile.temp_buf.Max
// Return constant 8192 -- max. number of items in the pool
inline i32 algo_lib::temp_buf_Max(algo_lib::InTextFile& parent) {
    (void)parent;
    return 8192;
}

// --- algo_lib.InTextFile.temp_buf.N
// Return number of items in the array
inline i32 algo_lib::temp_buf_N(const algo_lib::InTextFile& parent) {
    (void)parent;//only to avoid -Wunused-parameter
    return parent.temp_buf_n;
}

// --- algo_lib.InTextFile.temp_buf.qFind
// 'quick' Access row by row id. No bounds checking in release.
inline u8& algo_lib::temp_buf_qFind(algo_lib::InTextFile& parent, u64 t) {
    u64 idx = t;
    return reinterpret_cast<u8*>(parent.temp_buf_data)[idx];
}

// --- algo_lib.InTextFile.temp_buf.rowid_Get
// Compute row id of element given element's address
inline u64 algo_lib::temp_buf_rowid_Get(algo_lib::InTextFile& parent, u8 &row) {
    u64 ret = u64(&row - reinterpret_cast<u8*>(parent.temp_buf_data));
    return u64(ret);
}

// --- algo_lib.InTextFile.temp_buf_curs.Reset
// cursor points to valid item
inline void algo_lib::InTextFile_temp_buf_curs_Reset(InTextFile_temp_buf_curs &curs, algo_lib::InTextFile &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- algo_lib.InTextFile.temp_buf_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::InTextFile_temp_buf_curs_ValidQ(InTextFile_temp_buf_curs &curs) {
    return u64(curs.index) < u64(curs.parent->temp_buf_n);
}

// --- algo_lib.InTextFile.temp_buf_curs.Next
// proceed to next item
inline void algo_lib::InTextFile_temp_buf_curs_Next(InTextFile_temp_buf_curs &curs) {
    curs.index++;
}

// --- algo_lib.InTextFile.temp_buf_curs.Access
// item access
inline u8& algo_lib::InTextFile_temp_buf_curs_Access(InTextFile_temp_buf_curs &curs) {
    return temp_buf_qFind((*curs.parent), u64(curs.index));
}
inline algo_lib::Mmap::Mmap() {
}

inline algo_lib::Mmap::~Mmap() {
    algo_lib::Mmap_Uninit(*this);
}

inline algo_lib::MmapFile::MmapFile() {
}

inline algo_lib::Regx::Regx() {
    algo_lib::Regx_Init(*this);
}

inline algo_lib::Regx::~Regx() {
    algo_lib::Regx_Uninit(*this);
}


// --- algo_lib.Regx.state.EmptyQ
// Return true if index is empty
inline bool algo_lib::state_EmptyQ(algo_lib::Regx& regx) {
    return regx.state_n == 0;
}

// --- algo_lib.Regx.state.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::RegxState* algo_lib::state_Find(algo_lib::Regx& regx, u64 t) {
    u64 idx = t;
    u64 lim = regx.state_n;
    if (idx >= lim) return NULL;
    return regx.state_elems + idx;
}

// --- algo_lib.Regx.state.Getary
// Return array pointer by value
inline algo::aryptr<algo_lib::RegxState> algo_lib::state_Getary(algo_lib::Regx& regx) {
    return algo::aryptr<algo_lib::RegxState>(regx.state_elems, regx.state_n);
}

// --- algo_lib.Regx.state.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo_lib::RegxState* algo_lib::state_Last(algo_lib::Regx& regx) {
    return state_Find(regx, u64(regx.state_n-1));
}

// --- algo_lib.Regx.state.Max
// Return max. number of items in the array
inline i32 algo_lib::state_Max(algo_lib::Regx& regx) {
    (void)regx;
    return regx.state_max;
}

// --- algo_lib.Regx.state.N
// Return number of items in the array
inline i32 algo_lib::state_N(const algo_lib::Regx& regx) {
    return regx.state_n;
}

// --- algo_lib.Regx.state.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::state_Reserve(algo_lib::Regx& regx, int n) {
    u32 new_n = regx.state_n + n;
    if (UNLIKELY(new_n > regx.state_max)) {
        state_AbsReserve(regx, new_n);
    }
}

// --- algo_lib.Regx.state.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo_lib::RegxState& algo_lib::state_qFind(algo_lib::Regx& regx, u64 t) {
    return regx.state_elems[t];
}

// --- algo_lib.Regx.state.qLast
// Return reference to last element of array. No bounds checking
inline algo_lib::RegxState& algo_lib::state_qLast(algo_lib::Regx& regx) {
    return state_qFind(regx, u64(regx.state_n-1));
}

// --- algo_lib.Regx.state.rowid_Get
// Return row id of specified element
inline u64 algo_lib::state_rowid_Get(algo_lib::Regx& regx, algo_lib::RegxState &elem) {
    u64 id = &elem - regx.state_elems;
    return u64(id);
}

// --- algo_lib.Regx.state_curs.Next
// proceed to next item
inline void algo_lib::regx_state_curs_Next(regx_state_curs &curs) {
    curs.index++;
}

// --- algo_lib.Regx.state_curs.Reset
inline void algo_lib::regx_state_curs_Reset(regx_state_curs &curs, algo_lib::Regx &parent) {
    curs.elems = parent.state_elems;
    curs.n_elems = parent.state_n;
    curs.index = 0;
}

// --- algo_lib.Regx.state_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::regx_state_curs_ValidQ(regx_state_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.Regx.state_curs.Access
// item access
inline algo_lib::RegxState& algo_lib::regx_state_curs_Access(regx_state_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.Regx..Init
// Set all fields to initial values.
inline void algo_lib::Regx_Init(algo_lib::Regx& regx) {
    regx.state_elems 	= 0; // (algo_lib.Regx.state)
    regx.state_n     	= 0; // (algo_lib.Regx.state)
    regx.state_max   	= 0; // (algo_lib.Regx.state)
    regx.accept = i32(0);
    regx.parseerror = bool(false);
    regx.accepts_all = bool(false);
    regx.literal = bool(false);
}
inline algo_lib::RegxToken::RegxToken(i32                            in_type)
    : type(in_type)
{
}
inline algo_lib::RegxToken::RegxToken(algo_lib_RegxToken_type_Enum arg) { this->type = i32(arg); }
inline algo_lib::RegxToken::RegxToken() {
    algo_lib::RegxToken_Init(*this);
}


// --- algo_lib.RegxToken.type.GetEnum
// Get value of field as enum type
inline algo_lib_RegxToken_type_Enum algo_lib::type_GetEnum(const algo_lib::RegxToken& parent) {
    return algo_lib_RegxToken_type_Enum(parent.type);
}

// --- algo_lib.RegxToken.type.SetEnum
// Set value of field from enum type.
inline void algo_lib::type_SetEnum(algo_lib::RegxToken& parent, algo_lib_RegxToken_type_Enum rhs) {
    parent.type = i32(rhs);
}

// --- algo_lib.RegxToken.type.Cast
inline algo_lib::RegxToken::operator algo_lib_RegxToken_type_Enum () const {
    return algo_lib_RegxToken_type_Enum((*this).type);
}

// --- algo_lib.RegxToken..Init
// Set all fields to initial values.
inline void algo_lib::RegxToken_Init(algo_lib::RegxToken& parent) {
    parent.type = i32(0);
}
inline algo_lib::RegxExpr::RegxExpr() {
    algo_lib::RegxExpr_Init(*this);
}


// --- algo_lib.RegxExpr..Init
// Set all fields to initial values.
inline void algo_lib::RegxExpr_Init(algo_lib::RegxExpr& ary_expr) {
    ary_expr.in = i32(0);
}
inline algo_lib::RegxParse::RegxParse() {
    algo_lib::RegxParse_Init(*this);
}

inline algo_lib::RegxParse::~RegxParse() {
    algo_lib::RegxParse_Uninit(*this);
}


// --- algo_lib.RegxParse.ary_expr.EmptyQ
// Return true if index is empty
inline bool algo_lib::ary_expr_EmptyQ(algo_lib::RegxParse& regxparse) {
    return regxparse.ary_expr_n == 0;
}

// --- algo_lib.RegxParse.ary_expr.Find
// Look up row by row id. Return NULL if out of range
inline algo_lib::RegxExpr* algo_lib::ary_expr_Find(algo_lib::RegxParse& regxparse, u64 t) {
    u64 idx = t;
    u64 lim = regxparse.ary_expr_n;
    if (idx >= lim) return NULL;
    return regxparse.ary_expr_elems + idx;
}

// --- algo_lib.RegxParse.ary_expr.Getary
// Return array pointer by value
inline algo::aryptr<algo_lib::RegxExpr> algo_lib::ary_expr_Getary(algo_lib::RegxParse& regxparse) {
    return algo::aryptr<algo_lib::RegxExpr>(regxparse.ary_expr_elems, regxparse.ary_expr_n);
}

// --- algo_lib.RegxParse.ary_expr.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo_lib::RegxExpr* algo_lib::ary_expr_Last(algo_lib::RegxParse& regxparse) {
    return ary_expr_Find(regxparse, u64(regxparse.ary_expr_n-1));
}

// --- algo_lib.RegxParse.ary_expr.Max
// Return max. number of items in the array
inline i32 algo_lib::ary_expr_Max(algo_lib::RegxParse& regxparse) {
    (void)regxparse;
    return regxparse.ary_expr_max;
}

// --- algo_lib.RegxParse.ary_expr.N
// Return number of items in the array
inline i32 algo_lib::ary_expr_N(const algo_lib::RegxParse& regxparse) {
    return regxparse.ary_expr_n;
}

// --- algo_lib.RegxParse.ary_expr.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::ary_expr_Reserve(algo_lib::RegxParse& regxparse, int n) {
    u32 new_n = regxparse.ary_expr_n + n;
    if (UNLIKELY(new_n > regxparse.ary_expr_max)) {
        ary_expr_AbsReserve(regxparse, new_n);
    }
}

// --- algo_lib.RegxParse.ary_expr.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo_lib::RegxExpr& algo_lib::ary_expr_qFind(algo_lib::RegxParse& regxparse, u64 t) {
    return regxparse.ary_expr_elems[t];
}

// --- algo_lib.RegxParse.ary_expr.qLast
// Return reference to last element of array. No bounds checking
inline algo_lib::RegxExpr& algo_lib::ary_expr_qLast(algo_lib::RegxParse& regxparse) {
    return ary_expr_qFind(regxparse, u64(regxparse.ary_expr_n-1));
}

// --- algo_lib.RegxParse.ary_expr.rowid_Get
// Return row id of specified element
inline u64 algo_lib::ary_expr_rowid_Get(algo_lib::RegxParse& regxparse, algo_lib::RegxExpr &elem) {
    u64 id = &elem - regxparse.ary_expr_elems;
    return u64(id);
}

// --- algo_lib.RegxParse.ary_expr_curs.Next
// proceed to next item
inline void algo_lib::regxparse_ary_expr_curs_Next(regxparse_ary_expr_curs &curs) {
    curs.index++;
}

// --- algo_lib.RegxParse.ary_expr_curs.Reset
inline void algo_lib::regxparse_ary_expr_curs_Reset(regxparse_ary_expr_curs &curs, algo_lib::RegxParse &parent) {
    curs.elems = parent.ary_expr_elems;
    curs.n_elems = parent.ary_expr_n;
    curs.index = 0;
}

// --- algo_lib.RegxParse.ary_expr_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::regxparse_ary_expr_curs_ValidQ(regxparse_ary_expr_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.RegxParse.ary_expr_curs.Access
// item access
inline algo_lib::RegxExpr& algo_lib::regxparse_ary_expr_curs_Access(regxparse_ary_expr_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.RegxParse..Init
// Set all fields to initial values.
inline void algo_lib::RegxParse_Init(algo_lib::RegxParse& regxparse) {
    regxparse.p_regx = NULL;
    regxparse.ary_expr_elems 	= 0; // (algo_lib.RegxParse.ary_expr)
    regxparse.ary_expr_n     	= 0; // (algo_lib.RegxParse.ary_expr)
    regxparse.ary_expr_max   	= 0; // (algo_lib.RegxParse.ary_expr)
}
inline algo_lib::RegxState::RegxState() {
    algo_lib::RegxState_Init(*this);
}

inline algo_lib::RegxState::~RegxState() {
    algo_lib::RegxState_Uninit(*this);
}


// --- algo_lib.RegxState.ch_class.EmptyQ
// Return true if index is empty
inline bool algo_lib::ch_class_EmptyQ(algo_lib::RegxState& state) {
    return state.ch_class_n == 0;
}

// --- algo_lib.RegxState.ch_class.Find
// Look up row by row id. Return NULL if out of range
inline algo::i32_Range* algo_lib::ch_class_Find(algo_lib::RegxState& state, u64 t) {
    u64 idx = t;
    u64 lim = state.ch_class_n;
    if (idx >= lim) return NULL;
    return state.ch_class_elems + idx;
}

// --- algo_lib.RegxState.ch_class.Getary
// Return array pointer by value
inline algo::aryptr<algo::i32_Range> algo_lib::ch_class_Getary(algo_lib::RegxState& state) {
    return algo::aryptr<algo::i32_Range>(state.ch_class_elems, state.ch_class_n);
}

// --- algo_lib.RegxState.ch_class.Last
// Return pointer to last element of array, or NULL if array is empty
inline algo::i32_Range* algo_lib::ch_class_Last(algo_lib::RegxState& state) {
    return ch_class_Find(state, u64(state.ch_class_n-1));
}

// --- algo_lib.RegxState.ch_class.Max
// Return max. number of items in the array
inline i32 algo_lib::ch_class_Max(algo_lib::RegxState& state) {
    (void)state;
    return state.ch_class_max;
}

// --- algo_lib.RegxState.ch_class.N
// Return number of items in the array
inline i32 algo_lib::ch_class_N(const algo_lib::RegxState& state) {
    return state.ch_class_n;
}

// --- algo_lib.RegxState.ch_class.RemoveAll
inline void algo_lib::ch_class_RemoveAll(algo_lib::RegxState& state) {
    state.ch_class_n = 0;
}

// --- algo_lib.RegxState.ch_class.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::ch_class_Reserve(algo_lib::RegxState& state, int n) {
    u32 new_n = state.ch_class_n + n;
    if (UNLIKELY(new_n > state.ch_class_max)) {
        ch_class_AbsReserve(state, new_n);
    }
}

// --- algo_lib.RegxState.ch_class.qFind
// 'quick' Access row by row id. No bounds checking.
inline algo::i32_Range& algo_lib::ch_class_qFind(algo_lib::RegxState& state, u64 t) {
    return state.ch_class_elems[t];
}

// --- algo_lib.RegxState.ch_class.qLast
// Return reference to last element of array. No bounds checking
inline algo::i32_Range& algo_lib::ch_class_qLast(algo_lib::RegxState& state) {
    return ch_class_qFind(state, u64(state.ch_class_n-1));
}

// --- algo_lib.RegxState.ch_class.rowid_Get
// Return row id of specified element
inline u64 algo_lib::ch_class_rowid_Get(algo_lib::RegxState& state, algo::i32_Range &elem) {
    u64 id = &elem - state.ch_class_elems;
    return u64(id);
}

// --- algo_lib.RegxState.ch_class_curs.Next
// proceed to next item
inline void algo_lib::state_ch_class_curs_Next(state_ch_class_curs &curs) {
    curs.index++;
}

// --- algo_lib.RegxState.ch_class_curs.Reset
inline void algo_lib::state_ch_class_curs_Reset(state_ch_class_curs &curs, algo_lib::RegxState &parent) {
    curs.elems = parent.ch_class_elems;
    curs.n_elems = parent.ch_class_n;
    curs.index = 0;
}

// --- algo_lib.RegxState.ch_class_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::state_ch_class_curs_ValidQ(state_ch_class_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.RegxState.ch_class_curs.Access
// item access
inline algo::i32_Range& algo_lib::state_ch_class_curs_Access(state_ch_class_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.RegxState..Init
// Set all fields to initial values.
inline void algo_lib::RegxState_Init(algo_lib::RegxState& state) {
    state.ch_class_elems 	= 0; // (algo_lib.RegxState.ch_class)
    state.ch_class_n     	= 0; // (algo_lib.RegxState.ch_class)
    state.ch_class_max   	= 0; // (algo_lib.RegxState.ch_class)
    state.accept_all = bool(false);
}
inline algo_lib::Replscope::Replscope() {
    algo_lib::Replscope_Init(*this);
}

inline algo_lib::Replscope::~Replscope() {
    algo_lib::Replscope_Uninit(*this);
}


// --- algo_lib.Replscope.ind_replvar.EmptyQ
// Return true if hash is empty
inline bool algo_lib::ind_replvar_EmptyQ(algo_lib::Replscope& replscope) {
    return replscope.ind_replvar_n == 0;
}

// --- algo_lib.Replscope.ind_replvar.N
// Return number of items in the hash
inline i32 algo_lib::ind_replvar_N(const algo_lib::Replscope& replscope) {
    return replscope.ind_replvar_n;
}

// --- algo_lib.Replscope.ind_replvar_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::replscope_ind_replvar_curs_ValidQ(replscope_ind_replvar_curs &curs) {
    return *curs.prow != NULL;
}

// --- algo_lib.Replscope.ind_replvar_curs.Next
// proceed to next item
inline void algo_lib::replscope_ind_replvar_curs_Next(replscope_ind_replvar_curs &curs) {
    curs.prow = &(*curs.prow)->ind_replvar_next;
    while (!*curs.prow) {
        curs.bucket += 1;
        if (curs.bucket >= curs.parent->ind_replvar_buckets_n) break;
        curs.prow = &curs.parent->ind_replvar_buckets_elems[curs.bucket];
    }
}

// --- algo_lib.Replscope.ind_replvar_curs.Access
// item access
inline algo_lib::FReplvar& algo_lib::replscope_ind_replvar_curs_Access(replscope_ind_replvar_curs &curs) {
    return **curs.prow;
}
inline algo_lib::ShHdr::ShHdr() {
    algo_lib::ShHdr_Init(*this);
}


// --- algo_lib.ShHdr..Init
// Set all fields to initial values.
inline void algo_lib::ShHdr_Init(algo_lib::ShHdr& parent) {
    parent.magic = u32(0x09202017);
    parent.dataoffset = u64(4096);
    parent.eof = u64(0);
    parent.sof = u64(0);
    parent.bufsize = u64(0);
    parent.pad = u64(0);
}
inline algo_lib::Srng::Srng() {
    algo_lib::Srng_Init(*this);
}


// --- algo_lib.Srng..Init
// Set all fields to initial values.
inline void algo_lib::Srng_Init(algo_lib::Srng& parent) {
    parent.z = u32(123);
    parent.w = u32(456);
}
inline algo_lib::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline algo_lib::TableId::TableId(algo_lib_TableIdEnum arg) { this->value = i32(arg); }
inline algo_lib::TableId::TableId() {
    algo_lib::TableId_Init(*this);
}


// --- algo_lib.TableId.value.GetEnum
// Get value of field as enum type
inline algo_lib_TableIdEnum algo_lib::value_GetEnum(const algo_lib::TableId& parent) {
    return algo_lib_TableIdEnum(parent.value);
}

// --- algo_lib.TableId.value.SetEnum
// Set value of field from enum type.
inline void algo_lib::value_SetEnum(algo_lib::TableId& parent, algo_lib_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- algo_lib.TableId.value.Cast
inline algo_lib::TableId::operator algo_lib_TableIdEnum () const {
    return algo_lib_TableIdEnum((*this).value);
}

// --- algo_lib.TableId..Init
// Set all fields to initial values.
inline void algo_lib::TableId_Init(algo_lib::TableId& parent) {
    parent.value = i32(-1);
}
inline algo_lib::Tabulate::Tabulate() {
    algo_lib::Tabulate_Init(*this);
}

inline algo_lib::Tabulate::~Tabulate() {
    algo_lib::Tabulate_Uninit(*this);
}


// --- algo_lib.Tabulate.width.EmptyQ
// Return true if index is empty
inline bool algo_lib::width_EmptyQ(algo_lib::Tabulate& tabulate) {
    return tabulate.width_n == 0;
}

// --- algo_lib.Tabulate.width.Find
// Look up row by row id. Return NULL if out of range
inline i32* algo_lib::width_Find(algo_lib::Tabulate& tabulate, u64 t) {
    u64 idx = t;
    u64 lim = tabulate.width_n;
    if (idx >= lim) return NULL;
    return tabulate.width_elems + idx;
}

// --- algo_lib.Tabulate.width.Getary
// Return array pointer by value
inline algo::aryptr<i32> algo_lib::width_Getary(algo_lib::Tabulate& tabulate) {
    return algo::aryptr<i32>(tabulate.width_elems, tabulate.width_n);
}

// --- algo_lib.Tabulate.width.Last
// Return pointer to last element of array, or NULL if array is empty
inline i32* algo_lib::width_Last(algo_lib::Tabulate& tabulate) {
    return width_Find(tabulate, u64(tabulate.width_n-1));
}

// --- algo_lib.Tabulate.width.Max
// Return max. number of items in the array
inline i32 algo_lib::width_Max(algo_lib::Tabulate& tabulate) {
    (void)tabulate;
    return tabulate.width_max;
}

// --- algo_lib.Tabulate.width.N
// Return number of items in the array
inline i32 algo_lib::width_N(const algo_lib::Tabulate& tabulate) {
    return tabulate.width_n;
}

// --- algo_lib.Tabulate.width.RemoveAll
inline void algo_lib::width_RemoveAll(algo_lib::Tabulate& tabulate) {
    tabulate.width_n = 0;
}

// --- algo_lib.Tabulate.width.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void algo_lib::width_Reserve(algo_lib::Tabulate& tabulate, int n) {
    u32 new_n = tabulate.width_n + n;
    if (UNLIKELY(new_n > tabulate.width_max)) {
        width_AbsReserve(tabulate, new_n);
    }
}

// --- algo_lib.Tabulate.width.qFind
// 'quick' Access row by row id. No bounds checking.
inline i32& algo_lib::width_qFind(algo_lib::Tabulate& tabulate, u64 t) {
    return tabulate.width_elems[t];
}

// --- algo_lib.Tabulate.width.qLast
// Return reference to last element of array. No bounds checking
inline i32& algo_lib::width_qLast(algo_lib::Tabulate& tabulate) {
    return width_qFind(tabulate, u64(tabulate.width_n-1));
}

// --- algo_lib.Tabulate.width.rowid_Get
// Return row id of specified element
inline u64 algo_lib::width_rowid_Get(algo_lib::Tabulate& tabulate, i32 &elem) {
    u64 id = &elem - tabulate.width_elems;
    return u64(id);
}

// --- algo_lib.Tabulate.width_curs.Next
// proceed to next item
inline void algo_lib::tabulate_width_curs_Next(tabulate_width_curs &curs) {
    curs.index++;
}

// --- algo_lib.Tabulate.width_curs.Reset
inline void algo_lib::tabulate_width_curs_Reset(tabulate_width_curs &curs, algo_lib::Tabulate &parent) {
    curs.elems = parent.width_elems;
    curs.n_elems = parent.width_n;
    curs.index = 0;
}

// --- algo_lib.Tabulate.width_curs.ValidQ
// cursor points to valid item
inline bool algo_lib::tabulate_width_curs_ValidQ(tabulate_width_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- algo_lib.Tabulate.width_curs.Access
// item access
inline i32& algo_lib::tabulate_width_curs_Access(tabulate_width_curs &curs) {
    return curs.elems[curs.index];
}

// --- algo_lib.Tabulate..Init
// Set all fields to initial values.
inline void algo_lib::Tabulate_Init(algo_lib::Tabulate& tabulate) {
    tabulate.width_elems 	= 0; // (algo_lib.Tabulate.width)
    tabulate.width_n     	= 0; // (algo_lib.Tabulate.width)
    tabulate.width_max   	= 0; // (algo_lib.Tabulate.width)
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::CsvParse &row) {// cfmt:algo_lib.CsvParse.String
    algo_lib::CsvParse_Print(const_cast<algo_lib::CsvParse&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::ErrorX &row) {// cfmt:algo_lib.ErrorX.String
    algo_lib::ErrorX_Print(const_cast<algo_lib::ErrorX&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::FFildes &row) {// cfmt:algo_lib.FFildes.String
    algo_lib::FFildes_Print(const_cast<algo_lib::FFildes&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::trace &row) {// cfmt:algo_lib.trace.String
    algo_lib::trace_Print(const_cast<algo_lib::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::FDispsigcheck &row) {// cfmt:algo_lib.FDispsigcheck.String
    algo_lib::FDispsigcheck_Print(const_cast<algo_lib::FDispsigcheck&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::FTxttbl &row) {// cfmt:algo_lib.FTxttbl.String
    algo_lib::FTxttbl_Print(const_cast<algo_lib::FTxttbl&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::FieldId &row) {// cfmt:algo_lib.FieldId.String
    algo_lib::FieldId_Print(const_cast<algo_lib::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::Regx &row) {// cfmt:algo_lib.Regx.String
    algo_lib::Regx_Print(const_cast<algo_lib::Regx&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::RegxParse &row) {// cfmt:algo_lib.RegxParse.String
    algo_lib::RegxParse_Print(const_cast<algo_lib::RegxParse&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::RegxState &row) {// cfmt:algo_lib.RegxState.String
    algo_lib::RegxState_Print(const_cast<algo_lib::RegxState&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::Replscope &row) {// cfmt:algo_lib.Replscope.String
    algo_lib::Replscope_Print(const_cast<algo_lib::Replscope&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::TableId &row) {// cfmt:algo_lib.TableId.String
    algo_lib::TableId_Print(const_cast<algo_lib::TableId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const algo_lib::Tabulate &row) {// cfmt:algo_lib.Tabulate.String
    algo_lib::Tabulate_Print(const_cast<algo_lib::Tabulate&>(row), str);
    return str;
}
