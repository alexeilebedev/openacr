//
// include/gen/apm_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/dmmeta_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/command_gen.inl.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude
inline apm::FCtype::FCtype() {
    apm::FCtype_Init(*this);
}

inline apm::FCtype::~FCtype() {
    apm::FCtype_Uninit(*this);
}


// --- apm.FCtype.c_ssimfile.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool apm::c_ssimfile_InsertMaybe(apm::FCtype& ctype, apm::FSsimfile& row) {
    apm::FSsimfile* ptr = ctype.c_ssimfile;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        ctype.c_ssimfile = &row;
    }
    return retval;
}

// --- apm.FCtype.c_ssimfile.Remove
// Remove element from index. If element is not in index, do nothing.
inline void apm::c_ssimfile_Remove(apm::FCtype& ctype, apm::FSsimfile& row) {
    apm::FSsimfile *ptr = ctype.c_ssimfile;
    if (LIKELY(ptr == &row)) {
        ctype.c_ssimfile = NULL;
    }
}

// --- apm.FCtype.c_field.EmptyQ
// Return true if index is empty
inline bool apm::c_field_EmptyQ(apm::FCtype& ctype) {
    return ctype.c_field_n == 0;
}

// --- apm.FCtype.c_field.Find
// Look up row by row id. Return NULL if out of range
inline apm::FField* apm::c_field_Find(apm::FCtype& ctype, u32 t) {
    apm::FField *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_field_n;
    if (idx < lim) {
        retval = ctype.c_field_elems[idx];
    }
    return retval;
}

// --- apm.FCtype.c_field.Getary
// Return array of pointers
inline algo::aryptr<apm::FField*> apm::c_field_Getary(apm::FCtype& ctype) {
    return algo::aryptr<apm::FField*>(ctype.c_field_elems, ctype.c_field_n);
}

// --- apm.FCtype.c_field.N
// Return number of items in the pointer array
inline i32 apm::c_field_N(const apm::FCtype& ctype) {
    return ctype.c_field_n;
}

// --- apm.FCtype.c_field.RemoveAll
// Empty the index. (The rows are not deleted)
inline void apm::c_field_RemoveAll(apm::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_field_n; i++) {
        // mark all elements as not-in-array
        ctype.c_field_elems[i]->ctype_c_field_in_ary = false;
    }
    ctype.c_field_n = 0;
}

// --- apm.FCtype.c_field.qFind
// Return reference without bounds checking
inline apm::FField& apm::c_field_qFind(apm::FCtype& ctype, u32 idx) {
    return *ctype.c_field_elems[idx];
}

// --- apm.FCtype.c_field.InAryQ
// True if row is in any ptrary instance
inline bool apm::ctype_c_field_InAryQ(apm::FField& row) {
    return row.ctype_c_field_in_ary;
}

// --- apm.FCtype.c_field.qLast
// Reference to last element without bounds checking
inline apm::FField& apm::c_field_qLast(apm::FCtype& ctype) {
    return *ctype.c_field_elems[ctype.c_field_n-1];
}

// --- apm.FCtype.c_ssimreq.EmptyQ
// Return true if index is empty
inline bool apm::c_ssimreq_EmptyQ(apm::FCtype& ctype) {
    return ctype.c_ssimreq_n == 0;
}

// --- apm.FCtype.c_ssimreq.Find
// Look up row by row id. Return NULL if out of range
inline apm::FSsimreq* apm::c_ssimreq_Find(apm::FCtype& ctype, u32 t) {
    apm::FSsimreq *retval = NULL;
    u64 idx = t;
    u64 lim = ctype.c_ssimreq_n;
    if (idx < lim) {
        retval = ctype.c_ssimreq_elems[idx];
    }
    return retval;
}

// --- apm.FCtype.c_ssimreq.Getary
// Return array of pointers
inline algo::aryptr<apm::FSsimreq*> apm::c_ssimreq_Getary(apm::FCtype& ctype) {
    return algo::aryptr<apm::FSsimreq*>(ctype.c_ssimreq_elems, ctype.c_ssimreq_n);
}

// --- apm.FCtype.c_ssimreq.N
// Return number of items in the pointer array
inline i32 apm::c_ssimreq_N(const apm::FCtype& ctype) {
    return ctype.c_ssimreq_n;
}

// --- apm.FCtype.c_ssimreq.RemoveAll
// Empty the index. (The rows are not deleted)
inline void apm::c_ssimreq_RemoveAll(apm::FCtype& ctype) {
    for (u32 i = 0; i < ctype.c_ssimreq_n; i++) {
        // mark all elements as not-in-array
        ctype.c_ssimreq_elems[i]->ctype_c_ssimreq_in_ary = false;
    }
    ctype.c_ssimreq_n = 0;
}

// --- apm.FCtype.c_ssimreq.qFind
// Return reference without bounds checking
inline apm::FSsimreq& apm::c_ssimreq_qFind(apm::FCtype& ctype, u32 idx) {
    return *ctype.c_ssimreq_elems[idx];
}

// --- apm.FCtype.c_ssimreq.InAryQ
// True if row is in any ptrary instance
inline bool apm::ctype_c_ssimreq_InAryQ(apm::FSsimreq& row) {
    return row.ctype_c_ssimreq_in_ary;
}

// --- apm.FCtype.c_ssimreq.qLast
// Reference to last element without bounds checking
inline apm::FSsimreq& apm::c_ssimreq_qLast(apm::FCtype& ctype) {
    return *ctype.c_ssimreq_elems[ctype.c_ssimreq_n-1];
}

// --- apm.FCtype.c_field_curs.Reset
inline void apm::ctype_c_field_curs_Reset(ctype_c_field_curs &curs, apm::FCtype &parent) {
    curs.elems = parent.c_field_elems;
    curs.n_elems = parent.c_field_n;
    curs.index = 0;
}

// --- apm.FCtype.c_field_curs.ValidQ
// cursor points to valid item
inline bool apm::ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- apm.FCtype.c_field_curs.Next
// proceed to next item
inline void apm::ctype_c_field_curs_Next(ctype_c_field_curs &curs) {
    curs.index++;
}

// --- apm.FCtype.c_field_curs.Access
// item access
inline apm::FField& apm::ctype_c_field_curs_Access(ctype_c_field_curs &curs) {
    return *curs.elems[curs.index];
}

// --- apm.FCtype.c_ssimreq_curs.Reset
inline void apm::ctype_c_ssimreq_curs_Reset(ctype_c_ssimreq_curs &curs, apm::FCtype &parent) {
    curs.elems = parent.c_ssimreq_elems;
    curs.n_elems = parent.c_ssimreq_n;
    curs.index = 0;
}

// --- apm.FCtype.c_ssimreq_curs.ValidQ
// cursor points to valid item
inline bool apm::ctype_c_ssimreq_curs_ValidQ(ctype_c_ssimreq_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- apm.FCtype.c_ssimreq_curs.Next
// proceed to next item
inline void apm::ctype_c_ssimreq_curs_Next(ctype_c_ssimreq_curs &curs) {
    curs.index++;
}

// --- apm.FCtype.c_ssimreq_curs.Access
// item access
inline apm::FSsimreq& apm::ctype_c_ssimreq_curs_Access(ctype_c_ssimreq_curs &curs) {
    return *curs.elems[curs.index];
}

// --- apm.FCtype..Init
// Set all fields to initial values.
inline void apm::FCtype_Init(apm::FCtype& ctype) {
    ctype.c_ssimfile = NULL;
    ctype.c_field_elems = NULL; // (apm.FCtype.c_field)
    ctype.c_field_n = 0; // (apm.FCtype.c_field)
    ctype.c_field_max = 0; // (apm.FCtype.c_field)
    ctype.c_ssimreq_elems = NULL; // (apm.FCtype.c_ssimreq)
    ctype.c_ssimreq_n = 0; // (apm.FCtype.c_ssimreq)
    ctype.c_ssimreq_max = 0; // (apm.FCtype.c_ssimreq)
    ctype.ind_ctype_next = (apm::FCtype*)-1; // (apm.FDb.ind_ctype) not-in-hash
}
inline apm::trace::trace() {
}


// --- apm.FDb.package.EmptyQ
// Return true if index is empty
inline bool apm::package_EmptyQ() {
    return _db.package_n == 0;
}

// --- apm.FDb.package.Find
// Look up row by row id. Return NULL if out of range
inline apm::FPackage* apm::package_Find(u64 t) {
    apm::FPackage *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.package_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.package_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.package.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FPackage* apm::package_Last() {
    return package_Find(u64(_db.package_n-1));
}

// --- apm.FDb.package.N
// Return number of items in the pool
inline i32 apm::package_N() {
    return _db.package_n;
}

// --- apm.FDb.package.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FPackage& apm::package_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.package_lary[bsr][index];
}

// --- apm.FDb.zd_sel_package.EmptyQ
// Return true if index is empty
inline bool apm::zd_sel_package_EmptyQ() {
    return _db.zd_sel_package_head == NULL;
}

// --- apm.FDb.zd_sel_package.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FPackage* apm::zd_sel_package_First() {
    apm::FPackage *row = NULL;
    row = _db.zd_sel_package_head;
    return row;
}

// --- apm.FDb.zd_sel_package.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_sel_package_InLlistQ(apm::FPackage& row) {
    bool result = false;
    result = !(row.zd_sel_package_next == (apm::FPackage*)-1);
    return result;
}

// --- apm.FDb.zd_sel_package.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FPackage* apm::zd_sel_package_Last() {
    apm::FPackage *row = NULL;
    row = _db.zd_sel_package_tail;
    return row;
}

// --- apm.FDb.zd_sel_package.N
// Return number of items in the linked list
inline i32 apm::zd_sel_package_N() {
    return _db.zd_sel_package_n;
}

// --- apm.FDb.zd_sel_package.Next
// Return pointer to next element in the list
inline apm::FPackage* apm::zd_sel_package_Next(apm::FPackage &row) {
    return row.zd_sel_package_next;
}

// --- apm.FDb.zd_sel_package.Prev
// Return pointer to previous element in the list
inline apm::FPackage* apm::zd_sel_package_Prev(apm::FPackage &row) {
    return row.zd_sel_package_prev;
}

// --- apm.FDb.zd_sel_package.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FPackage& apm::zd_sel_package_qLast() {
    apm::FPackage *row = NULL;
    row = _db.zd_sel_package_tail;
    return *row;
}

// --- apm.FDb.ind_package.EmptyQ
// Return true if hash is empty
inline bool apm::ind_package_EmptyQ() {
    return _db.ind_package_n == 0;
}

// --- apm.FDb.ind_package.N
// Return number of items in the hash
inline i32 apm::ind_package_N() {
    return _db.ind_package_n;
}

// --- apm.FDb.pkgkey.EmptyQ
// Return true if index is empty
inline bool apm::pkgkey_EmptyQ() {
    return _db.pkgkey_n == 0;
}

// --- apm.FDb.pkgkey.Find
// Look up row by row id. Return NULL if out of range
inline apm::FPkgkey* apm::pkgkey_Find(u64 t) {
    apm::FPkgkey *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.pkgkey_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.pkgkey_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.pkgkey.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FPkgkey* apm::pkgkey_Last() {
    return pkgkey_Find(u64(_db.pkgkey_n-1));
}

// --- apm.FDb.pkgkey.N
// Return number of items in the pool
inline i32 apm::pkgkey_N() {
    return _db.pkgkey_n;
}

// --- apm.FDb.pkgkey.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FPkgkey& apm::pkgkey_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.pkgkey_lary[bsr][index];
}

// --- apm.FDb.pkgdep.EmptyQ
// Return true if index is empty
inline bool apm::pkgdep_EmptyQ() {
    return _db.pkgdep_n == 0;
}

// --- apm.FDb.pkgdep.Find
// Look up row by row id. Return NULL if out of range
inline apm::FPkgdep* apm::pkgdep_Find(u64 t) {
    apm::FPkgdep *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.pkgdep_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.pkgdep_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.pkgdep.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FPkgdep* apm::pkgdep_Last() {
    return pkgdep_Find(u64(_db.pkgdep_n-1));
}

// --- apm.FDb.pkgdep.N
// Return number of items in the pool
inline i32 apm::pkgdep_N() {
    return _db.pkgdep_n;
}

// --- apm.FDb.pkgdep.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FPkgdep& apm::pkgdep_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.pkgdep_lary[bsr][index];
}

// --- apm.FDb.mergefile.EmptyQ
// Return true if index is empty
inline bool apm::mergefile_EmptyQ() {
    return _db.mergefile_n == 0;
}

// --- apm.FDb.mergefile.Find
// Look up row by row id. Return NULL if out of range
inline apm::FMergefile* apm::mergefile_Find(u64 t) {
    apm::FMergefile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.mergefile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.mergefile_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.mergefile.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FMergefile* apm::mergefile_Last() {
    return mergefile_Find(u64(_db.mergefile_n-1));
}

// --- apm.FDb.mergefile.N
// Return number of items in the pool
inline i32 apm::mergefile_N() {
    return _db.mergefile_n;
}

// --- apm.FDb.mergefile.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FMergefile& apm::mergefile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.mergefile_lary[bsr][index];
}

// --- apm.FDb.ind_mergefile.EmptyQ
// Return true if hash is empty
inline bool apm::ind_mergefile_EmptyQ() {
    return _db.ind_mergefile_n == 0;
}

// --- apm.FDb.ind_mergefile.N
// Return number of items in the hash
inline i32 apm::ind_mergefile_N() {
    return _db.ind_mergefile_n;
}

// --- apm.FDb.ind_pkgkey.EmptyQ
// Return true if hash is empty
inline bool apm::ind_pkgkey_EmptyQ() {
    return _db.ind_pkgkey_n == 0;
}

// --- apm.FDb.ind_pkgkey.N
// Return number of items in the hash
inline i32 apm::ind_pkgkey_N() {
    return _db.ind_pkgkey_n;
}

// --- apm.FDb.ctype.EmptyQ
// Return true if index is empty
inline bool apm::ctype_EmptyQ() {
    return _db.ctype_n == 0;
}

// --- apm.FDb.ctype.Find
// Look up row by row id. Return NULL if out of range
inline apm::FCtype* apm::ctype_Find(u64 t) {
    apm::FCtype *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ctype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ctype_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.ctype.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FCtype* apm::ctype_Last() {
    return ctype_Find(u64(_db.ctype_n-1));
}

// --- apm.FDb.ctype.N
// Return number of items in the pool
inline i32 apm::ctype_N() {
    return _db.ctype_n;
}

// --- apm.FDb.ctype.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FCtype& apm::ctype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ctype_lary[bsr][index];
}

// --- apm.FDb.ind_ctype.EmptyQ
// Return true if hash is empty
inline bool apm::ind_ctype_EmptyQ() {
    return _db.ind_ctype_n == 0;
}

// --- apm.FDb.ind_ctype.N
// Return number of items in the hash
inline i32 apm::ind_ctype_N() {
    return _db.ind_ctype_n;
}

// --- apm.FDb.field.EmptyQ
// Return true if index is empty
inline bool apm::field_EmptyQ() {
    return _db.field_n == 0;
}

// --- apm.FDb.field.Find
// Look up row by row id. Return NULL if out of range
inline apm::FField* apm::field_Find(u64 t) {
    apm::FField *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.field_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.field_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.field.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FField* apm::field_Last() {
    return field_Find(u64(_db.field_n-1));
}

// --- apm.FDb.field.N
// Return number of items in the pool
inline i32 apm::field_N() {
    return _db.field_n;
}

// --- apm.FDb.field.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FField& apm::field_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.field_lary[bsr][index];
}

// --- apm.FDb.ind_field.EmptyQ
// Return true if hash is empty
inline bool apm::ind_field_EmptyQ() {
    return _db.ind_field_n == 0;
}

// --- apm.FDb.ind_field.N
// Return number of items in the hash
inline i32 apm::ind_field_N() {
    return _db.ind_field_n;
}

// --- apm.FDb.ssimfile.EmptyQ
// Return true if index is empty
inline bool apm::ssimfile_EmptyQ() {
    return _db.ssimfile_n == 0;
}

// --- apm.FDb.ssimfile.Find
// Look up row by row id. Return NULL if out of range
inline apm::FSsimfile* apm::ssimfile_Find(u64 t) {
    apm::FSsimfile *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ssimfile_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ssimfile_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.ssimfile.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FSsimfile* apm::ssimfile_Last() {
    return ssimfile_Find(u64(_db.ssimfile_n-1));
}

// --- apm.FDb.ssimfile.N
// Return number of items in the pool
inline i32 apm::ssimfile_N() {
    return _db.ssimfile_n;
}

// --- apm.FDb.ssimfile.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FSsimfile& apm::ssimfile_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimfile_lary[bsr][index];
}

// --- apm.FDb.ind_ssimfile.EmptyQ
// Return true if hash is empty
inline bool apm::ind_ssimfile_EmptyQ() {
    return _db.ind_ssimfile_n == 0;
}

// --- apm.FDb.ind_ssimfile.N
// Return number of items in the hash
inline i32 apm::ind_ssimfile_N() {
    return _db.ind_ssimfile_n;
}

// --- apm.FDb.ind_rec.EmptyQ
// Return true if hash is empty
inline bool apm::ind_rec_EmptyQ() {
    return _db.ind_rec_n == 0;
}

// --- apm.FDb.ind_rec.N
// Return number of items in the hash
inline i32 apm::ind_rec_N() {
    return _db.ind_rec_n;
}

// --- apm.FDb.zd_rec.EmptyQ
// Return true if index is empty
inline bool apm::zd_rec_EmptyQ() {
    return _db.zd_rec_head == NULL;
}

// --- apm.FDb.zd_rec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FRec* apm::zd_rec_First() {
    apm::FRec *row = NULL;
    row = _db.zd_rec_head;
    return row;
}

// --- apm.FDb.zd_rec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_rec_InLlistQ(apm::FRec& row) {
    bool result = false;
    result = !(row.zd_rec_next == (apm::FRec*)-1);
    return result;
}

// --- apm.FDb.zd_rec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FRec* apm::zd_rec_Last() {
    apm::FRec *row = NULL;
    row = _db.zd_rec_tail;
    return row;
}

// --- apm.FDb.zd_rec.N
// Return number of items in the linked list
inline i32 apm::zd_rec_N() {
    return _db.zd_rec_n;
}

// --- apm.FDb.zd_rec.Next
// Return pointer to next element in the list
inline apm::FRec* apm::zd_rec_Next(apm::FRec &row) {
    return row.zd_rec_next;
}

// --- apm.FDb.zd_rec.Prev
// Return pointer to previous element in the list
inline apm::FRec* apm::zd_rec_Prev(apm::FRec &row) {
    return row.zd_rec_prev;
}

// --- apm.FDb.zd_rec.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FRec& apm::zd_rec_qLast() {
    apm::FRec *row = NULL;
    row = _db.zd_rec_tail;
    return *row;
}

// --- apm.FDb.zd_selrec.EmptyQ
// Return true if index is empty
inline bool apm::zd_selrec_EmptyQ() {
    return _db.zd_selrec_head == NULL;
}

// --- apm.FDb.zd_selrec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FRec* apm::zd_selrec_First() {
    apm::FRec *row = NULL;
    row = _db.zd_selrec_head;
    return row;
}

// --- apm.FDb.zd_selrec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_selrec_InLlistQ(apm::FRec& row) {
    bool result = false;
    result = !(row.zd_selrec_next == (apm::FRec*)-1);
    return result;
}

// --- apm.FDb.zd_selrec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FRec* apm::zd_selrec_Last() {
    apm::FRec *row = NULL;
    row = _db.zd_selrec_tail;
    return row;
}

// --- apm.FDb.zd_selrec.N
// Return number of items in the linked list
inline i32 apm::zd_selrec_N() {
    return _db.zd_selrec_n;
}

// --- apm.FDb.zd_selrec.Next
// Return pointer to next element in the list
inline apm::FRec* apm::zd_selrec_Next(apm::FRec &row) {
    return row.zd_selrec_next;
}

// --- apm.FDb.zd_selrec.Prev
// Return pointer to previous element in the list
inline apm::FRec* apm::zd_selrec_Prev(apm::FRec &row) {
    return row.zd_selrec_prev;
}

// --- apm.FDb.zd_selrec.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FRec& apm::zd_selrec_qLast() {
    apm::FRec *row = NULL;
    row = _db.zd_selrec_tail;
    return *row;
}

// --- apm.FDb.zd_chooserec.EmptyQ
// Return true if index is empty
inline bool apm::zd_chooserec_EmptyQ() {
    return _db.zd_chooserec_head == NULL;
}

// --- apm.FDb.zd_chooserec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FRec* apm::zd_chooserec_First() {
    apm::FRec *row = NULL;
    row = _db.zd_chooserec_head;
    return row;
}

// --- apm.FDb.zd_chooserec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_chooserec_InLlistQ(apm::FRec& row) {
    bool result = false;
    result = !(row.zd_chooserec_next == (apm::FRec*)-1);
    return result;
}

// --- apm.FDb.zd_chooserec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FRec* apm::zd_chooserec_Last() {
    apm::FRec *row = NULL;
    row = _db.zd_chooserec_tail;
    return row;
}

// --- apm.FDb.zd_chooserec.N
// Return number of items in the linked list
inline i32 apm::zd_chooserec_N() {
    return _db.zd_chooserec_n;
}

// --- apm.FDb.zd_chooserec.Next
// Return pointer to next element in the list
inline apm::FRec* apm::zd_chooserec_Next(apm::FRec &row) {
    return row.zd_chooserec_next;
}

// --- apm.FDb.zd_chooserec.Prev
// Return pointer to previous element in the list
inline apm::FRec* apm::zd_chooserec_Prev(apm::FRec &row) {
    return row.zd_chooserec_prev;
}

// --- apm.FDb.zd_chooserec.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FRec& apm::zd_chooserec_qLast() {
    apm::FRec *row = NULL;
    row = _db.zd_chooserec_tail;
    return *row;
}

// --- apm.FDb.substr.EmptyQ
// Return true if index is empty
inline bool apm::substr_EmptyQ() {
    return _db.substr_n == 0;
}

// --- apm.FDb.substr.Find
// Look up row by row id. Return NULL if out of range
inline apm::FSubstr* apm::substr_Find(u64 t) {
    apm::FSubstr *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.substr_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.substr_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.substr.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FSubstr* apm::substr_Last() {
    return substr_Find(u64(_db.substr_n-1));
}

// --- apm.FDb.substr.N
// Return number of items in the pool
inline i32 apm::substr_N() {
    return _db.substr_n;
}

// --- apm.FDb.substr.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FSubstr& apm::substr_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.substr_lary[bsr][index];
}

// --- apm.FDb.zd_topo_package.EmptyQ
// Return true if index is empty
inline bool apm::zd_topo_package_EmptyQ() {
    return _db.zd_topo_package_head == NULL;
}

// --- apm.FDb.zd_topo_package.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FPackage* apm::zd_topo_package_First() {
    apm::FPackage *row = NULL;
    row = _db.zd_topo_package_head;
    return row;
}

// --- apm.FDb.zd_topo_package.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_topo_package_InLlistQ(apm::FPackage& row) {
    bool result = false;
    result = !(row.zd_topo_package_next == (apm::FPackage*)-1);
    return result;
}

// --- apm.FDb.zd_topo_package.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FPackage* apm::zd_topo_package_Last() {
    apm::FPackage *row = NULL;
    row = _db.zd_topo_package_tail;
    return row;
}

// --- apm.FDb.zd_topo_package.N
// Return number of items in the linked list
inline i32 apm::zd_topo_package_N() {
    return _db.zd_topo_package_n;
}

// --- apm.FDb.zd_topo_package.Next
// Return pointer to next element in the list
inline apm::FPackage* apm::zd_topo_package_Next(apm::FPackage &row) {
    return row.zd_topo_package_next;
}

// --- apm.FDb.zd_topo_package.Prev
// Return pointer to previous element in the list
inline apm::FPackage* apm::zd_topo_package_Prev(apm::FPackage &row) {
    return row.zd_topo_package_prev;
}

// --- apm.FDb.zd_topo_package.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FPackage& apm::zd_topo_package_qLast() {
    apm::FPackage *row = NULL;
    row = _db.zd_topo_package_tail;
    return *row;
}

// --- apm.FDb.ssimreq.EmptyQ
// Return true if index is empty
inline bool apm::ssimreq_EmptyQ() {
    return _db.ssimreq_n == 0;
}

// --- apm.FDb.ssimreq.Find
// Look up row by row id. Return NULL if out of range
inline apm::FSsimreq* apm::ssimreq_Find(u64 t) {
    apm::FSsimreq *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ssimreq_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ssimreq_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.ssimreq.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FSsimreq* apm::ssimreq_Last() {
    return ssimreq_Find(u64(_db.ssimreq_n-1));
}

// --- apm.FDb.ssimreq.N
// Return number of items in the pool
inline i32 apm::ssimreq_N() {
    return _db.ssimreq_n;
}

// --- apm.FDb.ssimreq.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FSsimreq& apm::ssimreq_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ssimreq_lary[bsr][index];
}

// --- apm.FDb.mkdir.EmptyQ
// Return true if index is empty
inline bool apm::mkdir_EmptyQ() {
    return _db.mkdir_n == 0;
}

// --- apm.FDb.mkdir.Find
// Look up row by row id. Return NULL if out of range
inline apm::FMkdir* apm::mkdir_Find(u64 t) {
    apm::FMkdir *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.mkdir_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.mkdir_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.mkdir.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FMkdir* apm::mkdir_Last() {
    return mkdir_Find(u64(_db.mkdir_n-1));
}

// --- apm.FDb.mkdir.N
// Return number of items in the pool
inline i32 apm::mkdir_N() {
    return _db.mkdir_n;
}

// --- apm.FDb.mkdir.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FMkdir& apm::mkdir_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.mkdir_lary[bsr][index];
}

// --- apm.FDb.ind_mkdir.EmptyQ
// Return true if hash is empty
inline bool apm::ind_mkdir_EmptyQ() {
    return _db.ind_mkdir_n == 0;
}

// --- apm.FDb.ind_mkdir.N
// Return number of items in the hash
inline i32 apm::ind_mkdir_N() {
    return _db.ind_mkdir_n;
}

// --- apm.FDb.ns.EmptyQ
// Return true if index is empty
inline bool apm::ns_EmptyQ() {
    return _db.ns_n == 0;
}

// --- apm.FDb.ns.Find
// Look up row by row id. Return NULL if out of range
inline apm::FNs* apm::ns_Find(u64 t) {
    apm::FNs *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.ns_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.ns_lary[bsr][index];
    }
    return retval;
}

// --- apm.FDb.ns.Last
// Return pointer to last element of array, or NULL if array is empty
inline apm::FNs* apm::ns_Last() {
    return ns_Find(u64(_db.ns_n-1));
}

// --- apm.FDb.ns.N
// Return number of items in the pool
inline i32 apm::ns_N() {
    return _db.ns_n;
}

// --- apm.FDb.ns.qFind
// 'quick' Access row by row id. No bounds checking.
inline apm::FNs& apm::ns_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.ns_lary[bsr][index];
}

// --- apm.FDb.package_curs.Reset
// cursor points to valid item
inline void apm::_db_package_curs_Reset(_db_package_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.package_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_package_curs_ValidQ(_db_package_curs &curs) {
    return curs.index < _db.package_n;
}

// --- apm.FDb.package_curs.Next
// proceed to next item
inline void apm::_db_package_curs_Next(_db_package_curs &curs) {
    curs.index++;
}

// --- apm.FDb.package_curs.Access
// item access
inline apm::FPackage& apm::_db_package_curs_Access(_db_package_curs &curs) {
    return package_qFind(u64(curs.index));
}

// --- apm.FDb.zd_sel_package_curs.Reset
// cursor points to valid item
inline void apm::_db_zd_sel_package_curs_Reset(_db_zd_sel_package_curs &curs, apm::FDb &parent) {
    curs.row = parent.zd_sel_package_head;
}

// --- apm.FDb.zd_sel_package_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_zd_sel_package_curs_ValidQ(_db_zd_sel_package_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FDb.zd_sel_package_curs.Next
// proceed to next item
inline void apm::_db_zd_sel_package_curs_Next(_db_zd_sel_package_curs &curs) {
    apm::FPackage *next = (*curs.row).zd_sel_package_next;
    curs.row = next;
}

// --- apm.FDb.zd_sel_package_curs.Access
// item access
inline apm::FPackage& apm::_db_zd_sel_package_curs_Access(_db_zd_sel_package_curs &curs) {
    return *curs.row;
}

// --- apm.FDb.pkgkey_curs.Reset
// cursor points to valid item
inline void apm::_db_pkgkey_curs_Reset(_db_pkgkey_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.pkgkey_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_pkgkey_curs_ValidQ(_db_pkgkey_curs &curs) {
    return curs.index < _db.pkgkey_n;
}

// --- apm.FDb.pkgkey_curs.Next
// proceed to next item
inline void apm::_db_pkgkey_curs_Next(_db_pkgkey_curs &curs) {
    curs.index++;
}

// --- apm.FDb.pkgkey_curs.Access
// item access
inline apm::FPkgkey& apm::_db_pkgkey_curs_Access(_db_pkgkey_curs &curs) {
    return pkgkey_qFind(u64(curs.index));
}

// --- apm.FDb.pkgdep_curs.Reset
// cursor points to valid item
inline void apm::_db_pkgdep_curs_Reset(_db_pkgdep_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.pkgdep_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_pkgdep_curs_ValidQ(_db_pkgdep_curs &curs) {
    return curs.index < _db.pkgdep_n;
}

// --- apm.FDb.pkgdep_curs.Next
// proceed to next item
inline void apm::_db_pkgdep_curs_Next(_db_pkgdep_curs &curs) {
    curs.index++;
}

// --- apm.FDb.pkgdep_curs.Access
// item access
inline apm::FPkgdep& apm::_db_pkgdep_curs_Access(_db_pkgdep_curs &curs) {
    return pkgdep_qFind(u64(curs.index));
}

// --- apm.FDb.mergefile_curs.Reset
// cursor points to valid item
inline void apm::_db_mergefile_curs_Reset(_db_mergefile_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.mergefile_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_mergefile_curs_ValidQ(_db_mergefile_curs &curs) {
    return curs.index < _db.mergefile_n;
}

// --- apm.FDb.mergefile_curs.Next
// proceed to next item
inline void apm::_db_mergefile_curs_Next(_db_mergefile_curs &curs) {
    curs.index++;
}

// --- apm.FDb.mergefile_curs.Access
// item access
inline apm::FMergefile& apm::_db_mergefile_curs_Access(_db_mergefile_curs &curs) {
    return mergefile_qFind(u64(curs.index));
}

// --- apm.FDb.ctype_curs.Reset
// cursor points to valid item
inline void apm::_db_ctype_curs_Reset(_db_ctype_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.ctype_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_ctype_curs_ValidQ(_db_ctype_curs &curs) {
    return curs.index < _db.ctype_n;
}

// --- apm.FDb.ctype_curs.Next
// proceed to next item
inline void apm::_db_ctype_curs_Next(_db_ctype_curs &curs) {
    curs.index++;
}

// --- apm.FDb.ctype_curs.Access
// item access
inline apm::FCtype& apm::_db_ctype_curs_Access(_db_ctype_curs &curs) {
    return ctype_qFind(u64(curs.index));
}

// --- apm.FDb.field_curs.Reset
// cursor points to valid item
inline void apm::_db_field_curs_Reset(_db_field_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.field_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_field_curs_ValidQ(_db_field_curs &curs) {
    return curs.index < _db.field_n;
}

// --- apm.FDb.field_curs.Next
// proceed to next item
inline void apm::_db_field_curs_Next(_db_field_curs &curs) {
    curs.index++;
}

// --- apm.FDb.field_curs.Access
// item access
inline apm::FField& apm::_db_field_curs_Access(_db_field_curs &curs) {
    return field_qFind(u64(curs.index));
}

// --- apm.FDb.ssimfile_curs.Reset
// cursor points to valid item
inline void apm::_db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.ssimfile_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) {
    return curs.index < _db.ssimfile_n;
}

// --- apm.FDb.ssimfile_curs.Next
// proceed to next item
inline void apm::_db_ssimfile_curs_Next(_db_ssimfile_curs &curs) {
    curs.index++;
}

// --- apm.FDb.ssimfile_curs.Access
// item access
inline apm::FSsimfile& apm::_db_ssimfile_curs_Access(_db_ssimfile_curs &curs) {
    return ssimfile_qFind(u64(curs.index));
}

// --- apm.FDb.zd_rec_curs.Reset
// cursor points to valid item
inline void apm::_db_zd_rec_curs_Reset(_db_zd_rec_curs &curs, apm::FDb &parent) {
    curs.row = parent.zd_rec_head;
}

// --- apm.FDb.zd_rec_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_zd_rec_curs_ValidQ(_db_zd_rec_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FDb.zd_rec_curs.Next
// proceed to next item
inline void apm::_db_zd_rec_curs_Next(_db_zd_rec_curs &curs) {
    apm::FRec *next = (*curs.row).zd_rec_next;
    curs.row = next;
}

// --- apm.FDb.zd_rec_curs.Access
// item access
inline apm::FRec& apm::_db_zd_rec_curs_Access(_db_zd_rec_curs &curs) {
    return *curs.row;
}

// --- apm.FDb.zd_selrec_curs.Reset
// cursor points to valid item
inline void apm::_db_zd_selrec_curs_Reset(_db_zd_selrec_curs &curs, apm::FDb &parent) {
    curs.row = parent.zd_selrec_head;
}

// --- apm.FDb.zd_selrec_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_zd_selrec_curs_ValidQ(_db_zd_selrec_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FDb.zd_selrec_curs.Next
// proceed to next item
inline void apm::_db_zd_selrec_curs_Next(_db_zd_selrec_curs &curs) {
    apm::FRec *next = (*curs.row).zd_selrec_next;
    curs.row = next;
}

// --- apm.FDb.zd_selrec_curs.Access
// item access
inline apm::FRec& apm::_db_zd_selrec_curs_Access(_db_zd_selrec_curs &curs) {
    return *curs.row;
}

// --- apm.FDb.zd_chooserec_curs.Reset
// cursor points to valid item
inline void apm::_db_zd_chooserec_curs_Reset(_db_zd_chooserec_curs &curs, apm::FDb &parent) {
    curs.row = parent.zd_chooserec_head;
}

// --- apm.FDb.zd_chooserec_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_zd_chooserec_curs_ValidQ(_db_zd_chooserec_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FDb.zd_chooserec_curs.Next
// proceed to next item
inline void apm::_db_zd_chooserec_curs_Next(_db_zd_chooserec_curs &curs) {
    apm::FRec *next = (*curs.row).zd_chooserec_next;
    curs.row = next;
}

// --- apm.FDb.zd_chooserec_curs.Access
// item access
inline apm::FRec& apm::_db_zd_chooserec_curs_Access(_db_zd_chooserec_curs &curs) {
    return *curs.row;
}

// --- apm.FDb.zd_chooserec_delcurs.Reset
// cursor points to valid item
inline void apm::_db_zd_chooserec_delcurs_Reset(_db_zd_chooserec_delcurs &curs, apm::FDb &parent) {
    curs.row = parent.zd_chooserec_head;
    if (curs.row) {
        curs.next = (*curs.row).zd_chooserec_next;
    }
}

// --- apm.FDb.zd_chooserec_delcurs.ValidQ
// cursor points to valid item
inline bool apm::_db_zd_chooserec_delcurs_ValidQ(_db_zd_chooserec_delcurs &curs) {
    return curs.row != NULL;
}

// --- apm.FDb.zd_chooserec_delcurs.Next
// proceed to next item
inline void apm::_db_zd_chooserec_delcurs_Next(_db_zd_chooserec_delcurs &curs) {
    apm::FRec *next = curs.next;
    curs.row = next;
    if (curs.row) {
        curs.next = (*curs.row).zd_chooserec_next;
    }
}

// --- apm.FDb.zd_chooserec_delcurs.Access
// item access
inline apm::FRec& apm::_db_zd_chooserec_delcurs_Access(_db_zd_chooserec_delcurs &curs) {
    return *curs.row;
}

// --- apm.FDb.substr_curs.Reset
// cursor points to valid item
inline void apm::_db_substr_curs_Reset(_db_substr_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.substr_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_substr_curs_ValidQ(_db_substr_curs &curs) {
    return curs.index < _db.substr_n;
}

// --- apm.FDb.substr_curs.Next
// proceed to next item
inline void apm::_db_substr_curs_Next(_db_substr_curs &curs) {
    curs.index++;
}

// --- apm.FDb.substr_curs.Access
// item access
inline apm::FSubstr& apm::_db_substr_curs_Access(_db_substr_curs &curs) {
    return substr_qFind(u64(curs.index));
}

// --- apm.FDb.zd_topo_package_curs.Reset
// cursor points to valid item
inline void apm::_db_zd_topo_package_curs_Reset(_db_zd_topo_package_curs &curs, apm::FDb &parent) {
    curs.row = parent.zd_topo_package_head;
}

// --- apm.FDb.zd_topo_package_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_zd_topo_package_curs_ValidQ(_db_zd_topo_package_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FDb.zd_topo_package_curs.Next
// proceed to next item
inline void apm::_db_zd_topo_package_curs_Next(_db_zd_topo_package_curs &curs) {
    apm::FPackage *next = (*curs.row).zd_topo_package_next;
    curs.row = next;
}

// --- apm.FDb.zd_topo_package_curs.Access
// item access
inline apm::FPackage& apm::_db_zd_topo_package_curs_Access(_db_zd_topo_package_curs &curs) {
    return *curs.row;
}

// --- apm.FDb.ssimreq_curs.Reset
// cursor points to valid item
inline void apm::_db_ssimreq_curs_Reset(_db_ssimreq_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.ssimreq_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_ssimreq_curs_ValidQ(_db_ssimreq_curs &curs) {
    return curs.index < _db.ssimreq_n;
}

// --- apm.FDb.ssimreq_curs.Next
// proceed to next item
inline void apm::_db_ssimreq_curs_Next(_db_ssimreq_curs &curs) {
    curs.index++;
}

// --- apm.FDb.ssimreq_curs.Access
// item access
inline apm::FSsimreq& apm::_db_ssimreq_curs_Access(_db_ssimreq_curs &curs) {
    return ssimreq_qFind(u64(curs.index));
}

// --- apm.FDb.mkdir_curs.Reset
// cursor points to valid item
inline void apm::_db_mkdir_curs_Reset(_db_mkdir_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.mkdir_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_mkdir_curs_ValidQ(_db_mkdir_curs &curs) {
    return curs.index < _db.mkdir_n;
}

// --- apm.FDb.mkdir_curs.Next
// proceed to next item
inline void apm::_db_mkdir_curs_Next(_db_mkdir_curs &curs) {
    curs.index++;
}

// --- apm.FDb.mkdir_curs.Access
// item access
inline apm::FMkdir& apm::_db_mkdir_curs_Access(_db_mkdir_curs &curs) {
    return mkdir_qFind(u64(curs.index));
}

// --- apm.FDb.ns_curs.Reset
// cursor points to valid item
inline void apm::_db_ns_curs_Reset(_db_ns_curs &curs, apm::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- apm.FDb.ns_curs.ValidQ
// cursor points to valid item
inline bool apm::_db_ns_curs_ValidQ(_db_ns_curs &curs) {
    return curs.index < _db.ns_n;
}

// --- apm.FDb.ns_curs.Next
// proceed to next item
inline void apm::_db_ns_curs_Next(_db_ns_curs &curs) {
    curs.index++;
}

// --- apm.FDb.ns_curs.Access
// item access
inline apm::FNs& apm::_db_ns_curs_Access(_db_ns_curs &curs) {
    return ns_qFind(u64(curs.index));
}
inline apm::FField::FField() {
    apm::FField_Init(*this);
}

inline apm::FField::~FField() {
    apm::FField_Uninit(*this);
}


// --- apm.FField.c_substr.InsertMaybe
// Insert row into pointer index. Return final membership status.
inline bool apm::c_substr_InsertMaybe(apm::FField& field, apm::FSubstr& row) {
    apm::FSubstr* ptr = field.c_substr;
    bool retval = (ptr == NULL) | (ptr == &row);
    if (retval) {
        field.c_substr = &row;
    }
    return retval;
}

// --- apm.FField.c_substr.Remove
// Remove element from index. If element is not in index, do nothing.
inline void apm::c_substr_Remove(apm::FField& field, apm::FSubstr& row) {
    apm::FSubstr *ptr = field.c_substr;
    if (LIKELY(ptr == &row)) {
        field.c_substr = NULL;
    }
}
inline apm::FMergefile::FMergefile() {
    apm::FMergefile_Init(*this);
}

inline apm::FMergefile::~FMergefile() {
    apm::FMergefile_Uninit(*this);
}


// --- apm.FMergefile..Init
// Set all fields to initial values.
inline void apm::FMergefile_Init(apm::FMergefile& mergefile) {
    mergefile.base_mode = i32(0);
    mergefile.ours_mode = i32(0);
    mergefile.theirs_mode = i32(0);
    mergefile.ind_mergefile_next = (apm::FMergefile*)-1; // (apm.FDb.ind_mergefile) not-in-hash
}
inline apm::FMkdir::FMkdir() {
    apm::FMkdir_Init(*this);
}

inline apm::FMkdir::~FMkdir() {
    apm::FMkdir_Uninit(*this);
}


// --- apm.FMkdir..Init
// Set all fields to initial values.
inline void apm::FMkdir_Init(apm::FMkdir& mkdir) {
    mkdir.ind_mkdir_next = (apm::FMkdir*)-1; // (apm.FDb.ind_mkdir) not-in-hash
}
inline apm::FNs::FNs() {
}

inline apm::FPackage::FPackage() {
    apm::FPackage_Init(*this);
}

inline apm::FPackage::~FPackage() {
    apm::FPackage_Uninit(*this);
}


// --- apm.FPackage.zd_pkgkey.EmptyQ
// Return true if index is empty
inline bool apm::zd_pkgkey_EmptyQ(apm::FPackage& package) {
    return package.zd_pkgkey_head == NULL;
}

// --- apm.FPackage.zd_pkgkey.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FPkgkey* apm::zd_pkgkey_First(apm::FPackage& package) {
    apm::FPkgkey *row = NULL;
    row = package.zd_pkgkey_head;
    return row;
}

// --- apm.FPackage.zd_pkgkey.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_pkgkey_InLlistQ(apm::FPkgkey& row) {
    bool result = false;
    result = !(row.zd_pkgkey_next == (apm::FPkgkey*)-1);
    return result;
}

// --- apm.FPackage.zd_pkgkey.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FPkgkey* apm::zd_pkgkey_Last(apm::FPackage& package) {
    apm::FPkgkey *row = NULL;
    row = package.zd_pkgkey_tail;
    return row;
}

// --- apm.FPackage.zd_pkgkey.N
// Return number of items in the linked list
inline i32 apm::zd_pkgkey_N(const apm::FPackage& package) {
    return package.zd_pkgkey_n;
}

// --- apm.FPackage.zd_pkgkey.Next
// Return pointer to next element in the list
inline apm::FPkgkey* apm::zd_pkgkey_Next(apm::FPkgkey &row) {
    return row.zd_pkgkey_next;
}

// --- apm.FPackage.zd_pkgkey.Prev
// Return pointer to previous element in the list
inline apm::FPkgkey* apm::zd_pkgkey_Prev(apm::FPkgkey &row) {
    return row.zd_pkgkey_prev;
}

// --- apm.FPackage.zd_pkgkey.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FPkgkey& apm::zd_pkgkey_qLast(apm::FPackage& package) {
    apm::FPkgkey *row = NULL;
    row = package.zd_pkgkey_tail;
    return *row;
}

// --- apm.FPackage.c_pkgdep.EmptyQ
// Return true if index is empty
inline bool apm::c_pkgdep_EmptyQ(apm::FPackage& package) {
    return package.c_pkgdep_n == 0;
}

// --- apm.FPackage.c_pkgdep.Find
// Look up row by row id. Return NULL if out of range
inline apm::FPkgdep* apm::c_pkgdep_Find(apm::FPackage& package, u32 t) {
    apm::FPkgdep *retval = NULL;
    u64 idx = t;
    u64 lim = package.c_pkgdep_n;
    if (idx < lim) {
        retval = package.c_pkgdep_elems[idx];
    }
    return retval;
}

// --- apm.FPackage.c_pkgdep.Getary
// Return array of pointers
inline algo::aryptr<apm::FPkgdep*> apm::c_pkgdep_Getary(apm::FPackage& package) {
    return algo::aryptr<apm::FPkgdep*>(package.c_pkgdep_elems, package.c_pkgdep_n);
}

// --- apm.FPackage.c_pkgdep.N
// Return number of items in the pointer array
inline i32 apm::c_pkgdep_N(const apm::FPackage& package) {
    return package.c_pkgdep_n;
}

// --- apm.FPackage.c_pkgdep.RemoveAll
// Empty the index. (The rows are not deleted)
inline void apm::c_pkgdep_RemoveAll(apm::FPackage& package) {
    for (u32 i = 0; i < package.c_pkgdep_n; i++) {
        // mark all elements as not-in-array
        package.c_pkgdep_elems[i]->package_c_pkgdep_in_ary = false;
    }
    package.c_pkgdep_n = 0;
}

// --- apm.FPackage.c_pkgdep.qFind
// Return reference without bounds checking
inline apm::FPkgdep& apm::c_pkgdep_qFind(apm::FPackage& package, u32 idx) {
    return *package.c_pkgdep_elems[idx];
}

// --- apm.FPackage.c_pkgdep.InAryQ
// True if row is in any ptrary instance
inline bool apm::package_c_pkgdep_InAryQ(apm::FPkgdep& row) {
    return row.package_c_pkgdep_in_ary;
}

// --- apm.FPackage.c_pkgdep.qLast
// Reference to last element without bounds checking
inline apm::FPkgdep& apm::c_pkgdep_qLast(apm::FPackage& package) {
    return *package.c_pkgdep_elems[package.c_pkgdep_n-1];
}

// --- apm.FPackage.c_pkgdep_parent.EmptyQ
// Return true if index is empty
inline bool apm::c_pkgdep_parent_EmptyQ(apm::FPackage& package) {
    return package.c_pkgdep_parent_n == 0;
}

// --- apm.FPackage.c_pkgdep_parent.Find
// Look up row by row id. Return NULL if out of range
inline apm::FPkgdep* apm::c_pkgdep_parent_Find(apm::FPackage& package, u32 t) {
    apm::FPkgdep *retval = NULL;
    u64 idx = t;
    u64 lim = package.c_pkgdep_parent_n;
    if (idx < lim) {
        retval = package.c_pkgdep_parent_elems[idx];
    }
    return retval;
}

// --- apm.FPackage.c_pkgdep_parent.Getary
// Return array of pointers
inline algo::aryptr<apm::FPkgdep*> apm::c_pkgdep_parent_Getary(apm::FPackage& package) {
    return algo::aryptr<apm::FPkgdep*>(package.c_pkgdep_parent_elems, package.c_pkgdep_parent_n);
}

// --- apm.FPackage.c_pkgdep_parent.N
// Return number of items in the pointer array
inline i32 apm::c_pkgdep_parent_N(const apm::FPackage& package) {
    return package.c_pkgdep_parent_n;
}

// --- apm.FPackage.c_pkgdep_parent.RemoveAll
// Empty the index. (The rows are not deleted)
inline void apm::c_pkgdep_parent_RemoveAll(apm::FPackage& package) {
    for (u32 i = 0; i < package.c_pkgdep_parent_n; i++) {
        // mark all elements as not-in-array
        package.c_pkgdep_parent_elems[i]->package_c_pkgdep_parent_in_ary = false;
    }
    package.c_pkgdep_parent_n = 0;
}

// --- apm.FPackage.c_pkgdep_parent.qFind
// Return reference without bounds checking
inline apm::FPkgdep& apm::c_pkgdep_parent_qFind(apm::FPackage& package, u32 idx) {
    return *package.c_pkgdep_parent_elems[idx];
}

// --- apm.FPackage.c_pkgdep_parent.InAryQ
// True if row is in any ptrary instance
inline bool apm::package_c_pkgdep_parent_InAryQ(apm::FPkgdep& row) {
    return row.package_c_pkgdep_parent_in_ary;
}

// --- apm.FPackage.c_pkgdep_parent.qLast
// Reference to last element without bounds checking
inline apm::FPkgdep& apm::c_pkgdep_parent_qLast(apm::FPackage& package) {
    return *package.c_pkgdep_parent_elems[package.c_pkgdep_parent_n-1];
}

// --- apm.FPackage.zd_pkgrec.EmptyQ
// Return true if index is empty
inline bool apm::zd_pkgrec_EmptyQ(apm::FPackage& package) {
    return package.zd_pkgrec_head == NULL;
}

// --- apm.FPackage.zd_pkgrec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FPkgrec* apm::zd_pkgrec_First(apm::FPackage& package) {
    apm::FPkgrec *row = NULL;
    row = package.zd_pkgrec_head;
    return row;
}

// --- apm.FPackage.zd_pkgrec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_pkgrec_InLlistQ(apm::FPkgrec& row) {
    bool result = false;
    result = !(row.zd_pkgrec_next == (apm::FPkgrec*)-1);
    return result;
}

// --- apm.FPackage.zd_pkgrec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FPkgrec* apm::zd_pkgrec_Last(apm::FPackage& package) {
    apm::FPkgrec *row = NULL;
    row = package.zd_pkgrec_tail;
    return row;
}

// --- apm.FPackage.zd_pkgrec.N
// Return number of items in the linked list
inline i32 apm::zd_pkgrec_N(const apm::FPackage& package) {
    return package.zd_pkgrec_n;
}

// --- apm.FPackage.zd_pkgrec.Next
// Return pointer to next element in the list
inline apm::FPkgrec* apm::zd_pkgrec_Next(apm::FPkgrec &row) {
    return row.zd_pkgrec_next;
}

// --- apm.FPackage.zd_pkgrec.Prev
// Return pointer to previous element in the list
inline apm::FPkgrec* apm::zd_pkgrec_Prev(apm::FPkgrec &row) {
    return row.zd_pkgrec_prev;
}

// --- apm.FPackage.zd_pkgrec.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FPkgrec& apm::zd_pkgrec_qLast(apm::FPackage& package) {
    apm::FPkgrec *row = NULL;
    row = package.zd_pkgrec_tail;
    return *row;
}

// --- apm.FPackage..Init
// Set all fields to initial values.
inline void apm::FPackage_Init(apm::FPackage& package) {
    package.zd_pkgkey_head = NULL; // (apm.FPackage.zd_pkgkey)
    package.zd_pkgkey_n = 0; // (apm.FPackage.zd_pkgkey)
    package.zd_pkgkey_tail = NULL; // (apm.FPackage.zd_pkgkey)
    package.c_pkgdep_elems = NULL; // (apm.FPackage.c_pkgdep)
    package.c_pkgdep_n = 0; // (apm.FPackage.c_pkgdep)
    package.c_pkgdep_max = 0; // (apm.FPackage.c_pkgdep)
    package.c_pkgdep_parent_elems = NULL; // (apm.FPackage.c_pkgdep_parent)
    package.c_pkgdep_parent_n = 0; // (apm.FPackage.c_pkgdep_parent)
    package.c_pkgdep_parent_max = 0; // (apm.FPackage.c_pkgdep_parent)
    package.zd_pkgrec_head = NULL; // (apm.FPackage.zd_pkgrec)
    package.zd_pkgrec_n = 0; // (apm.FPackage.zd_pkgrec)
    package.zd_pkgrec_tail = NULL; // (apm.FPackage.zd_pkgrec)
    package.visited = bool(false);
    package.zd_sel_package_next = (apm::FPackage*)-1; // (apm.FDb.zd_sel_package) not-in-list
    package.zd_sel_package_prev = NULL; // (apm.FDb.zd_sel_package)
    package.ind_package_next = (apm::FPackage*)-1; // (apm.FDb.ind_package) not-in-hash
    package.zd_topo_package_next = (apm::FPackage*)-1; // (apm.FDb.zd_topo_package) not-in-list
    package.zd_topo_package_prev = NULL; // (apm.FDb.zd_topo_package)
}

// --- apm.FPackage.zd_pkgkey_curs.Reset
// cursor points to valid item
inline void apm::package_zd_pkgkey_curs_Reset(package_zd_pkgkey_curs &curs, apm::FPackage &parent) {
    curs.row = parent.zd_pkgkey_head;
}

// --- apm.FPackage.zd_pkgkey_curs.ValidQ
// cursor points to valid item
inline bool apm::package_zd_pkgkey_curs_ValidQ(package_zd_pkgkey_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FPackage.zd_pkgkey_curs.Next
// proceed to next item
inline void apm::package_zd_pkgkey_curs_Next(package_zd_pkgkey_curs &curs) {
    apm::FPkgkey *next = (*curs.row).zd_pkgkey_next;
    curs.row = next;
}

// --- apm.FPackage.zd_pkgkey_curs.Access
// item access
inline apm::FPkgkey& apm::package_zd_pkgkey_curs_Access(package_zd_pkgkey_curs &curs) {
    return *curs.row;
}

// --- apm.FPackage.c_pkgdep_curs.Reset
inline void apm::package_c_pkgdep_curs_Reset(package_c_pkgdep_curs &curs, apm::FPackage &parent) {
    curs.elems = parent.c_pkgdep_elems;
    curs.n_elems = parent.c_pkgdep_n;
    curs.index = 0;
}

// --- apm.FPackage.c_pkgdep_curs.ValidQ
// cursor points to valid item
inline bool apm::package_c_pkgdep_curs_ValidQ(package_c_pkgdep_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- apm.FPackage.c_pkgdep_curs.Next
// proceed to next item
inline void apm::package_c_pkgdep_curs_Next(package_c_pkgdep_curs &curs) {
    curs.index++;
}

// --- apm.FPackage.c_pkgdep_curs.Access
// item access
inline apm::FPkgdep& apm::package_c_pkgdep_curs_Access(package_c_pkgdep_curs &curs) {
    return *curs.elems[curs.index];
}

// --- apm.FPackage.c_pkgdep_parent_curs.Reset
inline void apm::package_c_pkgdep_parent_curs_Reset(package_c_pkgdep_parent_curs &curs, apm::FPackage &parent) {
    curs.elems = parent.c_pkgdep_parent_elems;
    curs.n_elems = parent.c_pkgdep_parent_n;
    curs.index = 0;
}

// --- apm.FPackage.c_pkgdep_parent_curs.ValidQ
// cursor points to valid item
inline bool apm::package_c_pkgdep_parent_curs_ValidQ(package_c_pkgdep_parent_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- apm.FPackage.c_pkgdep_parent_curs.Next
// proceed to next item
inline void apm::package_c_pkgdep_parent_curs_Next(package_c_pkgdep_parent_curs &curs) {
    curs.index++;
}

// --- apm.FPackage.c_pkgdep_parent_curs.Access
// item access
inline apm::FPkgdep& apm::package_c_pkgdep_parent_curs_Access(package_c_pkgdep_parent_curs &curs) {
    return *curs.elems[curs.index];
}

// --- apm.FPackage.zd_pkgrec_curs.Reset
// cursor points to valid item
inline void apm::package_zd_pkgrec_curs_Reset(package_zd_pkgrec_curs &curs, apm::FPackage &parent) {
    curs.row = parent.zd_pkgrec_head;
}

// --- apm.FPackage.zd_pkgrec_curs.ValidQ
// cursor points to valid item
inline bool apm::package_zd_pkgrec_curs_ValidQ(package_zd_pkgrec_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FPackage.zd_pkgrec_curs.Next
// proceed to next item
inline void apm::package_zd_pkgrec_curs_Next(package_zd_pkgrec_curs &curs) {
    apm::FPkgrec *next = (*curs.row).zd_pkgrec_next;
    curs.row = next;
}

// --- apm.FPackage.zd_pkgrec_curs.Access
// item access
inline apm::FPkgrec& apm::package_zd_pkgrec_curs_Access(package_zd_pkgrec_curs &curs) {
    return *curs.row;
}
inline apm::FPkgdep::FPkgdep() {
    apm::FPkgdep_Init(*this);
}

inline apm::FPkgdep::~FPkgdep() {
    apm::FPkgdep_Uninit(*this);
}


// --- apm.FPkgdep..Init
// Set all fields to initial values.
inline void apm::FPkgdep_Init(apm::FPkgdep& pkgdep) {
    pkgdep.soft = bool(false);
    pkgdep.p_parent = NULL;
    pkgdep.p_package = NULL;
    pkgdep.package_c_pkgdep_in_ary = bool(false);
    pkgdep.package_c_pkgdep_parent_in_ary = bool(false);
}
inline apm::FPkgkey::FPkgkey() {
    apm::FPkgkey_Init(*this);
}

inline apm::FPkgkey::~FPkgkey() {
    apm::FPkgkey_Uninit(*this);
}


// --- apm.FPkgkey.c_pkgrec.EmptyQ
// Return true if index is empty
inline bool apm::c_pkgrec_EmptyQ(apm::FPkgkey& pkgkey) {
    return pkgkey.c_pkgrec_n == 0;
}

// --- apm.FPkgkey.c_pkgrec.Find
// Look up row by row id. Return NULL if out of range
inline apm::FPkgrec* apm::c_pkgrec_Find(apm::FPkgkey& pkgkey, u32 t) {
    apm::FPkgrec *retval = NULL;
    u64 idx = t;
    u64 lim = pkgkey.c_pkgrec_n;
    if (idx < lim) {
        retval = pkgkey.c_pkgrec_elems[idx];
    }
    return retval;
}

// --- apm.FPkgkey.c_pkgrec.Getary
// Return array of pointers
inline algo::aryptr<apm::FPkgrec*> apm::c_pkgrec_Getary(apm::FPkgkey& pkgkey) {
    return algo::aryptr<apm::FPkgrec*>(pkgkey.c_pkgrec_elems, pkgkey.c_pkgrec_n);
}

// --- apm.FPkgkey.c_pkgrec.N
// Return number of items in the pointer array
inline i32 apm::c_pkgrec_N(const apm::FPkgkey& pkgkey) {
    return pkgkey.c_pkgrec_n;
}

// --- apm.FPkgkey.c_pkgrec.RemoveAll
// Empty the index. (The rows are not deleted)
inline void apm::c_pkgrec_RemoveAll(apm::FPkgkey& pkgkey) {
    for (u32 i = 0; i < pkgkey.c_pkgrec_n; i++) {
        // mark all elements as not-in-array
        pkgkey.c_pkgrec_elems[i]->pkgkey_c_pkgrec_in_ary = false;
    }
    pkgkey.c_pkgrec_n = 0;
}

// --- apm.FPkgkey.c_pkgrec.qFind
// Return reference without bounds checking
inline apm::FPkgrec& apm::c_pkgrec_qFind(apm::FPkgkey& pkgkey, u32 idx) {
    return *pkgkey.c_pkgrec_elems[idx];
}

// --- apm.FPkgkey.c_pkgrec.InAryQ
// True if row is in any ptrary instance
inline bool apm::pkgkey_c_pkgrec_InAryQ(apm::FPkgrec& row) {
    return row.pkgkey_c_pkgrec_in_ary;
}

// --- apm.FPkgkey.c_pkgrec.qLast
// Reference to last element without bounds checking
inline apm::FPkgrec& apm::c_pkgrec_qLast(apm::FPkgkey& pkgkey) {
    return *pkgkey.c_pkgrec_elems[pkgkey.c_pkgrec_n-1];
}

// --- apm.FPkgkey..Init
// Set all fields to initial values.
inline void apm::FPkgkey_Init(apm::FPkgkey& pkgkey) {
    pkgkey.c_pkgrec_elems = NULL; // (apm.FPkgkey.c_pkgrec)
    pkgkey.c_pkgrec_n = 0; // (apm.FPkgkey.c_pkgrec)
    pkgkey.c_pkgrec_max = 0; // (apm.FPkgkey.c_pkgrec)
    pkgkey.ind_pkgkey_next = (apm::FPkgkey*)-1; // (apm.FDb.ind_pkgkey) not-in-hash
    pkgkey.zd_pkgkey_next = (apm::FPkgkey*)-1; // (apm.FPackage.zd_pkgkey) not-in-list
    pkgkey.zd_pkgkey_prev = NULL; // (apm.FPackage.zd_pkgkey)
}

// --- apm.FPkgkey.c_pkgrec_curs.Reset
inline void apm::pkgkey_c_pkgrec_curs_Reset(pkgkey_c_pkgrec_curs &curs, apm::FPkgkey &parent) {
    curs.elems = parent.c_pkgrec_elems;
    curs.n_elems = parent.c_pkgrec_n;
    curs.index = 0;
}

// --- apm.FPkgkey.c_pkgrec_curs.ValidQ
// cursor points to valid item
inline bool apm::pkgkey_c_pkgrec_curs_ValidQ(pkgkey_c_pkgrec_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- apm.FPkgkey.c_pkgrec_curs.Next
// proceed to next item
inline void apm::pkgkey_c_pkgrec_curs_Next(pkgkey_c_pkgrec_curs &curs) {
    curs.index++;
}

// --- apm.FPkgkey.c_pkgrec_curs.Access
// item access
inline apm::FPkgrec& apm::pkgkey_c_pkgrec_curs_Access(pkgkey_c_pkgrec_curs &curs) {
    return *curs.elems[curs.index];
}
inline apm::FPkgrec::FPkgrec() {
    apm::FPkgrec_Init(*this);
}

inline apm::FPkgrec::~FPkgrec() {
    apm::FPkgrec_Uninit(*this);
}


// --- apm.FPkgrec..Init
// Set all fields to initial values.
inline void apm::FPkgrec_Init(apm::FPkgrec& pkgrec) {
    pkgrec.p_package = NULL;
    pkgrec.p_rec = NULL;
    pkgrec.p_pkgkey = NULL;
    pkgrec.pkgkey_c_pkgrec_in_ary = bool(false);
    pkgrec.pkgrec_next = (apm::FPkgrec*)-1; // (apm.FDb.pkgrec) not-in-tpool's freelist
    pkgrec.zd_pkgrec_next = (apm::FPkgrec*)-1; // (apm.FPackage.zd_pkgrec) not-in-list
    pkgrec.zd_pkgrec_prev = NULL; // (apm.FPackage.zd_pkgrec)
    pkgrec.zd_rec_pkgrec_next = (apm::FPkgrec*)-1; // (apm.FRec.zd_rec_pkgrec) not-in-list
    pkgrec.zd_rec_pkgrec_prev = NULL; // (apm.FRec.zd_rec_pkgrec)
}
inline apm::FRec::FRec() {
    apm::FRec_Init(*this);
}

inline apm::FRec::~FRec() {
    apm::FRec_Uninit(*this);
}


// --- apm.FRec.c_child.EmptyQ
// Return true if index is empty
inline bool apm::c_child_EmptyQ(apm::FRec& rec) {
    return rec.c_child_n == 0;
}

// --- apm.FRec.c_child.Find
// Look up row by row id. Return NULL if out of range
inline apm::FRec* apm::c_child_Find(apm::FRec& rec, u32 t) {
    apm::FRec *retval = NULL;
    u64 idx = t;
    u64 lim = rec.c_child_n;
    if (idx < lim) {
        retval = rec.c_child_elems[idx];
    }
    return retval;
}

// --- apm.FRec.c_child.Getary
// Return array of pointers
inline algo::aryptr<apm::FRec*> apm::c_child_Getary(apm::FRec& rec) {
    return algo::aryptr<apm::FRec*>(rec.c_child_elems, rec.c_child_n);
}

// --- apm.FRec.c_child.N
// Return number of items in the pointer array
inline i32 apm::c_child_N(const apm::FRec& rec) {
    return rec.c_child_n;
}

// --- apm.FRec.c_child.RemoveAll
// Empty the index. (The rows are not deleted)
inline void apm::c_child_RemoveAll(apm::FRec& rec) {
    rec.c_child_n = 0;
}

// --- apm.FRec.c_child.qFind
// Return reference without bounds checking
inline apm::FRec& apm::c_child_qFind(apm::FRec& rec, u32 idx) {
    return *rec.c_child_elems[idx];
}

// --- apm.FRec.c_child.qLast
// Reference to last element without bounds checking
inline apm::FRec& apm::c_child_qLast(apm::FRec& rec) {
    return *rec.c_child_elems[rec.c_child_n-1];
}

// --- apm.FRec.zd_rec_pkgrec.EmptyQ
// Return true if index is empty
inline bool apm::zd_rec_pkgrec_EmptyQ(apm::FRec& rec) {
    return rec.zd_rec_pkgrec_head == NULL;
}

// --- apm.FRec.zd_rec_pkgrec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FPkgrec* apm::zd_rec_pkgrec_First(apm::FRec& rec) {
    apm::FPkgrec *row = NULL;
    row = rec.zd_rec_pkgrec_head;
    return row;
}

// --- apm.FRec.zd_rec_pkgrec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_rec_pkgrec_InLlistQ(apm::FPkgrec& row) {
    bool result = false;
    result = !(row.zd_rec_pkgrec_next == (apm::FPkgrec*)-1);
    return result;
}

// --- apm.FRec.zd_rec_pkgrec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FPkgrec* apm::zd_rec_pkgrec_Last(apm::FRec& rec) {
    apm::FPkgrec *row = NULL;
    row = rec.zd_rec_pkgrec_tail;
    return row;
}

// --- apm.FRec.zd_rec_pkgrec.N
// Return number of items in the linked list
inline i32 apm::zd_rec_pkgrec_N(const apm::FRec& rec) {
    return rec.zd_rec_pkgrec_n;
}

// --- apm.FRec.zd_rec_pkgrec.Next
// Return pointer to next element in the list
inline apm::FPkgrec* apm::zd_rec_pkgrec_Next(apm::FPkgrec &row) {
    return row.zd_rec_pkgrec_next;
}

// --- apm.FRec.zd_rec_pkgrec.Prev
// Return pointer to previous element in the list
inline apm::FPkgrec* apm::zd_rec_pkgrec_Prev(apm::FPkgrec &row) {
    return row.zd_rec_pkgrec_prev;
}

// --- apm.FRec.zd_rec_pkgrec.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FPkgrec& apm::zd_rec_pkgrec_qLast(apm::FRec& rec) {
    apm::FPkgrec *row = NULL;
    row = rec.zd_rec_pkgrec_tail;
    return *row;
}

// --- apm.FRec..Init
// Set all fields to initial values.
inline void apm::FRec_Init(apm::FRec& rec) {
    rec.p_ssimfile = NULL;
    rec.c_child_elems = NULL; // (apm.FRec.c_child)
    rec.c_child_n = 0; // (apm.FRec.c_child)
    rec.c_child_max = 0; // (apm.FRec.c_child)
    rec.level = i32(0);
    rec.zd_rec_pkgrec_head = NULL; // (apm.FRec.zd_rec_pkgrec)
    rec.zd_rec_pkgrec_n = 0; // (apm.FRec.zd_rec_pkgrec)
    rec.zd_rec_pkgrec_tail = NULL; // (apm.FRec.zd_rec_pkgrec)
    rec.rec_next = (apm::FRec*)-1; // (apm.FDb.rec) not-in-tpool's freelist
    rec.ind_rec_next = (apm::FRec*)-1; // (apm.FDb.ind_rec) not-in-hash
    rec.zd_rec_next = (apm::FRec*)-1; // (apm.FDb.zd_rec) not-in-list
    rec.zd_rec_prev = NULL; // (apm.FDb.zd_rec)
    rec.zd_selrec_next = (apm::FRec*)-1; // (apm.FDb.zd_selrec) not-in-list
    rec.zd_selrec_prev = NULL; // (apm.FDb.zd_selrec)
    rec.zd_chooserec_next = (apm::FRec*)-1; // (apm.FDb.zd_chooserec) not-in-list
    rec.zd_chooserec_prev = NULL; // (apm.FDb.zd_chooserec)
    rec.zd_ssimfile_rec_next = (apm::FRec*)-1; // (apm.FSsimfile.zd_ssimfile_rec) not-in-list
    rec.zd_ssimfile_rec_prev = NULL; // (apm.FSsimfile.zd_ssimfile_rec)
}

// --- apm.FRec.c_child_curs.Reset
inline void apm::rec_c_child_curs_Reset(rec_c_child_curs &curs, apm::FRec &parent) {
    curs.elems = parent.c_child_elems;
    curs.n_elems = parent.c_child_n;
    curs.index = 0;
}

// --- apm.FRec.c_child_curs.ValidQ
// cursor points to valid item
inline bool apm::rec_c_child_curs_ValidQ(rec_c_child_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- apm.FRec.c_child_curs.Next
// proceed to next item
inline void apm::rec_c_child_curs_Next(rec_c_child_curs &curs) {
    curs.index++;
}

// --- apm.FRec.c_child_curs.Access
// item access
inline apm::FRec& apm::rec_c_child_curs_Access(rec_c_child_curs &curs) {
    return *curs.elems[curs.index];
}

// --- apm.FRec.zd_rec_pkgrec_curs.Reset
// cursor points to valid item
inline void apm::rec_zd_rec_pkgrec_curs_Reset(rec_zd_rec_pkgrec_curs &curs, apm::FRec &parent) {
    curs.row = parent.zd_rec_pkgrec_head;
}

// --- apm.FRec.zd_rec_pkgrec_curs.ValidQ
// cursor points to valid item
inline bool apm::rec_zd_rec_pkgrec_curs_ValidQ(rec_zd_rec_pkgrec_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FRec.zd_rec_pkgrec_curs.Next
// proceed to next item
inline void apm::rec_zd_rec_pkgrec_curs_Next(rec_zd_rec_pkgrec_curs &curs) {
    apm::FPkgrec *next = (*curs.row).zd_rec_pkgrec_next;
    curs.row = next;
}

// --- apm.FRec.zd_rec_pkgrec_curs.Access
// item access
inline apm::FPkgrec& apm::rec_zd_rec_pkgrec_curs_Access(rec_zd_rec_pkgrec_curs &curs) {
    return *curs.row;
}
inline apm::FSsimfile::FSsimfile() {
    apm::FSsimfile_Init(*this);
}

inline apm::FSsimfile::~FSsimfile() {
    apm::FSsimfile_Uninit(*this);
}


// --- apm.FSsimfile.zd_ssimfile_rec.EmptyQ
// Return true if index is empty
inline bool apm::zd_ssimfile_rec_EmptyQ(apm::FSsimfile& ssimfile) {
    return ssimfile.zd_ssimfile_rec_head == NULL;
}

// --- apm.FSsimfile.zd_ssimfile_rec.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline apm::FRec* apm::zd_ssimfile_rec_First(apm::FSsimfile& ssimfile) {
    apm::FRec *row = NULL;
    row = ssimfile.zd_ssimfile_rec_head;
    return row;
}

// --- apm.FSsimfile.zd_ssimfile_rec.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool apm::zd_ssimfile_rec_InLlistQ(apm::FRec& row) {
    bool result = false;
    result = !(row.zd_ssimfile_rec_next == (apm::FRec*)-1);
    return result;
}

// --- apm.FSsimfile.zd_ssimfile_rec.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline apm::FRec* apm::zd_ssimfile_rec_Last(apm::FSsimfile& ssimfile) {
    apm::FRec *row = NULL;
    row = ssimfile.zd_ssimfile_rec_tail;
    return row;
}

// --- apm.FSsimfile.zd_ssimfile_rec.N
// Return number of items in the linked list
inline i32 apm::zd_ssimfile_rec_N(const apm::FSsimfile& ssimfile) {
    return ssimfile.zd_ssimfile_rec_n;
}

// --- apm.FSsimfile.zd_ssimfile_rec.Next
// Return pointer to next element in the list
inline apm::FRec* apm::zd_ssimfile_rec_Next(apm::FRec &row) {
    return row.zd_ssimfile_rec_next;
}

// --- apm.FSsimfile.zd_ssimfile_rec.Prev
// Return pointer to previous element in the list
inline apm::FRec* apm::zd_ssimfile_rec_Prev(apm::FRec &row) {
    return row.zd_ssimfile_rec_prev;
}

// --- apm.FSsimfile.zd_ssimfile_rec.qLast
// Return reference to last element in the index. No bounds checking.
inline apm::FRec& apm::zd_ssimfile_rec_qLast(apm::FSsimfile& ssimfile) {
    apm::FRec *row = NULL;
    row = ssimfile.zd_ssimfile_rec_tail;
    return *row;
}

// --- apm.FSsimfile..Init
// Set all fields to initial values.
inline void apm::FSsimfile_Init(apm::FSsimfile& ssimfile) {
    ssimfile.p_ctype = NULL;
    ssimfile.zd_ssimfile_rec_head = NULL; // (apm.FSsimfile.zd_ssimfile_rec)
    ssimfile.zd_ssimfile_rec_n = 0; // (apm.FSsimfile.zd_ssimfile_rec)
    ssimfile.zd_ssimfile_rec_tail = NULL; // (apm.FSsimfile.zd_ssimfile_rec)
    ssimfile.ind_ssimfile_next = (apm::FSsimfile*)-1; // (apm.FDb.ind_ssimfile) not-in-hash
}

// --- apm.FSsimfile.zd_ssimfile_rec_curs.Reset
// cursor points to valid item
inline void apm::ssimfile_zd_ssimfile_rec_curs_Reset(ssimfile_zd_ssimfile_rec_curs &curs, apm::FSsimfile &parent) {
    curs.row = parent.zd_ssimfile_rec_head;
}

// --- apm.FSsimfile.zd_ssimfile_rec_curs.ValidQ
// cursor points to valid item
inline bool apm::ssimfile_zd_ssimfile_rec_curs_ValidQ(ssimfile_zd_ssimfile_rec_curs &curs) {
    return curs.row != NULL;
}

// --- apm.FSsimfile.zd_ssimfile_rec_curs.Next
// proceed to next item
inline void apm::ssimfile_zd_ssimfile_rec_curs_Next(ssimfile_zd_ssimfile_rec_curs &curs) {
    apm::FRec *next = (*curs.row).zd_ssimfile_rec_next;
    curs.row = next;
}

// --- apm.FSsimfile.zd_ssimfile_rec_curs.Access
// item access
inline apm::FRec& apm::ssimfile_zd_ssimfile_rec_curs_Access(ssimfile_zd_ssimfile_rec_curs &curs) {
    return *curs.row;
}
inline apm::FSsimreq::FSsimreq() {
    apm::FSsimreq_Init(*this);
}

inline apm::FSsimreq::~FSsimreq() {
    apm::FSsimreq_Uninit(*this);
}

inline apm::FSubstr::FSubstr() {
    apm::FSubstr_Init(*this);
}

inline apm::FSubstr::~FSubstr() {
    apm::FSubstr_Uninit(*this);
}


// --- apm.FSubstr..Init
// Set all fields to initial values.
inline void apm::FSubstr_Init(apm::FSubstr& substr) {
    substr.p_srcfield = NULL;
}
inline apm::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline apm::FieldId::FieldId(apm_FieldIdEnum arg) { this->value = i32(arg); }
inline apm::FieldId::FieldId() {
    apm::FieldId_Init(*this);
}


// --- apm.FieldId.value.GetEnum
// Get value of field as enum type
inline apm_FieldIdEnum apm::value_GetEnum(const apm::FieldId& parent) {
    return apm_FieldIdEnum(parent.value);
}

// --- apm.FieldId.value.SetEnum
// Set value of field from enum type.
inline void apm::value_SetEnum(apm::FieldId& parent, apm_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- apm.FieldId.value.Cast
inline apm::FieldId::operator apm_FieldIdEnum () const {
    return apm_FieldIdEnum((*this).value);
}

// --- apm.FieldId..Init
// Set all fields to initial values.
inline void apm::FieldId_Init(apm::FieldId& parent) {
    parent.value = i32(-1);
}
inline apm::TableId::TableId(i32                            in_value)
    : value(in_value)
{
}
inline apm::TableId::TableId(apm_TableIdEnum arg) { this->value = i32(arg); }
inline apm::TableId::TableId() {
    apm::TableId_Init(*this);
}


// --- apm.TableId.value.GetEnum
// Get value of field as enum type
inline apm_TableIdEnum apm::value_GetEnum(const apm::TableId& parent) {
    return apm_TableIdEnum(parent.value);
}

// --- apm.TableId.value.SetEnum
// Set value of field from enum type.
inline void apm::value_SetEnum(apm::TableId& parent, apm_TableIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- apm.TableId.value.Cast
inline apm::TableId::operator apm_TableIdEnum () const {
    return apm_TableIdEnum((*this).value);
}

// --- apm.TableId..Init
// Set all fields to initial values.
inline void apm::TableId_Init(apm::TableId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const apm::trace &row) {// cfmt:apm.trace.String
    apm::trace_Print(const_cast<apm::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const apm::FMergefile &row) {// cfmt:apm.FMergefile.String
    apm::FMergefile_Print(const_cast<apm::FMergefile&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const apm::FieldId &row) {// cfmt:apm.FieldId.String
    apm::FieldId_Print(const_cast<apm::FieldId&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const apm::TableId &row) {// cfmt:apm.TableId.String
    apm::TableId_Print(const_cast<apm::TableId&>(row), str);
    return str;
}
