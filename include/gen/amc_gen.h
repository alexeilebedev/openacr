//
// include/gen/amc_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/amcdb_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/report_gen.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/dev_gen.h"
//#pragma endinclude

// --- amc_BltinIdEnum

enum amc_BltinIdEnum {             // amc.BltinId.value
     amc_BltinId_bool       = 0    // dflt is a c++ expr: real dflt is 'N'
    ,amc_BltinId_char       = 1    // char
    ,amc_BltinId_double     = 2    // double
    ,amc_BltinId_float      = 3    // float
    ,amc_BltinId_i16        = 4    // 16-bit   signed integer
    ,amc_BltinId_i32        = 5    // 32-bit   signed integer
    ,amc_BltinId_i64        = 6    // 64-bit   signed integer
    ,amc_BltinId_i8         = 7    // 8-bit   signed integer
    ,amc_BltinId_pad_byte   = 8
    ,amc_BltinId_u128       = 9    // 128-bit unsigned integer
    ,amc_BltinId_u16        = 10   // 16-bit unsigned integer
    ,amc_BltinId_u32        = 11   // 32-bit unsigned integer
    ,amc_BltinId_u64        = 12   // 64-bit unsigned integer
    ,amc_BltinId_u8         = 13   // 8-bit unsigned integer
};

enum { amc_BltinIdEnum_N = 14 };


// --- amc_CppkeywordIdEnum

enum amc_CppkeywordIdEnum {                    // amc.CppkeywordId.id
     amc_CppkeywordId_alignas            = 0
    ,amc_CppkeywordId_alignof            = 1
    ,amc_CppkeywordId_and                = 2
    ,amc_CppkeywordId_and_eq             = 3
    ,amc_CppkeywordId_asm                = 4
    ,amc_CppkeywordId_auto               = 5
    ,amc_CppkeywordId_bitand             = 6
    ,amc_CppkeywordId_bitor              = 7
    ,amc_CppkeywordId_bool               = 8
    ,amc_CppkeywordId_break              = 9
    ,amc_CppkeywordId_case               = 10
    ,amc_CppkeywordId_catch              = 11
    ,amc_CppkeywordId_char               = 12
    ,amc_CppkeywordId_char16_t           = 13
    ,amc_CppkeywordId_char32_t           = 14
    ,amc_CppkeywordId_class              = 15
    ,amc_CppkeywordId_compl              = 16
    ,amc_CppkeywordId_const              = 17
    ,amc_CppkeywordId_constexpr          = 18
    ,amc_CppkeywordId_const_cast         = 19
    ,amc_CppkeywordId_continue           = 20
    ,amc_CppkeywordId_decltype           = 21
    ,amc_CppkeywordId_default            = 22
    ,amc_CppkeywordId_delete             = 23
    ,amc_CppkeywordId_do                 = 24
    ,amc_CppkeywordId_double             = 25
    ,amc_CppkeywordId_dynamic_cast       = 26
    ,amc_CppkeywordId_else               = 27
    ,amc_CppkeywordId_enum               = 28
    ,amc_CppkeywordId_explicit           = 29
    ,amc_CppkeywordId_export             = 30
    ,amc_CppkeywordId_extern             = 31
    ,amc_CppkeywordId_false              = 32
    ,amc_CppkeywordId_float              = 33
    ,amc_CppkeywordId_for                = 34
    ,amc_CppkeywordId_friend             = 35
    ,amc_CppkeywordId_goto               = 36
    ,amc_CppkeywordId_if                 = 37
    ,amc_CppkeywordId_inline             = 38
    ,amc_CppkeywordId_int                = 39
    ,amc_CppkeywordId_long               = 40
    ,amc_CppkeywordId_mutable            = 41
    ,amc_CppkeywordId_namespace          = 42
    ,amc_CppkeywordId_new                = 43
    ,amc_CppkeywordId_noexcept           = 44
    ,amc_CppkeywordId_not                = 45
    ,amc_CppkeywordId_not_eq             = 46
    ,amc_CppkeywordId_nullptr            = 47
    ,amc_CppkeywordId_operator           = 48
    ,amc_CppkeywordId_or                 = 49
    ,amc_CppkeywordId_or_eq              = 50
    ,amc_CppkeywordId_private            = 51
    ,amc_CppkeywordId_protected          = 52
    ,amc_CppkeywordId_public             = 53
    ,amc_CppkeywordId_register           = 54
    ,amc_CppkeywordId_reinterpret_cast   = 55
    ,amc_CppkeywordId_return             = 56
    ,amc_CppkeywordId_short              = 57
    ,amc_CppkeywordId_signed             = 58
    ,amc_CppkeywordId_sizeof             = 59
    ,amc_CppkeywordId_static             = 60
    ,amc_CppkeywordId_static_assert      = 61
    ,amc_CppkeywordId_static_cast        = 62
    ,amc_CppkeywordId_struct             = 63
    ,amc_CppkeywordId_switch             = 64
    ,amc_CppkeywordId_template           = 65
    ,amc_CppkeywordId_this               = 66
    ,amc_CppkeywordId_thread_local       = 67
    ,amc_CppkeywordId_throw              = 68
    ,amc_CppkeywordId_true               = 69
    ,amc_CppkeywordId_try                = 70
    ,amc_CppkeywordId_typedef            = 71
    ,amc_CppkeywordId_typeid             = 72
    ,amc_CppkeywordId_typename           = 73
    ,amc_CppkeywordId_union              = 74
    ,amc_CppkeywordId_unsigned           = 75
    ,amc_CppkeywordId_using              = 76
    ,amc_CppkeywordId_virtual            = 77
    ,amc_CppkeywordId_void               = 78
    ,amc_CppkeywordId_volatile           = 79
    ,amc_CppkeywordId_wchar_t            = 80
    ,amc_CppkeywordId_while              = 81
    ,amc_CppkeywordId_xor                = 82
    ,amc_CppkeywordId_xor_eq             = 83
};

enum { amc_CppkeywordIdEnum_N = 84 };


// --- amc_FieldIdEnum

enum amc_FieldIdEnum {        // amc.FieldId.value
     amc_FieldId_value   = 0
    ,amc_FieldId_len     = 1
    ,amc_FieldId_str     = 2
};

enum { amc_FieldIdEnum_N = 3 };


// --- amc_TableIdEnum

enum amc_TableIdEnum {                        // amc.TableId.value
     amc_TableId_dmmeta_Anonfld        = 0    // dmmeta.Anonfld -> amc.FAnonfld
    ,amc_TableId_dmmeta_anonfld        = 0    // dmmeta.anonfld -> amc.FAnonfld
    ,amc_TableId_dmmeta_Argvtype       = 1    // dmmeta.Argvtype -> amc.FArgvtype
    ,amc_TableId_dmmeta_argvtype       = 1    // dmmeta.argvtype -> amc.FArgvtype
    ,amc_TableId_dmmeta_Basepool       = 2    // dmmeta.Basepool -> amc.FBasepool
    ,amc_TableId_dmmeta_basepool       = 2    // dmmeta.basepool -> amc.FBasepool
    ,amc_TableId_dmmeta_Bitfld         = 3    // dmmeta.Bitfld -> amc.FBitfld
    ,amc_TableId_dmmeta_bitfld         = 3    // dmmeta.bitfld -> amc.FBitfld
    ,amc_TableId_amcdb_Bltin           = 4    // amcdb.Bltin -> amc.FBltin
    ,amc_TableId_amcdb_bltin           = 4    // amcdb.bltin -> amc.FBltin
    ,amc_TableId_dmmeta_Cafter         = 5    // dmmeta.Cafter -> amc.FCafter
    ,amc_TableId_dmmeta_cafter         = 5    // dmmeta.cafter -> amc.FCafter
    ,amc_TableId_dmmeta_Cascdel        = 6    // dmmeta.Cascdel -> amc.FCascdel
    ,amc_TableId_dmmeta_cascdel        = 6    // dmmeta.cascdel -> amc.FCascdel
    ,amc_TableId_dmmeta_Ccmp           = 7    // dmmeta.Ccmp -> amc.FCcmp
    ,amc_TableId_dmmeta_ccmp           = 7    // dmmeta.ccmp -> amc.FCcmp
    ,amc_TableId_dmmeta_Cdecl          = 8    // dmmeta.Cdecl -> amc.FCdecl
    ,amc_TableId_dmmeta_cdecl          = 8    // dmmeta.cdecl -> amc.FCdecl
    ,amc_TableId_dmmeta_Cdflt          = 9    // dmmeta.Cdflt -> amc.FCdflt
    ,amc_TableId_dmmeta_cdflt          = 9    // dmmeta.cdflt -> amc.FCdflt
    ,amc_TableId_dmmeta_Cextern        = 10   // dmmeta.Cextern -> amc.FCextern
    ,amc_TableId_dmmeta_cextern        = 10   // dmmeta.cextern -> amc.FCextern
    ,amc_TableId_dmmeta_Cfmt           = 11   // dmmeta.Cfmt -> amc.FCfmt
    ,amc_TableId_dmmeta_cfmt           = 11   // dmmeta.cfmt -> amc.FCfmt
    ,amc_TableId_dmmeta_Cget           = 12   // dmmeta.Cget -> amc.FCget
    ,amc_TableId_dmmeta_cget           = 12   // dmmeta.cget -> amc.FCget
    ,amc_TableId_dmmeta_Charset        = 13   // dmmeta.Charset -> amc.FCharset
    ,amc_TableId_dmmeta_charset        = 13   // dmmeta.charset -> amc.FCharset
    ,amc_TableId_dmmeta_Chash          = 14   // dmmeta.Chash -> amc.FChash
    ,amc_TableId_dmmeta_chash          = 14   // dmmeta.chash -> amc.FChash
    ,amc_TableId_dmmeta_Cppfunc        = 15   // dmmeta.Cppfunc -> amc.FCppfunc
    ,amc_TableId_dmmeta_cppfunc        = 15   // dmmeta.cppfunc -> amc.FCppfunc
    ,amc_TableId_dmmeta_Cpptype        = 16   // dmmeta.Cpptype -> amc.FCpptype
    ,amc_TableId_dmmeta_cpptype        = 16   // dmmeta.cpptype -> amc.FCpptype
    ,amc_TableId_dmmeta_Csize          = 17   // dmmeta.Csize -> amc.FCsize
    ,amc_TableId_dmmeta_csize          = 17   // dmmeta.csize -> amc.FCsize
    ,amc_TableId_dmmeta_Cstr           = 18   // dmmeta.Cstr -> amc.FCstr
    ,amc_TableId_dmmeta_cstr           = 18   // dmmeta.cstr -> amc.FCstr
    ,amc_TableId_dmmeta_Ctype          = 19   // dmmeta.Ctype -> amc.FCtype
    ,amc_TableId_dmmeta_ctype          = 19   // dmmeta.ctype -> amc.FCtype
    ,amc_TableId_dmmeta_Dispatch       = 20   // dmmeta.Dispatch -> amc.FDispatch
    ,amc_TableId_dmmeta_dispatch       = 20   // dmmeta.dispatch -> amc.FDispatch
    ,amc_TableId_dmmeta_DispatchMsg    = 21   // dmmeta.DispatchMsg -> amc.FDispatchmsg
    ,amc_TableId_dmmeta_dispatch_msg   = 21   // dmmeta.dispatch_msg -> amc.FDispatchmsg
    ,amc_TableId_dmmeta_Dispctx        = 22   // dmmeta.Dispctx -> amc.FDispctx
    ,amc_TableId_dmmeta_dispctx        = 22   // dmmeta.dispctx -> amc.FDispctx
    ,amc_TableId_dmmeta_Dispfilter     = 23   // dmmeta.Dispfilter -> amc.FDispfilter
    ,amc_TableId_dmmeta_dispfilter     = 23   // dmmeta.dispfilter -> amc.FDispfilter
    ,amc_TableId_dmmeta_Disptrace      = 24   // dmmeta.Disptrace -> amc.FDisptrace
    ,amc_TableId_dmmeta_disptrace      = 24   // dmmeta.disptrace -> amc.FDisptrace
    ,amc_TableId_dmmeta_Fbase          = 25   // dmmeta.Fbase -> amc.FFbase
    ,amc_TableId_dmmeta_fbase          = 25   // dmmeta.fbase -> amc.FFbase
    ,amc_TableId_dmmeta_Fbigend        = 26   // dmmeta.Fbigend -> amc.FFbigend
    ,amc_TableId_dmmeta_fbigend        = 26   // dmmeta.fbigend -> amc.FFbigend
    ,amc_TableId_dmmeta_Fbitset        = 27   // dmmeta.Fbitset -> amc.FFbitset
    ,amc_TableId_dmmeta_fbitset        = 27   // dmmeta.fbitset -> amc.FFbitset
    ,amc_TableId_dmmeta_Fbuf           = 28   // dmmeta.Fbuf -> amc.FFbuf
    ,amc_TableId_dmmeta_fbuf           = 28   // dmmeta.fbuf -> amc.FFbuf
    ,amc_TableId_dmmeta_Fcast          = 29   // dmmeta.Fcast -> amc.FFcast
    ,amc_TableId_dmmeta_fcast          = 29   // dmmeta.fcast -> amc.FFcast
    ,amc_TableId_dmmeta_Fcleanup       = 30   // dmmeta.Fcleanup -> amc.FFcleanup
    ,amc_TableId_dmmeta_fcleanup       = 30   // dmmeta.fcleanup -> amc.FFcleanup
    ,amc_TableId_dmmeta_Fcmap          = 31   // dmmeta.Fcmap -> amc.FFcmap
    ,amc_TableId_dmmeta_fcmap          = 31   // dmmeta.fcmap -> amc.FFcmap
    ,amc_TableId_dmmeta_Fcmdline       = 32   // dmmeta.Fcmdline -> amc.FFcmdline
    ,amc_TableId_dmmeta_fcmdline       = 32   // dmmeta.fcmdline -> amc.FFcmdline
    ,amc_TableId_dmmeta_Fcmp           = 33   // dmmeta.Fcmp -> amc.FFcmp
    ,amc_TableId_dmmeta_fcmp           = 33   // dmmeta.fcmp -> amc.FFcmp
    ,amc_TableId_dmmeta_Fcompact       = 34   // dmmeta.Fcompact -> amc.FFcompact
    ,amc_TableId_dmmeta_fcompact       = 34   // dmmeta.fcompact -> amc.FFcompact
    ,amc_TableId_dmmeta_Fconst         = 35   // dmmeta.Fconst -> amc.FFconst
    ,amc_TableId_dmmeta_fconst         = 35   // dmmeta.fconst -> amc.FFconst
    ,amc_TableId_dmmeta_Fcurs          = 36   // dmmeta.Fcurs -> amc.FFcurs
    ,amc_TableId_dmmeta_fcurs          = 36   // dmmeta.fcurs -> amc.FFcurs
    ,amc_TableId_dmmeta_Fdec           = 37   // dmmeta.Fdec -> amc.FFdec
    ,amc_TableId_dmmeta_fdec           = 37   // dmmeta.fdec -> amc.FFdec
    ,amc_TableId_dmmeta_Fdelay         = 38   // dmmeta.Fdelay -> amc.FFdelay
    ,amc_TableId_dmmeta_fdelay         = 38   // dmmeta.fdelay -> amc.FFdelay
    ,amc_TableId_dmmeta_Field          = 39   // dmmeta.Field -> amc.FField
    ,amc_TableId_dmmeta_field          = 39   // dmmeta.field -> amc.FField
    ,amc_TableId_dmmeta_Findrem        = 40   // dmmeta.Findrem -> amc.FFindrem
    ,amc_TableId_dmmeta_findrem        = 40   // dmmeta.findrem -> amc.FFindrem
    ,amc_TableId_dmmeta_Finput         = 41   // dmmeta.Finput -> amc.FFinput
    ,amc_TableId_dmmeta_finput         = 41   // dmmeta.finput -> amc.FFinput
    ,amc_TableId_dmmeta_Fldoffset      = 42   // dmmeta.Fldoffset -> amc.FFldoffset
    ,amc_TableId_dmmeta_fldoffset      = 42   // dmmeta.fldoffset -> amc.FFldoffset
    ,amc_TableId_dmmeta_Floadtuples    = 43   // dmmeta.Floadtuples -> amc.FFloadtuples
    ,amc_TableId_dmmeta_floadtuples    = 43   // dmmeta.floadtuples -> amc.FFloadtuples
    ,amc_TableId_dmmeta_Fnoremove      = 44   // dmmeta.Fnoremove -> amc.FFnoremove
    ,amc_TableId_dmmeta_fnoremove      = 44   // dmmeta.fnoremove -> amc.FFnoremove
    ,amc_TableId_dmmeta_Foutput        = 45   // dmmeta.Foutput -> amc.FFoutput
    ,amc_TableId_dmmeta_foutput        = 45   // dmmeta.foutput -> amc.FFoutput
    ,amc_TableId_dmmeta_Fprefix        = 46   // dmmeta.Fprefix -> amc.FFprefix
    ,amc_TableId_dmmeta_fprefix        = 46   // dmmeta.fprefix -> amc.FFprefix
    ,amc_TableId_dmmeta_Fregx          = 47   // dmmeta.Fregx -> amc.FFregx
    ,amc_TableId_dmmeta_fregx          = 47   // dmmeta.fregx -> amc.FFregx
    ,amc_TableId_dmmeta_Fsort          = 48   // dmmeta.Fsort -> amc.FFsort
    ,amc_TableId_dmmeta_fsort          = 48   // dmmeta.fsort -> amc.FFsort
    ,amc_TableId_dmmeta_Fstep          = 49   // dmmeta.Fstep -> amc.FFstep
    ,amc_TableId_dmmeta_fstep          = 49   // dmmeta.fstep -> amc.FFstep
    ,amc_TableId_dmmeta_Ftrace         = 50   // dmmeta.Ftrace -> amc.FFtrace
    ,amc_TableId_dmmeta_ftrace         = 50   // dmmeta.ftrace -> amc.FFtrace
    ,amc_TableId_dmmeta_Func           = 51   // dmmeta.Func -> amc.FFunc
    ,amc_TableId_dmmeta_Funique        = 52   // dmmeta.Funique -> amc.FFunique
    ,amc_TableId_dmmeta_funique        = 52   // dmmeta.funique -> amc.FFunique
    ,amc_TableId_dmmeta_Fwddecl        = 53   // dmmeta.Fwddecl -> amc.FFwddecl
    ,amc_TableId_dmmeta_fwddecl        = 53   // dmmeta.fwddecl -> amc.FFwddecl
    ,amc_TableId_dmmeta_Gconst         = 54   // dmmeta.Gconst -> amc.FGconst
    ,amc_TableId_dmmeta_gconst         = 54   // dmmeta.gconst -> amc.FGconst
    ,amc_TableId_dmmeta_Gstatic        = 55   // dmmeta.Gstatic -> amc.FGstatic
    ,amc_TableId_dmmeta_gstatic        = 55   // dmmeta.gstatic -> amc.FGstatic
    ,amc_TableId_dmmeta_Gsymbol        = 56   // dmmeta.Gsymbol -> amc.FGsymbol
    ,amc_TableId_dmmeta_gsymbol        = 56   // dmmeta.gsymbol -> amc.FGsymbol
    ,amc_TableId_dmmeta_Hook           = 57   // dmmeta.Hook -> amc.FHook
    ,amc_TableId_dmmeta_hook           = 57   // dmmeta.hook -> amc.FHook
    ,amc_TableId_dmmeta_Inlary         = 58   // dmmeta.Inlary -> amc.FInlary
    ,amc_TableId_dmmeta_inlary         = 58   // dmmeta.inlary -> amc.FInlary
    ,amc_TableId_dmmeta_Lenfld         = 59   // dmmeta.Lenfld -> amc.FLenfld
    ,amc_TableId_dmmeta_lenfld         = 59   // dmmeta.lenfld -> amc.FLenfld
    ,amc_TableId_dmmeta_Listtype       = 60   // dmmeta.Listtype -> amc.FListtype
    ,amc_TableId_dmmeta_listtype       = 60   // dmmeta.listtype -> amc.FListtype
    ,amc_TableId_dmmeta_Llist          = 61   // dmmeta.Llist -> amc.FLlist
    ,amc_TableId_dmmeta_llist          = 61   // dmmeta.llist -> amc.FLlist
    ,amc_TableId_dmmeta_Main           = 62   // dmmeta.Main -> amc.FMain
    ,amc_TableId_dmmeta_main           = 62   // dmmeta.main -> amc.FMain
    ,amc_TableId_dmmeta_Msgtype        = 63   // dmmeta.Msgtype -> amc.FMsgtype
    ,amc_TableId_dmmeta_msgtype        = 63   // dmmeta.msgtype -> amc.FMsgtype
    ,amc_TableId_dmmeta_Nocascdel      = 64   // dmmeta.Nocascdel -> amc.FNocascdel
    ,amc_TableId_dmmeta_nocascdel      = 64   // dmmeta.nocascdel -> amc.FNocascdel
    ,amc_TableId_dmmeta_Nossimfile     = 65   // dmmeta.Nossimfile -> amc.FNossimfile
    ,amc_TableId_dmmeta_nossimfile     = 65   // dmmeta.nossimfile -> amc.FNossimfile
    ,amc_TableId_dmmeta_Noxref         = 66   // dmmeta.Noxref -> amc.FNoxref
    ,amc_TableId_dmmeta_noxref         = 66   // dmmeta.noxref -> amc.FNoxref
    ,amc_TableId_dmmeta_Ns             = 67   // dmmeta.Ns -> amc.FNs
    ,amc_TableId_dmmeta_ns             = 67   // dmmeta.ns -> amc.FNs
    ,amc_TableId_dmmeta_Nsdb           = 68   // dmmeta.Nsdb -> amc.FNsdb
    ,amc_TableId_dmmeta_nsdb           = 68   // dmmeta.nsdb -> amc.FNsdb
    ,amc_TableId_dmmeta_Nsinclude      = 69   // dmmeta.Nsinclude -> amc.FNsinclude
    ,amc_TableId_dmmeta_nsinclude      = 69   // dmmeta.nsinclude -> amc.FNsinclude
    ,amc_TableId_dmmeta_Nsproto        = 70   // dmmeta.Nsproto -> amc.FNsproto
    ,amc_TableId_dmmeta_nsproto        = 70   // dmmeta.nsproto -> amc.FNsproto
    ,amc_TableId_dmmeta_Nsx            = 71   // dmmeta.Nsx -> amc.FNsx
    ,amc_TableId_dmmeta_nsx            = 71   // dmmeta.nsx -> amc.FNsx
    ,amc_TableId_dmmeta_Numstr         = 72   // dmmeta.Numstr -> amc.FNumstr
    ,amc_TableId_dmmeta_numstr         = 72   // dmmeta.numstr -> amc.FNumstr
    ,amc_TableId_dmmeta_Pack           = 73   // dmmeta.Pack -> amc.FPack
    ,amc_TableId_dmmeta_pack           = 73   // dmmeta.pack -> amc.FPack
    ,amc_TableId_dmmeta_Pmaskfld       = 74   // dmmeta.Pmaskfld -> amc.FPmaskfld
    ,amc_TableId_dmmeta_pmaskfld       = 74   // dmmeta.pmaskfld -> amc.FPmaskfld
    ,amc_TableId_dmmeta_Pnew           = 75   // dmmeta.Pnew -> amc.FPnew
    ,amc_TableId_dmmeta_pnew           = 75   // dmmeta.pnew -> amc.FPnew
    ,amc_TableId_dmmeta_Ptrary         = 76   // dmmeta.Ptrary -> amc.FPtrary
    ,amc_TableId_dmmeta_ptrary         = 76   // dmmeta.ptrary -> amc.FPtrary
    ,amc_TableId_dmmeta_Rowid          = 77   // dmmeta.Rowid -> amc.FRowid
    ,amc_TableId_dmmeta_rowid          = 77   // dmmeta.rowid -> amc.FRowid
    ,amc_TableId_dmmeta_Smallstr       = 78   // dmmeta.Smallstr -> amc.FSmallstr
    ,amc_TableId_dmmeta_smallstr       = 78   // dmmeta.smallstr -> amc.FSmallstr
    ,amc_TableId_dmmeta_Sortfld        = 79   // dmmeta.Sortfld -> amc.FSortfld
    ,amc_TableId_dmmeta_sortfld        = 79   // dmmeta.sortfld -> amc.FSortfld
    ,amc_TableId_dmmeta_Ssimfile       = 80   // dmmeta.Ssimfile -> amc.FSsimfile
    ,amc_TableId_dmmeta_ssimfile       = 80   // dmmeta.ssimfile -> amc.FSsimfile
    ,amc_TableId_dmmeta_Ssimvolatile   = 81   // dmmeta.Ssimvolatile -> amc.FSsimvolatile
    ,amc_TableId_dmmeta_ssimvolatile   = 81   // dmmeta.ssimvolatile -> amc.FSsimvolatile
    ,amc_TableId_dmmeta_Substr         = 82   // dmmeta.Substr -> amc.FSubstr
    ,amc_TableId_dmmeta_substr         = 82   // dmmeta.substr -> amc.FSubstr
    ,amc_TableId_dev_Targdep           = 83   // dev.Targdep -> amc.FTargdep
    ,amc_TableId_dev_targdep           = 83   // dev.targdep -> amc.FTargdep
    ,amc_TableId_dev_Target            = 84   // dev.Target -> amc.FTarget
    ,amc_TableId_dev_target            = 84   // dev.target -> amc.FTarget
    ,amc_TableId_dmmeta_Tary           = 85   // dmmeta.Tary -> amc.FTary
    ,amc_TableId_dmmeta_tary           = 85   // dmmeta.tary -> amc.FTary
    ,amc_TableId_amcdb_Tcursor         = 86   // amcdb.Tcursor -> amc.FTcursor
    ,amc_TableId_amcdb_tcursor         = 86   // amcdb.tcursor -> amc.FTcursor
    ,amc_TableId_dmmeta_Thash          = 87   // dmmeta.Thash -> amc.FThash
    ,amc_TableId_dmmeta_thash          = 87   // dmmeta.thash -> amc.FThash
    ,amc_TableId_dmmeta_Typefld        = 88   // dmmeta.Typefld -> amc.FTypefld
    ,amc_TableId_dmmeta_typefld        = 88   // dmmeta.typefld -> amc.FTypefld
    ,amc_TableId_dmmeta_Usertracefld   = 89   // dmmeta.Usertracefld -> amc.FUsertracefld
    ,amc_TableId_dmmeta_usertracefld   = 89   // dmmeta.usertracefld -> amc.FUsertracefld
    ,amc_TableId_dmmeta_Xref           = 90   // dmmeta.Xref -> amc.FXref
    ,amc_TableId_dmmeta_xref           = 90   // dmmeta.xref -> amc.FXref
};

enum { amc_TableIdEnum_N = 181 };

namespace dmmeta { struct Anonfld; }
namespace dmmeta { struct Argvtype; }
namespace dmmeta { struct Basepool; }
namespace amc { struct FField; }
namespace dmmeta { struct Bitfld; }
namespace amcdb { struct Bltin; }
namespace dmmeta { struct Cafter; }
namespace amc { struct FCtype; }
namespace dmmeta { struct Cascdel; }
namespace dmmeta { struct Ccmp; }
namespace dmmeta { struct Cdecl; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cextern; }
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cget; }
namespace dmmeta { struct Charset; }
namespace dmmeta { struct Chash; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Csize; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace amc { struct FNs; }
namespace dmmeta { struct Ctypelen; }
namespace dmmeta { struct Dispatch; }
namespace dmmeta { struct DispatchMsg; }
namespace amc { struct FDispatch; }
namespace dmmeta { struct Dispctx; }
namespace dmmeta { struct Dispfilter; }
namespace dmmeta { struct Dispsig; }
namespace dmmeta { struct Disptrace; }
namespace dmmeta { struct Fbase; }
namespace dmmeta { struct Fbigend; }
namespace dmmeta { struct Fbitset; }
namespace dmmeta { struct Fbuf; }
namespace dmmeta { struct Fcast; }
namespace dmmeta { struct Fcleanup; }
namespace dmmeta { struct Fcmap; }
namespace dmmeta { struct Fcmdline; }
namespace dmmeta { struct Fcmp; }
namespace dmmeta { struct Fcompact; }
namespace dmmeta { struct Fconst; }
namespace dmmeta { struct Fcurs; }
namespace dmmeta { struct Fdec; }
namespace dmmeta { struct Fdelay; }
namespace dmmeta { struct Field; }
namespace amc { struct FReftype; }
namespace dmmeta { struct Findrem; }
namespace dmmeta { struct Finput; }
namespace dmmeta { struct Fldoffset; }
namespace dmmeta { struct Floadtuples; }
namespace dmmeta { struct Fnoremove; }
namespace dmmeta { struct Foutput; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Fregx; }
namespace dmmeta { struct Fsort; }
namespace dmmeta { struct Fstep; }
namespace dmmeta { struct Ftrace; }
namespace dmmeta { struct Func; }
namespace dmmeta { struct Funique; }
namespace dmmeta { struct Fwddecl; }
namespace dmmeta { struct Gconst; }
namespace amcdb { struct Gen; }
namespace dmmeta { struct Gstatic; }
namespace dmmeta { struct Gsymbol; }
namespace dmmeta { struct Hook; }
namespace dmmeta { struct Inlary; }
namespace dmmeta { struct Lenfld; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Llist; }
namespace amc { struct FListtype; }
namespace dmmeta { struct Main; }
namespace dmmeta { struct Msgtype; }
namespace dmmeta { struct Nocascdel; }
namespace dmmeta { struct Nossimfile; }
namespace dmmeta { struct Noxref; }
namespace dmmeta { struct Ns; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Nsinclude; }
namespace dmmeta { struct Nsproto; }
namespace dmmeta { struct Nsx; }
namespace dmmeta { struct Numstr; }
namespace dmmeta { struct Pack; }
namespace dmmeta { struct Pmaskfld; }
namespace dmmeta { struct Pnew; }
namespace dmmeta { struct Ptrary; }
namespace dmmeta { struct Reftype; }
namespace amc { struct FTclass; }
namespace dmmeta { struct Rowid; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Sortfld; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimvolatile; }
namespace dmmeta { struct Substr; }
namespace dev { struct Targdep; }
namespace amc { struct FTarget; }
namespace dev { struct Target; }
namespace dmmeta { struct Tary; }
namespace amcdb { struct Tclass; }
namespace amcdb { struct Tcursor; }
namespace amcdb { struct Tfunc; }
namespace dmmeta { struct Thash; }
namespace dmmeta { struct Tracefld; }
namespace dmmeta { struct Tracerec; }
namespace dmmeta { struct Typefld; }
namespace dmmeta { struct Usertracefld; }
namespace dmmeta { struct Xref; }
namespace amc { struct FTfunc; }
namespace amc { struct FFunc; }
namespace amc { struct BltinId; }
namespace amc { struct CppkeywordId; }
namespace amc { struct Enumstr; }
namespace amc { struct FAnonfld; }
namespace amc { struct FArgvtype; }
namespace amc { struct FBasepool; }
namespace amc { struct FBitfld; }
namespace amc { struct FBltin; }
namespace amc { struct FCafter; }
namespace amc { struct FCascdel; }
namespace amc { struct FCcmp; }
namespace amc { struct FCdecl; }
namespace amc { struct FCdflt; }
namespace amc { struct FCextern; }
namespace amc { struct FCfmt; }
namespace amc { struct FCget; }
namespace amc { struct FCharset; }
namespace amc { struct FChash; }
namespace amc { struct FCppfunc; }
namespace amc { struct FCpptype; }
namespace amc { struct FCsize; }
namespace amc { struct FCstr; }
namespace amc { struct FCtypelen; }
namespace amc { struct Genfield; }
namespace amc { struct trace; }
namespace amc { struct FDb; }
namespace amc { struct FDispatchmsg; }
namespace amc { struct FDispctx; }
namespace amc { struct FDispfilter; }
namespace amc { struct FDispsig; }
namespace amc { struct FDisptrace; }
namespace amc { struct FEnumstr; }
namespace amc { struct FEnumstrLen; }
namespace amc { struct FFbase; }
namespace amc { struct FFbigend; }
namespace amc { struct FFbitset; }
namespace amc { struct FFbuf; }
namespace amc { struct FFcast; }
namespace amc { struct FFcleanup; }
namespace amc { struct FFcmap; }
namespace amc { struct FFcmdline; }
namespace amc { struct FFcmp; }
namespace amc { struct FFcompact; }
namespace amc { struct FFconst; }
namespace amc { struct FFcurs; }
namespace amc { struct FFdec; }
namespace amc { struct FFdelay; }
namespace amc { struct FFindrem; }
namespace amc { struct FFinput; }
namespace amc { struct FFldoffset; }
namespace amc { struct FFloadtuples; }
namespace amc { struct FFnoremove; }
namespace amc { struct FFoutput; }
namespace amc { struct FFprefix; }
namespace amc { struct FFregx; }
namespace amc { struct FFsort; }
namespace amc { struct FFstep; }
namespace amc { struct FFtrace; }
namespace amc { struct FFunique; }
namespace amc { struct FFwddecl; }
namespace amc { struct FGconst; }
namespace amc { struct FGen; }
namespace amc { struct FGenXref; }
namespace amc { struct FGenXrefSeen; }
namespace amc { struct FGstatic; }
namespace amc { struct FGsymbol; }
namespace amc { struct FHook; }
namespace amc { struct FInlary; }
namespace amc { struct FLenfld; }
namespace amc { struct FLlist; }
namespace amc { struct FMain; }
namespace amc { struct FMsgtype; }
namespace amc { struct FNocascdel; }
namespace amc { struct FNossimfile; }
namespace amc { struct FNoxref; }
namespace amc { struct FNsdb; }
namespace amc { struct FNsinclude; }
namespace amc { struct FNsproto; }
namespace amc { struct FNsx; }
namespace amc { struct FNumstr; }
namespace amc { struct FOutfile; }
namespace amc { struct FPack; }
namespace amc { struct FPmaskfld; }
namespace amc { struct FPnew; }
namespace amc { struct FPtrary; }
namespace amc { struct FRowid; }
namespace amc { struct FSmallstr; }
namespace amc { struct FSortfld; }
namespace amc { struct FSsimfile; }
namespace amc { struct FSsimvolatile; }
namespace amc { struct FStatictuple; }
namespace amc { struct FSubstr; }
namespace amc { struct FTargdep; }
namespace amc { struct FTary; }
namespace amc { struct FTcursor; }
namespace amc { struct FThash; }
namespace amc { struct FTracefld; }
namespace amc { struct FTracerec; }
namespace amc { struct FTypefld; }
namespace amc { struct FUsertracefld; }
namespace amc { struct FXref; }
namespace amc { struct FieldId; }
namespace amc { struct Funcarg; }
namespace amc { struct Genpnew; }
namespace amc { struct TableId; }
namespace amc { struct ctype_zs_cfmt_curs; }
namespace amc { struct ctype_c_field_curs; }
namespace amc { struct ctype_c_static_curs; }
namespace amc { struct ctype_c_parent_curs; }
namespace amc { struct ctype_c_datafld_curs; }
namespace amc { struct ctype_zd_inst_curs; }
namespace amc { struct ctype_zs_xref_curs; }
namespace amc { struct ctype_c_ffunc_curs; }
namespace amc { struct ctype_zd_cafter_curs; }
namespace amc { struct ctype_zd_access_curs; }
namespace amc { struct ctype_c_fcurs_curs; }
namespace amc { struct ctype_c_cdecl_curs; }
namespace amc { struct tclass_c_tfunc_curs; }
namespace amc { struct _db_fsort_curs; }
namespace amc { struct _db_ind_cfmt_curs; }
namespace amc { struct _db_dispfilter_curs; }
namespace amc { struct _db_usertracefld_curs; }
namespace amc { struct _db_cfmt_curs; }
namespace amc { struct _db_dispatch_curs; }
namespace amc { struct _db_dispatch_msg_curs; }
namespace amc { struct _db_ctype_curs; }
namespace amc { struct _db_field_curs; }
namespace amc { struct _db_basepool_curs; }
namespace amc { struct _db_llist_curs; }
namespace amc { struct _db_anonfld_curs; }
namespace amc { struct _db_xref_curs; }
namespace amc { struct _db_ns_curs; }
namespace amc { struct _db_pnew_curs; }
namespace amc { struct _db_fldoffset_curs; }
namespace amc { struct _db_typefld_curs; }
namespace amc { struct _db_lenfld_curs; }
namespace amc { struct _db_bltin_curs; }
namespace amc { struct _db_static_tuple_curs; }
namespace amc { struct _db_msgtype_curs; }
namespace amc { struct _db_gconst_curs; }
namespace amc { struct _db_gstatic_curs; }
namespace amc { struct _db_thash_curs; }
namespace amc { struct _db_func_curs; }
namespace amc { struct _db_smallstr_curs; }
namespace amc { struct _db_numstr_curs; }
namespace amc { struct _db_main_curs; }
namespace amc { struct _db_reftype_curs; }
namespace amc { struct _db_ind_bltin_curs; }
namespace amc { struct _db_ind_ctype_curs; }
namespace amc { struct _db_ind_dispatch_curs; }
namespace amc { struct _db_ind_func_curs; }
namespace amc { struct _db_ind_field_curs; }
namespace amc { struct _db_ind_ns_curs; }
namespace amc { struct _db_ind_pnew_curs; }
namespace amc { struct _db_ind_xref_curs; }
namespace amc { struct _db_cpptype_curs; }
namespace amc { struct _db_ind_cpptype_curs; }
namespace amc { struct _db_inlary_curs; }
namespace amc { struct _db_ind_inlary_curs; }
namespace amc { struct _db_tary_curs; }
namespace amc { struct _db_ind_tary_curs; }
namespace amc { struct _db_cppfunc_curs; }
namespace amc { struct _db_rowid_curs; }
namespace amc { struct _db_ind_rowid_curs; }
namespace amc { struct _db_cascdel_curs; }
namespace amc { struct _db_substr_curs; }
namespace amc { struct _db_bitfld_curs; }
namespace amc { struct _db_ssimfile_curs; }
namespace amc { struct _db_ind_ssimfile_curs; }
namespace amc { struct _db_pack_curs; }
namespace amc { struct _db_ind_pack_curs; }
namespace amc { struct _db_ind_smallstr_curs; }
namespace amc { struct _db_ptrary_curs; }
namespace amc { struct _db_c_ctype_sorted_curs; }
namespace amc { struct _db_enumstr_curs; }
namespace amc { struct _db_enumstr_len_curs; }
namespace amc { struct _db_bh_enumstr_len_curs; }
namespace amc { struct _db_bh_enumstr_len_unordcurs; }
namespace amc { struct _db_ind_enumstr_len_curs; }
namespace amc { struct _db_ind_enumstr_curs; }
namespace amc { struct _db_fbitset_curs; }
namespace amc { struct _db_ind_fbitset_curs; }
namespace amc { struct _db_fcleanup_curs; }
namespace amc { struct _db_fdec_curs; }
namespace amc { struct _db_ind_fdec_curs; }
namespace amc { struct _db_ind_reftype_curs; }
namespace amc { struct _db_fconst_curs; }
namespace amc { struct _db_ind_fconst_curs; }
namespace amc { struct _db_c_ns_sorted_curs; }
namespace amc { struct _db_finput_curs; }
namespace amc { struct _db_foutput_curs; }
namespace amc { struct _db_fbuf_curs; }
namespace amc { struct _db_ind_fbuf_curs; }
namespace amc { struct _db_chash_curs; }
namespace amc { struct _db_ind_chash_curs; }
namespace amc { struct _db_ccmp_curs; }
namespace amc { struct _db_ind_ccmp_curs; }
namespace amc { struct _db_fbigend_curs; }
namespace amc { struct _db_zsl_ctype_pack_tran_curs; }
namespace amc { struct _db_cstr_curs; }
namespace amc { struct _db_listtype_curs; }
namespace amc { struct _db_ind_listtype_curs; }
namespace amc { struct _db_fstep_curs; }
namespace amc { struct _db_cextern_curs; }
namespace amc { struct _db_fdelay_curs; }
namespace amc { struct _db_disptrace_curs; }
namespace amc { struct _db_ind_fstep_curs; }
namespace amc { struct _db_tracefld_curs; }
namespace amc { struct _db_tracerec_curs; }
namespace amc { struct _db_dispsig_curs; }
namespace amc { struct _db_c_dispsig_sorted_curs; }
namespace amc { struct _db_zs_sig_visit_curs; }
namespace amc { struct _db_target_curs; }
namespace amc { struct _db_ind_target_curs; }
namespace amc { struct _db_targdep_curs; }
namespace amc { struct _db_dispctx_curs; }
namespace amc { struct _db_pmaskfld_curs; }
namespace amc { struct _db_fwddecl_curs; }
namespace amc { struct _db_ind_fwddecl_curs; }
namespace amc { struct _db_tfunc_curs; }
namespace amc { struct _db_ind_tfunc_curs; }
namespace amc { struct _db_gen_curs; }
namespace amc { struct _db_fregx_curs; }
namespace amc { struct _db_tclass_curs; }
namespace amc { struct _db_ind_tclass_curs; }
namespace amc { struct _db_fcmp_curs; }
namespace amc { struct _db_fcast_curs; }
namespace amc { struct _db_noxref_curs; }
namespace amc { struct _db_nocascdel_curs; }
namespace amc { struct _db_cafter_curs; }
namespace amc { struct _db_csize_curs; }
namespace amc { struct _db_nsx_curs; }
namespace amc { struct _db_fcompact_curs; }
namespace amc { struct _db_findrem_curs; }
namespace amc { struct _db_tcursor_curs; }
namespace amc { struct _db_fcurs_curs; }
namespace amc { struct _db_cdflt_curs; }
namespace amc { struct _db_argvtype_curs; }
namespace amc { struct _db_fcmdline_curs; }
namespace amc { struct _db_ind_main_curs; }
namespace amc { struct _db_floadtuples_curs; }
namespace amc { struct _db_fcmap_curs; }
namespace amc { struct _db_zs_ordkeyfield_curs; }
namespace amc { struct _db_nsproto_curs; }
namespace amc { struct _db_nsdb_curs; }
namespace amc { struct _db_zd_substr_params_curs; }
namespace amc { struct _db_ind_fconst_int_curs; }
namespace amc { struct _db_fprefix_curs; }
namespace amc { struct _db_ind_prefix_curs; }
namespace amc { struct _db_ftrace_curs; }
namespace amc { struct _db_fnoremove_curs; }
namespace amc { struct _db_c_substr_field_curs; }
namespace amc { struct _db_ctypelen_curs; }
namespace amc { struct _db_c_ctypelen_curs; }
namespace amc { struct _db_c_tempfield_curs; }
namespace amc { struct _db_fbase_curs; }
namespace amc { struct _db_ind_fcmap_curs; }
namespace amc { struct _db_nossimfile_curs; }
namespace amc { struct _db_gsymbol_curs; }
namespace amc { struct _db_sortfld_curs; }
namespace amc { struct _db_cget_curs; }
namespace amc { struct _db_cd_temp_func_curs; }
namespace amc { struct _db_cdecl_curs; }
namespace amc { struct _db_zs_gen_perns_curs; }
namespace amc { struct _db_hook_curs; }
namespace amc { struct _db_charset_curs; }
namespace amc { struct _db_nsinclude_curs; }
namespace amc { struct _db_ssimvolatile_curs; }
namespace amc { struct _db_funique_curs; }
namespace amc { struct dispatch_c_dispatch_msg_curs; }
namespace amc { struct enumstr_c_fconst_curs; }
namespace amc { struct enumstr_len_bh_enumstr_curs; }
namespace amc { struct enumstr_len_bh_enumstr_unordcurs; }
namespace amc { struct field_c_ffunc_curs; }
namespace amc { struct field_c_fconst_curs; }
namespace amc { struct field_zd_xref_keyfld_curs; }
namespace amc { struct field_zs_fcmap_curs; }
namespace amc { struct field_bh_bitfld_curs; }
namespace amc { struct field_bh_bitfld_unordcurs; }
namespace amc { struct func_funcarg_curs; }
namespace amc { struct FGenXref_ind_seen_curs; }
namespace amc { struct FGenXref_seen_curs; }
namespace amc { struct ns_c_ctype_curs; }
namespace amc { struct ns_c_func_curs; }
namespace amc { struct ns_c_dispatch_curs; }
namespace amc { struct ns_c_gstatic_curs; }
namespace amc { struct ns_include_curs; }
namespace amc { struct ns_c_ctype_ins_curs; }
namespace amc { struct ns_c_dispsig_curs; }
namespace amc { struct ns_c_parentns_curs; }
namespace amc { struct ns_c_cppincl_curs; }
namespace amc { struct ns_c_hdrincl_curs; }
namespace amc { struct ns_c_fwddecl_curs; }
namespace amc { struct ns_c_pnew_curs; }
namespace amc { struct ns_c_outfile_curs; }
namespace amc { struct ns_c_finput_curs; }
namespace amc { struct ns_c_foutput_curs; }
namespace amc { struct ns_c_fstep_curs; }
namespace amc { struct ns_c_gsymbol_curs; }
namespace amc { struct ns_c_nsinclude_curs; }
namespace amc { struct reftype_zs_fprefix_curs; }
namespace amc { struct target_c_targdep_curs; }
namespace amc {
}//pkey typedefs
namespace amc {
typedef void (*tclass_step_hook)();
struct lpool_Lpblock {
    lpool_Lpblock* next;
};
extern const char *amc_help;
extern const char *amc_syntax;
extern FDb _db;
typedef void (*gen_step_hook)();
typedef void (*tfunc_step_hook)();

// --- amc.BltinId
struct BltinId { // amc.BltinId
    u8   value;   //   0
    inline operator amc_BltinIdEnum() const;
    explicit BltinId(u8                             in_value);
    BltinId(amc_BltinIdEnum arg);
    BltinId();
};

// Get value of field as enum type
amc_BltinIdEnum      value_GetEnum(const amc::BltinId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(amc::BltinId& parent, amc_BltinIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const amc::BltinId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const amc::BltinId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(amc::BltinId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(amc::BltinId& parent, algo::strptr rhs, amc_BltinIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(amc::BltinId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::BltinId from an ascii string.
// The format of the string is the format of the amc::BltinId's only field
bool                 BltinId_ReadStrptrMaybe(amc::BltinId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 BltinId_Init(amc::BltinId& parent);
// print string representation of amc::BltinId to string LHS, no header -- cprint:amc.BltinId.String
void                 BltinId_Print(amc::BltinId row, algo::cstring &str) __attribute__((nothrow));

// --- amc.CppkeywordId
struct CppkeywordId { // amc.CppkeywordId
    u32   id;   //   0
    CppkeywordId();
};

// Get value of field as enum type
amc_CppkeywordIdEnum id_GetEnum(const amc::CppkeywordId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 id_SetEnum(amc::CppkeywordId& parent, amc_CppkeywordIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          id_ToCstr(const amc::CppkeywordId& parent) __attribute__((nothrow));
// Convert id to a string. First, attempt conversion to a known string.
// If no string matches, print id as a numeric value.
void                 id_Print(const amc::CppkeywordId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 id_SetStrptrMaybe(amc::CppkeywordId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 id_SetStrptr(amc::CppkeywordId& parent, algo::strptr rhs, amc_CppkeywordIdEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
void                 CppkeywordId_Init(amc::CppkeywordId& parent);

// --- amc.Enumstr
struct Enumstr { // amc.Enumstr: Key
    i32               len;   //   0
    algo::RnullStr8   str;   //
    explicit Enumstr(i32                            in_len
        ,const algo::strptr&            in_str);
    bool operator ==(const amc::Enumstr &rhs) const;
    bool operator <(const amc::Enumstr &rhs) const;
    Enumstr();
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
bool                 str_Lt(amc::Enumstr& parent, amc::Enumstr &rhs) __attribute__((nothrow));
// Compare two fields.
i32                  str_Cmp(amc::Enumstr& parent, amc::Enumstr &rhs) __attribute__((nothrow));

u32                  Enumstr_Hash(u32 prev, const amc::Enumstr & rhs) __attribute__((nothrow));
bool                 Enumstr_ReadFieldMaybe(amc::Enumstr &parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of amc::Enumstr from an ascii string.
// The format of the string is an ssim Tuple
bool                 Enumstr_ReadStrptrMaybe(amc::Enumstr &parent, algo::strptr in_str);
bool                 Enumstr_Lt(amc::Enumstr & lhs, amc::Enumstr & rhs) __attribute__((nothrow));
i32                  Enumstr_Cmp(amc::Enumstr & lhs, amc::Enumstr & rhs) __attribute__((nothrow));
// Set all fields to initial values.
void                 Enumstr_Init(amc::Enumstr& parent);
bool                 Enumstr_Eq(const amc::Enumstr & lhs,const amc::Enumstr & rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
bool                 Enumstr_Update(amc::Enumstr &lhs, amc::Enumstr & rhs) __attribute__((nothrow));
// print string representation of amc::Enumstr to string LHS, no header -- cprint:amc.Enumstr.String
void                 Enumstr_Print(amc::Enumstr & row, algo::cstring &str) __attribute__((nothrow));

// --- amc.FAnonfld
// create: amc.FDb.anonfld (Lary)
// access: amc.FField.c_anonfld (Ptr)
struct FAnonfld { // amc.FAnonfld
    algo::Smallstr100   field;      //
    i32                 anon_idx;   //   0  Index of anonymous field (if any)
private:
    friend amc::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 anonfld_RemoveLast() __attribute__((nothrow));
    FAnonfld();
    ~FAnonfld();
    FAnonfld(const FAnonfld&){ /*disallow copy constructor */}
    void operator =(const FAnonfld&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 anonfld_CopyIn(amc::FAnonfld &row, dmmeta::Anonfld &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FAnonfld_Init(amc::FAnonfld& anonfld);
void                 FAnonfld_Uninit(amc::FAnonfld& anonfld) __attribute__((nothrow));

// --- amc.FArgvtype
// create: amc.FDb.argvtype (Lary)
// access: amc.FCtype.c_argvtype (Ptr)
struct FArgvtype { // amc.FArgvtype
    algo::Smallstr50   ctype;      //
    algo::Smallstr50   argvtype;   //
    algo::Comment      comment;    //
private:
    friend amc::FArgvtype&      argvtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FArgvtype*      argvtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 argvtype_RemoveLast() __attribute__((nothrow));
    FArgvtype();
    ~FArgvtype();
    FArgvtype(const FArgvtype&){ /*disallow copy constructor */}
    void operator =(const FArgvtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 argvtype_CopyOut(amc::FArgvtype &row, dmmeta::Argvtype &out) __attribute__((nothrow));
// Copy fields in to row
void                 argvtype_CopyIn(amc::FArgvtype &row, dmmeta::Argvtype &in) __attribute__((nothrow));

void                 FArgvtype_Uninit(amc::FArgvtype& argvtype) __attribute__((nothrow));

// --- amc.FBasepool
// create: amc.FDb.basepool (Lary)
// access: amc.FField.c_basepool (Ptr)
struct FBasepool { // amc.FBasepool
    algo::Smallstr100   field;     //
    algo::Smallstr100   base;      //
    amc::FField*        p_field;   // reference to parent row
    amc::FField*        p_base;    // reference to parent row
private:
    friend amc::FBasepool&      basepool_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FBasepool*      basepool_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 basepool_RemoveLast() __attribute__((nothrow));
    FBasepool();
    ~FBasepool();
    FBasepool(const FBasepool&){ /*disallow copy constructor */}
    void operator =(const FBasepool&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 basepool_CopyIn(amc::FBasepool &row, dmmeta::Basepool &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FBasepool_Init(amc::FBasepool& basepool);
void                 FBasepool_Uninit(amc::FBasepool& basepool) __attribute__((nothrow));

// --- amc.FBitfld
// create: amc.FDb.bitfld (Lary)
// access: amc.FField.c_bitfld (Ptr)
// access: amc.FField.bh_bitfld (Bheap)
struct FBitfld { // amc.FBitfld
    algo::Smallstr100   field;           //
    i32                 offset;          //   0  Offset, in bits, within parent field
    i32                 width;           //   0  Width, in bits, within parent field.
    algo::Smallstr100   srcfield;        //
    amc::FField*        p_srcfield;      // reference to parent row
    i32                 bh_bitfld_idx;   // index in heap; -1 means not-in-heap
private:
    friend amc::FBitfld&        bitfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FBitfld*        bitfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 bitfld_RemoveLast() __attribute__((nothrow));
    FBitfld();
    ~FBitfld();
    FBitfld(const FBitfld&){ /*disallow copy constructor */}
    void operator =(const FBitfld&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 bitfld_CopyIn(amc::FBitfld &row, dmmeta::Bitfld &in) __attribute__((nothrow));

algo::Smallstr50     name_Get(amc::FBitfld& bitfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FBitfld_Init(amc::FBitfld& bitfld);
void                 FBitfld_Uninit(amc::FBitfld& bitfld) __attribute__((nothrow));

// --- amc.FBltin
// create: amc.FDb.bltin (Lary)
// global access: ind_bltin (Thash)
// access: amc.FCtype.c_bltin (Ptr)
struct FBltin { // amc.FBltin
    algo::Smallstr50   ctype;            //
    bool               likeu64;          //   false
    bool               bigendok;         //   false
    bool               issigned;         //   false
    amc::FBltin*       ind_bltin_next;   // hash next
private:
    friend amc::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 bltin_RemoveLast() __attribute__((nothrow));
    FBltin();
    ~FBltin();
    FBltin(const FBltin&){ /*disallow copy constructor */}
    void operator =(const FBltin&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 bltin_CopyIn(amc::FBltin &row, amcdb::Bltin &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FBltin_Init(amc::FBltin& bltin);
void                 FBltin_Uninit(amc::FBltin& bltin) __attribute__((nothrow));

// --- amc.FCafter
// create: amc.FDb.cafter (Lary)
// access: amc.FCtype.zd_cafter (Llist)
struct FCafter { // amc.FCafter
    algo::Smallstr50   cafter;           //
    amc::FCtype*       p_after;          // reference to parent row
    amc::FCafter*      zd_cafter_next;   // zslist link; -1 means not-in-list
    amc::FCafter*      zd_cafter_prev;   // previous element
private:
    friend amc::FCafter&        cafter_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCafter*        cafter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cafter_RemoveLast() __attribute__((nothrow));
    FCafter();
    ~FCafter();
    FCafter(const FCafter&){ /*disallow copy constructor */}
    void operator =(const FCafter&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 cafter_CopyIn(amc::FCafter &row, dmmeta::Cafter &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FCafter& cafter) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     after_Get(amc::FCafter& cafter) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FCafter_Init(amc::FCafter& cafter);
void                 FCafter_Uninit(amc::FCafter& cafter) __attribute__((nothrow));

// --- amc.FCascdel
// create: amc.FDb.cascdel (Lary)
// access: amc.FField.c_cascdel (Ptr)
struct FCascdel { // amc.FCascdel
    algo::Smallstr100   field;     //
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FCascdel&       cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCascdel*       cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cascdel_RemoveLast() __attribute__((nothrow));
    FCascdel();
    ~FCascdel();
    FCascdel(const FCascdel&){ /*disallow copy constructor */}
    void operator =(const FCascdel&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 cascdel_CopyIn(amc::FCascdel &row, dmmeta::Cascdel &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCascdel_Init(amc::FCascdel& cascdel);
void                 FCascdel_Uninit(amc::FCascdel& cascdel) __attribute__((nothrow));

// --- amc.FCcmp
// create: amc.FDb.ccmp (Lary)
// global access: ind_ccmp (Thash)
// access: amc.FCtype.c_ccmp (Ptr)
struct FCcmp { // amc.FCcmp
    algo::Smallstr50   ctype;           // Target ctype
    bool               extrn;           //   false  Whether implementation is external
    bool               genop;           //   false  Generate C++ comparison operators (<,>, etc)
    bool               order;           //   false
    bool               minmax;          //   false
    amc::FCcmp*        ind_ccmp_next;   // hash next
private:
    friend amc::FCcmp&          ccmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCcmp*          ccmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ccmp_RemoveLast() __attribute__((nothrow));
    FCcmp();
    ~FCcmp();
    FCcmp(const FCcmp&){ /*disallow copy constructor */}
    void operator =(const FCcmp&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 ccmp_CopyIn(amc::FCcmp &row, dmmeta::Ccmp &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCcmp_Init(amc::FCcmp& ccmp);
void                 FCcmp_Uninit(amc::FCcmp& ccmp) __attribute__((nothrow));

// --- amc.FCdecl
// create: amc.FDb.cdecl (Lary)
// access: amc.FCtype.c_cdecl (Ptrary)
struct FCdecl { // amc.FCdecl
    algo::Smallstr50   ctype;                  //
    bool               fwddecl;                //   false
    bool               gen_using;              //   false
    algo::Comment      comment;                //
    amc::FCtype*       p_ctype;                // reference to parent row
    bool               ctype_c_cdecl_in_ary;   //   false  membership flag
private:
    friend amc::FCdecl&         cdecl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCdecl*         cdecl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cdecl_RemoveAll() __attribute__((nothrow));
    friend void                 cdecl_RemoveLast() __attribute__((nothrow));
    FCdecl();
    ~FCdecl();
    FCdecl(const FCdecl&){ /*disallow copy constructor */}
    void operator =(const FCdecl&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cdecl_CopyOut(amc::FCdecl &row, dmmeta::Cdecl &out) __attribute__((nothrow));
// Copy fields in to row
void                 cdecl_CopyIn(amc::FCdecl &row, dmmeta::Cdecl &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCdecl_Init(amc::FCdecl& cdecl);
void                 FCdecl_Uninit(amc::FCdecl& cdecl) __attribute__((nothrow));

// --- amc.FCdflt
// create: amc.FDb.cdflt (Lary)
// access: amc.FCtype.c_cdflt (Ptr)
struct FCdflt { // amc.FCdflt
    algo::Smallstr50   ctype;      //
    dmmeta::CppExpr    dflt;       //
    dmmeta::CppExpr    cppdflt;    //
    algo::Smallstr50   ssimdflt;   //
    algo::Comment      comment;    //
private:
    friend amc::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cdflt_RemoveLast() __attribute__((nothrow));
    FCdflt();
    ~FCdflt();
    FCdflt(const FCdflt&){ /*disallow copy constructor */}
    void operator =(const FCdflt&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cdflt_CopyOut(amc::FCdflt &row, dmmeta::Cdflt &out) __attribute__((nothrow));
// Copy fields in to row
void                 cdflt_CopyIn(amc::FCdflt &row, dmmeta::Cdflt &in) __attribute__((nothrow));

void                 FCdflt_Uninit(amc::FCdflt& cdflt) __attribute__((nothrow));

// --- amc.FCextern
// create: amc.FDb.cextern (Lary)
// access: amc.FCtype.c_cextern (Ptr)
struct FCextern { // amc.FCextern
    algo::Smallstr50   ctype;        // Ctype in question
    bool               initmemset;   //   false  Initialize using memset? (set this to Y for all C structs)
private:
    friend amc::FCextern&       cextern_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCextern*       cextern_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cextern_RemoveLast() __attribute__((nothrow));
    FCextern();
    ~FCextern();
    FCextern(const FCextern&){ /*disallow copy constructor */}
    void operator =(const FCextern&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 cextern_CopyIn(amc::FCextern &row, dmmeta::Cextern &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCextern_Init(amc::FCextern& cextern);
void                 FCextern_Uninit(amc::FCextern& cextern) __attribute__((nothrow));

// --- amc.FCfmt
// create: amc.FDb.cfmt (Lary)
// global access: ind_cfmt (Thash)
// access: amc.FCtype.zs_cfmt (Llist)
struct FCfmt { // amc.FCfmt
    algo::Smallstr50   cfmt;            //
    algo::Smallstr50   printfmt;        //
    bool               read;            //   false
    bool               print;           //   false
    algo::Smallstr20   sep;             //
    bool               genop;           //   false
    amc::FCfmt*        zs_cfmt_next;    // zslist link; -1 means not-in-list
    amc::FCfmt*        ind_cfmt_next;   // hash next
private:
    friend amc::FCfmt&          cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCfmt*          cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfmt_RemoveLast() __attribute__((nothrow));
    FCfmt();
    ~FCfmt();
    FCfmt(const FCfmt&){ /*disallow copy constructor */}
    void operator =(const FCfmt&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 cfmt_CopyIn(amc::FCfmt &row, dmmeta::Cfmt &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     strfmt_Get(amc::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FCfmt_Init(amc::FCfmt& cfmt);
void                 FCfmt_Uninit(amc::FCfmt& cfmt) __attribute__((nothrow));

// --- amc.FCget
// create: amc.FDb.cget (Lary)
struct FCget { // amc.FCget
    algo::Smallstr50   ctype;     //
    algo::Comment      comment;   //
    amc::FCtype*       p_ctype;   // reference to parent row
private:
    friend amc::FCget&          cget_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCget*          cget_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cget_RemoveLast() __attribute__((nothrow));
    FCget();
    // x-reference on amc.FCget.p_ctype prevents copy
    FCget(const FCget&){ /*disallow copy constructor */}
    void operator =(const FCget&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cget_CopyOut(amc::FCget &row, dmmeta::Cget &out) __attribute__((nothrow));
// Copy fields in to row
void                 cget_CopyIn(amc::FCget &row, dmmeta::Cget &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCget_Init(amc::FCget& cget);

// --- amc.FCharset
// create: amc.FDb.charset (Lary)
// access: amc.FField.c_charset (Ptr)
struct FCharset { // amc.FCharset
    algo::Smallstr100   field;       //
    algo::Smallstr100   expr;        //
    bool                charrange;   //   false
    bool                calc;        //   false
    algo::Comment       comment;     //
    algo::Charset       chars;       //
private:
    friend amc::FCharset&       charset_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCharset*       charset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 charset_RemoveAll() __attribute__((nothrow));
    friend void                 charset_RemoveLast() __attribute__((nothrow));
    FCharset();
    ~FCharset();
    FCharset(const FCharset&){ /*disallow copy constructor */}
    void operator =(const FCharset&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 charset_CopyOut(amc::FCharset &row, dmmeta::Charset &out) __attribute__((nothrow));
// Copy fields in to row
void                 charset_CopyIn(amc::FCharset &row, dmmeta::Charset &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCharset_Init(amc::FCharset& charset);
void                 FCharset_Uninit(amc::FCharset& charset) __attribute__((nothrow));

// --- amc.FChash
// create: amc.FDb.chash (Lary)
// global access: ind_chash (Thash)
// access: amc.FCtype.c_chash (Ptr)
struct FChash { // amc.FChash
    algo::Smallstr50   ctype;            // Target ctype
    algo::Smallstr50   hashtype;         // Hash type
    amc::FChash*       ind_chash_next;   // hash next
private:
    friend amc::FChash&         chash_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FChash*         chash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 chash_RemoveLast() __attribute__((nothrow));
    FChash();
    ~FChash();
    FChash(const FChash&){ /*disallow copy constructor */}
    void operator =(const FChash&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 chash_CopyIn(amc::FChash &row, dmmeta::Chash &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FChash_Init(amc::FChash& chash);
void                 FChash_Uninit(amc::FChash& chash) __attribute__((nothrow));

// --- amc.FCppfunc
// create: amc.FDb.cppfunc (Lary)
// access: amc.FField.c_cppfunc (Ptr)
struct FCppfunc { // amc.FCppfunc
    algo::Smallstr100   field;   //
    dmmeta::CppExpr     expr;    //
private:
    friend amc::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cppfunc_RemoveLast() __attribute__((nothrow));
    FCppfunc();
    ~FCppfunc();
    FCppfunc(const FCppfunc&){ /*disallow copy constructor */}
    void operator =(const FCppfunc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 cppfunc_CopyOut(amc::FCppfunc &row, dmmeta::Cppfunc &out) __attribute__((nothrow));
// Copy fields in to row
void                 cppfunc_CopyIn(amc::FCppfunc &row, dmmeta::Cppfunc &in) __attribute__((nothrow));

void                 FCppfunc_Uninit(amc::FCppfunc& cppfunc) __attribute__((nothrow));

// --- amc.FCpptype
// create: amc.FDb.cpptype (Lary)
// global access: ind_cpptype (Thash)
// access: amc.FCtype.c_cpptype (Ptr)
struct FCpptype { // amc.FCpptype
    algo::Smallstr50   ctype;              //
    bool               ctor;               //   false  if true, generate non-default constructor from all fields
    bool               dtor;               //   true  generate non-default destructor
    bool               cheap_copy;         //   false  Pass by value whenever possible
    amc::FCtype*       p_ctype;            // reference to parent row
    amc::FCpptype*     ind_cpptype_next;   // hash next
private:
    friend amc::FCpptype&       cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCpptype*       cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cpptype_RemoveLast() __attribute__((nothrow));
    FCpptype();
    ~FCpptype();
    FCpptype(const FCpptype&){ /*disallow copy constructor */}
    void operator =(const FCpptype&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 cpptype_CopyIn(amc::FCpptype &row, dmmeta::Cpptype &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCpptype_Init(amc::FCpptype& cpptype);
void                 FCpptype_Uninit(amc::FCpptype& cpptype) __attribute__((nothrow));

// --- amc.FCsize
// create: amc.FDb.csize (Lary)
// access: amc.FCtype.c_csize (Ptr)
struct FCsize { // amc.FCsize
    algo::Smallstr50   ctype;       //
    u32                size;        //   0
    u32                alignment;   //   1
private:
    friend amc::FCsize&         csize_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCsize*         csize_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 csize_RemoveLast() __attribute__((nothrow));
    FCsize();
    ~FCsize();
    FCsize(const FCsize&){ /*disallow copy constructor */}
    void operator =(const FCsize&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 csize_CopyIn(amc::FCsize &row, dmmeta::Csize &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCsize_Init(amc::FCsize& csize);
void                 FCsize_Uninit(amc::FCsize& csize) __attribute__((nothrow));

// --- amc.FCstr
// create: amc.FDb.cstr (Lary)
// access: amc.FCtype.c_cstr (Ptr)
struct FCstr { // amc.FCstr
    algo::Smallstr50   ctype;      //
    bool               strequiv;   //   false  Use strptr instead of this type when possible
private:
    friend amc::FCstr&          cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCstr*          cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstr_RemoveLast() __attribute__((nothrow));
    FCstr();
    ~FCstr();
    FCstr(const FCstr&){ /*disallow copy constructor */}
    void operator =(const FCstr&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 cstr_CopyIn(amc::FCstr &row, dmmeta::Cstr &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCstr_Init(amc::FCstr& cstr);
void                 FCstr_Uninit(amc::FCstr& cstr) __attribute__((nothrow));

// --- amc.FCtype
// create: amc.FDb.ctype (Lary)
// global access: ind_ctype (Thash)
// global access: c_ctype_sorted (Ptrary)
// global access: zsl_ctype_pack_tran (Llist)
// global access: zs_sig_visit (Llist)
// global access: c_u64 (Ptr)
// access: amc.FCafter.p_after (Upptr)
// access: amc.FCdecl.p_ctype (Upptr)
// access: amc.FCget.p_ctype (Upptr)
// access: amc.FCpptype.p_ctype (Upptr)
// access: amc.FCtype.c_parent (Ptrary)
// access: amc.FDispatch.p_ctype_hdr (Upptr)
// access: amc.FDispatch.p_casetype (Upptr)
// access: amc.FDispatchmsg.p_ctype (Upptr)
// access: amc.FDispctx.p_ctype (Upptr)
// access: amc.FField.p_ctype (Upptr)
// access: amc.FField.p_arg (Upptr)
// access: amc.FHook.p_funcptr (Upptr)
// access: amc.FMsgtype.p_ctype (Upptr)
// access: amc.FNs.c_ctype (Ptrary)
// access: amc.FNs.c_ctype_ins (Ptrary)
// access: amc.FNumstr.p_numtype (Upptr)
// access: amc.FPack.p_ctype (Upptr)
// access: amc.FPnew.p_ctype (Upptr)
// access: amc.FSsimfile.p_ctype (Upptr)
// access: amc.FTypefld.p_ctype (Upptr)
// access: amc.FXref.p_ctype (Upptr)
// access: amc.Genfield.p_ctype (Upptr)
// access: amc.Genpnew.p_ctype (Upptr)
struct FCtype { // amc.FCtype
    algo::Smallstr50      ctype;                      // Identifier. must be ns.typename
    algo::Comment         comment;                    //
    amc::FCfmt*           zs_cfmt_head;               // zero-terminated singly linked list
    amc::FCfmt*           zs_cfmt_tail;               // pointer to last element
    algo::cstring         cpp_type;                   // type name to use in c++
    algo::cstring         body;                       // Struct contents
    algo::cstring         sizecheck;                  // Size check assertions
    amc::FFunc*           c_init;                     // Pointer to constructor. optional pointer
    amc::FNs*             p_ns;                       // reference to parent row
    amc::FBltin*          c_bltin;                    // optional pointer
    amc::FField**         c_field_elems;              // array of pointers
    u32                   c_field_n;                  // array of pointers
    u32                   c_field_max;                // capacity of allocated array
    amc::FMsgtype*        c_msgtype;                  // optional pointer
    amc::FField*          c_varlenfld;                // optional pointer
    amc::FField*          c_optfld;                   // optional pointer
    amc::FStatictuple**   c_static_elems;             // array of pointers
    u32                   c_static_n;                 // array of pointers
    u32                   c_static_max;               // capacity of allocated array
    amc::FCpptype*        c_cpptype;                  // optional pointer
    amc::FCtype**         c_parent_elems;             // array of pointers
    u32                   c_parent_n;                 // array of pointers
    u32                   c_parent_max;               // capacity of allocated array
    amc::FSsimfile*       c_ssimfile;                 // optional pointer
    amc::FPack*           c_pack;                     // optional pointer
    amc::FLenfld*         c_lenfld;                   // optional pointer
    amc::FPmaskfld*       c_pmaskfld;                 // optional pointer
    amc::FTypefld*        c_typefld;                  // optional pointer
    amc::FField**         c_datafld_elems;            // array of pointers
    u32                   c_datafld_n;                // array of pointers
    u32                   c_datafld_max;              // capacity of allocated array
    amc::FField*          zd_inst_head;               // zero-terminated doubly linked list
    i32                   zd_inst_n;                  // zero-terminated doubly linked list
    amc::FField*          zd_inst_tail;               // pointer to last element
    amc::FXref*           zs_xref_head;               // zero-terminated singly linked list
    i32                   zs_xref_n;                  // zero-terminated singly linked list
    amc::FXref*           zs_xref_tail;               // pointer to last element
    amc::FChash*          c_chash;                    // optional pointer
    amc::FCcmp*           c_ccmp;                     // optional pointer
    amc::FCstr*           c_cstr;                     // optional pointer
    amc::FCextern*        c_cextern;                  // optional pointer
    algo::Sha1sig         signature;                  //
    amc::FFunc**          c_ffunc_elems;              // array of pointers
    u32                   c_ffunc_n;                  // array of pointers
    u32                   c_ffunc_max;                // capacity of allocated array
    amc::FCafter*         zd_cafter_head;             // zero-terminated doubly linked list
    i32                   zd_cafter_n;                // zero-terminated doubly linked list
    amc::FCafter*         zd_cafter_tail;             // pointer to last element
    amc::FCsize*          c_csize;                    // optional pointer
    amc::FField*          zd_access_head;             // zero-terminated doubly linked list
    i32                   zd_access_n;                // zero-terminated doubly linked list
    amc::FField*          zd_access_tail;             // pointer to last element
    amc::FCdflt*          c_cdflt;                    // optional pointer
    amc::FArgvtype*       c_argvtype;                 // optional pointer
    amc::FFloadtuples*    c_floadtuples;              // optional pointer
    amc::FField*          c_pkeyfield;                // Field corresponding to pkey of this type. optional pointer
    amc::FFcurs**         c_fcurs_elems;              // array of pointers
    u32                   c_fcurs_n;                  // array of pointers
    u32                   c_fcurs_max;                // capacity of allocated array
    algo::cstring         copy_priv_reason;           //
    amc::FCtypelen*       c_ctypelen;                 // optional pointer
    bool                  copy_priv_valid;            //   false
    bool                  size_unknown;               //   false
    bool                  size_locked;                //   false
    bool                  topo_visited;               //   false  Temporary
    bool                  ins_visited;                //   false  Temporary
    bool                  enum_visited;               //   false  Temporary
    bool                  copy_priv;                  //   false  disallow copy ctor / assign op
    bool                  fields_cloned;              //   false  True if fields from c_cbase have been cloned.
    bool                  original;                   //   false  True if this ctype comes from disk
    u32                   alignment;                  //   1
    i32                   n_padbytes;                 //   0
    u32                   totsize_byte;               //   0  Total size in bytes of all fields
    i32                   n_xref;                     //   0
    i32                   next_anon_idx;              //   0  sequence to enumerate positional fields
    amc::FNossimfile*     c_nossimfile;               // optional pointer
    amc::FCdecl**         c_cdecl_elems;              // array of pointers
    u32                   c_cdecl_n;                  // array of pointers
    u32                   c_cdecl_max;                // capacity of allocated array
    bool                  ns_c_ctype_in_ary;          //   false  membership flag
    bool                  ns_c_ctype_ins_in_ary;      //   false  membership flag
    amc::FCtype*          ind_ctype_next;             // hash next
    amc::FCtype*          zsl_ctype_pack_tran_next;   // zslist link; -1 means not-in-list
    amc::FCtype*          zs_sig_visit_next;          // zslist link; -1 means not-in-list
private:
    friend amc::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
    FCtype();
    ~FCtype();
    FCtype(const FCtype&){ /*disallow copy constructor */}
    void operator =(const FCtype&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ctype_CopyOut(amc::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
void                 ctype_CopyIn(amc::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zs_cfmt_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FCfmt*          zs_cfmt_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_cfmt_InLlistQ(amc::FCfmt& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_cfmt_Insert(amc::FCtype& ctype, amc::FCfmt& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FCfmt*          zs_cfmt_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FCfmt*          zs_cfmt_Next(amc::FCfmt &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_cfmt_Remove(amc::FCtype& ctype, amc::FCfmt& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_cfmt_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCfmt*          zs_cfmt_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FCfmt&          zs_cfmt_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_bltin_InsertMaybe(amc::FCtype& ctype, amc::FBltin& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_bltin_Remove(amc::FCtype& ctype, amc::FBltin& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_field_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FField*         c_field_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FField*> c_field_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_field_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_field_ScanInsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_field_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_field_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_field_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_field_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_field_SortedQ(amc::FCtype& ctype) __attribute__((nothrow));
// Insertion sort
void                 c_field_InsertionSort(amc::FCtype& ctype) __attribute__((nothrow));
// Heap sort
void                 c_field_HeapSort(amc::FCtype& ctype) __attribute__((nothrow));
// Quick sort
void                 c_field_QuickSort(amc::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_msgtype_InsertMaybe(amc::FCtype& ctype, amc::FMsgtype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_msgtype_Remove(amc::FCtype& ctype, amc::FMsgtype& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_varlenfld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_varlenfld_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_optfld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_optfld_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_static_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FStatictuple*   c_static_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FStatictuple*> c_static_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_static_Insert(amc::FCtype& ctype, amc::FStatictuple& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_static_InsertMaybe(amc::FCtype& ctype, amc::FStatictuple& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_static_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_static_Remove(amc::FCtype& ctype, amc::FStatictuple& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_static_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_static_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cpptype_InsertMaybe(amc::FCtype& ctype, amc::FCpptype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cpptype_Remove(amc::FCtype& ctype, amc::FCpptype& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_parent_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtype*         c_parent_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FCtype*> c_parent_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_parent_Insert(amc::FCtype& ctype, amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_parent_ScanInsertMaybe(amc::FCtype& ctype, amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_parent_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_parent_Remove(amc::FCtype& ctype, amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_parent_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_parent_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ssimfile_InsertMaybe(amc::FCtype& ctype, amc::FSsimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ssimfile_Remove(amc::FCtype& ctype, amc::FSsimfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_pack_InsertMaybe(amc::FCtype& ctype, amc::FPack& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_pack_Remove(amc::FCtype& ctype, amc::FPack& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_lenfld_InsertMaybe(amc::FCtype& ctype, amc::FLenfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_lenfld_Remove(amc::FCtype& ctype, amc::FLenfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_pmaskfld_InsertMaybe(amc::FCtype& ctype, amc::FPmaskfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_pmaskfld_Remove(amc::FCtype& ctype, amc::FPmaskfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_typefld_InsertMaybe(amc::FCtype& ctype, amc::FTypefld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_typefld_Remove(amc::FCtype& ctype, amc::FTypefld& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_datafld_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FField*         c_datafld_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FField*> c_datafld_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_datafld_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_datafld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_datafld_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_datafld_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_datafld_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_datafld_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_inst_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FField*         zd_inst_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_inst_InLlistQ(amc::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_inst_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FField*         zd_inst_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_inst_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FField*         zd_inst_Next(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
amc::FField*         zd_inst_Prev(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_inst_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_inst_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FField*         zd_inst_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FField&         zd_inst_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zs_xref_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FXref*          zs_xref_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_xref_InLlistQ(amc::FXref& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_xref_Insert(amc::FCtype& ctype, amc::FXref& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FXref*          zs_xref_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zs_xref_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FXref*          zs_xref_Next(amc::FXref &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_xref_Remove(amc::FCtype& ctype, amc::FXref& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_xref_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FXref*          zs_xref_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FXref&          zs_xref_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_chash_InsertMaybe(amc::FCtype& ctype, amc::FChash& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_chash_Remove(amc::FCtype& ctype, amc::FChash& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ccmp_InsertMaybe(amc::FCtype& ctype, amc::FCcmp& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ccmp_Remove(amc::FCtype& ctype, amc::FCcmp& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cstr_InsertMaybe(amc::FCtype& ctype, amc::FCstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cstr_Remove(amc::FCtype& ctype, amc::FCstr& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cextern_InsertMaybe(amc::FCtype& ctype, amc::FCextern& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cextern_Remove(amc::FCtype& ctype, amc::FCextern& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_ffunc_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFunc*          c_ffunc_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFunc*> c_ffunc_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ffunc_Insert(amc::FCtype& ctype, amc::FFunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_ffunc_ScanInsertMaybe(amc::FCtype& ctype, amc::FFunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ffunc_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ffunc_Remove(amc::FCtype& ctype, amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ffunc_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ffunc_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_cafter_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FCafter*        zd_cafter_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_cafter_InLlistQ(amc::FCafter& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_cafter_Insert(amc::FCtype& ctype, amc::FCafter& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FCafter*        zd_cafter_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_cafter_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FCafter*        zd_cafter_Next(amc::FCafter &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
amc::FCafter*        zd_cafter_Prev(amc::FCafter &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_cafter_Remove(amc::FCtype& ctype, amc::FCafter& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_cafter_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCafter*        zd_cafter_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FCafter&        zd_cafter_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_csize_InsertMaybe(amc::FCtype& ctype, amc::FCsize& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_csize_Remove(amc::FCtype& ctype, amc::FCsize& row) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_access_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FField*         zd_access_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_access_InLlistQ(amc::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_access_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FField*         zd_access_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_access_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FField*         zd_access_Next(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
amc::FField*         zd_access_Prev(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_access_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_access_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FField*         zd_access_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FField&         zd_access_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cdflt_InsertMaybe(amc::FCtype& ctype, amc::FCdflt& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cdflt_Remove(amc::FCtype& ctype, amc::FCdflt& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_argvtype_InsertMaybe(amc::FCtype& ctype, amc::FArgvtype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_argvtype_Remove(amc::FCtype& ctype, amc::FArgvtype& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_floadtuples_InsertMaybe(amc::FCtype& ctype, amc::FFloadtuples& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_floadtuples_Remove(amc::FCtype& ctype, amc::FFloadtuples& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_fcurs_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcurs*         c_fcurs_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFcurs*> c_fcurs_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_fcurs_Insert(amc::FCtype& ctype, amc::FFcurs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_fcurs_InsertMaybe(amc::FCtype& ctype, amc::FFcurs& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_fcurs_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_fcurs_Remove(amc::FCtype& ctype, amc::FFcurs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_fcurs_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_fcurs_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ctypelen_InsertMaybe(amc::FCtype& ctype, amc::FCtypelen& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ctypelen_Remove(amc::FCtype& ctype, amc::FCtypelen& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_nossimfile_InsertMaybe(amc::FCtype& ctype, amc::FNossimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_nossimfile_Remove(amc::FCtype& ctype, amc::FNossimfile& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_cdecl_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCdecl*         c_cdecl_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FCdecl*> c_cdecl_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_cdecl_Insert(amc::FCtype& ctype, amc::FCdecl& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_cdecl_InsertMaybe(amc::FCtype& ctype, amc::FCdecl& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_cdecl_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_cdecl_Remove(amc::FCtype& ctype, amc::FCdecl& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_cdecl_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_cdecl_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));

// cursor points to valid item
void                 ctype_zs_cfmt_curs_Reset(ctype_zs_cfmt_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_zs_cfmt_curs_ValidQ(ctype_zs_cfmt_curs &curs);
// proceed to next item
void                 ctype_zs_cfmt_curs_Next(ctype_zs_cfmt_curs &curs);
// item access
amc::FCfmt&          ctype_zs_cfmt_curs_Access(ctype_zs_cfmt_curs &curs);
void                 ctype_c_field_curs_Reset(ctype_c_field_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs);
// proceed to next item
void                 ctype_c_field_curs_Next(ctype_c_field_curs &curs);
// item access
amc::FField&         ctype_c_field_curs_Access(ctype_c_field_curs &curs);
void                 ctype_c_static_curs_Reset(ctype_c_static_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_static_curs_ValidQ(ctype_c_static_curs &curs);
// proceed to next item
void                 ctype_c_static_curs_Next(ctype_c_static_curs &curs);
// item access
amc::FStatictuple&   ctype_c_static_curs_Access(ctype_c_static_curs &curs);
void                 ctype_c_parent_curs_Reset(ctype_c_parent_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_parent_curs_ValidQ(ctype_c_parent_curs &curs);
// proceed to next item
void                 ctype_c_parent_curs_Next(ctype_c_parent_curs &curs);
// item access
amc::FCtype&         ctype_c_parent_curs_Access(ctype_c_parent_curs &curs);
void                 ctype_c_datafld_curs_Reset(ctype_c_datafld_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_datafld_curs_ValidQ(ctype_c_datafld_curs &curs);
// proceed to next item
void                 ctype_c_datafld_curs_Next(ctype_c_datafld_curs &curs);
// item access
amc::FField&         ctype_c_datafld_curs_Access(ctype_c_datafld_curs &curs);
// cursor points to valid item
void                 ctype_zd_inst_curs_Reset(ctype_zd_inst_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_zd_inst_curs_ValidQ(ctype_zd_inst_curs &curs);
// proceed to next item
void                 ctype_zd_inst_curs_Next(ctype_zd_inst_curs &curs);
// item access
amc::FField&         ctype_zd_inst_curs_Access(ctype_zd_inst_curs &curs);
// cursor points to valid item
void                 ctype_zs_xref_curs_Reset(ctype_zs_xref_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_zs_xref_curs_ValidQ(ctype_zs_xref_curs &curs);
// proceed to next item
void                 ctype_zs_xref_curs_Next(ctype_zs_xref_curs &curs);
// item access
amc::FXref&          ctype_zs_xref_curs_Access(ctype_zs_xref_curs &curs);
void                 ctype_c_ffunc_curs_Reset(ctype_c_ffunc_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_ffunc_curs_ValidQ(ctype_c_ffunc_curs &curs);
// proceed to next item
void                 ctype_c_ffunc_curs_Next(ctype_c_ffunc_curs &curs);
// item access
amc::FFunc&          ctype_c_ffunc_curs_Access(ctype_c_ffunc_curs &curs);
// cursor points to valid item
void                 ctype_zd_cafter_curs_Reset(ctype_zd_cafter_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_zd_cafter_curs_ValidQ(ctype_zd_cafter_curs &curs);
// proceed to next item
void                 ctype_zd_cafter_curs_Next(ctype_zd_cafter_curs &curs);
// item access
amc::FCafter&        ctype_zd_cafter_curs_Access(ctype_zd_cafter_curs &curs);
// cursor points to valid item
void                 ctype_zd_access_curs_Reset(ctype_zd_access_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_zd_access_curs_ValidQ(ctype_zd_access_curs &curs);
// proceed to next item
void                 ctype_zd_access_curs_Next(ctype_zd_access_curs &curs);
// item access
amc::FField&         ctype_zd_access_curs_Access(ctype_zd_access_curs &curs);
void                 ctype_c_fcurs_curs_Reset(ctype_c_fcurs_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_fcurs_curs_ValidQ(ctype_c_fcurs_curs &curs);
// proceed to next item
void                 ctype_c_fcurs_curs_Next(ctype_c_fcurs_curs &curs);
// item access
amc::FFcurs&         ctype_c_fcurs_curs_Access(ctype_c_fcurs_curs &curs);
void                 ctype_c_cdecl_curs_Reset(ctype_c_cdecl_curs &curs, amc::FCtype &parent);
// cursor points to valid item
bool                 ctype_c_cdecl_curs_ValidQ(ctype_c_cdecl_curs &curs);
// proceed to next item
void                 ctype_c_cdecl_curs_Next(ctype_c_cdecl_curs &curs);
// item access
amc::FCdecl&         ctype_c_cdecl_curs_Access(ctype_c_cdecl_curs &curs);
// Set all fields to initial values.
void                 FCtype_Init(amc::FCtype& ctype);
void                 FCtype_Uninit(amc::FCtype& ctype) __attribute__((nothrow));

// --- amc.FCtypelen
// create: amc.FDb.ctypelen (Lary)
// global access: c_ctypelen (Ptrary)
// access: amc.FCtype.c_ctypelen (Ptr)
struct FCtypelen { // amc.FCtypelen
    algo::Smallstr50   ctype;                   // Identifies the Ctype
    u32                len;                     //   0
    i32                alignment;               //   0
    i32                padbytes;                //   0
    bool               _db_c_ctypelen_in_ary;   //   false  membership flag
private:
    friend amc::FCtypelen&      ctypelen_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCtypelen*      ctypelen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctypelen_RemoveAll() __attribute__((nothrow));
    friend void                 ctypelen_RemoveLast() __attribute__((nothrow));
    FCtypelen();
    ~FCtypelen();
    FCtypelen(const FCtypelen&){ /*disallow copy constructor */}
    void operator =(const FCtypelen&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ctypelen_CopyOut(amc::FCtypelen &row, dmmeta::Ctypelen &out) __attribute__((nothrow));
// Copy fields in to row
void                 ctypelen_CopyIn(amc::FCtypelen &row, dmmeta::Ctypelen &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FCtypelen_Init(amc::FCtypelen& ctypelen);
void                 FCtypelen_Uninit(amc::FCtypelen& ctypelen) __attribute__((nothrow));

// --- amc.Genfield
struct Genfield { // amc.Genfield
    algo_lib::Replscope   R;         //
    amc::FField*          p_field;   // reference to parent row
    amc::FCtype*          p_ctype;   // reference to parent row
    amc::FTfunc*          p_tfunc;   // reference to parent row
    Genfield();
private:
    // value field amc.Genfield.R is not copiable
    Genfield(const Genfield&){ /*disallow copy constructor */}
    void operator =(const Genfield&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 Genfield_Init(amc::Genfield& parent);

// --- amc.FTclass
// create: amc.FDb.tclass (Inlary)
// global access: ind_tclass (Thash)
// access: amc.FReftype.p_tclass (Upptr)
struct FTclass { // amc.FTclass
    algo::Smallstr50        tclass;            //
    amc::FTfunc**           c_tfunc_elems;     // array of pointers
    u32                     c_tfunc_n;         // array of pointers
    u32                     c_tfunc_max;       // capacity of allocated array
    amc::tclass_step_hook   step;              //   NULL  Pointer to a function
    amc::FTclass*           ind_tclass_next;   // hash next
    FTclass();
    ~FTclass();
private:
    FTclass(const FTclass&){ /*disallow copy constructor */}
    void operator =(const FTclass&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 tclass_CopyIn(amc::FTclass &row, amcdb::Tclass &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_tfunc_EmptyQ(amc::FTclass& tclass) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTfunc*         c_tfunc_Find(amc::FTclass& tclass, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FTfunc*> c_tfunc_Getary(amc::FTclass& tclass) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_tfunc_Insert(amc::FTclass& tclass, amc::FTfunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_tfunc_InsertMaybe(amc::FTclass& tclass, amc::FTfunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_tfunc_N(const amc::FTclass& tclass) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_tfunc_Remove(amc::FTclass& tclass, amc::FTfunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_tfunc_RemoveAll(amc::FTclass& tclass) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_tfunc_Reserve(amc::FTclass& tclass, u32 n) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(amc::FTclass& tclass) __attribute__((nothrow));

void                 tclass_c_tfunc_curs_Reset(tclass_c_tfunc_curs &curs, amc::FTclass &parent);
// cursor points to valid item
bool                 tclass_c_tfunc_curs_ValidQ(tclass_c_tfunc_curs &curs);
// proceed to next item
void                 tclass_c_tfunc_curs_Next(tclass_c_tfunc_curs &curs);
// item access
amc::FTfunc&         tclass_c_tfunc_curs_Access(tclass_c_tfunc_curs &curs);
// Set all fields to initial values.
void                 FTclass_Init(amc::FTclass& tclass);
void                 FTclass_Uninit(amc::FTclass& tclass) __attribute__((nothrow));

// --- amc.trace
#pragma pack(push,1)
struct trace { // amc.trace
    trace();
};
#pragma pack(pop)

// print string representation of amc::trace to string LHS, no header -- cprint:amc.trace.String
void                 trace_Print(amc::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- amc.FDb
// create: amc.FDb._db (Global)
struct FDb { // amc.FDb
    lpool_Lpblock*        lpool_free[31];                           // Lpool levels
    amc::FFsort*          fsort_lary[32];                           // level array
    i32                   fsort_n;                                  // number of elements in array
    amc::FCfmt**          ind_cfmt_buckets_elems;                   // pointer to bucket array
    i32                   ind_cfmt_buckets_n;                       // number of elements in bucket array
    i32                   ind_cfmt_n;                               // number of elements in the hash table
    amc::FDispfilter*     dispfilter_lary[32];                      // level array
    i32                   dispfilter_n;                             // number of elements in array
    amc::FUsertracefld*   usertracefld_lary[32];                    // level array
    i32                   usertracefld_n;                           // number of elements in array
    amc::FCfmt*           cfmt_lary[32];                            // level array
    i32                   cfmt_n;                                   // number of elements in array
    command::amc          cmdline;                                  //
    amc::FDispatch*       dispatch_lary[32];                        // level array
    i32                   dispatch_n;                               // number of elements in array
    amc::FDispatchmsg*    dispatch_msg_lary[32];                    // level array
    i32                   dispatch_msg_n;                           // number of elements in array
    amc::FCtype*          ctype_lary[32];                           // level array
    i32                   ctype_n;                                  // number of elements in array
    amc::FField*          field_lary[32];                           // level array
    i32                   field_n;                                  // number of elements in array
    amc::FBasepool*       basepool_lary[32];                        // level array
    i32                   basepool_n;                               // number of elements in array
    amc::FLlist*          llist_lary[32];                           // level array
    i32                   llist_n;                                  // number of elements in array
    amc::FAnonfld*        anonfld_lary[32];                         // level array
    i32                   anonfld_n;                                // number of elements in array
    amc::FXref*           xref_lary[32];                            // level array
    i32                   xref_n;                                   // number of elements in array
    amc::FNs*             ns_lary[32];                              // level array
    i32                   ns_n;                                     // number of elements in array
    amc::FPnew*           pnew_lary[32];                            // level array
    i32                   pnew_n;                                   // number of elements in array
    amc::FFldoffset*      fldoffset_lary[32];                       // level array
    i32                   fldoffset_n;                              // number of elements in array
    amc::FTypefld*        typefld_lary[32];                         // level array
    i32                   typefld_n;                                // number of elements in array
    amc::FLenfld*         lenfld_lary[32];                          // level array
    i32                   lenfld_n;                                 // number of elements in array
    amc::FBltin*          bltin_lary[32];                           // level array
    i32                   bltin_n;                                  // number of elements in array
    amc::FStatictuple*    static_tuple_lary[32];                    // level array
    i32                   static_tuple_n;                           // number of elements in array
    amc::FMsgtype*        msgtype_lary[32];                         // level array
    i32                   msgtype_n;                                // number of elements in array
    amc::FGconst*         gconst_lary[32];                          // level array
    i32                   gconst_n;                                 // number of elements in array
    amc::FGstatic*        gstatic_lary[32];                         // level array
    i32                   gstatic_n;                                // number of elements in array
    amc::FThash*          thash_lary[32];                           // level array
    i32                   thash_n;                                  // number of elements in array
    u32                   outfile_blocksize;                        // # bytes per block
    amc::FOutfile*        outfile_free;                             //
    amc::FFunc*           func_lary[32];                            // level array
    i32                   func_n;                                   // number of elements in array
    amc::FSmallstr*       smallstr_lary[32];                        // level array
    i32                   smallstr_n;                               // number of elements in array
    amc::FNumstr*         numstr_lary[32];                          // level array
    i32                   numstr_n;                                 // number of elements in array
    amc::FMain*           main_lary[32];                            // level array
    i32                   main_n;                                   // number of elements in array
    amc::FReftype*        reftype_lary[32];                         // level array
    i32                   reftype_n;                                // number of elements in array
    amc::FBltin**         ind_bltin_buckets_elems;                  // pointer to bucket array
    i32                   ind_bltin_buckets_n;                      // number of elements in bucket array
    i32                   ind_bltin_n;                              // number of elements in the hash table
    amc::FCtype**         ind_ctype_buckets_elems;                  // pointer to bucket array
    i32                   ind_ctype_buckets_n;                      // number of elements in bucket array
    i32                   ind_ctype_n;                              // number of elements in the hash table
    amc::FDispatch**      ind_dispatch_buckets_elems;               // pointer to bucket array
    i32                   ind_dispatch_buckets_n;                   // number of elements in bucket array
    i32                   ind_dispatch_n;                           // number of elements in the hash table
    amc::FFunc**          ind_func_buckets_elems;                   // pointer to bucket array
    i32                   ind_func_buckets_n;                       // number of elements in bucket array
    i32                   ind_func_n;                               // number of elements in the hash table
    amc::FField**         ind_field_buckets_elems;                  // pointer to bucket array
    i32                   ind_field_buckets_n;                      // number of elements in bucket array
    i32                   ind_field_n;                              // number of elements in the hash table
    amc::FNs**            ind_ns_buckets_elems;                     // pointer to bucket array
    i32                   ind_ns_buckets_n;                         // number of elements in bucket array
    i32                   ind_ns_n;                                 // number of elements in the hash table
    amc::FPnew**          ind_pnew_buckets_elems;                   // pointer to bucket array
    i32                   ind_pnew_buckets_n;                       // number of elements in bucket array
    i32                   ind_pnew_n;                               // number of elements in the hash table
    amc::FXref**          ind_xref_buckets_elems;                   // pointer to bucket array
    i32                   ind_xref_buckets_n;                       // number of elements in bucket array
    i32                   ind_xref_n;                               // number of elements in the hash table
    amc::FCpptype*        cpptype_lary[32];                         // level array
    i32                   cpptype_n;                                // number of elements in array
    amc::FCpptype**       ind_cpptype_buckets_elems;                // pointer to bucket array
    i32                   ind_cpptype_buckets_n;                    // number of elements in bucket array
    i32                   ind_cpptype_n;                            // number of elements in the hash table
    amc::FInlary*         inlary_lary[32];                          // level array
    i32                   inlary_n;                                 // number of elements in array
    amc::FInlary**        ind_inlary_buckets_elems;                 // pointer to bucket array
    i32                   ind_inlary_buckets_n;                     // number of elements in bucket array
    i32                   ind_inlary_n;                             // number of elements in the hash table
    amc::FTary*           tary_lary[32];                            // level array
    i32                   tary_n;                                   // number of elements in array
    amc::FTary**          ind_tary_buckets_elems;                   // pointer to bucket array
    i32                   ind_tary_buckets_n;                       // number of elements in bucket array
    i32                   ind_tary_n;                               // number of elements in the hash table
    amc::FCppfunc*        cppfunc_lary[32];                         // level array
    i32                   cppfunc_n;                                // number of elements in array
    amc::FRowid*          rowid_lary[32];                           // level array
    i32                   rowid_n;                                  // number of elements in array
    amc::FRowid**         ind_rowid_buckets_elems;                  // pointer to bucket array
    i32                   ind_rowid_buckets_n;                      // number of elements in bucket array
    i32                   ind_rowid_n;                              // number of elements in the hash table
    amc::FCascdel*        cascdel_lary[32];                         // level array
    i32                   cascdel_n;                                // number of elements in array
    amc::FSubstr*         substr_lary[32];                          // level array
    i32                   substr_n;                                 // number of elements in array
    amc::FBitfld*         bitfld_lary[32];                          // level array
    i32                   bitfld_n;                                 // number of elements in array
    amc::FSsimfile*       ssimfile_lary[32];                        // level array
    i32                   ssimfile_n;                               // number of elements in array
    amc::FSsimfile**      ind_ssimfile_buckets_elems;               // pointer to bucket array
    i32                   ind_ssimfile_buckets_n;                   // number of elements in bucket array
    i32                   ind_ssimfile_n;                           // number of elements in the hash table
    amc::FPack*           pack_lary[32];                            // level array
    i32                   pack_n;                                   // number of elements in array
    amc::FPack**          ind_pack_buckets_elems;                   // pointer to bucket array
    i32                   ind_pack_buckets_n;                       // number of elements in bucket array
    i32                   ind_pack_n;                               // number of elements in the hash table
    amc::FSmallstr**      ind_smallstr_buckets_elems;               // pointer to bucket array
    i32                   ind_smallstr_buckets_n;                   // number of elements in bucket array
    i32                   ind_smallstr_n;                           // number of elements in the hash table
    amc::FPtrary*         ptrary_lary[32];                          // level array
    i32                   ptrary_n;                                 // number of elements in array
    amc::FCtype**         c_ctype_sorted_elems;                     // array of pointers
    u32                   c_ctype_sorted_n;                         // array of pointers
    u32                   c_ctype_sorted_max;                       // capacity of allocated array
    amc::FEnumstr*        enumstr_lary[32];                         // level array
    i32                   enumstr_n;                                // number of elements in array
    amc::FEnumstrLen*     enumstr_len_lary[32];                     // level array
    i32                   enumstr_len_n;                            // number of elements in array
    amc::FEnumstrLen**    bh_enumstr_len_elems;                     // binary heap by len
    i32                   bh_enumstr_len_n;                         // number of elements in the heap
    i32                   bh_enumstr_len_max;                       // max elements in bh_enumstr_len_elems
    amc::FEnumstrLen**    ind_enumstr_len_buckets_elems;            // pointer to bucket array
    i32                   ind_enumstr_len_buckets_n;                // number of elements in bucket array
    i32                   ind_enumstr_len_n;                        // number of elements in the hash table
    amc::FEnumstr**       ind_enumstr_buckets_elems;                // pointer to bucket array
    i32                   ind_enumstr_buckets_n;                    // number of elements in bucket array
    i32                   ind_enumstr_n;                            // number of elements in the hash table
    amc::FFbitset*        fbitset_lary[32];                         // level array
    i32                   fbitset_n;                                // number of elements in array
    amc::FFbitset**       ind_fbitset_buckets_elems;                // pointer to bucket array
    i32                   ind_fbitset_buckets_n;                    // number of elements in bucket array
    i32                   ind_fbitset_n;                            // number of elements in the hash table
    amc::FFcleanup*       fcleanup_lary[32];                        // level array
    i32                   fcleanup_n;                               // number of elements in array
    amc::FFdec*           fdec_lary[32];                            // level array
    i32                   fdec_n;                                   // number of elements in array
    amc::FFdec**          ind_fdec_buckets_elems;                   // pointer to bucket array
    i32                   ind_fdec_buckets_n;                       // number of elements in bucket array
    i32                   ind_fdec_n;                               // number of elements in the hash table
    amc::FReftype**       ind_reftype_buckets_elems;                // pointer to bucket array
    i32                   ind_reftype_buckets_n;                    // number of elements in bucket array
    i32                   ind_reftype_n;                            // number of elements in the hash table
    amc::FFconst*         fconst_lary[32];                          // level array
    i32                   fconst_n;                                 // number of elements in array
    amc::FFconst**        ind_fconst_buckets_elems;                 // pointer to bucket array
    i32                   ind_fconst_buckets_n;                     // number of elements in bucket array
    i32                   ind_fconst_n;                             // number of elements in the hash table
    amc::FNs**            c_ns_sorted_elems;                        // array of pointers
    u32                   c_ns_sorted_n;                            // array of pointers
    u32                   c_ns_sorted_max;                          // capacity of allocated array
    amc::FFinput*         finput_lary[32];                          // level array
    i32                   finput_n;                                 // number of elements in array
    amc::FFoutput*        foutput_lary[32];                         // level array
    i32                   foutput_n;                                // number of elements in array
    amc::FFbuf*           fbuf_lary[32];                            // level array
    i32                   fbuf_n;                                   // number of elements in array
    amc::FFbuf**          ind_fbuf_buckets_elems;                   // pointer to bucket array
    i32                   ind_fbuf_buckets_n;                       // number of elements in bucket array
    i32                   ind_fbuf_n;                               // number of elements in the hash table
    amc::FChash*          chash_lary[32];                           // level array
    i32                   chash_n;                                  // number of elements in array
    amc::FChash**         ind_chash_buckets_elems;                  // pointer to bucket array
    i32                   ind_chash_buckets_n;                      // number of elements in bucket array
    i32                   ind_chash_n;                              // number of elements in the hash table
    amc::FCcmp*           ccmp_lary[32];                            // level array
    i32                   ccmp_n;                                   // number of elements in array
    amc::FCcmp**          ind_ccmp_buckets_elems;                   // pointer to bucket array
    i32                   ind_ccmp_buckets_n;                       // number of elements in bucket array
    i32                   ind_ccmp_n;                               // number of elements in the hash table
    amc::FFbigend*        fbigend_lary[32];                         // level array
    i32                   fbigend_n;                                // number of elements in array
    amc::FCtype*          zsl_ctype_pack_tran_head;                 // zero-terminated singly linked list
    amc::FCstr*           cstr_lary[32];                            // level array
    i32                   cstr_n;                                   // number of elements in array
    amc::FListtype*       listtype_lary[32];                        // level array
    i32                   listtype_n;                               // number of elements in array
    amc::FListtype**      ind_listtype_buckets_elems;               // pointer to bucket array
    i32                   ind_listtype_buckets_n;                   // number of elements in bucket array
    i32                   ind_listtype_n;                           // number of elements in the hash table
    amc::FFstep*          fstep_lary[32];                           // level array
    i32                   fstep_n;                                  // number of elements in array
    amc::FCextern*        cextern_lary[32];                         // level array
    i32                   cextern_n;                                // number of elements in array
    amc::FFdelay*         fdelay_lary[32];                          // level array
    i32                   fdelay_n;                                 // number of elements in array
    amc::FDisptrace*      disptrace_lary[32];                       // level array
    i32                   disptrace_n;                              // number of elements in array
    amc::FFstep**         ind_fstep_buckets_elems;                  // pointer to bucket array
    i32                   ind_fstep_buckets_n;                      // number of elements in bucket array
    i32                   ind_fstep_n;                              // number of elements in the hash table
    amc::FTracefld*       tracefld_lary[32];                        // level array
    i32                   tracefld_n;                               // number of elements in array
    amc::FTracerec*       tracerec_lary[32];                        // level array
    i32                   tracerec_n;                               // number of elements in array
    amc::FDispsig*        dispsig_lary[32];                         // level array
    i32                   dispsig_n;                                // number of elements in array
    amc::FDispsig**       c_dispsig_sorted_elems;                   // array of pointers
    u32                   c_dispsig_sorted_n;                       // array of pointers
    u32                   c_dispsig_sorted_max;                     // capacity of allocated array
    amc::FCtype*          zs_sig_visit_head;                        // zero-terminated singly linked list
    amc::FCtype*          zs_sig_visit_tail;                        // pointer to last element
    amc::FTarget*         target_lary[32];                          // level array
    i32                   target_n;                                 // number of elements in array
    amc::FTarget**        ind_target_buckets_elems;                 // pointer to bucket array
    i32                   ind_target_buckets_n;                     // number of elements in bucket array
    i32                   ind_target_n;                             // number of elements in the hash table
    amc::FTargdep*        targdep_lary[32];                         // level array
    i32                   targdep_n;                                // number of elements in array
    amc::FField*          c_malloc;                                 // optional pointer
    amc::FDispctx*        dispctx_lary[32];                         // level array
    i32                   dispctx_n;                                // number of elements in array
    amc::FPmaskfld*       pmaskfld_lary[32];                        // level array
    i32                   pmaskfld_n;                               // number of elements in array
    amc::Genfield         genfield;                                 //
    amc::FFwddecl*        fwddecl_lary[32];                         // level array
    i32                   fwddecl_n;                                // number of elements in array
    amc::FFwddecl**       ind_fwddecl_buckets_elems;                // pointer to bucket array
    i32                   ind_fwddecl_buckets_n;                    // number of elements in bucket array
    i32                   ind_fwddecl_n;                            // number of elements in the hash table
    amc::FTfunc*          tfunc_lary[32];                           // level array
    i32                   tfunc_n;                                  // number of elements in array
    amc::FTfunc**         ind_tfunc_buckets_elems;                  // pointer to bucket array
    i32                   ind_tfunc_buckets_n;                      // number of elements in bucket array
    i32                   ind_tfunc_n;                              // number of elements in the hash table
    amc::FGen*            gen_lary[32];                             // level array
    i32                   gen_n;                                    // number of elements in array
    amc::FNs*             c_curns;                                  // optional pointer
    amc::FFregx*          fregx_lary[32];                           // level array
    i32                   fregx_n;                                  // number of elements in array
    u128                  tclass_data[sizeu128(amc::FTclass,49)];   // place for data
    i32                   tclass_n;                                 // number of elems current in existence
    enum { tclass_max = 49 };
    amc::FTclass**        ind_tclass_buckets_elems;                 // pointer to bucket array
    i32                   ind_tclass_buckets_n;                     // number of elements in bucket array
    i32                   ind_tclass_n;                             // number of elements in the hash table
    amc::FFcmp*           fcmp_lary[32];                            // level array
    i32                   fcmp_n;                                   // number of elements in array
    amc::FFcast*          fcast_lary[32];                           // level array
    i32                   fcast_n;                                  // number of elements in array
    amc::FNoxref*         noxref_lary[32];                          // level array
    i32                   noxref_n;                                 // number of elements in array
    amc::FNocascdel*      nocascdel_lary[32];                       // level array
    i32                   nocascdel_n;                              // number of elements in array
    amc::FCafter*         cafter_lary[32];                          // level array
    i32                   cafter_n;                                 // number of elements in array
    amc::FCsize*          csize_lary[32];                           // level array
    i32                   csize_n;                                  // number of elements in array
    amc::FNsx*            nsx_lary[32];                             // level array
    i32                   nsx_n;                                    // number of elements in array
    report::amc           report;                                   //
    amc::FFcompact*       fcompact_lary[32];                        // level array
    i32                   fcompact_n;                               // number of elements in array
    amc::FFindrem*        findrem_lary[32];                         // level array
    i32                   findrem_n;                                // number of elements in array
    amc::FTcursor*        tcursor_lary[32];                         // level array
    i32                   tcursor_n;                                // number of elements in array
    amc::FFcurs*          fcurs_lary[32];                           // level array
    i32                   fcurs_n;                                  // number of elements in array
    amc::FCdflt*          cdflt_lary[32];                           // level array
    i32                   cdflt_n;                                  // number of elements in array
    amc::FArgvtype*       argvtype_lary[32];                        // level array
    i32                   argvtype_n;                               // number of elements in array
    amc::FFcmdline*       fcmdline_lary[32];                        // level array
    i32                   fcmdline_n;                               // number of elements in array
    amc::FMain**          ind_main_buckets_elems;                   // pointer to bucket array
    i32                   ind_main_buckets_n;                       // number of elements in bucket array
    i32                   ind_main_n;                               // number of elements in the hash table
    amc::FFloadtuples*    floadtuples_lary[32];                     // level array
    i32                   floadtuples_n;                            // number of elements in array
    amc::FFcmap*          fcmap_lary[32];                           // level array
    i32                   fcmap_n;                                  // number of elements in array
    u32                   lim_ind_func;                             //   0  Limit for ind_func table, used to enforce function creation
    amc::FField*          zs_ordkeyfield_head;                      // zero-terminated singly linked list
    amc::FField*          zs_ordkeyfield_tail;                      // pointer to last element
    algo_lib::FLockfile   lockfile;                                 // Prevent concurrent execution
    amc::FNsproto*        nsproto_lary[32];                         // level array
    i32                   nsproto_n;                                // number of elements in array
    amc::FNsdb*           nsdb_lary[32];                            // level array
    i32                   nsdb_n;                                   // number of elements in array
    amc::FSubstr*         zd_substr_params_head;                    // zero-terminated doubly linked list
    i32                   zd_substr_params_n;                       // zero-terminated doubly linked list
    amc::FSubstr*         zd_substr_params_tail;                    // pointer to last element
    amc::FFconst**        ind_fconst_int_buckets_elems;             // pointer to bucket array
    i32                   ind_fconst_int_buckets_n;                 // number of elements in bucket array
    i32                   ind_fconst_int_n;                         // number of elements in the hash table
    amc::FFprefix*        fprefix_lary[32];                         // level array
    i32                   fprefix_n;                                // number of elements in array
    amc::FFprefix**       ind_prefix_buckets_elems;                 // pointer to bucket array
    i32                   ind_prefix_buckets_n;                     // number of elements in bucket array
    i32                   ind_prefix_n;                             // number of elements in the hash table
    amc::FFtrace*         ftrace_lary[32];                          // level array
    i32                   ftrace_n;                                 // number of elements in array
    amc::FNs*             c_ns;                                     // optional pointer
    amc::FFnoremove*      fnoremove_lary[32];                       // level array
    i32                   fnoremove_n;                              // number of elements in array
    amc::FSubstr**        c_substr_field_elems;                     // array of pointers
    u32                   c_substr_field_n;                         // array of pointers
    u32                   c_substr_field_max;                       // capacity of allocated array
    amc::FCtypelen*       ctypelen_lary[32];                        // level array
    i32                   ctypelen_n;                               // number of elements in array
    amc::FCtypelen**      c_ctypelen_elems;                         // array of pointers
    u32                   c_ctypelen_n;                             // array of pointers
    u32                   c_ctypelen_max;                           // capacity of allocated array
    amc::FCtype*          c_u64;                                    // optional pointer
    amc::FField**         c_tempfield_elems;                        // array of pointers
    u32                   c_tempfield_n;                            // array of pointers
    u32                   c_tempfield_max;                          // capacity of allocated array
    amc::FFbase*          fbase_lary[32];                           // level array
    i32                   fbase_n;                                  // number of elements in array
    amc::FFcmap**         ind_fcmap_buckets_elems;                  // pointer to bucket array
    i32                   ind_fcmap_buckets_n;                      // number of elements in bucket array
    i32                   ind_fcmap_n;                              // number of elements in the hash table
    amc::FNossimfile*     nossimfile_lary[32];                      // level array
    i32                   nossimfile_n;                             // number of elements in array
    amc::FGsymbol*        gsymbol_lary[32];                         // level array
    i32                   gsymbol_n;                                // number of elements in array
    amc::FSortfld*        sortfld_lary[32];                         // level array
    i32                   sortfld_n;                                // number of elements in array
    amc::FCget*           cget_lary[32];                            // level array
    i32                   cget_n;                                   // number of elements in array
    amc::FFunc*           cd_temp_func_head;                        // zero-terminated doubly linked list
    i32                   cd_temp_func_n;                           // zero-terminated doubly linked list
    amc::FCdecl*          cdecl_lary[32];                           // level array
    i32                   cdecl_n;                                  // number of elements in array
    amc::FGen*            zs_gen_perns_head;                        // zero-terminated singly linked list
    amc::FGen*            zs_gen_perns_tail;                        // pointer to last element
    amc::FHook*           hook_lary[32];                            // level array
    i32                   hook_n;                                   // number of elements in array
    amc::FCharset*        charset_lary[32];                         // level array
    i32                   charset_n;                                // number of elements in array
    algo::Charset         ValidRnumPad;                             //
    amc::FNsinclude*      nsinclude_lary[32];                       // level array
    i32                   nsinclude_n;                              // number of elements in array
    amc::FSsimvolatile*   ssimvolatile_lary[32];                    // level array
    i32                   ssimvolatile_n;                           // number of elements in array
    amc::FFunique*        funique_lary[32];                         // level array
    i32                   funique_n;                                // number of elements in array
    amc::trace            trace;                                    //
};

// Free block of memory previously returned by Lpool.
void                 lpool_FreeMem(void *mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is 16-byte aligned
void*                lpool_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
bool                 lpool_ReserveBuffers(int nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// New memory is always allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL: old memory untouched
void*                lpool_ReallocMem(void *oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFsort&         fsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFsort*         fsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFsort*         fsort_InsertMaybe(const dmmeta::Fsort &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fsort_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fsort_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFsort*         fsort_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFsort*         fsort_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fsort_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFsort&         fsort_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fsort_XrefMaybe(amc::FFsort &row);

// Return true if hash is empty
bool                 ind_cfmt_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FCfmt*          ind_cfmt_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCfmt&          ind_cfmt_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_cfmt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_cfmt_InsertMaybe(amc::FCfmt& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_cfmt_Remove(amc::FCfmt& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_cfmt_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispfilter&    dispfilter_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispfilter*    dispfilter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispfilter*    dispfilter_InsertMaybe(const dmmeta::Dispfilter &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                dispfilter_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 dispfilter_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispfilter*    dispfilter_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FDispfilter*    dispfilter_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  dispfilter_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 dispfilter_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FDispfilter&    dispfilter_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 dispfilter_XrefMaybe(amc::FDispfilter &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FUsertracefld&  usertracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FUsertracefld*  usertracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FUsertracefld*  usertracefld_InsertMaybe(const dmmeta::Usertracefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                usertracefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 usertracefld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FUsertracefld*  usertracefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FUsertracefld*  usertracefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  usertracefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 usertracefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FUsertracefld&  usertracefld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 usertracefld_XrefMaybe(amc::FUsertracefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCfmt&          cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCfmt*          cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCfmt*          cfmt_InsertMaybe(const dmmeta::Cfmt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cfmt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cfmt_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCfmt*          cfmt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCfmt*          cfmt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cfmt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cfmt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCfmt&          cfmt_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cfmt_XrefMaybe(amc::FCfmt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispatch&      dispatch_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispatch*      dispatch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispatch*      dispatch_InsertMaybe(const dmmeta::Dispatch &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                dispatch_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 dispatch_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispatch*      dispatch_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FDispatch*      dispatch_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  dispatch_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 dispatch_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FDispatch&      dispatch_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 dispatch_XrefMaybe(amc::FDispatch &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispatchmsg&   dispatch_msg_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispatchmsg*   dispatch_msg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispatchmsg*   dispatch_msg_InsertMaybe(const dmmeta::DispatchMsg &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                dispatch_msg_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 dispatch_msg_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispatchmsg*   dispatch_msg_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FDispatchmsg*   dispatch_msg_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  dispatch_msg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 dispatch_msg_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FDispatchmsg&   dispatch_msg_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 dispatch_msg_XrefMaybe(amc::FDispatchmsg &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCtype*         ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ctype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtype*         ctype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCtype*         ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCtype&         ctype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ctype_XrefMaybe(amc::FCtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FField*         field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 field_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FField*         field_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FField*         field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FField&         field_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 field_XrefMaybe(amc::FField &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FBasepool&      basepool_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FBasepool*      basepool_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FBasepool*      basepool_InsertMaybe(const dmmeta::Basepool &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                basepool_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 basepool_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FBasepool*      basepool_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FBasepool*      basepool_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  basepool_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 basepool_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FBasepool&      basepool_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 basepool_XrefMaybe(amc::FBasepool &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FLlist&         llist_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FLlist*         llist_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FLlist*         llist_InsertMaybe(const dmmeta::Llist &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                llist_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 llist_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FLlist*         llist_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FLlist*         llist_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  llist_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 llist_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FLlist&         llist_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 llist_XrefMaybe(amc::FLlist &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FAnonfld*       anonfld_InsertMaybe(const dmmeta::Anonfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                anonfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 anonfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FAnonfld*       anonfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FAnonfld*       anonfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  anonfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 anonfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FAnonfld&       anonfld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 anonfld_XrefMaybe(amc::FAnonfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FXref&          xref_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FXref*          xref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FXref*          xref_InsertMaybe(const dmmeta::Xref &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                xref_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 xref_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FXref*          xref_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FXref*          xref_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  xref_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 xref_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FXref&          xref_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 xref_XrefMaybe(amc::FXref &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNs&            ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNs*            ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNs*            ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ns_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNs*            ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNs*            ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNs&            ns_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ns_XrefMaybe(amc::FNs &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPnew&          pnew_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FPnew*          pnew_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPnew*          pnew_InsertMaybe(const dmmeta::Pnew &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                pnew_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 pnew_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FPnew*          pnew_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FPnew*          pnew_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  pnew_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 pnew_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FPnew&          pnew_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 pnew_XrefMaybe(amc::FPnew &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFldoffset&     fldoffset_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFldoffset*     fldoffset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFldoffset*     fldoffset_InsertMaybe(const dmmeta::Fldoffset &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fldoffset_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fldoffset_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFldoffset*     fldoffset_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFldoffset*     fldoffset_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fldoffset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fldoffset_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFldoffset&     fldoffset_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fldoffset_XrefMaybe(amc::FFldoffset &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTypefld&       typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTypefld*       typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTypefld*       typefld_InsertMaybe(const dmmeta::Typefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                typefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 typefld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTypefld*       typefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTypefld*       typefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  typefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 typefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTypefld&       typefld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 typefld_XrefMaybe(amc::FTypefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FLenfld&        lenfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FLenfld*        lenfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FLenfld*        lenfld_InsertMaybe(const dmmeta::Lenfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                lenfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 lenfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FLenfld*        lenfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FLenfld*        lenfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  lenfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 lenfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FLenfld&        lenfld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 lenfld_XrefMaybe(amc::FLenfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FBltin*         bltin_InsertMaybe(const amcdb::Bltin &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                bltin_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 bltin_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FBltin*         bltin_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FBltin*         bltin_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  bltin_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 bltin_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FBltin&         bltin_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 bltin_XrefMaybe(amc::FBltin &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FStatictuple&   static_tuple_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FStatictuple*   static_tuple_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                static_tuple_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 static_tuple_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FStatictuple*   static_tuple_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FStatictuple*   static_tuple_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  static_tuple_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 static_tuple_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 static_tuple_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FStatictuple&   static_tuple_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 static_tuple_XrefMaybe(amc::FStatictuple &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FMsgtype&       msgtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FMsgtype*       msgtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FMsgtype*       msgtype_InsertMaybe(const dmmeta::Msgtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                msgtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 msgtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FMsgtype*       msgtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FMsgtype*       msgtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  msgtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 msgtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FMsgtype&       msgtype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 msgtype_XrefMaybe(amc::FMsgtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGconst&        gconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FGconst*        gconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGconst*        gconst_InsertMaybe(const dmmeta::Gconst &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gconst_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gconst_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGconst*        gconst_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FGconst*        gconst_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gconst_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 gconst_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FGconst&        gconst_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 gconst_XrefMaybe(amc::FGconst &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGstatic&       gstatic_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FGstatic*       gstatic_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGstatic*       gstatic_InsertMaybe(const dmmeta::Gstatic &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gstatic_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gstatic_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGstatic*       gstatic_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FGstatic*       gstatic_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gstatic_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 gstatic_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FGstatic&       gstatic_qFind(u32 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 gstatic_XrefMaybe(amc::FGstatic &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FThash&         thash_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FThash*         thash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FThash*         thash_InsertMaybe(const dmmeta::Thash &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                thash_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 thash_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FThash*         thash_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FThash*         thash_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  thash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 thash_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FThash&         thash_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 thash_XrefMaybe(amc::FThash &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FOutfile&       outfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FOutfile*       outfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
void                 outfile_Delete(amc::FOutfile &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
void*                outfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
void                 outfile_FreeMem(amc::FOutfile &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
u64                  outfile_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
u64                  outfile_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 outfile_XrefMaybe(amc::FOutfile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFunc&          func_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFunc*          func_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFunc*          func_InsertMaybe(const dmmeta::Func &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                func_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 func_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFunc*          func_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFunc*          func_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  func_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 func_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFunc&          func_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 func_XrefMaybe(amc::FFunc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSmallstr*      smallstr_InsertMaybe(const dmmeta::Smallstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                smallstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 smallstr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FSmallstr*      smallstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FSmallstr*      smallstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  smallstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 smallstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FSmallstr&      smallstr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 smallstr_XrefMaybe(amc::FSmallstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNumstr&        numstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNumstr*        numstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNumstr*        numstr_InsertMaybe(const dmmeta::Numstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                numstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 numstr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNumstr*        numstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNumstr*        numstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  numstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 numstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNumstr&        numstr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 numstr_XrefMaybe(amc::FNumstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FMain&          main_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FMain*          main_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FMain*          main_InsertMaybe(const dmmeta::Main &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                main_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 main_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FMain*          main_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FMain*          main_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  main_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 main_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FMain&          main_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 main_XrefMaybe(amc::FMain &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FReftype&       reftype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FReftype*       reftype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FReftype*       reftype_InsertMaybe(const dmmeta::Reftype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                reftype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 reftype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FReftype*       reftype_Find(dmmeta::ReftypeId t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FReftype*       reftype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  reftype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 reftype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 reftype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FReftype&       reftype_qFind(dmmeta::ReftypeId t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 reftype_XrefMaybe(amc::FReftype &row);

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Save ssim data to given directory.
u32                  SaveTuples(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 _db_XrefMaybe();

// Return true if hash is empty
bool                 ind_bltin_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FBltin*         ind_bltin_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FBltin&         ind_bltin_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_bltin_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_bltin_InsertMaybe(amc::FBltin& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_bltin_Remove(amc::FBltin& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_bltin_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FCtype*         ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCtype&         ind_ctype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ctype_InsertMaybe(amc::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ctype_Remove(amc::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_dispatch_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FDispatch*      ind_dispatch_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FDispatch&      ind_dispatch_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_dispatch_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_dispatch_InsertMaybe(amc::FDispatch& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_dispatch_Remove(amc::FDispatch& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_dispatch_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_func_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFunc*          ind_func_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFunc&          ind_func_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_func_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_func_InsertMaybe(amc::FFunc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_func_Remove(amc::FFunc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_func_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FField*         ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_field_InsertMaybe(amc::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_field_Remove(amc::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FNs*            ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FNs&            ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ns_InsertMaybe(amc::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ns_Remove(amc::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_pnew_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FPnew*          ind_pnew_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FPnew&          ind_pnew_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_pnew_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_pnew_InsertMaybe(amc::FPnew& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_pnew_Remove(amc::FPnew& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_pnew_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_xref_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FXref*          ind_xref_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FXref&          ind_xref_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_xref_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_xref_InsertMaybe(amc::FXref& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_xref_Remove(amc::FXref& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_xref_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCpptype&       cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCpptype*       cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCpptype*       cpptype_InsertMaybe(const dmmeta::Cpptype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cpptype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cpptype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCpptype*       cpptype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCpptype*       cpptype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cpptype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cpptype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCpptype&       cpptype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cpptype_XrefMaybe(amc::FCpptype &row);

// Return true if hash is empty
bool                 ind_cpptype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FCpptype*       ind_cpptype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCpptype&       ind_cpptype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_cpptype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_cpptype_InsertMaybe(amc::FCpptype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_cpptype_Remove(amc::FCpptype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_cpptype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FInlary&        inlary_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FInlary*        inlary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FInlary*        inlary_InsertMaybe(const dmmeta::Inlary &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                inlary_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 inlary_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FInlary*        inlary_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FInlary*        inlary_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  inlary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 inlary_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FInlary&        inlary_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 inlary_XrefMaybe(amc::FInlary &row);

// Return true if hash is empty
bool                 ind_inlary_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FInlary*        ind_inlary_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FInlary&        ind_inlary_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_inlary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_inlary_InsertMaybe(amc::FInlary& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_inlary_Remove(amc::FInlary& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_inlary_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTary&          tary_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTary*          tary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTary*          tary_InsertMaybe(const dmmeta::Tary &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tary_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tary_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTary*          tary_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTary*          tary_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 tary_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTary&          tary_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 tary_XrefMaybe(amc::FTary &row);

// Return true if hash is empty
bool                 ind_tary_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FTary*          ind_tary_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTary&          ind_tary_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_tary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_tary_InsertMaybe(amc::FTary& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_tary_Remove(amc::FTary& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_tary_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCppfunc*       cppfunc_InsertMaybe(const dmmeta::Cppfunc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cppfunc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cppfunc_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCppfunc*       cppfunc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCppfunc*       cppfunc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cppfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cppfunc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCppfunc&       cppfunc_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cppfunc_XrefMaybe(amc::FCppfunc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FRowid&         rowid_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FRowid*         rowid_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FRowid*         rowid_InsertMaybe(const dmmeta::Rowid &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                rowid_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 rowid_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FRowid*         rowid_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FRowid*         rowid_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  rowid_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 rowid_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FRowid&         rowid_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 rowid_XrefMaybe(amc::FRowid &row);

// Return true if hash is empty
bool                 ind_rowid_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FRowid*         ind_rowid_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FRowid&         ind_rowid_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_rowid_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_rowid_InsertMaybe(amc::FRowid& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_rowid_Remove(amc::FRowid& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_rowid_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCascdel&       cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCascdel*       cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCascdel*       cascdel_InsertMaybe(const dmmeta::Cascdel &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cascdel_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cascdel_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCascdel*       cascdel_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCascdel*       cascdel_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cascdel_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cascdel_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCascdel&       cascdel_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cascdel_XrefMaybe(amc::FCascdel &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSubstr*        substr_InsertMaybe(const dmmeta::Substr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                substr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 substr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FSubstr*        substr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FSubstr*        substr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  substr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 substr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FSubstr&        substr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 substr_XrefMaybe(amc::FSubstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FBitfld&        bitfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FBitfld*        bitfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FBitfld*        bitfld_InsertMaybe(const dmmeta::Bitfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                bitfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 bitfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FBitfld*        bitfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FBitfld*        bitfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  bitfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 bitfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FBitfld&        bitfld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 bitfld_XrefMaybe(amc::FBitfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSsimfile*      ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FSsimfile*      ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FSsimfile*      ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FSsimfile&      ssimfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ssimfile_XrefMaybe(amc::FSsimfile &row);

// Return true if hash is empty
bool                 ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FSsimfile*      ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FSsimfile&      ind_ssimfile_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ssimfile_InsertMaybe(amc::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ssimfile_Remove(amc::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPack&          pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FPack*          pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPack*          pack_InsertMaybe(const dmmeta::Pack &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                pack_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 pack_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FPack*          pack_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FPack*          pack_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  pack_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 pack_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FPack&          pack_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 pack_XrefMaybe(amc::FPack &row);

// Return true if hash is empty
bool                 ind_pack_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FPack*          ind_pack_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FPack&          ind_pack_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_pack_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_pack_InsertMaybe(amc::FPack& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_pack_Remove(amc::FPack& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_pack_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_smallstr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FSmallstr*      ind_smallstr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FSmallstr&      ind_smallstr_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_smallstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_smallstr_InsertMaybe(amc::FSmallstr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_smallstr_Remove(amc::FSmallstr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_smallstr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPtrary&        ptrary_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FPtrary*        ptrary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPtrary*        ptrary_InsertMaybe(const dmmeta::Ptrary &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ptrary_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ptrary_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FPtrary*        ptrary_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FPtrary*        ptrary_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ptrary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ptrary_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FPtrary&        ptrary_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ptrary_XrefMaybe(amc::FPtrary &row);

// Return true if index is empty
bool                 c_ctype_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtype*         c_ctype_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FCtype*> c_ctype_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ctype_sorted_Insert(amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_ctype_sorted_ScanInsertMaybe(amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ctype_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ctype_sorted_Remove(amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ctype_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ctype_sorted_Reserve(u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_ctype_sorted_SortedQ() __attribute__((nothrow));
// Insertion sort
void                 c_ctype_sorted_InsertionSort() __attribute__((nothrow));
// Heap sort
void                 c_ctype_sorted_HeapSort() __attribute__((nothrow));
// Quick sort
void                 c_ctype_sorted_QuickSort() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FEnumstr&       enumstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FEnumstr*       enumstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                enumstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 enumstr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FEnumstr*       enumstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FEnumstr*       enumstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  enumstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 enumstr_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 enumstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FEnumstr&       enumstr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 enumstr_XrefMaybe(amc::FEnumstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FEnumstrLen&    enumstr_len_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FEnumstrLen*    enumstr_len_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                enumstr_len_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 enumstr_len_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FEnumstrLen*    enumstr_len_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FEnumstrLen*    enumstr_len_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  enumstr_len_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 enumstr_len_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 enumstr_len_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FEnumstrLen&    enumstr_len_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 enumstr_len_XrefMaybe(amc::FEnumstrLen &row);

// Remove all elements from heap and free memory used by the array.
void                 bh_enumstr_len_Dealloc() __attribute__((nothrow));
// Return true if index is empty
bool                 bh_enumstr_len_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FEnumstrLen*    bh_enumstr_len_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_enumstr_len_InBheapQ(amc::FEnumstrLen& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_enumstr_len_Insert(amc::FEnumstrLen& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_enumstr_len_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_enumstr_len_Reheap(amc::FEnumstrLen& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_enumstr_len_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_enumstr_len_Remove(amc::FEnumstrLen& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_enumstr_len_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
amc::FEnumstrLen*    bh_enumstr_len_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_enumstr_len_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_enumstr_len_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FEnumstrLen*    ind_enumstr_len_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FEnumstrLen&    ind_enumstr_len_GetOrCreate(i32 key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_enumstr_len_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_enumstr_len_InsertMaybe(amc::FEnumstrLen& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_enumstr_len_Remove(amc::FEnumstrLen& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_enumstr_len_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_enumstr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FEnumstr*       ind_enumstr_Find(const amc::Enumstr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FEnumstr&       ind_enumstr_GetOrCreate(const amc::Enumstr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_enumstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_enumstr_InsertMaybe(amc::FEnumstr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_enumstr_Remove(amc::FEnumstr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_enumstr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbitset&       fbitset_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbitset*       fbitset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbitset*       fbitset_InsertMaybe(const dmmeta::Fbitset &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fbitset_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fbitset_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFbitset*       fbitset_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFbitset*       fbitset_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fbitset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fbitset_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFbitset&       fbitset_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fbitset_XrefMaybe(amc::FFbitset &row);

// Return true if hash is empty
bool                 ind_fbitset_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFbitset*       ind_fbitset_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFbitset&       ind_fbitset_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fbitset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fbitset_InsertMaybe(amc::FFbitset& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fbitset_Remove(amc::FFbitset& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fbitset_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcleanup&      fcleanup_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcleanup*      fcleanup_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcleanup*      fcleanup_InsertMaybe(const dmmeta::Fcleanup &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcleanup_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcleanup_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcleanup*      fcleanup_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcleanup*      fcleanup_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcleanup_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcleanup_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcleanup&      fcleanup_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcleanup_XrefMaybe(amc::FFcleanup &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFdec&          fdec_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFdec*          fdec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFdec*          fdec_InsertMaybe(const dmmeta::Fdec &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fdec_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fdec_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFdec*          fdec_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFdec*          fdec_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fdec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fdec_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFdec&          fdec_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fdec_XrefMaybe(amc::FFdec &row);

// Return true if hash is empty
bool                 ind_fdec_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFdec*          ind_fdec_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFdec&          ind_fdec_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fdec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fdec_InsertMaybe(amc::FFdec& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fdec_Remove(amc::FFdec& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fdec_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_reftype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FReftype*       ind_reftype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FReftype&       ind_reftype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_reftype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_reftype_InsertMaybe(amc::FReftype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_reftype_Remove(amc::FReftype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_reftype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFconst&        fconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFconst*        fconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFconst*        fconst_InsertMaybe(const dmmeta::Fconst &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fconst_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fconst_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFconst*        fconst_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFconst*        fconst_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fconst_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fconst_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFconst&        fconst_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fconst_XrefMaybe(amc::FFconst &row);

// Return true if hash is empty
bool                 ind_fconst_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFconst*        ind_fconst_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFconst&        ind_fconst_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fconst_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fconst_InsertMaybe(amc::FFconst& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fconst_Remove(amc::FFconst& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fconst_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_ns_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNs*            c_ns_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FNs*> c_ns_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ns_sorted_Insert(amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_ns_sorted_ScanInsertMaybe(amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ns_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ns_sorted_Remove(amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ns_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ns_sorted_Reserve(u32 n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFinput&        finput_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFinput*        finput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFinput*        finput_InsertMaybe(const dmmeta::Finput &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                finput_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 finput_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFinput*        finput_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFinput*        finput_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  finput_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 finput_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFinput&        finput_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 finput_XrefMaybe(amc::FFinput &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFoutput&       foutput_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFoutput*       foutput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFoutput*       foutput_InsertMaybe(const dmmeta::Foutput &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                foutput_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 foutput_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFoutput*       foutput_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFoutput*       foutput_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  foutput_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 foutput_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFoutput&       foutput_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 foutput_XrefMaybe(amc::FFoutput &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbuf&          fbuf_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbuf*          fbuf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbuf*          fbuf_InsertMaybe(const dmmeta::Fbuf &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fbuf_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fbuf_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFbuf*          fbuf_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFbuf*          fbuf_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fbuf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fbuf_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFbuf&          fbuf_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fbuf_XrefMaybe(amc::FFbuf &row);

// Return true if hash is empty
bool                 ind_fbuf_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFbuf*          ind_fbuf_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFbuf&          ind_fbuf_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fbuf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fbuf_InsertMaybe(amc::FFbuf& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fbuf_Remove(amc::FFbuf& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fbuf_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FChash&         chash_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FChash*         chash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FChash*         chash_InsertMaybe(const dmmeta::Chash &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                chash_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 chash_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FChash*         chash_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FChash*         chash_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  chash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 chash_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FChash&         chash_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 chash_XrefMaybe(amc::FChash &row);

// Return true if hash is empty
bool                 ind_chash_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FChash*         ind_chash_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FChash&         ind_chash_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_chash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_chash_InsertMaybe(amc::FChash& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_chash_Remove(amc::FChash& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_chash_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCcmp&          ccmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCcmp*          ccmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCcmp*          ccmp_InsertMaybe(const dmmeta::Ccmp &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ccmp_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ccmp_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCcmp*          ccmp_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCcmp*          ccmp_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ccmp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ccmp_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCcmp&          ccmp_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ccmp_XrefMaybe(amc::FCcmp &row);

// Return true if hash is empty
bool                 ind_ccmp_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FCcmp*          ind_ccmp_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FCcmp&          ind_ccmp_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_ccmp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_ccmp_InsertMaybe(amc::FCcmp& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_ccmp_Remove(amc::FCcmp& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_ccmp_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbigend&       fbigend_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbigend*       fbigend_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbigend*       fbigend_InsertMaybe(const dmmeta::Fbigend &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fbigend_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fbigend_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFbigend*       fbigend_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFbigend*       fbigend_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fbigend_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fbigend_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFbigend&       fbigend_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fbigend_XrefMaybe(amc::FFbigend &row);

// Return true if index is empty
bool                 zsl_ctype_pack_tran_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FCtype*         zsl_ctype_pack_tran_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zsl_ctype_pack_tran_InLlistQ(amc::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zsl_ctype_pack_tran_Insert(amc::FCtype& row) __attribute__((nothrow));
// Return pointer to next element in the list
amc::FCtype*         zsl_ctype_pack_tran_Next(amc::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zsl_ctype_pack_tran_Remove(amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zsl_ctype_pack_tran_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCtype*         zsl_ctype_pack_tran_RemoveFirst() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCstr&          cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCstr*          cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCstr*          cstr_InsertMaybe(const dmmeta::Cstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cstr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCstr*          cstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCstr*          cstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCstr&          cstr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cstr_XrefMaybe(amc::FCstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FListtype&      listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FListtype*      listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FListtype*      listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 listtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FListtype*      listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FListtype*      listtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FListtype&      listtype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 listtype_XrefMaybe(amc::FListtype &row);

// Return true if hash is empty
bool                 ind_listtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FListtype*      ind_listtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FListtype&      ind_listtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_listtype_InsertMaybe(amc::FListtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_listtype_Remove(amc::FListtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_listtype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFstep&         fstep_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFstep*         fstep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFstep*         fstep_InsertMaybe(const dmmeta::Fstep &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fstep_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fstep_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFstep*         fstep_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFstep*         fstep_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fstep_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fstep_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFstep&         fstep_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fstep_XrefMaybe(amc::FFstep &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCextern&       cextern_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCextern*       cextern_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCextern*       cextern_InsertMaybe(const dmmeta::Cextern &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cextern_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cextern_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCextern*       cextern_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCextern*       cextern_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cextern_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cextern_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCextern&       cextern_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cextern_XrefMaybe(amc::FCextern &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFdelay&        fdelay_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFdelay*        fdelay_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFdelay*        fdelay_InsertMaybe(const dmmeta::Fdelay &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fdelay_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fdelay_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFdelay*        fdelay_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFdelay*        fdelay_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fdelay_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fdelay_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFdelay&        fdelay_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fdelay_XrefMaybe(amc::FFdelay &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDisptrace&     disptrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FDisptrace*     disptrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDisptrace*     disptrace_InsertMaybe(const dmmeta::Disptrace &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                disptrace_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 disptrace_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDisptrace*     disptrace_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FDisptrace*     disptrace_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  disptrace_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 disptrace_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FDisptrace&     disptrace_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 disptrace_XrefMaybe(amc::FDisptrace &row);

// Return true if hash is empty
bool                 ind_fstep_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFstep*         ind_fstep_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFstep&         ind_fstep_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fstep_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fstep_InsertMaybe(amc::FFstep& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fstep_Remove(amc::FFstep& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fstep_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTracefld&      tracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTracefld*      tracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTracefld*      tracefld_InsertMaybe(const dmmeta::Tracefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tracefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tracefld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTracefld*      tracefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTracefld*      tracefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tracefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 tracefld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tracefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTracefld&      tracefld_qFind(u64 t) __attribute__((nothrow));
// Save table to ssimfile
bool                 tracefld_SaveSsimfile(strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 tracefld_XrefMaybe(amc::FTracefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTracerec&      tracerec_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTracerec*      tracerec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTracerec*      tracerec_InsertMaybe(const dmmeta::Tracerec &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tracerec_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tracerec_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTracerec*      tracerec_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTracerec*      tracerec_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tracerec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 tracerec_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tracerec_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTracerec&      tracerec_qFind(u64 t) __attribute__((nothrow));
// Save table to ssimfile
bool                 tracerec_SaveSsimfile(strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 tracerec_XrefMaybe(amc::FTracerec &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispsig&       dispsig_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispsig*       dispsig_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispsig*       dispsig_InsertMaybe(const dmmeta::Dispsig &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                dispsig_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 dispsig_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispsig*       dispsig_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FDispsig*       dispsig_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  dispsig_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 dispsig_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 dispsig_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FDispsig&       dispsig_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 dispsig_XrefMaybe(amc::FDispsig &row);

// Return true if index is empty
bool                 c_dispsig_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispsig*       c_dispsig_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FDispsig*> c_dispsig_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_dispsig_sorted_Insert(amc::FDispsig& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_dispsig_sorted_InsertMaybe(amc::FDispsig& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_dispsig_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_dispsig_sorted_Remove(amc::FDispsig& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_dispsig_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_dispsig_sorted_Reserve(u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_dispsig_sorted_SortedQ() __attribute__((nothrow));
// Insertion sort
void                 c_dispsig_sorted_InsertionSort() __attribute__((nothrow));
// Heap sort
void                 c_dispsig_sorted_HeapSort() __attribute__((nothrow));
// Quick sort
void                 c_dispsig_sorted_QuickSort() __attribute__((nothrow));
// Save table to ssimfile
bool                 c_dispsig_sorted_SaveSsimfile(strptr fname) __attribute__((nothrow));

// Return true if index is empty
bool                 zs_sig_visit_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FCtype*         zs_sig_visit_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_sig_visit_InLlistQ(amc::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_sig_visit_Insert(amc::FCtype& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FCtype*         zs_sig_visit_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FCtype*         zs_sig_visit_Next(amc::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_sig_visit_Remove(amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_sig_visit_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FCtype*         zs_sig_visit_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FCtype&         zs_sig_visit_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTarget&        target_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTarget*        target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTarget*        target_InsertMaybe(const dev::Target &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                target_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 target_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTarget*        target_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTarget*        target_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 target_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTarget&        target_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 target_XrefMaybe(amc::FTarget &row);

// Return true if hash is empty
bool                 ind_target_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FTarget*        ind_target_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTarget&        ind_target_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_target_InsertMaybe(amc::FTarget& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_target_Remove(amc::FTarget& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_target_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTargdep&       targdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTargdep*       targdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTargdep*       targdep_InsertMaybe(const dev::Targdep &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                targdep_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 targdep_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTargdep*       targdep_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTargdep*       targdep_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  targdep_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 targdep_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTargdep&       targdep_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 targdep_XrefMaybe(amc::FTargdep &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FDispctx&       dispctx_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FDispctx*       dispctx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FDispctx*       dispctx_InsertMaybe(const dmmeta::Dispctx &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                dispctx_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 dispctx_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispctx*       dispctx_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FDispctx*       dispctx_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  dispctx_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 dispctx_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FDispctx&       dispctx_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 dispctx_XrefMaybe(amc::FDispctx &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FPmaskfld&      pmaskfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FPmaskfld*      pmaskfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FPmaskfld*      pmaskfld_InsertMaybe(const dmmeta::Pmaskfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                pmaskfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 pmaskfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FPmaskfld*      pmaskfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FPmaskfld*      pmaskfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  pmaskfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 pmaskfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FPmaskfld&      pmaskfld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 pmaskfld_XrefMaybe(amc::FPmaskfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFwddecl&       fwddecl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFwddecl*       fwddecl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFwddecl*       fwddecl_InsertMaybe(const dmmeta::Fwddecl &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fwddecl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fwddecl_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFwddecl*       fwddecl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFwddecl*       fwddecl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fwddecl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fwddecl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFwddecl&       fwddecl_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fwddecl_XrefMaybe(amc::FFwddecl &row);

// Return true if hash is empty
bool                 ind_fwddecl_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFwddecl*       ind_fwddecl_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFwddecl&       ind_fwddecl_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fwddecl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fwddecl_InsertMaybe(amc::FFwddecl& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fwddecl_Remove(amc::FFwddecl& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fwddecl_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTfunc&         tfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTfunc*         tfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTfunc*         tfunc_InsertMaybe(const amcdb::Tfunc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tfunc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tfunc_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTfunc*         tfunc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTfunc*         tfunc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 tfunc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tfunc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTfunc&         tfunc_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 tfunc_XrefMaybe(amc::FTfunc &row);

// Return true if hash is empty
bool                 ind_tfunc_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FTfunc*         ind_tfunc_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTfunc&         ind_tfunc_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_tfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_tfunc_InsertMaybe(amc::FTfunc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_tfunc_Remove(amc::FTfunc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_tfunc_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGen&           gen_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FGen*           gen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGen*           gen_InsertMaybe(const amcdb::Gen &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gen_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gen_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGen*           gen_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FGen*           gen_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gen_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gen_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gen_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FGen&           gen_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 gen_XrefMaybe(amc::FGen &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFregx&         fregx_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFregx*         fregx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFregx*         fregx_InsertMaybe(const dmmeta::Fregx &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fregx_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fregx_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFregx*         fregx_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFregx*         fregx_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fregx_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fregx_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFregx&         fregx_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fregx_XrefMaybe(amc::FFregx &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTclass&        tclass_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTclass*        tclass_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTclass*        tclass_InsertMaybe(const amcdb::Tclass &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tclass_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tclass_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTclass*        tclass_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<amc::FTclass> tclass_Getary() __attribute__((nothrow));
// Return constant 49 -- max. number of items in the pool
i32                  tclass_Max() __attribute__((nothrow));
// Return number of items in the array
i32                  tclass_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
void                 tclass_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 tclass_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
amc::FTclass&        tclass_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
u64                  tclass_rowid_Get(amc::FTclass &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 tclass_XrefMaybe(amc::FTclass &row);

// Return true if hash is empty
bool                 ind_tclass_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FTclass*        ind_tclass_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FTclass&        ind_tclass_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_tclass_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_tclass_InsertMaybe(amc::FTclass& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_tclass_Remove(amc::FTclass& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_tclass_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcmp&          fcmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcmp*          fcmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcmp*          fcmp_InsertMaybe(const dmmeta::Fcmp &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcmp_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcmp_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcmp*          fcmp_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcmp*          fcmp_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcmp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcmp_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcmp&          fcmp_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcmp_XrefMaybe(amc::FFcmp &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcast&         fcast_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcast*         fcast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcast*         fcast_InsertMaybe(const dmmeta::Fcast &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcast_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcast_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcast*         fcast_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcast*         fcast_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcast_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcast_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcast&         fcast_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcast_XrefMaybe(amc::FFcast &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNoxref&        noxref_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNoxref*        noxref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNoxref*        noxref_InsertMaybe(const dmmeta::Noxref &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                noxref_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 noxref_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNoxref*        noxref_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNoxref*        noxref_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  noxref_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 noxref_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNoxref&        noxref_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 noxref_XrefMaybe(amc::FNoxref &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNocascdel&     nocascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNocascdel*     nocascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNocascdel*     nocascdel_InsertMaybe(const dmmeta::Nocascdel &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nocascdel_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nocascdel_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNocascdel*     nocascdel_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNocascdel*     nocascdel_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nocascdel_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 nocascdel_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNocascdel&     nocascdel_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 nocascdel_XrefMaybe(amc::FNocascdel &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCafter&        cafter_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCafter*        cafter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCafter*        cafter_InsertMaybe(const dmmeta::Cafter &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cafter_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cafter_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCafter*        cafter_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCafter*        cafter_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cafter_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cafter_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCafter&        cafter_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cafter_XrefMaybe(amc::FCafter &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCsize&         csize_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCsize*         csize_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCsize*         csize_InsertMaybe(const dmmeta::Csize &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                csize_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 csize_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCsize*         csize_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCsize*         csize_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  csize_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 csize_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCsize&         csize_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 csize_XrefMaybe(amc::FCsize &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsx&           nsx_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsx*           nsx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsx*           nsx_InsertMaybe(const dmmeta::Nsx &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nsx_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nsx_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNsx*           nsx_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNsx*           nsx_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nsx_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 nsx_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNsx&           nsx_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 nsx_XrefMaybe(amc::FNsx &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcompact&      fcompact_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcompact*      fcompact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcompact*      fcompact_InsertMaybe(const dmmeta::Fcompact &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcompact_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcompact_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcompact*      fcompact_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcompact*      fcompact_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcompact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcompact_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcompact&      fcompact_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcompact_XrefMaybe(amc::FFcompact &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFindrem&       findrem_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFindrem*       findrem_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFindrem*       findrem_InsertMaybe(const dmmeta::Findrem &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                findrem_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 findrem_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFindrem*       findrem_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFindrem*       findrem_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  findrem_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 findrem_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFindrem&       findrem_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 findrem_XrefMaybe(amc::FFindrem &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FTcursor&       tcursor_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FTcursor*       tcursor_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FTcursor*       tcursor_InsertMaybe(const amcdb::Tcursor &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                tcursor_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 tcursor_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTcursor*       tcursor_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FTcursor*       tcursor_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  tcursor_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 tcursor_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FTcursor&       tcursor_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 tcursor_XrefMaybe(amc::FTcursor &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcurs&         fcurs_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcurs*         fcurs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcurs*         fcurs_InsertMaybe(const dmmeta::Fcurs &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcurs_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcurs_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcurs*         fcurs_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcurs*         fcurs_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcurs_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcurs_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcurs&         fcurs_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcurs_XrefMaybe(amc::FFcurs &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCdflt*         cdflt_InsertMaybe(const dmmeta::Cdflt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cdflt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cdflt_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCdflt*         cdflt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCdflt*         cdflt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cdflt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cdflt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCdflt&         cdflt_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cdflt_XrefMaybe(amc::FCdflt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FArgvtype&      argvtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FArgvtype*      argvtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FArgvtype*      argvtype_InsertMaybe(const dmmeta::Argvtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                argvtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 argvtype_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FArgvtype*      argvtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FArgvtype*      argvtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  argvtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 argvtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FArgvtype&      argvtype_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 argvtype_XrefMaybe(amc::FArgvtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcmdline&      fcmdline_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcmdline*      fcmdline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcmdline*      fcmdline_InsertMaybe(const dmmeta::Fcmdline &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcmdline_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcmdline_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcmdline*      fcmdline_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcmdline*      fcmdline_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcmdline_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcmdline_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcmdline&      fcmdline_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcmdline_XrefMaybe(amc::FFcmdline &row);

// Return true if hash is empty
bool                 ind_main_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FMain*          ind_main_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FMain&          ind_main_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_main_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_main_InsertMaybe(amc::FMain& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_main_Remove(amc::FMain& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_main_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFloadtuples&   floadtuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFloadtuples*   floadtuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFloadtuples*   floadtuples_InsertMaybe(const dmmeta::Floadtuples &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                floadtuples_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 floadtuples_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFloadtuples*   floadtuples_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFloadtuples*   floadtuples_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  floadtuples_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 floadtuples_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFloadtuples&   floadtuples_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 floadtuples_XrefMaybe(amc::FFloadtuples &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFcmap&         fcmap_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFcmap*         fcmap_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFcmap*         fcmap_InsertMaybe(const dmmeta::Fcmap &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fcmap_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fcmap_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFcmap*         fcmap_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFcmap*         fcmap_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fcmap_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fcmap_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFcmap&         fcmap_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fcmap_XrefMaybe(amc::FFcmap &row);

// Return true if index is empty
bool                 zs_ordkeyfield_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FField*         zs_ordkeyfield_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_ordkeyfield_InLlistQ(amc::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_ordkeyfield_Insert(amc::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FField*         zs_ordkeyfield_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FField*         zs_ordkeyfield_Next(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_ordkeyfield_Remove(amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_ordkeyfield_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FField*         zs_ordkeyfield_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FField&         zs_ordkeyfield_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsproto&       nsproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsproto*       nsproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsproto*       nsproto_InsertMaybe(const dmmeta::Nsproto &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nsproto_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nsproto_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNsproto*       nsproto_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNsproto*       nsproto_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nsproto_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 nsproto_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNsproto&       nsproto_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 nsproto_XrefMaybe(amc::FNsproto &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsdb&          nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsdb*          nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsdb*          nsdb_InsertMaybe(const dmmeta::Nsdb &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nsdb_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nsdb_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNsdb*          nsdb_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNsdb*          nsdb_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nsdb_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 nsdb_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNsdb&          nsdb_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 nsdb_XrefMaybe(amc::FNsdb &row);

// Return true if index is empty
bool                 zd_substr_params_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FSubstr*        zd_substr_params_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_substr_params_InLlistQ(amc::FSubstr& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_substr_params_Insert(amc::FSubstr& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FSubstr*        zd_substr_params_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_substr_params_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FSubstr*        zd_substr_params_Next(amc::FSubstr &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
amc::FSubstr*        zd_substr_params_Prev(amc::FSubstr &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_substr_params_Remove(amc::FSubstr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_substr_params_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FSubstr*        zd_substr_params_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FSubstr&        zd_substr_params_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if hash is empty
bool                 ind_fconst_int_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFconst*        ind_fconst_int_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_fconst_int_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fconst_int_InsertMaybe(amc::FFconst& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fconst_int_Remove(amc::FFconst& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fconst_int_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFprefix&       fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFprefix*       fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFprefix*       fprefix_InsertMaybe(const dmmeta::Fprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fprefix_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFprefix*       fprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFprefix*       fprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFprefix&       fprefix_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fprefix_XrefMaybe(amc::FFprefix &row);

// Return true if hash is empty
bool                 ind_prefix_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFprefix*       ind_prefix_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFprefix&       ind_prefix_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_prefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_prefix_InsertMaybe(amc::FFprefix& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_prefix_Remove(amc::FFprefix& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_prefix_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFtrace&        ftrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFtrace*        ftrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFtrace*        ftrace_InsertMaybe(const dmmeta::Ftrace &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ftrace_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ftrace_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFtrace*        ftrace_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFtrace*        ftrace_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ftrace_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 ftrace_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFtrace&        ftrace_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ftrace_XrefMaybe(amc::FFtrace &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFnoremove&     fnoremove_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFnoremove*     fnoremove_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFnoremove*     fnoremove_InsertMaybe(const dmmeta::Fnoremove &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fnoremove_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fnoremove_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFnoremove*     fnoremove_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFnoremove*     fnoremove_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fnoremove_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 fnoremove_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFnoremove&     fnoremove_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fnoremove_XrefMaybe(amc::FFnoremove &row);

// Return true if index is empty
bool                 c_substr_field_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FSubstr*        c_substr_field_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FSubstr*> c_substr_field_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_substr_field_Insert(amc::FSubstr& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_substr_field_InsertMaybe(amc::FSubstr& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_substr_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_substr_field_Remove(amc::FSubstr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_substr_field_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_substr_field_Reserve(u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_substr_field_SortedQ() __attribute__((nothrow));
// Insertion sort
void                 c_substr_field_InsertionSort() __attribute__((nothrow));
// Heap sort
void                 c_substr_field_HeapSort() __attribute__((nothrow));
// Quick sort
void                 c_substr_field_QuickSort() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCtypelen&      ctypelen_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCtypelen*      ctypelen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCtypelen*      ctypelen_InsertMaybe(const dmmeta::Ctypelen &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ctypelen_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ctypelen_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtypelen*      ctypelen_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCtypelen*      ctypelen_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ctypelen_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 ctypelen_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ctypelen_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCtypelen&      ctypelen_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ctypelen_XrefMaybe(amc::FCtypelen &row);

// Return true if index is empty
bool                 c_ctypelen_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtypelen*      c_ctypelen_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FCtypelen*> c_ctypelen_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ctypelen_Insert(amc::FCtypelen& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_ctypelen_InsertMaybe(amc::FCtypelen& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ctypelen_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ctypelen_Remove(amc::FCtypelen& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ctypelen_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ctypelen_Reserve(u32 n) __attribute__((nothrow));
// Verify whether array is sorted
bool                 c_ctypelen_SortedQ() __attribute__((nothrow));
// Insertion sort
void                 c_ctypelen_InsertionSort() __attribute__((nothrow));
// Heap sort
void                 c_ctypelen_HeapSort() __attribute__((nothrow));
// Quick sort
void                 c_ctypelen_QuickSort() __attribute__((nothrow));
// Save table to ssimfile
bool                 c_ctypelen_SaveSsimfile(strptr fname) __attribute__((nothrow));

// Return true if index is empty
bool                 c_tempfield_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FField*         c_tempfield_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FField*> c_tempfield_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_tempfield_Insert(amc::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_tempfield_InsertMaybe(amc::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_tempfield_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_tempfield_Remove(amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_tempfield_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_tempfield_Reserve(u32 n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFbase&         fbase_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFbase*         fbase_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFbase*         fbase_InsertMaybe(const dmmeta::Fbase &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                fbase_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 fbase_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFbase*         fbase_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFbase*         fbase_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  fbase_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 fbase_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 fbase_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFbase&         fbase_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 fbase_XrefMaybe(amc::FFbase &row);

// Return true if hash is empty
bool                 ind_fcmap_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FFcmap*         ind_fcmap_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
amc::FFcmap&         ind_fcmap_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_fcmap_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_fcmap_InsertMaybe(amc::FFcmap& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_fcmap_Remove(amc::FFcmap& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_fcmap_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNossimfile&    nossimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNossimfile*    nossimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNossimfile*    nossimfile_InsertMaybe(const dmmeta::Nossimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nossimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nossimfile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNossimfile*    nossimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNossimfile*    nossimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nossimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 nossimfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 nossimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNossimfile&    nossimfile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 nossimfile_XrefMaybe(amc::FNossimfile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGsymbol&       gsymbol_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FGsymbol*       gsymbol_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FGsymbol*       gsymbol_InsertMaybe(const dmmeta::Gsymbol &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                gsymbol_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 gsymbol_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGsymbol*       gsymbol_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FGsymbol*       gsymbol_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  gsymbol_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 gsymbol_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 gsymbol_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FGsymbol&       gsymbol_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 gsymbol_XrefMaybe(amc::FGsymbol &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSortfld&       sortfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FSortfld*       sortfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSortfld*       sortfld_InsertMaybe(const dmmeta::Sortfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                sortfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 sortfld_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FSortfld*       sortfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FSortfld*       sortfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  sortfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 sortfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FSortfld&       sortfld_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 sortfld_XrefMaybe(amc::FSortfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCget&          cget_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCget*          cget_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCget*          cget_InsertMaybe(const dmmeta::Cget &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cget_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cget_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCget*          cget_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCget*          cget_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cget_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
void                 cget_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCget&          cget_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cget_XrefMaybe(amc::FCget &row);

// Return true if index is empty
bool                 cd_temp_func_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FFunc*          cd_temp_func_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 cd_temp_func_InLlistQ(amc::FFunc& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 cd_temp_func_Insert(amc::FFunc& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FFunc*          cd_temp_func_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  cd_temp_func_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FFunc*          cd_temp_func_Next(amc::FFunc &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
amc::FFunc*          cd_temp_func_Prev(amc::FFunc &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 cd_temp_func_Remove(amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 cd_temp_func_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FFunc*          cd_temp_func_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
amc::FFunc*          cd_temp_func_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FFunc&          cd_temp_func_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCdecl&         cdecl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCdecl*         cdecl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCdecl*         cdecl_InsertMaybe(const dmmeta::Cdecl &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                cdecl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 cdecl_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCdecl*         cdecl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCdecl*         cdecl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  cdecl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 cdecl_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 cdecl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCdecl&         cdecl_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 cdecl_XrefMaybe(amc::FCdecl &row);

// Return true if index is empty
bool                 zs_gen_perns_EmptyQ() __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FGen*           zs_gen_perns_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_gen_perns_InLlistQ(amc::FGen& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_gen_perns_Insert(amc::FGen& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FGen*           zs_gen_perns_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FGen*           zs_gen_perns_Next(amc::FGen &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_gen_perns_Remove(amc::FGen& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_gen_perns_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FGen*           zs_gen_perns_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FGen&           zs_gen_perns_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FHook&          hook_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FHook*          hook_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FHook*          hook_InsertMaybe(const dmmeta::Hook &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                hook_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 hook_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FHook*          hook_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FHook*          hook_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  hook_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 hook_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 hook_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FHook&          hook_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 hook_XrefMaybe(amc::FHook &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FCharset&       charset_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FCharset*       charset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FCharset*       charset_InsertMaybe(const dmmeta::Charset &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                charset_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 charset_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCharset*       charset_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FCharset*       charset_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  charset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 charset_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 charset_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FCharset&       charset_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 charset_XrefMaybe(amc::FCharset &row);

bool                 ValidRnumPadQ(u32 ch) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FNsinclude&     nsinclude_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FNsinclude*     nsinclude_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FNsinclude*     nsinclude_InsertMaybe(const dmmeta::Nsinclude &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                nsinclude_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 nsinclude_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNsinclude*     nsinclude_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FNsinclude*     nsinclude_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  nsinclude_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 nsinclude_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 nsinclude_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FNsinclude&     nsinclude_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 nsinclude_XrefMaybe(amc::FNsinclude &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FSsimvolatile&  ssimvolatile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FSsimvolatile*  ssimvolatile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FSsimvolatile*  ssimvolatile_InsertMaybe(const dmmeta::Ssimvolatile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                ssimvolatile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 ssimvolatile_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FSsimvolatile*  ssimvolatile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FSsimvolatile*  ssimvolatile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  ssimvolatile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 ssimvolatile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 ssimvolatile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FSsimvolatile&  ssimvolatile_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 ssimvolatile_XrefMaybe(amc::FSsimvolatile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
amc::FFunique*       funique_InsertMaybe(const dmmeta::Funique &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                funique_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 funique_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFunique*       funique_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FFunique*       funique_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  funique_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 funique_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 funique_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FFunique&       funique_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 funique_XrefMaybe(amc::FFunique &row);

// cursor points to valid item
void                 _db_fsort_curs_Reset(_db_fsort_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fsort_curs_ValidQ(_db_fsort_curs &curs);
// proceed to next item
void                 _db_fsort_curs_Next(_db_fsort_curs &curs);
// item access
amc::FFsort&         _db_fsort_curs_Access(_db_fsort_curs &curs);
// cursor points to valid item
void                 _db_dispfilter_curs_Reset(_db_dispfilter_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_dispfilter_curs_ValidQ(_db_dispfilter_curs &curs);
// proceed to next item
void                 _db_dispfilter_curs_Next(_db_dispfilter_curs &curs);
// item access
amc::FDispfilter&    _db_dispfilter_curs_Access(_db_dispfilter_curs &curs);
// cursor points to valid item
void                 _db_usertracefld_curs_Reset(_db_usertracefld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_usertracefld_curs_ValidQ(_db_usertracefld_curs &curs);
// proceed to next item
void                 _db_usertracefld_curs_Next(_db_usertracefld_curs &curs);
// item access
amc::FUsertracefld&  _db_usertracefld_curs_Access(_db_usertracefld_curs &curs);
// cursor points to valid item
void                 _db_cfmt_curs_Reset(_db_cfmt_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cfmt_curs_ValidQ(_db_cfmt_curs &curs);
// proceed to next item
void                 _db_cfmt_curs_Next(_db_cfmt_curs &curs);
// item access
amc::FCfmt&          _db_cfmt_curs_Access(_db_cfmt_curs &curs);
// cursor points to valid item
void                 _db_dispatch_curs_Reset(_db_dispatch_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_dispatch_curs_ValidQ(_db_dispatch_curs &curs);
// proceed to next item
void                 _db_dispatch_curs_Next(_db_dispatch_curs &curs);
// item access
amc::FDispatch&      _db_dispatch_curs_Access(_db_dispatch_curs &curs);
// cursor points to valid item
void                 _db_dispatch_msg_curs_Reset(_db_dispatch_msg_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_dispatch_msg_curs_ValidQ(_db_dispatch_msg_curs &curs);
// proceed to next item
void                 _db_dispatch_msg_curs_Next(_db_dispatch_msg_curs &curs);
// item access
amc::FDispatchmsg&   _db_dispatch_msg_curs_Access(_db_dispatch_msg_curs &curs);
// cursor points to valid item
void                 _db_ctype_curs_Reset(_db_ctype_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ctype_curs_ValidQ(_db_ctype_curs &curs);
// proceed to next item
void                 _db_ctype_curs_Next(_db_ctype_curs &curs);
// item access
amc::FCtype&         _db_ctype_curs_Access(_db_ctype_curs &curs);
// cursor points to valid item
void                 _db_field_curs_Reset(_db_field_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_field_curs_ValidQ(_db_field_curs &curs);
// proceed to next item
void                 _db_field_curs_Next(_db_field_curs &curs);
// item access
amc::FField&         _db_field_curs_Access(_db_field_curs &curs);
// cursor points to valid item
void                 _db_basepool_curs_Reset(_db_basepool_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_basepool_curs_ValidQ(_db_basepool_curs &curs);
// proceed to next item
void                 _db_basepool_curs_Next(_db_basepool_curs &curs);
// item access
amc::FBasepool&      _db_basepool_curs_Access(_db_basepool_curs &curs);
// cursor points to valid item
void                 _db_llist_curs_Reset(_db_llist_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_llist_curs_ValidQ(_db_llist_curs &curs);
// proceed to next item
void                 _db_llist_curs_Next(_db_llist_curs &curs);
// item access
amc::FLlist&         _db_llist_curs_Access(_db_llist_curs &curs);
// cursor points to valid item
void                 _db_anonfld_curs_Reset(_db_anonfld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_anonfld_curs_ValidQ(_db_anonfld_curs &curs);
// proceed to next item
void                 _db_anonfld_curs_Next(_db_anonfld_curs &curs);
// item access
amc::FAnonfld&       _db_anonfld_curs_Access(_db_anonfld_curs &curs);
// cursor points to valid item
void                 _db_xref_curs_Reset(_db_xref_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_xref_curs_ValidQ(_db_xref_curs &curs);
// proceed to next item
void                 _db_xref_curs_Next(_db_xref_curs &curs);
// item access
amc::FXref&          _db_xref_curs_Access(_db_xref_curs &curs);
// cursor points to valid item
void                 _db_ns_curs_Reset(_db_ns_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ns_curs_ValidQ(_db_ns_curs &curs);
// proceed to next item
void                 _db_ns_curs_Next(_db_ns_curs &curs);
// item access
amc::FNs&            _db_ns_curs_Access(_db_ns_curs &curs);
// cursor points to valid item
void                 _db_pnew_curs_Reset(_db_pnew_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_pnew_curs_ValidQ(_db_pnew_curs &curs);
// proceed to next item
void                 _db_pnew_curs_Next(_db_pnew_curs &curs);
// item access
amc::FPnew&          _db_pnew_curs_Access(_db_pnew_curs &curs);
// cursor points to valid item
void                 _db_fldoffset_curs_Reset(_db_fldoffset_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fldoffset_curs_ValidQ(_db_fldoffset_curs &curs);
// proceed to next item
void                 _db_fldoffset_curs_Next(_db_fldoffset_curs &curs);
// item access
amc::FFldoffset&     _db_fldoffset_curs_Access(_db_fldoffset_curs &curs);
// cursor points to valid item
void                 _db_typefld_curs_Reset(_db_typefld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_typefld_curs_ValidQ(_db_typefld_curs &curs);
// proceed to next item
void                 _db_typefld_curs_Next(_db_typefld_curs &curs);
// item access
amc::FTypefld&       _db_typefld_curs_Access(_db_typefld_curs &curs);
// cursor points to valid item
void                 _db_lenfld_curs_Reset(_db_lenfld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_lenfld_curs_ValidQ(_db_lenfld_curs &curs);
// proceed to next item
void                 _db_lenfld_curs_Next(_db_lenfld_curs &curs);
// item access
amc::FLenfld&        _db_lenfld_curs_Access(_db_lenfld_curs &curs);
// cursor points to valid item
void                 _db_bltin_curs_Reset(_db_bltin_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_bltin_curs_ValidQ(_db_bltin_curs &curs);
// proceed to next item
void                 _db_bltin_curs_Next(_db_bltin_curs &curs);
// item access
amc::FBltin&         _db_bltin_curs_Access(_db_bltin_curs &curs);
// cursor points to valid item
void                 _db_static_tuple_curs_Reset(_db_static_tuple_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_static_tuple_curs_ValidQ(_db_static_tuple_curs &curs);
// proceed to next item
void                 _db_static_tuple_curs_Next(_db_static_tuple_curs &curs);
// item access
amc::FStatictuple&   _db_static_tuple_curs_Access(_db_static_tuple_curs &curs);
// cursor points to valid item
void                 _db_msgtype_curs_Reset(_db_msgtype_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_msgtype_curs_ValidQ(_db_msgtype_curs &curs);
// proceed to next item
void                 _db_msgtype_curs_Next(_db_msgtype_curs &curs);
// item access
amc::FMsgtype&       _db_msgtype_curs_Access(_db_msgtype_curs &curs);
// cursor points to valid item
void                 _db_gconst_curs_Reset(_db_gconst_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_gconst_curs_ValidQ(_db_gconst_curs &curs);
// proceed to next item
void                 _db_gconst_curs_Next(_db_gconst_curs &curs);
// item access
amc::FGconst&        _db_gconst_curs_Access(_db_gconst_curs &curs);
// cursor points to valid item
void                 _db_gstatic_curs_Reset(_db_gstatic_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_gstatic_curs_ValidQ(_db_gstatic_curs &curs);
// proceed to next item
void                 _db_gstatic_curs_Next(_db_gstatic_curs &curs);
// item access
amc::FGstatic&       _db_gstatic_curs_Access(_db_gstatic_curs &curs);
// cursor points to valid item
void                 _db_thash_curs_Reset(_db_thash_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_thash_curs_ValidQ(_db_thash_curs &curs);
// proceed to next item
void                 _db_thash_curs_Next(_db_thash_curs &curs);
// item access
amc::FThash&         _db_thash_curs_Access(_db_thash_curs &curs);
// cursor points to valid item
void                 _db_func_curs_Reset(_db_func_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_func_curs_ValidQ(_db_func_curs &curs);
// proceed to next item
void                 _db_func_curs_Next(_db_func_curs &curs);
// item access
amc::FFunc&          _db_func_curs_Access(_db_func_curs &curs);
// cursor points to valid item
void                 _db_smallstr_curs_Reset(_db_smallstr_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_smallstr_curs_ValidQ(_db_smallstr_curs &curs);
// proceed to next item
void                 _db_smallstr_curs_Next(_db_smallstr_curs &curs);
// item access
amc::FSmallstr&      _db_smallstr_curs_Access(_db_smallstr_curs &curs);
// cursor points to valid item
void                 _db_numstr_curs_Reset(_db_numstr_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_numstr_curs_ValidQ(_db_numstr_curs &curs);
// proceed to next item
void                 _db_numstr_curs_Next(_db_numstr_curs &curs);
// item access
amc::FNumstr&        _db_numstr_curs_Access(_db_numstr_curs &curs);
// cursor points to valid item
void                 _db_main_curs_Reset(_db_main_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_main_curs_ValidQ(_db_main_curs &curs);
// proceed to next item
void                 _db_main_curs_Next(_db_main_curs &curs);
// item access
amc::FMain&          _db_main_curs_Access(_db_main_curs &curs);
// cursor points to valid item
void                 _db_reftype_curs_Reset(_db_reftype_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_reftype_curs_ValidQ(_db_reftype_curs &curs);
// proceed to next item
void                 _db_reftype_curs_Next(_db_reftype_curs &curs);
// item access
amc::FReftype&       _db_reftype_curs_Access(_db_reftype_curs &curs);
// cursor points to valid item
void                 _db_cpptype_curs_Reset(_db_cpptype_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cpptype_curs_ValidQ(_db_cpptype_curs &curs);
// proceed to next item
void                 _db_cpptype_curs_Next(_db_cpptype_curs &curs);
// item access
amc::FCpptype&       _db_cpptype_curs_Access(_db_cpptype_curs &curs);
// cursor points to valid item
void                 _db_inlary_curs_Reset(_db_inlary_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_inlary_curs_ValidQ(_db_inlary_curs &curs);
// proceed to next item
void                 _db_inlary_curs_Next(_db_inlary_curs &curs);
// item access
amc::FInlary&        _db_inlary_curs_Access(_db_inlary_curs &curs);
// cursor points to valid item
void                 _db_tary_curs_Reset(_db_tary_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_tary_curs_ValidQ(_db_tary_curs &curs);
// proceed to next item
void                 _db_tary_curs_Next(_db_tary_curs &curs);
// item access
amc::FTary&          _db_tary_curs_Access(_db_tary_curs &curs);
// cursor points to valid item
void                 _db_cppfunc_curs_Reset(_db_cppfunc_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cppfunc_curs_ValidQ(_db_cppfunc_curs &curs);
// proceed to next item
void                 _db_cppfunc_curs_Next(_db_cppfunc_curs &curs);
// item access
amc::FCppfunc&       _db_cppfunc_curs_Access(_db_cppfunc_curs &curs);
// cursor points to valid item
void                 _db_rowid_curs_Reset(_db_rowid_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_rowid_curs_ValidQ(_db_rowid_curs &curs);
// proceed to next item
void                 _db_rowid_curs_Next(_db_rowid_curs &curs);
// item access
amc::FRowid&         _db_rowid_curs_Access(_db_rowid_curs &curs);
// cursor points to valid item
void                 _db_cascdel_curs_Reset(_db_cascdel_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cascdel_curs_ValidQ(_db_cascdel_curs &curs);
// proceed to next item
void                 _db_cascdel_curs_Next(_db_cascdel_curs &curs);
// item access
amc::FCascdel&       _db_cascdel_curs_Access(_db_cascdel_curs &curs);
// cursor points to valid item
void                 _db_substr_curs_Reset(_db_substr_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_substr_curs_ValidQ(_db_substr_curs &curs);
// proceed to next item
void                 _db_substr_curs_Next(_db_substr_curs &curs);
// item access
amc::FSubstr&        _db_substr_curs_Access(_db_substr_curs &curs);
// cursor points to valid item
void                 _db_bitfld_curs_Reset(_db_bitfld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_bitfld_curs_ValidQ(_db_bitfld_curs &curs);
// proceed to next item
void                 _db_bitfld_curs_Next(_db_bitfld_curs &curs);
// item access
amc::FBitfld&        _db_bitfld_curs_Access(_db_bitfld_curs &curs);
// cursor points to valid item
void                 _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs);
// proceed to next item
void                 _db_ssimfile_curs_Next(_db_ssimfile_curs &curs);
// item access
amc::FSsimfile&      _db_ssimfile_curs_Access(_db_ssimfile_curs &curs);
// cursor points to valid item
void                 _db_pack_curs_Reset(_db_pack_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_pack_curs_ValidQ(_db_pack_curs &curs);
// proceed to next item
void                 _db_pack_curs_Next(_db_pack_curs &curs);
// item access
amc::FPack&          _db_pack_curs_Access(_db_pack_curs &curs);
// cursor points to valid item
void                 _db_ptrary_curs_Reset(_db_ptrary_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ptrary_curs_ValidQ(_db_ptrary_curs &curs);
// proceed to next item
void                 _db_ptrary_curs_Next(_db_ptrary_curs &curs);
// item access
amc::FPtrary&        _db_ptrary_curs_Access(_db_ptrary_curs &curs);
void                 _db_c_ctype_sorted_curs_Reset(_db_c_ctype_sorted_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_ctype_sorted_curs_ValidQ(_db_c_ctype_sorted_curs &curs);
// proceed to next item
void                 _db_c_ctype_sorted_curs_Next(_db_c_ctype_sorted_curs &curs);
// item access
amc::FCtype&         _db_c_ctype_sorted_curs_Access(_db_c_ctype_sorted_curs &curs);
// cursor points to valid item
void                 _db_enumstr_curs_Reset(_db_enumstr_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_enumstr_curs_ValidQ(_db_enumstr_curs &curs);
// proceed to next item
void                 _db_enumstr_curs_Next(_db_enumstr_curs &curs);
// item access
amc::FEnumstr&       _db_enumstr_curs_Access(_db_enumstr_curs &curs);
// cursor points to valid item
void                 _db_enumstr_len_curs_Reset(_db_enumstr_len_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_enumstr_len_curs_ValidQ(_db_enumstr_len_curs &curs);
// proceed to next item
void                 _db_enumstr_len_curs_Next(_db_enumstr_len_curs &curs);
// item access
amc::FEnumstrLen&    _db_enumstr_len_curs_Access(_db_enumstr_len_curs &curs);
void                 _db_bh_enumstr_len_curs_Reserve(_db_bh_enumstr_len_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 _db_bh_enumstr_len_curs_Reset(_db_bh_enumstr_len_curs &curs, amc::FDb &parent);
// Advance cursor.
void                 _db_bh_enumstr_len_curs_Next(_db_bh_enumstr_len_curs &curs);
// Access current element. If not more elements, return NULL
amc::FEnumstrLen&    _db_bh_enumstr_len_curs_Access(_db_bh_enumstr_len_curs &curs);
// Return true if Access() will return non-NULL.
bool                 _db_bh_enumstr_len_curs_ValidQ(_db_bh_enumstr_len_curs &curs);
// cursor points to valid item
void                 _db_fbitset_curs_Reset(_db_fbitset_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fbitset_curs_ValidQ(_db_fbitset_curs &curs);
// proceed to next item
void                 _db_fbitset_curs_Next(_db_fbitset_curs &curs);
// item access
amc::FFbitset&       _db_fbitset_curs_Access(_db_fbitset_curs &curs);
// cursor points to valid item
void                 _db_fcleanup_curs_Reset(_db_fcleanup_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcleanup_curs_ValidQ(_db_fcleanup_curs &curs);
// proceed to next item
void                 _db_fcleanup_curs_Next(_db_fcleanup_curs &curs);
// item access
amc::FFcleanup&      _db_fcleanup_curs_Access(_db_fcleanup_curs &curs);
// cursor points to valid item
void                 _db_fdec_curs_Reset(_db_fdec_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fdec_curs_ValidQ(_db_fdec_curs &curs);
// proceed to next item
void                 _db_fdec_curs_Next(_db_fdec_curs &curs);
// item access
amc::FFdec&          _db_fdec_curs_Access(_db_fdec_curs &curs);
// cursor points to valid item
void                 _db_fconst_curs_Reset(_db_fconst_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fconst_curs_ValidQ(_db_fconst_curs &curs);
// proceed to next item
void                 _db_fconst_curs_Next(_db_fconst_curs &curs);
// item access
amc::FFconst&        _db_fconst_curs_Access(_db_fconst_curs &curs);
void                 _db_c_ns_sorted_curs_Reset(_db_c_ns_sorted_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_ns_sorted_curs_ValidQ(_db_c_ns_sorted_curs &curs);
// proceed to next item
void                 _db_c_ns_sorted_curs_Next(_db_c_ns_sorted_curs &curs);
// item access
amc::FNs&            _db_c_ns_sorted_curs_Access(_db_c_ns_sorted_curs &curs);
// cursor points to valid item
void                 _db_finput_curs_Reset(_db_finput_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_finput_curs_ValidQ(_db_finput_curs &curs);
// proceed to next item
void                 _db_finput_curs_Next(_db_finput_curs &curs);
// item access
amc::FFinput&        _db_finput_curs_Access(_db_finput_curs &curs);
// cursor points to valid item
void                 _db_foutput_curs_Reset(_db_foutput_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_foutput_curs_ValidQ(_db_foutput_curs &curs);
// proceed to next item
void                 _db_foutput_curs_Next(_db_foutput_curs &curs);
// item access
amc::FFoutput&       _db_foutput_curs_Access(_db_foutput_curs &curs);
// cursor points to valid item
void                 _db_fbuf_curs_Reset(_db_fbuf_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fbuf_curs_ValidQ(_db_fbuf_curs &curs);
// proceed to next item
void                 _db_fbuf_curs_Next(_db_fbuf_curs &curs);
// item access
amc::FFbuf&          _db_fbuf_curs_Access(_db_fbuf_curs &curs);
// cursor points to valid item
void                 _db_chash_curs_Reset(_db_chash_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_chash_curs_ValidQ(_db_chash_curs &curs);
// proceed to next item
void                 _db_chash_curs_Next(_db_chash_curs &curs);
// item access
amc::FChash&         _db_chash_curs_Access(_db_chash_curs &curs);
// cursor points to valid item
void                 _db_ccmp_curs_Reset(_db_ccmp_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ccmp_curs_ValidQ(_db_ccmp_curs &curs);
// proceed to next item
void                 _db_ccmp_curs_Next(_db_ccmp_curs &curs);
// item access
amc::FCcmp&          _db_ccmp_curs_Access(_db_ccmp_curs &curs);
// cursor points to valid item
void                 _db_fbigend_curs_Reset(_db_fbigend_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fbigend_curs_ValidQ(_db_fbigend_curs &curs);
// proceed to next item
void                 _db_fbigend_curs_Next(_db_fbigend_curs &curs);
// item access
amc::FFbigend&       _db_fbigend_curs_Access(_db_fbigend_curs &curs);
// cursor points to valid item
void                 _db_zsl_ctype_pack_tran_curs_Reset(_db_zsl_ctype_pack_tran_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_zsl_ctype_pack_tran_curs_ValidQ(_db_zsl_ctype_pack_tran_curs &curs);
// proceed to next item
void                 _db_zsl_ctype_pack_tran_curs_Next(_db_zsl_ctype_pack_tran_curs &curs);
// item access
amc::FCtype&         _db_zsl_ctype_pack_tran_curs_Access(_db_zsl_ctype_pack_tran_curs &curs);
// cursor points to valid item
void                 _db_cstr_curs_Reset(_db_cstr_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cstr_curs_ValidQ(_db_cstr_curs &curs);
// proceed to next item
void                 _db_cstr_curs_Next(_db_cstr_curs &curs);
// item access
amc::FCstr&          _db_cstr_curs_Access(_db_cstr_curs &curs);
// cursor points to valid item
void                 _db_listtype_curs_Reset(_db_listtype_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_listtype_curs_ValidQ(_db_listtype_curs &curs);
// proceed to next item
void                 _db_listtype_curs_Next(_db_listtype_curs &curs);
// item access
amc::FListtype&      _db_listtype_curs_Access(_db_listtype_curs &curs);
// cursor points to valid item
void                 _db_fstep_curs_Reset(_db_fstep_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fstep_curs_ValidQ(_db_fstep_curs &curs);
// proceed to next item
void                 _db_fstep_curs_Next(_db_fstep_curs &curs);
// item access
amc::FFstep&         _db_fstep_curs_Access(_db_fstep_curs &curs);
// cursor points to valid item
void                 _db_cextern_curs_Reset(_db_cextern_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cextern_curs_ValidQ(_db_cextern_curs &curs);
// proceed to next item
void                 _db_cextern_curs_Next(_db_cextern_curs &curs);
// item access
amc::FCextern&       _db_cextern_curs_Access(_db_cextern_curs &curs);
// cursor points to valid item
void                 _db_fdelay_curs_Reset(_db_fdelay_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fdelay_curs_ValidQ(_db_fdelay_curs &curs);
// proceed to next item
void                 _db_fdelay_curs_Next(_db_fdelay_curs &curs);
// item access
amc::FFdelay&        _db_fdelay_curs_Access(_db_fdelay_curs &curs);
// cursor points to valid item
void                 _db_disptrace_curs_Reset(_db_disptrace_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_disptrace_curs_ValidQ(_db_disptrace_curs &curs);
// proceed to next item
void                 _db_disptrace_curs_Next(_db_disptrace_curs &curs);
// item access
amc::FDisptrace&     _db_disptrace_curs_Access(_db_disptrace_curs &curs);
// cursor points to valid item
void                 _db_tracefld_curs_Reset(_db_tracefld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_tracefld_curs_ValidQ(_db_tracefld_curs &curs);
// proceed to next item
void                 _db_tracefld_curs_Next(_db_tracefld_curs &curs);
// item access
amc::FTracefld&      _db_tracefld_curs_Access(_db_tracefld_curs &curs);
// cursor points to valid item
void                 _db_tracerec_curs_Reset(_db_tracerec_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_tracerec_curs_ValidQ(_db_tracerec_curs &curs);
// proceed to next item
void                 _db_tracerec_curs_Next(_db_tracerec_curs &curs);
// item access
amc::FTracerec&      _db_tracerec_curs_Access(_db_tracerec_curs &curs);
// cursor points to valid item
void                 _db_dispsig_curs_Reset(_db_dispsig_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_dispsig_curs_ValidQ(_db_dispsig_curs &curs);
// proceed to next item
void                 _db_dispsig_curs_Next(_db_dispsig_curs &curs);
// item access
amc::FDispsig&       _db_dispsig_curs_Access(_db_dispsig_curs &curs);
void                 _db_c_dispsig_sorted_curs_Reset(_db_c_dispsig_sorted_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_dispsig_sorted_curs_ValidQ(_db_c_dispsig_sorted_curs &curs);
// proceed to next item
void                 _db_c_dispsig_sorted_curs_Next(_db_c_dispsig_sorted_curs &curs);
// item access
amc::FDispsig&       _db_c_dispsig_sorted_curs_Access(_db_c_dispsig_sorted_curs &curs);
// cursor points to valid item
void                 _db_zs_sig_visit_curs_Reset(_db_zs_sig_visit_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_zs_sig_visit_curs_ValidQ(_db_zs_sig_visit_curs &curs);
// proceed to next item
void                 _db_zs_sig_visit_curs_Next(_db_zs_sig_visit_curs &curs);
// item access
amc::FCtype&         _db_zs_sig_visit_curs_Access(_db_zs_sig_visit_curs &curs);
// cursor points to valid item
void                 _db_target_curs_Reset(_db_target_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_target_curs_ValidQ(_db_target_curs &curs);
// proceed to next item
void                 _db_target_curs_Next(_db_target_curs &curs);
// item access
amc::FTarget&        _db_target_curs_Access(_db_target_curs &curs);
// cursor points to valid item
void                 _db_targdep_curs_Reset(_db_targdep_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_targdep_curs_ValidQ(_db_targdep_curs &curs);
// proceed to next item
void                 _db_targdep_curs_Next(_db_targdep_curs &curs);
// item access
amc::FTargdep&       _db_targdep_curs_Access(_db_targdep_curs &curs);
// cursor points to valid item
void                 _db_dispctx_curs_Reset(_db_dispctx_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_dispctx_curs_ValidQ(_db_dispctx_curs &curs);
// proceed to next item
void                 _db_dispctx_curs_Next(_db_dispctx_curs &curs);
// item access
amc::FDispctx&       _db_dispctx_curs_Access(_db_dispctx_curs &curs);
// cursor points to valid item
void                 _db_pmaskfld_curs_Reset(_db_pmaskfld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_pmaskfld_curs_ValidQ(_db_pmaskfld_curs &curs);
// proceed to next item
void                 _db_pmaskfld_curs_Next(_db_pmaskfld_curs &curs);
// item access
amc::FPmaskfld&      _db_pmaskfld_curs_Access(_db_pmaskfld_curs &curs);
// cursor points to valid item
void                 _db_fwddecl_curs_Reset(_db_fwddecl_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fwddecl_curs_ValidQ(_db_fwddecl_curs &curs);
// proceed to next item
void                 _db_fwddecl_curs_Next(_db_fwddecl_curs &curs);
// item access
amc::FFwddecl&       _db_fwddecl_curs_Access(_db_fwddecl_curs &curs);
// cursor points to valid item
void                 _db_tfunc_curs_Reset(_db_tfunc_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_tfunc_curs_ValidQ(_db_tfunc_curs &curs);
// proceed to next item
void                 _db_tfunc_curs_Next(_db_tfunc_curs &curs);
// item access
amc::FTfunc&         _db_tfunc_curs_Access(_db_tfunc_curs &curs);
// cursor points to valid item
void                 _db_gen_curs_Reset(_db_gen_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_gen_curs_ValidQ(_db_gen_curs &curs);
// proceed to next item
void                 _db_gen_curs_Next(_db_gen_curs &curs);
// item access
amc::FGen&           _db_gen_curs_Access(_db_gen_curs &curs);
// cursor points to valid item
void                 _db_fregx_curs_Reset(_db_fregx_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fregx_curs_ValidQ(_db_fregx_curs &curs);
// proceed to next item
void                 _db_fregx_curs_Next(_db_fregx_curs &curs);
// item access
amc::FFregx&         _db_fregx_curs_Access(_db_fregx_curs &curs);
// cursor points to valid item
void                 _db_tclass_curs_Reset(_db_tclass_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_tclass_curs_ValidQ(_db_tclass_curs &curs);
// proceed to next item
void                 _db_tclass_curs_Next(_db_tclass_curs &curs);
// item access
amc::FTclass&        _db_tclass_curs_Access(_db_tclass_curs &curs);
// cursor points to valid item
void                 _db_fcmp_curs_Reset(_db_fcmp_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcmp_curs_ValidQ(_db_fcmp_curs &curs);
// proceed to next item
void                 _db_fcmp_curs_Next(_db_fcmp_curs &curs);
// item access
amc::FFcmp&          _db_fcmp_curs_Access(_db_fcmp_curs &curs);
// cursor points to valid item
void                 _db_fcast_curs_Reset(_db_fcast_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcast_curs_ValidQ(_db_fcast_curs &curs);
// proceed to next item
void                 _db_fcast_curs_Next(_db_fcast_curs &curs);
// item access
amc::FFcast&         _db_fcast_curs_Access(_db_fcast_curs &curs);
// cursor points to valid item
void                 _db_noxref_curs_Reset(_db_noxref_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_noxref_curs_ValidQ(_db_noxref_curs &curs);
// proceed to next item
void                 _db_noxref_curs_Next(_db_noxref_curs &curs);
// item access
amc::FNoxref&        _db_noxref_curs_Access(_db_noxref_curs &curs);
// cursor points to valid item
void                 _db_nocascdel_curs_Reset(_db_nocascdel_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_nocascdel_curs_ValidQ(_db_nocascdel_curs &curs);
// proceed to next item
void                 _db_nocascdel_curs_Next(_db_nocascdel_curs &curs);
// item access
amc::FNocascdel&     _db_nocascdel_curs_Access(_db_nocascdel_curs &curs);
// cursor points to valid item
void                 _db_cafter_curs_Reset(_db_cafter_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cafter_curs_ValidQ(_db_cafter_curs &curs);
// proceed to next item
void                 _db_cafter_curs_Next(_db_cafter_curs &curs);
// item access
amc::FCafter&        _db_cafter_curs_Access(_db_cafter_curs &curs);
// cursor points to valid item
void                 _db_csize_curs_Reset(_db_csize_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_csize_curs_ValidQ(_db_csize_curs &curs);
// proceed to next item
void                 _db_csize_curs_Next(_db_csize_curs &curs);
// item access
amc::FCsize&         _db_csize_curs_Access(_db_csize_curs &curs);
// cursor points to valid item
void                 _db_nsx_curs_Reset(_db_nsx_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_nsx_curs_ValidQ(_db_nsx_curs &curs);
// proceed to next item
void                 _db_nsx_curs_Next(_db_nsx_curs &curs);
// item access
amc::FNsx&           _db_nsx_curs_Access(_db_nsx_curs &curs);
// cursor points to valid item
void                 _db_fcompact_curs_Reset(_db_fcompact_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcompact_curs_ValidQ(_db_fcompact_curs &curs);
// proceed to next item
void                 _db_fcompact_curs_Next(_db_fcompact_curs &curs);
// item access
amc::FFcompact&      _db_fcompact_curs_Access(_db_fcompact_curs &curs);
// cursor points to valid item
void                 _db_findrem_curs_Reset(_db_findrem_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_findrem_curs_ValidQ(_db_findrem_curs &curs);
// proceed to next item
void                 _db_findrem_curs_Next(_db_findrem_curs &curs);
// item access
amc::FFindrem&       _db_findrem_curs_Access(_db_findrem_curs &curs);
// cursor points to valid item
void                 _db_tcursor_curs_Reset(_db_tcursor_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_tcursor_curs_ValidQ(_db_tcursor_curs &curs);
// proceed to next item
void                 _db_tcursor_curs_Next(_db_tcursor_curs &curs);
// item access
amc::FTcursor&       _db_tcursor_curs_Access(_db_tcursor_curs &curs);
// cursor points to valid item
void                 _db_fcurs_curs_Reset(_db_fcurs_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcurs_curs_ValidQ(_db_fcurs_curs &curs);
// proceed to next item
void                 _db_fcurs_curs_Next(_db_fcurs_curs &curs);
// item access
amc::FFcurs&         _db_fcurs_curs_Access(_db_fcurs_curs &curs);
// cursor points to valid item
void                 _db_cdflt_curs_Reset(_db_cdflt_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cdflt_curs_ValidQ(_db_cdflt_curs &curs);
// proceed to next item
void                 _db_cdflt_curs_Next(_db_cdflt_curs &curs);
// item access
amc::FCdflt&         _db_cdflt_curs_Access(_db_cdflt_curs &curs);
// cursor points to valid item
void                 _db_argvtype_curs_Reset(_db_argvtype_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_argvtype_curs_ValidQ(_db_argvtype_curs &curs);
// proceed to next item
void                 _db_argvtype_curs_Next(_db_argvtype_curs &curs);
// item access
amc::FArgvtype&      _db_argvtype_curs_Access(_db_argvtype_curs &curs);
// cursor points to valid item
void                 _db_fcmdline_curs_Reset(_db_fcmdline_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcmdline_curs_ValidQ(_db_fcmdline_curs &curs);
// proceed to next item
void                 _db_fcmdline_curs_Next(_db_fcmdline_curs &curs);
// item access
amc::FFcmdline&      _db_fcmdline_curs_Access(_db_fcmdline_curs &curs);
// cursor points to valid item
void                 _db_floadtuples_curs_Reset(_db_floadtuples_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_floadtuples_curs_ValidQ(_db_floadtuples_curs &curs);
// proceed to next item
void                 _db_floadtuples_curs_Next(_db_floadtuples_curs &curs);
// item access
amc::FFloadtuples&   _db_floadtuples_curs_Access(_db_floadtuples_curs &curs);
// cursor points to valid item
void                 _db_fcmap_curs_Reset(_db_fcmap_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fcmap_curs_ValidQ(_db_fcmap_curs &curs);
// proceed to next item
void                 _db_fcmap_curs_Next(_db_fcmap_curs &curs);
// item access
amc::FFcmap&         _db_fcmap_curs_Access(_db_fcmap_curs &curs);
// cursor points to valid item
void                 _db_zs_ordkeyfield_curs_Reset(_db_zs_ordkeyfield_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_zs_ordkeyfield_curs_ValidQ(_db_zs_ordkeyfield_curs &curs);
// proceed to next item
void                 _db_zs_ordkeyfield_curs_Next(_db_zs_ordkeyfield_curs &curs);
// item access
amc::FField&         _db_zs_ordkeyfield_curs_Access(_db_zs_ordkeyfield_curs &curs);
// cursor points to valid item
void                 _db_nsproto_curs_Reset(_db_nsproto_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_nsproto_curs_ValidQ(_db_nsproto_curs &curs);
// proceed to next item
void                 _db_nsproto_curs_Next(_db_nsproto_curs &curs);
// item access
amc::FNsproto&       _db_nsproto_curs_Access(_db_nsproto_curs &curs);
// cursor points to valid item
void                 _db_nsdb_curs_Reset(_db_nsdb_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_nsdb_curs_ValidQ(_db_nsdb_curs &curs);
// proceed to next item
void                 _db_nsdb_curs_Next(_db_nsdb_curs &curs);
// item access
amc::FNsdb&          _db_nsdb_curs_Access(_db_nsdb_curs &curs);
// cursor points to valid item
void                 _db_zd_substr_params_curs_Reset(_db_zd_substr_params_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_zd_substr_params_curs_ValidQ(_db_zd_substr_params_curs &curs);
// proceed to next item
void                 _db_zd_substr_params_curs_Next(_db_zd_substr_params_curs &curs);
// item access
amc::FSubstr&        _db_zd_substr_params_curs_Access(_db_zd_substr_params_curs &curs);
// cursor points to valid item
void                 _db_fprefix_curs_Reset(_db_fprefix_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fprefix_curs_ValidQ(_db_fprefix_curs &curs);
// proceed to next item
void                 _db_fprefix_curs_Next(_db_fprefix_curs &curs);
// item access
amc::FFprefix&       _db_fprefix_curs_Access(_db_fprefix_curs &curs);
// cursor points to valid item
void                 _db_ftrace_curs_Reset(_db_ftrace_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ftrace_curs_ValidQ(_db_ftrace_curs &curs);
// proceed to next item
void                 _db_ftrace_curs_Next(_db_ftrace_curs &curs);
// item access
amc::FFtrace&        _db_ftrace_curs_Access(_db_ftrace_curs &curs);
// cursor points to valid item
void                 _db_fnoremove_curs_Reset(_db_fnoremove_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fnoremove_curs_ValidQ(_db_fnoremove_curs &curs);
// proceed to next item
void                 _db_fnoremove_curs_Next(_db_fnoremove_curs &curs);
// item access
amc::FFnoremove&     _db_fnoremove_curs_Access(_db_fnoremove_curs &curs);
void                 _db_c_substr_field_curs_Reset(_db_c_substr_field_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_substr_field_curs_ValidQ(_db_c_substr_field_curs &curs);
// proceed to next item
void                 _db_c_substr_field_curs_Next(_db_c_substr_field_curs &curs);
// item access
amc::FSubstr&        _db_c_substr_field_curs_Access(_db_c_substr_field_curs &curs);
// cursor points to valid item
void                 _db_ctypelen_curs_Reset(_db_ctypelen_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ctypelen_curs_ValidQ(_db_ctypelen_curs &curs);
// proceed to next item
void                 _db_ctypelen_curs_Next(_db_ctypelen_curs &curs);
// item access
amc::FCtypelen&      _db_ctypelen_curs_Access(_db_ctypelen_curs &curs);
void                 _db_c_ctypelen_curs_Reset(_db_c_ctypelen_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_ctypelen_curs_ValidQ(_db_c_ctypelen_curs &curs);
// proceed to next item
void                 _db_c_ctypelen_curs_Next(_db_c_ctypelen_curs &curs);
// item access
amc::FCtypelen&      _db_c_ctypelen_curs_Access(_db_c_ctypelen_curs &curs);
void                 _db_c_tempfield_curs_Reset(_db_c_tempfield_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_c_tempfield_curs_ValidQ(_db_c_tempfield_curs &curs);
// proceed to next item
void                 _db_c_tempfield_curs_Next(_db_c_tempfield_curs &curs);
// item access
amc::FField&         _db_c_tempfield_curs_Access(_db_c_tempfield_curs &curs);
// cursor points to valid item
void                 _db_fbase_curs_Reset(_db_fbase_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_fbase_curs_ValidQ(_db_fbase_curs &curs);
// proceed to next item
void                 _db_fbase_curs_Next(_db_fbase_curs &curs);
// item access
amc::FFbase&         _db_fbase_curs_Access(_db_fbase_curs &curs);
// cursor points to valid item
void                 _db_nossimfile_curs_Reset(_db_nossimfile_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_nossimfile_curs_ValidQ(_db_nossimfile_curs &curs);
// proceed to next item
void                 _db_nossimfile_curs_Next(_db_nossimfile_curs &curs);
// item access
amc::FNossimfile&    _db_nossimfile_curs_Access(_db_nossimfile_curs &curs);
// cursor points to valid item
void                 _db_gsymbol_curs_Reset(_db_gsymbol_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_gsymbol_curs_ValidQ(_db_gsymbol_curs &curs);
// proceed to next item
void                 _db_gsymbol_curs_Next(_db_gsymbol_curs &curs);
// item access
amc::FGsymbol&       _db_gsymbol_curs_Access(_db_gsymbol_curs &curs);
// cursor points to valid item
void                 _db_sortfld_curs_Reset(_db_sortfld_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_sortfld_curs_ValidQ(_db_sortfld_curs &curs);
// proceed to next item
void                 _db_sortfld_curs_Next(_db_sortfld_curs &curs);
// item access
amc::FSortfld&       _db_sortfld_curs_Access(_db_sortfld_curs &curs);
// cursor points to valid item
void                 _db_cget_curs_Reset(_db_cget_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cget_curs_ValidQ(_db_cget_curs &curs);
// proceed to next item
void                 _db_cget_curs_Next(_db_cget_curs &curs);
// item access
amc::FCget&          _db_cget_curs_Access(_db_cget_curs &curs);
// cursor points to valid item
void                 _db_cd_temp_func_curs_Reset(_db_cd_temp_func_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cd_temp_func_curs_ValidQ(_db_cd_temp_func_curs &curs);
// proceed to next item
void                 _db_cd_temp_func_curs_Next(_db_cd_temp_func_curs &curs);
// item access
amc::FFunc&          _db_cd_temp_func_curs_Access(_db_cd_temp_func_curs &curs);
// cursor points to valid item
void                 _db_cdecl_curs_Reset(_db_cdecl_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_cdecl_curs_ValidQ(_db_cdecl_curs &curs);
// proceed to next item
void                 _db_cdecl_curs_Next(_db_cdecl_curs &curs);
// item access
amc::FCdecl&         _db_cdecl_curs_Access(_db_cdecl_curs &curs);
// cursor points to valid item
void                 _db_zs_gen_perns_curs_Reset(_db_zs_gen_perns_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_zs_gen_perns_curs_ValidQ(_db_zs_gen_perns_curs &curs);
// proceed to next item
void                 _db_zs_gen_perns_curs_Next(_db_zs_gen_perns_curs &curs);
// item access
amc::FGen&           _db_zs_gen_perns_curs_Access(_db_zs_gen_perns_curs &curs);
// cursor points to valid item
void                 _db_hook_curs_Reset(_db_hook_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_hook_curs_ValidQ(_db_hook_curs &curs);
// proceed to next item
void                 _db_hook_curs_Next(_db_hook_curs &curs);
// item access
amc::FHook&          _db_hook_curs_Access(_db_hook_curs &curs);
// cursor points to valid item
void                 _db_charset_curs_Reset(_db_charset_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_charset_curs_ValidQ(_db_charset_curs &curs);
// proceed to next item
void                 _db_charset_curs_Next(_db_charset_curs &curs);
// item access
amc::FCharset&       _db_charset_curs_Access(_db_charset_curs &curs);
// cursor points to valid item
void                 _db_nsinclude_curs_Reset(_db_nsinclude_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_nsinclude_curs_ValidQ(_db_nsinclude_curs &curs);
// proceed to next item
void                 _db_nsinclude_curs_Next(_db_nsinclude_curs &curs);
// item access
amc::FNsinclude&     _db_nsinclude_curs_Access(_db_nsinclude_curs &curs);
// cursor points to valid item
void                 _db_ssimvolatile_curs_Reset(_db_ssimvolatile_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_ssimvolatile_curs_ValidQ(_db_ssimvolatile_curs &curs);
// proceed to next item
void                 _db_ssimvolatile_curs_Next(_db_ssimvolatile_curs &curs);
// item access
amc::FSsimvolatile&  _db_ssimvolatile_curs_Access(_db_ssimvolatile_curs &curs);
// cursor points to valid item
void                 _db_funique_curs_Reset(_db_funique_curs &curs, amc::FDb &parent);
// cursor points to valid item
bool                 _db_funique_curs_ValidQ(_db_funique_curs &curs);
// proceed to next item
void                 _db_funique_curs_Next(_db_funique_curs &curs);
// item access
amc::FFunique&       _db_funique_curs_Access(_db_funique_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- amc.FDispatch
// create: amc.FDb.dispatch (Lary)
// global access: ind_dispatch (Thash)
// access: amc.FDispatchmsg.p_dispatch (Upptr)
// access: amc.FDisptrace.p_dispatch (Upptr)
// access: amc.FNs.c_dispatch (Ptrary)
struct FDispatch { // amc.FDispatch
    amc::FDispatch*       ind_dispatch_next;      // hash next
    algo::Smallstr50      dispatch;               //
    bool                  unk;                    //   false  Want default case?
    bool                  read;                   //   false
    bool                  print;                  //   false
    bool                  haslen;                 //   false
    bool                  call;                   //   false
    bool                  strict;                 //   false  Only dispatch if length matches exactly
    amc::FCtype*          p_ctype_hdr;            // reference to parent row
    amc::FCtype*          p_casetype;             // reference to parent row
    amc::FDispfilter*     c_dispfilter;           // optional pointer
    amc::FNs*             p_ns;                   // reference to parent row
    amc::FDispatchmsg**   c_dispatch_msg_elems;   // array of pointers
    u32                   c_dispatch_msg_n;       // array of pointers
    u32                   c_dispatch_msg_max;     // capacity of allocated array
    amc::FDisptrace*      c_disptrace;            // optional pointer
    algo::Sha1sig         signature;              //
    amc::FDispctx*        c_dispctx;              // optional pointer
    bool                  ns_c_dispatch_in_ary;   //   false  membership flag
private:
    friend amc::FDispatch&      dispatch_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispatch*      dispatch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispatch_RemoveLast() __attribute__((nothrow));
    FDispatch();
    ~FDispatch();
    FDispatch(const FDispatch&){ /*disallow copy constructor */}
    void operator =(const FDispatch&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 dispatch_CopyIn(amc::FDispatch &row, dmmeta::Dispatch &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FDispatch& dispatch) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FDispatch& dispatch) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_dispfilter_InsertMaybe(amc::FDispatch& dispatch, amc::FDispfilter& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_dispfilter_Remove(amc::FDispatch& dispatch, amc::FDispfilter& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_dispatch_msg_EmptyQ(amc::FDispatch& dispatch) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispatchmsg*   c_dispatch_msg_Find(amc::FDispatch& dispatch, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FDispatchmsg*> c_dispatch_msg_Getary(amc::FDispatch& dispatch) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_dispatch_msg_Insert(amc::FDispatch& dispatch, amc::FDispatchmsg& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_dispatch_msg_InsertMaybe(amc::FDispatch& dispatch, amc::FDispatchmsg& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_dispatch_msg_N(const amc::FDispatch& dispatch) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_dispatch_msg_Remove(amc::FDispatch& dispatch, amc::FDispatchmsg& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_dispatch_msg_RemoveAll(amc::FDispatch& dispatch) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_dispatch_msg_Reserve(amc::FDispatch& dispatch, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_disptrace_InsertMaybe(amc::FDispatch& dispatch, amc::FDisptrace& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_disptrace_Remove(amc::FDispatch& dispatch, amc::FDisptrace& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_dispctx_InsertMaybe(amc::FDispatch& dispatch, amc::FDispctx& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_dispctx_Remove(amc::FDispatch& dispatch, amc::FDispctx& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FDispatch_Init(amc::FDispatch& dispatch);
void                 dispatch_c_dispatch_msg_curs_Reset(dispatch_c_dispatch_msg_curs &curs, amc::FDispatch &parent);
// cursor points to valid item
bool                 dispatch_c_dispatch_msg_curs_ValidQ(dispatch_c_dispatch_msg_curs &curs);
// proceed to next item
void                 dispatch_c_dispatch_msg_curs_Next(dispatch_c_dispatch_msg_curs &curs);
// item access
amc::FDispatchmsg&   dispatch_c_dispatch_msg_curs_Access(dispatch_c_dispatch_msg_curs &curs);
void                 FDispatch_Uninit(amc::FDispatch& dispatch) __attribute__((nothrow));

// --- amc.FDispatchmsg
// create: amc.FDb.dispatch_msg (Lary)
// access: amc.FDispatch.c_dispatch_msg (Ptrary)
struct FDispatchmsg { // amc.FDispatchmsg
    algo::Smallstr100   dispatch_msg;                     //
    amc::FCtype*        p_ctype;                          // reference to parent row
    amc::FDispatch*     p_dispatch;                       // reference to parent row
    algo::cstring       selector;                         //
    bool                dispatch_c_dispatch_msg_in_ary;   //   false  membership flag
private:
    friend amc::FDispatchmsg&   dispatch_msg_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispatchmsg*   dispatch_msg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispatch_msg_RemoveLast() __attribute__((nothrow));
    FDispatchmsg();
    ~FDispatchmsg();
    FDispatchmsg(const FDispatchmsg&){ /*disallow copy constructor */}
    void operator =(const FDispatchmsg&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 dispatch_msg_CopyIn(amc::FDispatchmsg &row, dmmeta::DispatchMsg &in) __attribute__((nothrow));

algo::Smallstr50     dispatch_Get(amc::FDispatchmsg& dispatch_msg) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     ctype_Get(amc::FDispatchmsg& dispatch_msg) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FDispatchmsg_Init(amc::FDispatchmsg& dispatch_msg);
void                 FDispatchmsg_Uninit(amc::FDispatchmsg& dispatch_msg) __attribute__((nothrow));

// --- amc.FDispctx
// create: amc.FDb.dispctx (Lary)
// access: amc.FDispatch.c_dispctx (Ptr)
struct FDispctx { // amc.FDispctx
    algo::Smallstr50   dispatch;   //
    algo::Smallstr50   ctype;      //
    amc::FCtype*       p_ctype;    // reference to parent row
private:
    friend amc::FDispctx&       dispctx_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispctx*       dispctx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispctx_RemoveLast() __attribute__((nothrow));
    FDispctx();
    ~FDispctx();
    FDispctx(const FDispctx&){ /*disallow copy constructor */}
    void operator =(const FDispctx&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 dispctx_CopyIn(amc::FDispctx &row, dmmeta::Dispctx &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FDispctx_Init(amc::FDispctx& dispctx);
void                 FDispctx_Uninit(amc::FDispctx& dispctx) __attribute__((nothrow));

// --- amc.FDispfilter
// create: amc.FDb.dispfilter (Lary)
// access: amc.FDispatch.c_dispfilter (Ptr)
struct FDispfilter { // amc.FDispfilter
    algo::Smallstr50   dispatch;    //
    bool               match_all;   //   false
private:
    friend amc::FDispfilter&    dispfilter_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispfilter*    dispfilter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispfilter_RemoveLast() __attribute__((nothrow));
    FDispfilter();
    ~FDispfilter();
    FDispfilter(const FDispfilter&){ /*disallow copy constructor */}
    void operator =(const FDispfilter&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 dispfilter_CopyIn(amc::FDispfilter &row, dmmeta::Dispfilter &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FDispfilter_Init(amc::FDispfilter& dispfilter);
void                 FDispfilter_Uninit(amc::FDispfilter& dispfilter) __attribute__((nothrow));

// --- amc.FDispsig
// create: amc.FDb.dispsig (Lary)
// global access: c_dispsig_sorted (Ptrary)
// access: amc.FNs.c_dispsig (Ptrary)
struct FDispsig { // amc.FDispsig
    algo::Smallstr50   dispsig;                       //
    algo::Sha1sig      signature;                     //
    bool               _db_c_dispsig_sorted_in_ary;   //   false  membership flag
    bool               ns_c_dispsig_in_ary;           //   false  membership flag
private:
    friend amc::FDispsig&       dispsig_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispsig*       dispsig_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispsig_RemoveAll() __attribute__((nothrow));
    friend void                 dispsig_RemoveLast() __attribute__((nothrow));
    FDispsig();
    ~FDispsig();
    FDispsig(const FDispsig&){ /*disallow copy constructor */}
    void operator =(const FDispsig&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 dispsig_CopyOut(amc::FDispsig &row, dmmeta::Dispsig &out) __attribute__((nothrow));
// Copy fields in to row
void                 dispsig_CopyIn(amc::FDispsig &row, dmmeta::Dispsig &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FDispsig& dispsig) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FDispsig& dispsig) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FDispsig_Init(amc::FDispsig& dispsig);
void                 FDispsig_Uninit(amc::FDispsig& dispsig) __attribute__((nothrow));

// --- amc.FDisptrace
// create: amc.FDb.disptrace (Lary)
// access: amc.FDispatch.c_disptrace (Ptr)
struct FDisptrace { // amc.FDisptrace
    algo::Smallstr50   dispatch;     //
    bool               cycle;        //   false
    algo::Comment      comment;      //
    amc::FDispatch*    p_dispatch;   // reference to parent row
private:
    friend amc::FDisptrace&     disptrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDisptrace*     disptrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 disptrace_RemoveLast() __attribute__((nothrow));
    FDisptrace();
    ~FDisptrace();
    FDisptrace(const FDisptrace&){ /*disallow copy constructor */}
    void operator =(const FDisptrace&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 disptrace_CopyOut(amc::FDisptrace &row, dmmeta::Disptrace &out) __attribute__((nothrow));
// Copy fields in to row
void                 disptrace_CopyIn(amc::FDisptrace &row, dmmeta::Disptrace &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FDisptrace_Init(amc::FDisptrace& disptrace);
void                 FDisptrace_Uninit(amc::FDisptrace& disptrace) __attribute__((nothrow));

// --- amc.FEnumstr
// create: amc.FDb.enumstr (Lary)
// global access: ind_enumstr (Thash)
// access: amc.FEnumstrLen.bh_enumstr (Bheap)
struct FEnumstr { // amc.FEnumstr: All values of a given length
    amc::FEnumstr*   ind_enumstr_next;   // hash next
    amc::Enumstr     enumstr;            //
    amc::FFconst**   c_fconst_elems;     // array of pointers
    u32              c_fconst_n;         // array of pointers
    u32              c_fconst_max;       // capacity of allocated array
    i32              bh_enumstr_idx;     // index in heap; -1 means not-in-heap
private:
    friend amc::FEnumstr&       enumstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FEnumstr*       enumstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 enumstr_RemoveAll() __attribute__((nothrow));
    friend void                 enumstr_RemoveLast() __attribute__((nothrow));
    FEnumstr();
    ~FEnumstr();
    FEnumstr(const FEnumstr&){ /*disallow copy constructor */}
    void operator =(const FEnumstr&){ /*disallow direct assignment */}
};

// Return true if index is empty
bool                 c_fconst_EmptyQ(amc::FEnumstr& enumstr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFconst*        c_fconst_Find(amc::FEnumstr& enumstr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFconst*> c_fconst_Getary(amc::FEnumstr& enumstr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_fconst_Insert(amc::FEnumstr& enumstr, amc::FFconst& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_fconst_ScanInsertMaybe(amc::FEnumstr& enumstr, amc::FFconst& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_fconst_N(const amc::FEnumstr& enumstr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_fconst_Remove(amc::FEnumstr& enumstr, amc::FFconst& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_fconst_RemoveAll(amc::FEnumstr& enumstr) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_fconst_Reserve(amc::FEnumstr& enumstr, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FEnumstr_Init(amc::FEnumstr& enumstr);
void                 enumstr_c_fconst_curs_Reset(enumstr_c_fconst_curs &curs, amc::FEnumstr &parent);
// cursor points to valid item
bool                 enumstr_c_fconst_curs_ValidQ(enumstr_c_fconst_curs &curs);
// proceed to next item
void                 enumstr_c_fconst_curs_Next(enumstr_c_fconst_curs &curs);
// item access
amc::FFconst&        enumstr_c_fconst_curs_Access(enumstr_c_fconst_curs &curs);
void                 FEnumstr_Uninit(amc::FEnumstr& enumstr) __attribute__((nothrow));

// --- amc.FEnumstrLen
// create: amc.FDb.enumstr_len (Lary)
// global access: bh_enumstr_len (Bheap)
// global access: ind_enumstr_len (Thash)
struct FEnumstrLen { // amc.FEnumstrLen
    i32                 bh_enumstr_len_idx;     // index in heap; -1 means not-in-heap
    amc::FEnumstrLen*   ind_enumstr_len_next;   // hash next
    i32                 len;                    //   0
    amc::FEnumstr**     bh_enumstr_elems;       // binary heap by str
    i32                 bh_enumstr_n;           // number of elements in the heap
    i32                 bh_enumstr_max;         // max elements in bh_enumstr_elems
private:
    friend amc::FEnumstrLen&    enumstr_len_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FEnumstrLen*    enumstr_len_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 enumstr_len_RemoveAll() __attribute__((nothrow));
    friend void                 enumstr_len_RemoveLast() __attribute__((nothrow));
    FEnumstrLen();
    ~FEnumstrLen();
    FEnumstrLen(const FEnumstrLen&){ /*disallow copy constructor */}
    void operator =(const FEnumstrLen&){ /*disallow direct assignment */}
};

// Remove all elements from heap and free memory used by the array.
void                 bh_enumstr_Dealloc(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// Return true if index is empty
bool                 bh_enumstr_EmptyQ(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FEnumstr*       bh_enumstr_First(amc::FEnumstrLen& enumstr_len) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_enumstr_InBheapQ(amc::FEnumstr& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_enumstr_Insert(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_enumstr_N(const amc::FEnumstrLen& enumstr_len) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_enumstr_Reheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_enumstr_ReheapFirst(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_enumstr_Remove(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_enumstr_RemoveAll(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
amc::FEnumstr*       bh_enumstr_RemoveFirst(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_enumstr_Reserve(amc::FEnumstrLen& enumstr_len, int n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FEnumstrLen_Init(amc::FEnumstrLen& enumstr_len);
void                 enumstr_len_bh_enumstr_curs_Reserve(enumstr_len_bh_enumstr_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 enumstr_len_bh_enumstr_curs_Reset(enumstr_len_bh_enumstr_curs &curs, amc::FEnumstrLen &parent);
// Advance cursor.
void                 enumstr_len_bh_enumstr_curs_Next(enumstr_len_bh_enumstr_curs &curs);
// Access current element. If not more elements, return NULL
amc::FEnumstr&       enumstr_len_bh_enumstr_curs_Access(enumstr_len_bh_enumstr_curs &curs);
// Return true if Access() will return non-NULL.
bool                 enumstr_len_bh_enumstr_curs_ValidQ(enumstr_len_bh_enumstr_curs &curs);
void                 FEnumstrLen_Uninit(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));

// --- amc.FFbase
// create: amc.FDb.fbase (Lary)
// access: amc.FField.c_fbase (Ptr)
struct FFbase { // amc.FFbase
    algo::Smallstr100   field;          //
    bool                stripcomment;   //   false
    algo::Comment       comment;        //
private:
    friend amc::FFbase&         fbase_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbase*         fbase_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbase_RemoveAll() __attribute__((nothrow));
    friend void                 fbase_RemoveLast() __attribute__((nothrow));
    FFbase();
    ~FFbase();
    FFbase(const FFbase&){ /*disallow copy constructor */}
    void operator =(const FFbase&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fbase_CopyOut(amc::FFbase &row, dmmeta::Fbase &out) __attribute__((nothrow));
// Copy fields in to row
void                 fbase_CopyIn(amc::FFbase &row, dmmeta::Fbase &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFbase_Init(amc::FFbase& fbase);
void                 FFbase_Uninit(amc::FFbase& fbase) __attribute__((nothrow));

// --- amc.FFbigend
// create: amc.FDb.fbigend (Lary)
// access: amc.FField.c_fbigend (Ptr)
struct FFbigend { // amc.FFbigend
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FFbigend&       fbigend_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbigend*       fbigend_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbigend_RemoveLast() __attribute__((nothrow));
    FFbigend();
    ~FFbigend();
    FFbigend(const FFbigend&){ /*disallow copy constructor */}
    void operator =(const FFbigend&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fbigend_CopyOut(amc::FFbigend &row, dmmeta::Fbigend &out) __attribute__((nothrow));
// Copy fields in to row
void                 fbigend_CopyIn(amc::FFbigend &row, dmmeta::Fbigend &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFbigend_Init(amc::FFbigend& fbigend);
void                 FFbigend_Uninit(amc::FFbigend& fbigend) __attribute__((nothrow));

// --- amc.FFbitset
// create: amc.FDb.fbitset (Lary)
// global access: ind_fbitset (Thash)
// access: amc.FField.c_fbitset (Ptr)
struct FFbitset { // amc.FFbitset
    amc::FFbitset*      ind_fbitset_next;   // hash next
    algo::Smallstr100   field;              //
    amc::FField*        p_field;            // reference to parent row
private:
    friend amc::FFbitset&       fbitset_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbitset*       fbitset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbitset_RemoveLast() __attribute__((nothrow));
    FFbitset();
    ~FFbitset();
    FFbitset(const FFbitset&){ /*disallow copy constructor */}
    void operator =(const FFbitset&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fbitset_CopyIn(amc::FFbitset &row, dmmeta::Fbitset &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFbitset_Init(amc::FFbitset& fbitset);
void                 FFbitset_Uninit(amc::FFbitset& fbitset) __attribute__((nothrow));

// --- amc.FFbuf
// create: amc.FDb.fbuf (Lary)
// global access: ind_fbuf (Thash)
// access: amc.FField.c_fbuf (Ptr)
struct FFbuf { // amc.FFbuf
    amc::FFbuf*         ind_fbuf_next;   // hash next
    algo::Smallstr100   field;           //
    u32                 max;             //   0  Size of buffer in bytes
    algo::Smallstr50    fbuftype;        // Type of buffer
    algo::Smallstr100   insready;        //
    algo::Smallstr100   inseof;          //
    amc::FField*        p_insready;      // reference to parent row
    amc::FField*        p_inseof;        // reference to parent row
private:
    friend amc::FFbuf&          fbuf_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbuf*          fbuf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbuf_RemoveLast() __attribute__((nothrow));
    FFbuf();
    ~FFbuf();
    FFbuf(const FFbuf&){ /*disallow copy constructor */}
    void operator =(const FFbuf&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fbuf_CopyIn(amc::FFbuf &row, dmmeta::Fbuf &in) __attribute__((nothrow));

algo::Smallstr50     fbufdir_Get(amc::FFbuf& fbuf) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFbuf_Init(amc::FFbuf& fbuf);
void                 FFbuf_Uninit(amc::FFbuf& fbuf) __attribute__((nothrow));

// --- amc.FFcast
// create: amc.FDb.fcast (Lary)
// access: amc.FField.c_fcast (Ptr)
struct FFcast { // amc.FFcast
    algo::Smallstr100   field;   //
    algo::Smallstr100   expr;    //
private:
    friend amc::FFcast&         fcast_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcast*         fcast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcast_RemoveLast() __attribute__((nothrow));
    FFcast();
    ~FFcast();
    FFcast(const FFcast&){ /*disallow copy constructor */}
    void operator =(const FFcast&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fcast_CopyIn(amc::FFcast &row, dmmeta::Fcast &in) __attribute__((nothrow));

void                 FFcast_Uninit(amc::FFcast& fcast) __attribute__((nothrow));

// --- amc.FFcleanup
// create: amc.FDb.fcleanup (Lary)
// access: amc.FField.c_fcleanup (Ptr)
struct FFcleanup { // amc.FFcleanup
    algo::Smallstr100   field;     //
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FFcleanup&      fcleanup_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcleanup*      fcleanup_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcleanup_RemoveLast() __attribute__((nothrow));
    FFcleanup();
    ~FFcleanup();
    FFcleanup(const FFcleanup&){ /*disallow copy constructor */}
    void operator =(const FFcleanup&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fcleanup_CopyIn(amc::FFcleanup &row, dmmeta::Fcleanup &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFcleanup_Init(amc::FFcleanup& fcleanup);
void                 FFcleanup_Uninit(amc::FFcleanup& fcleanup) __attribute__((nothrow));

// --- amc.FFcmap
// create: amc.FDb.fcmap (Lary)
// global access: ind_fcmap (Thash)
// access: amc.FField.zs_fcmap (Llist)
struct FFcmap { // amc.FFcmap
    amc::FFcmap*        ind_fcmap_next;   // hash next
    algo::Smallstr250   fcmap;            // cstring maybe?
    bool                bidir;            //   true
    algo::Comment       comment;          //
    amc::FField*        p_leftField;      // reference to parent row
    amc::FField*        p_rightField;     // reference to parent row
    amc::FFunc*         c_convfunc;       // Generated conversion func. optional pointer
    amc::FFcmap*        zs_fcmap_next;    // zslist link; -1 means not-in-list
private:
    friend amc::FFcmap&         fcmap_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcmap*         fcmap_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcmap_RemoveLast() __attribute__((nothrow));
    FFcmap();
    ~FFcmap();
    FFcmap(const FFcmap&){ /*disallow copy constructor */}
    void operator =(const FFcmap&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fcmap_CopyOut(amc::FFcmap &row, dmmeta::Fcmap &out) __attribute__((nothrow));
// Copy fields in to row
void                 fcmap_CopyIn(amc::FFcmap &row, dmmeta::Fcmap &in) __attribute__((nothrow));

algo::Smallstr100    leftField_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr40     leftVal_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr40     rightVal_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr100    rightField_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFcmap_Init(amc::FFcmap& fcmap);
void                 FFcmap_Uninit(amc::FFcmap& fcmap) __attribute__((nothrow));

// --- amc.FFcmdline
// create: amc.FDb.fcmdline (Lary)
// access: amc.FNs.c_fcmdline (Ptr)
struct FFcmdline { // amc.FFcmdline
    algo::Smallstr100   field;     //
    bool                read;      //   true
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FFcmdline&      fcmdline_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcmdline*      fcmdline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcmdline_RemoveLast() __attribute__((nothrow));
    FFcmdline();
    ~FFcmdline();
    FFcmdline(const FFcmdline&){ /*disallow copy constructor */}
    void operator =(const FFcmdline&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fcmdline_CopyOut(amc::FFcmdline &row, dmmeta::Fcmdline &out) __attribute__((nothrow));
// Copy fields in to row
void                 fcmdline_CopyIn(amc::FFcmdline &row, dmmeta::Fcmdline &in) __attribute__((nothrow));

amc::FNs*            p_ns_Get(amc::FFcmdline& fcmdline) __attribute__((__warn_unused_result__, nothrow));
void                 p_ns_Set(amc::FFcmdline& fcmdline, amc::FNs* rhs) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFcmdline_Init(amc::FFcmdline& fcmdline);
void                 FFcmdline_Uninit(amc::FFcmdline& fcmdline) __attribute__((nothrow));

// --- amc.FFcmp
// create: amc.FDb.fcmp (Lary)
// access: amc.FField.c_fcmp (Ptr)
struct FFcmp { // amc.FFcmp
    algo::Smallstr100   field;         // Target field
    bool                versionsort;   //   false  Use version sort (detect embedded integers in string)
    bool                casesens;      //   true  Comparison is case-sensitive
    bool                extrn;         //   false  Whether implementation is external
    algo::Comment       comment;       //
private:
    friend amc::FFcmp&          fcmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcmp*          fcmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcmp_RemoveLast() __attribute__((nothrow));
    FFcmp();
    ~FFcmp();
    FFcmp(const FFcmp&){ /*disallow copy constructor */}
    void operator =(const FFcmp&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fcmp_CopyOut(amc::FFcmp &row, dmmeta::Fcmp &out) __attribute__((nothrow));
// Copy fields in to row
void                 fcmp_CopyIn(amc::FFcmp &row, dmmeta::Fcmp &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFcmp_Init(amc::FFcmp& fcmp);
void                 FFcmp_Uninit(amc::FFcmp& fcmp) __attribute__((nothrow));

// --- amc.FFcompact
// create: amc.FDb.fcompact (Lary)
// access: amc.FField.c_fcompact (Ptr)
struct FFcompact { // amc.FFcompact
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
private:
    friend amc::FFcompact&      fcompact_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcompact*      fcompact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcompact_RemoveLast() __attribute__((nothrow));
    FFcompact();
    ~FFcompact();
    FFcompact(const FFcompact&){ /*disallow copy constructor */}
    void operator =(const FFcompact&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fcompact_CopyOut(amc::FFcompact &row, dmmeta::Fcompact &out) __attribute__((nothrow));
// Copy fields in to row
void                 fcompact_CopyIn(amc::FFcompact &row, dmmeta::Fcompact &in) __attribute__((nothrow));

void                 FFcompact_Uninit(amc::FFcompact& fcompact) __attribute__((nothrow));

// --- amc.FFconst
// create: amc.FDb.fconst (Lary)
// global access: ind_fconst (Thash)
// global access: ind_fconst_int (Thash)
// access: amc.FEnumstr.c_fconst (Ptrary)
// access: amc.FField.c_fconst (Ptrary)
// access: amc.FField.c_inkey_fconst (Ptr)
struct FFconst { // amc.FFconst
    amc::FFconst*       ind_fconst_next;         // hash next
    amc::FFconst*       ind_fconst_int_next;     // hash next
    algo::Smallstr100   fconst;                  //
    dmmeta::CppExpr     value;                   //
    algo::Comment       comment;                 //
    amc::FField*        p_field;                 // reference to parent row
    algo::cstring       cpp_value;               //
    i64                 int_val;                 //   0  integer value
    algo::cstring       cpp_name;                // symbol to use in cpp file
    bool                field_c_fconst_in_ary;   //   false  membership flag
private:
    friend amc::FFconst&        fconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFconst*        fconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fconst_RemoveLast() __attribute__((nothrow));
    FFconst();
    ~FFconst();
    FFconst(const FFconst&){ /*disallow copy constructor */}
    void operator =(const FFconst&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fconst_CopyOut(amc::FFconst &row, dmmeta::Fconst &out) __attribute__((nothrow));
// Copy fields in to row
void                 fconst_CopyIn(amc::FFconst &row, dmmeta::Fconst &in) __attribute__((nothrow));

algo::Smallstr100    field_Get(amc::FFconst& fconst) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr100    name_Get(amc::FFconst& fconst) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFconst_Init(amc::FFconst& fconst);
void                 FFconst_Uninit(amc::FFconst& fconst) __attribute__((nothrow));

// --- amc.FFcurs
// create: amc.FDb.fcurs (Lary)
// access: amc.FCtype.c_fcurs (Ptrary)
struct FFcurs { // amc.FFcurs
    algo::Smallstr50   fcurs;                  //
    algo::Comment      comment;                //
    bool               ctype_c_fcurs_in_ary;   //   false  membership flag
private:
    friend amc::FFcurs&         fcurs_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcurs*         fcurs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcurs_RemoveLast() __attribute__((nothrow));
    FFcurs();
    ~FFcurs();
    FFcurs(const FFcurs&){ /*disallow copy constructor */}
    void operator =(const FFcurs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fcurs_CopyOut(amc::FFcurs &row, dmmeta::Fcurs &out) __attribute__((nothrow));
// Copy fields in to row
void                 fcurs_CopyIn(amc::FFcurs &row, dmmeta::Fcurs &in) __attribute__((nothrow));

algo::Smallstr100    field_Get(amc::FFcurs& fcurs) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     ctype_Get(amc::FFcurs& fcurs) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     curs_Get(amc::FFcurs& fcurs) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFcurs_Init(amc::FFcurs& fcurs);
void                 FFcurs_Uninit(amc::FFcurs& fcurs) __attribute__((nothrow));

// --- amc.FFdec
// create: amc.FDb.fdec (Lary)
// global access: ind_fdec (Thash)
// access: amc.FField.c_fdec (Ptr)
struct FFdec { // amc.FFdec
    amc::FFdec*         ind_fdec_next;   // hash next
    algo::Smallstr100   field;           // Target field
    i32                 nplace;          //   0  Number of implied decimal places
    bool                fixedfmt;        //   false  Print exactly SCALE chars after decimal point
    amc::FField*        p_field;         // reference to parent row
private:
    friend amc::FFdec&          fdec_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFdec*          fdec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fdec_RemoveLast() __attribute__((nothrow));
    FFdec();
    ~FFdec();
    FFdec(const FFdec&){ /*disallow copy constructor */}
    void operator =(const FFdec&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fdec_CopyIn(amc::FFdec &row, dmmeta::Fdec &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFdec_Init(amc::FFdec& fdec);
void                 FFdec_Uninit(amc::FFdec& fdec) __attribute__((nothrow));

// --- amc.FFdelay
// create: amc.FDb.fdelay (Lary)
// access: amc.FFstep.c_fdelay (Ptr)
struct FFdelay { // amc.FFdelay
    algo::Smallstr100   fstep;   //
    algo::I64Dec9       delay;   // Delay between steps in seconds
    bool                scale;   //   false  Does delay apply to the whole list?
private:
    friend amc::FFdelay&        fdelay_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFdelay*        fdelay_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fdelay_RemoveLast() __attribute__((nothrow));
    FFdelay();
    ~FFdelay();
    FFdelay(const FFdelay&){ /*disallow copy constructor */}
    void operator =(const FFdelay&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fdelay_CopyIn(amc::FFdelay &row, dmmeta::Fdelay &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFdelay_Init(amc::FFdelay& fdelay);
void                 FFdelay_Uninit(amc::FFdelay& fdelay) __attribute__((nothrow));

// --- amc.FField
// create: amc.FDb.field (Lary)
// global access: ind_field (Thash)
// global access: c_malloc (Ptr)
// global access: zs_ordkeyfield (Llist)
// global access: c_tempfield (Ptrary)
// access: amc.FBasepool.p_field (Upptr)
// access: amc.FBasepool.p_base (Upptr)
// access: amc.FBitfld.p_srcfield (Upptr)
// access: amc.FCascdel.p_field (Upptr)
// access: amc.FCtype.c_field (Ptrary)
// access: amc.FCtype.c_varlenfld (Ptr)
// access: amc.FCtype.c_optfld (Ptr)
// access: amc.FCtype.c_datafld (Ptrary)
// access: amc.FCtype.zd_inst (Llist)
// access: amc.FCtype.zd_access (Llist)
// access: amc.FCtype.c_pkeyfield (Ptr)
// access: amc.FFbigend.p_field (Upptr)
// access: amc.FFbitset.p_field (Upptr)
// access: amc.FFbuf.p_insready (Upptr)
// access: amc.FFbuf.p_inseof (Upptr)
// access: amc.FFcleanup.p_field (Upptr)
// access: amc.FFcmap.p_leftField (Upptr)
// access: amc.FFcmap.p_rightField (Upptr)
// access: amc.FFcmdline.p_field (Upptr)
// access: amc.FFconst.p_field (Upptr)
// access: amc.FFdec.p_field (Upptr)
// access: amc.FFinput.p_field (Upptr)
// access: amc.FFldoffset.p_field (Upptr)
// access: amc.FFloadtuples.p_field (Upptr)
// access: amc.FFsort.p_field (Upptr)
// access: amc.FFsort.p_sortfld (Upptr)
// access: amc.FFstep.p_field (Upptr)
// access: amc.FGconst.p_namefld (Upptr)
// access: amc.FGconst.p_field (Upptr)
// access: amc.FGstatic.p_field (Upptr)
// access: amc.FHook.p_field (Upptr)
// access: amc.FLenfld.p_field (Upptr)
// access: amc.FNs.c_globfld (Ptr)
// access: amc.FNsx.p_pool (Upptr)
// access: amc.FPmaskfld.p_field (Upptr)
// access: amc.FPtrary.p_field (Upptr)
// access: amc.FSmallstr.p_field (Upptr)
// access: amc.FSortfld.p_sortfld (Upptr)
// access: amc.FSubstr.p_field (Upptr)
// access: amc.FSubstr.p_srcfield (Upptr)
// access: amc.FTary.p_field (Upptr)
// access: amc.FThash.p_hashfld (Upptr)
// access: amc.FThash.p_field (Upptr)
// access: amc.FTypefld.p_field (Upptr)
// access: amc.FXref.p_field (Upptr)
// access: amc.FXref.p_viafld (Upptr)
// access: amc.FXref.p_keyfld (Upptr)
// access: amc.Genfield.p_field (Upptr)
// access: amc.Genpnew.p_optfld (Upptr)
// access: amc.Genpnew.p_varlenfld (Upptr)
struct FField { // amc.FField
    amc::FField*        zd_inst_next;             // zslist link; -1 means not-in-list
    amc::FField*        zd_inst_prev;             // previous element
    amc::FField*        zd_access_next;           // zslist link; -1 means not-in-list
    amc::FField*        zd_access_prev;           // previous element
    amc::FField*        ind_field_next;           // hash next
    amc::FField*        zs_ordkeyfield_next;      // zslist link; -1 means not-in-list
    algo::Smallstr100   field;                    //
    algo::Smallstr50    arg;                      // type of field
    algo::Smallstr50    reftype;                  //   "Val"
    dmmeta::CppExpr     dflt;                     // default value (c++ expression)
    algo::Comment       comment;                  //
    amc::FFsort*        c_fsort;                  // optional pointer
    amc::FFbitset*      c_fbitset;                // optional pointer
    amc::FSmallstr*     c_smallstr;               // optional pointer
    amc::FFunc**        c_ffunc_elems;            // array of pointers
    u32                 c_ffunc_n;                // array of pointers
    u32                 c_ffunc_max;              // capacity of allocated array
    algo::cstring       cpp_type;                 // C++ expression to use in declaration
    amc::FCtype*        p_ctype;                  // reference to parent row
    amc::FCtype*        p_arg;                    // reference to parent row
    amc::FXref*         c_xref;                   // optional pointer
    amc::FAnonfld*      c_anonfld;                // optional pointer
    amc::FFldoffset*    c_fldoffset;              // optional pointer
    amc::FBasepool*     c_basepool;               // optional pointer
    amc::FLlist*        c_llist;                  // optional pointer
    amc::FThash*        c_thash;                  // optional pointer
    amc::FInlary*       c_inlary;                 // optional pointer
    amc::FTary*         c_tary;                   // optional pointer
    amc::FRowid*        c_rowid;                  // optional pointer
    amc::FCascdel*      c_cascdel;                // optional pointer
    double              rowid;                    //   0.0
    double              child_rowid;              //   0.0  Rowid increment for next child
    amc::FGstatic*      c_gstatic;                // optional pointer
    amc::FPtrary*       c_ptrary;                 // optional pointer
    amc::FPmaskfld*     c_pmaskfld;               // optional pointer
    amc::FTypefld*      c_typefld;                // optional pointer
    amc::FFcleanup*     c_fcleanup;               // optional pointer
    amc::FFdec*         c_fdec;                   // optional pointer
    amc::FReftype*      p_reftype;                // reference to parent row
    amc::FFconst**      c_fconst_elems;           // array of pointers
    u32                 c_fconst_n;               // array of pointers
    u32                 c_fconst_max;             // capacity of allocated array
    amc::FFinput*       c_finput;                 // optional pointer
    amc::FFoutput*      c_foutput;                // optional pointer
    amc::FFbuf*         c_fbuf;                   // optional pointer
    amc::FFbigend*      c_fbigend;                // optional pointer
    amc::FFstep*        c_fstep;                  // optional pointer
    amc::FFregx*        c_fregx;                  // optional pointer
    amc::FFcmp*         c_fcmp;                   // optional pointer
    amc::FFcast*        c_fcast;                  // optional pointer
    amc::FGconst*       c_gconst;                 // optional pointer
    amc::FBitfld*       c_bitfld;                 // optional pointer
    amc::FNoxref*       c_noxref;                 // optional pointer
    amc::FCppfunc*      c_cppfunc;                // optional pointer
    amc::FSubstr*       c_substr;                 // optional pointer
    amc::FFcompact*     c_fcompact;               // optional pointer
    amc::FFindrem*      c_findrem;                // optional pointer
    amc::FXref*         zd_xref_keyfld_head;      // zero-terminated doubly linked list
    i32                 zd_xref_keyfld_n;         // zero-terminated doubly linked list
    amc::FXref*         zd_xref_keyfld_tail;      // pointer to last element
    amc::FFcmap*        zs_fcmap_head;            // zero-terminated singly linked list
    amc::FFcmap*        zs_fcmap_tail;            // pointer to last element
    amc::FFconst*       c_inkey_fconst;           // optional pointer
    amc::FFbase*        c_fbase;                  // optional pointer
    amc::FFnoremove*    c_fnoremove;              // optional pointer
    amc::FSortfld*      c_sortfld;                // optional pointer
    amc::FFtrace*       c_ftrace;                 // optional pointer
    bool                reflect;                  //   false  Want reflection
    bool                ctype_read;               //   false
    bool                has_substr;               //   false
    bool                need_firstchanged;        //   false
    bool                do_trace;                 //   false  Enable tracing
    bool                processed;                //   false
    bool                synthetic;                //   false
    bool                visit;                    //   false  Temporary flag
    amc::FHook*         c_hook;                   // optional pointer
    amc::FCharset*      c_charset;                // optional pointer
    amc::FBitfld**      bh_bitfld_elems;          // binary heap by offset
    i32                 bh_bitfld_n;              // number of elements in the heap
    i32                 bh_bitfld_max;            // max elements in bh_bitfld_elems
    amc::FFunique*      c_funique;                // optional pointer
    bool                ctype_c_datafld_in_ary;   //   false  membership flag
    bool                _db_c_tempfield_in_ary;   //   false  membership flag
private:
    friend amc::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
    FField();
    ~FField();
    FField(const FField&){ /*disallow copy constructor */}
    void operator =(const FField&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 field_CopyOut(amc::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
void                 field_CopyIn(amc::FField &row, dmmeta::Field &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fsort_InsertMaybe(amc::FField& field, amc::FFsort& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fsort_Remove(amc::FField& field, amc::FFsort& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fbitset_InsertMaybe(amc::FField& field, amc::FFbitset& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fbitset_Remove(amc::FField& field, amc::FFbitset& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_smallstr_InsertMaybe(amc::FField& field, amc::FSmallstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_smallstr_Remove(amc::FField& field, amc::FSmallstr& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_ffunc_EmptyQ(amc::FField& field) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFunc*          c_ffunc_Find(amc::FField& field, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFunc*> c_ffunc_Getary(amc::FField& field) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ffunc_Insert(amc::FField& field, amc::FFunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_ffunc_ScanInsertMaybe(amc::FField& field, amc::FFunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ffunc_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ffunc_Remove(amc::FField& field, amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ffunc_RemoveAll(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ffunc_Reserve(amc::FField& field, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_xref_InsertMaybe(amc::FField& field, amc::FXref& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_xref_Remove(amc::FField& field, amc::FXref& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_anonfld_InsertMaybe(amc::FField& field, amc::FAnonfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_anonfld_Remove(amc::FField& field, amc::FAnonfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fldoffset_InsertMaybe(amc::FField& field, amc::FFldoffset& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fldoffset_Remove(amc::FField& field, amc::FFldoffset& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_basepool_InsertMaybe(amc::FField& field, amc::FBasepool& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_basepool_Remove(amc::FField& field, amc::FBasepool& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_llist_InsertMaybe(amc::FField& field, amc::FLlist& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_llist_Remove(amc::FField& field, amc::FLlist& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_thash_InsertMaybe(amc::FField& field, amc::FThash& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_thash_Remove(amc::FField& field, amc::FThash& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_inlary_InsertMaybe(amc::FField& field, amc::FInlary& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_inlary_Remove(amc::FField& field, amc::FInlary& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_tary_InsertMaybe(amc::FField& field, amc::FTary& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_tary_Remove(amc::FField& field, amc::FTary& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_rowid_InsertMaybe(amc::FField& field, amc::FRowid& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_rowid_Remove(amc::FField& field, amc::FRowid& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cascdel_InsertMaybe(amc::FField& field, amc::FCascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cascdel_Remove(amc::FField& field, amc::FCascdel& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_gstatic_InsertMaybe(amc::FField& field, amc::FGstatic& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_gstatic_Remove(amc::FField& field, amc::FGstatic& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ptrary_InsertMaybe(amc::FField& field, amc::FPtrary& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ptrary_Remove(amc::FField& field, amc::FPtrary& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_pmaskfld_InsertMaybe(amc::FField& field, amc::FPmaskfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_pmaskfld_Remove(amc::FField& field, amc::FPmaskfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_typefld_InsertMaybe(amc::FField& field, amc::FTypefld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_typefld_Remove(amc::FField& field, amc::FTypefld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fcleanup_InsertMaybe(amc::FField& field, amc::FFcleanup& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fcleanup_Remove(amc::FField& field, amc::FFcleanup& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fdec_InsertMaybe(amc::FField& field, amc::FFdec& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fdec_Remove(amc::FField& field, amc::FFdec& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_fconst_EmptyQ(amc::FField& field) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFconst*        c_fconst_Find(amc::FField& field, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFconst*> c_fconst_Getary(amc::FField& field) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_fconst_Insert(amc::FField& field, amc::FFconst& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_fconst_InsertMaybe(amc::FField& field, amc::FFconst& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_fconst_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_fconst_Remove(amc::FField& field, amc::FFconst& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_fconst_RemoveAll(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_fconst_Reserve(amc::FField& field, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_finput_InsertMaybe(amc::FField& field, amc::FFinput& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_finput_Remove(amc::FField& field, amc::FFinput& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_foutput_InsertMaybe(amc::FField& field, amc::FFoutput& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_foutput_Remove(amc::FField& field, amc::FFoutput& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fbuf_InsertMaybe(amc::FField& field, amc::FFbuf& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fbuf_Remove(amc::FField& field, amc::FFbuf& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fbigend_InsertMaybe(amc::FField& field, amc::FFbigend& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fbigend_Remove(amc::FField& field, amc::FFbigend& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fstep_InsertMaybe(amc::FField& field, amc::FFstep& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fstep_Remove(amc::FField& field, amc::FFstep& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fregx_InsertMaybe(amc::FField& field, amc::FFregx& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fregx_Remove(amc::FField& field, amc::FFregx& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fcmp_InsertMaybe(amc::FField& field, amc::FFcmp& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fcmp_Remove(amc::FField& field, amc::FFcmp& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fcast_InsertMaybe(amc::FField& field, amc::FFcast& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fcast_Remove(amc::FField& field, amc::FFcast& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_gconst_InsertMaybe(amc::FField& field, amc::FGconst& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_gconst_Remove(amc::FField& field, amc::FGconst& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_bitfld_InsertMaybe(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_bitfld_Remove(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_noxref_InsertMaybe(amc::FField& field, amc::FNoxref& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_noxref_Remove(amc::FField& field, amc::FNoxref& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_cppfunc_InsertMaybe(amc::FField& field, amc::FCppfunc& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_cppfunc_Remove(amc::FField& field, amc::FCppfunc& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_substr_InsertMaybe(amc::FField& field, amc::FSubstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_substr_Remove(amc::FField& field, amc::FSubstr& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fcompact_InsertMaybe(amc::FField& field, amc::FFcompact& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fcompact_Remove(amc::FField& field, amc::FFcompact& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_findrem_InsertMaybe(amc::FField& field, amc::FFindrem& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_findrem_Remove(amc::FField& field, amc::FFindrem& row) __attribute__((nothrow));

// Return true if index is empty
bool                 zd_xref_keyfld_EmptyQ(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FXref*          zd_xref_keyfld_First(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zd_xref_keyfld_InLlistQ(amc::FXref& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zd_xref_keyfld_Insert(amc::FField& field, amc::FXref& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FXref*          zd_xref_keyfld_Last(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
i32                  zd_xref_keyfld_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FXref*          zd_xref_keyfld_Next(amc::FXref &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
amc::FXref*          zd_xref_keyfld_Prev(amc::FXref &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 zd_xref_keyfld_Remove(amc::FField& field, amc::FXref& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zd_xref_keyfld_RemoveAll(amc::FField& field) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FXref*          zd_xref_keyfld_RemoveFirst(amc::FField& field) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FXref&          zd_xref_keyfld_qLast(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 zs_fcmap_EmptyQ(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FFcmap*         zs_fcmap_First(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_fcmap_InLlistQ(amc::FFcmap& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_fcmap_Insert(amc::FField& field, amc::FFcmap& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FFcmap*         zs_fcmap_Last(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FFcmap*         zs_fcmap_Next(amc::FFcmap &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_fcmap_Remove(amc::FField& field, amc::FFcmap& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_fcmap_RemoveAll(amc::FField& field) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FFcmap*         zs_fcmap_RemoveFirst(amc::FField& field) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FFcmap&         zs_fcmap_qLast(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fbase_InsertMaybe(amc::FField& field, amc::FFbase& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fbase_Remove(amc::FField& field, amc::FFbase& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fnoremove_InsertMaybe(amc::FField& field, amc::FFnoremove& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fnoremove_Remove(amc::FField& field, amc::FFnoremove& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_sortfld_InsertMaybe(amc::FField& field, amc::FSortfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_sortfld_Remove(amc::FField& field, amc::FSortfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ftrace_InsertMaybe(amc::FField& field, amc::FFtrace& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ftrace_Remove(amc::FField& field, amc::FFtrace& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_hook_InsertMaybe(amc::FField& field, amc::FHook& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_hook_Remove(amc::FField& field, amc::FHook& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_charset_InsertMaybe(amc::FField& field, amc::FCharset& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_charset_Remove(amc::FField& field, amc::FCharset& row) __attribute__((nothrow));

// Remove all elements from heap and free memory used by the array.
void                 bh_bitfld_Dealloc(amc::FField& field) __attribute__((nothrow));
// Return true if index is empty
bool                 bh_bitfld_EmptyQ(amc::FField& field) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FBitfld*        bh_bitfld_First(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
bool                 bh_bitfld_InBheapQ(amc::FBitfld& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
void                 bh_bitfld_Insert(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Return number of items in the heap
i32                  bh_bitfld_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
i32                  bh_bitfld_Reheap(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
i32                  bh_bitfld_ReheapFirst(amc::FField& field) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 bh_bitfld_Remove(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Remove all elements from binary heap
void                 bh_bitfld_RemoveAll(amc::FField& field) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
amc::FBitfld*        bh_bitfld_RemoveFirst(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements
void                 bh_bitfld_Reserve(amc::FField& field, int n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_funique_InsertMaybe(amc::FField& field, amc::FFunique& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_funique_Remove(amc::FField& field, amc::FFunique& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FField_Init(amc::FField& field);
void                 field_c_ffunc_curs_Reset(field_c_ffunc_curs &curs, amc::FField &parent);
// cursor points to valid item
bool                 field_c_ffunc_curs_ValidQ(field_c_ffunc_curs &curs);
// proceed to next item
void                 field_c_ffunc_curs_Next(field_c_ffunc_curs &curs);
// item access
amc::FFunc&          field_c_ffunc_curs_Access(field_c_ffunc_curs &curs);
void                 field_c_fconst_curs_Reset(field_c_fconst_curs &curs, amc::FField &parent);
// cursor points to valid item
bool                 field_c_fconst_curs_ValidQ(field_c_fconst_curs &curs);
// proceed to next item
void                 field_c_fconst_curs_Next(field_c_fconst_curs &curs);
// item access
amc::FFconst&        field_c_fconst_curs_Access(field_c_fconst_curs &curs);
// cursor points to valid item
void                 field_zd_xref_keyfld_curs_Reset(field_zd_xref_keyfld_curs &curs, amc::FField &parent);
// cursor points to valid item
bool                 field_zd_xref_keyfld_curs_ValidQ(field_zd_xref_keyfld_curs &curs);
// proceed to next item
void                 field_zd_xref_keyfld_curs_Next(field_zd_xref_keyfld_curs &curs);
// item access
amc::FXref&          field_zd_xref_keyfld_curs_Access(field_zd_xref_keyfld_curs &curs);
// cursor points to valid item
void                 field_zs_fcmap_curs_Reset(field_zs_fcmap_curs &curs, amc::FField &parent);
// cursor points to valid item
bool                 field_zs_fcmap_curs_ValidQ(field_zs_fcmap_curs &curs);
// proceed to next item
void                 field_zs_fcmap_curs_Next(field_zs_fcmap_curs &curs);
// item access
amc::FFcmap&         field_zs_fcmap_curs_Access(field_zs_fcmap_curs &curs);
void                 field_bh_bitfld_curs_Reserve(field_bh_bitfld_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
void                 field_bh_bitfld_curs_Reset(field_bh_bitfld_curs &curs, amc::FField &parent);
// Advance cursor.
void                 field_bh_bitfld_curs_Next(field_bh_bitfld_curs &curs);
// Access current element. If not more elements, return NULL
amc::FBitfld&        field_bh_bitfld_curs_Access(field_bh_bitfld_curs &curs);
// Return true if Access() will return non-NULL.
bool                 field_bh_bitfld_curs_ValidQ(field_bh_bitfld_curs &curs);
void                 FField_Uninit(amc::FField& field) __attribute__((nothrow));

// --- amc.FFindrem
// create: amc.FDb.findrem (Lary)
// access: amc.FField.c_findrem (Ptr)
struct FFindrem { // amc.FFindrem
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
private:
    friend amc::FFindrem&       findrem_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFindrem*       findrem_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 findrem_RemoveLast() __attribute__((nothrow));
    FFindrem();
    ~FFindrem();
    FFindrem(const FFindrem&){ /*disallow copy constructor */}
    void operator =(const FFindrem&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 findrem_CopyOut(amc::FFindrem &row, dmmeta::Findrem &out) __attribute__((nothrow));
// Copy fields in to row
void                 findrem_CopyIn(amc::FFindrem &row, dmmeta::Findrem &in) __attribute__((nothrow));

void                 FFindrem_Uninit(amc::FFindrem& findrem) __attribute__((nothrow));

// --- amc.FFinput
// create: amc.FDb.finput (Lary)
// access: amc.FField.c_finput (Ptr)
// access: amc.FNs.c_finput (Ptrary)
struct FFinput { // amc.FFinput
    algo::Smallstr100   field;                // Target field to read
    bool                extrn;                //   false  Call user-provided function
    bool                update;               //   false
    bool                strict;               //   true  Exist process if record contains error
    amc::FField*        p_field;              // reference to parent row
    bool                ns_c_finput_in_ary;   //   false  membership flag
private:
    friend amc::FFinput&        finput_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFinput*        finput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 finput_RemoveLast() __attribute__((nothrow));
    FFinput();
    ~FFinput();
    FFinput(const FFinput&){ /*disallow copy constructor */}
    void operator =(const FFinput&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 finput_CopyIn(amc::FFinput &row, dmmeta::Finput &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FFinput& finput) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFinput_Init(amc::FFinput& finput);
void                 FFinput_Uninit(amc::FFinput& finput) __attribute__((nothrow));

// --- amc.FFldoffset
// create: amc.FDb.fldoffset (Lary)
// access: amc.FField.c_fldoffset (Ptr)
struct FFldoffset { // amc.FFldoffset
    algo::Smallstr100   field;     //
    i32                 offset;    //   0
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FFldoffset&     fldoffset_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFldoffset*     fldoffset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fldoffset_RemoveLast() __attribute__((nothrow));
    FFldoffset();
    ~FFldoffset();
    FFldoffset(const FFldoffset&){ /*disallow copy constructor */}
    void operator =(const FFldoffset&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fldoffset_CopyIn(amc::FFldoffset &row, dmmeta::Fldoffset &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFldoffset_Init(amc::FFldoffset& fldoffset);
void                 FFldoffset_Uninit(amc::FFldoffset& fldoffset) __attribute__((nothrow));

// --- amc.FFloadtuples
// create: amc.FDb.floadtuples (Lary)
// access: amc.FCtype.c_floadtuples (Ptr)
struct FFloadtuples { // amc.FFloadtuples
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FFloadtuples&   floadtuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFloadtuples*   floadtuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 floadtuples_RemoveLast() __attribute__((nothrow));
    FFloadtuples();
    ~FFloadtuples();
    FFloadtuples(const FFloadtuples&){ /*disallow copy constructor */}
    void operator =(const FFloadtuples&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 floadtuples_CopyOut(amc::FFloadtuples &row, dmmeta::Floadtuples &out) __attribute__((nothrow));
// Copy fields in to row
void                 floadtuples_CopyIn(amc::FFloadtuples &row, dmmeta::Floadtuples &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FFloadtuples& floadtuples) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFloadtuples_Init(amc::FFloadtuples& floadtuples);
void                 FFloadtuples_Uninit(amc::FFloadtuples& floadtuples) __attribute__((nothrow));

// --- amc.FFnoremove
// create: amc.FDb.fnoremove (Lary)
// access: amc.FField.c_fnoremove (Ptr)
struct FFnoremove { // amc.FFnoremove
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
private:
    friend amc::FFnoremove&     fnoremove_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFnoremove*     fnoremove_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fnoremove_RemoveLast() __attribute__((nothrow));
    FFnoremove();
    ~FFnoremove();
    FFnoremove(const FFnoremove&){ /*disallow copy constructor */}
    void operator =(const FFnoremove&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fnoremove_CopyOut(amc::FFnoremove &row, dmmeta::Fnoremove &out) __attribute__((nothrow));
// Copy fields in to row
void                 fnoremove_CopyIn(amc::FFnoremove &row, dmmeta::Fnoremove &in) __attribute__((nothrow));

void                 FFnoremove_Uninit(amc::FFnoremove& fnoremove) __attribute__((nothrow));

// --- amc.FFoutput
// create: amc.FDb.foutput (Lary)
// access: amc.FField.c_foutput (Ptr)
// access: amc.FNs.c_foutput (Ptrary)
struct FFoutput { // amc.FFoutput
    algo::Smallstr100   field;                 //
    bool                ns_c_foutput_in_ary;   //   false  membership flag
private:
    friend amc::FFoutput&       foutput_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFoutput*       foutput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 foutput_RemoveLast() __attribute__((nothrow));
    FFoutput();
    ~FFoutput();
    FFoutput(const FFoutput&){ /*disallow copy constructor */}
    void operator =(const FFoutput&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 foutput_CopyIn(amc::FFoutput &row, dmmeta::Foutput &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FFoutput& foutput) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFoutput_Init(amc::FFoutput& foutput);
void                 FFoutput_Uninit(amc::FFoutput& foutput) __attribute__((nothrow));

// --- amc.FFprefix
// create: amc.FDb.fprefix (Lary)
// global access: ind_prefix (Thash)
// access: amc.FReftype.zs_fprefix (Llist)
struct FFprefix { // amc.FFprefix
    amc::FFprefix*     ind_prefix_next;   // hash next
    algo::Smallstr5    fprefix;           //
    algo::Smallstr50   reftype;           //
    algo::Comment      comment;           //
    amc::FFprefix*     zs_fprefix_next;   // zslist link; -1 means not-in-list
private:
    friend amc::FFprefix&       fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFprefix*       fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fprefix_RemoveLast() __attribute__((nothrow));
    FFprefix();
    ~FFprefix();
    FFprefix(const FFprefix&){ /*disallow copy constructor */}
    void operator =(const FFprefix&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fprefix_CopyOut(amc::FFprefix &row, dmmeta::Fprefix &out) __attribute__((nothrow));
// Copy fields in to row
void                 fprefix_CopyIn(amc::FFprefix &row, dmmeta::Fprefix &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFprefix_Init(amc::FFprefix& fprefix);
void                 FFprefix_Uninit(amc::FFprefix& fprefix) __attribute__((nothrow));

// --- amc.FFregx
// create: amc.FDb.fregx (Lary)
// access: amc.FField.c_fregx (Ptr)
struct FFregx { // amc.FFregx
    algo::Smallstr100   field;     //
    bool                partial;   //   false
private:
    friend amc::FFregx&         fregx_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFregx*         fregx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fregx_RemoveLast() __attribute__((nothrow));
    FFregx();
    ~FFregx();
    FFregx(const FFregx&){ /*disallow copy constructor */}
    void operator =(const FFregx&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fregx_CopyIn(amc::FFregx &row, dmmeta::Fregx &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFregx_Init(amc::FFregx& fregx);
void                 FFregx_Uninit(amc::FFregx& fregx) __attribute__((nothrow));

// --- amc.FFsort
// create: amc.FDb.fsort (Lary)
// access: amc.FField.c_fsort (Ptr)
struct FFsort { // amc.FFsort
    algo::Smallstr100   field;       // Field (array etc) being sorted
    algo::Smallstr50    sorttype;    // Kind of sort to generate
    algo::Smallstr100   sortfld;     // Field to sort on
    amc::FField*        p_field;     // reference to parent row
    amc::FField*        p_sortfld;   // reference to parent row
private:
    friend amc::FFsort&         fsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFsort*         fsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fsort_RemoveLast() __attribute__((nothrow));
    FFsort();
    ~FFsort();
    FFsort(const FFsort&){ /*disallow copy constructor */}
    void operator =(const FFsort&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fsort_CopyIn(amc::FFsort &row, dmmeta::Fsort &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFsort_Init(amc::FFsort& fsort);
void                 FFsort_Uninit(amc::FFsort& fsort) __attribute__((nothrow));

// --- amc.FFstep
// create: amc.FDb.fstep (Lary)
// global access: ind_fstep (Thash)
// access: amc.FField.c_fstep (Ptr)
// access: amc.FNs.c_fstep (Ptrary)
struct FFstep { // amc.FFstep
    amc::FFstep*        ind_fstep_next;      // hash next
    algo::Smallstr100   fstep;               //
    algo::Smallstr50    steptype;            //
    algo::Comment       comment;             //
    amc::FFdelay*       c_fdelay;            // optional pointer
    amc::FField*        p_field;             // reference to parent row
    bool                ns_c_fstep_in_ary;   //   false  membership flag
private:
    friend amc::FFstep&         fstep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFstep*         fstep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fstep_RemoveLast() __attribute__((nothrow));
    FFstep();
    ~FFstep();
    FFstep(const FFstep&){ /*disallow copy constructor */}
    void operator =(const FFstep&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 fstep_CopyOut(amc::FFstep &row, dmmeta::Fstep &out) __attribute__((nothrow));
// Copy fields in to row
void                 fstep_CopyIn(amc::FFstep &row, dmmeta::Fstep &in) __attribute__((nothrow));

algo::Smallstr100    field_Get(amc::FFstep& fstep) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(amc::FFstep& fstep) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FFstep& fstep) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fdelay_InsertMaybe(amc::FFstep& fstep, amc::FFdelay& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fdelay_Remove(amc::FFstep& fstep, amc::FFdelay& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FFstep_Init(amc::FFstep& fstep);
void                 FFstep_Uninit(amc::FFstep& fstep) __attribute__((nothrow));

// --- amc.FFtrace
// create: amc.FDb.ftrace (Lary)
// access: amc.FField.c_ftrace (Ptr)
struct FFtrace { // amc.FFtrace
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
private:
    friend amc::FFtrace&        ftrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFtrace*        ftrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ftrace_RemoveLast() __attribute__((nothrow));
    FFtrace();
    ~FFtrace();
    FFtrace(const FFtrace&){ /*disallow copy constructor */}
    void operator =(const FFtrace&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ftrace_CopyOut(amc::FFtrace &row, dmmeta::Ftrace &out) __attribute__((nothrow));
// Copy fields in to row
void                 ftrace_CopyIn(amc::FFtrace &row, dmmeta::Ftrace &in) __attribute__((nothrow));

void                 FFtrace_Uninit(amc::FFtrace& ftrace) __attribute__((nothrow));

// --- amc.FFunc
// create: amc.FDb.func (Lary)
// global access: ind_func (Thash)
// global access: cd_temp_func (Llist)
// access: amc.FCtype.c_init (Ptr)
// access: amc.FCtype.c_ffunc (Ptrary)
// access: amc.FFcmap.c_convfunc (Ptr)
// access: amc.FField.c_ffunc (Ptrary)
// access: amc.FNs.c_func (Ptrary)
// access: amc.Genpnew.p_func (Upptr)
struct FFunc { // amc.FFunc
    amc::FFunc*         ind_func_next;       // hash next
    amc::FFunc*         cd_temp_func_next;   // zslist link; -1 means not-in-list
    amc::FFunc*         cd_temp_func_prev;   // previous element
    algo::Smallstr100   func;                // Primary key
    bool                inl;                 //   false  Make inline?
    algo::cstring       proto;               // Prototype
    algo::cstring       body;                // Body of function
    bool                deprecate;           //   false  Make deprecated?
    bool                ismacro;             //   false  Always inline.
    bool                extrn;               //   false  Implemented externally by user
    bool                glob;                //   false  Function is not attached to a field (EXPLAIN!!)
    bool                priv;                //   false  Private to translateion unit (static)
    algo::cstring       ret;                 // Return type
    algo::cstring       comment;             // Description (keep it as algo.comment)
    bool                printed;             //   false  Already printed? (internal)
    bool                throws;              //   false  Throws exceptions
    bool                nothrow;             //   false  Definitely doesn't throw exception
    bool                disable;             //   false  Function is enabled (if not, don't print)
    bool                oper;                //   false  Is operator?
    bool                globns;              //   false
    amc::FNs*           p_ns;                // reference to parent row
    bool                isalloc;             //   false
    bool                wur;                 //   false  Warn unused result
    algo::Smallstr10    nonnull;             // List of non-null attributes
    bool                pure;                //   false  OK to call fewer times than specified in text
    amc::Funcarg*       funcarg_elems;       // pointer to elements
    u32                 funcarg_n;           // number of elements in array
    u32                 funcarg_max;         // max. capacity of array before realloc
    bool                finalized;           //   false
    bool                istmpl;              //   false
    algo::cstring       funcname;            // Actual callable function name
    bool                ns_c_func_in_ary;    //   false  membership flag
private:
    friend amc::FFunc&          func_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFunc*          func_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 func_RemoveLast() __attribute__((nothrow));
    FFunc();
    ~FFunc();
    FFunc(const FFunc&){ /*disallow copy constructor */}
    void operator =(const FFunc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 func_CopyOut(amc::FFunc &row, dmmeta::Func &out) __attribute__((nothrow));
// Copy fields in to row
void                 func_CopyIn(amc::FFunc &row, dmmeta::Func &in) __attribute__((nothrow));

algo::Smallstr100    field_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     ctype_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
amc::Funcarg&        funcarg_Alloc(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
amc::Funcarg&        funcarg_AllocAt(amc::FFunc& func, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<amc::Funcarg> funcarg_AllocN(amc::FFunc& func, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 funcarg_EmptyQ(amc::FFunc& func) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::Funcarg*        funcarg_Find(amc::FFunc& func, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<amc::Funcarg> funcarg_Getary(amc::FFunc& func) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::Funcarg*        funcarg_Last(amc::FFunc& func) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  funcarg_Max(amc::FFunc& func) __attribute__((nothrow));
// Return number of items in the array
i32                  funcarg_N(const amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 funcarg_Remove(amc::FFunc& func, u32 i) __attribute__((nothrow));
void                 funcarg_RemoveAll(amc::FFunc& func) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 funcarg_RemoveLast(amc::FFunc& func) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 funcarg_Reserve(amc::FFunc& func, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 funcarg_AbsReserve(amc::FFunc& func, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 funcarg_Setary(amc::FFunc& func, amc::FFunc &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::Funcarg&        funcarg_qFind(amc::FFunc& func, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
amc::Funcarg&        funcarg_qLast(amc::FFunc& func) __attribute__((nothrow));
// Return row id of specified element
u64                  funcarg_rowid_Get(amc::FFunc& func, amc::Funcarg &elem) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 funcarg_XrefMaybe(amc::Funcarg &row);

// Set all fields to initial values.
void                 FFunc_Init(amc::FFunc& func);
// proceed to next item
void                 func_funcarg_curs_Next(func_funcarg_curs &curs);
void                 func_funcarg_curs_Reset(func_funcarg_curs &curs, amc::FFunc &parent);
// cursor points to valid item
bool                 func_funcarg_curs_ValidQ(func_funcarg_curs &curs);
// item access
amc::Funcarg&        func_funcarg_curs_Access(func_funcarg_curs &curs);
void                 FFunc_Uninit(amc::FFunc& func) __attribute__((nothrow));

// --- amc.FFunique
// create: amc.FDb.funique (Lary)
// access: amc.FField.c_funique (Ptr)
struct FFunique { // amc.FFunique
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
private:
    friend amc::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 funique_RemoveAll() __attribute__((nothrow));
    friend void                 funique_RemoveLast() __attribute__((nothrow));
    FFunique();
    ~FFunique();
    FFunique(const FFunique&){ /*disallow copy constructor */}
    void operator =(const FFunique&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 funique_CopyOut(amc::FFunique &row, dmmeta::Funique &out) __attribute__((nothrow));
// Copy fields in to row
void                 funique_CopyIn(amc::FFunique &row, dmmeta::Funique &in) __attribute__((nothrow));

void                 FFunique_Uninit(amc::FFunique& funique) __attribute__((nothrow));

// --- amc.FFwddecl
// create: amc.FDb.fwddecl (Lary)
// global access: ind_fwddecl (Thash)
// access: amc.FNs.c_fwddecl (Ptrary)
struct FFwddecl { // amc.FFwddecl
    amc::FFwddecl*      ind_fwddecl_next;      // hash next
    algo::Smallstr100   fwddecl;               //
    bool                ns_c_fwddecl_in_ary;   //   false  membership flag
private:
    friend amc::FFwddecl&       fwddecl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFwddecl*       fwddecl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fwddecl_RemoveLast() __attribute__((nothrow));
    FFwddecl();
    ~FFwddecl();
    FFwddecl(const FFwddecl&){ /*disallow copy constructor */}
    void operator =(const FFwddecl&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 fwddecl_CopyIn(amc::FFwddecl &row, dmmeta::Fwddecl &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FFwddecl& fwddecl) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     ctype_Get(amc::FFwddecl& fwddecl) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FFwddecl_Init(amc::FFwddecl& fwddecl);
void                 FFwddecl_Uninit(amc::FFwddecl& fwddecl) __attribute__((nothrow));

// --- amc.FGconst
// create: amc.FDb.gconst (Lary)
// access: amc.FField.c_gconst (Ptr)
struct FGconst { // amc.FGconst
    algo::Smallstr100   field;       // Field with which to associate constants
    algo::Smallstr100   namefld;     // Field which gives the name of the constant
    algo::Smallstr100   idfld;       // Optional attribute of namefld that gives numeric ID for gconst
    bool                wantenum;    //   true
    amc::FField*        p_namefld;   // reference to parent row
    amc::FField*        p_field;     // reference to parent row
private:
    friend amc::FGconst&        gconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGconst*        gconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gconst_RemoveLast() __attribute__((nothrow));
    FGconst();
    ~FGconst();
    FGconst(const FGconst&){ /*disallow copy constructor */}
    void operator =(const FGconst&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gconst_CopyOut(amc::FGconst &row, dmmeta::Gconst &out) __attribute__((nothrow));
// Copy fields in to row
void                 gconst_CopyIn(amc::FGconst &row, dmmeta::Gconst &in) __attribute__((nothrow));

algo::Smallstr50     namefldctyp_Get(amc::FGconst& gconst) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGconst_Init(amc::FGconst& gconst);
void                 FGconst_Uninit(amc::FGconst& gconst) __attribute__((nothrow));

// --- amc.FGen
// create: amc.FDb.gen (Lary)
// global access: zs_gen_perns (Llist)
struct FGen { // amc.FGen
    amc::FGen*           zs_gen_perns_next;   // zslist link; -1 means not-in-list
    algo::Smallstr50     gen;                 //
    bool                 perns;               //   false
    algo::Comment        comment;             //
    u64                  cycle_total;         //   0
    amc::gen_step_hook   step;                //   NULL  Pointer to a function
private:
    friend amc::FGen&           gen_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGen*           gen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gen_RemoveAll() __attribute__((nothrow));
    friend void                 gen_RemoveLast() __attribute__((nothrow));
    FGen();
    ~FGen();
    FGen(const FGen&){ /*disallow copy constructor */}
    void operator =(const FGen&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gen_CopyOut(amc::FGen &row, amcdb::Gen &out) __attribute__((nothrow));
// Copy fields in to row
void                 gen_CopyIn(amc::FGen &row, amcdb::Gen &in) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(amc::FGen& gen) __attribute__((nothrow));

// Set all fields to initial values.
void                 FGen_Init(amc::FGen& gen);
void                 FGen_Uninit(amc::FGen& gen) __attribute__((nothrow));

// --- amc.FGenXref
struct FGenXref { // amc.FGenXref
    amc::FGenXrefSeen**   ind_seen_buckets_elems;   // pointer to bucket array
    i32                   ind_seen_buckets_n;       // number of elements in bucket array
    i32                   ind_seen_n;               // number of elements in the hash table
    amc::FGenXrefSeen*    seen_lary[32];            // level array
    i32                   seen_n;                   // number of elements in array
    FGenXref();
    ~FGenXref();
private:
    // reftype of amc.FGenXref.ind_seen prohibits copy
    // reftype of amc.FGenXref.seen prohibits copy
    FGenXref(const FGenXref&){ /*disallow copy constructor */}
    void operator =(const FGenXref&){ /*disallow direct assignment */}
};

// Return true if hash is empty
bool                 ind_seen_EmptyQ(amc::FGenXref& parent) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
amc::FGenXrefSeen*   ind_seen_Find(amc::FGenXref& parent, const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
i32                  ind_seen_N(const amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_seen_InsertMaybe(amc::FGenXref& parent, amc::FGenXrefSeen& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_seen_Remove(amc::FGenXref& parent, amc::FGenXrefSeen& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_seen_Reserve(amc::FGenXref& parent, int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
amc::FGenXrefSeen&   seen_Alloc(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
amc::FGenXrefSeen*   seen_AllocMaybe(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                seen_AllocMem(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 seen_EmptyQ(amc::FGenXref& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGenXrefSeen*   seen_Find(amc::FGenXref& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
amc::FGenXrefSeen*   seen_Last(amc::FGenXref& parent) __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  seen_N(const amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 seen_RemoveAll(amc::FGenXref& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 seen_RemoveLast(amc::FGenXref& parent) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
amc::FGenXrefSeen&   seen_qFind(amc::FGenXref& parent, u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Call Unref or Delete to cleanup partially inserted row.
bool                 seen_XrefMaybe(amc::FGenXrefSeen &row);

// cursor points to valid item
void                 FGenXref_seen_curs_Reset(FGenXref_seen_curs &curs, amc::FGenXref &parent);
// cursor points to valid item
bool                 FGenXref_seen_curs_ValidQ(FGenXref_seen_curs &curs);
// proceed to next item
void                 FGenXref_seen_curs_Next(FGenXref_seen_curs &curs);
// item access
amc::FGenXrefSeen&   FGenXref_seen_curs_Access(FGenXref_seen_curs &curs);
// Set all fields to initial values.
void                 FGenXref_Init(amc::FGenXref& parent);
void                 FGenXref_Uninit(amc::FGenXref& parent) __attribute__((nothrow));

// --- amc.FGenXrefSeen
// create: amc.FGenXref.seen (Lary)
// access: amc.FGenXref.ind_seen (Thash)
struct FGenXrefSeen { // amc.FGenXrefSeen
    amc::FGenXrefSeen*   ind_seen_next;   // hash next
    algo::cstring        value;           //
    algo::Smallstr100    via;             // Saved via
    algo::Smallstr100    xreffld;         // Saved xreffld
private:
    friend amc::FGenXrefSeen&   seen_Alloc(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGenXrefSeen*   seen_AllocMaybe(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
    friend void                 seen_RemoveAll(amc::FGenXref& parent) __attribute__((nothrow));
    friend void                 seen_RemoveLast(amc::FGenXref& parent) __attribute__((nothrow));
    FGenXrefSeen();
};

// Set all fields to initial values.
void                 FGenXrefSeen_Init(amc::FGenXrefSeen& seen);

// --- amc.FGstatic
// create: amc.FDb.gstatic (Lary)
// access: amc.FField.c_gstatic (Ptr)
// access: amc.FNs.c_gstatic (Ptrary)
struct FGstatic { // amc.FGstatic
    algo::Smallstr100   field;                 //
    amc::FField*        p_field;               // reference to parent row
    u32                 rowid;                 //   0
    bool                ns_c_gstatic_in_ary;   //   false  membership flag
private:
    friend amc::FGstatic&       gstatic_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGstatic*       gstatic_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gstatic_RemoveLast() __attribute__((nothrow));
    FGstatic();
    ~FGstatic();
    FGstatic(const FGstatic&){ /*disallow copy constructor */}
    void operator =(const FGstatic&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 gstatic_CopyIn(amc::FGstatic &row, dmmeta::Gstatic &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FGstatic& gstatic) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGstatic_Init(amc::FGstatic& gstatic);
void                 FGstatic_Uninit(amc::FGstatic& gstatic) __attribute__((nothrow));

// --- amc.FGsymbol
// create: amc.FDb.gsymbol (Lary)
// access: amc.FNs.c_gsymbol (Ptrary)
struct FGsymbol { // amc.FGsymbol
    algo::Smallstr50    gsymbol;               //
    algo::Smallstr100   inc;                   //
    algo::Comment       comment;               //
    bool                ns_c_gsymbol_in_ary;   //   false  membership flag
private:
    friend amc::FGsymbol&       gsymbol_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGsymbol*       gsymbol_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gsymbol_RemoveAll() __attribute__((nothrow));
    friend void                 gsymbol_RemoveLast() __attribute__((nothrow));
    FGsymbol();
    ~FGsymbol();
    FGsymbol(const FGsymbol&){ /*disallow copy constructor */}
    void operator =(const FGsymbol&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 gsymbol_CopyOut(amc::FGsymbol &row, dmmeta::Gsymbol &out) __attribute__((nothrow));
// Copy fields in to row
void                 gsymbol_CopyIn(amc::FGsymbol &row, dmmeta::Gsymbol &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FGsymbol& gsymbol) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     ssimfile_Get(amc::FGsymbol& gsymbol) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FGsymbol_Init(amc::FGsymbol& gsymbol);
void                 FGsymbol_Uninit(amc::FGsymbol& gsymbol) __attribute__((nothrow));

// --- amc.FHook
// create: amc.FDb.hook (Lary)
// access: amc.FField.c_hook (Ptr)
struct FHook { // amc.FHook
    algo::Smallstr100   field;       // The field
    algo::Comment       comment;     //
    amc::FCtype*        p_funcptr;   // reference to parent row
    amc::FField*        p_field;     // reference to parent row
private:
    friend amc::FHook&          hook_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FHook*          hook_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 hook_RemoveAll() __attribute__((nothrow));
    friend void                 hook_RemoveLast() __attribute__((nothrow));
    FHook();
    ~FHook();
    FHook(const FHook&){ /*disallow copy constructor */}
    void operator =(const FHook&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 hook_CopyOut(amc::FHook &row, dmmeta::Hook &out) __attribute__((nothrow));
// Copy fields in to row
void                 hook_CopyIn(amc::FHook &row, dmmeta::Hook &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FHook_Init(amc::FHook& hook);
void                 FHook_Uninit(amc::FHook& hook) __attribute__((nothrow));

// --- amc.FInlary
// create: amc.FDb.inlary (Lary)
// global access: ind_inlary (Thash)
// access: amc.FField.c_inlary (Ptr)
struct FInlary { // amc.FInlary
    amc::FInlary*       ind_inlary_next;   // hash next
    algo::Smallstr100   field;             //
    i32                 min;               //   0  Min. elements to preallocate
    i32                 max;               //   0  Max. elements
    algo::Comment       comment;           //
private:
    friend amc::FInlary&        inlary_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FInlary*        inlary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 inlary_RemoveLast() __attribute__((nothrow));
    FInlary();
    ~FInlary();
    FInlary(const FInlary&){ /*disallow copy constructor */}
    void operator =(const FInlary&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 inlary_CopyOut(amc::FInlary &row, dmmeta::Inlary &out) __attribute__((nothrow));
// Copy fields in to row
void                 inlary_CopyIn(amc::FInlary &row, dmmeta::Inlary &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FInlary_Init(amc::FInlary& inlary);
void                 FInlary_Uninit(amc::FInlary& inlary) __attribute__((nothrow));

// --- amc.FLenfld
// create: amc.FDb.lenfld (Lary)
// access: amc.FCtype.c_lenfld (Ptr)
struct FLenfld { // amc.FLenfld
    algo::Smallstr100   field;     // Name of length field
    i32                 extra;     //   0  Extra #bytes to add
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FLenfld&        lenfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FLenfld*        lenfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 lenfld_RemoveLast() __attribute__((nothrow));
    FLenfld();
    ~FLenfld();
    FLenfld(const FLenfld&){ /*disallow copy constructor */}
    void operator =(const FLenfld&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 lenfld_CopyOut(amc::FLenfld &row, dmmeta::Lenfld &out) __attribute__((nothrow));
// Copy fields in to row
void                 lenfld_CopyIn(amc::FLenfld &row, dmmeta::Lenfld &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FLenfld& lenfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FLenfld_Init(amc::FLenfld& lenfld);
void                 FLenfld_Uninit(amc::FLenfld& lenfld) __attribute__((nothrow));

// --- amc.FListtype
// create: amc.FDb.listtype (Lary)
// global access: ind_listtype (Thash)
// access: amc.FLlist.p_listtype (Upptr)
struct FListtype { // amc.FListtype
    amc::FListtype*   ind_listtype_next;   // hash next
    algo::Smallstr5   listtype;            //
    bool              circular;            //   false  Circular list
    bool              haveprev;            //   false  Previous link
    bool              instail;             //   false  Queue
private:
    friend amc::FListtype&      listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FListtype*      listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 listtype_RemoveLast() __attribute__((nothrow));
    FListtype();
    ~FListtype();
    FListtype(const FListtype&){ /*disallow copy constructor */}
    void operator =(const FListtype&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 listtype_CopyIn(amc::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FListtype_Init(amc::FListtype& listtype);
void                 FListtype_Uninit(amc::FListtype& listtype) __attribute__((nothrow));

// --- amc.FLlist
// create: amc.FDb.llist (Lary)
// access: amc.FField.c_llist (Ptr)
struct FLlist { // amc.FLlist
    algo::Smallstr100   field;        // Index in question
    bool                havetail;     //   true  Generate 'tail' field
    bool                havecount;    //   false  Generate count of elements
    amc::FListtype*     p_listtype;   // reference to parent row
private:
    friend amc::FLlist&         llist_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FLlist*         llist_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 llist_RemoveLast() __attribute__((nothrow));
    FLlist();
    ~FLlist();
    FLlist(const FLlist&){ /*disallow copy constructor */}
    void operator =(const FLlist&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 llist_CopyIn(amc::FLlist &row, dmmeta::Llist &in) __attribute__((nothrow));

algo::Smallstr5      listtype_Get(amc::FLlist& llist) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FLlist_Init(amc::FLlist& llist);
void                 FLlist_Uninit(amc::FLlist& llist) __attribute__((nothrow));

// --- amc.FMain
// create: amc.FDb.main (Lary)
// global access: ind_main (Thash)
// access: amc.FNs.c_main (Ptr)
struct FMain { // amc.FMain
    amc::FMain*        ind_main_next;   // hash next
    algo::Smallstr16   ns;              //
    bool               ismodule;        //   false
private:
    friend amc::FMain&          main_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FMain*          main_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 main_RemoveLast() __attribute__((nothrow));
    FMain();
    ~FMain();
    FMain(const FMain&){ /*disallow copy constructor */}
    void operator =(const FMain&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 main_CopyIn(amc::FMain &row, dmmeta::Main &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FMain_Init(amc::FMain& main);
void                 FMain_Uninit(amc::FMain& main) __attribute__((nothrow));

// --- amc.FMsgtype
// create: amc.FDb.msgtype (Lary)
// access: amc.FCtype.c_msgtype (Ptr)
struct FMsgtype { // amc.FMsgtype
    algo::Smallstr50   ctype;     //
    dmmeta::CppExpr    type;      //
    amc::FCtype*       p_ctype;   // reference to parent row
private:
    friend amc::FMsgtype&       msgtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FMsgtype*       msgtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 msgtype_RemoveLast() __attribute__((nothrow));
    FMsgtype();
    ~FMsgtype();
    FMsgtype(const FMsgtype&){ /*disallow copy constructor */}
    void operator =(const FMsgtype&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 msgtype_CopyIn(amc::FMsgtype &row, dmmeta::Msgtype &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FMsgtype_Init(amc::FMsgtype& msgtype);
void                 FMsgtype_Uninit(amc::FMsgtype& msgtype) __attribute__((nothrow));

// --- amc.FNocascdel
// create: amc.FDb.nocascdel (Lary)
// access: amc.FXref.c_nocascdel (Ptr)
struct FNocascdel { // amc.FNocascdel
    algo::Smallstr100   xref;   //
private:
    friend amc::FNocascdel&     nocascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNocascdel*     nocascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nocascdel_RemoveLast() __attribute__((nothrow));
    FNocascdel();
    ~FNocascdel();
    FNocascdel(const FNocascdel&){ /*disallow copy constructor */}
    void operator =(const FNocascdel&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 nocascdel_CopyIn(amc::FNocascdel &row, dmmeta::Nocascdel &in) __attribute__((nothrow));

void                 FNocascdel_Uninit(amc::FNocascdel& nocascdel) __attribute__((nothrow));

// --- amc.FNossimfile
// create: amc.FDb.nossimfile (Lary)
// access: amc.FCtype.c_nossimfile (Ptr)
struct FNossimfile { // amc.FNossimfile
    algo::Smallstr50   ctype;     //
    algo::Comment      comment;   //
private:
    friend amc::FNossimfile&    nossimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNossimfile*    nossimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nossimfile_RemoveAll() __attribute__((nothrow));
    friend void                 nossimfile_RemoveLast() __attribute__((nothrow));
    FNossimfile();
    ~FNossimfile();
    FNossimfile(const FNossimfile&){ /*disallow copy constructor */}
    void operator =(const FNossimfile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 nossimfile_CopyOut(amc::FNossimfile &row, dmmeta::Nossimfile &out) __attribute__((nothrow));
// Copy fields in to row
void                 nossimfile_CopyIn(amc::FNossimfile &row, dmmeta::Nossimfile &in) __attribute__((nothrow));

void                 FNossimfile_Uninit(amc::FNossimfile& nossimfile) __attribute__((nothrow));

// --- amc.FNoxref
// create: amc.FDb.noxref (Lary)
// access: amc.FField.c_noxref (Ptr)
struct FNoxref { // amc.FNoxref
    algo::Smallstr100   field;   //
private:
    friend amc::FNoxref&        noxref_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNoxref*        noxref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 noxref_RemoveLast() __attribute__((nothrow));
    FNoxref();
    ~FNoxref();
    FNoxref(const FNoxref&){ /*disallow copy constructor */}
    void operator =(const FNoxref&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 noxref_CopyIn(amc::FNoxref &row, dmmeta::Noxref &in) __attribute__((nothrow));

void                 FNoxref_Uninit(amc::FNoxref& noxref) __attribute__((nothrow));

// --- amc.FNs
// create: amc.FDb.ns (Lary)
// global access: ind_ns (Thash)
// global access: c_ns_sorted (Ptrary)
// global access: c_curns (Ptr)
// global access: c_ns (Ptr)
// access: amc.FCtype.p_ns (Upptr)
// access: amc.FDispatch.p_ns (Upptr)
// access: amc.FFcmdline.p_ns (Upptr)
// access: amc.FFunc.p_ns (Upptr)
// access: amc.FNs.c_parentns (Ptrary)
// access: amc.FNs.c_cppincl (Ptrary)
// access: amc.FNs.c_hdrincl (Ptrary)
// access: amc.FOutfile.p_ns (Upptr)
// access: amc.FPnew.p_ns (Upptr)
// access: amc.FTarget.p_ns (Upptr)
struct FNs { // amc.FNs
    amc::FNs*           ind_ns_next;         // hash next
    algo::Smallstr16    ns;                  // Namespace name (primary key)
    algo::Smallstr50    nstype;              //
    algo::Comment       comment;             //
    i32                 nhash;               //   0  number of hash functions generated (hack)
    algo::cstring       curstext;            //
    amc::FCtype**       c_ctype_elems;       // array of pointers
    u32                 c_ctype_n;           // array of pointers
    u32                 c_ctype_max;         // capacity of allocated array
    amc::FFunc**        c_func_elems;        // array of pointers
    u32                 c_func_n;            // array of pointers
    u32                 c_func_max;          // capacity of allocated array
    amc::FDispatch**    c_dispatch_elems;    // array of pointers
    u32                 c_dispatch_n;        // array of pointers
    u32                 c_dispatch_max;      // capacity of allocated array
    amc::FField*        c_globfld;           // optional pointer
    amc::FGstatic**     c_gstatic_elems;     // array of pointers
    u32                 c_gstatic_n;         // array of pointers
    u32                 c_gstatic_max;       // capacity of allocated array
    amc::FMain*         c_main;              // optional pointer
    algo::cstring*      hdr;                 // Temporary hack -- pointer to hdr contents. optional pointer
    algo::cstring*      inl;                 // optional pointer
    algo::cstring*      cpp;                 // optional pointer
    algo::cstring*      include_elems;       // pointer to elements
    u32                 include_n;           // number of elements in array
    u32                 include_max;         // max. capacity of array before realloc
    amc::FCtype**       c_ctype_ins_elems;   // array of pointers
    u32                 c_ctype_ins_n;       // array of pointers
    u32                 c_ctype_ins_max;     // capacity of allocated array
    bool                topo_visited;        //   false
    algo::Sha1sig       signature;           //
    algo::Sha1sig       signature_input;     //
    amc::FDispsig**     c_dispsig_elems;     // array of pointers
    u32                 c_dispsig_n;         // array of pointers
    u32                 c_dispsig_max;       // capacity of allocated array
    amc::FNs**          c_parentns_elems;    // array of pointers
    u32                 c_parentns_n;        // array of pointers
    u32                 c_parentns_max;      // capacity of allocated array
    amc::FNs**          c_cppincl_elems;     // array of pointers
    u32                 c_cppincl_n;         // array of pointers
    u32                 c_cppincl_max;       // capacity of allocated array
    amc::FNs**          c_hdrincl_elems;     // array of pointers
    u32                 c_hdrincl_n;         // array of pointers
    u32                 c_hdrincl_max;       // capacity of allocated array
    amc::FFwddecl**     c_fwddecl_elems;     // array of pointers
    u32                 c_fwddecl_n;         // array of pointers
    u32                 c_fwddecl_max;       // capacity of allocated array
    bool                select;              //   false
    amc::FNsx*          c_nsx;               // optional pointer
    amc::FTarget*       c_target;            // optional pointer
    amc::FPnew**        c_pnew_elems;        // array of pointers
    u32                 c_pnew_n;            // array of pointers
    u32                 c_pnew_max;          // capacity of allocated array
    amc::FFcmdline*     c_fcmdline;          // optional pointer
    amc::FNsproto*      c_nsproto;           // optional pointer
    amc::FNsdb*         c_nsdb;              // optional pointer
    amc::FOutfile**     c_outfile_elems;     // array of pointers
    u32                 c_outfile_n;         // array of pointers
    u32                 c_outfile_max;       // capacity of allocated array
    amc::FFinput**      c_finput_elems;      // array of pointers
    u32                 c_finput_n;          // array of pointers
    u32                 c_finput_max;        // capacity of allocated array
    amc::FFoutput**     c_foutput_elems;     // array of pointers
    u32                 c_foutput_n;         // array of pointers
    u32                 c_foutput_max;       // capacity of allocated array
    amc::FFstep**       c_fstep_elems;       // array of pointers
    u32                 c_fstep_n;           // array of pointers
    u32                 c_fstep_max;         // capacity of allocated array
    amc::FGsymbol**     c_gsymbol_elems;     // array of pointers
    u32                 c_gsymbol_n;         // array of pointers
    u32                 c_gsymbol_max;       // capacity of allocated array
    amc::FNsinclude**   c_nsinclude_elems;   // array of pointers
    u32                 c_nsinclude_n;       // array of pointers
    u32                 c_nsinclude_max;     // capacity of allocated array
private:
    friend amc::FNs&            ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNs*            ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
    FNs();
    ~FNs();
    FNs(const FNs&){ /*disallow copy constructor */}
    void operator =(const FNs&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ns_CopyOut(amc::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
void                 ns_CopyIn(amc::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_ctype_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtype*         c_ctype_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FCtype*> c_ctype_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ctype_Insert(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_ctype_InsertMaybe(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ctype_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ctype_Remove(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ctype_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ctype_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_func_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFunc*          c_func_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFunc*> c_func_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_func_Insert(amc::FNs& ns, amc::FFunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_func_InsertMaybe(amc::FNs& ns, amc::FFunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_func_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_func_Remove(amc::FNs& ns, amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_func_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_func_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_dispatch_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispatch*      c_dispatch_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FDispatch*> c_dispatch_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_dispatch_Insert(amc::FNs& ns, amc::FDispatch& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_dispatch_InsertMaybe(amc::FNs& ns, amc::FDispatch& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_dispatch_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_dispatch_Remove(amc::FNs& ns, amc::FDispatch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_dispatch_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_dispatch_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_globfld_InsertMaybe(amc::FNs& ns, amc::FField& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_globfld_Remove(amc::FNs& ns, amc::FField& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gstatic_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGstatic*       c_gstatic_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FGstatic*> c_gstatic_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gstatic_Insert(amc::FNs& ns, amc::FGstatic& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gstatic_InsertMaybe(amc::FNs& ns, amc::FGstatic& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gstatic_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gstatic_Remove(amc::FNs& ns, amc::FGstatic& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gstatic_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gstatic_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_main_InsertMaybe(amc::FNs& ns, amc::FMain& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_main_Remove(amc::FNs& ns, amc::FMain& row) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       include_Alloc(amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       include_AllocAt(amc::FNs& ns, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> include_AllocN(amc::FNs& ns, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 include_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       include_Find(amc::FNs& ns, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> include_Getary(amc::FNs& ns) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       include_Last(amc::FNs& ns) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  include_Max(amc::FNs& ns) __attribute__((nothrow));
// Return number of items in the array
i32                  include_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 include_Remove(amc::FNs& ns, u32 i) __attribute__((nothrow));
void                 include_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 include_RemoveLast(amc::FNs& ns) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 include_Reserve(amc::FNs& ns, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 include_AbsReserve(amc::FNs& ns, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 include_Setary(amc::FNs& ns, amc::FNs &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       include_qFind(amc::FNs& ns, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       include_qLast(amc::FNs& ns) __attribute__((nothrow));
// Return row id of specified element
u64                  include_rowid_Get(amc::FNs& ns, algo::cstring &elem) __attribute__((nothrow));

// Return true if index is empty
bool                 c_ctype_ins_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FCtype*         c_ctype_ins_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FCtype*> c_ctype_ins_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_ctype_ins_Insert(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_ctype_ins_InsertMaybe(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_ctype_ins_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_ctype_ins_Remove(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_ctype_ins_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_ctype_ins_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_dispsig_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FDispsig*       c_dispsig_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FDispsig*> c_dispsig_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_dispsig_Insert(amc::FNs& ns, amc::FDispsig& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_dispsig_InsertMaybe(amc::FNs& ns, amc::FDispsig& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_dispsig_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_dispsig_Remove(amc::FNs& ns, amc::FDispsig& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_dispsig_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_dispsig_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_parentns_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNs*            c_parentns_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FNs*> c_parentns_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_parentns_Insert(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_parentns_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_parentns_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_parentns_Remove(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_parentns_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_parentns_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_cppincl_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNs*            c_cppincl_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FNs*> c_cppincl_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_cppincl_Insert(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_cppincl_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_cppincl_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_cppincl_Remove(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_cppincl_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_cppincl_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_hdrincl_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNs*            c_hdrincl_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FNs*> c_hdrincl_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_hdrincl_Insert(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
bool                 c_hdrincl_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_hdrincl_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_hdrincl_Remove(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_hdrincl_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_hdrincl_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_fwddecl_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFwddecl*       c_fwddecl_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFwddecl*> c_fwddecl_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_fwddecl_Insert(amc::FNs& ns, amc::FFwddecl& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_fwddecl_InsertMaybe(amc::FNs& ns, amc::FFwddecl& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_fwddecl_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_fwddecl_Remove(amc::FNs& ns, amc::FFwddecl& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_fwddecl_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_fwddecl_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_nsx_InsertMaybe(amc::FNs& ns, amc::FNsx& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_nsx_Remove(amc::FNs& ns, amc::FNsx& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_target_InsertMaybe(amc::FNs& ns, amc::FTarget& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_target_Remove(amc::FNs& ns, amc::FTarget& row) __attribute__((nothrow));

// Return true if index is empty
bool                 c_pnew_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FPnew*          c_pnew_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FPnew*> c_pnew_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_pnew_Insert(amc::FNs& ns, amc::FPnew& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_pnew_InsertMaybe(amc::FNs& ns, amc::FPnew& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_pnew_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_pnew_Remove(amc::FNs& ns, amc::FPnew& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_pnew_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_pnew_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_fcmdline_InsertMaybe(amc::FNs& ns, amc::FFcmdline& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_fcmdline_Remove(amc::FNs& ns, amc::FFcmdline& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_nsproto_InsertMaybe(amc::FNs& ns, amc::FNsproto& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_nsproto_Remove(amc::FNs& ns, amc::FNsproto& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_nsdb_InsertMaybe(amc::FNs& ns, amc::FNsdb& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_nsdb_Remove(amc::FNs& ns, amc::FNsdb& row) __attribute__((nothrow));

// Delete all elements pointed to by the index.
void                 c_outfile_Cascdel(amc::FNs& ns) __attribute__((nothrow));
// Return true if index is empty
bool                 c_outfile_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FOutfile*       c_outfile_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FOutfile*> c_outfile_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_outfile_Insert(amc::FNs& ns, amc::FOutfile& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_outfile_InsertMaybe(amc::FNs& ns, amc::FOutfile& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_outfile_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_outfile_Remove(amc::FNs& ns, amc::FOutfile& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_outfile_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_outfile_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_finput_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFinput*        c_finput_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFinput*> c_finput_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_finput_Insert(amc::FNs& ns, amc::FFinput& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_finput_InsertMaybe(amc::FNs& ns, amc::FFinput& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_finput_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_finput_Remove(amc::FNs& ns, amc::FFinput& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_finput_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_finput_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_foutput_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFoutput*       c_foutput_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFoutput*> c_foutput_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_foutput_Insert(amc::FNs& ns, amc::FFoutput& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_foutput_InsertMaybe(amc::FNs& ns, amc::FFoutput& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_foutput_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_foutput_Remove(amc::FNs& ns, amc::FFoutput& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_foutput_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_foutput_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_fstep_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FFstep*         c_fstep_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FFstep*> c_fstep_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_fstep_Insert(amc::FNs& ns, amc::FFstep& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_fstep_InsertMaybe(amc::FNs& ns, amc::FFstep& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_fstep_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_fstep_Remove(amc::FNs& ns, amc::FFstep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_fstep_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_fstep_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_gsymbol_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FGsymbol*       c_gsymbol_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FGsymbol*> c_gsymbol_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_gsymbol_Insert(amc::FNs& ns, amc::FGsymbol& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_gsymbol_InsertMaybe(amc::FNs& ns, amc::FGsymbol& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_gsymbol_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_gsymbol_Remove(amc::FNs& ns, amc::FGsymbol& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_gsymbol_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_gsymbol_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_nsinclude_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FNsinclude*     c_nsinclude_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FNsinclude*> c_nsinclude_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_nsinclude_Insert(amc::FNs& ns, amc::FNsinclude& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_nsinclude_InsertMaybe(amc::FNs& ns, amc::FNsinclude& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_nsinclude_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_nsinclude_Remove(amc::FNs& ns, amc::FNsinclude& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_nsinclude_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_nsinclude_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNs_Init(amc::FNs& ns);
void                 ns_c_ctype_curs_Reset(ns_c_ctype_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_ctype_curs_ValidQ(ns_c_ctype_curs &curs);
// proceed to next item
void                 ns_c_ctype_curs_Next(ns_c_ctype_curs &curs);
// item access
amc::FCtype&         ns_c_ctype_curs_Access(ns_c_ctype_curs &curs);
void                 ns_c_func_curs_Reset(ns_c_func_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_func_curs_ValidQ(ns_c_func_curs &curs);
// proceed to next item
void                 ns_c_func_curs_Next(ns_c_func_curs &curs);
// item access
amc::FFunc&          ns_c_func_curs_Access(ns_c_func_curs &curs);
void                 ns_c_dispatch_curs_Reset(ns_c_dispatch_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_dispatch_curs_ValidQ(ns_c_dispatch_curs &curs);
// proceed to next item
void                 ns_c_dispatch_curs_Next(ns_c_dispatch_curs &curs);
// item access
amc::FDispatch&      ns_c_dispatch_curs_Access(ns_c_dispatch_curs &curs);
void                 ns_c_gstatic_curs_Reset(ns_c_gstatic_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_gstatic_curs_ValidQ(ns_c_gstatic_curs &curs);
// proceed to next item
void                 ns_c_gstatic_curs_Next(ns_c_gstatic_curs &curs);
// item access
amc::FGstatic&       ns_c_gstatic_curs_Access(ns_c_gstatic_curs &curs);
// proceed to next item
void                 ns_include_curs_Next(ns_include_curs &curs);
void                 ns_include_curs_Reset(ns_include_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_include_curs_ValidQ(ns_include_curs &curs);
// item access
algo::cstring&       ns_include_curs_Access(ns_include_curs &curs);
void                 ns_c_ctype_ins_curs_Reset(ns_c_ctype_ins_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_ctype_ins_curs_ValidQ(ns_c_ctype_ins_curs &curs);
// proceed to next item
void                 ns_c_ctype_ins_curs_Next(ns_c_ctype_ins_curs &curs);
// item access
amc::FCtype&         ns_c_ctype_ins_curs_Access(ns_c_ctype_ins_curs &curs);
void                 ns_c_dispsig_curs_Reset(ns_c_dispsig_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_dispsig_curs_ValidQ(ns_c_dispsig_curs &curs);
// proceed to next item
void                 ns_c_dispsig_curs_Next(ns_c_dispsig_curs &curs);
// item access
amc::FDispsig&       ns_c_dispsig_curs_Access(ns_c_dispsig_curs &curs);
void                 ns_c_parentns_curs_Reset(ns_c_parentns_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_parentns_curs_ValidQ(ns_c_parentns_curs &curs);
// proceed to next item
void                 ns_c_parentns_curs_Next(ns_c_parentns_curs &curs);
// item access
amc::FNs&            ns_c_parentns_curs_Access(ns_c_parentns_curs &curs);
void                 ns_c_cppincl_curs_Reset(ns_c_cppincl_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_cppincl_curs_ValidQ(ns_c_cppincl_curs &curs);
// proceed to next item
void                 ns_c_cppincl_curs_Next(ns_c_cppincl_curs &curs);
// item access
amc::FNs&            ns_c_cppincl_curs_Access(ns_c_cppincl_curs &curs);
void                 ns_c_hdrincl_curs_Reset(ns_c_hdrincl_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_hdrincl_curs_ValidQ(ns_c_hdrincl_curs &curs);
// proceed to next item
void                 ns_c_hdrincl_curs_Next(ns_c_hdrincl_curs &curs);
// item access
amc::FNs&            ns_c_hdrincl_curs_Access(ns_c_hdrincl_curs &curs);
void                 ns_c_fwddecl_curs_Reset(ns_c_fwddecl_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_fwddecl_curs_ValidQ(ns_c_fwddecl_curs &curs);
// proceed to next item
void                 ns_c_fwddecl_curs_Next(ns_c_fwddecl_curs &curs);
// item access
amc::FFwddecl&       ns_c_fwddecl_curs_Access(ns_c_fwddecl_curs &curs);
void                 ns_c_pnew_curs_Reset(ns_c_pnew_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_pnew_curs_ValidQ(ns_c_pnew_curs &curs);
// proceed to next item
void                 ns_c_pnew_curs_Next(ns_c_pnew_curs &curs);
// item access
amc::FPnew&          ns_c_pnew_curs_Access(ns_c_pnew_curs &curs);
void                 ns_c_outfile_curs_Reset(ns_c_outfile_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_outfile_curs_ValidQ(ns_c_outfile_curs &curs);
// proceed to next item
void                 ns_c_outfile_curs_Next(ns_c_outfile_curs &curs);
// item access
amc::FOutfile&       ns_c_outfile_curs_Access(ns_c_outfile_curs &curs);
void                 ns_c_finput_curs_Reset(ns_c_finput_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_finput_curs_ValidQ(ns_c_finput_curs &curs);
// proceed to next item
void                 ns_c_finput_curs_Next(ns_c_finput_curs &curs);
// item access
amc::FFinput&        ns_c_finput_curs_Access(ns_c_finput_curs &curs);
void                 ns_c_foutput_curs_Reset(ns_c_foutput_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_foutput_curs_ValidQ(ns_c_foutput_curs &curs);
// proceed to next item
void                 ns_c_foutput_curs_Next(ns_c_foutput_curs &curs);
// item access
amc::FFoutput&       ns_c_foutput_curs_Access(ns_c_foutput_curs &curs);
void                 ns_c_fstep_curs_Reset(ns_c_fstep_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_fstep_curs_ValidQ(ns_c_fstep_curs &curs);
// proceed to next item
void                 ns_c_fstep_curs_Next(ns_c_fstep_curs &curs);
// item access
amc::FFstep&         ns_c_fstep_curs_Access(ns_c_fstep_curs &curs);
void                 ns_c_gsymbol_curs_Reset(ns_c_gsymbol_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_gsymbol_curs_ValidQ(ns_c_gsymbol_curs &curs);
// proceed to next item
void                 ns_c_gsymbol_curs_Next(ns_c_gsymbol_curs &curs);
// item access
amc::FGsymbol&       ns_c_gsymbol_curs_Access(ns_c_gsymbol_curs &curs);
void                 ns_c_nsinclude_curs_Reset(ns_c_nsinclude_curs &curs, amc::FNs &parent);
// cursor points to valid item
bool                 ns_c_nsinclude_curs_ValidQ(ns_c_nsinclude_curs &curs);
// proceed to next item
void                 ns_c_nsinclude_curs_Next(ns_c_nsinclude_curs &curs);
// item access
amc::FNsinclude&     ns_c_nsinclude_curs_Access(ns_c_nsinclude_curs &curs);
void                 FNs_Uninit(amc::FNs& ns) __attribute__((nothrow));

// --- amc.FNsdb
// create: amc.FDb.nsdb (Lary)
// access: amc.FNs.c_nsdb (Ptr)
struct FNsdb { // amc.FNsdb
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
private:
    friend amc::FNsdb&          nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsdb*          nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsdb_RemoveLast() __attribute__((nothrow));
    FNsdb();
    ~FNsdb();
    FNsdb(const FNsdb&){ /*disallow copy constructor */}
    void operator =(const FNsdb&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 nsdb_CopyOut(amc::FNsdb &row, dmmeta::Nsdb &out) __attribute__((nothrow));
// Copy fields in to row
void                 nsdb_CopyIn(amc::FNsdb &row, dmmeta::Nsdb &in) __attribute__((nothrow));

void                 FNsdb_Uninit(amc::FNsdb& nsdb) __attribute__((nothrow));

// --- amc.FNsinclude
// create: amc.FDb.nsinclude (Lary)
// access: amc.FNs.c_nsinclude (Ptrary)
struct FNsinclude { // amc.FNsinclude
    algo::Smallstr50   nsinclude;               //
    bool               sys;                     //   false
    algo::Comment      comment;                 //
    bool               ns_c_nsinclude_in_ary;   //   false  membership flag
private:
    friend amc::FNsinclude&     nsinclude_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsinclude*     nsinclude_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsinclude_RemoveAll() __attribute__((nothrow));
    friend void                 nsinclude_RemoveLast() __attribute__((nothrow));
    FNsinclude();
    ~FNsinclude();
    FNsinclude(const FNsinclude&){ /*disallow copy constructor */}
    void operator =(const FNsinclude&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 nsinclude_CopyOut(amc::FNsinclude &row, dmmeta::Nsinclude &out) __attribute__((nothrow));
// Copy fields in to row
void                 nsinclude_CopyIn(amc::FNsinclude &row, dmmeta::Nsinclude &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FNsinclude& nsinclude) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FNsinclude& nsinclude) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FNsinclude_Init(amc::FNsinclude& nsinclude);
void                 FNsinclude_Uninit(amc::FNsinclude& nsinclude) __attribute__((nothrow));

// --- amc.FNsproto
// create: amc.FDb.nsproto (Lary)
// access: amc.FNs.c_nsproto (Ptr)
struct FNsproto { // amc.FNsproto
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
private:
    friend amc::FNsproto&       nsproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsproto*       nsproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsproto_RemoveLast() __attribute__((nothrow));
    FNsproto();
    ~FNsproto();
    FNsproto(const FNsproto&){ /*disallow copy constructor */}
    void operator =(const FNsproto&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 nsproto_CopyOut(amc::FNsproto &row, dmmeta::Nsproto &out) __attribute__((nothrow));
// Copy fields in to row
void                 nsproto_CopyIn(amc::FNsproto &row, dmmeta::Nsproto &in) __attribute__((nothrow));

void                 FNsproto_Uninit(amc::FNsproto& nsproto) __attribute__((nothrow));

// --- amc.FNsx
// create: amc.FDb.nsx (Lary)
// access: amc.FNs.c_nsx (Ptr)
struct FNsx { // amc.FNsx
    algo::Smallstr16    ns;                    //
    bool                genthrow;              //   false
    bool                correct_getorcreate;   //   false
    algo::Smallstr100   pool;                  //
    bool                sortxref;              //   false
    bool                pack;                  //   false
    bool                fldoffset_asserts;     //   false
    algo::Comment       comment;               //
    amc::FField*        p_pool;                // reference to parent row
private:
    friend amc::FNsx&           nsx_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsx*           nsx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsx_RemoveLast() __attribute__((nothrow));
    FNsx();
    ~FNsx();
    FNsx(const FNsx&){ /*disallow copy constructor */}
    void operator =(const FNsx&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 nsx_CopyOut(amc::FNsx &row, dmmeta::Nsx &out) __attribute__((nothrow));
// Copy fields in to row
void                 nsx_CopyIn(amc::FNsx &row, dmmeta::Nsx &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNsx_Init(amc::FNsx& nsx);
void                 FNsx_Uninit(amc::FNsx& nsx) __attribute__((nothrow));

// --- amc.FNumstr
// create: amc.FDb.numstr (Lary)
// access: amc.FSmallstr.c_numstr (Ptr)
struct FNumstr { // amc.FNumstr
    algo::Smallstr100   field;       // String type
    algo::Smallstr50    numtype;     // Corresponding numeric type
    i32                 base;        //   0  Base for conversion
    i32                 min_len;     //   0  Mininum length of string
    amc::FCtype*        p_numtype;   // reference to parent row
    u64                 nummin;      //   0
    u64                 nummax;      //   0
    bool                issigned;    //   false
private:
    friend amc::FNumstr&        numstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNumstr*        numstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 numstr_RemoveLast() __attribute__((nothrow));
    FNumstr();
    ~FNumstr();
    FNumstr(const FNumstr&){ /*disallow copy constructor */}
    void operator =(const FNumstr&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 numstr_CopyIn(amc::FNumstr &row, dmmeta::Numstr &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FNumstr_Init(amc::FNumstr& numstr);
void                 FNumstr_Uninit(amc::FNumstr& numstr) __attribute__((nothrow));

// --- amc.FOutfile
// create: amc.FDb.outfile (Tpool)
// access: amc.FNs.c_outfile (Ptrary)
struct FOutfile { // amc.FOutfile: AMC's output file (generated file under include/gen or cpp/gen)
    amc::FOutfile*      outfile_next;          // Pointer to next free element int tpool
    algo::cstring       text;                  //
    amc::FNs*           p_ns;                  // reference to parent row
    algo::cstring       ssim;                  // Ssim content
    algo::cstring       prev_head;             // Helper
    algo::Smallstr200   outfile;               //
    bool                ns_c_outfile_in_ary;   //   false  membership flag
private:
    friend amc::FOutfile&       outfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FOutfile*       outfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 outfile_Delete(amc::FOutfile &row) __attribute__((nothrow));
    FOutfile();
    ~FOutfile();
    FOutfile(const FOutfile&){ /*disallow copy constructor */}
    void operator =(const FOutfile&){ /*disallow direct assignment */}
};

algo::Smallstr16     ns_Get(amc::FOutfile& outfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FOutfile_Init(amc::FOutfile& outfile);
void                 FOutfile_Uninit(amc::FOutfile& outfile) __attribute__((nothrow));

// --- amc.FPack
// create: amc.FDb.pack (Lary)
// global access: ind_pack (Thash)
// access: amc.FCtype.c_pack (Ptr)
struct FPack { // amc.FPack
    amc::FPack*        ind_pack_next;   // hash next
    algo::Smallstr50   ctype;           // Target ctype
    amc::FCtype*       p_ctype;         // reference to parent row
private:
    friend amc::FPack&          pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPack*          pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pack_RemoveLast() __attribute__((nothrow));
    FPack();
    ~FPack();
    FPack(const FPack&){ /*disallow copy constructor */}
    void operator =(const FPack&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 pack_CopyIn(amc::FPack &row, dmmeta::Pack &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FPack_Init(amc::FPack& pack);
void                 FPack_Uninit(amc::FPack& pack) __attribute__((nothrow));

// --- amc.FPmaskfld
// create: amc.FDb.pmaskfld (Lary)
// access: amc.FCtype.c_pmaskfld (Ptr)
// access: amc.FField.c_pmaskfld (Ptr)
struct FPmaskfld { // amc.FPmaskfld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
    u32                 nextbit;   //   0  Next bit to allocate
private:
    friend amc::FPmaskfld&      pmaskfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPmaskfld*      pmaskfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pmaskfld_RemoveLast() __attribute__((nothrow));
    FPmaskfld();
    ~FPmaskfld();
    FPmaskfld(const FPmaskfld&){ /*disallow copy constructor */}
    void operator =(const FPmaskfld&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 pmaskfld_CopyOut(amc::FPmaskfld &row, dmmeta::Pmaskfld &out) __attribute__((nothrow));
// Copy fields in to row
void                 pmaskfld_CopyIn(amc::FPmaskfld &row, dmmeta::Pmaskfld &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FPmaskfld& pmaskfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FPmaskfld_Init(amc::FPmaskfld& pmaskfld);
void                 FPmaskfld_Uninit(amc::FPmaskfld& pmaskfld) __attribute__((nothrow));

// --- amc.FPnew
// create: amc.FDb.pnew (Lary)
// global access: ind_pnew (Thash)
// access: amc.FNs.c_pnew (Ptrary)
struct FPnew { // amc.FPnew
    amc::FPnew*         ind_pnew_next;      // hash next
    algo::Smallstr100   pnew;               //
    amc::FCtype*        p_ctype;            // reference to parent row
    amc::FNs*           p_ns;               // reference to parent row
    bool                ns_c_pnew_in_ary;   //   false  membership flag
private:
    friend amc::FPnew&          pnew_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPnew*          pnew_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pnew_RemoveLast() __attribute__((nothrow));
    FPnew();
    ~FPnew();
    FPnew(const FPnew&){ /*disallow copy constructor */}
    void operator =(const FPnew&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 pnew_CopyIn(amc::FPnew &row, dmmeta::Pnew &in) __attribute__((nothrow));

algo::Smallstr16     ns_Get(amc::FPnew& pnew) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     ctype_Get(amc::FPnew& pnew) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     buftype_Get(amc::FPnew& pnew) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FPnew_Init(amc::FPnew& pnew);
void                 FPnew_Uninit(amc::FPnew& pnew) __attribute__((nothrow));

// --- amc.FPtrary
// create: amc.FDb.ptrary (Lary)
// access: amc.FField.c_ptrary (Ptr)
struct FPtrary { // amc.FPtrary
    algo::Smallstr100   field;     //
    bool                unique;    //   false  Search for and ignore duplicates
    amc::FField*        p_field;   // reference to parent row
private:
    friend amc::FPtrary&        ptrary_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPtrary*        ptrary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ptrary_RemoveLast() __attribute__((nothrow));
    FPtrary();
    ~FPtrary();
    FPtrary(const FPtrary&){ /*disallow copy constructor */}
    void operator =(const FPtrary&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 ptrary_CopyIn(amc::FPtrary &row, dmmeta::Ptrary &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FPtrary_Init(amc::FPtrary& ptrary);
void                 FPtrary_Uninit(amc::FPtrary& ptrary) __attribute__((nothrow));

// --- amc.FReftype
// create: amc.FDb.reftype (Lary)
// global access: ind_reftype (Thash)
// access: amc.FField.p_reftype (Upptr)
struct FReftype { // amc.FReftype
    amc::FReftype*      ind_reftype_next;   // hash next
    algo::Smallstr50    reftype;            //   "Val"
    bool                isval;              //   false  True if field makes values of target type
    bool                cascins;            //   false  Field is cascade-insert
    bool                usebasepool;        //   false
    bool                cancopy;            //   false
    bool                isxref;             //   false
    bool                del;                //   false  Supports random deletion?
    bool                up;                 //   false
    bool                isnew;              //   false
    bool                hasalloc;           //   false
    bool                inst;               //   false
    bool                varlen;             //   false
    dmmeta::ReftypeId   rowid;              //
    amc::FTclass*       p_tclass;           // reference to parent row
    amc::FFprefix*      zs_fprefix_head;    // zero-terminated singly linked list
    amc::FFprefix*      zs_fprefix_tail;    // pointer to last element
private:
    friend amc::FReftype&       reftype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FReftype*       reftype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 reftype_RemoveAll() __attribute__((nothrow));
    friend void                 reftype_RemoveLast() __attribute__((nothrow));
    FReftype();
    ~FReftype();
    FReftype(const FReftype&){ /*disallow copy constructor */}
    void operator =(const FReftype&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 reftype_CopyIn(amc::FReftype &row, dmmeta::Reftype &in) __attribute__((nothrow));

// Return true if index is empty
bool                 zs_fprefix_EmptyQ(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
amc::FFprefix*       zs_fprefix_First(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
bool                 zs_fprefix_InLlistQ(amc::FFprefix& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
void                 zs_fprefix_Insert(amc::FReftype& reftype, amc::FFprefix& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
amc::FFprefix*       zs_fprefix_Last(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
amc::FFprefix*       zs_fprefix_Next(amc::FFprefix &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
void                 zs_fprefix_Remove(amc::FReftype& reftype, amc::FFprefix& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 zs_fprefix_RemoveAll(amc::FReftype& reftype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
amc::FFprefix*       zs_fprefix_RemoveFirst(amc::FReftype& reftype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
amc::FFprefix&       zs_fprefix_qLast(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FReftype_Init(amc::FReftype& reftype);
// cursor points to valid item
void                 reftype_zs_fprefix_curs_Reset(reftype_zs_fprefix_curs &curs, amc::FReftype &parent);
// cursor points to valid item
bool                 reftype_zs_fprefix_curs_ValidQ(reftype_zs_fprefix_curs &curs);
// proceed to next item
void                 reftype_zs_fprefix_curs_Next(reftype_zs_fprefix_curs &curs);
// item access
amc::FFprefix&       reftype_zs_fprefix_curs_Access(reftype_zs_fprefix_curs &curs);
void                 FReftype_Uninit(amc::FReftype& reftype) __attribute__((nothrow));

// --- amc.FRowid
// create: amc.FDb.rowid (Lary)
// global access: ind_rowid (Thash)
// access: amc.FField.c_rowid (Ptr)
struct FRowid { // amc.FRowid
    amc::FRowid*        ind_rowid_next;   // hash next
    algo::Smallstr100   field;            //
    algo::Comment       comment;          //
private:
    friend amc::FRowid&         rowid_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FRowid*         rowid_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 rowid_RemoveLast() __attribute__((nothrow));
    FRowid();
    ~FRowid();
    FRowid(const FRowid&){ /*disallow copy constructor */}
    void operator =(const FRowid&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 rowid_CopyOut(amc::FRowid &row, dmmeta::Rowid &out) __attribute__((nothrow));
// Copy fields in to row
void                 rowid_CopyIn(amc::FRowid &row, dmmeta::Rowid &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FRowid_Init(amc::FRowid& rowid);
void                 FRowid_Uninit(amc::FRowid& rowid) __attribute__((nothrow));

// --- amc.FSmallstr
// create: amc.FDb.smallstr (Lary)
// global access: ind_smallstr (Thash)
// access: amc.FField.c_smallstr (Ptr)
struct FSmallstr { // amc.FSmallstr
    amc::FSmallstr*     ind_smallstr_next;   // hash next
    algo::Smallstr100   field;               //
    i32                 length;              //   0  Maximum characters in the string
    algo::Smallstr50    strtype;             // Data format for string
    dmmeta::CppExpr     pad;                 // Pad character (if applicable)
    bool                strict;              //   false
    amc::FField*        p_field;             // reference to parent row
    amc::FNumstr*       c_numstr;            // optional pointer
private:
    friend amc::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 smallstr_RemoveLast() __attribute__((nothrow));
    FSmallstr();
    ~FSmallstr();
    FSmallstr(const FSmallstr&){ /*disallow copy constructor */}
    void operator =(const FSmallstr&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 smallstr_CopyIn(amc::FSmallstr &row, dmmeta::Smallstr &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FSmallstr& smallstr) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_numstr_InsertMaybe(amc::FSmallstr& smallstr, amc::FNumstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_numstr_Remove(amc::FSmallstr& smallstr, amc::FNumstr& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSmallstr_Init(amc::FSmallstr& smallstr);
void                 FSmallstr_Uninit(amc::FSmallstr& smallstr) __attribute__((nothrow));

// --- amc.FSortfld
// create: amc.FDb.sortfld (Lary)
// access: amc.FField.c_sortfld (Ptr)
struct FSortfld { // amc.FSortfld
    algo::Smallstr100   field;       //
    algo::Smallstr100   sortfld;     // Field to sort by
    amc::FField*        p_sortfld;   // reference to parent row
private:
    friend amc::FSortfld&       sortfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSortfld*       sortfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 sortfld_RemoveLast() __attribute__((nothrow));
    FSortfld();
    ~FSortfld();
    FSortfld(const FSortfld&){ /*disallow copy constructor */}
    void operator =(const FSortfld&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 sortfld_CopyIn(amc::FSortfld &row, dmmeta::Sortfld &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSortfld_Init(amc::FSortfld& sortfld);
void                 FSortfld_Uninit(amc::FSortfld& sortfld) __attribute__((nothrow));

// --- amc.FSsimfile
// create: amc.FDb.ssimfile (Lary)
// global access: ind_ssimfile (Thash)
// access: amc.FCtype.c_ssimfile (Ptr)
struct FSsimfile { // amc.FSsimfile
    amc::FSsimfile*       ind_ssimfile_next;   // hash next
    algo::Smallstr50      ssimfile;            //
    algo::Smallstr50      ctype;               //
    algo::cstring         ssim;                // Ssim content
    amc::FCtype*          p_ctype;             // reference to parent row
    amc::FSsimvolatile*   c_ssimvolatile;      // optional pointer
private:
    friend amc::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
    FSsimfile();
    ~FSsimfile();
    FSsimfile(const FSsimfile&){ /*disallow copy constructor */}
    void operator =(const FSsimfile&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 ssimfile_CopyIn(amc::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

algo::Smallstr16     ssimns_Get(amc::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(amc::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_ssimvolatile_InsertMaybe(amc::FSsimfile& ssimfile, amc::FSsimvolatile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_ssimvolatile_Remove(amc::FSsimfile& ssimfile, amc::FSsimvolatile& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSsimfile_Init(amc::FSsimfile& ssimfile);
void                 FSsimfile_Uninit(amc::FSsimfile& ssimfile) __attribute__((nothrow));

// --- amc.FSsimvolatile
// create: amc.FDb.ssimvolatile (Lary)
// access: amc.FSsimfile.c_ssimvolatile (Ptr)
struct FSsimvolatile { // amc.FSsimvolatile
    algo::Smallstr50   ssimfile;   //
    algo::Comment      comment;    //
private:
    friend amc::FSsimvolatile&  ssimvolatile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSsimvolatile*  ssimvolatile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimvolatile_RemoveAll() __attribute__((nothrow));
    friend void                 ssimvolatile_RemoveLast() __attribute__((nothrow));
    FSsimvolatile();
    ~FSsimvolatile();
    FSsimvolatile(const FSsimvolatile&){ /*disallow copy constructor */}
    void operator =(const FSsimvolatile&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 ssimvolatile_CopyOut(amc::FSsimvolatile &row, dmmeta::Ssimvolatile &out) __attribute__((nothrow));
// Copy fields in to row
void                 ssimvolatile_CopyIn(amc::FSsimvolatile &row, dmmeta::Ssimvolatile &in) __attribute__((nothrow));

void                 FSsimvolatile_Uninit(amc::FSsimvolatile& ssimvolatile) __attribute__((nothrow));

// --- amc.FStatictuple
// create: amc.FDb.static_tuple (Lary)
// access: amc.FCtype.c_static (Ptrary)
struct FStatictuple { // amc.FStatictuple
    algo::Smallstr50   ctype;                   //
    algo::Tuple        tuple;                   //
    algo::cstring      cppident;                //
    bool               ctype_c_static_in_ary;   //   false  membership flag
private:
    friend amc::FStatictuple&   static_tuple_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FStatictuple*   static_tuple_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 static_tuple_RemoveAll() __attribute__((nothrow));
    friend void                 static_tuple_RemoveLast() __attribute__((nothrow));
    FStatictuple();
    ~FStatictuple();
    FStatictuple(const FStatictuple&){ /*disallow copy constructor */}
    void operator =(const FStatictuple&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 FStatictuple_Init(amc::FStatictuple& static_tuple);
void                 FStatictuple_Uninit(amc::FStatictuple& static_tuple) __attribute__((nothrow));

// --- amc.FSubstr
// create: amc.FDb.substr (Lary)
// global access: zd_substr_params (Llist)
// global access: c_substr_field (Ptrary)
// access: amc.FField.c_substr (Ptr)
struct FSubstr { // amc.FSubstr
    amc::FSubstr*       zd_substr_params_next;       // zslist link; -1 means not-in-list
    amc::FSubstr*       zd_substr_params_prev;       // previous element
    algo::Smallstr100   field;                       //
    dmmeta::CppExpr     expr;                        //
    algo::Smallstr100   srcfield;                    //
    amc::FField*        p_field;                     // reference to parent row
    amc::FField*        p_srcfield;                  // reference to parent row
    u64                 range;                       //   0
    bool                _db_c_substr_field_in_ary;   //   false  membership flag
private:
    friend amc::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 substr_RemoveLast() __attribute__((nothrow));
    FSubstr();
    ~FSubstr();
    FSubstr(const FSubstr&){ /*disallow copy constructor */}
    void operator =(const FSubstr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 substr_CopyOut(amc::FSubstr &row, dmmeta::Substr &out) __attribute__((nothrow));
// Copy fields in to row
void                 substr_CopyIn(amc::FSubstr &row, dmmeta::Substr &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FSubstr_Init(amc::FSubstr& substr);
void                 FSubstr_Uninit(amc::FSubstr& substr) __attribute__((nothrow));

// --- amc.FTargdep
// create: amc.FDb.targdep (Lary)
// access: amc.FTarget.c_targdep (Ptrary)
struct FTargdep { // amc.FTargdep
    algo::Smallstr50   targdep;                   //
    amc::FTarget*      p_target;                  // reference to parent row
    amc::FTarget*      p_parent;                  // reference to parent row
    bool               target_c_targdep_in_ary;   //   false  membership flag
private:
    friend amc::FTargdep&       targdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTargdep*       targdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targdep_RemoveLast() __attribute__((nothrow));
    FTargdep();
    ~FTargdep();
    FTargdep(const FTargdep&){ /*disallow copy constructor */}
    void operator =(const FTargdep&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 targdep_CopyIn(amc::FTargdep &row, dev::Targdep &in) __attribute__((nothrow));

algo::Smallstr16     target_Get(amc::FTargdep& targdep) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     parent_Get(amc::FTargdep& targdep) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FTargdep_Init(amc::FTargdep& targdep);
void                 FTargdep_Uninit(amc::FTargdep& targdep) __attribute__((nothrow));

// --- amc.FTarget
// create: amc.FDb.target (Lary)
// global access: ind_target (Thash)
// access: amc.FNs.c_target (Ptr)
// access: amc.FTargdep.p_target (Upptr)
// access: amc.FTargdep.p_parent (Upptr)
struct FTarget { // amc.FTarget
    amc::FTarget*      ind_target_next;   // hash next
    algo::Smallstr16   target;            //
    amc::FTargdep**    c_targdep_elems;   // array of pointers
    u32                c_targdep_n;       // array of pointers
    u32                c_targdep_max;     // capacity of allocated array
    amc::FNs*          p_ns;              // reference to parent row
private:
    friend amc::FTarget&        target_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTarget*        target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 target_RemoveLast() __attribute__((nothrow));
    FTarget();
    ~FTarget();
    FTarget(const FTarget&){ /*disallow copy constructor */}
    void operator =(const FTarget&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 target_CopyIn(amc::FTarget &row, dev::Target &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_targdep_EmptyQ(amc::FTarget& target) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
amc::FTargdep*       c_targdep_Find(amc::FTarget& target, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<amc::FTargdep*> c_targdep_Getary(amc::FTarget& target) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_targdep_Insert(amc::FTarget& target, amc::FTargdep& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_targdep_InsertMaybe(amc::FTarget& target, amc::FTargdep& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_targdep_N(const amc::FTarget& target) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_targdep_Remove(amc::FTarget& target, amc::FTargdep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_targdep_RemoveAll(amc::FTarget& target) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_targdep_Reserve(amc::FTarget& target, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTarget_Init(amc::FTarget& target);
void                 target_c_targdep_curs_Reset(target_c_targdep_curs &curs, amc::FTarget &parent);
// cursor points to valid item
bool                 target_c_targdep_curs_ValidQ(target_c_targdep_curs &curs);
// proceed to next item
void                 target_c_targdep_curs_Next(target_c_targdep_curs &curs);
// item access
amc::FTargdep&       target_c_targdep_curs_Access(target_c_targdep_curs &curs);
void                 FTarget_Uninit(amc::FTarget& target) __attribute__((nothrow));

// --- amc.FTary
// create: amc.FDb.tary (Lary)
// global access: ind_tary (Thash)
// access: amc.FField.c_tary (Ptr)
struct FTary { // amc.FTary
    amc::FTary*         ind_tary_next;   // hash next
    algo::Smallstr100   field;           //
    bool                aliased;         //   false  Geneate functions to copy from aryptr
    amc::FField*        p_field;         // reference to parent row
private:
    friend amc::FTary&          tary_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTary*          tary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tary_RemoveLast() __attribute__((nothrow));
    FTary();
    ~FTary();
    FTary(const FTary&){ /*disallow copy constructor */}
    void operator =(const FTary&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 tary_CopyIn(amc::FTary &row, dmmeta::Tary &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTary_Init(amc::FTary& tary);
void                 FTary_Uninit(amc::FTary& tary) __attribute__((nothrow));

// --- amc.FTcursor
// create: amc.FDb.tcursor (Lary)
// access: amc.FTfunc.c_tcursor (Ptr)
struct FTcursor { // amc.FTcursor
    algo::Smallstr50   tfunc;     //
    algo::Comment      comment;   //
private:
    friend amc::FTcursor&       tcursor_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTcursor*       tcursor_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tcursor_RemoveLast() __attribute__((nothrow));
    FTcursor();
    ~FTcursor();
    FTcursor(const FTcursor&){ /*disallow copy constructor */}
    void operator =(const FTcursor&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 tcursor_CopyOut(amc::FTcursor &row, amcdb::Tcursor &out) __attribute__((nothrow));
// Copy fields in to row
void                 tcursor_CopyIn(amc::FTcursor &row, amcdb::Tcursor &in) __attribute__((nothrow));

void                 FTcursor_Uninit(amc::FTcursor& tcursor) __attribute__((nothrow));

// --- amc.FTfunc
// create: amc.FDb.tfunc (Lary)
// global access: ind_tfunc (Thash)
// access: amc.FTclass.c_tfunc (Ptrary)
// access: amc.Genfield.p_tfunc (Upptr)
struct FTfunc { // amc.FTfunc
    amc::FTfunc*           ind_tfunc_next;          // hash next
    algo::Smallstr50       tfunc;                   //
    bool                   hasthrow;                //   false  Important defaults for new tfuncs to work
    bool                   leaf;                    //   true  Important defaults for new tfuncs to work
    bool                   poolfunc;                //   false
    bool                   inl;                     //   false  Function is typically inline
    bool                   wur;                     //   false  Warn unused result
    bool                   pure;                    //   false  OK to call fewer times than specified in text
    bool                   ismacro;                 //   false
    algo::Comment          comment;                 //
    amc::FTcursor*         c_tcursor;               // optional pointer
    amc::tfunc_step_hook   step;                    //   NULL  Pointer to a function
    bool                   tclass_c_tfunc_in_ary;   //   false  membership flag
private:
    friend amc::FTfunc&         tfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTfunc*         tfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tfunc_RemoveAll() __attribute__((nothrow));
    friend void                 tfunc_RemoveLast() __attribute__((nothrow));
    FTfunc();
    ~FTfunc();
    FTfunc(const FTfunc&){ /*disallow copy constructor */}
    void operator =(const FTfunc&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 tfunc_CopyOut(amc::FTfunc &row, amcdb::Tfunc &out) __attribute__((nothrow));
// Copy fields in to row
void                 tfunc_CopyIn(amc::FTfunc &row, amcdb::Tfunc &in) __attribute__((nothrow));

algo::Smallstr50     tclass_Get(amc::FTfunc& tfunc) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FTfunc& tfunc) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_tcursor_InsertMaybe(amc::FTfunc& tfunc, amc::FTcursor& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_tcursor_Remove(amc::FTfunc& tfunc, amc::FTcursor& row) __attribute__((nothrow));

// Invoke function by pointer
void                 step_Call(amc::FTfunc& tfunc) __attribute__((nothrow));

// Set all fields to initial values.
void                 FTfunc_Init(amc::FTfunc& tfunc);
void                 FTfunc_Uninit(amc::FTfunc& tfunc) __attribute__((nothrow));

// --- amc.FThash
// create: amc.FDb.thash (Lary)
// access: amc.FField.c_thash (Ptr)
struct FThash { // amc.FThash
    algo::Smallstr100   field;       //
    algo::Smallstr100   hashfld;     // Field on which hash function is computed
    bool                unique;      //   true  Enforce uniqueness of member elements
    amc::FField*        p_hashfld;   // reference to parent row
    amc::FField*        p_field;     // reference to parent row
private:
    friend amc::FThash&         thash_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FThash*         thash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 thash_RemoveLast() __attribute__((nothrow));
    FThash();
    ~FThash();
    FThash(const FThash&){ /*disallow copy constructor */}
    void operator =(const FThash&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 thash_CopyIn(amc::FThash &row, dmmeta::Thash &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FThash_Init(amc::FThash& thash);
void                 FThash_Uninit(amc::FThash& thash) __attribute__((nothrow));

// --- amc.FTracefld
// create: amc.FDb.tracefld (Lary)
struct FTracefld { // amc.FTracefld
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
private:
    friend amc::FTracefld&      tracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTracefld*      tracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tracefld_RemoveAll() __attribute__((nothrow));
    friend void                 tracefld_RemoveLast() __attribute__((nothrow));
    FTracefld();
};

// Copy fields out of row
void                 tracefld_CopyOut(amc::FTracefld &row, dmmeta::Tracefld &out) __attribute__((nothrow));
// Copy fields in to row
void                 tracefld_CopyIn(amc::FTracefld &row, dmmeta::Tracefld &in) __attribute__((nothrow));

algo::Smallstr50     tracerec_Get(amc::FTracefld& tracefld) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr50     name_Get(amc::FTracefld& tracefld) __attribute__((__warn_unused_result__, nothrow));


// --- amc.FTracerec
// create: amc.FDb.tracerec (Lary)
struct FTracerec { // amc.FTracerec
    algo::Smallstr50   tracerec;   // e.g. rl_lib.trace
    algo::Comment      comment;    //
private:
    friend amc::FTracerec&      tracerec_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTracerec*      tracerec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tracerec_RemoveAll() __attribute__((nothrow));
    friend void                 tracerec_RemoveLast() __attribute__((nothrow));
    FTracerec();
};

// Copy fields out of row
void                 tracerec_CopyOut(amc::FTracerec &row, dmmeta::Tracerec &out) __attribute__((nothrow));
// Copy fields in to row
void                 tracerec_CopyIn(amc::FTracerec &row, dmmeta::Tracerec &in) __attribute__((nothrow));

algo::Smallstr50     name_Get(amc::FTracerec& tracerec) __attribute__((__warn_unused_result__, nothrow));


// --- amc.FTypefld
// create: amc.FDb.typefld (Lary)
// access: amc.FCtype.c_typefld (Ptr)
// access: amc.FField.c_typefld (Ptr)
struct FTypefld { // amc.FTypefld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
    amc::FCtype*        p_ctype;   // reference to parent row
private:
    friend amc::FTypefld&       typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTypefld*       typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typefld_RemoveLast() __attribute__((nothrow));
    FTypefld();
    ~FTypefld();
    FTypefld(const FTypefld&){ /*disallow copy constructor */}
    void operator =(const FTypefld&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 typefld_CopyOut(amc::FTypefld &row, dmmeta::Typefld &out) __attribute__((nothrow));
// Copy fields in to row
void                 typefld_CopyIn(amc::FTypefld &row, dmmeta::Typefld &in) __attribute__((nothrow));

algo::Smallstr50     ctype_Get(amc::FTypefld& typefld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FTypefld_Init(amc::FTypefld& typefld);
void                 FTypefld_Uninit(amc::FTypefld& typefld) __attribute__((nothrow));

// --- amc.FUsertracefld
// create: amc.FDb.usertracefld (Lary)
struct FUsertracefld { // amc.FUsertracefld
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
private:
    friend amc::FUsertracefld&  usertracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FUsertracefld*  usertracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 usertracefld_RemoveLast() __attribute__((nothrow));
    FUsertracefld();
};

// Copy fields out of row
void                 usertracefld_CopyOut(amc::FUsertracefld &row, dmmeta::Usertracefld &out) __attribute__((nothrow));
// Copy fields in to row
void                 usertracefld_CopyIn(amc::FUsertracefld &row, dmmeta::Usertracefld &in) __attribute__((nothrow));


// --- amc.FXref
// create: amc.FDb.xref (Lary)
// global access: ind_xref (Thash)
// access: amc.FCtype.zs_xref (Llist)
// access: amc.FField.c_xref (Ptr)
// access: amc.FField.zd_xref_keyfld (Llist)
struct FXref { // amc.FXref
    amc::FXref*         zs_xref_next;          // zslist link; -1 means not-in-list
    amc::FXref*         ind_xref_next;         // hash next
    amc::FXref*         zd_xref_keyfld_next;   // zslist link; -1 means not-in-list
    amc::FXref*         zd_xref_keyfld_prev;   // previous element
    algo::Smallstr100   field;                 //
    dmmeta::CppExpr     inscond;               //   "true"  Insert condition
    algo::Smallstr200   via;                   //
    amc::FField*        p_field;               // reference to parent row
    amc::FCtype*        p_ctype;               // reference to parent row
    amc::FNocascdel*    c_nocascdel;           // optional pointer
    amc::FField*        p_viafld;              // reference to parent row
    amc::FField*        p_keyfld;              // reference to parent row
private:
    friend amc::FXref&          xref_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FXref*          xref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 xref_RemoveLast() __attribute__((nothrow));
    FXref();
    ~FXref();
    FXref(const FXref&){ /*disallow copy constructor */}
    void operator =(const FXref&){ /*disallow direct assignment */}
};

// Copy fields in to row
void                 xref_CopyIn(amc::FXref &row, dmmeta::Xref &in) __attribute__((nothrow));

algo::Smallstr50     name_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr16     ns_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr100    viafld_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

algo::Smallstr100    keyfld_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_nocascdel_InsertMaybe(amc::FXref& xref, amc::FNocascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_nocascdel_Remove(amc::FXref& xref, amc::FNocascdel& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FXref_Init(amc::FXref& xref);
void                 FXref_Uninit(amc::FXref& xref) __attribute__((nothrow));

// --- amc.FieldId
#pragma pack(push,1)
struct FieldId { // amc.FieldId: Field read helper
    i32   value;   //   -1
    inline operator amc_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(amc_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
amc_FieldIdEnum      value_GetEnum(const amc::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(amc::FieldId& parent, amc_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const amc::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const amc::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(amc::FieldId& parent, algo::strptr rhs, amc_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::FieldId from an ascii string.
// The format of the string is the format of the amc::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(amc::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(amc::FieldId& parent);
// print string representation of amc::FieldId to string LHS, no header -- cprint:amc.FieldId.String
void                 FieldId_Print(amc::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- amc.Funcarg
// create: amc.FFunc.funcarg (Tary)
struct Funcarg { // amc.Funcarg
    algo::cstring   type;          // C++ expression for declaration
    algo::cstring   name;          // Argument name
    algo::cstring   dflt;          // Initializer
    bool            retval;        //   false  Is return value?
    bool            initialized;   //   false
    bool            indent;        //   false  Formatting option for prototype
    bool            typearg;       //   false
    Funcarg();
};

// Set all fields to initial values.
void                 Funcarg_Init(amc::Funcarg& funcarg);

// --- amc.Genpnew
struct Genpnew { // amc.Genpnew
    amc::FFunc*           p_func;        // reference to parent row
    algo_lib::Replscope   R;             //
    algo::cstring         preamble;      //
    algo::cstring         postamble;     //
    bool                  req_pack;      //   false
    amc::FCtype*          p_ctype;       // reference to parent row
    amc::FField*          p_optfld;      // reference to parent row
    amc::FField*          p_varlenfld;   // reference to parent row
    bool                  optnolen;      //   false
    bool                  hasret;        //   true
    Genpnew();
private:
    // value field amc.Genpnew.R is not copiable
    Genpnew(const Genpnew&){ /*disallow copy constructor */}
    void operator =(const Genpnew&){ /*disallow direct assignment */}
};

// Set all fields to initial values.
void                 Genpnew_Init(amc::Genpnew& parent);

// --- amc.TableId
struct TableId { // amc.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator amc_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(amc_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
amc_TableIdEnum      value_GetEnum(const amc::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(amc::TableId& parent, amc_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const amc::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const amc::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(amc::TableId& parent, algo::strptr rhs, amc_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::TableId from an ascii string.
// The format of the string is the format of the amc::TableId's only field
bool                 TableId_ReadStrptrMaybe(amc::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(amc::TableId& parent);
// print string representation of amc::TableId to string LHS, no header -- cprint:amc.TableId.String
void                 TableId_Print(amc::TableId & row, algo::cstring &str) __attribute__((nothrow));

struct ctype_zs_cfmt_curs {// cursor
    typedef amc::FCfmt ChildType;
    amc::FCfmt* row;
    ctype_zs_cfmt_curs() {
        row = NULL;
    }
};


struct ctype_c_field_curs {// cursor
    typedef amc::FField ChildType;
    amc::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_static_curs {// cursor
    typedef amc::FStatictuple ChildType;
    amc::FStatictuple** elems;
    u32 n_elems;
    u32 index;
    ctype_c_static_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_parent_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    ctype_c_parent_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_datafld_curs {// cursor
    typedef amc::FField ChildType;
    amc::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_datafld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_inst_curs {// cursor
    typedef amc::FField ChildType;
    amc::FField* row;
    ctype_zd_inst_curs() {
        row = NULL;
    }
};


struct ctype_zs_xref_curs {// cursor
    typedef amc::FXref ChildType;
    amc::FXref* row;
    ctype_zs_xref_curs() {
        row = NULL;
    }
};


struct ctype_c_ffunc_curs {// cursor
    typedef amc::FFunc ChildType;
    amc::FFunc** elems;
    u32 n_elems;
    u32 index;
    ctype_c_ffunc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_cafter_curs {// cursor
    typedef amc::FCafter ChildType;
    amc::FCafter* row;
    ctype_zd_cafter_curs() {
        row = NULL;
    }
};


struct ctype_zd_access_curs {// cursor
    typedef amc::FField ChildType;
    amc::FField* row;
    ctype_zd_access_curs() {
        row = NULL;
    }
};


struct ctype_c_fcurs_curs {// cursor
    typedef amc::FFcurs ChildType;
    amc::FFcurs** elems;
    u32 n_elems;
    u32 index;
    ctype_c_fcurs_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_cdecl_curs {// cursor
    typedef amc::FCdecl ChildType;
    amc::FCdecl** elems;
    u32 n_elems;
    u32 index;
    ctype_c_cdecl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct tclass_c_tfunc_curs {// cursor
    typedef amc::FTfunc ChildType;
    amc::FTfunc** elems;
    u32 n_elems;
    u32 index;
    tclass_c_tfunc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_fsort_curs {// cursor
    typedef amc::FFsort ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fsort_curs(){ parent=NULL; index=0; }
};


struct _db_dispfilter_curs {// cursor
    typedef amc::FDispfilter ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispfilter_curs(){ parent=NULL; index=0; }
};


struct _db_usertracefld_curs {// cursor
    typedef amc::FUsertracefld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_usertracefld_curs(){ parent=NULL; index=0; }
};


struct _db_cfmt_curs {// cursor
    typedef amc::FCfmt ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cfmt_curs(){ parent=NULL; index=0; }
};


struct _db_dispatch_curs {// cursor
    typedef amc::FDispatch ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispatch_curs(){ parent=NULL; index=0; }
};


struct _db_dispatch_msg_curs {// cursor
    typedef amc::FDispatchmsg ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispatch_msg_curs(){ parent=NULL; index=0; }
};


struct _db_ctype_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef amc::FField ChildType;
    amc::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_basepool_curs {// cursor
    typedef amc::FBasepool ChildType;
    amc::FDb *parent;
    i64 index;
    _db_basepool_curs(){ parent=NULL; index=0; }
};


struct _db_llist_curs {// cursor
    typedef amc::FLlist ChildType;
    amc::FDb *parent;
    i64 index;
    _db_llist_curs(){ parent=NULL; index=0; }
};


struct _db_anonfld_curs {// cursor
    typedef amc::FAnonfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_anonfld_curs(){ parent=NULL; index=0; }
};


struct _db_xref_curs {// cursor
    typedef amc::FXref ChildType;
    amc::FDb *parent;
    i64 index;
    _db_xref_curs(){ parent=NULL; index=0; }
};


struct _db_ns_curs {// cursor
    typedef amc::FNs ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_pnew_curs {// cursor
    typedef amc::FPnew ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pnew_curs(){ parent=NULL; index=0; }
};


struct _db_fldoffset_curs {// cursor
    typedef amc::FFldoffset ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fldoffset_curs(){ parent=NULL; index=0; }
};


struct _db_typefld_curs {// cursor
    typedef amc::FTypefld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_typefld_curs(){ parent=NULL; index=0; }
};


struct _db_lenfld_curs {// cursor
    typedef amc::FLenfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_lenfld_curs(){ parent=NULL; index=0; }
};


struct _db_bltin_curs {// cursor
    typedef amc::FBltin ChildType;
    amc::FDb *parent;
    i64 index;
    _db_bltin_curs(){ parent=NULL; index=0; }
};


struct _db_static_tuple_curs {// cursor
    typedef amc::FStatictuple ChildType;
    amc::FDb *parent;
    i64 index;
    _db_static_tuple_curs(){ parent=NULL; index=0; }
};


struct _db_msgtype_curs {// cursor
    typedef amc::FMsgtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_msgtype_curs(){ parent=NULL; index=0; }
};


struct _db_gconst_curs {// cursor
    typedef amc::FGconst ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gconst_curs(){ parent=NULL; index=0; }
};


struct _db_gstatic_curs {// cursor
    typedef amc::FGstatic ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gstatic_curs(){ parent=NULL; index=0; }
};


struct _db_thash_curs {// cursor
    typedef amc::FThash ChildType;
    amc::FDb *parent;
    i64 index;
    _db_thash_curs(){ parent=NULL; index=0; }
};


struct _db_func_curs {// cursor
    typedef amc::FFunc ChildType;
    amc::FDb *parent;
    i64 index;
    _db_func_curs(){ parent=NULL; index=0; }
};


struct _db_smallstr_curs {// cursor
    typedef amc::FSmallstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_smallstr_curs(){ parent=NULL; index=0; }
};


struct _db_numstr_curs {// cursor
    typedef amc::FNumstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_numstr_curs(){ parent=NULL; index=0; }
};


struct _db_main_curs {// cursor
    typedef amc::FMain ChildType;
    amc::FDb *parent;
    i64 index;
    _db_main_curs(){ parent=NULL; index=0; }
};


struct _db_reftype_curs {// cursor
    typedef amc::FReftype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_reftype_curs(){ parent=NULL; index=0; }
};


struct _db_cpptype_curs {// cursor
    typedef amc::FCpptype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cpptype_curs(){ parent=NULL; index=0; }
};


struct _db_inlary_curs {// cursor
    typedef amc::FInlary ChildType;
    amc::FDb *parent;
    i64 index;
    _db_inlary_curs(){ parent=NULL; index=0; }
};


struct _db_tary_curs {// cursor
    typedef amc::FTary ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tary_curs(){ parent=NULL; index=0; }
};


struct _db_cppfunc_curs {// cursor
    typedef amc::FCppfunc ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cppfunc_curs(){ parent=NULL; index=0; }
};


struct _db_rowid_curs {// cursor
    typedef amc::FRowid ChildType;
    amc::FDb *parent;
    i64 index;
    _db_rowid_curs(){ parent=NULL; index=0; }
};


struct _db_cascdel_curs {// cursor
    typedef amc::FCascdel ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cascdel_curs(){ parent=NULL; index=0; }
};


struct _db_substr_curs {// cursor
    typedef amc::FSubstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_substr_curs(){ parent=NULL; index=0; }
};


struct _db_bitfld_curs {// cursor
    typedef amc::FBitfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_bitfld_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef amc::FSsimfile ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_pack_curs {// cursor
    typedef amc::FPack ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pack_curs(){ parent=NULL; index=0; }
};


struct _db_ptrary_curs {// cursor
    typedef amc::FPtrary ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ptrary_curs(){ parent=NULL; index=0; }
};


struct _db_c_ctype_sorted_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    _db_c_ctype_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_enumstr_curs {// cursor
    typedef amc::FEnumstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_enumstr_curs(){ parent=NULL; index=0; }
};


struct _db_enumstr_len_curs {// cursor
    typedef amc::FEnumstrLen ChildType;
    amc::FDb *parent;
    i64 index;
    _db_enumstr_len_curs(){ parent=NULL; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_enumstr_len_curs {
    typedef amc::FEnumstrLen ChildType;
    amc::FDb      *parent;        // parent
    amc::FEnumstrLen*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_enumstr_len_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_enumstr_len_curs();
};


struct _db_fbitset_curs {// cursor
    typedef amc::FFbitset ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbitset_curs(){ parent=NULL; index=0; }
};


struct _db_fcleanup_curs {// cursor
    typedef amc::FFcleanup ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcleanup_curs(){ parent=NULL; index=0; }
};


struct _db_fdec_curs {// cursor
    typedef amc::FFdec ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fdec_curs(){ parent=NULL; index=0; }
};


struct _db_fconst_curs {// cursor
    typedef amc::FFconst ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fconst_curs(){ parent=NULL; index=0; }
};


struct _db_c_ns_sorted_curs {// cursor
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    _db_c_ns_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_finput_curs {// cursor
    typedef amc::FFinput ChildType;
    amc::FDb *parent;
    i64 index;
    _db_finput_curs(){ parent=NULL; index=0; }
};


struct _db_foutput_curs {// cursor
    typedef amc::FFoutput ChildType;
    amc::FDb *parent;
    i64 index;
    _db_foutput_curs(){ parent=NULL; index=0; }
};


struct _db_fbuf_curs {// cursor
    typedef amc::FFbuf ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbuf_curs(){ parent=NULL; index=0; }
};


struct _db_chash_curs {// cursor
    typedef amc::FChash ChildType;
    amc::FDb *parent;
    i64 index;
    _db_chash_curs(){ parent=NULL; index=0; }
};


struct _db_ccmp_curs {// cursor
    typedef amc::FCcmp ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ccmp_curs(){ parent=NULL; index=0; }
};


struct _db_fbigend_curs {// cursor
    typedef amc::FFbigend ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbigend_curs(){ parent=NULL; index=0; }
};


struct _db_zsl_ctype_pack_tran_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FCtype* row;
    _db_zsl_ctype_pack_tran_curs() {
        row = NULL;
    }
};


struct _db_cstr_curs {// cursor
    typedef amc::FCstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cstr_curs(){ parent=NULL; index=0; }
};


struct _db_listtype_curs {// cursor
    typedef amc::FListtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_listtype_curs(){ parent=NULL; index=0; }
};


struct _db_fstep_curs {// cursor
    typedef amc::FFstep ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fstep_curs(){ parent=NULL; index=0; }
};


struct _db_cextern_curs {// cursor
    typedef amc::FCextern ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cextern_curs(){ parent=NULL; index=0; }
};


struct _db_fdelay_curs {// cursor
    typedef amc::FFdelay ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fdelay_curs(){ parent=NULL; index=0; }
};


struct _db_disptrace_curs {// cursor
    typedef amc::FDisptrace ChildType;
    amc::FDb *parent;
    i64 index;
    _db_disptrace_curs(){ parent=NULL; index=0; }
};


struct _db_tracefld_curs {// cursor
    typedef amc::FTracefld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tracefld_curs(){ parent=NULL; index=0; }
};


struct _db_tracerec_curs {// cursor
    typedef amc::FTracerec ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tracerec_curs(){ parent=NULL; index=0; }
};


struct _db_dispsig_curs {// cursor
    typedef amc::FDispsig ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispsig_curs(){ parent=NULL; index=0; }
};


struct _db_c_dispsig_sorted_curs {// cursor
    typedef amc::FDispsig ChildType;
    amc::FDispsig** elems;
    u32 n_elems;
    u32 index;
    _db_c_dispsig_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_zs_sig_visit_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FCtype* row;
    _db_zs_sig_visit_curs() {
        row = NULL;
    }
};


struct _db_target_curs {// cursor
    typedef amc::FTarget ChildType;
    amc::FDb *parent;
    i64 index;
    _db_target_curs(){ parent=NULL; index=0; }
};


struct _db_targdep_curs {// cursor
    typedef amc::FTargdep ChildType;
    amc::FDb *parent;
    i64 index;
    _db_targdep_curs(){ parent=NULL; index=0; }
};


struct _db_dispctx_curs {// cursor
    typedef amc::FDispctx ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispctx_curs(){ parent=NULL; index=0; }
};


struct _db_pmaskfld_curs {// cursor
    typedef amc::FPmaskfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pmaskfld_curs(){ parent=NULL; index=0; }
};


struct _db_fwddecl_curs {// cursor
    typedef amc::FFwddecl ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fwddecl_curs(){ parent=NULL; index=0; }
};


struct _db_tfunc_curs {// cursor
    typedef amc::FTfunc ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tfunc_curs(){ parent=NULL; index=0; }
};


struct _db_gen_curs {// cursor
    typedef amc::FGen ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gen_curs(){ parent=NULL; index=0; }
};


struct _db_fregx_curs {// cursor
    typedef amc::FFregx ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fregx_curs(){ parent=NULL; index=0; }
};


struct _db_tclass_curs {// cursor
    typedef amc::FTclass ChildType;
    int index;
    amc::FDb *parent;
    _db_tclass_curs() { parent=NULL; index=0; }
};


struct _db_fcmp_curs {// cursor
    typedef amc::FFcmp ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcmp_curs(){ parent=NULL; index=0; }
};


struct _db_fcast_curs {// cursor
    typedef amc::FFcast ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcast_curs(){ parent=NULL; index=0; }
};


struct _db_noxref_curs {// cursor
    typedef amc::FNoxref ChildType;
    amc::FDb *parent;
    i64 index;
    _db_noxref_curs(){ parent=NULL; index=0; }
};


struct _db_nocascdel_curs {// cursor
    typedef amc::FNocascdel ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nocascdel_curs(){ parent=NULL; index=0; }
};


struct _db_cafter_curs {// cursor
    typedef amc::FCafter ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cafter_curs(){ parent=NULL; index=0; }
};


struct _db_csize_curs {// cursor
    typedef amc::FCsize ChildType;
    amc::FDb *parent;
    i64 index;
    _db_csize_curs(){ parent=NULL; index=0; }
};


struct _db_nsx_curs {// cursor
    typedef amc::FNsx ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsx_curs(){ parent=NULL; index=0; }
};


struct _db_fcompact_curs {// cursor
    typedef amc::FFcompact ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcompact_curs(){ parent=NULL; index=0; }
};


struct _db_findrem_curs {// cursor
    typedef amc::FFindrem ChildType;
    amc::FDb *parent;
    i64 index;
    _db_findrem_curs(){ parent=NULL; index=0; }
};


struct _db_tcursor_curs {// cursor
    typedef amc::FTcursor ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tcursor_curs(){ parent=NULL; index=0; }
};


struct _db_fcurs_curs {// cursor
    typedef amc::FFcurs ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcurs_curs(){ parent=NULL; index=0; }
};


struct _db_cdflt_curs {// cursor
    typedef amc::FCdflt ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cdflt_curs(){ parent=NULL; index=0; }
};


struct _db_argvtype_curs {// cursor
    typedef amc::FArgvtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_argvtype_curs(){ parent=NULL; index=0; }
};


struct _db_fcmdline_curs {// cursor
    typedef amc::FFcmdline ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcmdline_curs(){ parent=NULL; index=0; }
};


struct _db_floadtuples_curs {// cursor
    typedef amc::FFloadtuples ChildType;
    amc::FDb *parent;
    i64 index;
    _db_floadtuples_curs(){ parent=NULL; index=0; }
};


struct _db_fcmap_curs {// cursor
    typedef amc::FFcmap ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcmap_curs(){ parent=NULL; index=0; }
};


struct _db_zs_ordkeyfield_curs {// cursor
    typedef amc::FField ChildType;
    amc::FField* row;
    _db_zs_ordkeyfield_curs() {
        row = NULL;
    }
};


struct _db_nsproto_curs {// cursor
    typedef amc::FNsproto ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsproto_curs(){ parent=NULL; index=0; }
};


struct _db_nsdb_curs {// cursor
    typedef amc::FNsdb ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsdb_curs(){ parent=NULL; index=0; }
};


struct _db_zd_substr_params_curs {// cursor
    typedef amc::FSubstr ChildType;
    amc::FSubstr* row;
    _db_zd_substr_params_curs() {
        row = NULL;
    }
};


struct _db_fprefix_curs {// cursor
    typedef amc::FFprefix ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fprefix_curs(){ parent=NULL; index=0; }
};


struct _db_ftrace_curs {// cursor
    typedef amc::FFtrace ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ftrace_curs(){ parent=NULL; index=0; }
};


struct _db_fnoremove_curs {// cursor
    typedef amc::FFnoremove ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fnoremove_curs(){ parent=NULL; index=0; }
};


struct _db_c_substr_field_curs {// cursor
    typedef amc::FSubstr ChildType;
    amc::FSubstr** elems;
    u32 n_elems;
    u32 index;
    _db_c_substr_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_ctypelen_curs {// cursor
    typedef amc::FCtypelen ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ctypelen_curs(){ parent=NULL; index=0; }
};


struct _db_c_ctypelen_curs {// cursor
    typedef amc::FCtypelen ChildType;
    amc::FCtypelen** elems;
    u32 n_elems;
    u32 index;
    _db_c_ctypelen_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_c_tempfield_curs {// cursor
    typedef amc::FField ChildType;
    amc::FField** elems;
    u32 n_elems;
    u32 index;
    _db_c_tempfield_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_fbase_curs {// cursor
    typedef amc::FFbase ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbase_curs(){ parent=NULL; index=0; }
};


struct _db_nossimfile_curs {// cursor
    typedef amc::FNossimfile ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nossimfile_curs(){ parent=NULL; index=0; }
};


struct _db_gsymbol_curs {// cursor
    typedef amc::FGsymbol ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gsymbol_curs(){ parent=NULL; index=0; }
};


struct _db_sortfld_curs {// cursor
    typedef amc::FSortfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_sortfld_curs(){ parent=NULL; index=0; }
};


struct _db_cget_curs {// cursor
    typedef amc::FCget ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cget_curs(){ parent=NULL; index=0; }
};


struct _db_cd_temp_func_curs {// cursor
    typedef amc::FFunc ChildType;
    amc::FFunc* row;
    amc::FFunc* head;
    _db_cd_temp_func_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cdecl_curs {// cursor
    typedef amc::FCdecl ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cdecl_curs(){ parent=NULL; index=0; }
};


struct _db_zs_gen_perns_curs {// cursor
    typedef amc::FGen ChildType;
    amc::FGen* row;
    _db_zs_gen_perns_curs() {
        row = NULL;
    }
};


struct _db_hook_curs {// cursor
    typedef amc::FHook ChildType;
    amc::FDb *parent;
    i64 index;
    _db_hook_curs(){ parent=NULL; index=0; }
};


struct _db_charset_curs {// cursor
    typedef amc::FCharset ChildType;
    amc::FDb *parent;
    i64 index;
    _db_charset_curs(){ parent=NULL; index=0; }
};


struct _db_nsinclude_curs {// cursor
    typedef amc::FNsinclude ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsinclude_curs(){ parent=NULL; index=0; }
};


struct _db_ssimvolatile_curs {// cursor
    typedef amc::FSsimvolatile ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ssimvolatile_curs(){ parent=NULL; index=0; }
};


struct _db_funique_curs {// cursor
    typedef amc::FFunique ChildType;
    amc::FDb *parent;
    i64 index;
    _db_funique_curs(){ parent=NULL; index=0; }
};


struct dispatch_c_dispatch_msg_curs {// cursor
    typedef amc::FDispatchmsg ChildType;
    amc::FDispatchmsg** elems;
    u32 n_elems;
    u32 index;
    dispatch_c_dispatch_msg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct enumstr_c_fconst_curs {// cursor
    typedef amc::FFconst ChildType;
    amc::FFconst** elems;
    u32 n_elems;
    u32 index;
    enumstr_c_fconst_curs() { elems=NULL; n_elems=0; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct enumstr_len_bh_enumstr_curs {
    typedef amc::FEnumstr ChildType;
    amc::FEnumstrLen      *parent;        // parent
    amc::FEnumstr*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    enumstr_len_bh_enumstr_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~enumstr_len_bh_enumstr_curs();
};


struct field_c_ffunc_curs {// cursor
    typedef amc::FFunc ChildType;
    amc::FFunc** elems;
    u32 n_elems;
    u32 index;
    field_c_ffunc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct field_c_fconst_curs {// cursor
    typedef amc::FFconst ChildType;
    amc::FFconst** elems;
    u32 n_elems;
    u32 index;
    field_c_fconst_curs() { elems=NULL; n_elems=0; index=0; }
};


struct field_zd_xref_keyfld_curs {// cursor
    typedef amc::FXref ChildType;
    amc::FXref* row;
    field_zd_xref_keyfld_curs() {
        row = NULL;
    }
};


struct field_zs_fcmap_curs {// cursor
    typedef amc::FFcmap ChildType;
    amc::FFcmap* row;
    field_zs_fcmap_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct field_bh_bitfld_curs {
    typedef amc::FBitfld ChildType;
    amc::FField      *parent;        // parent
    amc::FBitfld*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    field_bh_bitfld_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~field_bh_bitfld_curs();
};


struct func_funcarg_curs {// cursor
    typedef amc::Funcarg ChildType;
    amc::Funcarg* elems;
    int n_elems;
    int index;
    func_funcarg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FGenXref_seen_curs {// cursor
    typedef amc::FGenXrefSeen ChildType;
    amc::FGenXref *parent;
    i64 index;
    FGenXref_seen_curs(){ parent=NULL; index=0; }
};


struct ns_c_ctype_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    ns_c_ctype_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_func_curs {// cursor
    typedef amc::FFunc ChildType;
    amc::FFunc** elems;
    u32 n_elems;
    u32 index;
    ns_c_func_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_dispatch_curs {// cursor
    typedef amc::FDispatch ChildType;
    amc::FDispatch** elems;
    u32 n_elems;
    u32 index;
    ns_c_dispatch_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_gstatic_curs {// cursor
    typedef amc::FGstatic ChildType;
    amc::FGstatic** elems;
    u32 n_elems;
    u32 index;
    ns_c_gstatic_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_include_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    ns_include_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_ctype_ins_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    ns_c_ctype_ins_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_dispsig_curs {// cursor
    typedef amc::FDispsig ChildType;
    amc::FDispsig** elems;
    u32 n_elems;
    u32 index;
    ns_c_dispsig_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_parentns_curs {// cursor
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    ns_c_parentns_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_cppincl_curs {// cursor
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    ns_c_cppincl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_hdrincl_curs {// cursor
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    ns_c_hdrincl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_fwddecl_curs {// cursor
    typedef amc::FFwddecl ChildType;
    amc::FFwddecl** elems;
    u32 n_elems;
    u32 index;
    ns_c_fwddecl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_pnew_curs {// cursor
    typedef amc::FPnew ChildType;
    amc::FPnew** elems;
    u32 n_elems;
    u32 index;
    ns_c_pnew_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_outfile_curs {// cursor
    typedef amc::FOutfile ChildType;
    amc::FOutfile** elems;
    u32 n_elems;
    u32 index;
    ns_c_outfile_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_finput_curs {// cursor
    typedef amc::FFinput ChildType;
    amc::FFinput** elems;
    u32 n_elems;
    u32 index;
    ns_c_finput_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_foutput_curs {// cursor
    typedef amc::FFoutput ChildType;
    amc::FFoutput** elems;
    u32 n_elems;
    u32 index;
    ns_c_foutput_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_fstep_curs {// cursor
    typedef amc::FFstep ChildType;
    amc::FFstep** elems;
    u32 n_elems;
    u32 index;
    ns_c_fstep_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_gsymbol_curs {// cursor
    typedef amc::FGsymbol ChildType;
    amc::FGsymbol** elems;
    u32 n_elems;
    u32 index;
    ns_c_gsymbol_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_nsinclude_curs {// cursor
    typedef amc::FNsinclude ChildType;
    amc::FNsinclude** elems;
    u32 n_elems;
    u32 index;
    ns_c_nsinclude_curs() { elems=NULL; n_elems=0; index=0; }
};


struct reftype_zs_fprefix_curs {// cursor
    typedef amc::FFprefix ChildType;
    amc::FFprefix* row;
    reftype_zs_fprefix_curs() {
        row = NULL;
    }
};


struct target_c_targdep_curs {// cursor
    typedef amc::FTargdep ChildType;
    amc::FTargdep** elems;
    u32 n_elems;
    u32 index;
    target_c_targdep_curs() { elems=NULL; n_elems=0; index=0; }
};

// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Atree();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Base();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Bheap();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Bitfld();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Bitset();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Blkpool();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Charset();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Cmp();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Count();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Cppfunc();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Cppstack();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Ctype();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Dec();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Delptr();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Exec();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Fbuf();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Fcast();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Fconst();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Field();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Field2();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Global();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Hook();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Inlary();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Io();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Lary();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Llist();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Lpool();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Malloc();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Numstr();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Opt();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Pkey();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Pmask();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Pool();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Protocol();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Ptr();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Ptrary();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_RegxSql();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Sbrk();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Smallstr();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Sort();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Step();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Substr();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Tary();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Thash();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Tpool();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Upptr();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Val();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_Varlen();
// User-implemented function from gstatic:amc.FDb.tclass
void                 tclass_ZSListMT();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_FirstImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_First();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_InTreeQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_InsertImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Balance();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Propagate();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_TallerChild();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Disconnect();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Rebalance();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Next();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Prev();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_LastImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_ElemLt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_UpdateDepth();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Turn();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Connect();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_RemoveAllImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_Reinsert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_FirstGe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Atree_LastLt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Base_CopyOut();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Base_Castdown();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Base_Castbase();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Base_CopyIn();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Compact();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Dealloc();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Downheap();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_First();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_InBheapQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Reheap();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_ReheapFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_SetIfBetter();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_Upheap();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_ElemLt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_ElemLtval();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bheap_unordcurs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitfld_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitfld_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitfld_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_NBits();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_qGetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_GetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_BitsEmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_Sum1s();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_qClearBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_ClearBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_qSetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_SetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_qSetBitVal();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_qOrBitVal();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_ClearBitsAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_ClearBits();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_OrBits();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_ExpandBits();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_AllocBit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Bitset_Sup();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Blkpool_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Blkpool_SetBufferSize();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Blkpool_ReserveBuffers();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Blkpool_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Blkpool_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Charset_Match();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cmp_Swap();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cmp_Rotleft();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cmp_Nextchar();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cmp_Lt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cmp_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Count_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Count_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Count_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cppfunc_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cppfunc_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Cppfunc_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Hash();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_XrefMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Unref();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_ReadFieldMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_ReadTupleMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Lt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_GetMsgLength();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_GetMsgMemptr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_UpdateMax();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Min();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_UpdateMin();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Eq();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Update();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_EqStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_PrintArgv();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_ToCmdline();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_FmtJson();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_EqEnum();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ctype_GetAnon();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_qSetDouble();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_GetDouble();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_GetInt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_GetScale();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_SetDoubleMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Dec_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Delptr_Access();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Delptr_Delete();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Delptr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Delptr_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Start();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Kill();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Wait();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Exec();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_ExecX();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Execv();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_ToCmdline();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Exec_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_BeginRead();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_EndRead();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_EndWrite();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_BeginWrite();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_GetMsg();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_Outflow();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_Refill();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_Scanmsg();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_Shift();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_SkipBytes();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_SkipMsg();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_WriteAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fbuf_WriteMsg();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fcast_Cast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_GetEnum();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_SetEnum();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_ToCstr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_SetStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_SetStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Fconst_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Field_Cleanup();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Field_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Field_Concat();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Field2_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_ReadArgv();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_MainArgs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_main();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_MainLoop();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_Step();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_Main();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_InitReflection();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_StaticCheck();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_InsertStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_LoadTuplesMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_SaveTuples();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Global_LoadSsimfileMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Hook_Call();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Hook_Set0();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Hook_Set1();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Hook_Set2();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Fill();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_RemoveLast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Setary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_rowid_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Eq();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Inlary_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Io_SaveSsimfile();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Io_Input();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Io_InputMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Io_LoadStatic();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_RemoveLast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_DestructiveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_First();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_InLlistQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Next();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Prev();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_RotateFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Llist_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lpool_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lpool_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lpool_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lpool_ReserveBuffers();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lpool_ReallocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Lpool_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Malloc_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Malloc_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Malloc_ReallocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Numstr_qGetnum();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Numstr_GetnumDflt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Numstr_Geti64();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Numstr_SetnumMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Numstr_ForAllStrings();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Opt_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Opt_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Opt_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Opt_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pmask_PresentQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pmask_SetPresent();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_Alloc();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_AllocMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_AllocExtra();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_AllocExtraMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_AllocVarlenMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_AllocVarlen();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_UpdateMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Pool_Delete();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Protocol_StaticCheck();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptr_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptr_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptr_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptr_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_ScanInsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Ptrary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_RegxSql_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_RegxSql_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_RegxSql_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sbrk_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sbrk_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sbrk_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Add();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_AddStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Hash();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_HashStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Smallstr_qSet();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_Swap();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_Rotleft();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_Lt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_SortedQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_IntInsertionSort();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_IntHeapSort();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_IntQuickSort();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_InsertionSort();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_HeapSort();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Sort_QuickSort();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Step_FirstChanged();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Step_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Step_UpdateCycles();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Step_Step();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Step_Call();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Substr_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Substr_Get2();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Eq();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Addary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Alloc();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_AllocAt();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_AllocN();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_RemoveLast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_AbsReserve();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Setary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Setary2();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_rowid_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_FindX();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_GetOrCreate();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_FindRemove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Thash_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tpool_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tpool_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tpool_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tpool_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Tpool_ReserveMem();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Upptr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Val_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Val_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Val_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Val_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Val_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Varlen_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Varlen_Addr();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Varlen_N();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Varlen_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_Varlen_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_ZSListMT_DestructiveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_ZSListMT_InLlistQ();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_ZSListMT_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_ZSListMT_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_ZSListMT_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
void                 tfunc_ZSListMT_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_prep_signature();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_select_ns();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_dispenum();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_countxref();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_detectinst();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_trace();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_lookuppkey();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_tableenum();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_gconst();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_proc();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_msgcurs();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_basefield();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_clonefconst();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_prep_proto();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_charset();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_count();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_hook();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_exec();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_sortfld();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_cbase();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_ptrary();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_cfmt();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_newfield_dispatch();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_fieldid();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_prep_field();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_basepool();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_basepool();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_bigend();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_reftype();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_static();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_cheapcopy();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_cascdel();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_cpptype();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_prefix();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_bitfld();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_xref_parent();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_datafld();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ctype_toposort();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_prep_ctype();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_prep_fconst();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_usedns();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_include();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_load_gstatic();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_copypriv();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_pmask();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ssimdb();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_xref2();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_check_xref();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_fwddecl();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_enums();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_fwddecl2();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_pkeytypedef();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_begin();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_field();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_gstatic();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_compute_size();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_cget();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_fcmap();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_include();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_gsymbol();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_size_enums();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_ctype();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_check_path();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_check_pack();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_check_nstype();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_check_main();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_dispatch();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_pnew();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_funcindex();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_print_proto();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_print_struct();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_curstext();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_func();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_operators();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_check_lim();
// User-implemented function from gstatic:amc.FDb.gen
void                 gen_ns_write();
int                  main(int argc, char **argv);
} // end namespace amc
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const amc::BltinId &row);// cfmt:amc.BltinId.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::Enumstr &row);// cfmt:amc.Enumstr.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::trace &row);// cfmt:amc.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::FieldId &row);// cfmt:amc.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::TableId &row);// cfmt:amc.TableId.String
}
