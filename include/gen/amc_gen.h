//
// include/gen/amc_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/algo_gen.h"
#include "include/gen/dmmeta_gen.h"
#include "include/gen/amcdb_gen.h"
#include "include/gen/command_gen.h"
#include "include/gen/report_gen.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/dev_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- amc_BltinIdEnum

enum amc_BltinIdEnum {             // amc.BltinId.value
     amc_BltinId_bool       = 0    // dflt is a c++ expr: real dflt is 'N'
    ,amc_BltinId_char       = 1    // char
    ,amc_BltinId_double     = 2    // double
    ,amc_BltinId_float      = 3    // float
    ,amc_BltinId_i16        = 4    // 16-bit   signed integer
    ,amc_BltinId_i32        = 5    // 32-bit   signed integer
    ,amc_BltinId_i64        = 6    // 64-bit   signed integer
    ,amc_BltinId_i8         = 7    // 8-bit   signed integer
    ,amc_BltinId_pad_byte   = 8
    ,amc_BltinId_u128       = 9    // 128-bit unsigned integer
    ,amc_BltinId_u16        = 10   // 16-bit unsigned integer
    ,amc_BltinId_u32        = 11   // 32-bit unsigned integer
    ,amc_BltinId_u64        = 12   // 64-bit unsigned integer
    ,amc_BltinId_u8         = 13   // 8-bit unsigned integer
};

enum { amc_BltinIdEnum_N = 14 };


// --- amc_CppkeywordIdEnum

enum amc_CppkeywordIdEnum {                    // amc.CppkeywordId.id
     amc_CppkeywordId_alignas            = 0
    ,amc_CppkeywordId_alignof            = 1
    ,amc_CppkeywordId_and                = 2
    ,amc_CppkeywordId_and_eq             = 3
    ,amc_CppkeywordId_asm                = 4
    ,amc_CppkeywordId_auto               = 5
    ,amc_CppkeywordId_bitand             = 6
    ,amc_CppkeywordId_bitor              = 7
    ,amc_CppkeywordId_bool               = 8
    ,amc_CppkeywordId_break              = 9
    ,amc_CppkeywordId_case               = 10
    ,amc_CppkeywordId_catch              = 11
    ,amc_CppkeywordId_char               = 12
    ,amc_CppkeywordId_char16_t           = 13
    ,amc_CppkeywordId_char32_t           = 14
    ,amc_CppkeywordId_class              = 15
    ,amc_CppkeywordId_compl              = 16
    ,amc_CppkeywordId_const              = 17
    ,amc_CppkeywordId_constexpr          = 18
    ,amc_CppkeywordId_const_cast         = 19
    ,amc_CppkeywordId_continue           = 20
    ,amc_CppkeywordId_decltype           = 21
    ,amc_CppkeywordId_default            = 22
    ,amc_CppkeywordId_delete             = 23
    ,amc_CppkeywordId_do                 = 24
    ,amc_CppkeywordId_double             = 25
    ,amc_CppkeywordId_dynamic_cast       = 26
    ,amc_CppkeywordId_else               = 27
    ,amc_CppkeywordId_enum               = 28
    ,amc_CppkeywordId_explicit           = 29
    ,amc_CppkeywordId_export             = 30
    ,amc_CppkeywordId_extern             = 31
    ,amc_CppkeywordId_false              = 32
    ,amc_CppkeywordId_float              = 33
    ,amc_CppkeywordId_for                = 34
    ,amc_CppkeywordId_friend             = 35
    ,amc_CppkeywordId_goto               = 36
    ,amc_CppkeywordId_if                 = 37
    ,amc_CppkeywordId_inline             = 38
    ,amc_CppkeywordId_int                = 39
    ,amc_CppkeywordId_long               = 40
    ,amc_CppkeywordId_mutable            = 41
    ,amc_CppkeywordId_namespace          = 42
    ,amc_CppkeywordId_new                = 43
    ,amc_CppkeywordId_noexcept           = 44
    ,amc_CppkeywordId_not                = 45
    ,amc_CppkeywordId_not_eq             = 46
    ,amc_CppkeywordId_nullptr            = 47
    ,amc_CppkeywordId_operator           = 48
    ,amc_CppkeywordId_or                 = 49
    ,amc_CppkeywordId_or_eq              = 50
    ,amc_CppkeywordId_private            = 51
    ,amc_CppkeywordId_protected          = 52
    ,amc_CppkeywordId_public             = 53
    ,amc_CppkeywordId_register           = 54
    ,amc_CppkeywordId_reinterpret_cast   = 55
    ,amc_CppkeywordId_return             = 56
    ,amc_CppkeywordId_short              = 57
    ,amc_CppkeywordId_signed             = 58
    ,amc_CppkeywordId_sizeof             = 59
    ,amc_CppkeywordId_static             = 60
    ,amc_CppkeywordId_static_assert      = 61
    ,amc_CppkeywordId_static_cast        = 62
    ,amc_CppkeywordId_struct             = 63
    ,amc_CppkeywordId_switch             = 64
    ,amc_CppkeywordId_template           = 65
    ,amc_CppkeywordId_this               = 66
    ,amc_CppkeywordId_thread_local       = 67
    ,amc_CppkeywordId_throw              = 68
    ,amc_CppkeywordId_true               = 69
    ,amc_CppkeywordId_try                = 70
    ,amc_CppkeywordId_typedef            = 71
    ,amc_CppkeywordId_typeid             = 72
    ,amc_CppkeywordId_typename           = 73
    ,amc_CppkeywordId_union              = 74
    ,amc_CppkeywordId_unsigned           = 75
    ,amc_CppkeywordId_using              = 76
    ,amc_CppkeywordId_virtual            = 77
    ,amc_CppkeywordId_void               = 78
    ,amc_CppkeywordId_volatile           = 79
    ,amc_CppkeywordId_wchar_t            = 80
    ,amc_CppkeywordId_while              = 81
    ,amc_CppkeywordId_xor                = 82
    ,amc_CppkeywordId_xor_eq             = 83
};

enum { amc_CppkeywordIdEnum_N = 84 };


// --- amc_FieldIdEnum

enum amc_FieldIdEnum {        // amc.FieldId.value
     amc_FieldId_value   = 0
    ,amc_FieldId_len     = 1
    ,amc_FieldId_str     = 2
};

enum { amc_FieldIdEnum_N = 3 };


// --- amc_PnewtypeEnum

enum amc_PnewtypeEnum {             // amc.Pnewtype.value
     amc_Pnewtype_Memptr      = 0   // Some region in memory
    ,amc_Pnewtype_AmsStream   = 1   // Ams stream
    ,amc_Pnewtype_Fixed       = 2   // Fixed buffer
    ,amc_Pnewtype_Dynamic     = 3   // Dynamic buffer
    ,amc_Pnewtype_ByteAry     = 4   // ByteAry
    ,amc_Pnewtype_Append      = 5   // Append
};

enum { amc_PnewtypeEnum_N = 6 };


// --- amc_TableIdEnum

enum amc_TableIdEnum {                           // amc.TableId.value
     amc_TableId_dmmeta_Anonfld           = 0    // dmmeta.Anonfld -> amc.FAnonfld
    ,amc_TableId_dmmeta_anonfld           = 0    // dmmeta.anonfld -> amc.FAnonfld
    ,amc_TableId_dmmeta_Argvtype          = 1    // dmmeta.Argvtype -> amc.FArgvtype
    ,amc_TableId_dmmeta_argvtype          = 1    // dmmeta.argvtype -> amc.FArgvtype
    ,amc_TableId_dmmeta_Basepool          = 2    // dmmeta.Basepool -> amc.FBasepool
    ,amc_TableId_dmmeta_basepool          = 2    // dmmeta.basepool -> amc.FBasepool
    ,amc_TableId_dmmeta_Bitfld            = 3    // dmmeta.Bitfld -> amc.FBitfld
    ,amc_TableId_dmmeta_bitfld            = 3    // dmmeta.bitfld -> amc.FBitfld
    ,amc_TableId_amcdb_Bltin              = 4    // amcdb.Bltin -> amc.FBltin
    ,amc_TableId_amcdb_bltin              = 4    // amcdb.bltin -> amc.FBltin
    ,amc_TableId_dmmeta_Cafter            = 5    // dmmeta.Cafter -> amc.FCafter
    ,amc_TableId_dmmeta_cafter            = 5    // dmmeta.cafter -> amc.FCafter
    ,amc_TableId_dmmeta_Cascdel           = 6    // dmmeta.Cascdel -> amc.FCascdel
    ,amc_TableId_dmmeta_cascdel           = 6    // dmmeta.cascdel -> amc.FCascdel
    ,amc_TableId_dmmeta_Ccmp              = 7    // dmmeta.Ccmp -> amc.FCcmp
    ,amc_TableId_dmmeta_ccmp              = 7    // dmmeta.ccmp -> amc.FCcmp
    ,amc_TableId_dmmeta_Cdflt             = 8    // dmmeta.Cdflt -> amc.FCdflt
    ,amc_TableId_dmmeta_cdflt             = 8    // dmmeta.cdflt -> amc.FCdflt
    ,amc_TableId_dmmeta_Cextern           = 9    // dmmeta.Cextern -> amc.FCextern
    ,amc_TableId_dmmeta_cextern           = 9    // dmmeta.cextern -> amc.FCextern
    ,amc_TableId_dmmeta_Cfast             = 10   // dmmeta.Cfast -> amc.FCfast
    ,amc_TableId_dmmeta_cfast             = 10   // dmmeta.cfast -> amc.FCfast
    ,amc_TableId_dmmeta_Cfmt              = 11   // dmmeta.Cfmt -> amc.FCfmt
    ,amc_TableId_dmmeta_cfmt              = 11   // dmmeta.cfmt -> amc.FCfmt
    ,amc_TableId_dmmeta_Cget              = 12   // dmmeta.Cget -> amc.FCget
    ,amc_TableId_dmmeta_cget              = 12   // dmmeta.cget -> amc.FCget
    ,amc_TableId_dmmeta_Charset           = 13   // dmmeta.Charset -> amc.FCharset
    ,amc_TableId_dmmeta_charset           = 13   // dmmeta.charset -> amc.FCharset
    ,amc_TableId_dmmeta_Chash             = 14   // dmmeta.Chash -> amc.FChash
    ,amc_TableId_dmmeta_chash             = 14   // dmmeta.chash -> amc.FChash
    ,amc_TableId_dmmeta_Cppfunc           = 15   // dmmeta.Cppfunc -> amc.FCppfunc
    ,amc_TableId_dmmeta_cppfunc           = 15   // dmmeta.cppfunc -> amc.FCppfunc
    ,amc_TableId_dmmeta_Cpptype           = 16   // dmmeta.Cpptype -> amc.FCpptype
    ,amc_TableId_dmmeta_cpptype           = 16   // dmmeta.cpptype -> amc.FCpptype
    ,amc_TableId_dmmeta_Csize             = 17   // dmmeta.Csize -> amc.FCsize
    ,amc_TableId_dmmeta_csize             = 17   // dmmeta.csize -> amc.FCsize
    ,amc_TableId_dmmeta_Cstr              = 18   // dmmeta.Cstr -> amc.FCstr
    ,amc_TableId_dmmeta_cstr              = 18   // dmmeta.cstr -> amc.FCstr
    ,amc_TableId_dmmeta_Ctype             = 19   // dmmeta.Ctype -> amc.FCtype
    ,amc_TableId_dmmeta_ctype             = 19   // dmmeta.ctype -> amc.FCtype
    ,amc_TableId_dmmeta_Dispatch          = 20   // dmmeta.Dispatch -> amc.FDispatch
    ,amc_TableId_dmmeta_dispatch          = 20   // dmmeta.dispatch -> amc.FDispatch
    ,amc_TableId_dmmeta_DispatchMsg       = 21   // dmmeta.DispatchMsg -> amc.FDispatchmsg
    ,amc_TableId_dmmeta_dispatch_msg      = 21   // dmmeta.dispatch_msg -> amc.FDispatchmsg
    ,amc_TableId_dmmeta_Dispctx           = 22   // dmmeta.Dispctx -> amc.FDispctx
    ,amc_TableId_dmmeta_dispctx           = 22   // dmmeta.dispctx -> amc.FDispctx
    ,amc_TableId_dmmeta_Dispfilter        = 23   // dmmeta.Dispfilter -> amc.FDispfilter
    ,amc_TableId_dmmeta_dispfilter        = 23   // dmmeta.dispfilter -> amc.FDispfilter
    ,amc_TableId_dmmeta_Disptrace         = 24   // dmmeta.Disptrace -> amc.FDisptrace
    ,amc_TableId_dmmeta_disptrace         = 24   // dmmeta.disptrace -> amc.FDisptrace
    ,amc_TableId_dmmeta_Falias            = 25   // dmmeta.Falias -> amc.FFalias
    ,amc_TableId_dmmeta_falias            = 25   // dmmeta.falias -> amc.FFalias
    ,amc_TableId_dmmeta_Fbase             = 26   // dmmeta.Fbase -> amc.FFbase
    ,amc_TableId_dmmeta_fbase             = 26   // dmmeta.fbase -> amc.FFbase
    ,amc_TableId_dmmeta_Fbigend           = 27   // dmmeta.Fbigend -> amc.FFbigend
    ,amc_TableId_dmmeta_fbigend           = 27   // dmmeta.fbigend -> amc.FFbigend
    ,amc_TableId_dmmeta_Fbitset           = 28   // dmmeta.Fbitset -> amc.FFbitset
    ,amc_TableId_dmmeta_fbitset           = 28   // dmmeta.fbitset -> amc.FFbitset
    ,amc_TableId_dmmeta_Fbuf              = 29   // dmmeta.Fbuf -> amc.FFbuf
    ,amc_TableId_dmmeta_fbuf              = 29   // dmmeta.fbuf -> amc.FFbuf
    ,amc_TableId_dmmeta_Fcast             = 30   // dmmeta.Fcast -> amc.FFcast
    ,amc_TableId_dmmeta_fcast             = 30   // dmmeta.fcast -> amc.FFcast
    ,amc_TableId_dmmeta_Fcleanup          = 31   // dmmeta.Fcleanup -> amc.FFcleanup
    ,amc_TableId_dmmeta_fcleanup          = 31   // dmmeta.fcleanup -> amc.FFcleanup
    ,amc_TableId_dmmeta_Fcmap             = 32   // dmmeta.Fcmap -> amc.FFcmap
    ,amc_TableId_dmmeta_fcmap             = 32   // dmmeta.fcmap -> amc.FFcmap
    ,amc_TableId_dmmeta_Fcmdline          = 33   // dmmeta.Fcmdline -> amc.FFcmdline
    ,amc_TableId_dmmeta_fcmdline          = 33   // dmmeta.fcmdline -> amc.FFcmdline
    ,amc_TableId_dmmeta_Fcmp              = 34   // dmmeta.Fcmp -> amc.FFcmp
    ,amc_TableId_dmmeta_fcmp              = 34   // dmmeta.fcmp -> amc.FFcmp
    ,amc_TableId_dmmeta_Fcompact          = 35   // dmmeta.Fcompact -> amc.FFcompact
    ,amc_TableId_dmmeta_fcompact          = 35   // dmmeta.fcompact -> amc.FFcompact
    ,amc_TableId_dmmeta_Fconst            = 36   // dmmeta.Fconst -> amc.FFconst
    ,amc_TableId_dmmeta_fconst            = 36   // dmmeta.fconst -> amc.FFconst
    ,amc_TableId_dmmeta_Fcurs             = 37   // dmmeta.Fcurs -> amc.FFcurs
    ,amc_TableId_dmmeta_fcurs             = 37   // dmmeta.fcurs -> amc.FFcurs
    ,amc_TableId_dmmeta_Fdec              = 38   // dmmeta.Fdec -> amc.FFdec
    ,amc_TableId_dmmeta_fdec              = 38   // dmmeta.fdec -> amc.FFdec
    ,amc_TableId_dmmeta_Fdelay            = 39   // dmmeta.Fdelay -> amc.FFdelay
    ,amc_TableId_dmmeta_fdelay            = 39   // dmmeta.fdelay -> amc.FFdelay
    ,amc_TableId_dmmeta_Ffast             = 40   // dmmeta.Ffast -> amc.FFfast
    ,amc_TableId_dmmeta_ffast             = 40   // dmmeta.ffast -> amc.FFfast
    ,amc_TableId_dmmeta_Fflag             = 41   // dmmeta.Fflag -> amc.FFflag
    ,amc_TableId_dmmeta_fflag             = 41   // dmmeta.fflag -> amc.FFflag
    ,amc_TableId_dmmeta_Field             = 42   // dmmeta.Field -> amc.FField
    ,amc_TableId_dmmeta_field             = 42   // dmmeta.field -> amc.FField
    ,amc_TableId_dmmeta_Findrem           = 43   // dmmeta.Findrem -> amc.FFindrem
    ,amc_TableId_dmmeta_findrem           = 43   // dmmeta.findrem -> amc.FFindrem
    ,amc_TableId_dmmeta_Finput            = 44   // dmmeta.Finput -> amc.FFinput
    ,amc_TableId_dmmeta_finput            = 44   // dmmeta.finput -> amc.FFinput
    ,amc_TableId_dmmeta_Fldoffset         = 45   // dmmeta.Fldoffset -> amc.FFldoffset
    ,amc_TableId_dmmeta_fldoffset         = 45   // dmmeta.fldoffset -> amc.FFldoffset
    ,amc_TableId_dmmeta_Floadtuples       = 46   // dmmeta.Floadtuples -> amc.FFloadtuples
    ,amc_TableId_dmmeta_floadtuples       = 46   // dmmeta.floadtuples -> amc.FFloadtuples
    ,amc_TableId_dmmeta_Fnoremove         = 47   // dmmeta.Fnoremove -> amc.FFnoremove
    ,amc_TableId_dmmeta_fnoremove         = 47   // dmmeta.fnoremove -> amc.FFnoremove
    ,amc_TableId_dmmeta_Foutput           = 48   // dmmeta.Foutput -> amc.FFoutput
    ,amc_TableId_dmmeta_foutput           = 48   // dmmeta.foutput -> amc.FFoutput
    ,amc_TableId_dmmeta_Fprefix           = 49   // dmmeta.Fprefix -> amc.FFprefix
    ,amc_TableId_dmmeta_fprefix           = 49   // dmmeta.fprefix -> amc.FFprefix
    ,amc_TableId_dmmeta_Fregx             = 50   // dmmeta.Fregx -> amc.FFregx
    ,amc_TableId_dmmeta_fregx             = 50   // dmmeta.fregx -> amc.FFregx
    ,amc_TableId_dmmeta_Fsort             = 51   // dmmeta.Fsort -> amc.FFsort
    ,amc_TableId_dmmeta_fsort             = 51   // dmmeta.fsort -> amc.FFsort
    ,amc_TableId_dmmeta_Fstep             = 52   // dmmeta.Fstep -> amc.FFstep
    ,amc_TableId_dmmeta_fstep             = 52   // dmmeta.fstep -> amc.FFstep
    ,amc_TableId_dmmeta_Ftrace            = 53   // dmmeta.Ftrace -> amc.FFtrace
    ,amc_TableId_dmmeta_ftrace            = 53   // dmmeta.ftrace -> amc.FFtrace
    ,amc_TableId_dmmeta_Func              = 54   // dmmeta.Func -> amc.FFunc
    ,amc_TableId_dmmeta_func              = 54   // dmmeta.func -> amc.FFunc
    ,amc_TableId_dmmeta_Funique           = 55   // dmmeta.Funique -> amc.FFunique
    ,amc_TableId_dmmeta_funique           = 55   // dmmeta.funique -> amc.FFunique
    ,amc_TableId_dmmeta_Fuserinit         = 56   // dmmeta.Fuserinit -> amc.FFuserinit
    ,amc_TableId_dmmeta_fuserinit         = 56   // dmmeta.fuserinit -> amc.FFuserinit
    ,amc_TableId_dmmeta_Fwddecl           = 57   // dmmeta.Fwddecl -> amc.FFwddecl
    ,amc_TableId_dmmeta_fwddecl           = 57   // dmmeta.fwddecl -> amc.FFwddecl
    ,amc_TableId_dmmeta_Gconst            = 58   // dmmeta.Gconst -> amc.FGconst
    ,amc_TableId_dmmeta_gconst            = 58   // dmmeta.gconst -> amc.FGconst
    ,amc_TableId_dmmeta_Gstatic           = 59   // dmmeta.Gstatic -> amc.FGstatic
    ,amc_TableId_dmmeta_gstatic           = 59   // dmmeta.gstatic -> amc.FGstatic
    ,amc_TableId_dmmeta_Gsymbol           = 60   // dmmeta.Gsymbol -> amc.FGsymbol
    ,amc_TableId_dmmeta_gsymbol           = 60   // dmmeta.gsymbol -> amc.FGsymbol
    ,amc_TableId_dmmeta_Hook              = 61   // dmmeta.Hook -> amc.FHook
    ,amc_TableId_dmmeta_hook              = 61   // dmmeta.hook -> amc.FHook
    ,amc_TableId_dmmeta_Inlary            = 62   // dmmeta.Inlary -> amc.FInlary
    ,amc_TableId_dmmeta_inlary            = 62   // dmmeta.inlary -> amc.FInlary
    ,amc_TableId_dmmeta_Lenfld            = 63   // dmmeta.Lenfld -> amc.FLenfld
    ,amc_TableId_dmmeta_lenfld            = 63   // dmmeta.lenfld -> amc.FLenfld
    ,amc_TableId_dev_License              = 64   // dev.License -> amc.FLicense
    ,amc_TableId_dev_license              = 64   // dev.license -> amc.FLicense
    ,amc_TableId_dmmeta_Listtype          = 65   // dmmeta.Listtype -> amc.FListtype
    ,amc_TableId_dmmeta_listtype          = 65   // dmmeta.listtype -> amc.FListtype
    ,amc_TableId_dmmeta_Llist             = 66   // dmmeta.Llist -> amc.FLlist
    ,amc_TableId_dmmeta_llist             = 66   // dmmeta.llist -> amc.FLlist
    ,amc_TableId_dmmeta_Main              = 67   // dmmeta.Main -> amc.FMain
    ,amc_TableId_dmmeta_main              = 67   // dmmeta.main -> amc.FMain
    ,amc_TableId_dmmeta_Msgtype           = 68   // dmmeta.Msgtype -> amc.FMsgtype
    ,amc_TableId_dmmeta_msgtype           = 68   // dmmeta.msgtype -> amc.FMsgtype
    ,amc_TableId_dmmeta_Nocascdel         = 69   // dmmeta.Nocascdel -> amc.FNocascdel
    ,amc_TableId_dmmeta_nocascdel         = 69   // dmmeta.nocascdel -> amc.FNocascdel
    ,amc_TableId_dmmeta_Nossimfile        = 70   // dmmeta.Nossimfile -> amc.FNossimfile
    ,amc_TableId_dmmeta_nossimfile        = 70   // dmmeta.nossimfile -> amc.FNossimfile
    ,amc_TableId_dmmeta_Noxref            = 71   // dmmeta.Noxref -> amc.FNoxref
    ,amc_TableId_dmmeta_noxref            = 71   // dmmeta.noxref -> amc.FNoxref
    ,amc_TableId_dmmeta_Ns                = 72   // dmmeta.Ns -> amc.FNs
    ,amc_TableId_dmmeta_ns                = 72   // dmmeta.ns -> amc.FNs
    ,amc_TableId_dmmeta_Nscpp             = 73   // dmmeta.Nscpp -> amc.FNscpp
    ,amc_TableId_dmmeta_nscpp             = 73   // dmmeta.nscpp -> amc.FNscpp
    ,amc_TableId_dmmeta_Nsdb              = 74   // dmmeta.Nsdb -> amc.FNsdb
    ,amc_TableId_dmmeta_nsdb              = 74   // dmmeta.nsdb -> amc.FNsdb
    ,amc_TableId_dmmeta_Nsinclude         = 75   // dmmeta.Nsinclude -> amc.FNsinclude
    ,amc_TableId_dmmeta_nsinclude         = 75   // dmmeta.nsinclude -> amc.FNsinclude
    ,amc_TableId_dmmeta_Nsproto           = 76   // dmmeta.Nsproto -> amc.FNsproto
    ,amc_TableId_dmmeta_nsproto           = 76   // dmmeta.nsproto -> amc.FNsproto
    ,amc_TableId_dmmeta_Nsx               = 77   // dmmeta.Nsx -> amc.FNsx
    ,amc_TableId_dmmeta_nsx               = 77   // dmmeta.nsx -> amc.FNsx
    ,amc_TableId_dmmeta_Numstr            = 78   // dmmeta.Numstr -> amc.FNumstr
    ,amc_TableId_dmmeta_numstr            = 78   // dmmeta.numstr -> amc.FNumstr
    ,amc_TableId_dmmeta_Pack              = 79   // dmmeta.Pack -> amc.FPack
    ,amc_TableId_dmmeta_pack              = 79   // dmmeta.pack -> amc.FPack
    ,amc_TableId_dmmeta_Pmaskfld          = 80   // dmmeta.Pmaskfld -> amc.FPmaskfld
    ,amc_TableId_dmmeta_pmaskfld          = 80   // dmmeta.pmaskfld -> amc.FPmaskfld
    ,amc_TableId_dmmeta_PmaskfldMember    = 81   // dmmeta.PmaskfldMember -> amc.FPmaskfldMember
    ,amc_TableId_dmmeta_pmaskfld_member   = 81   // dmmeta.pmaskfld_member -> amc.FPmaskfldMember
    ,amc_TableId_dmmeta_Pnew              = 82   // dmmeta.Pnew -> amc.FPnew
    ,amc_TableId_dmmeta_pnew              = 82   // dmmeta.pnew -> amc.FPnew
    ,amc_TableId_dmmeta_Ptrary            = 83   // dmmeta.Ptrary -> amc.FPtrary
    ,amc_TableId_dmmeta_ptrary            = 83   // dmmeta.ptrary -> amc.FPtrary
    ,amc_TableId_dmmeta_Rowid             = 84   // dmmeta.Rowid -> amc.FRowid
    ,amc_TableId_dmmeta_rowid             = 84   // dmmeta.rowid -> amc.FRowid
    ,amc_TableId_dmmeta_Smallstr          = 85   // dmmeta.Smallstr -> amc.FSmallstr
    ,amc_TableId_dmmeta_smallstr          = 85   // dmmeta.smallstr -> amc.FSmallstr
    ,amc_TableId_dmmeta_Sortfld           = 86   // dmmeta.Sortfld -> amc.FSortfld
    ,amc_TableId_dmmeta_sortfld           = 86   // dmmeta.sortfld -> amc.FSortfld
    ,amc_TableId_dmmeta_Ssimfile          = 87   // dmmeta.Ssimfile -> amc.FSsimfile
    ,amc_TableId_dmmeta_ssimfile          = 87   // dmmeta.ssimfile -> amc.FSsimfile
    ,amc_TableId_dmmeta_Ssimsort          = 88   // dmmeta.Ssimsort -> amc.FSsimsort
    ,amc_TableId_dmmeta_ssimsort          = 88   // dmmeta.ssimsort -> amc.FSsimsort
    ,amc_TableId_dmmeta_Ssimvolatile      = 89   // dmmeta.Ssimvolatile -> amc.FSsimvolatile
    ,amc_TableId_dmmeta_ssimvolatile      = 89   // dmmeta.ssimvolatile -> amc.FSsimvolatile
    ,amc_TableId_dmmeta_Substr            = 90   // dmmeta.Substr -> amc.FSubstr
    ,amc_TableId_dmmeta_substr            = 90   // dmmeta.substr -> amc.FSubstr
    ,amc_TableId_dev_Targdep              = 91   // dev.Targdep -> amc.FTargdep
    ,amc_TableId_dev_targdep              = 91   // dev.targdep -> amc.FTargdep
    ,amc_TableId_dev_Target               = 92   // dev.Target -> amc.FTarget
    ,amc_TableId_dev_target               = 92   // dev.target -> amc.FTarget
    ,amc_TableId_dmmeta_Tary              = 93   // dmmeta.Tary -> amc.FTary
    ,amc_TableId_dmmeta_tary              = 93   // dmmeta.tary -> amc.FTary
    ,amc_TableId_amcdb_Tcurs              = 94   // amcdb.Tcurs -> amc.FTcurs
    ,amc_TableId_amcdb_tcurs              = 94   // amcdb.tcurs -> amc.FTcurs
    ,amc_TableId_dmmeta_Thash             = 95   // dmmeta.Thash -> amc.FThash
    ,amc_TableId_dmmeta_thash             = 95   // dmmeta.thash -> amc.FThash
    ,amc_TableId_dmmeta_Typefld           = 96   // dmmeta.Typefld -> amc.FTypefld
    ,amc_TableId_dmmeta_typefld           = 96   // dmmeta.typefld -> amc.FTypefld
    ,amc_TableId_dmmeta_Usertracefld      = 97   // dmmeta.Usertracefld -> amc.FUsertracefld
    ,amc_TableId_dmmeta_usertracefld      = 97   // dmmeta.usertracefld -> amc.FUsertracefld
    ,amc_TableId_dmmeta_Xref              = 98   // dmmeta.Xref -> amc.FXref
    ,amc_TableId_dmmeta_xref              = 98   // dmmeta.xref -> amc.FXref
};

enum { amc_TableIdEnum_N = 198 };

namespace amc { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace amc { // gen:ns_tclass_field
struct lpool_Lpblock {
    lpool_Lpblock* next;
};
extern const char *amc_help;
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace dmmeta { struct Anonfld; }
namespace dmmeta { struct Argvtype; }
namespace dmmeta { struct Basepool; }
namespace amc { struct FField; }
namespace dmmeta { struct Bitfld; }
namespace amcdb { struct Bltin; }
namespace dmmeta { struct Cafter; }
namespace amc { struct FCtype; }
namespace dmmeta { struct Cascdel; }
namespace dmmeta { struct Ccmp; }
namespace dmmeta { struct Cdflt; }
namespace dmmeta { struct Cextern; }
namespace dmmeta { struct Cfast; }
namespace dmmeta { struct Cfmt; }
namespace dmmeta { struct Cget; }
namespace dmmeta { struct Charset; }
namespace dmmeta { struct Chash; }
namespace dmmeta { struct Cppfunc; }
namespace dmmeta { struct Cpptype; }
namespace dmmeta { struct Csize; }
namespace dmmeta { struct Cstr; }
namespace dmmeta { struct Ctype; }
namespace amc { struct FNs; }
namespace dmmeta { struct Ctypelen; }
namespace dmmeta { struct Dispatch; }
namespace dmmeta { struct DispatchMsg; }
namespace amc { struct FDispatch; }
namespace dmmeta { struct Dispctx; }
namespace dmmeta { struct Dispfilter; }
namespace dmmeta { struct Dispsig; }
namespace dmmeta { struct Disptrace; }
namespace dmmeta { struct Falias; }
namespace dmmeta { struct Fbase; }
namespace dmmeta { struct Fbigend; }
namespace dmmeta { struct Fbitset; }
namespace dmmeta { struct Fbuf; }
namespace dmmeta { struct Fcast; }
namespace dmmeta { struct Fcleanup; }
namespace dmmeta { struct Fcmap; }
namespace dmmeta { struct Fcmdline; }
namespace dmmeta { struct Fcmp; }
namespace dmmeta { struct Fcompact; }
namespace dmmeta { struct Fconst; }
namespace dmmeta { struct Fcurs; }
namespace dmmeta { struct Fdec; }
namespace dmmeta { struct Fdelay; }
namespace dmmeta { struct Ffast; }
namespace dmmeta { struct Fflag; }
namespace dmmeta { struct Field; }
namespace amc { struct FReftype; }
namespace dmmeta { struct Findrem; }
namespace dmmeta { struct Finput; }
namespace dmmeta { struct Fldoffset; }
namespace dmmeta { struct Floadtuples; }
namespace dmmeta { struct Fnoremove; }
namespace dmmeta { struct Foutput; }
namespace dmmeta { struct Fprefix; }
namespace dmmeta { struct Fregx; }
namespace dmmeta { struct Fsort; }
namespace dmmeta { struct Fstep; }
namespace dmmeta { struct Ftrace; }
namespace dmmeta { struct Func; }
namespace dmmeta { struct Funique; }
namespace dmmeta { struct Fuserinit; }
namespace dmmeta { struct Fwddecl; }
namespace dmmeta { struct Gconst; }
namespace amcdb { struct Gen; }
namespace dmmeta { struct Gstatic; }
namespace dmmeta { struct Gsymbol; }
namespace amc { struct FSsimfile; }
namespace dmmeta { struct Hook; }
namespace dmmeta { struct Inlary; }
namespace dmmeta { struct Lenfld; }
namespace dev { struct License; }
namespace dmmeta { struct Listtype; }
namespace dmmeta { struct Llist; }
namespace amc { struct FListtype; }
namespace dmmeta { struct Main; }
namespace dmmeta { struct Msgtype; }
namespace dmmeta { struct Nocascdel; }
namespace dmmeta { struct Nossimfile; }
namespace dmmeta { struct Noxref; }
namespace dmmeta { struct Ns; }
namespace amc { struct FLicense; }
namespace dmmeta { struct Nscpp; }
namespace dmmeta { struct Nsdb; }
namespace dmmeta { struct Nsinclude; }
namespace dmmeta { struct Nsproto; }
namespace dmmeta { struct Nsx; }
namespace dmmeta { struct Numstr; }
namespace dmmeta { struct Pack; }
namespace dmmeta { struct Pmaskfld; }
namespace dmmeta { struct PmaskfldMember; }
namespace amc { struct FPmaskfld; }
namespace dmmeta { struct Pnew; }
namespace dmmeta { struct Ptrary; }
namespace dmmeta { struct Reftype; }
namespace amc { struct FTclass; }
namespace dmmeta { struct Rowid; }
namespace dmmeta { struct Smallstr; }
namespace dmmeta { struct Sortfld; }
namespace dmmeta { struct Ssimfile; }
namespace dmmeta { struct Ssimsort; }
namespace dmmeta { struct Ssimvolatile; }
namespace dmmeta { struct Substr; }
namespace dev { struct Targdep; }
namespace amc { struct FTarget; }
namespace dev { struct Target; }
namespace dmmeta { struct Tary; }
namespace amcdb { struct Tclass; }
namespace amcdb { struct Tcurs; }
namespace amcdb { struct Tfunc; }
namespace dmmeta { struct Thash; }
namespace dmmeta { struct Tracefld; }
namespace dmmeta { struct Tracerec; }
namespace dmmeta { struct Typefld; }
namespace dmmeta { struct Usertracefld; }
namespace dmmeta { struct Xref; }
namespace amc { struct FTfunc; }
namespace amc { struct FFunc; }
namespace amc { struct ctype_zs_cfmt_curs; }
namespace amc { struct ctype_c_field_curs; }
namespace amc { struct ctype_c_static_curs; }
namespace amc { struct ctype_c_parent_curs; }
namespace amc { struct ctype_c_pmaskfld_curs; }
namespace amc { struct ctype_c_datafld_curs; }
namespace amc { struct ctype_zd_inst_curs; }
namespace amc { struct ctype_zs_xref_curs; }
namespace amc { struct ctype_c_ffunc_curs; }
namespace amc { struct ctype_zd_cafter_curs; }
namespace amc { struct ctype_zd_access_curs; }
namespace amc { struct ctype_c_fcurs_curs; }
namespace amc { struct ctype_c_ffast_curs; }
namespace amc { struct tclass_c_tfunc_curs; }
namespace amc { struct _db_fsort_curs; }
namespace amc { struct _db_dispfilter_curs; }
namespace amc { struct _db_usertracefld_curs; }
namespace amc { struct _db_cfmt_curs; }
namespace amc { struct _db_dispatch_curs; }
namespace amc { struct _db_dispatch_msg_curs; }
namespace amc { struct _db_ctype_curs; }
namespace amc { struct _db_field_curs; }
namespace amc { struct _db_basepool_curs; }
namespace amc { struct _db_llist_curs; }
namespace amc { struct _db_anonfld_curs; }
namespace amc { struct _db_xref_curs; }
namespace amc { struct _db_ns_curs; }
namespace amc { struct _db_pnew_curs; }
namespace amc { struct _db_fldoffset_curs; }
namespace amc { struct _db_typefld_curs; }
namespace amc { struct _db_lenfld_curs; }
namespace amc { struct _db_bltin_curs; }
namespace amc { struct _db_static_tuple_curs; }
namespace amc { struct _db_msgtype_curs; }
namespace amc { struct _db_gconst_curs; }
namespace amc { struct _db_gstatic_curs; }
namespace amc { struct _db_thash_curs; }
namespace amc { struct _db_func_curs; }
namespace amc { struct _db_smallstr_curs; }
namespace amc { struct _db_numstr_curs; }
namespace amc { struct _db_main_curs; }
namespace amc { struct _db_reftype_curs; }
namespace amc { struct _db_cpptype_curs; }
namespace amc { struct _db_inlary_curs; }
namespace amc { struct _db_tary_curs; }
namespace amc { struct _db_cppfunc_curs; }
namespace amc { struct _db_rowid_curs; }
namespace amc { struct _db_cascdel_curs; }
namespace amc { struct _db_substr_curs; }
namespace amc { struct _db_bitfld_curs; }
namespace amc { struct _db_ssimfile_curs; }
namespace amc { struct _db_pack_curs; }
namespace amc { struct _db_ptrary_curs; }
namespace amc { struct _db_c_ctype_sorted_curs; }
namespace amc { struct _db_enumstr_curs; }
namespace amc { struct _db_enumstr_len_curs; }
namespace amc { struct _db_bh_enumstr_len_curs; }
namespace amc { struct _db_fbitset_curs; }
namespace amc { struct _db_fcleanup_curs; }
namespace amc { struct _db_fdec_curs; }
namespace amc { struct _db_fconst_curs; }
namespace amc { struct _db_c_ns_sorted_curs; }
namespace amc { struct _db_finput_curs; }
namespace amc { struct _db_foutput_curs; }
namespace amc { struct _db_fbuf_curs; }
namespace amc { struct _db_chash_curs; }
namespace amc { struct _db_ccmp_curs; }
namespace amc { struct _db_fbigend_curs; }
namespace amc { struct _db_zsl_ctype_pack_tran_curs; }
namespace amc { struct _db_cstr_curs; }
namespace amc { struct _db_listtype_curs; }
namespace amc { struct _db_fstep_curs; }
namespace amc { struct _db_cextern_curs; }
namespace amc { struct _db_fdelay_curs; }
namespace amc { struct _db_disptrace_curs; }
namespace amc { struct _db_tracefld_curs; }
namespace amc { struct _db_tracerec_curs; }
namespace amc { struct _db_dispsig_curs; }
namespace amc { struct _db_c_dispsig_sorted_curs; }
namespace amc { struct _db_zs_sig_visit_curs; }
namespace amc { struct _db_target_curs; }
namespace amc { struct _db_targdep_curs; }
namespace amc { struct _db_dispctx_curs; }
namespace amc { struct _db_pmaskfld_curs; }
namespace amc { struct _db_fwddecl_curs; }
namespace amc { struct _db_tfunc_curs; }
namespace amc { struct _db_gen_curs; }
namespace amc { struct _db_fregx_curs; }
namespace amc { struct _db_tclass_curs; }
namespace amc { struct _db_fcmp_curs; }
namespace amc { struct _db_fcast_curs; }
namespace amc { struct _db_noxref_curs; }
namespace amc { struct _db_nocascdel_curs; }
namespace amc { struct _db_cafter_curs; }
namespace amc { struct _db_csize_curs; }
namespace amc { struct _db_nsx_curs; }
namespace amc { struct _db_fcompact_curs; }
namespace amc { struct _db_findrem_curs; }
namespace amc { struct _db_fcurs_curs; }
namespace amc { struct _db_cdflt_curs; }
namespace amc { struct _db_argvtype_curs; }
namespace amc { struct _db_fcmdline_curs; }
namespace amc { struct _db_floadtuples_curs; }
namespace amc { struct _db_fcmap_curs; }
namespace amc { struct _db_zs_ordkeyfield_curs; }
namespace amc { struct _db_nsproto_curs; }
namespace amc { struct _db_nsdb_curs; }
namespace amc { struct _db_zd_substr_params_curs; }
namespace amc { struct _db_fprefix_curs; }
namespace amc { struct _db_ftrace_curs; }
namespace amc { struct _db_fnoremove_curs; }
namespace amc { struct _db_c_substr_field_curs; }
namespace amc { struct _db_ctypelen_curs; }
namespace amc { struct _db_c_ctypelen_curs; }
namespace amc { struct _db_c_tempfield_curs; }
namespace amc { struct _db_fbase_curs; }
namespace amc { struct _db_nossimfile_curs; }
namespace amc { struct _db_gsymbol_curs; }
namespace amc { struct _db_sortfld_curs; }
namespace amc { struct _db_cget_curs; }
namespace amc { struct _db_cd_temp_func_curs; }
namespace amc { struct _db_zs_gen_perns_curs; }
namespace amc { struct _db_hook_curs; }
namespace amc { struct _db_charset_curs; }
namespace amc { struct _db_nsinclude_curs; }
namespace amc { struct _db_ssimvolatile_curs; }
namespace amc { struct _db_funique_curs; }
namespace amc { struct _db_fuserinit_curs; }
namespace amc { struct _db_tcurs_curs; }
namespace amc { struct _db_nscpp_curs; }
namespace amc { struct _db_fflag_curs; }
namespace amc { struct _db_falias_curs; }
namespace amc { struct _db_license_curs; }
namespace amc { struct _db_c_ssimfile_sorted_curs; }
namespace amc { struct _db_zd_ssimfile_todo_curs; }
namespace amc { struct _db_cfast_curs; }
namespace amc { struct _db_ffast_curs; }
namespace amc { struct _db_pmaskfld_member_curs; }
namespace amc { struct _db_ssimsort_curs; }
namespace amc { struct dispatch_c_dispatch_msg_curs; }
namespace amc { struct enumstr_c_fconst_curs; }
namespace amc { struct enumstr_len_bh_enumstr_curs; }
namespace amc { struct field_c_ffunc_curs; }
namespace amc { struct field_c_fconst_curs; }
namespace amc { struct field_zd_xref_keyfld_curs; }
namespace amc { struct field_zs_fcmap_curs; }
namespace amc { struct field_bh_bitfld_curs; }
namespace amc { struct field_c_ffast_curs; }
namespace amc { struct field_c_pmaskfld_member_curs; }
namespace amc { struct func_funcarg_curs; }
namespace amc { struct FGenXref_seen_curs; }
namespace amc { struct ns_c_ctype_curs; }
namespace amc { struct ns_c_func_curs; }
namespace amc { struct ns_c_dispatch_curs; }
namespace amc { struct ns_c_gstatic_curs; }
namespace amc { struct ns_include_curs; }
namespace amc { struct ns_c_dispsig_curs; }
namespace amc { struct ns_c_parentns_curs; }
namespace amc { struct ns_c_cppincl_curs; }
namespace amc { struct ns_c_hdrincl_curs; }
namespace amc { struct ns_c_fwddecl_curs; }
namespace amc { struct ns_c_pnew_curs; }
namespace amc { struct ns_c_outfile_curs; }
namespace amc { struct ns_c_foutput_curs; }
namespace amc { struct ns_c_fstep_curs; }
namespace amc { struct ns_c_gsymbol_curs; }
namespace amc { struct ns_c_nsinclude_curs; }
namespace amc { struct pmaskfld_c_pmaskfld_member_curs; }
namespace amc { struct reftype_zs_fprefix_curs; }
namespace amc { struct target_c_targdep_curs; }
namespace amc { struct BltinId; }
namespace amc { struct CppkeywordId; }
namespace amc { struct Enumstr; }
namespace amc { struct FAnonfld; }
namespace amc { struct FArgvtype; }
namespace amc { struct FBasepool; }
namespace amc { struct FBitfld; }
namespace amc { struct FBltin; }
namespace amc { struct FCafter; }
namespace amc { struct FCascdel; }
namespace amc { struct FCcmp; }
namespace amc { struct FCdflt; }
namespace amc { struct FCextern; }
namespace amc { struct FCfast; }
namespace amc { struct FCfmt; }
namespace amc { struct FCget; }
namespace amc { struct FCharset; }
namespace amc { struct FChash; }
namespace amc { struct FCppfunc; }
namespace amc { struct FCpptype; }
namespace amc { struct FCsize; }
namespace amc { struct FCstr; }
namespace amc { struct FCtypelen; }
namespace amc { struct Genctx; }
namespace amc { struct trace; }
namespace amc { struct FDb; }
namespace amc { struct FDispatchmsg; }
namespace amc { struct FDispctx; }
namespace amc { struct FDispfilter; }
namespace amc { struct FDispsig; }
namespace amc { struct FDisptrace; }
namespace amc { struct FEnumstr; }
namespace amc { struct FEnumstrLen; }
namespace amc { struct FFalias; }
namespace amc { struct FFbase; }
namespace amc { struct FFbigend; }
namespace amc { struct FFbitset; }
namespace amc { struct FFbuf; }
namespace amc { struct FFcast; }
namespace amc { struct FFcleanup; }
namespace amc { struct FFcmap; }
namespace amc { struct FFcmdline; }
namespace amc { struct FFcmp; }
namespace amc { struct FFcompact; }
namespace amc { struct FFconst; }
namespace amc { struct FFcurs; }
namespace amc { struct FFdec; }
namespace amc { struct FFdelay; }
namespace amc { struct FFfast; }
namespace amc { struct FFflag; }
namespace amc { struct FFindrem; }
namespace amc { struct FFinput; }
namespace amc { struct FFldoffset; }
namespace amc { struct FFloadtuples; }
namespace amc { struct FFnoremove; }
namespace amc { struct FFoutput; }
namespace amc { struct FFprefix; }
namespace amc { struct FFregx; }
namespace amc { struct FFsort; }
namespace amc { struct FFstep; }
namespace amc { struct FFtrace; }
namespace amc { struct FFunique; }
namespace amc { struct FFuserinit; }
namespace amc { struct FFwddecl; }
namespace amc { struct FGconst; }
namespace amc { struct FGen; }
namespace amc { struct FGenXref; }
namespace amc { struct FGenXrefSeen; }
namespace amc { struct FGstatic; }
namespace amc { struct FGsymbol; }
namespace amc { struct FHook; }
namespace amc { struct FInlary; }
namespace amc { struct FLenfld; }
namespace amc { struct FLlist; }
namespace amc { struct FMain; }
namespace amc { struct FMsgtype; }
namespace amc { struct FNocascdel; }
namespace amc { struct FNossimfile; }
namespace amc { struct FNoxref; }
namespace amc { struct FNscpp; }
namespace amc { struct FNsdb; }
namespace amc { struct FNsinclude; }
namespace amc { struct FNsproto; }
namespace amc { struct FNsx; }
namespace amc { struct FNumstr; }
namespace amc { struct FOutfile; }
namespace amc { struct FPack; }
namespace amc { struct FPmaskfldMember; }
namespace amc { struct FPnew; }
namespace amc { struct FPtrary; }
namespace amc { struct FRowid; }
namespace amc { struct FSmallstr; }
namespace amc { struct FSortfld; }
namespace amc { struct FSsimsort; }
namespace amc { struct FSsimvolatile; }
namespace amc { struct FStatictuple; }
namespace amc { struct FSubstr; }
namespace amc { struct FTargdep; }
namespace amc { struct FTary; }
namespace amc { struct FTcurs; }
namespace amc { struct FThash; }
namespace amc { struct FTracefld; }
namespace amc { struct FTracerec; }
namespace amc { struct FTypefld; }
namespace amc { struct FUsertracefld; }
namespace amc { struct FXref; }
namespace amc { struct FieldId; }
namespace amc { struct Funcarg; }
namespace amc { struct Genpnew; }
namespace amc { struct Pnewtype; }
namespace amc { struct TableId; }
namespace amc { extern struct amc::FDb _db; }
namespace amc { // hook_fcn_typedef
    typedef void (*tclass_step_hook)(); // hook:amc.FTclass.step
    typedef void (*gen_step_hook)(); // hook:amc.FGen.step
    typedef void (*tfunc_step_hook)(); // hook:amc.FTfunc.step
} // hook_decl
namespace amc { // gen:ns_gsymbol
    extern const algo::strptr amcdb_regxtype_; // ""
    extern const algo::strptr amcdb_regxtype_Acr; // "Acr"
    extern const algo::strptr amcdb_regxtype_Shell; // "Shell"
    extern const algo::strptr amcdb_regxtype_Sql; // "Sql"
} // gen:ns_gsymbol
namespace amc { // gen:ns_gsymbol
    extern const algo::strptr dev_gitfile_conf_copyright_txt; // "conf/copyright.txt"
} // gen:ns_gsymbol
namespace amc { // gen:ns_print_struct

// --- amc.BltinId
struct BltinId { // amc.BltinId
    u8   value;   //   0
    // func:amc.BltinId.value.Cast
    inline               operator amc_BltinIdEnum() const __attribute__((nothrow));
    // func:amc.BltinId..Ctor
    inline               BltinId() __attribute__((nothrow));
    // func:amc.BltinId..FieldwiseCtor
    explicit inline               BltinId(u8 in_value) __attribute__((nothrow));
    // func:amc.BltinId..EnumCtor
    inline               BltinId(amc_BltinIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:amc.BltinId.value.GetEnum
inline amc_BltinIdEnum value_GetEnum(const amc::BltinId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:amc.BltinId.value.SetEnum
inline void          value_SetEnum(amc::BltinId& parent, amc_BltinIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:amc.BltinId.value.ToCstr
const char*          value_ToCstr(const amc::BltinId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:amc.BltinId.value.Print
void                 value_Print(const amc::BltinId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:amc.BltinId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(amc::BltinId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:amc.BltinId.value.SetStrptr
void                 value_SetStrptr(amc::BltinId& parent, algo::strptr rhs, amc_BltinIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:amc.BltinId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(amc::BltinId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::BltinId from an ascii string.
// The format of the string is the format of the amc::BltinId's only field
// func:amc.BltinId..ReadStrptrMaybe
bool                 BltinId_ReadStrptrMaybe(amc::BltinId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.BltinId..Init
inline void          BltinId_Init(amc::BltinId& parent);
// print string representation of ROW to string STR
// cfmt:amc.BltinId.String  printfmt:Raw
// func:amc.BltinId..Print
void                 BltinId_Print(amc::BltinId row, algo::cstring& str) __attribute__((nothrow));

// --- amc.CppkeywordId
struct CppkeywordId { // amc.CppkeywordId
    u32   id;   //   0
    // func:amc.CppkeywordId..Ctor
    inline               CppkeywordId() __attribute__((nothrow));
    // func:amc.CppkeywordId..EnumCtor
    inline               CppkeywordId(amc_CppkeywordIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:amc.CppkeywordId.id.GetEnum
inline amc_CppkeywordIdEnum id_GetEnum(const amc::CppkeywordId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:amc.CppkeywordId.id.SetEnum
inline void          id_SetEnum(amc::CppkeywordId& parent, amc_CppkeywordIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:amc.CppkeywordId.id.ToCstr
const char*          id_ToCstr(const amc::CppkeywordId& parent) __attribute__((nothrow));
// Convert id to a string. First, attempt conversion to a known string.
// If no string matches, print id as a numeric value.
// func:amc.CppkeywordId.id.Print
void                 id_Print(const amc::CppkeywordId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:amc.CppkeywordId.id.SetStrptrMaybe
bool                 id_SetStrptrMaybe(amc::CppkeywordId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:amc.CppkeywordId.id.SetStrptr
void                 id_SetStrptr(amc::CppkeywordId& parent, algo::strptr rhs, amc_CppkeywordIdEnum dflt) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.CppkeywordId..Init
inline void          CppkeywordId_Init(amc::CppkeywordId& parent);

// --- amc.Enumstr
struct Enumstr { // amc.Enumstr: Key
    i32               len;   //   0
    algo::RnullStr8   str;   //
    // func:amc.Enumstr..EqOp
    inline bool          operator ==(const amc::Enumstr &rhs) const __attribute__((nothrow));
    // func:amc.Enumstr..NeOp
    inline bool          operator !=(const amc::Enumstr &rhs) const __attribute__((nothrow));
    // func:amc.Enumstr..LtOp
    inline bool          operator <(const amc::Enumstr &rhs) const __attribute__((nothrow));
    // func:amc.Enumstr..GtOp
    inline bool          operator >(const amc::Enumstr &rhs) const __attribute__((nothrow));
    // func:amc.Enumstr..LeOp
    inline bool          operator <=(const amc::Enumstr &rhs) const __attribute__((nothrow));
    // func:amc.Enumstr..GeOp
    inline bool          operator >=(const amc::Enumstr &rhs) const __attribute__((nothrow));
    // func:amc.Enumstr..Ctor
    inline               Enumstr() __attribute__((nothrow));
    // func:amc.Enumstr..FieldwiseCtor
    explicit inline               Enumstr(i32 in_len, const algo::strptr& in_str) __attribute__((nothrow));
};

// Compare two fields. Comparison is anti-symmetric: if a>b, then !(b>a).
// func:amc.Enumstr.str.Lt
inline bool          str_Lt(amc::Enumstr& parent, amc::Enumstr &rhs) __attribute__((nothrow));
// Compare two fields.
// func:amc.Enumstr.str.Cmp
inline i32           str_Cmp(amc::Enumstr& parent, amc::Enumstr &rhs) __attribute__((nothrow));

// func:amc.Enumstr..Hash
inline u32           Enumstr_Hash(u32 prev, const amc::Enumstr& rhs) __attribute__((nothrow));
// func:amc.Enumstr..ReadFieldMaybe
bool                 Enumstr_ReadFieldMaybe(amc::Enumstr& parent, algo::strptr field, algo::strptr strval) __attribute__((nothrow));
// Read fields of amc::Enumstr from an ascii string.
// The format of the string is an ssim Tuple
// func:amc.Enumstr..ReadStrptrMaybe
bool                 Enumstr_ReadStrptrMaybe(amc::Enumstr &parent, algo::strptr in_str) __attribute__((nothrow));
// func:amc.Enumstr..Lt
inline bool          Enumstr_Lt(amc::Enumstr& lhs, amc::Enumstr& rhs) __attribute__((nothrow));
// func:amc.Enumstr..Cmp
inline i32           Enumstr_Cmp(amc::Enumstr& lhs, amc::Enumstr& rhs) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.Enumstr..Init
inline void          Enumstr_Init(amc::Enumstr& parent);
// func:amc.Enumstr..Eq
inline bool          Enumstr_Eq(amc::Enumstr& lhs, amc::Enumstr& rhs) __attribute__((nothrow));
// Set value. Return true if new value is different from old value.
// func:amc.Enumstr..Update
inline bool          Enumstr_Update(amc::Enumstr &lhs, amc::Enumstr& rhs) __attribute__((nothrow));
// print string representation of ROW to string STR
// cfmt:amc.Enumstr.String  printfmt:Tuple
// func:amc.Enumstr..Print
void                 Enumstr_Print(amc::Enumstr& row, algo::cstring& str) __attribute__((nothrow));

// --- amc.FAnonfld
// create: amc.FDb.anonfld (Lary)
// global access: anonfld (Lary, by rowid)
// access: amc.FField.c_anonfld (Ptr)
struct FAnonfld { // amc.FAnonfld
    algo::Smallstr100   field;      //
    i32                 anon_idx;   //   0  Index of anonymous field (if any)
    // func:amc.FAnonfld..AssignOp
    inline amc::FAnonfld& operator =(const amc::FAnonfld &rhs) = delete;
    // func:amc.FAnonfld..CopyCtor
    inline               FAnonfld(const amc::FAnonfld &rhs) = delete;
private:
    // func:amc.FAnonfld..Ctor
    inline               FAnonfld() __attribute__((nothrow));
    // func:amc.FAnonfld..Dtor
    inline               ~FAnonfld() __attribute__((nothrow));
    friend amc::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 anonfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FAnonfld.msghdr.CopyOut
void                 anonfld_CopyOut(amc::FAnonfld &row, dmmeta::Anonfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FAnonfld.msghdr.CopyIn
void                 anonfld_CopyIn(amc::FAnonfld &row, dmmeta::Anonfld &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FAnonfld..Init
inline void          FAnonfld_Init(amc::FAnonfld& anonfld);
// func:amc.FAnonfld..Uninit
void                 FAnonfld_Uninit(amc::FAnonfld& anonfld) __attribute__((nothrow));

// --- amc.FArgvtype
// create: amc.FDb.argvtype (Lary)
// global access: argvtype (Lary, by rowid)
// access: amc.FCtype.c_argvtype (Ptr)
struct FArgvtype { // amc.FArgvtype
    algo::Smallstr100   ctype;      //
    algo::Smallstr50    argvtype;   //
    algo::Comment       comment;    //
    // func:amc.FArgvtype..AssignOp
    inline amc::FArgvtype& operator =(const amc::FArgvtype &rhs) = delete;
    // func:amc.FArgvtype..CopyCtor
    inline               FArgvtype(const amc::FArgvtype &rhs) = delete;
private:
    // func:amc.FArgvtype..Ctor
    inline               FArgvtype() __attribute__((nothrow));
    // func:amc.FArgvtype..Dtor
    inline               ~FArgvtype() __attribute__((nothrow));
    friend amc::FArgvtype&      argvtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FArgvtype*      argvtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 argvtype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FArgvtype.base.CopyOut
void                 argvtype_CopyOut(amc::FArgvtype &row, dmmeta::Argvtype &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FArgvtype.base.CopyIn
void                 argvtype_CopyIn(amc::FArgvtype &row, dmmeta::Argvtype &in) __attribute__((nothrow));

// func:amc.FArgvtype..Uninit
void                 FArgvtype_Uninit(amc::FArgvtype& argvtype) __attribute__((nothrow));

// --- amc.FBasepool
// create: amc.FDb.basepool (Lary)
// global access: basepool (Lary, by rowid)
// access: amc.FField.c_basepool (Ptr)
struct FBasepool { // amc.FBasepool
    algo::Smallstr100   field;     //
    algo::Smallstr100   base;      //
    amc::FField*        p_field;   // reference to parent row
    amc::FField*        p_base;    // reference to parent row
    // x-reference on amc.FBasepool.p_field prevents copy
    // x-reference on amc.FBasepool.p_base prevents copy
    // func:amc.FBasepool..AssignOp
    inline amc::FBasepool& operator =(const amc::FBasepool &rhs) = delete;
    // x-reference on amc.FBasepool.p_field prevents copy
    // x-reference on amc.FBasepool.p_base prevents copy
    // func:amc.FBasepool..CopyCtor
    inline               FBasepool(const amc::FBasepool &rhs) = delete;
private:
    // func:amc.FBasepool..Ctor
    inline               FBasepool() __attribute__((nothrow));
    // func:amc.FBasepool..Dtor
    inline               ~FBasepool() __attribute__((nothrow));
    friend amc::FBasepool&      basepool_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FBasepool*      basepool_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 basepool_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FBasepool.msghdr.CopyOut
void                 basepool_CopyOut(amc::FBasepool &row, dmmeta::Basepool &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FBasepool.msghdr.CopyIn
void                 basepool_CopyIn(amc::FBasepool &row, dmmeta::Basepool &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FBasepool..Init
inline void          FBasepool_Init(amc::FBasepool& basepool);
// func:amc.FBasepool..Uninit
void                 FBasepool_Uninit(amc::FBasepool& basepool) __attribute__((nothrow));

// --- amc.FBitfld
// create: amc.FDb.bitfld (Lary)
// global access: bitfld (Lary, by rowid)
// access: amc.FField.c_bitfld (Ptr)
// access: amc.FField.bh_bitfld (Bheap)
struct FBitfld { // amc.FBitfld
    algo::Smallstr100   field;           //
    i32                 offset;          //   0  Offset, in bits, within parent field
    i32                 width;           //   0  Width, in bits, within parent field.
    algo::Smallstr100   srcfield;        //
    amc::FField*        p_srcfield;      // reference to parent row
    amc::FField*        p_field;         // reference to parent row
    i32                 bh_bitfld_idx;   // index in heap; -1 means not-in-heap
    // x-reference on amc.FBitfld.p_srcfield prevents copy
    // x-reference on amc.FBitfld.p_field prevents copy
    // func:amc.FBitfld..AssignOp
    inline amc::FBitfld& operator =(const amc::FBitfld &rhs) = delete;
    // x-reference on amc.FBitfld.p_srcfield prevents copy
    // x-reference on amc.FBitfld.p_field prevents copy
    // func:amc.FBitfld..CopyCtor
    inline               FBitfld(const amc::FBitfld &rhs) = delete;
private:
    // func:amc.FBitfld..Ctor
    inline               FBitfld() __attribute__((nothrow));
    // func:amc.FBitfld..Dtor
    inline               ~FBitfld() __attribute__((nothrow));
    friend amc::FBitfld&        bitfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FBitfld*        bitfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 bitfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FBitfld.msghdr.CopyOut
void                 bitfld_CopyOut(amc::FBitfld &row, dmmeta::Bitfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FBitfld.msghdr.CopyIn
void                 bitfld_CopyIn(amc::FBitfld &row, dmmeta::Bitfld &in) __attribute__((nothrow));

// func:amc.FBitfld.name.Get
algo::Smallstr50     name_Get(amc::FBitfld& bitfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FBitfld..Init
inline void          FBitfld_Init(amc::FBitfld& bitfld);
// func:amc.FBitfld..Uninit
void                 FBitfld_Uninit(amc::FBitfld& bitfld) __attribute__((nothrow));

// --- amc.FBltin
// create: amc.FDb.bltin (Lary)
// global access: bltin (Lary, by rowid)
// global access: ind_bltin (Thash, hash field ctype)
// access: amc.FCtype.c_bltin (Ptr)
struct FBltin { // amc.FBltin
    algo::Smallstr100   ctype;            //
    bool                likeu64;          //   false
    bool                bigendok;         //   false
    bool                issigned;         //   false
    amc::FBltin*        ind_bltin_next;   // hash next
    // func:amc.FBltin..AssignOp
    inline amc::FBltin&  operator =(const amc::FBltin &rhs) = delete;
    // func:amc.FBltin..CopyCtor
    inline               FBltin(const amc::FBltin &rhs) = delete;
private:
    // func:amc.FBltin..Ctor
    inline               FBltin() __attribute__((nothrow));
    // func:amc.FBltin..Dtor
    inline               ~FBltin() __attribute__((nothrow));
    friend amc::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 bltin_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FBltin.msghdr.CopyOut
void                 bltin_CopyOut(amc::FBltin &row, amcdb::Bltin &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FBltin.msghdr.CopyIn
void                 bltin_CopyIn(amc::FBltin &row, amcdb::Bltin &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FBltin..Init
inline void          FBltin_Init(amc::FBltin& bltin);
// func:amc.FBltin..Uninit
void                 FBltin_Uninit(amc::FBltin& bltin) __attribute__((nothrow));

// --- amc.FCafter
// create: amc.FDb.cafter (Lary)
// global access: cafter (Lary, by rowid)
// access: amc.FCtype.zd_cafter (Llist)
struct FCafter { // amc.FCafter
    algo::Smallstr50   cafter;           //
    amc::FCtype*       p_after;          // reference to parent row
    amc::FCafter*      zd_cafter_next;   // zslist link; -1 means not-in-list
    amc::FCafter*      zd_cafter_prev;   // previous element
    // x-reference on amc.FCafter.p_after prevents copy
    // func:amc.FCafter..AssignOp
    inline amc::FCafter& operator =(const amc::FCafter &rhs) = delete;
    // x-reference on amc.FCafter.p_after prevents copy
    // func:amc.FCafter..CopyCtor
    inline               FCafter(const amc::FCafter &rhs) = delete;
private:
    // func:amc.FCafter..Ctor
    inline               FCafter() __attribute__((nothrow));
    // func:amc.FCafter..Dtor
    inline               ~FCafter() __attribute__((nothrow));
    friend amc::FCafter&        cafter_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCafter*        cafter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cafter_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCafter.msghdr.CopyOut
void                 cafter_CopyOut(amc::FCafter &row, dmmeta::Cafter &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCafter.msghdr.CopyIn
void                 cafter_CopyIn(amc::FCafter &row, dmmeta::Cafter &in) __attribute__((nothrow));

// func:amc.FCafter.ctype.Get
algo::Smallstr100    ctype_Get(amc::FCafter& cafter) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FCafter.after.Get
algo::Smallstr100    after_Get(amc::FCafter& cafter) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FCafter..Init
inline void          FCafter_Init(amc::FCafter& cafter);
// func:amc.FCafter..Uninit
void                 FCafter_Uninit(amc::FCafter& cafter) __attribute__((nothrow));

// --- amc.FCascdel
// create: amc.FDb.cascdel (Lary)
// global access: cascdel (Lary, by rowid)
// access: amc.FField.c_cascdel (Ptr)
struct FCascdel { // amc.FCascdel
    algo::Smallstr100   field;     //
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FCascdel.p_field prevents copy
    // func:amc.FCascdel..AssignOp
    inline amc::FCascdel& operator =(const amc::FCascdel &rhs) = delete;
    // x-reference on amc.FCascdel.p_field prevents copy
    // func:amc.FCascdel..CopyCtor
    inline               FCascdel(const amc::FCascdel &rhs) = delete;
private:
    // func:amc.FCascdel..Ctor
    inline               FCascdel() __attribute__((nothrow));
    // func:amc.FCascdel..Dtor
    inline               ~FCascdel() __attribute__((nothrow));
    friend amc::FCascdel&       cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCascdel*       cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cascdel_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCascdel.msghdr.CopyOut
void                 cascdel_CopyOut(amc::FCascdel &row, dmmeta::Cascdel &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCascdel.msghdr.CopyIn
void                 cascdel_CopyIn(amc::FCascdel &row, dmmeta::Cascdel &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCascdel..Init
inline void          FCascdel_Init(amc::FCascdel& cascdel);
// func:amc.FCascdel..Uninit
void                 FCascdel_Uninit(amc::FCascdel& cascdel) __attribute__((nothrow));

// --- amc.FCcmp
// create: amc.FDb.ccmp (Lary)
// global access: ccmp (Lary, by rowid)
// global access: ind_ccmp (Thash, hash field ctype)
// access: amc.FCtype.c_ccmp (Ptr)
struct FCcmp { // amc.FCcmp
    algo::Smallstr100   ctype;           // Target ctype
    bool                extrn;           //   false  Whether implementation is external
    bool                genop;           //   false  Generate C++ comparison operators (<,>, etc)
    bool                order;           //   false
    bool                minmax;          //   false
    amc::FCcmp*         ind_ccmp_next;   // hash next
    // func:amc.FCcmp..AssignOp
    inline amc::FCcmp&   operator =(const amc::FCcmp &rhs) = delete;
    // func:amc.FCcmp..CopyCtor
    inline               FCcmp(const amc::FCcmp &rhs) = delete;
private:
    // func:amc.FCcmp..Ctor
    inline               FCcmp() __attribute__((nothrow));
    // func:amc.FCcmp..Dtor
    inline               ~FCcmp() __attribute__((nothrow));
    friend amc::FCcmp&          ccmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCcmp*          ccmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ccmp_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCcmp.msghdr.CopyOut
void                 ccmp_CopyOut(amc::FCcmp &row, dmmeta::Ccmp &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCcmp.msghdr.CopyIn
void                 ccmp_CopyIn(amc::FCcmp &row, dmmeta::Ccmp &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCcmp..Init
inline void          FCcmp_Init(amc::FCcmp& ccmp);
// func:amc.FCcmp..Uninit
void                 FCcmp_Uninit(amc::FCcmp& ccmp) __attribute__((nothrow));

// --- amc.FCdflt
// create: amc.FDb.cdflt (Lary)
// global access: cdflt (Lary, by rowid)
// access: amc.FCtype.c_cdflt (Ptr)
struct FCdflt { // amc.FCdflt
    algo::Smallstr100   ctype;      //
    algo::CppExpr       dflt;       //
    algo::CppExpr       cppdflt;    //
    algo::Smallstr50    ssimdflt;   //
    algo::Smallstr50    jsdflt;     //
    algo::Comment       comment;    //
    // func:amc.FCdflt..AssignOp
    inline amc::FCdflt&  operator =(const amc::FCdflt &rhs) = delete;
    // func:amc.FCdflt..CopyCtor
    inline               FCdflt(const amc::FCdflt &rhs) = delete;
private:
    // func:amc.FCdflt..Ctor
    inline               FCdflt() __attribute__((nothrow));
    // func:amc.FCdflt..Dtor
    inline               ~FCdflt() __attribute__((nothrow));
    friend amc::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cdflt_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCdflt.base.CopyOut
void                 cdflt_CopyOut(amc::FCdflt &row, dmmeta::Cdflt &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCdflt.base.CopyIn
void                 cdflt_CopyIn(amc::FCdflt &row, dmmeta::Cdflt &in) __attribute__((nothrow));

// func:amc.FCdflt..Uninit
void                 FCdflt_Uninit(amc::FCdflt& cdflt) __attribute__((nothrow));

// --- amc.FCextern
// create: amc.FDb.cextern (Lary)
// global access: cextern (Lary, by rowid)
// access: amc.FCtype.c_cextern (Ptr)
struct FCextern { // amc.FCextern
    algo::Smallstr100   ctype;        // Ctype in question
    bool                initmemset;   //   false  Initialize using memset? (set this to Y for all C structs)
    bool                isstruct;     //   false
    bool                plaindata;    //   false
    // func:amc.FCextern..AssignOp
    inline amc::FCextern& operator =(const amc::FCextern &rhs) = delete;
    // func:amc.FCextern..CopyCtor
    inline               FCextern(const amc::FCextern &rhs) = delete;
private:
    // func:amc.FCextern..Ctor
    inline               FCextern() __attribute__((nothrow));
    // func:amc.FCextern..Dtor
    inline               ~FCextern() __attribute__((nothrow));
    friend amc::FCextern&       cextern_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCextern*       cextern_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cextern_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCextern.msghdr.CopyOut
void                 cextern_CopyOut(amc::FCextern &row, dmmeta::Cextern &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCextern.msghdr.CopyIn
void                 cextern_CopyIn(amc::FCextern &row, dmmeta::Cextern &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCextern..Init
inline void          FCextern_Init(amc::FCextern& cextern);
// func:amc.FCextern..Uninit
void                 FCextern_Uninit(amc::FCextern& cextern) __attribute__((nothrow));

// --- amc.FCfast
// create: amc.FDb.cfast (Lary)
// global access: cfast (Lary, by rowid)
// access: amc.FCtype.c_cfast (Ptr)
struct FCfast { // amc.FCfast
    algo::Smallstr100   ctype;      //
    u32                 id;         //   0
    algo::Smallstr50    encoding;   //
    bool                reset;      //   false
    algo::Comment       comment;    //
    // func:amc.FCfast..AssignOp
    inline amc::FCfast&  operator =(const amc::FCfast &rhs) = delete;
    // func:amc.FCfast..CopyCtor
    inline               FCfast(const amc::FCfast &rhs) = delete;
private:
    // func:amc.FCfast..Ctor
    inline               FCfast() __attribute__((nothrow));
    // func:amc.FCfast..Dtor
    inline               ~FCfast() __attribute__((nothrow));
    friend amc::FCfast&         cfast_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCfast*         cfast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfast_RemoveAll() __attribute__((nothrow));
    friend void                 cfast_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCfast.base.CopyOut
void                 cfast_CopyOut(amc::FCfast &row, dmmeta::Cfast &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCfast.base.CopyIn
void                 cfast_CopyIn(amc::FCfast &row, dmmeta::Cfast &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCfast..Init
inline void          FCfast_Init(amc::FCfast& cfast);
// func:amc.FCfast..Uninit
void                 FCfast_Uninit(amc::FCfast& cfast) __attribute__((nothrow));

// --- amc.FCfmt
// create: amc.FDb.cfmt (Lary)
// global access: ind_cfmt (Thash, hash field cfmt)
// global access: cfmt (Lary, by rowid)
// access: amc.FCtype.zs_cfmt (Llist)
struct FCfmt { // amc.FCfmt
    algo::Smallstr100   cfmt;            //
    algo::Smallstr50    printfmt;        //
    bool                read;            //   false
    bool                print;           //   false
    algo::Smallstr20    sep;             //
    bool                genop;           //   false
    amc::FCfmt*         zs_cfmt_next;    // zslist link; -1 means not-in-list
    amc::FCfmt*         ind_cfmt_next;   // hash next
    // func:amc.FCfmt..AssignOp
    inline amc::FCfmt&   operator =(const amc::FCfmt &rhs) = delete;
    // func:amc.FCfmt..CopyCtor
    inline               FCfmt(const amc::FCfmt &rhs) = delete;
private:
    // func:amc.FCfmt..Ctor
    inline               FCfmt() __attribute__((nothrow));
    // func:amc.FCfmt..Dtor
    inline               ~FCfmt() __attribute__((nothrow));
    friend amc::FCfmt&          cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCfmt*          cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cfmt_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCfmt.msghdr.CopyOut
void                 cfmt_CopyOut(amc::FCfmt &row, dmmeta::Cfmt &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCfmt.msghdr.CopyIn
void                 cfmt_CopyIn(amc::FCfmt &row, dmmeta::Cfmt &in) __attribute__((nothrow));

// func:amc.FCfmt.ctype.Get
algo::Smallstr100    ctype_Get(amc::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FCfmt.strfmt.Get
algo::Smallstr50     strfmt_Get(amc::FCfmt& cfmt) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FCfmt..Init
inline void          FCfmt_Init(amc::FCfmt& cfmt);
// func:amc.FCfmt..Uninit
void                 FCfmt_Uninit(amc::FCfmt& cfmt) __attribute__((nothrow));

// --- amc.FCget
// create: amc.FDb.cget (Lary)
// global access: cget (Lary, by rowid)
struct FCget { // amc.FCget
    algo::Smallstr100   ctype;     //
    algo::Comment       comment;   //
    amc::FCtype*        p_ctype;   // reference to parent row
private:
    // func:amc.FCget..Ctor
    inline               FCget() __attribute__((nothrow));
    friend amc::FCget&          cget_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCget*          cget_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cget_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCget.base.CopyOut
void                 cget_CopyOut(amc::FCget &row, dmmeta::Cget &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCget.base.CopyIn
void                 cget_CopyIn(amc::FCget &row, dmmeta::Cget &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCget..Init
inline void          FCget_Init(amc::FCget& cget);

// --- amc.FCharset
// create: amc.FDb.charset (Lary)
// global access: charset (Lary, by rowid)
// access: amc.FField.c_charset (Ptr)
struct FCharset { // amc.FCharset
    algo::Smallstr100   field;       //
    algo::Smallstr100   expr;        //
    bool                charrange;   //   false
    bool                calc;        //   false
    algo::Comment       comment;     //
    algo::Charset       chars;       //
    // func:amc.FCharset..AssignOp
    inline amc::FCharset& operator =(const amc::FCharset &rhs) = delete;
    // func:amc.FCharset..CopyCtor
    inline               FCharset(const amc::FCharset &rhs) = delete;
private:
    // func:amc.FCharset..Ctor
    inline               FCharset() __attribute__((nothrow));
    // func:amc.FCharset..Dtor
    inline               ~FCharset() __attribute__((nothrow));
    friend amc::FCharset&       charset_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCharset*       charset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 charset_RemoveAll() __attribute__((nothrow));
    friend void                 charset_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCharset.base.CopyOut
void                 charset_CopyOut(amc::FCharset &row, dmmeta::Charset &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCharset.base.CopyIn
void                 charset_CopyIn(amc::FCharset &row, dmmeta::Charset &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCharset..Init
inline void          FCharset_Init(amc::FCharset& charset);
// func:amc.FCharset..Uninit
void                 FCharset_Uninit(amc::FCharset& charset) __attribute__((nothrow));

// --- amc.FChash
// create: amc.FDb.chash (Lary)
// global access: chash (Lary, by rowid)
// global access: ind_chash (Thash, hash field ctype)
// access: amc.FCtype.c_chash (Ptr)
struct FChash { // amc.FChash
    algo::Smallstr100   ctype;            // Target ctype
    algo::Smallstr50    hashtype;         // Hash type
    amc::FChash*        ind_chash_next;   // hash next
    // func:amc.FChash..AssignOp
    inline amc::FChash&  operator =(const amc::FChash &rhs) = delete;
    // func:amc.FChash..CopyCtor
    inline               FChash(const amc::FChash &rhs) = delete;
private:
    // func:amc.FChash..Ctor
    inline               FChash() __attribute__((nothrow));
    // func:amc.FChash..Dtor
    inline               ~FChash() __attribute__((nothrow));
    friend amc::FChash&         chash_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FChash*         chash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 chash_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FChash.msghdr.CopyOut
void                 chash_CopyOut(amc::FChash &row, dmmeta::Chash &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FChash.msghdr.CopyIn
void                 chash_CopyIn(amc::FChash &row, dmmeta::Chash &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FChash..Init
inline void          FChash_Init(amc::FChash& chash);
// func:amc.FChash..Uninit
void                 FChash_Uninit(amc::FChash& chash) __attribute__((nothrow));

// --- amc.FCppfunc
// create: amc.FDb.cppfunc (Lary)
// global access: cppfunc (Lary, by rowid)
// access: amc.FField.c_cppfunc (Ptr)
struct FCppfunc { // amc.FCppfunc
    algo::Smallstr100   field;   //
    algo::CppExpr       expr;    //
    bool                print;   //   false
    bool                set;     //   false
    // func:amc.FCppfunc..AssignOp
    inline amc::FCppfunc& operator =(const amc::FCppfunc &rhs) = delete;
    // func:amc.FCppfunc..CopyCtor
    inline               FCppfunc(const amc::FCppfunc &rhs) = delete;
private:
    // func:amc.FCppfunc..Ctor
    inline               FCppfunc() __attribute__((nothrow));
    // func:amc.FCppfunc..Dtor
    inline               ~FCppfunc() __attribute__((nothrow));
    friend amc::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cppfunc_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCppfunc.msghdr.CopyOut
void                 cppfunc_CopyOut(amc::FCppfunc &row, dmmeta::Cppfunc &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCppfunc.msghdr.CopyIn
void                 cppfunc_CopyIn(amc::FCppfunc &row, dmmeta::Cppfunc &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCppfunc..Init
inline void          FCppfunc_Init(amc::FCppfunc& cppfunc);
// func:amc.FCppfunc..Uninit
void                 FCppfunc_Uninit(amc::FCppfunc& cppfunc) __attribute__((nothrow));

// --- amc.FCpptype
// create: amc.FDb.cpptype (Lary)
// global access: cpptype (Lary, by rowid)
// global access: ind_cpptype (Thash, hash field ctype)
// access: amc.FCtype.c_cpptype (Ptr)
struct FCpptype { // amc.FCpptype
    algo::Smallstr100   ctype;              //
    bool                ctor;               //   false  if true, generate non-default constructor from all fields
    bool                dtor;               //   true  generate non-default destructor
    bool                cheap_copy;         //   false  Pass by value whenever possible
    amc::FCtype*        p_ctype;            // reference to parent row
    amc::FCpptype*      ind_cpptype_next;   // hash next
    // x-reference on amc.FCpptype.p_ctype prevents copy
    // func:amc.FCpptype..AssignOp
    inline amc::FCpptype& operator =(const amc::FCpptype &rhs) = delete;
    // x-reference on amc.FCpptype.p_ctype prevents copy
    // func:amc.FCpptype..CopyCtor
    inline               FCpptype(const amc::FCpptype &rhs) = delete;
private:
    // func:amc.FCpptype..Ctor
    inline               FCpptype() __attribute__((nothrow));
    // func:amc.FCpptype..Dtor
    inline               ~FCpptype() __attribute__((nothrow));
    friend amc::FCpptype&       cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCpptype*       cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cpptype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCpptype.msghdr.CopyOut
void                 cpptype_CopyOut(amc::FCpptype &row, dmmeta::Cpptype &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCpptype.msghdr.CopyIn
void                 cpptype_CopyIn(amc::FCpptype &row, dmmeta::Cpptype &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCpptype..Init
inline void          FCpptype_Init(amc::FCpptype& cpptype);
// func:amc.FCpptype..Uninit
void                 FCpptype_Uninit(amc::FCpptype& cpptype) __attribute__((nothrow));

// --- amc.FCsize
// create: amc.FDb.csize (Lary)
// global access: csize (Lary, by rowid)
// access: amc.FCtype.c_csize (Ptr)
struct FCsize { // amc.FCsize
    algo::Smallstr100   ctype;       //
    u32                 size;        //   0
    u32                 alignment;   //   1
    // func:amc.FCsize..AssignOp
    inline amc::FCsize&  operator =(const amc::FCsize &rhs) = delete;
    // func:amc.FCsize..CopyCtor
    inline               FCsize(const amc::FCsize &rhs) = delete;
private:
    // func:amc.FCsize..Ctor
    inline               FCsize() __attribute__((nothrow));
    // func:amc.FCsize..Dtor
    inline               ~FCsize() __attribute__((nothrow));
    friend amc::FCsize&         csize_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCsize*         csize_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 csize_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCsize.msghdr.CopyOut
void                 csize_CopyOut(amc::FCsize &row, dmmeta::Csize &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCsize.msghdr.CopyIn
void                 csize_CopyIn(amc::FCsize &row, dmmeta::Csize &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCsize..Init
inline void          FCsize_Init(amc::FCsize& csize);
// func:amc.FCsize..Uninit
void                 FCsize_Uninit(amc::FCsize& csize) __attribute__((nothrow));

// --- amc.FCstr
// create: amc.FDb.cstr (Lary)
// global access: cstr (Lary, by rowid)
// access: amc.FCtype.c_cstr (Ptr)
struct FCstr { // amc.FCstr
    algo::Smallstr100   ctype;      //
    bool                strequiv;   //   false  Use strptr instead of this type when possible
    // func:amc.FCstr..AssignOp
    inline amc::FCstr&   operator =(const amc::FCstr &rhs) = delete;
    // func:amc.FCstr..CopyCtor
    inline               FCstr(const amc::FCstr &rhs) = delete;
private:
    // func:amc.FCstr..Ctor
    inline               FCstr() __attribute__((nothrow));
    // func:amc.FCstr..Dtor
    inline               ~FCstr() __attribute__((nothrow));
    friend amc::FCstr&          cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCstr*          cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 cstr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCstr.msghdr.CopyOut
void                 cstr_CopyOut(amc::FCstr &row, dmmeta::Cstr &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCstr.msghdr.CopyIn
void                 cstr_CopyIn(amc::FCstr &row, dmmeta::Cstr &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCstr..Init
inline void          FCstr_Init(amc::FCstr& cstr);
// func:amc.FCstr..Uninit
void                 FCstr_Uninit(amc::FCstr& cstr) __attribute__((nothrow));

// --- amc.FCtype
// create: amc.FDb.ctype (Lary)
// global access: ctype (Lary, by rowid)
// global access: ind_ctype (Thash, hash field ctype)
// global access: c_ctype_sorted (Ptrary)
// global access: zsl_ctype_pack_tran (Llist)
// global access: zs_sig_visit (Llist)
// global access: c_u64 (Ptr)
// access: amc.FCafter.p_after (Upptr)
// access: amc.FCget.p_ctype (Upptr)
// access: amc.FCpptype.p_ctype (Upptr)
// access: amc.FCtype.c_parent (Ptrary)
// access: amc.FDispatch.p_ctype_hdr (Upptr)
// access: amc.FDispatch.p_casetype (Upptr)
// access: amc.FDispatchmsg.p_ctype (Upptr)
// access: amc.FDispctx.p_ctype (Upptr)
// access: amc.FField.p_ctype (Upptr)
// access: amc.FField.p_arg (Upptr)
// access: amc.FGsymbol.p_symboltype (Upptr)
// access: amc.FHook.p_funcptr (Upptr)
// access: amc.FMsgtype.p_ctype (Upptr)
// access: amc.FNs.c_ctype (Ptrary)
// access: amc.FNumstr.p_numtype (Upptr)
// access: amc.FPack.p_ctype (Upptr)
// access: amc.FPnew.p_ctype (Upptr)
// access: amc.FSsimfile.p_ctype (Upptr)
// access: amc.FTypefld.p_ctype (Upptr)
// access: amc.FXref.p_ctype (Upptr)
// access: amc.Genctx.p_ctype (Upptr)
// access: amc.Genpnew.p_ctype (Upptr)
struct FCtype { // amc.FCtype
    algo::Smallstr100     ctype;                      // Identifier. must be ns.typename
    algo::Comment         comment;                    //
    amc::FCfmt*           zs_cfmt_head;               // zero-terminated singly linked list
    amc::FCfmt*           zs_cfmt_tail;               // pointer to last element
    algo::cstring         cpp_type;                   // type name to use in c++
    algo::cstring         body;                       // Struct contents
    algo::cstring         sizecheck;                  // Size check assertions
    amc::FFunc*           c_init;                     // Pointer to constructor. optional pointer
    amc::FNs*             p_ns;                       // reference to parent row
    amc::FBltin*          c_bltin;                    // optional pointer
    amc::FField**         c_field_elems;              // array of pointers
    u32                   c_field_n;                  // array of pointers
    u32                   c_field_max;                // capacity of allocated array
    amc::FMsgtype*        c_msgtype;                  // optional pointer
    amc::FField*          c_varlenfld;                // optional pointer
    amc::FField*          c_optfld;                   // optional pointer
    amc::FStatictuple**   c_static_elems;             // array of pointers
    u32                   c_static_n;                 // array of pointers
    u32                   c_static_max;               // capacity of allocated array
    amc::FCpptype*        c_cpptype;                  // optional pointer
    amc::FCtype**         c_parent_elems;             // array of pointers
    u32                   c_parent_n;                 // array of pointers
    u32                   c_parent_max;               // capacity of allocated array
    amc::FSsimfile*       c_ssimfile;                 // Ssimfile associated with this ctype. optional pointer
    amc::FPack*           c_pack;                     // optional pointer
    amc::FLenfld*         c_lenfld;                   // optional pointer
    amc::FPmaskfld**      c_pmaskfld_elems;           // array of pointers
    u32                   c_pmaskfld_n;               // array of pointers
    u32                   c_pmaskfld_max;             // capacity of allocated array
    amc::FTypefld*        c_typefld;                  // optional pointer
    amc::FField**         c_datafld_elems;            // array of pointers
    u32                   c_datafld_n;                // array of pointers
    u32                   c_datafld_max;              // capacity of allocated array
    amc::FField*          zd_inst_head;               // zero-terminated doubly linked list
    i32                   zd_inst_n;                  // zero-terminated doubly linked list
    amc::FField*          zd_inst_tail;               // pointer to last element
    amc::FXref*           zs_xref_head;               // zero-terminated singly linked list
    i32                   zs_xref_n;                  // zero-terminated singly linked list
    amc::FXref*           zs_xref_tail;               // pointer to last element
    amc::FChash*          c_chash;                    // optional pointer
    amc::FCcmp*           c_ccmp;                     // optional pointer
    amc::FCstr*           c_cstr;                     // optional pointer
    amc::FCextern*        c_cextern;                  // optional pointer
    algo::Sha1sig         signature;                  //
    amc::FFunc**          c_ffunc_elems;              // array of pointers
    u32                   c_ffunc_n;                  // array of pointers
    u32                   c_ffunc_max;                // capacity of allocated array
    amc::FCafter*         zd_cafter_head;             // zero-terminated doubly linked list
    i32                   zd_cafter_n;                // zero-terminated doubly linked list
    amc::FCafter*         zd_cafter_tail;             // pointer to last element
    amc::FCsize*          c_csize;                    // optional pointer
    amc::FField*          zd_access_head;             // zero-terminated doubly linked list
    i32                   zd_access_n;                // zero-terminated doubly linked list
    amc::FField*          zd_access_tail;             // pointer to last element
    amc::FCdflt*          c_cdflt;                    // optional pointer
    amc::FArgvtype*       c_argvtype;                 // optional pointer
    amc::FFloadtuples*    c_floadtuples;              // optional pointer
    amc::FField*          c_pkeyfield;                // Field corresponding to pkey of this type. optional pointer
    amc::FFcurs**         c_fcurs_elems;              // array of pointers
    u32                   c_fcurs_n;                  // array of pointers
    u32                   c_fcurs_max;                // capacity of allocated array
    algo::cstring         copy_priv_reason;           //
    amc::FCtypelen*       c_ctypelen;                 // optional pointer
    bool                  copy_priv_valid;            //   false
    bool                  size_unknown;               //   false
    bool                  size_locked;                //   false
    bool                  topo_visited;               //   false  Temporary
    bool                  enum_visited;               //   false  Temporary
    bool                  copy_priv;                  //   false  disallow copy ctor / assign op
    bool                  fields_cloned;              //   false  True if fields from c_cbase have been cloned.
    bool                  original;                   //   false  True if this ctype comes from disk
    bool                  plaindata;                  //   false
    u32                   alignment;                  //   1
    i32                   n_padbytes;                 //   0
    u32                   totsize_byte;               //   0  Total size in bytes of all fields
    i32                   n_xref;                     //   0
    i32                   next_anon_idx;              //   0  sequence to enumerate positional fields
    amc::FNossimfile*     c_nossimfile;               // optional pointer
    i32                   topo_idx;                   //   0  Index of ctype in array c_ctype (after topological sort)
    amc::FCfast*          c_cfast;                    // optional pointer
    amc::FFfast**         c_ffast_elems;              // array of pointers
    u32                   c_ffast_n;                  // array of pointers
    u32                   c_ffast_max;                // capacity of allocated array
    bool                  ns_c_ctype_in_ary;          //   false  membership flag
    amc::FCtype*          ind_ctype_next;             // hash next
    amc::FCtype*          zsl_ctype_pack_tran_next;   // zslist link; -1 means not-in-list
    amc::FCtype*          zs_sig_visit_next;          // zslist link; -1 means not-in-list
    // reftype Llist of amc.FCtype.zs_cfmt prohibits copy
    // x-reference on amc.FCtype.p_ns prevents copy
    // x-reference on amc.FCtype.c_bltin prevents copy
    // reftype Ptrary of amc.FCtype.c_field prohibits copy
    // x-reference on amc.FCtype.c_msgtype prevents copy
    // x-reference on amc.FCtype.c_varlenfld prevents copy
    // x-reference on amc.FCtype.c_optfld prevents copy
    // reftype Ptrary of amc.FCtype.c_static prohibits copy
    // x-reference on amc.FCtype.c_cpptype prevents copy
    // reftype Ptrary of amc.FCtype.c_parent prohibits copy
    // x-reference on amc.FCtype.c_ssimfile prevents copy
    // x-reference on amc.FCtype.c_pack prevents copy
    // x-reference on amc.FCtype.c_lenfld prevents copy
    // reftype Ptrary of amc.FCtype.c_pmaskfld prohibits copy
    // x-reference on amc.FCtype.c_typefld prevents copy
    // reftype Ptrary of amc.FCtype.c_datafld prohibits copy
    // reftype Llist of amc.FCtype.zd_inst prohibits copy
    // reftype Llist of amc.FCtype.zs_xref prohibits copy
    // x-reference on amc.FCtype.c_chash prevents copy
    // x-reference on amc.FCtype.c_ccmp prevents copy
    // x-reference on amc.FCtype.c_cstr prevents copy
    // x-reference on amc.FCtype.c_cextern prevents copy
    // reftype Ptrary of amc.FCtype.c_ffunc prohibits copy
    // reftype Llist of amc.FCtype.zd_cafter prohibits copy
    // x-reference on amc.FCtype.c_csize prevents copy
    // reftype Llist of amc.FCtype.zd_access prohibits copy
    // x-reference on amc.FCtype.c_cdflt prevents copy
    // x-reference on amc.FCtype.c_argvtype prevents copy
    // x-reference on amc.FCtype.c_floadtuples prevents copy
    // reftype Ptrary of amc.FCtype.c_fcurs prohibits copy
    // x-reference on amc.FCtype.c_ctypelen prevents copy
    // x-reference on amc.FCtype.c_nossimfile prevents copy
    // x-reference on amc.FCtype.c_cfast prevents copy
    // reftype Ptrary of amc.FCtype.c_ffast prohibits copy
    // func:amc.FCtype..AssignOp
    amc::FCtype&         operator =(const amc::FCtype &rhs) = delete;
    // reftype Llist of amc.FCtype.zs_cfmt prohibits copy
    // x-reference on amc.FCtype.p_ns prevents copy
    // x-reference on amc.FCtype.c_bltin prevents copy
    // reftype Ptrary of amc.FCtype.c_field prohibits copy
    // x-reference on amc.FCtype.c_msgtype prevents copy
    // x-reference on amc.FCtype.c_varlenfld prevents copy
    // x-reference on amc.FCtype.c_optfld prevents copy
    // reftype Ptrary of amc.FCtype.c_static prohibits copy
    // x-reference on amc.FCtype.c_cpptype prevents copy
    // reftype Ptrary of amc.FCtype.c_parent prohibits copy
    // x-reference on amc.FCtype.c_ssimfile prevents copy
    // x-reference on amc.FCtype.c_pack prevents copy
    // x-reference on amc.FCtype.c_lenfld prevents copy
    // reftype Ptrary of amc.FCtype.c_pmaskfld prohibits copy
    // x-reference on amc.FCtype.c_typefld prevents copy
    // reftype Ptrary of amc.FCtype.c_datafld prohibits copy
    // reftype Llist of amc.FCtype.zd_inst prohibits copy
    // reftype Llist of amc.FCtype.zs_xref prohibits copy
    // x-reference on amc.FCtype.c_chash prevents copy
    // x-reference on amc.FCtype.c_ccmp prevents copy
    // x-reference on amc.FCtype.c_cstr prevents copy
    // x-reference on amc.FCtype.c_cextern prevents copy
    // reftype Ptrary of amc.FCtype.c_ffunc prohibits copy
    // reftype Llist of amc.FCtype.zd_cafter prohibits copy
    // x-reference on amc.FCtype.c_csize prevents copy
    // reftype Llist of amc.FCtype.zd_access prohibits copy
    // x-reference on amc.FCtype.c_cdflt prevents copy
    // x-reference on amc.FCtype.c_argvtype prevents copy
    // x-reference on amc.FCtype.c_floadtuples prevents copy
    // reftype Ptrary of amc.FCtype.c_fcurs prohibits copy
    // x-reference on amc.FCtype.c_ctypelen prevents copy
    // x-reference on amc.FCtype.c_nossimfile prevents copy
    // x-reference on amc.FCtype.c_cfast prevents copy
    // reftype Ptrary of amc.FCtype.c_ffast prohibits copy
    // func:amc.FCtype..CopyCtor
    FCtype(const amc::FCtype &rhs) = delete;
private:
    // func:amc.FCtype..Ctor
    inline               FCtype() __attribute__((nothrow));
    // func:amc.FCtype..Dtor
    inline               ~FCtype() __attribute__((nothrow));
    friend amc::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCtype.msghdr.CopyOut
void                 ctype_CopyOut(amc::FCtype &row, dmmeta::Ctype &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCtype.msghdr.CopyIn
void                 ctype_CopyIn(amc::FCtype &row, dmmeta::Ctype &in) __attribute__((nothrow));

// func:amc.FCtype.ns.Get
algo::Smallstr16     ns_Get(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FCtype.name.Get
algo::Smallstr100    name_Get(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:amc.FCtype.zs_cfmt.EmptyQ
inline bool          zs_cfmt_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FCtype.zs_cfmt.First
inline amc::FCfmt*   zs_cfmt_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FCtype.zs_cfmt.InLlistQ
inline bool          zs_cfmt_InLlistQ(amc::FCfmt& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FCtype.zs_cfmt.Insert
void                 zs_cfmt_Insert(amc::FCtype& ctype, amc::FCfmt& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FCtype.zs_cfmt.Last
inline amc::FCfmt*   zs_cfmt_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FCtype.zs_cfmt.Next
inline amc::FCfmt*   zs_cfmt_Next(amc::FCfmt &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FCtype.zs_cfmt.Remove
void                 zs_cfmt_Remove(amc::FCtype& ctype, amc::FCfmt& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.zs_cfmt.RemoveAll
void                 zs_cfmt_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FCtype.zs_cfmt.RemoveFirst
amc::FCfmt*          zs_cfmt_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FCtype.zs_cfmt.qLast
inline amc::FCfmt&   zs_cfmt_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_bltin.InsertMaybe
inline bool          c_bltin_InsertMaybe(amc::FCtype& ctype, amc::FBltin& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_bltin.Remove
inline void          c_bltin_Remove(amc::FCtype& ctype, amc::FBltin& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_field.EmptyQ
inline bool          c_field_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_field.Find
inline amc::FField*  c_field_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_field.Getary
inline algo::aryptr<amc::FField*> c_field_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_field.Insert
void                 c_field_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_field.ScanInsertMaybe
bool                 c_field_ScanInsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_field.N
inline i32           c_field_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_field.Remove
void                 c_field_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_field.RemoveAll
inline void          c_field_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_field.Reserve
void                 c_field_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_field.qFind
inline amc::FField&  c_field_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_field.qLast
inline amc::FField&  c_field_qLast(amc::FCtype& ctype) __attribute__((nothrow));
// Verify whether array is sorted
// func:amc.FCtype.c_field.SortedQ
bool                 c_field_SortedQ(amc::FCtype& ctype) __attribute__((nothrow));
// Insertion sort
// func:amc.FCtype.c_field.InsertionSort
void                 c_field_InsertionSort(amc::FCtype& ctype) __attribute__((nothrow));
// Heap sort
// func:amc.FCtype.c_field.HeapSort
void                 c_field_HeapSort(amc::FCtype& ctype) __attribute__((nothrow));
// Quick sort
// func:amc.FCtype.c_field.QuickSort
void                 c_field_QuickSort(amc::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_msgtype.InsertMaybe
inline bool          c_msgtype_InsertMaybe(amc::FCtype& ctype, amc::FMsgtype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_msgtype.Remove
inline void          c_msgtype_Remove(amc::FCtype& ctype, amc::FMsgtype& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_varlenfld.InsertMaybe
inline bool          c_varlenfld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_varlenfld.Remove
inline void          c_varlenfld_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_optfld.InsertMaybe
inline bool          c_optfld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_optfld.Remove
inline void          c_optfld_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_static.EmptyQ
inline bool          c_static_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_static.Find
inline amc::FStatictuple* c_static_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_static.Getary
inline algo::aryptr<amc::FStatictuple*> c_static_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_static.Insert
void                 c_static_Insert(amc::FCtype& ctype, amc::FStatictuple& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_static.InsertMaybe
bool                 c_static_InsertMaybe(amc::FCtype& ctype, amc::FStatictuple& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_static.N
inline i32           c_static_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_static.Remove
void                 c_static_Remove(amc::FCtype& ctype, amc::FStatictuple& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_static.RemoveAll
inline void          c_static_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_static.Reserve
void                 c_static_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_static.qFind
inline amc::FStatictuple& c_static_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FCtype.c_static.InAryQ
inline bool          ctype_c_static_InAryQ(amc::FStatictuple& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_static.qLast
inline amc::FStatictuple& c_static_qLast(amc::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_cpptype.InsertMaybe
inline bool          c_cpptype_InsertMaybe(amc::FCtype& ctype, amc::FCpptype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_cpptype.Remove
inline void          c_cpptype_Remove(amc::FCtype& ctype, amc::FCpptype& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_parent.EmptyQ
inline bool          c_parent_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_parent.Find
inline amc::FCtype*  c_parent_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_parent.Getary
inline algo::aryptr<amc::FCtype*> c_parent_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_parent.Insert
void                 c_parent_Insert(amc::FCtype& ctype, amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_parent.ScanInsertMaybe
bool                 c_parent_ScanInsertMaybe(amc::FCtype& ctype, amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_parent.N
inline i32           c_parent_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_parent.Remove
void                 c_parent_Remove(amc::FCtype& ctype, amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_parent.RemoveAll
inline void          c_parent_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_parent.Reserve
void                 c_parent_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_parent.qFind
inline amc::FCtype&  c_parent_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_parent.qLast
inline amc::FCtype&  c_parent_qLast(amc::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_ssimfile.InsertMaybe
inline bool          c_ssimfile_InsertMaybe(amc::FCtype& ctype, amc::FSsimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_ssimfile.Remove
inline void          c_ssimfile_Remove(amc::FCtype& ctype, amc::FSsimfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_pack.InsertMaybe
inline bool          c_pack_InsertMaybe(amc::FCtype& ctype, amc::FPack& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_pack.Remove
inline void          c_pack_Remove(amc::FCtype& ctype, amc::FPack& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_lenfld.InsertMaybe
inline bool          c_lenfld_InsertMaybe(amc::FCtype& ctype, amc::FLenfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_lenfld.Remove
inline void          c_lenfld_Remove(amc::FCtype& ctype, amc::FLenfld& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_pmaskfld.EmptyQ
inline bool          c_pmaskfld_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_pmaskfld.Find
inline amc::FPmaskfld* c_pmaskfld_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_pmaskfld.Getary
inline algo::aryptr<amc::FPmaskfld*> c_pmaskfld_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_pmaskfld.Insert
void                 c_pmaskfld_Insert(amc::FCtype& ctype, amc::FPmaskfld& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_pmaskfld.InsertMaybe
bool                 c_pmaskfld_InsertMaybe(amc::FCtype& ctype, amc::FPmaskfld& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_pmaskfld.N
inline i32           c_pmaskfld_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_pmaskfld.Remove
void                 c_pmaskfld_Remove(amc::FCtype& ctype, amc::FPmaskfld& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_pmaskfld.RemoveAll
inline void          c_pmaskfld_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_pmaskfld.Reserve
void                 c_pmaskfld_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_pmaskfld.qFind
inline amc::FPmaskfld& c_pmaskfld_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FCtype.c_pmaskfld.InAryQ
inline bool          ctype_c_pmaskfld_InAryQ(amc::FPmaskfld& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_pmaskfld.qLast
inline amc::FPmaskfld& c_pmaskfld_qLast(amc::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_typefld.InsertMaybe
inline bool          c_typefld_InsertMaybe(amc::FCtype& ctype, amc::FTypefld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_typefld.Remove
inline void          c_typefld_Remove(amc::FCtype& ctype, amc::FTypefld& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_datafld.EmptyQ
inline bool          c_datafld_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_datafld.Find
inline amc::FField*  c_datafld_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_datafld.Getary
inline algo::aryptr<amc::FField*> c_datafld_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_datafld.Insert
void                 c_datafld_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_datafld.InsertMaybe
bool                 c_datafld_InsertMaybe(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_datafld.N
inline i32           c_datafld_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_datafld.Remove
void                 c_datafld_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_datafld.RemoveAll
inline void          c_datafld_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_datafld.Reserve
void                 c_datafld_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_datafld.qFind
inline amc::FField&  c_datafld_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FCtype.c_datafld.InAryQ
inline bool          ctype_c_datafld_InAryQ(amc::FField& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_datafld.qLast
inline amc::FField&  c_datafld_qLast(amc::FCtype& ctype) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.zd_inst.EmptyQ
inline bool          zd_inst_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FCtype.zd_inst.First
inline amc::FField*  zd_inst_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FCtype.zd_inst.InLlistQ
inline bool          zd_inst_InLlistQ(amc::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FCtype.zd_inst.Insert
void                 zd_inst_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FCtype.zd_inst.Last
inline amc::FField*  zd_inst_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FCtype.zd_inst.N
inline i32           zd_inst_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FCtype.zd_inst.Next
inline amc::FField*  zd_inst_Next(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FCtype.zd_inst.Prev
inline amc::FField*  zd_inst_Prev(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.zd_inst.Remove
void                 zd_inst_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.zd_inst.RemoveAll
void                 zd_inst_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FCtype.zd_inst.RemoveFirst
amc::FField*         zd_inst_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FCtype.zd_inst.qLast
inline amc::FField&  zd_inst_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:amc.FCtype.zs_xref.EmptyQ
inline bool          zs_xref_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FCtype.zs_xref.First
inline amc::FXref*   zs_xref_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FCtype.zs_xref.InLlistQ
inline bool          zs_xref_InLlistQ(amc::FXref& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FCtype.zs_xref.Insert
void                 zs_xref_Insert(amc::FCtype& ctype, amc::FXref& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FCtype.zs_xref.Last
inline amc::FXref*   zs_xref_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FCtype.zs_xref.N
inline i32           zs_xref_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FCtype.zs_xref.Next
inline amc::FXref*   zs_xref_Next(amc::FXref &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FCtype.zs_xref.Remove
void                 zs_xref_Remove(amc::FCtype& ctype, amc::FXref& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.zs_xref.RemoveAll
void                 zs_xref_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FCtype.zs_xref.RemoveFirst
amc::FXref*          zs_xref_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FCtype.zs_xref.qLast
inline amc::FXref&   zs_xref_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_chash.InsertMaybe
inline bool          c_chash_InsertMaybe(amc::FCtype& ctype, amc::FChash& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_chash.Remove
inline void          c_chash_Remove(amc::FCtype& ctype, amc::FChash& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_ccmp.InsertMaybe
inline bool          c_ccmp_InsertMaybe(amc::FCtype& ctype, amc::FCcmp& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_ccmp.Remove
inline void          c_ccmp_Remove(amc::FCtype& ctype, amc::FCcmp& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_cstr.InsertMaybe
inline bool          c_cstr_InsertMaybe(amc::FCtype& ctype, amc::FCstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_cstr.Remove
inline void          c_cstr_Remove(amc::FCtype& ctype, amc::FCstr& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_cextern.InsertMaybe
inline bool          c_cextern_InsertMaybe(amc::FCtype& ctype, amc::FCextern& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_cextern.Remove
inline void          c_cextern_Remove(amc::FCtype& ctype, amc::FCextern& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_ffunc.EmptyQ
inline bool          c_ffunc_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_ffunc.Find
inline amc::FFunc*   c_ffunc_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_ffunc.Getary
inline algo::aryptr<amc::FFunc*> c_ffunc_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_ffunc.Insert
void                 c_ffunc_Insert(amc::FCtype& ctype, amc::FFunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_ffunc.ScanInsertMaybe
bool                 c_ffunc_ScanInsertMaybe(amc::FCtype& ctype, amc::FFunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_ffunc.N
inline i32           c_ffunc_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_ffunc.Remove
void                 c_ffunc_Remove(amc::FCtype& ctype, amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_ffunc.RemoveAll
inline void          c_ffunc_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_ffunc.Reserve
void                 c_ffunc_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_ffunc.qFind
inline amc::FFunc&   c_ffunc_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_ffunc.qLast
inline amc::FFunc&   c_ffunc_qLast(amc::FCtype& ctype) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.zd_cafter.EmptyQ
inline bool          zd_cafter_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FCtype.zd_cafter.First
inline amc::FCafter* zd_cafter_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FCtype.zd_cafter.InLlistQ
inline bool          zd_cafter_InLlistQ(amc::FCafter& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FCtype.zd_cafter.Insert
void                 zd_cafter_Insert(amc::FCtype& ctype, amc::FCafter& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FCtype.zd_cafter.Last
inline amc::FCafter* zd_cafter_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FCtype.zd_cafter.N
inline i32           zd_cafter_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FCtype.zd_cafter.Next
inline amc::FCafter* zd_cafter_Next(amc::FCafter &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FCtype.zd_cafter.Prev
inline amc::FCafter* zd_cafter_Prev(amc::FCafter &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.zd_cafter.Remove
void                 zd_cafter_Remove(amc::FCtype& ctype, amc::FCafter& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.zd_cafter.RemoveAll
void                 zd_cafter_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FCtype.zd_cafter.RemoveFirst
amc::FCafter*        zd_cafter_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FCtype.zd_cafter.qLast
inline amc::FCafter& zd_cafter_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_csize.InsertMaybe
inline bool          c_csize_InsertMaybe(amc::FCtype& ctype, amc::FCsize& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_csize.Remove
inline void          c_csize_Remove(amc::FCtype& ctype, amc::FCsize& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.zd_access.EmptyQ
inline bool          zd_access_EmptyQ(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FCtype.zd_access.First
inline amc::FField*  zd_access_First(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FCtype.zd_access.InLlistQ
inline bool          zd_access_InLlistQ(amc::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FCtype.zd_access.Insert
void                 zd_access_Insert(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FCtype.zd_access.Last
inline amc::FField*  zd_access_Last(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FCtype.zd_access.N
inline i32           zd_access_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FCtype.zd_access.Next
inline amc::FField*  zd_access_Next(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FCtype.zd_access.Prev
inline amc::FField*  zd_access_Prev(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.zd_access.Remove
void                 zd_access_Remove(amc::FCtype& ctype, amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.zd_access.RemoveAll
void                 zd_access_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FCtype.zd_access.RemoveFirst
amc::FField*         zd_access_RemoveFirst(amc::FCtype& ctype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FCtype.zd_access.qLast
inline amc::FField&  zd_access_qLast(amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_cdflt.InsertMaybe
inline bool          c_cdflt_InsertMaybe(amc::FCtype& ctype, amc::FCdflt& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_cdflt.Remove
inline void          c_cdflt_Remove(amc::FCtype& ctype, amc::FCdflt& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_argvtype.InsertMaybe
inline bool          c_argvtype_InsertMaybe(amc::FCtype& ctype, amc::FArgvtype& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_argvtype.Remove
inline void          c_argvtype_Remove(amc::FCtype& ctype, amc::FArgvtype& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_floadtuples.InsertMaybe
inline bool          c_floadtuples_InsertMaybe(amc::FCtype& ctype, amc::FFloadtuples& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_floadtuples.Remove
inline void          c_floadtuples_Remove(amc::FCtype& ctype, amc::FFloadtuples& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_fcurs.EmptyQ
inline bool          c_fcurs_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_fcurs.Find
inline amc::FFcurs*  c_fcurs_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_fcurs.Getary
inline algo::aryptr<amc::FFcurs*> c_fcurs_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_fcurs.Insert
void                 c_fcurs_Insert(amc::FCtype& ctype, amc::FFcurs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_fcurs.InsertMaybe
bool                 c_fcurs_InsertMaybe(amc::FCtype& ctype, amc::FFcurs& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_fcurs.N
inline i32           c_fcurs_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_fcurs.Remove
void                 c_fcurs_Remove(amc::FCtype& ctype, amc::FFcurs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_fcurs.RemoveAll
inline void          c_fcurs_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_fcurs.Reserve
void                 c_fcurs_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_fcurs.qFind
inline amc::FFcurs&  c_fcurs_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FCtype.c_fcurs.InAryQ
inline bool          ctype_c_fcurs_InAryQ(amc::FFcurs& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_fcurs.qLast
inline amc::FFcurs&  c_fcurs_qLast(amc::FCtype& ctype) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_ctypelen.InsertMaybe
inline bool          c_ctypelen_InsertMaybe(amc::FCtype& ctype, amc::FCtypelen& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_ctypelen.Remove
inline void          c_ctypelen_Remove(amc::FCtype& ctype, amc::FCtypelen& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_nossimfile.InsertMaybe
inline bool          c_nossimfile_InsertMaybe(amc::FCtype& ctype, amc::FNossimfile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_nossimfile.Remove
inline void          c_nossimfile_Remove(amc::FCtype& ctype, amc::FNossimfile& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FCtype.c_cfast.InsertMaybe
inline bool          c_cfast_InsertMaybe(amc::FCtype& ctype, amc::FCfast& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FCtype.c_cfast.Remove
inline void          c_cfast_Remove(amc::FCtype& ctype, amc::FCfast& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FCtype.c_ffast.EmptyQ
inline bool          c_ffast_EmptyQ(amc::FCtype& ctype) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FCtype.c_ffast.Find
inline amc::FFfast*  c_ffast_Find(amc::FCtype& ctype, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FCtype.c_ffast.Getary
inline algo::aryptr<amc::FFfast*> c_ffast_Getary(amc::FCtype& ctype) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FCtype.c_ffast.Insert
void                 c_ffast_Insert(amc::FCtype& ctype, amc::FFfast& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FCtype.c_ffast.InsertMaybe
bool                 c_ffast_InsertMaybe(amc::FCtype& ctype, amc::FFfast& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FCtype.c_ffast.N
inline i32           c_ffast_N(const amc::FCtype& ctype) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FCtype.c_ffast.Remove
void                 c_ffast_Remove(amc::FCtype& ctype, amc::FFfast& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FCtype.c_ffast.RemoveAll
inline void          c_ffast_RemoveAll(amc::FCtype& ctype) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FCtype.c_ffast.Reserve
void                 c_ffast_Reserve(amc::FCtype& ctype, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FCtype.c_ffast.qFind
inline amc::FFfast&  c_ffast_qFind(amc::FCtype& ctype, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FCtype.c_ffast.InAryQ
inline bool          ctype_c_ffast_InAryQ(amc::FFfast& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FCtype.c_ffast.qLast
inline amc::FFfast&  c_ffast_qLast(amc::FCtype& ctype) __attribute__((nothrow));
// Verify whether array is sorted
// func:amc.FCtype.c_ffast.SortedQ
bool                 c_ffast_SortedQ(amc::FCtype& ctype) __attribute__((nothrow));
// Insertion sort
// func:amc.FCtype.c_ffast.InsertionSort
void                 c_ffast_InsertionSort(amc::FCtype& ctype) __attribute__((nothrow));
// Heap sort
// func:amc.FCtype.c_ffast.HeapSort
void                 c_ffast_HeapSort(amc::FCtype& ctype) __attribute__((nothrow));
// Quick sort
// func:amc.FCtype.c_ffast.QuickSort
void                 c_ffast_QuickSort(amc::FCtype& ctype) __attribute__((nothrow));

// cursor points to valid item
// func:amc.FCtype.zs_cfmt_curs.Reset
inline void          ctype_zs_cfmt_curs_Reset(ctype_zs_cfmt_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zs_cfmt_curs.ValidQ
inline bool          ctype_zs_cfmt_curs_ValidQ(ctype_zs_cfmt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.zs_cfmt_curs.Next
inline void          ctype_zs_cfmt_curs_Next(ctype_zs_cfmt_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.zs_cfmt_curs.Access
inline amc::FCfmt&   ctype_zs_cfmt_curs_Access(ctype_zs_cfmt_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_field_curs.Reset
inline void          ctype_c_field_curs_Reset(ctype_c_field_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_field_curs.ValidQ
inline bool          ctype_c_field_curs_ValidQ(ctype_c_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_field_curs.Next
inline void          ctype_c_field_curs_Next(ctype_c_field_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_field_curs.Access
inline amc::FField&  ctype_c_field_curs_Access(ctype_c_field_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_static_curs.Reset
inline void          ctype_c_static_curs_Reset(ctype_c_static_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_static_curs.ValidQ
inline bool          ctype_c_static_curs_ValidQ(ctype_c_static_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_static_curs.Next
inline void          ctype_c_static_curs_Next(ctype_c_static_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_static_curs.Access
inline amc::FStatictuple& ctype_c_static_curs_Access(ctype_c_static_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_parent_curs.Reset
inline void          ctype_c_parent_curs_Reset(ctype_c_parent_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_parent_curs.ValidQ
inline bool          ctype_c_parent_curs_ValidQ(ctype_c_parent_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_parent_curs.Next
inline void          ctype_c_parent_curs_Next(ctype_c_parent_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_parent_curs.Access
inline amc::FCtype&  ctype_c_parent_curs_Access(ctype_c_parent_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_pmaskfld_curs.Reset
inline void          ctype_c_pmaskfld_curs_Reset(ctype_c_pmaskfld_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_pmaskfld_curs.ValidQ
inline bool          ctype_c_pmaskfld_curs_ValidQ(ctype_c_pmaskfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_pmaskfld_curs.Next
inline void          ctype_c_pmaskfld_curs_Next(ctype_c_pmaskfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_pmaskfld_curs.Access
inline amc::FPmaskfld& ctype_c_pmaskfld_curs_Access(ctype_c_pmaskfld_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_datafld_curs.Reset
inline void          ctype_c_datafld_curs_Reset(ctype_c_datafld_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_datafld_curs.ValidQ
inline bool          ctype_c_datafld_curs_ValidQ(ctype_c_datafld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_datafld_curs.Next
inline void          ctype_c_datafld_curs_Next(ctype_c_datafld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_datafld_curs.Access
inline amc::FField&  ctype_c_datafld_curs_Access(ctype_c_datafld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zd_inst_curs.Reset
inline void          ctype_zd_inst_curs_Reset(ctype_zd_inst_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zd_inst_curs.ValidQ
inline bool          ctype_zd_inst_curs_ValidQ(ctype_zd_inst_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.zd_inst_curs.Next
inline void          ctype_zd_inst_curs_Next(ctype_zd_inst_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.zd_inst_curs.Access
inline amc::FField&  ctype_zd_inst_curs_Access(ctype_zd_inst_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zs_xref_curs.Reset
inline void          ctype_zs_xref_curs_Reset(ctype_zs_xref_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zs_xref_curs.ValidQ
inline bool          ctype_zs_xref_curs_ValidQ(ctype_zs_xref_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.zs_xref_curs.Next
inline void          ctype_zs_xref_curs_Next(ctype_zs_xref_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.zs_xref_curs.Access
inline amc::FXref&   ctype_zs_xref_curs_Access(ctype_zs_xref_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_ffunc_curs.Reset
inline void          ctype_c_ffunc_curs_Reset(ctype_c_ffunc_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_ffunc_curs.ValidQ
inline bool          ctype_c_ffunc_curs_ValidQ(ctype_c_ffunc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_ffunc_curs.Next
inline void          ctype_c_ffunc_curs_Next(ctype_c_ffunc_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_ffunc_curs.Access
inline amc::FFunc&   ctype_c_ffunc_curs_Access(ctype_c_ffunc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zd_cafter_curs.Reset
inline void          ctype_zd_cafter_curs_Reset(ctype_zd_cafter_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zd_cafter_curs.ValidQ
inline bool          ctype_zd_cafter_curs_ValidQ(ctype_zd_cafter_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.zd_cafter_curs.Next
inline void          ctype_zd_cafter_curs_Next(ctype_zd_cafter_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.zd_cafter_curs.Access
inline amc::FCafter& ctype_zd_cafter_curs_Access(ctype_zd_cafter_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zd_access_curs.Reset
inline void          ctype_zd_access_curs_Reset(ctype_zd_access_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.zd_access_curs.ValidQ
inline bool          ctype_zd_access_curs_ValidQ(ctype_zd_access_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.zd_access_curs.Next
inline void          ctype_zd_access_curs_Next(ctype_zd_access_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.zd_access_curs.Access
inline amc::FField&  ctype_zd_access_curs_Access(ctype_zd_access_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_fcurs_curs.Reset
inline void          ctype_c_fcurs_curs_Reset(ctype_c_fcurs_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_fcurs_curs.ValidQ
inline bool          ctype_c_fcurs_curs_ValidQ(ctype_c_fcurs_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_fcurs_curs.Next
inline void          ctype_c_fcurs_curs_Next(ctype_c_fcurs_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_fcurs_curs.Access
inline amc::FFcurs&  ctype_c_fcurs_curs_Access(ctype_c_fcurs_curs &curs) __attribute__((nothrow));
// func:amc.FCtype.c_ffast_curs.Reset
inline void          ctype_c_ffast_curs_Reset(ctype_c_ffast_curs &curs, amc::FCtype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FCtype.c_ffast_curs.ValidQ
inline bool          ctype_c_ffast_curs_ValidQ(ctype_c_ffast_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FCtype.c_ffast_curs.Next
inline void          ctype_c_ffast_curs_Next(ctype_c_ffast_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FCtype.c_ffast_curs.Access
inline amc::FFfast&  ctype_c_ffast_curs_Access(ctype_c_ffast_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.FCtype..Init
void                 FCtype_Init(amc::FCtype& ctype);
// func:amc.FCtype..Uninit
void                 FCtype_Uninit(amc::FCtype& ctype) __attribute__((nothrow));

// --- amc.FCtypelen
// create: amc.FDb.ctypelen (Lary)
// global access: ctypelen (Lary, by rowid)
// global access: c_ctypelen (Ptrary)
// access: amc.FCtype.c_ctypelen (Ptr)
struct FCtypelen { // amc.FCtypelen
    algo::Smallstr100   ctype;                   // Identifies the Ctype
    u32                 len;                     //   0  (calculated) length of the C++ struct in bytes
    i32                 alignment;               //   0  (calculated) alignment for the struct
    i32                 padbytes;                //   0  (calculated) total # of pad bytes
    bool                plaindata;               //   false  (calculated) this struct can me safely memcpy'ed
    bool                _db_c_ctypelen_in_ary;   //   false  membership flag
    // func:amc.FCtypelen..AssignOp
    inline amc::FCtypelen& operator =(const amc::FCtypelen &rhs) = delete;
    // func:amc.FCtypelen..CopyCtor
    inline               FCtypelen(const amc::FCtypelen &rhs) = delete;
private:
    // func:amc.FCtypelen..Ctor
    inline               FCtypelen() __attribute__((nothrow));
    // func:amc.FCtypelen..Dtor
    inline               ~FCtypelen() __attribute__((nothrow));
    friend amc::FCtypelen&      ctypelen_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FCtypelen*      ctypelen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ctypelen_RemoveAll() __attribute__((nothrow));
    friend void                 ctypelen_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FCtypelen.base.CopyOut
void                 ctypelen_CopyOut(amc::FCtypelen &row, dmmeta::Ctypelen &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FCtypelen.base.CopyIn
void                 ctypelen_CopyIn(amc::FCtypelen &row, dmmeta::Ctypelen &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FCtypelen..Init
inline void          FCtypelen_Init(amc::FCtypelen& ctypelen);
// func:amc.FCtypelen..Uninit
void                 FCtypelen_Uninit(amc::FCtypelen& ctypelen) __attribute__((nothrow));

// --- amc.Genctx
struct Genctx { // amc.Genctx
    algo_lib::Replscope   R;         //
    amc::FNs*             p_ns;      // reference to parent row
    amc::FCtype*          p_ctype;   // reference to parent row
    amc::FField*          p_field;   // reference to parent row
    amc::FTfunc*          p_tfunc;   // reference to parent row
    // func:amc.Genctx..Ctor
    inline               Genctx() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:amc.Genctx..Init
inline void          Genctx_Init(amc::Genctx& parent);

// --- amc.FTclass
// create: amc.FDb.tclass (Inlary)
// global access: ind_tclass (Thash, hash field tclass)
// access: amc.FReftype.p_tclass (Upptr)
struct FTclass { // amc.FTclass
    algo::Smallstr50        tclass;            //
    amc::FTfunc**           c_tfunc_elems;     // array of pointers
    u32                     c_tfunc_n;         // array of pointers
    u32                     c_tfunc_max;       // capacity of allocated array
    amc::tclass_step_hook   step;              //   NULL  Pointer to a function
    amc::FTclass*           ind_tclass_next;   // hash next
    // reftype Ptrary of amc.FTclass.c_tfunc prohibits copy
    // reftype Hook of amc.FTclass.step prohibits copy
    // func:amc.FTclass..AssignOp
    inline amc::FTclass& operator =(const amc::FTclass &rhs) = delete;
    // func:amc.FTclass..Ctor
    inline               FTclass() __attribute__((nothrow));
    // func:amc.FTclass..Dtor
    inline               ~FTclass() __attribute__((nothrow));
    // reftype Ptrary of amc.FTclass.c_tfunc prohibits copy
    // reftype Hook of amc.FTclass.step prohibits copy
    // func:amc.FTclass..CopyCtor
    inline               FTclass(const amc::FTclass &rhs) = delete;
};

// Copy fields out of row
// func:amc.FTclass.msghdr.CopyOut
void                 tclass_CopyOut(amc::FTclass &row, amcdb::Tclass &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTclass.msghdr.CopyIn
void                 tclass_CopyIn(amc::FTclass &row, amcdb::Tclass &in) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FTclass.c_tfunc.EmptyQ
inline bool          c_tfunc_EmptyQ(amc::FTclass& tclass) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FTclass.c_tfunc.Find
inline amc::FTfunc*  c_tfunc_Find(amc::FTclass& tclass, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FTclass.c_tfunc.Getary
inline algo::aryptr<amc::FTfunc*> c_tfunc_Getary(amc::FTclass& tclass) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FTclass.c_tfunc.Insert
void                 c_tfunc_Insert(amc::FTclass& tclass, amc::FTfunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FTclass.c_tfunc.InsertMaybe
bool                 c_tfunc_InsertMaybe(amc::FTclass& tclass, amc::FTfunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FTclass.c_tfunc.N
inline i32           c_tfunc_N(const amc::FTclass& tclass) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FTclass.c_tfunc.Remove
void                 c_tfunc_Remove(amc::FTclass& tclass, amc::FTfunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FTclass.c_tfunc.RemoveAll
inline void          c_tfunc_RemoveAll(amc::FTclass& tclass) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FTclass.c_tfunc.Reserve
void                 c_tfunc_Reserve(amc::FTclass& tclass, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FTclass.c_tfunc.qFind
inline amc::FTfunc&  c_tfunc_qFind(amc::FTclass& tclass, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FTclass.c_tfunc.InAryQ
inline bool          tclass_c_tfunc_InAryQ(amc::FTfunc& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FTclass.c_tfunc.qLast
inline amc::FTfunc&  c_tfunc_qLast(amc::FTclass& tclass) __attribute__((nothrow));

// Invoke function by pointer
// func:amc.FTclass.step.Call
inline void          step_Call(amc::FTclass& tclass) __attribute__((nothrow));

// func:amc.FTclass.c_tfunc_curs.Reset
inline void          tclass_c_tfunc_curs_Reset(tclass_c_tfunc_curs &curs, amc::FTclass &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FTclass.c_tfunc_curs.ValidQ
inline bool          tclass_c_tfunc_curs_ValidQ(tclass_c_tfunc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FTclass.c_tfunc_curs.Next
inline void          tclass_c_tfunc_curs_Next(tclass_c_tfunc_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FTclass.c_tfunc_curs.Access
inline amc::FTfunc&  tclass_c_tfunc_curs_Access(tclass_c_tfunc_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.FTclass..Init
inline void          FTclass_Init(amc::FTclass& tclass);
// func:amc.FTclass..Uninit
void                 FTclass_Uninit(amc::FTclass& tclass) __attribute__((nothrow));

// --- amc.trace
#pragma pack(push,1)
struct trace { // amc.trace
    // func:amc.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)

// print string representation of ROW to string STR
// cfmt:amc.trace.String  printfmt:Tuple
// func:amc.trace..Print
void                 trace_Print(amc::trace& row, algo::cstring& str) __attribute__((nothrow));

// --- amc.FDb
// create: amc.FDb._db (Global)
struct FDb { // amc.FDb: In-memory database for amc
    lpool_Lpblock*          lpool_free[36];                           // Lpool levels
    amc::FFsort*            fsort_lary[32];                           // level array
    i32                     fsort_n;                                  // number of elements in array
    amc::FCfmt**            ind_cfmt_buckets_elems;                   // pointer to bucket array
    i32                     ind_cfmt_buckets_n;                       // number of elements in bucket array
    i32                     ind_cfmt_n;                               // number of elements in the hash table
    amc::FDispfilter*       dispfilter_lary[32];                      // level array
    i32                     dispfilter_n;                             // number of elements in array
    amc::FUsertracefld*     usertracefld_lary[32];                    // level array
    i32                     usertracefld_n;                           // number of elements in array
    amc::FCfmt*             cfmt_lary[32];                            // level array
    i32                     cfmt_n;                                   // number of elements in array
    command::amc            cmdline;                                  //
    amc::FDispatch*         dispatch_lary[32];                        // level array
    i32                     dispatch_n;                               // number of elements in array
    amc::FDispatchmsg*      dispatch_msg_lary[32];                    // level array
    i32                     dispatch_msg_n;                           // number of elements in array
    amc::FCtype*            ctype_lary[32];                           // level array
    i32                     ctype_n;                                  // number of elements in array
    amc::FField*            field_lary[32];                           // level array
    i32                     field_n;                                  // number of elements in array
    amc::FBasepool*         basepool_lary[32];                        // level array
    i32                     basepool_n;                               // number of elements in array
    amc::FLlist*            llist_lary[32];                           // level array
    i32                     llist_n;                                  // number of elements in array
    amc::FAnonfld*          anonfld_lary[32];                         // level array
    i32                     anonfld_n;                                // number of elements in array
    amc::FXref*             xref_lary[32];                            // level array
    i32                     xref_n;                                   // number of elements in array
    amc::FNs*               ns_lary[32];                              // level array
    i32                     ns_n;                                     // number of elements in array
    amc::FPnew*             pnew_lary[32];                            // level array
    i32                     pnew_n;                                   // number of elements in array
    amc::FFldoffset*        fldoffset_lary[32];                       // level array
    i32                     fldoffset_n;                              // number of elements in array
    amc::FTypefld*          typefld_lary[32];                         // level array
    i32                     typefld_n;                                // number of elements in array
    amc::FLenfld*           lenfld_lary[32];                          // level array
    i32                     lenfld_n;                                 // number of elements in array
    amc::FBltin*            bltin_lary[32];                           // level array
    i32                     bltin_n;                                  // number of elements in array
    amc::FStatictuple*      static_tuple_lary[32];                    // level array
    i32                     static_tuple_n;                           // number of elements in array
    amc::FMsgtype*          msgtype_lary[32];                         // level array
    i32                     msgtype_n;                                // number of elements in array
    amc::FGconst*           gconst_lary[32];                          // level array
    i32                     gconst_n;                                 // number of elements in array
    amc::FGstatic*          gstatic_lary[32];                         // level array
    i32                     gstatic_n;                                // number of elements in array
    amc::FThash*            thash_lary[32];                           // level array
    i32                     thash_n;                                  // number of elements in array
    u64                     outfile_blocksize;                        // # bytes per block
    amc::FOutfile*          outfile_free;                             //
    amc::FFunc*             func_lary[32];                            // level array
    i32                     func_n;                                   // number of elements in array
    amc::FSmallstr*         smallstr_lary[32];                        // level array
    i32                     smallstr_n;                               // number of elements in array
    amc::FNumstr*           numstr_lary[32];                          // level array
    i32                     numstr_n;                                 // number of elements in array
    amc::FMain*             main_lary[32];                            // level array
    i32                     main_n;                                   // number of elements in array
    amc::FReftype*          reftype_lary[32];                         // level array
    i32                     reftype_n;                                // number of elements in array
    amc::FBltin**           ind_bltin_buckets_elems;                  // pointer to bucket array
    i32                     ind_bltin_buckets_n;                      // number of elements in bucket array
    i32                     ind_bltin_n;                              // number of elements in the hash table
    amc::FCtype**           ind_ctype_buckets_elems;                  // pointer to bucket array
    i32                     ind_ctype_buckets_n;                      // number of elements in bucket array
    i32                     ind_ctype_n;                              // number of elements in the hash table
    amc::FDispatch**        ind_dispatch_buckets_elems;               // pointer to bucket array
    i32                     ind_dispatch_buckets_n;                   // number of elements in bucket array
    i32                     ind_dispatch_n;                           // number of elements in the hash table
    amc::FFunc**            ind_func_buckets_elems;                   // pointer to bucket array
    i32                     ind_func_buckets_n;                       // number of elements in bucket array
    i32                     ind_func_n;                               // number of elements in the hash table
    amc::FField**           ind_field_buckets_elems;                  // pointer to bucket array
    i32                     ind_field_buckets_n;                      // number of elements in bucket array
    i32                     ind_field_n;                              // number of elements in the hash table
    amc::FNs**              ind_ns_buckets_elems;                     // pointer to bucket array
    i32                     ind_ns_buckets_n;                         // number of elements in bucket array
    i32                     ind_ns_n;                                 // number of elements in the hash table
    amc::FPnew**            ind_pnew_buckets_elems;                   // pointer to bucket array
    i32                     ind_pnew_buckets_n;                       // number of elements in bucket array
    i32                     ind_pnew_n;                               // number of elements in the hash table
    amc::FXref**            ind_xref_buckets_elems;                   // pointer to bucket array
    i32                     ind_xref_buckets_n;                       // number of elements in bucket array
    i32                     ind_xref_n;                               // number of elements in the hash table
    amc::FCpptype*          cpptype_lary[32];                         // level array
    i32                     cpptype_n;                                // number of elements in array
    amc::FCpptype**         ind_cpptype_buckets_elems;                // pointer to bucket array
    i32                     ind_cpptype_buckets_n;                    // number of elements in bucket array
    i32                     ind_cpptype_n;                            // number of elements in the hash table
    amc::FInlary*           inlary_lary[32];                          // level array
    i32                     inlary_n;                                 // number of elements in array
    amc::FInlary**          ind_inlary_buckets_elems;                 // pointer to bucket array
    i32                     ind_inlary_buckets_n;                     // number of elements in bucket array
    i32                     ind_inlary_n;                             // number of elements in the hash table
    amc::FTary*             tary_lary[32];                            // level array
    i32                     tary_n;                                   // number of elements in array
    amc::FTary**            ind_tary_buckets_elems;                   // pointer to bucket array
    i32                     ind_tary_buckets_n;                       // number of elements in bucket array
    i32                     ind_tary_n;                               // number of elements in the hash table
    amc::FCppfunc*          cppfunc_lary[32];                         // level array
    i32                     cppfunc_n;                                // number of elements in array
    amc::FRowid*            rowid_lary[32];                           // level array
    i32                     rowid_n;                                  // number of elements in array
    amc::FRowid**           ind_rowid_buckets_elems;                  // pointer to bucket array
    i32                     ind_rowid_buckets_n;                      // number of elements in bucket array
    i32                     ind_rowid_n;                              // number of elements in the hash table
    amc::FCascdel*          cascdel_lary[32];                         // level array
    i32                     cascdel_n;                                // number of elements in array
    amc::FSubstr*           substr_lary[32];                          // level array
    i32                     substr_n;                                 // number of elements in array
    amc::FBitfld*           bitfld_lary[32];                          // level array
    i32                     bitfld_n;                                 // number of elements in array
    amc::FSsimfile*         ssimfile_lary[32];                        // level array
    i32                     ssimfile_n;                               // number of elements in array
    amc::FSsimfile**        ind_ssimfile_buckets_elems;               // pointer to bucket array
    i32                     ind_ssimfile_buckets_n;                   // number of elements in bucket array
    i32                     ind_ssimfile_n;                           // number of elements in the hash table
    amc::FPack*             pack_lary[32];                            // level array
    i32                     pack_n;                                   // number of elements in array
    amc::FPack**            ind_pack_buckets_elems;                   // pointer to bucket array
    i32                     ind_pack_buckets_n;                       // number of elements in bucket array
    i32                     ind_pack_n;                               // number of elements in the hash table
    amc::FSmallstr**        ind_smallstr_buckets_elems;               // pointer to bucket array
    i32                     ind_smallstr_buckets_n;                   // number of elements in bucket array
    i32                     ind_smallstr_n;                           // number of elements in the hash table
    amc::FPtrary*           ptrary_lary[32];                          // level array
    i32                     ptrary_n;                                 // number of elements in array
    amc::FCtype**           c_ctype_sorted_elems;                     // array of pointers
    u32                     c_ctype_sorted_n;                         // array of pointers
    u32                     c_ctype_sorted_max;                       // capacity of allocated array
    amc::FEnumstr*          enumstr_lary[32];                         // level array
    i32                     enumstr_n;                                // number of elements in array
    amc::FEnumstrLen*       enumstr_len_lary[32];                     // level array
    i32                     enumstr_len_n;                            // number of elements in array
    amc::FEnumstrLen**      bh_enumstr_len_elems;                     // binary heap by len
    i32                     bh_enumstr_len_n;                         // number of elements in the heap
    i32                     bh_enumstr_len_max;                       // max elements in bh_enumstr_len_elems
    amc::FEnumstrLen**      ind_enumstr_len_buckets_elems;            // pointer to bucket array
    i32                     ind_enumstr_len_buckets_n;                // number of elements in bucket array
    i32                     ind_enumstr_len_n;                        // number of elements in the hash table
    amc::FEnumstr**         ind_enumstr_buckets_elems;                // pointer to bucket array
    i32                     ind_enumstr_buckets_n;                    // number of elements in bucket array
    i32                     ind_enumstr_n;                            // number of elements in the hash table
    amc::FFbitset*          fbitset_lary[32];                         // level array
    i32                     fbitset_n;                                // number of elements in array
    amc::FFbitset**         ind_fbitset_buckets_elems;                // pointer to bucket array
    i32                     ind_fbitset_buckets_n;                    // number of elements in bucket array
    i32                     ind_fbitset_n;                            // number of elements in the hash table
    amc::FFcleanup*         fcleanup_lary[32];                        // level array
    i32                     fcleanup_n;                               // number of elements in array
    amc::FFdec*             fdec_lary[32];                            // level array
    i32                     fdec_n;                                   // number of elements in array
    amc::FFdec**            ind_fdec_buckets_elems;                   // pointer to bucket array
    i32                     ind_fdec_buckets_n;                       // number of elements in bucket array
    i32                     ind_fdec_n;                               // number of elements in the hash table
    amc::FReftype**         ind_reftype_buckets_elems;                // pointer to bucket array
    i32                     ind_reftype_buckets_n;                    // number of elements in bucket array
    i32                     ind_reftype_n;                            // number of elements in the hash table
    amc::FFconst*           fconst_lary[32];                          // level array
    i32                     fconst_n;                                 // number of elements in array
    amc::FFconst**          ind_fconst_buckets_elems;                 // pointer to bucket array
    i32                     ind_fconst_buckets_n;                     // number of elements in bucket array
    i32                     ind_fconst_n;                             // number of elements in the hash table
    amc::FNs**              c_ns_sorted_elems;                        // array of pointers
    u32                     c_ns_sorted_n;                            // array of pointers
    u32                     c_ns_sorted_max;                          // capacity of allocated array
    amc::FFinput*           finput_lary[32];                          // level array
    i32                     finput_n;                                 // number of elements in array
    amc::FFoutput*          foutput_lary[32];                         // level array
    i32                     foutput_n;                                // number of elements in array
    amc::FFbuf*             fbuf_lary[32];                            // level array
    i32                     fbuf_n;                                   // number of elements in array
    amc::FFbuf**            ind_fbuf_buckets_elems;                   // pointer to bucket array
    i32                     ind_fbuf_buckets_n;                       // number of elements in bucket array
    i32                     ind_fbuf_n;                               // number of elements in the hash table
    amc::FChash*            chash_lary[32];                           // level array
    i32                     chash_n;                                  // number of elements in array
    amc::FChash**           ind_chash_buckets_elems;                  // pointer to bucket array
    i32                     ind_chash_buckets_n;                      // number of elements in bucket array
    i32                     ind_chash_n;                              // number of elements in the hash table
    amc::FCcmp*             ccmp_lary[32];                            // level array
    i32                     ccmp_n;                                   // number of elements in array
    amc::FCcmp**            ind_ccmp_buckets_elems;                   // pointer to bucket array
    i32                     ind_ccmp_buckets_n;                       // number of elements in bucket array
    i32                     ind_ccmp_n;                               // number of elements in the hash table
    amc::FFbigend*          fbigend_lary[32];                         // level array
    i32                     fbigend_n;                                // number of elements in array
    amc::FCtype*            zsl_ctype_pack_tran_head;                 // zero-terminated singly linked list
    amc::FCstr*             cstr_lary[32];                            // level array
    i32                     cstr_n;                                   // number of elements in array
    amc::FListtype*         listtype_lary[32];                        // level array
    i32                     listtype_n;                               // number of elements in array
    amc::FListtype**        ind_listtype_buckets_elems;               // pointer to bucket array
    i32                     ind_listtype_buckets_n;                   // number of elements in bucket array
    i32                     ind_listtype_n;                           // number of elements in the hash table
    amc::FFstep*            fstep_lary[32];                           // level array
    i32                     fstep_n;                                  // number of elements in array
    amc::FCextern*          cextern_lary[32];                         // level array
    i32                     cextern_n;                                // number of elements in array
    amc::FFdelay*           fdelay_lary[32];                          // level array
    i32                     fdelay_n;                                 // number of elements in array
    amc::FDisptrace*        disptrace_lary[32];                       // level array
    i32                     disptrace_n;                              // number of elements in array
    amc::FFstep**           ind_fstep_buckets_elems;                  // pointer to bucket array
    i32                     ind_fstep_buckets_n;                      // number of elements in bucket array
    i32                     ind_fstep_n;                              // number of elements in the hash table
    amc::FTracefld*         tracefld_lary[32];                        // level array
    i32                     tracefld_n;                               // number of elements in array
    amc::FTracerec*         tracerec_lary[32];                        // level array
    i32                     tracerec_n;                               // number of elements in array
    amc::FDispsig*          dispsig_lary[32];                         // level array
    i32                     dispsig_n;                                // number of elements in array
    amc::FDispsig**         c_dispsig_sorted_elems;                   // array of pointers
    u32                     c_dispsig_sorted_n;                       // array of pointers
    u32                     c_dispsig_sorted_max;                     // capacity of allocated array
    amc::FCtype*            zs_sig_visit_head;                        // zero-terminated singly linked list
    amc::FCtype*            zs_sig_visit_tail;                        // pointer to last element
    amc::FTarget*           target_lary[32];                          // level array
    i32                     target_n;                                 // number of elements in array
    amc::FTarget**          ind_target_buckets_elems;                 // pointer to bucket array
    i32                     ind_target_buckets_n;                     // number of elements in bucket array
    i32                     ind_target_n;                             // number of elements in the hash table
    amc::FTargdep*          targdep_lary[32];                         // level array
    i32                     targdep_n;                                // number of elements in array
    amc::FField*            c_malloc;                                 // optional pointer
    amc::FDispctx*          dispctx_lary[32];                         // level array
    i32                     dispctx_n;                                // number of elements in array
    amc::FPmaskfld*         pmaskfld_lary[32];                        // level array
    i32                     pmaskfld_n;                               // number of elements in array
    amc::Genctx             genctx;                                   //
    amc::FFwddecl*          fwddecl_lary[32];                         // level array
    i32                     fwddecl_n;                                // number of elements in array
    amc::FFwddecl**         ind_fwddecl_buckets_elems;                // pointer to bucket array
    i32                     ind_fwddecl_buckets_n;                    // number of elements in bucket array
    i32                     ind_fwddecl_n;                            // number of elements in the hash table
    amc::FTfunc*            tfunc_lary[32];                           // level array
    i32                     tfunc_n;                                  // number of elements in array
    amc::FTfunc**           ind_tfunc_buckets_elems;                  // pointer to bucket array
    i32                     ind_tfunc_buckets_n;                      // number of elements in bucket array
    i32                     ind_tfunc_n;                              // number of elements in the hash table
    amc::FGen*              gen_lary[32];                             // level array
    i32                     gen_n;                                    // number of elements in array
    amc::FNs*               c_curns;                                  // optional pointer
    amc::FFregx*            fregx_lary[32];                           // level array
    i32                     fregx_n;                                  // number of elements in array
    u128                    tclass_data[sizeu128(amc::FTclass,51)];   // place for data
    i32                     tclass_n;                                 // number of elems current in existence
    enum { tclass_max = 51 };
    amc::FTclass**          ind_tclass_buckets_elems;                 // pointer to bucket array
    i32                     ind_tclass_buckets_n;                     // number of elements in bucket array
    i32                     ind_tclass_n;                             // number of elements in the hash table
    amc::FFcmp*             fcmp_lary[32];                            // level array
    i32                     fcmp_n;                                   // number of elements in array
    amc::FFcast*            fcast_lary[32];                           // level array
    i32                     fcast_n;                                  // number of elements in array
    amc::FNoxref*           noxref_lary[32];                          // level array
    i32                     noxref_n;                                 // number of elements in array
    amc::FNocascdel*        nocascdel_lary[32];                       // level array
    i32                     nocascdel_n;                              // number of elements in array
    amc::FCafter*           cafter_lary[32];                          // level array
    i32                     cafter_n;                                 // number of elements in array
    amc::FCsize*            csize_lary[32];                           // level array
    i32                     csize_n;                                  // number of elements in array
    amc::FNsx*              nsx_lary[32];                             // level array
    i32                     nsx_n;                                    // number of elements in array
    report::amc             report;                                   // Final report
    amc::FFcompact*         fcompact_lary[32];                        // level array
    i32                     fcompact_n;                               // number of elements in array
    amc::FFindrem*          findrem_lary[32];                         // level array
    i32                     findrem_n;                                // number of elements in array
    amc::FFcurs*            fcurs_lary[32];                           // level array
    i32                     fcurs_n;                                  // number of elements in array
    amc::FCdflt*            cdflt_lary[32];                           // level array
    i32                     cdflt_n;                                  // number of elements in array
    amc::FArgvtype*         argvtype_lary[32];                        // level array
    i32                     argvtype_n;                               // number of elements in array
    amc::FFcmdline*         fcmdline_lary[32];                        // level array
    i32                     fcmdline_n;                               // number of elements in array
    amc::FMain**            ind_main_buckets_elems;                   // pointer to bucket array
    i32                     ind_main_buckets_n;                       // number of elements in bucket array
    i32                     ind_main_n;                               // number of elements in the hash table
    amc::FFloadtuples*      floadtuples_lary[32];                     // level array
    i32                     floadtuples_n;                            // number of elements in array
    amc::FFcmap*            fcmap_lary[32];                           // level array
    i32                     fcmap_n;                                  // number of elements in array
    u32                     lim_ind_func;                             //   0  Limit for ind_func table, used to enforce function creation
    amc::FField*            zs_ordkeyfield_head;                      // zero-terminated singly linked list
    amc::FField*            zs_ordkeyfield_tail;                      // pointer to last element
    algo_lib::FLockfile     lockfile;                                 // Prevent concurrent execution
    amc::FNsproto*          nsproto_lary[32];                         // level array
    i32                     nsproto_n;                                // number of elements in array
    amc::FNsdb*             nsdb_lary[32];                            // level array
    i32                     nsdb_n;                                   // number of elements in array
    amc::FSubstr*           zd_substr_params_head;                    // zero-terminated doubly linked list
    i32                     zd_substr_params_n;                       // zero-terminated doubly linked list
    amc::FSubstr*           zd_substr_params_tail;                    // pointer to last element
    amc::FFconst**          ind_fconst_int_buckets_elems;             // pointer to bucket array
    i32                     ind_fconst_int_buckets_n;                 // number of elements in bucket array
    i32                     ind_fconst_int_n;                         // number of elements in the hash table
    amc::FFprefix*          fprefix_lary[32];                         // level array
    i32                     fprefix_n;                                // number of elements in array
    amc::FFprefix**         ind_prefix_buckets_elems;                 // pointer to bucket array
    i32                     ind_prefix_buckets_n;                     // number of elements in bucket array
    i32                     ind_prefix_n;                             // number of elements in the hash table
    amc::FFtrace*           ftrace_lary[32];                          // level array
    i32                     ftrace_n;                                 // number of elements in array
    amc::FNs*               c_ns;                                     // optional pointer
    amc::FFnoremove*        fnoremove_lary[32];                       // level array
    i32                     fnoremove_n;                              // number of elements in array
    amc::FSubstr**          c_substr_field_elems;                     // array of pointers
    u32                     c_substr_field_n;                         // array of pointers
    u32                     c_substr_field_max;                       // capacity of allocated array
    amc::FCtypelen*         ctypelen_lary[32];                        // level array
    i32                     ctypelen_n;                               // number of elements in array
    amc::FCtypelen**        c_ctypelen_elems;                         // array of pointers
    u32                     c_ctypelen_n;                             // array of pointers
    u32                     c_ctypelen_max;                           // capacity of allocated array
    amc::FCtype*            c_u64;                                    // optional pointer
    amc::FField**           c_tempfield_elems;                        // array of pointers
    u32                     c_tempfield_n;                            // array of pointers
    u32                     c_tempfield_max;                          // capacity of allocated array
    amc::FFbase*            fbase_lary[32];                           // level array
    i32                     fbase_n;                                  // number of elements in array
    amc::FFcmap**           ind_fcmap_buckets_elems;                  // pointer to bucket array
    i32                     ind_fcmap_buckets_n;                      // number of elements in bucket array
    i32                     ind_fcmap_n;                              // number of elements in the hash table
    amc::FNossimfile*       nossimfile_lary[32];                      // level array
    i32                     nossimfile_n;                             // number of elements in array
    amc::FGsymbol*          gsymbol_lary[32];                         // level array
    i32                     gsymbol_n;                                // number of elements in array
    amc::FSortfld*          sortfld_lary[32];                         // level array
    i32                     sortfld_n;                                // number of elements in array
    amc::FCget*             cget_lary[32];                            // level array
    i32                     cget_n;                                   // number of elements in array
    amc::FFunc*             cd_temp_func_head;                        // zero-terminated doubly linked list
    i32                     cd_temp_func_n;                           // zero-terminated doubly linked list
    amc::FGen*              zs_gen_perns_head;                        // zero-terminated singly linked list
    amc::FGen*              zs_gen_perns_tail;                        // pointer to last element
    amc::FHook*             hook_lary[32];                            // level array
    i32                     hook_n;                                   // number of elements in array
    amc::FCharset*          charset_lary[32];                         // level array
    i32                     charset_n;                                // number of elements in array
    algo::Charset           ValidRnumPad;                             //
    amc::FNsinclude*        nsinclude_lary[32];                       // level array
    i32                     nsinclude_n;                              // number of elements in array
    amc::FSsimvolatile*     ssimvolatile_lary[32];                    // level array
    i32                     ssimvolatile_n;                           // number of elements in array
    amc::FFunique*          funique_lary[32];                         // level array
    i32                     funique_n;                                // number of elements in array
    amc::FFuserinit*        fuserinit_lary[32];                       // level array
    i32                     fuserinit_n;                              // number of elements in array
    amc::FFcurs**           ind_fcurs_buckets_elems;                  // pointer to bucket array
    i32                     ind_fcurs_buckets_n;                      // number of elements in bucket array
    i32                     ind_fcurs_n;                              // number of elements in the hash table
    amc::FTcurs*            tcurs_lary[32];                           // level array
    i32                     tcurs_n;                                  // number of elements in array
    algo::cstring           cur_gen;                                  //
    bool                    has_ams_fwd_declare;                      //   false
    amc::FNscpp*            nscpp_lary[32];                           // level array
    i32                     nscpp_n;                                  // number of elements in array
    amc::FFflag*            fflag_lary[32];                           // level array
    i32                     fflag_n;                                  // number of elements in array
    amc::FFflag**           ind_fflag_buckets_elems;                  // pointer to bucket array
    i32                     ind_fflag_buckets_n;                      // number of elements in bucket array
    i32                     ind_fflag_n;                              // number of elements in the hash table
    amc::FFalias*           falias_lary[32];                          // level array
    i32                     falias_n;                                 // number of elements in array
    algo::cstring           copyright;                                //
    amc::FLicense*          license_lary[32];                         // level array
    i32                     license_n;                                // number of elements in array
    amc::FLicense**         ind_license_buckets_elems;                // pointer to bucket array
    i32                     ind_license_buckets_n;                    // number of elements in bucket array
    i32                     ind_license_n;                            // number of elements in the hash table
    amc::FSsimfile**        c_ssimfile_sorted_elems;                  // array of pointers
    u32                     c_ssimfile_sorted_n;                      // array of pointers
    u32                     c_ssimfile_sorted_max;                    // capacity of allocated array
    amc::FSsimfile*         zd_ssimfile_todo_head;                    // zero-terminated doubly linked list
    i32                     zd_ssimfile_todo_n;                       // zero-terminated doubly linked list
    amc::FSsimfile*         zd_ssimfile_todo_tail;                    // pointer to last element
    amc::FCfast*            cfast_lary[32];                           // level array
    i32                     cfast_n;                                  // number of elements in array
    amc::FFfast*            ffast_lary[32];                           // level array
    i32                     ffast_n;                                  // number of elements in array
    amc::FPmaskfldMember*   pmaskfld_member_lary[32];                 // level array
    i32                     pmaskfld_member_n;                        // number of elements in array
    amc::FPmaskfld**        ind_pmaskfld_buckets_elems;               // pointer to bucket array
    i32                     ind_pmaskfld_buckets_n;                   // number of elements in bucket array
    i32                     ind_pmaskfld_n;                           // number of elements in the hash table
    amc::FSsimsort*         ssimsort_lary[32];                        // level array
    i32                     ssimsort_n;                               // number of elements in array
    amc::trace              trace;                                    //
};

// Free block of memory previously returned by Lpool.
// func:amc.FDb.lpool.FreeMem
void                 lpool_FreeMem(void* mem, u64 size) __attribute__((nothrow));
// Allocate new piece of memory at least SIZE bytes long.
// If not successful, return NULL
// The allocated block is at least 1<<4
// The maximum allocation size is at most 1<<(36+4)
// func:amc.FDb.lpool.AllocMem
void*                lpool_AllocMem(u64 size) __attribute__((__warn_unused_result__, nothrow));
// Add N buffers of some size to the free store
// Reserve NBUF buffers of size BUFSIZE from the base pool (algo_lib::sbrk)
// func:amc.FDb.lpool.ReserveBuffers
bool                 lpool_ReserveBuffers(u64 nbuf, u64 bufsize) __attribute__((nothrow));
// Allocate new block, copy old to new, delete old.
// If the new size is same as old size, do nothing.
// In all other cases, new memory is allocated (i.e. size reduction is not a no-op)
// If no memory, return NULL; old memory remains untouched
// func:amc.FDb.lpool.ReallocMem
void*                lpool_ReallocMem(void* oldmem, u64 old_size, u64 new_size) __attribute__((nothrow));
// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.lpool.Alloc
u8&                  lpool_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.lpool.AllocMaybe
u8*                  lpool_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:amc.FDb.lpool.Delete
void                 lpool_Delete(u8 &row) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fsort.Alloc
amc::FFsort&         fsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fsort.AllocMaybe
amc::FFsort*         fsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fsort.InsertMaybe
amc::FFsort*         fsort_InsertMaybe(const dmmeta::Fsort &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fsort.AllocMem
void*                fsort_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fsort.EmptyQ
inline bool          fsort_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fsort.Find
inline amc::FFsort*  fsort_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fsort.Last
inline amc::FFsort*  fsort_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fsort.N
inline i32           fsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fsort.RemoveLast
void                 fsort_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fsort.qFind
inline amc::FFsort&  fsort_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fsort.XrefMaybe
bool                 fsort_XrefMaybe(amc::FFsort &row);

// Return true if hash is empty
// func:amc.FDb.ind_cfmt.EmptyQ
inline bool          ind_cfmt_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_cfmt.Find
amc::FCfmt*          ind_cfmt_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_cfmt.GetOrCreate
amc::FCfmt&          ind_cfmt_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_cfmt.N
inline i32           ind_cfmt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_cfmt.InsertMaybe
bool                 ind_cfmt_InsertMaybe(amc::FCfmt& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_cfmt.Remove
void                 ind_cfmt_Remove(amc::FCfmt& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_cfmt.Reserve
void                 ind_cfmt_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.dispfilter.Alloc
amc::FDispfilter&    dispfilter_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.dispfilter.AllocMaybe
amc::FDispfilter*    dispfilter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.dispfilter.InsertMaybe
amc::FDispfilter*    dispfilter_InsertMaybe(const dmmeta::Dispfilter &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.dispfilter.AllocMem
void*                dispfilter_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.dispfilter.EmptyQ
inline bool          dispfilter_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.dispfilter.Find
inline amc::FDispfilter* dispfilter_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.dispfilter.Last
inline amc::FDispfilter* dispfilter_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.dispfilter.N
inline i32           dispfilter_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.dispfilter.RemoveLast
void                 dispfilter_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.dispfilter.qFind
inline amc::FDispfilter& dispfilter_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.dispfilter.XrefMaybe
bool                 dispfilter_XrefMaybe(amc::FDispfilter &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.usertracefld.Alloc
amc::FUsertracefld&  usertracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.usertracefld.AllocMaybe
amc::FUsertracefld*  usertracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.usertracefld.InsertMaybe
amc::FUsertracefld*  usertracefld_InsertMaybe(const dmmeta::Usertracefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.usertracefld.AllocMem
void*                usertracefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.usertracefld.EmptyQ
inline bool          usertracefld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.usertracefld.Find
inline amc::FUsertracefld* usertracefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.usertracefld.Last
inline amc::FUsertracefld* usertracefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.usertracefld.N
inline i32           usertracefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.usertracefld.RemoveLast
void                 usertracefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.usertracefld.qFind
inline amc::FUsertracefld& usertracefld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.usertracefld.XrefMaybe
bool                 usertracefld_XrefMaybe(amc::FUsertracefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cfmt.Alloc
amc::FCfmt&          cfmt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cfmt.AllocMaybe
amc::FCfmt*          cfmt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cfmt.InsertMaybe
amc::FCfmt*          cfmt_InsertMaybe(const dmmeta::Cfmt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cfmt.AllocMem
void*                cfmt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cfmt.EmptyQ
inline bool          cfmt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cfmt.Find
inline amc::FCfmt*   cfmt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cfmt.Last
inline amc::FCfmt*   cfmt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cfmt.N
inline i32           cfmt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cfmt.RemoveLast
void                 cfmt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cfmt.qFind
inline amc::FCfmt&   cfmt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cfmt.XrefMaybe
bool                 cfmt_XrefMaybe(amc::FCfmt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.dispatch.Alloc
amc::FDispatch&      dispatch_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.dispatch.AllocMaybe
amc::FDispatch*      dispatch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.dispatch.InsertMaybe
amc::FDispatch*      dispatch_InsertMaybe(const dmmeta::Dispatch &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.dispatch.AllocMem
void*                dispatch_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.dispatch.EmptyQ
inline bool          dispatch_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.dispatch.Find
inline amc::FDispatch* dispatch_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.dispatch.Last
inline amc::FDispatch* dispatch_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.dispatch.N
inline i32           dispatch_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.dispatch.RemoveLast
void                 dispatch_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.dispatch.qFind
inline amc::FDispatch& dispatch_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.dispatch.XrefMaybe
bool                 dispatch_XrefMaybe(amc::FDispatch &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.dispatch_msg.Alloc
amc::FDispatchmsg&   dispatch_msg_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.dispatch_msg.AllocMaybe
amc::FDispatchmsg*   dispatch_msg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.dispatch_msg.InsertMaybe
amc::FDispatchmsg*   dispatch_msg_InsertMaybe(const dmmeta::DispatchMsg &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.dispatch_msg.AllocMem
void*                dispatch_msg_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.dispatch_msg.EmptyQ
inline bool          dispatch_msg_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.dispatch_msg.Find
inline amc::FDispatchmsg* dispatch_msg_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.dispatch_msg.Last
inline amc::FDispatchmsg* dispatch_msg_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.dispatch_msg.N
inline i32           dispatch_msg_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.dispatch_msg.RemoveLast
void                 dispatch_msg_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.dispatch_msg.qFind
inline amc::FDispatchmsg& dispatch_msg_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.dispatch_msg.XrefMaybe
bool                 dispatch_msg_XrefMaybe(amc::FDispatchmsg &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ctype.Alloc
amc::FCtype&         ctype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ctype.AllocMaybe
amc::FCtype*         ctype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ctype.InsertMaybe
amc::FCtype*         ctype_InsertMaybe(const dmmeta::Ctype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ctype.AllocMem
void*                ctype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ctype.EmptyQ
inline bool          ctype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ctype.Find
inline amc::FCtype*  ctype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ctype.Last
inline amc::FCtype*  ctype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ctype.N
inline i32           ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ctype.RemoveLast
void                 ctype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ctype.qFind
inline amc::FCtype&  ctype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ctype.XrefMaybe
bool                 ctype_XrefMaybe(amc::FCtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.field.Alloc
amc::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.field.AllocMaybe
amc::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.field.InsertMaybe
amc::FField*         field_InsertMaybe(const dmmeta::Field &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.field.AllocMem
void*                field_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.field.EmptyQ
inline bool          field_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.field.Find
inline amc::FField*  field_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.field.Last
inline amc::FField*  field_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.field.N
inline i32           field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.field.RemoveLast
void                 field_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.field.qFind
inline amc::FField&  field_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.field.XrefMaybe
bool                 field_XrefMaybe(amc::FField &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.basepool.Alloc
amc::FBasepool&      basepool_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.basepool.AllocMaybe
amc::FBasepool*      basepool_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.basepool.InsertMaybe
amc::FBasepool*      basepool_InsertMaybe(const dmmeta::Basepool &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.basepool.AllocMem
void*                basepool_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.basepool.EmptyQ
inline bool          basepool_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.basepool.Find
inline amc::FBasepool* basepool_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.basepool.Last
inline amc::FBasepool* basepool_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.basepool.N
inline i32           basepool_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.basepool.RemoveLast
void                 basepool_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.basepool.qFind
inline amc::FBasepool& basepool_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.basepool.XrefMaybe
bool                 basepool_XrefMaybe(amc::FBasepool &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.llist.Alloc
amc::FLlist&         llist_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.llist.AllocMaybe
amc::FLlist*         llist_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.llist.InsertMaybe
amc::FLlist*         llist_InsertMaybe(const dmmeta::Llist &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.llist.AllocMem
void*                llist_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.llist.EmptyQ
inline bool          llist_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.llist.Find
inline amc::FLlist*  llist_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.llist.Last
inline amc::FLlist*  llist_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.llist.N
inline i32           llist_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.llist.RemoveLast
void                 llist_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.llist.qFind
inline amc::FLlist&  llist_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.llist.XrefMaybe
bool                 llist_XrefMaybe(amc::FLlist &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.anonfld.Alloc
amc::FAnonfld&       anonfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.anonfld.AllocMaybe
amc::FAnonfld*       anonfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.anonfld.InsertMaybe
amc::FAnonfld*       anonfld_InsertMaybe(const dmmeta::Anonfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.anonfld.AllocMem
void*                anonfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.anonfld.EmptyQ
inline bool          anonfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.anonfld.Find
inline amc::FAnonfld* anonfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.anonfld.Last
inline amc::FAnonfld* anonfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.anonfld.N
inline i32           anonfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.anonfld.RemoveLast
void                 anonfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.anonfld.qFind
inline amc::FAnonfld& anonfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.anonfld.XrefMaybe
bool                 anonfld_XrefMaybe(amc::FAnonfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.xref.Alloc
amc::FXref&          xref_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.xref.AllocMaybe
amc::FXref*          xref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.xref.InsertMaybe
amc::FXref*          xref_InsertMaybe(const dmmeta::Xref &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.xref.AllocMem
void*                xref_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.xref.EmptyQ
inline bool          xref_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.xref.Find
inline amc::FXref*   xref_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.xref.Last
inline amc::FXref*   xref_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.xref.N
inline i32           xref_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.xref.RemoveLast
void                 xref_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.xref.qFind
inline amc::FXref&   xref_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.xref.XrefMaybe
bool                 xref_XrefMaybe(amc::FXref &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ns.Alloc
amc::FNs&            ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ns.AllocMaybe
amc::FNs*            ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ns.InsertMaybe
amc::FNs*            ns_InsertMaybe(const dmmeta::Ns &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ns.AllocMem
void*                ns_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ns.EmptyQ
inline bool          ns_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ns.Find
inline amc::FNs*     ns_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ns.Last
inline amc::FNs*     ns_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ns.N
inline i32           ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ns.RemoveLast
void                 ns_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ns.qFind
inline amc::FNs&     ns_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ns.XrefMaybe
bool                 ns_XrefMaybe(amc::FNs &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.pnew.Alloc
amc::FPnew&          pnew_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.pnew.AllocMaybe
amc::FPnew*          pnew_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.pnew.InsertMaybe
amc::FPnew*          pnew_InsertMaybe(const dmmeta::Pnew &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.pnew.AllocMem
void*                pnew_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.pnew.EmptyQ
inline bool          pnew_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.pnew.Find
inline amc::FPnew*   pnew_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.pnew.Last
inline amc::FPnew*   pnew_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.pnew.N
inline i32           pnew_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.pnew.RemoveLast
void                 pnew_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.pnew.qFind
inline amc::FPnew&   pnew_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.pnew.XrefMaybe
bool                 pnew_XrefMaybe(amc::FPnew &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fldoffset.Alloc
amc::FFldoffset&     fldoffset_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fldoffset.AllocMaybe
amc::FFldoffset*     fldoffset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fldoffset.InsertMaybe
amc::FFldoffset*     fldoffset_InsertMaybe(const dmmeta::Fldoffset &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fldoffset.AllocMem
void*                fldoffset_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fldoffset.EmptyQ
inline bool          fldoffset_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fldoffset.Find
inline amc::FFldoffset* fldoffset_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fldoffset.Last
inline amc::FFldoffset* fldoffset_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fldoffset.N
inline i32           fldoffset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fldoffset.RemoveLast
void                 fldoffset_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fldoffset.qFind
inline amc::FFldoffset& fldoffset_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fldoffset.XrefMaybe
bool                 fldoffset_XrefMaybe(amc::FFldoffset &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.typefld.Alloc
amc::FTypefld&       typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.typefld.AllocMaybe
amc::FTypefld*       typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.typefld.InsertMaybe
amc::FTypefld*       typefld_InsertMaybe(const dmmeta::Typefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.typefld.AllocMem
void*                typefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.typefld.EmptyQ
inline bool          typefld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.typefld.Find
inline amc::FTypefld* typefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.typefld.Last
inline amc::FTypefld* typefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.typefld.N
inline i32           typefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.typefld.RemoveLast
void                 typefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.typefld.qFind
inline amc::FTypefld& typefld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.typefld.XrefMaybe
bool                 typefld_XrefMaybe(amc::FTypefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.lenfld.Alloc
amc::FLenfld&        lenfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.lenfld.AllocMaybe
amc::FLenfld*        lenfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.lenfld.InsertMaybe
amc::FLenfld*        lenfld_InsertMaybe(const dmmeta::Lenfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.lenfld.AllocMem
void*                lenfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.lenfld.EmptyQ
inline bool          lenfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.lenfld.Find
inline amc::FLenfld* lenfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.lenfld.Last
inline amc::FLenfld* lenfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.lenfld.N
inline i32           lenfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.lenfld.RemoveLast
void                 lenfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.lenfld.qFind
inline amc::FLenfld& lenfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.lenfld.XrefMaybe
bool                 lenfld_XrefMaybe(amc::FLenfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.bltin.Alloc
amc::FBltin&         bltin_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.bltin.AllocMaybe
amc::FBltin*         bltin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.bltin.InsertMaybe
amc::FBltin*         bltin_InsertMaybe(const amcdb::Bltin &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.bltin.AllocMem
void*                bltin_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.bltin.EmptyQ
inline bool          bltin_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.bltin.Find
inline amc::FBltin*  bltin_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.bltin.Last
inline amc::FBltin*  bltin_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.bltin.N
inline i32           bltin_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.bltin.RemoveLast
void                 bltin_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.bltin.qFind
inline amc::FBltin&  bltin_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.bltin.XrefMaybe
bool                 bltin_XrefMaybe(amc::FBltin &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.static_tuple.Alloc
amc::FStatictuple&   static_tuple_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.static_tuple.AllocMaybe
amc::FStatictuple*   static_tuple_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.static_tuple.AllocMem
void*                static_tuple_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.static_tuple.EmptyQ
inline bool          static_tuple_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.static_tuple.Find
inline amc::FStatictuple* static_tuple_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.static_tuple.Last
inline amc::FStatictuple* static_tuple_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.static_tuple.N
inline i32           static_tuple_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.static_tuple.RemoveAll
void                 static_tuple_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.static_tuple.RemoveLast
void                 static_tuple_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.static_tuple.qFind
inline amc::FStatictuple& static_tuple_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.static_tuple.XrefMaybe
bool                 static_tuple_XrefMaybe(amc::FStatictuple &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.msgtype.Alloc
amc::FMsgtype&       msgtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.msgtype.AllocMaybe
amc::FMsgtype*       msgtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.msgtype.InsertMaybe
amc::FMsgtype*       msgtype_InsertMaybe(const dmmeta::Msgtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.msgtype.AllocMem
void*                msgtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.msgtype.EmptyQ
inline bool          msgtype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.msgtype.Find
inline amc::FMsgtype* msgtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.msgtype.Last
inline amc::FMsgtype* msgtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.msgtype.N
inline i32           msgtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.msgtype.RemoveLast
void                 msgtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.msgtype.qFind
inline amc::FMsgtype& msgtype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.msgtype.XrefMaybe
bool                 msgtype_XrefMaybe(amc::FMsgtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.gconst.Alloc
amc::FGconst&        gconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.gconst.AllocMaybe
amc::FGconst*        gconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.gconst.InsertMaybe
amc::FGconst*        gconst_InsertMaybe(const dmmeta::Gconst &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.gconst.AllocMem
void*                gconst_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.gconst.EmptyQ
inline bool          gconst_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.gconst.Find
inline amc::FGconst* gconst_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.gconst.Last
inline amc::FGconst* gconst_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.gconst.N
inline i32           gconst_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.gconst.RemoveLast
void                 gconst_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.gconst.qFind
inline amc::FGconst& gconst_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.gconst.XrefMaybe
bool                 gconst_XrefMaybe(amc::FGconst &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.gstatic.Alloc
amc::FGstatic&       gstatic_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.gstatic.AllocMaybe
amc::FGstatic*       gstatic_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.gstatic.InsertMaybe
amc::FGstatic*       gstatic_InsertMaybe(const dmmeta::Gstatic &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.gstatic.AllocMem
void*                gstatic_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.gstatic.EmptyQ
inline bool          gstatic_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.gstatic.Find
inline amc::FGstatic* gstatic_Find(u32 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.gstatic.Last
inline amc::FGstatic* gstatic_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.gstatic.N
inline i32           gstatic_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.gstatic.RemoveLast
void                 gstatic_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.gstatic.qFind
inline amc::FGstatic& gstatic_qFind(u32 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.gstatic.XrefMaybe
bool                 gstatic_XrefMaybe(amc::FGstatic &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.thash.Alloc
amc::FThash&         thash_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.thash.AllocMaybe
amc::FThash*         thash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.thash.InsertMaybe
amc::FThash*         thash_InsertMaybe(const dmmeta::Thash &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.thash.AllocMem
void*                thash_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.thash.EmptyQ
inline bool          thash_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.thash.Find
inline amc::FThash*  thash_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.thash.Last
inline amc::FThash*  thash_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.thash.N
inline i32           thash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.thash.RemoveLast
void                 thash_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.thash.qFind
inline amc::FThash&  thash_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.thash.XrefMaybe
bool                 thash_XrefMaybe(amc::FThash &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.outfile.Alloc
amc::FOutfile&       outfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.outfile.AllocMaybe
amc::FOutfile*       outfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:amc.FDb.outfile.Delete
void                 outfile_Delete(amc::FOutfile &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:amc.FDb.outfile.AllocMem
void*                outfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:amc.FDb.outfile.FreeMem
void                 outfile_FreeMem(amc::FOutfile &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:amc.FDb.outfile.Reserve
u64                  outfile_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:amc.FDb.outfile.ReserveMem
u64                  outfile_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.outfile.XrefMaybe
bool                 outfile_XrefMaybe(amc::FOutfile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.func.Alloc
amc::FFunc&          func_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.func.AllocMaybe
amc::FFunc*          func_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.func.InsertMaybe
amc::FFunc*          func_InsertMaybe(const dmmeta::Func &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.func.AllocMem
void*                func_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.func.EmptyQ
inline bool          func_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.func.Find
inline amc::FFunc*   func_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.func.Last
inline amc::FFunc*   func_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.func.N
inline i32           func_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.func.RemoveLast
void                 func_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.func.qFind
inline amc::FFunc&   func_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.func.XrefMaybe
bool                 func_XrefMaybe(amc::FFunc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.smallstr.Alloc
amc::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.smallstr.AllocMaybe
amc::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.smallstr.InsertMaybe
amc::FSmallstr*      smallstr_InsertMaybe(const dmmeta::Smallstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.smallstr.AllocMem
void*                smallstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.smallstr.EmptyQ
inline bool          smallstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.smallstr.Find
inline amc::FSmallstr* smallstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.smallstr.Last
inline amc::FSmallstr* smallstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.smallstr.N
inline i32           smallstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.smallstr.RemoveLast
void                 smallstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.smallstr.qFind
inline amc::FSmallstr& smallstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.smallstr.XrefMaybe
bool                 smallstr_XrefMaybe(amc::FSmallstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.numstr.Alloc
amc::FNumstr&        numstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.numstr.AllocMaybe
amc::FNumstr*        numstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.numstr.InsertMaybe
amc::FNumstr*        numstr_InsertMaybe(const dmmeta::Numstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.numstr.AllocMem
void*                numstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.numstr.EmptyQ
inline bool          numstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.numstr.Find
inline amc::FNumstr* numstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.numstr.Last
inline amc::FNumstr* numstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.numstr.N
inline i32           numstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.numstr.RemoveLast
void                 numstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.numstr.qFind
inline amc::FNumstr& numstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.numstr.XrefMaybe
bool                 numstr_XrefMaybe(amc::FNumstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.main.Alloc
amc::FMain&          main_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.main.AllocMaybe
amc::FMain*          main_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.main.InsertMaybe
amc::FMain*          main_InsertMaybe(const dmmeta::Main &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.main.AllocMem
void*                main_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.main.EmptyQ
inline bool          main_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.main.Find
inline amc::FMain*   main_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.main.Last
inline amc::FMain*   main_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.main.N
inline i32           main_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.main.RemoveLast
void                 main_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.main.qFind
inline amc::FMain&   main_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.main.XrefMaybe
bool                 main_XrefMaybe(amc::FMain &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.reftype.Alloc
amc::FReftype&       reftype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.reftype.AllocMaybe
amc::FReftype*       reftype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.reftype.InsertMaybe
amc::FReftype*       reftype_InsertMaybe(const dmmeta::Reftype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.reftype.AllocMem
void*                reftype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.reftype.EmptyQ
inline bool          reftype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.reftype.Find
inline amc::FReftype* reftype_Find(i32 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.reftype.Last
inline amc::FReftype* reftype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.reftype.N
inline i32           reftype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.reftype.RemoveAll
void                 reftype_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.reftype.RemoveLast
void                 reftype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.reftype.qFind
inline amc::FReftype& reftype_qFind(i32 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.reftype.XrefMaybe
bool                 reftype_XrefMaybe(amc::FReftype &row);

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     amc.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:amc.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
// func:amc.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:amc.FDb._db.Step
void                 Step();
// Main function
// func:amc.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:amc.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:amc.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:amc.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:amc.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Save ssim data to given directory.
// func:amc.FDb._db.SaveTuples
u32                  SaveTuples(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
// func:amc.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:amc.FDb._db.Steps
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();

// Return true if hash is empty
// func:amc.FDb.ind_bltin.EmptyQ
inline bool          ind_bltin_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_bltin.Find
amc::FBltin*         ind_bltin_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_bltin.GetOrCreate
amc::FBltin&         ind_bltin_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_bltin.N
inline i32           ind_bltin_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_bltin.InsertMaybe
bool                 ind_bltin_InsertMaybe(amc::FBltin& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_bltin.Remove
void                 ind_bltin_Remove(amc::FBltin& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_bltin.Reserve
void                 ind_bltin_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_ctype.EmptyQ
inline bool          ind_ctype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_ctype.Find
amc::FCtype*         ind_ctype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_ctype.GetOrCreate
amc::FCtype&         ind_ctype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_ctype.N
inline i32           ind_ctype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_ctype.InsertMaybe
bool                 ind_ctype_InsertMaybe(amc::FCtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_ctype.Remove
void                 ind_ctype_Remove(amc::FCtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_ctype.Reserve
void                 ind_ctype_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_dispatch.EmptyQ
inline bool          ind_dispatch_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_dispatch.Find
amc::FDispatch*      ind_dispatch_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_dispatch.GetOrCreate
amc::FDispatch&      ind_dispatch_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_dispatch.N
inline i32           ind_dispatch_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_dispatch.InsertMaybe
bool                 ind_dispatch_InsertMaybe(amc::FDispatch& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_dispatch.Remove
void                 ind_dispatch_Remove(amc::FDispatch& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_dispatch.Reserve
void                 ind_dispatch_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_func.EmptyQ
inline bool          ind_func_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_func.Find
amc::FFunc*          ind_func_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_func.GetOrCreate
amc::FFunc&          ind_func_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_func.N
inline i32           ind_func_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_func.InsertMaybe
bool                 ind_func_InsertMaybe(amc::FFunc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_func.Remove
void                 ind_func_Remove(amc::FFunc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_func.Reserve
void                 ind_func_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_field.EmptyQ
inline bool          ind_field_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_field.Find
amc::FField*         ind_field_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_field.N
inline i32           ind_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_field.InsertMaybe
bool                 ind_field_InsertMaybe(amc::FField& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_field.Remove
void                 ind_field_Remove(amc::FField& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_field.Reserve
void                 ind_field_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_ns.EmptyQ
inline bool          ind_ns_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_ns.Find
amc::FNs*            ind_ns_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_ns.GetOrCreate
amc::FNs&            ind_ns_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_ns.N
inline i32           ind_ns_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_ns.InsertMaybe
bool                 ind_ns_InsertMaybe(amc::FNs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_ns.Remove
void                 ind_ns_Remove(amc::FNs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_ns.Reserve
void                 ind_ns_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_pnew.EmptyQ
inline bool          ind_pnew_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_pnew.Find
amc::FPnew*          ind_pnew_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_pnew.GetOrCreate
amc::FPnew&          ind_pnew_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_pnew.N
inline i32           ind_pnew_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_pnew.InsertMaybe
bool                 ind_pnew_InsertMaybe(amc::FPnew& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_pnew.Remove
void                 ind_pnew_Remove(amc::FPnew& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_pnew.Reserve
void                 ind_pnew_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_xref.EmptyQ
inline bool          ind_xref_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_xref.Find
amc::FXref*          ind_xref_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_xref.GetOrCreate
amc::FXref&          ind_xref_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_xref.N
inline i32           ind_xref_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_xref.InsertMaybe
bool                 ind_xref_InsertMaybe(amc::FXref& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_xref.Remove
void                 ind_xref_Remove(amc::FXref& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_xref.Reserve
void                 ind_xref_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cpptype.Alloc
amc::FCpptype&       cpptype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cpptype.AllocMaybe
amc::FCpptype*       cpptype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cpptype.InsertMaybe
amc::FCpptype*       cpptype_InsertMaybe(const dmmeta::Cpptype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cpptype.AllocMem
void*                cpptype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cpptype.EmptyQ
inline bool          cpptype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cpptype.Find
inline amc::FCpptype* cpptype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cpptype.Last
inline amc::FCpptype* cpptype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cpptype.N
inline i32           cpptype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cpptype.RemoveLast
void                 cpptype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cpptype.qFind
inline amc::FCpptype& cpptype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cpptype.XrefMaybe
bool                 cpptype_XrefMaybe(amc::FCpptype &row);

// Return true if hash is empty
// func:amc.FDb.ind_cpptype.EmptyQ
inline bool          ind_cpptype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_cpptype.Find
amc::FCpptype*       ind_cpptype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_cpptype.GetOrCreate
amc::FCpptype&       ind_cpptype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_cpptype.N
inline i32           ind_cpptype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_cpptype.InsertMaybe
bool                 ind_cpptype_InsertMaybe(amc::FCpptype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_cpptype.Remove
void                 ind_cpptype_Remove(amc::FCpptype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_cpptype.Reserve
void                 ind_cpptype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.inlary.Alloc
amc::FInlary&        inlary_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.inlary.AllocMaybe
amc::FInlary*        inlary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.inlary.InsertMaybe
amc::FInlary*        inlary_InsertMaybe(const dmmeta::Inlary &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.inlary.AllocMem
void*                inlary_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.inlary.EmptyQ
inline bool          inlary_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.inlary.Find
inline amc::FInlary* inlary_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.inlary.Last
inline amc::FInlary* inlary_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.inlary.N
inline i32           inlary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.inlary.RemoveLast
void                 inlary_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.inlary.qFind
inline amc::FInlary& inlary_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.inlary.XrefMaybe
bool                 inlary_XrefMaybe(amc::FInlary &row);

// Return true if hash is empty
// func:amc.FDb.ind_inlary.EmptyQ
inline bool          ind_inlary_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_inlary.Find
amc::FInlary*        ind_inlary_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_inlary.GetOrCreate
amc::FInlary&        ind_inlary_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_inlary.N
inline i32           ind_inlary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_inlary.InsertMaybe
bool                 ind_inlary_InsertMaybe(amc::FInlary& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_inlary.Remove
void                 ind_inlary_Remove(amc::FInlary& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_inlary.Reserve
void                 ind_inlary_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.tary.Alloc
amc::FTary&          tary_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.tary.AllocMaybe
amc::FTary*          tary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.tary.InsertMaybe
amc::FTary*          tary_InsertMaybe(const dmmeta::Tary &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.tary.AllocMem
void*                tary_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.tary.EmptyQ
inline bool          tary_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.tary.Find
inline amc::FTary*   tary_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.tary.Last
inline amc::FTary*   tary_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.tary.N
inline i32           tary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.tary.RemoveLast
void                 tary_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.tary.qFind
inline amc::FTary&   tary_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.tary.XrefMaybe
bool                 tary_XrefMaybe(amc::FTary &row);

// Return true if hash is empty
// func:amc.FDb.ind_tary.EmptyQ
inline bool          ind_tary_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_tary.Find
amc::FTary*          ind_tary_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_tary.GetOrCreate
amc::FTary&          ind_tary_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_tary.N
inline i32           ind_tary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_tary.InsertMaybe
bool                 ind_tary_InsertMaybe(amc::FTary& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_tary.Remove
void                 ind_tary_Remove(amc::FTary& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_tary.Reserve
void                 ind_tary_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cppfunc.Alloc
amc::FCppfunc&       cppfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cppfunc.AllocMaybe
amc::FCppfunc*       cppfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cppfunc.InsertMaybe
amc::FCppfunc*       cppfunc_InsertMaybe(const dmmeta::Cppfunc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cppfunc.AllocMem
void*                cppfunc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cppfunc.EmptyQ
inline bool          cppfunc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cppfunc.Find
inline amc::FCppfunc* cppfunc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cppfunc.Last
inline amc::FCppfunc* cppfunc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cppfunc.N
inline i32           cppfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cppfunc.RemoveLast
void                 cppfunc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cppfunc.qFind
inline amc::FCppfunc& cppfunc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cppfunc.XrefMaybe
bool                 cppfunc_XrefMaybe(amc::FCppfunc &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.rowid.Alloc
amc::FRowid&         rowid_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.rowid.AllocMaybe
amc::FRowid*         rowid_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.rowid.InsertMaybe
amc::FRowid*         rowid_InsertMaybe(const dmmeta::Rowid &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.rowid.AllocMem
void*                rowid_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.rowid.EmptyQ
inline bool          rowid_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.rowid.Find
inline amc::FRowid*  rowid_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.rowid.Last
inline amc::FRowid*  rowid_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.rowid.N
inline i32           rowid_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.rowid.RemoveLast
void                 rowid_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.rowid.qFind
inline amc::FRowid&  rowid_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.rowid.XrefMaybe
bool                 rowid_XrefMaybe(amc::FRowid &row);

// Return true if hash is empty
// func:amc.FDb.ind_rowid.EmptyQ
inline bool          ind_rowid_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_rowid.Find
amc::FRowid*         ind_rowid_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_rowid.GetOrCreate
amc::FRowid&         ind_rowid_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_rowid.N
inline i32           ind_rowid_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_rowid.InsertMaybe
bool                 ind_rowid_InsertMaybe(amc::FRowid& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_rowid.Remove
void                 ind_rowid_Remove(amc::FRowid& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_rowid.Reserve
void                 ind_rowid_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cascdel.Alloc
amc::FCascdel&       cascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cascdel.AllocMaybe
amc::FCascdel*       cascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cascdel.InsertMaybe
amc::FCascdel*       cascdel_InsertMaybe(const dmmeta::Cascdel &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cascdel.AllocMem
void*                cascdel_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cascdel.EmptyQ
inline bool          cascdel_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cascdel.Find
inline amc::FCascdel* cascdel_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cascdel.Last
inline amc::FCascdel* cascdel_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cascdel.N
inline i32           cascdel_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cascdel.RemoveLast
void                 cascdel_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cascdel.qFind
inline amc::FCascdel& cascdel_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cascdel.XrefMaybe
bool                 cascdel_XrefMaybe(amc::FCascdel &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.substr.Alloc
amc::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.substr.AllocMaybe
amc::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.substr.InsertMaybe
amc::FSubstr*        substr_InsertMaybe(const dmmeta::Substr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.substr.AllocMem
void*                substr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.substr.EmptyQ
inline bool          substr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.substr.Find
inline amc::FSubstr* substr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.substr.Last
inline amc::FSubstr* substr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.substr.N
inline i32           substr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.substr.RemoveLast
void                 substr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.substr.qFind
inline amc::FSubstr& substr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.substr.XrefMaybe
bool                 substr_XrefMaybe(amc::FSubstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.bitfld.Alloc
amc::FBitfld&        bitfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.bitfld.AllocMaybe
amc::FBitfld*        bitfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.bitfld.InsertMaybe
amc::FBitfld*        bitfld_InsertMaybe(const dmmeta::Bitfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.bitfld.AllocMem
void*                bitfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.bitfld.EmptyQ
inline bool          bitfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.bitfld.Find
inline amc::FBitfld* bitfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.bitfld.Last
inline amc::FBitfld* bitfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.bitfld.N
inline i32           bitfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.bitfld.RemoveLast
void                 bitfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.bitfld.qFind
inline amc::FBitfld& bitfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.bitfld.XrefMaybe
bool                 bitfld_XrefMaybe(amc::FBitfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ssimfile.Alloc
amc::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ssimfile.AllocMaybe
amc::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ssimfile.InsertMaybe
amc::FSsimfile*      ssimfile_InsertMaybe(const dmmeta::Ssimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ssimfile.AllocMem
void*                ssimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ssimfile.EmptyQ
inline bool          ssimfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ssimfile.Find
inline amc::FSsimfile* ssimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ssimfile.Last
inline amc::FSsimfile* ssimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ssimfile.N
inline i32           ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ssimfile.RemoveLast
void                 ssimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ssimfile.qFind
inline amc::FSsimfile& ssimfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ssimfile.XrefMaybe
bool                 ssimfile_XrefMaybe(amc::FSsimfile &row);

// Return true if hash is empty
// func:amc.FDb.ind_ssimfile.EmptyQ
inline bool          ind_ssimfile_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_ssimfile.Find
amc::FSsimfile*      ind_ssimfile_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_ssimfile.GetOrCreate
amc::FSsimfile&      ind_ssimfile_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_ssimfile.N
inline i32           ind_ssimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_ssimfile.InsertMaybe
bool                 ind_ssimfile_InsertMaybe(amc::FSsimfile& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_ssimfile.Remove
void                 ind_ssimfile_Remove(amc::FSsimfile& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_ssimfile.Reserve
void                 ind_ssimfile_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.pack.Alloc
amc::FPack&          pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.pack.AllocMaybe
amc::FPack*          pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.pack.InsertMaybe
amc::FPack*          pack_InsertMaybe(const dmmeta::Pack &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.pack.AllocMem
void*                pack_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.pack.EmptyQ
inline bool          pack_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.pack.Find
inline amc::FPack*   pack_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.pack.Last
inline amc::FPack*   pack_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.pack.N
inline i32           pack_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.pack.RemoveLast
void                 pack_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.pack.qFind
inline amc::FPack&   pack_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.pack.XrefMaybe
bool                 pack_XrefMaybe(amc::FPack &row);

// Return true if hash is empty
// func:amc.FDb.ind_pack.EmptyQ
inline bool          ind_pack_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_pack.Find
amc::FPack*          ind_pack_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_pack.GetOrCreate
amc::FPack&          ind_pack_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_pack.N
inline i32           ind_pack_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_pack.InsertMaybe
bool                 ind_pack_InsertMaybe(amc::FPack& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_pack.Remove
void                 ind_pack_Remove(amc::FPack& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_pack.Reserve
void                 ind_pack_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_smallstr.EmptyQ
inline bool          ind_smallstr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_smallstr.Find
amc::FSmallstr*      ind_smallstr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_smallstr.GetOrCreate
amc::FSmallstr&      ind_smallstr_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_smallstr.N
inline i32           ind_smallstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_smallstr.InsertMaybe
bool                 ind_smallstr_InsertMaybe(amc::FSmallstr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_smallstr.Remove
void                 ind_smallstr_Remove(amc::FSmallstr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_smallstr.Reserve
void                 ind_smallstr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ptrary.Alloc
amc::FPtrary&        ptrary_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ptrary.AllocMaybe
amc::FPtrary*        ptrary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ptrary.InsertMaybe
amc::FPtrary*        ptrary_InsertMaybe(const dmmeta::Ptrary &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ptrary.AllocMem
void*                ptrary_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ptrary.EmptyQ
inline bool          ptrary_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ptrary.Find
inline amc::FPtrary* ptrary_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ptrary.Last
inline amc::FPtrary* ptrary_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ptrary.N
inline i32           ptrary_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ptrary.RemoveLast
void                 ptrary_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ptrary.qFind
inline amc::FPtrary& ptrary_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ptrary.XrefMaybe
bool                 ptrary_XrefMaybe(amc::FPtrary &row);

// Return true if index is empty
// func:amc.FDb.c_ctype_sorted.EmptyQ
inline bool          c_ctype_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_ctype_sorted.Find
inline amc::FCtype*  c_ctype_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_ctype_sorted.Getary
inline algo::aryptr<amc::FCtype*> c_ctype_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_ctype_sorted.Insert
void                 c_ctype_sorted_Insert(amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_ctype_sorted.ScanInsertMaybe
bool                 c_ctype_sorted_ScanInsertMaybe(amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_ctype_sorted.N
inline i32           c_ctype_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_ctype_sorted.Remove
void                 c_ctype_sorted_Remove(amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_ctype_sorted.RemoveAll
inline void          c_ctype_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_ctype_sorted.Reserve
void                 c_ctype_sorted_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_ctype_sorted.qFind
inline amc::FCtype&  c_ctype_sorted_qFind(u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_ctype_sorted.qLast
inline amc::FCtype&  c_ctype_sorted_qLast() __attribute__((nothrow));
// Verify whether array is sorted
// func:amc.FDb.c_ctype_sorted.SortedQ
bool                 c_ctype_sorted_SortedQ() __attribute__((nothrow));
// Insertion sort
// func:amc.FDb.c_ctype_sorted.InsertionSort
void                 c_ctype_sorted_InsertionSort() __attribute__((nothrow));
// Heap sort
// func:amc.FDb.c_ctype_sorted.HeapSort
void                 c_ctype_sorted_HeapSort() __attribute__((nothrow));
// Quick sort
// func:amc.FDb.c_ctype_sorted.QuickSort
void                 c_ctype_sorted_QuickSort() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.enumstr.Alloc
amc::FEnumstr&       enumstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.enumstr.AllocMaybe
amc::FEnumstr*       enumstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.enumstr.AllocMem
void*                enumstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.enumstr.EmptyQ
inline bool          enumstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.enumstr.Find
inline amc::FEnumstr* enumstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.enumstr.Last
inline amc::FEnumstr* enumstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.enumstr.N
inline i32           enumstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.enumstr.RemoveAll
void                 enumstr_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.enumstr.RemoveLast
void                 enumstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.enumstr.qFind
inline amc::FEnumstr& enumstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.enumstr.XrefMaybe
bool                 enumstr_XrefMaybe(amc::FEnumstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.enumstr_len.Alloc
amc::FEnumstrLen&    enumstr_len_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.enumstr_len.AllocMaybe
amc::FEnumstrLen*    enumstr_len_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.enumstr_len.AllocMem
void*                enumstr_len_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.enumstr_len.EmptyQ
inline bool          enumstr_len_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.enumstr_len.Find
inline amc::FEnumstrLen* enumstr_len_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.enumstr_len.Last
inline amc::FEnumstrLen* enumstr_len_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.enumstr_len.N
inline i32           enumstr_len_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.enumstr_len.RemoveAll
void                 enumstr_len_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.enumstr_len.RemoveLast
void                 enumstr_len_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.enumstr_len.qFind
inline amc::FEnumstrLen& enumstr_len_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.enumstr_len.XrefMaybe
bool                 enumstr_len_XrefMaybe(amc::FEnumstrLen &row);

// Remove all elements from heap and free memory used by the array.
// func:amc.FDb.bh_enumstr_len.Dealloc
void                 bh_enumstr_len_Dealloc() __attribute__((nothrow));
// Return true if index is empty
// func:amc.FDb.bh_enumstr_len.EmptyQ
inline bool          bh_enumstr_len_EmptyQ() __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.bh_enumstr_len.First
inline amc::FEnumstrLen* bh_enumstr_len_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:amc.FDb.bh_enumstr_len.InBheapQ
inline bool          bh_enumstr_len_InBheapQ(amc::FEnumstrLen& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:amc.FDb.bh_enumstr_len.Insert
void                 bh_enumstr_len_Insert(amc::FEnumstrLen& row) __attribute__((nothrow));
// Return number of items in the heap
// func:amc.FDb.bh_enumstr_len.N
inline i32           bh_enumstr_len_N() __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:amc.FDb.bh_enumstr_len.Reheap
i32                  bh_enumstr_len_Reheap(amc::FEnumstrLen& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:amc.FDb.bh_enumstr_len.ReheapFirst
i32                  bh_enumstr_len_ReheapFirst() __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDb.bh_enumstr_len.Remove
void                 bh_enumstr_len_Remove(amc::FEnumstrLen& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:amc.FDb.bh_enumstr_len.RemoveAll
void                 bh_enumstr_len_RemoveAll() __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:amc.FDb.bh_enumstr_len.RemoveFirst
amc::FEnumstrLen*    bh_enumstr_len_RemoveFirst() __attribute__((nothrow));
// Reserve space in index for N more elements
// func:amc.FDb.bh_enumstr_len.Reserve
void                 bh_enumstr_len_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_enumstr_len.EmptyQ
inline bool          ind_enumstr_len_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_enumstr_len.Find
amc::FEnumstrLen*    ind_enumstr_len_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_enumstr_len.GetOrCreate
amc::FEnumstrLen&    ind_enumstr_len_GetOrCreate(i32 key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_enumstr_len.N
inline i32           ind_enumstr_len_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_enumstr_len.InsertMaybe
bool                 ind_enumstr_len_InsertMaybe(amc::FEnumstrLen& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_enumstr_len.Remove
void                 ind_enumstr_len_Remove(amc::FEnumstrLen& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_enumstr_len.Reserve
void                 ind_enumstr_len_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_enumstr.EmptyQ
inline bool          ind_enumstr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_enumstr.Find
amc::FEnumstr*       ind_enumstr_Find(const amc::Enumstr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_enumstr.GetOrCreate
amc::FEnumstr&       ind_enumstr_GetOrCreate(const amc::Enumstr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_enumstr.N
inline i32           ind_enumstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_enumstr.InsertMaybe
bool                 ind_enumstr_InsertMaybe(amc::FEnumstr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_enumstr.Remove
void                 ind_enumstr_Remove(amc::FEnumstr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_enumstr.Reserve
void                 ind_enumstr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fbitset.Alloc
amc::FFbitset&       fbitset_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fbitset.AllocMaybe
amc::FFbitset*       fbitset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fbitset.InsertMaybe
amc::FFbitset*       fbitset_InsertMaybe(const dmmeta::Fbitset &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fbitset.AllocMem
void*                fbitset_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fbitset.EmptyQ
inline bool          fbitset_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fbitset.Find
inline amc::FFbitset* fbitset_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fbitset.Last
inline amc::FFbitset* fbitset_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fbitset.N
inline i32           fbitset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fbitset.RemoveLast
void                 fbitset_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fbitset.qFind
inline amc::FFbitset& fbitset_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fbitset.XrefMaybe
bool                 fbitset_XrefMaybe(amc::FFbitset &row);

// Return true if hash is empty
// func:amc.FDb.ind_fbitset.EmptyQ
inline bool          ind_fbitset_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fbitset.Find
amc::FFbitset*       ind_fbitset_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fbitset.GetOrCreate
amc::FFbitset&       ind_fbitset_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fbitset.N
inline i32           ind_fbitset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fbitset.InsertMaybe
bool                 ind_fbitset_InsertMaybe(amc::FFbitset& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fbitset.Remove
void                 ind_fbitset_Remove(amc::FFbitset& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fbitset.Reserve
void                 ind_fbitset_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcleanup.Alloc
amc::FFcleanup&      fcleanup_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcleanup.AllocMaybe
amc::FFcleanup*      fcleanup_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcleanup.InsertMaybe
amc::FFcleanup*      fcleanup_InsertMaybe(const dmmeta::Fcleanup &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcleanup.AllocMem
void*                fcleanup_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcleanup.EmptyQ
inline bool          fcleanup_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcleanup.Find
inline amc::FFcleanup* fcleanup_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcleanup.Last
inline amc::FFcleanup* fcleanup_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcleanup.N
inline i32           fcleanup_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcleanup.RemoveLast
void                 fcleanup_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcleanup.qFind
inline amc::FFcleanup& fcleanup_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcleanup.XrefMaybe
bool                 fcleanup_XrefMaybe(amc::FFcleanup &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fdec.Alloc
amc::FFdec&          fdec_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fdec.AllocMaybe
amc::FFdec*          fdec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fdec.InsertMaybe
amc::FFdec*          fdec_InsertMaybe(const dmmeta::Fdec &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fdec.AllocMem
void*                fdec_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fdec.EmptyQ
inline bool          fdec_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fdec.Find
inline amc::FFdec*   fdec_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fdec.Last
inline amc::FFdec*   fdec_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fdec.N
inline i32           fdec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fdec.RemoveLast
void                 fdec_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fdec.qFind
inline amc::FFdec&   fdec_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fdec.XrefMaybe
bool                 fdec_XrefMaybe(amc::FFdec &row);

// Return true if hash is empty
// func:amc.FDb.ind_fdec.EmptyQ
inline bool          ind_fdec_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fdec.Find
amc::FFdec*          ind_fdec_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fdec.GetOrCreate
amc::FFdec&          ind_fdec_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fdec.N
inline i32           ind_fdec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fdec.InsertMaybe
bool                 ind_fdec_InsertMaybe(amc::FFdec& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fdec.Remove
void                 ind_fdec_Remove(amc::FFdec& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fdec.Reserve
void                 ind_fdec_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_reftype.EmptyQ
inline bool          ind_reftype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_reftype.Find
amc::FReftype*       ind_reftype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_reftype.GetOrCreate
amc::FReftype&       ind_reftype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_reftype.N
inline i32           ind_reftype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_reftype.InsertMaybe
bool                 ind_reftype_InsertMaybe(amc::FReftype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_reftype.Remove
void                 ind_reftype_Remove(amc::FReftype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_reftype.Reserve
void                 ind_reftype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fconst.Alloc
amc::FFconst&        fconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fconst.AllocMaybe
amc::FFconst*        fconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fconst.InsertMaybe
amc::FFconst*        fconst_InsertMaybe(const dmmeta::Fconst &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fconst.AllocMem
void*                fconst_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fconst.EmptyQ
inline bool          fconst_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fconst.Find
inline amc::FFconst* fconst_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fconst.Last
inline amc::FFconst* fconst_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fconst.N
inline i32           fconst_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fconst.RemoveLast
void                 fconst_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fconst.qFind
inline amc::FFconst& fconst_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fconst.XrefMaybe
bool                 fconst_XrefMaybe(amc::FFconst &row);

// Return true if hash is empty
// func:amc.FDb.ind_fconst.EmptyQ
inline bool          ind_fconst_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fconst.Find
amc::FFconst*        ind_fconst_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fconst.GetOrCreate
amc::FFconst&        ind_fconst_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fconst.N
inline i32           ind_fconst_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fconst.InsertMaybe
bool                 ind_fconst_InsertMaybe(amc::FFconst& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fconst.Remove
void                 ind_fconst_Remove(amc::FFconst& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fconst.Reserve
void                 ind_fconst_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FDb.c_ns_sorted.EmptyQ
inline bool          c_ns_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_ns_sorted.Find
inline amc::FNs*     c_ns_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_ns_sorted.Getary
inline algo::aryptr<amc::FNs*> c_ns_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_ns_sorted.Insert
void                 c_ns_sorted_Insert(amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_ns_sorted.ScanInsertMaybe
bool                 c_ns_sorted_ScanInsertMaybe(amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_ns_sorted.N
inline i32           c_ns_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_ns_sorted.Remove
void                 c_ns_sorted_Remove(amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_ns_sorted.RemoveAll
inline void          c_ns_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_ns_sorted.Reserve
void                 c_ns_sorted_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_ns_sorted.qFind
inline amc::FNs&     c_ns_sorted_qFind(u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_ns_sorted.qLast
inline amc::FNs&     c_ns_sorted_qLast() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.finput.Alloc
amc::FFinput&        finput_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.finput.AllocMaybe
amc::FFinput*        finput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.finput.InsertMaybe
amc::FFinput*        finput_InsertMaybe(const dmmeta::Finput &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.finput.AllocMem
void*                finput_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.finput.EmptyQ
inline bool          finput_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.finput.Find
inline amc::FFinput* finput_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.finput.Last
inline amc::FFinput* finput_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.finput.N
inline i32           finput_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.finput.RemoveLast
void                 finput_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.finput.qFind
inline amc::FFinput& finput_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.finput.XrefMaybe
bool                 finput_XrefMaybe(amc::FFinput &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.foutput.Alloc
amc::FFoutput&       foutput_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.foutput.AllocMaybe
amc::FFoutput*       foutput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.foutput.InsertMaybe
amc::FFoutput*       foutput_InsertMaybe(const dmmeta::Foutput &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.foutput.AllocMem
void*                foutput_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.foutput.EmptyQ
inline bool          foutput_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.foutput.Find
inline amc::FFoutput* foutput_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.foutput.Last
inline amc::FFoutput* foutput_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.foutput.N
inline i32           foutput_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.foutput.RemoveLast
void                 foutput_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.foutput.qFind
inline amc::FFoutput& foutput_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.foutput.XrefMaybe
bool                 foutput_XrefMaybe(amc::FFoutput &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fbuf.Alloc
amc::FFbuf&          fbuf_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fbuf.AllocMaybe
amc::FFbuf*          fbuf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fbuf.InsertMaybe
amc::FFbuf*          fbuf_InsertMaybe(const dmmeta::Fbuf &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fbuf.AllocMem
void*                fbuf_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fbuf.EmptyQ
inline bool          fbuf_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fbuf.Find
inline amc::FFbuf*   fbuf_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fbuf.Last
inline amc::FFbuf*   fbuf_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fbuf.N
inline i32           fbuf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fbuf.RemoveLast
void                 fbuf_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fbuf.qFind
inline amc::FFbuf&   fbuf_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fbuf.XrefMaybe
bool                 fbuf_XrefMaybe(amc::FFbuf &row);

// Return true if hash is empty
// func:amc.FDb.ind_fbuf.EmptyQ
inline bool          ind_fbuf_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fbuf.Find
amc::FFbuf*          ind_fbuf_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fbuf.GetOrCreate
amc::FFbuf&          ind_fbuf_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fbuf.N
inline i32           ind_fbuf_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fbuf.InsertMaybe
bool                 ind_fbuf_InsertMaybe(amc::FFbuf& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fbuf.Remove
void                 ind_fbuf_Remove(amc::FFbuf& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fbuf.Reserve
void                 ind_fbuf_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.chash.Alloc
amc::FChash&         chash_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.chash.AllocMaybe
amc::FChash*         chash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.chash.InsertMaybe
amc::FChash*         chash_InsertMaybe(const dmmeta::Chash &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.chash.AllocMem
void*                chash_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.chash.EmptyQ
inline bool          chash_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.chash.Find
inline amc::FChash*  chash_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.chash.Last
inline amc::FChash*  chash_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.chash.N
inline i32           chash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.chash.RemoveLast
void                 chash_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.chash.qFind
inline amc::FChash&  chash_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.chash.XrefMaybe
bool                 chash_XrefMaybe(amc::FChash &row);

// Return true if hash is empty
// func:amc.FDb.ind_chash.EmptyQ
inline bool          ind_chash_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_chash.Find
amc::FChash*         ind_chash_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_chash.GetOrCreate
amc::FChash&         ind_chash_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_chash.N
inline i32           ind_chash_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_chash.InsertMaybe
bool                 ind_chash_InsertMaybe(amc::FChash& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_chash.Remove
void                 ind_chash_Remove(amc::FChash& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_chash.Reserve
void                 ind_chash_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ccmp.Alloc
amc::FCcmp&          ccmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ccmp.AllocMaybe
amc::FCcmp*          ccmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ccmp.InsertMaybe
amc::FCcmp*          ccmp_InsertMaybe(const dmmeta::Ccmp &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ccmp.AllocMem
void*                ccmp_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ccmp.EmptyQ
inline bool          ccmp_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ccmp.Find
inline amc::FCcmp*   ccmp_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ccmp.Last
inline amc::FCcmp*   ccmp_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ccmp.N
inline i32           ccmp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ccmp.RemoveLast
void                 ccmp_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ccmp.qFind
inline amc::FCcmp&   ccmp_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ccmp.XrefMaybe
bool                 ccmp_XrefMaybe(amc::FCcmp &row);

// Return true if hash is empty
// func:amc.FDb.ind_ccmp.EmptyQ
inline bool          ind_ccmp_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_ccmp.Find
amc::FCcmp*          ind_ccmp_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_ccmp.GetOrCreate
amc::FCcmp&          ind_ccmp_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_ccmp.N
inline i32           ind_ccmp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_ccmp.InsertMaybe
bool                 ind_ccmp_InsertMaybe(amc::FCcmp& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_ccmp.Remove
void                 ind_ccmp_Remove(amc::FCcmp& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_ccmp.Reserve
void                 ind_ccmp_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fbigend.Alloc
amc::FFbigend&       fbigend_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fbigend.AllocMaybe
amc::FFbigend*       fbigend_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fbigend.InsertMaybe
amc::FFbigend*       fbigend_InsertMaybe(const dmmeta::Fbigend &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fbigend.AllocMem
void*                fbigend_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fbigend.EmptyQ
inline bool          fbigend_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fbigend.Find
inline amc::FFbigend* fbigend_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fbigend.Last
inline amc::FFbigend* fbigend_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fbigend.N
inline i32           fbigend_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fbigend.RemoveLast
void                 fbigend_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fbigend.qFind
inline amc::FFbigend& fbigend_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fbigend.XrefMaybe
bool                 fbigend_XrefMaybe(amc::FFbigend &row);

// Return true if index is empty
// func:amc.FDb.zsl_ctype_pack_tran.EmptyQ
inline bool          zsl_ctype_pack_tran_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.zsl_ctype_pack_tran.First
inline amc::FCtype*  zsl_ctype_pack_tran_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.zsl_ctype_pack_tran.InLlistQ
inline bool          zsl_ctype_pack_tran_InLlistQ(amc::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.zsl_ctype_pack_tran.Insert
void                 zsl_ctype_pack_tran_Insert(amc::FCtype& row) __attribute__((nothrow));
// Return pointer to next element in the list
// func:amc.FDb.zsl_ctype_pack_tran.Next
inline amc::FCtype*  zsl_ctype_pack_tran_Next(amc::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FDb.zsl_ctype_pack_tran.Remove
void                 zsl_ctype_pack_tran_Remove(amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.zsl_ctype_pack_tran.RemoveAll
void                 zsl_ctype_pack_tran_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.zsl_ctype_pack_tran.RemoveFirst
amc::FCtype*         zsl_ctype_pack_tran_RemoveFirst() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cstr.Alloc
amc::FCstr&          cstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cstr.AllocMaybe
amc::FCstr*          cstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cstr.InsertMaybe
amc::FCstr*          cstr_InsertMaybe(const dmmeta::Cstr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cstr.AllocMem
void*                cstr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cstr.EmptyQ
inline bool          cstr_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cstr.Find
inline amc::FCstr*   cstr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cstr.Last
inline amc::FCstr*   cstr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cstr.N
inline i32           cstr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cstr.RemoveLast
void                 cstr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cstr.qFind
inline amc::FCstr&   cstr_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cstr.XrefMaybe
bool                 cstr_XrefMaybe(amc::FCstr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.listtype.Alloc
amc::FListtype&      listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.listtype.AllocMaybe
amc::FListtype*      listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.listtype.InsertMaybe
amc::FListtype*      listtype_InsertMaybe(const dmmeta::Listtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.listtype.AllocMem
void*                listtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.listtype.EmptyQ
inline bool          listtype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.listtype.Find
inline amc::FListtype* listtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.listtype.Last
inline amc::FListtype* listtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.listtype.N
inline i32           listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.listtype.RemoveLast
void                 listtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.listtype.qFind
inline amc::FListtype& listtype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.listtype.XrefMaybe
bool                 listtype_XrefMaybe(amc::FListtype &row);

// Return true if hash is empty
// func:amc.FDb.ind_listtype.EmptyQ
inline bool          ind_listtype_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_listtype.Find
amc::FListtype*      ind_listtype_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_listtype.GetOrCreate
amc::FListtype&      ind_listtype_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_listtype.N
inline i32           ind_listtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_listtype.InsertMaybe
bool                 ind_listtype_InsertMaybe(amc::FListtype& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_listtype.Remove
void                 ind_listtype_Remove(amc::FListtype& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_listtype.Reserve
void                 ind_listtype_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fstep.Alloc
amc::FFstep&         fstep_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fstep.AllocMaybe
amc::FFstep*         fstep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fstep.InsertMaybe
amc::FFstep*         fstep_InsertMaybe(const dmmeta::Fstep &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fstep.AllocMem
void*                fstep_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fstep.EmptyQ
inline bool          fstep_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fstep.Find
inline amc::FFstep*  fstep_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fstep.Last
inline amc::FFstep*  fstep_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fstep.N
inline i32           fstep_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fstep.RemoveLast
void                 fstep_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fstep.qFind
inline amc::FFstep&  fstep_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fstep.XrefMaybe
bool                 fstep_XrefMaybe(amc::FFstep &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cextern.Alloc
amc::FCextern&       cextern_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cextern.AllocMaybe
amc::FCextern*       cextern_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cextern.InsertMaybe
amc::FCextern*       cextern_InsertMaybe(const dmmeta::Cextern &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cextern.AllocMem
void*                cextern_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cextern.EmptyQ
inline bool          cextern_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cextern.Find
inline amc::FCextern* cextern_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cextern.Last
inline amc::FCextern* cextern_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cextern.N
inline i32           cextern_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cextern.RemoveLast
void                 cextern_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cextern.qFind
inline amc::FCextern& cextern_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cextern.XrefMaybe
bool                 cextern_XrefMaybe(amc::FCextern &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fdelay.Alloc
amc::FFdelay&        fdelay_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fdelay.AllocMaybe
amc::FFdelay*        fdelay_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fdelay.InsertMaybe
amc::FFdelay*        fdelay_InsertMaybe(const dmmeta::Fdelay &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fdelay.AllocMem
void*                fdelay_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fdelay.EmptyQ
inline bool          fdelay_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fdelay.Find
inline amc::FFdelay* fdelay_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fdelay.Last
inline amc::FFdelay* fdelay_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fdelay.N
inline i32           fdelay_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fdelay.RemoveLast
void                 fdelay_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fdelay.qFind
inline amc::FFdelay& fdelay_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fdelay.XrefMaybe
bool                 fdelay_XrefMaybe(amc::FFdelay &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.disptrace.Alloc
amc::FDisptrace&     disptrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.disptrace.AllocMaybe
amc::FDisptrace*     disptrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.disptrace.InsertMaybe
amc::FDisptrace*     disptrace_InsertMaybe(const dmmeta::Disptrace &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.disptrace.AllocMem
void*                disptrace_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.disptrace.EmptyQ
inline bool          disptrace_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.disptrace.Find
inline amc::FDisptrace* disptrace_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.disptrace.Last
inline amc::FDisptrace* disptrace_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.disptrace.N
inline i32           disptrace_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.disptrace.RemoveLast
void                 disptrace_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.disptrace.qFind
inline amc::FDisptrace& disptrace_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.disptrace.XrefMaybe
bool                 disptrace_XrefMaybe(amc::FDisptrace &row);

// Return true if hash is empty
// func:amc.FDb.ind_fstep.EmptyQ
inline bool          ind_fstep_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fstep.Find
amc::FFstep*         ind_fstep_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fstep.GetOrCreate
amc::FFstep&         ind_fstep_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fstep.N
inline i32           ind_fstep_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fstep.InsertMaybe
bool                 ind_fstep_InsertMaybe(amc::FFstep& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fstep.Remove
void                 ind_fstep_Remove(amc::FFstep& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fstep.Reserve
void                 ind_fstep_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.tracefld.Alloc
amc::FTracefld&      tracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.tracefld.AllocMaybe
amc::FTracefld*      tracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.tracefld.InsertMaybe
amc::FTracefld*      tracefld_InsertMaybe(const dmmeta::Tracefld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.tracefld.AllocMem
void*                tracefld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.tracefld.EmptyQ
inline bool          tracefld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.tracefld.Find
inline amc::FTracefld* tracefld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.tracefld.Last
inline amc::FTracefld* tracefld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.tracefld.N
inline i32           tracefld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.tracefld.RemoveAll
void                 tracefld_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.tracefld.RemoveLast
void                 tracefld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.tracefld.qFind
inline amc::FTracefld& tracefld_qFind(u64 t) __attribute__((nothrow, pure));
// Save table to ssimfile
// func:amc.FDb.tracefld.SaveSsimfile
bool                 tracefld_SaveSsimfile(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.tracefld.XrefMaybe
bool                 tracefld_XrefMaybe(amc::FTracefld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.tracerec.Alloc
amc::FTracerec&      tracerec_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.tracerec.AllocMaybe
amc::FTracerec*      tracerec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.tracerec.InsertMaybe
amc::FTracerec*      tracerec_InsertMaybe(const dmmeta::Tracerec &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.tracerec.AllocMem
void*                tracerec_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.tracerec.EmptyQ
inline bool          tracerec_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.tracerec.Find
inline amc::FTracerec* tracerec_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.tracerec.Last
inline amc::FTracerec* tracerec_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.tracerec.N
inline i32           tracerec_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.tracerec.RemoveAll
void                 tracerec_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.tracerec.RemoveLast
void                 tracerec_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.tracerec.qFind
inline amc::FTracerec& tracerec_qFind(u64 t) __attribute__((nothrow, pure));
// Save table to ssimfile
// func:amc.FDb.tracerec.SaveSsimfile
bool                 tracerec_SaveSsimfile(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.tracerec.XrefMaybe
bool                 tracerec_XrefMaybe(amc::FTracerec &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.dispsig.Alloc
amc::FDispsig&       dispsig_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.dispsig.AllocMaybe
amc::FDispsig*       dispsig_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.dispsig.InsertMaybe
amc::FDispsig*       dispsig_InsertMaybe(const dmmeta::Dispsig &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.dispsig.AllocMem
void*                dispsig_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.dispsig.EmptyQ
inline bool          dispsig_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.dispsig.Find
inline amc::FDispsig* dispsig_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.dispsig.Last
inline amc::FDispsig* dispsig_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.dispsig.N
inline i32           dispsig_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.dispsig.RemoveAll
void                 dispsig_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.dispsig.RemoveLast
void                 dispsig_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.dispsig.qFind
inline amc::FDispsig& dispsig_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.dispsig.XrefMaybe
bool                 dispsig_XrefMaybe(amc::FDispsig &row);

// Return true if index is empty
// func:amc.FDb.c_dispsig_sorted.EmptyQ
inline bool          c_dispsig_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_dispsig_sorted.Find
inline amc::FDispsig* c_dispsig_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_dispsig_sorted.Getary
inline algo::aryptr<amc::FDispsig*> c_dispsig_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_dispsig_sorted.Insert
void                 c_dispsig_sorted_Insert(amc::FDispsig& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_dispsig_sorted.InsertMaybe
bool                 c_dispsig_sorted_InsertMaybe(amc::FDispsig& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_dispsig_sorted.N
inline i32           c_dispsig_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_dispsig_sorted.Remove
void                 c_dispsig_sorted_Remove(amc::FDispsig& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_dispsig_sorted.RemoveAll
inline void          c_dispsig_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_dispsig_sorted.Reserve
void                 c_dispsig_sorted_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_dispsig_sorted.qFind
inline amc::FDispsig& c_dispsig_sorted_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FDb.c_dispsig_sorted.InAryQ
inline bool          c_dispsig_sorted_InAryQ(amc::FDispsig& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_dispsig_sorted.qLast
inline amc::FDispsig& c_dispsig_sorted_qLast() __attribute__((nothrow));
// Verify whether array is sorted
// func:amc.FDb.c_dispsig_sorted.SortedQ
bool                 c_dispsig_sorted_SortedQ() __attribute__((nothrow));
// Insertion sort
// func:amc.FDb.c_dispsig_sorted.InsertionSort
void                 c_dispsig_sorted_InsertionSort() __attribute__((nothrow));
// Heap sort
// func:amc.FDb.c_dispsig_sorted.HeapSort
void                 c_dispsig_sorted_HeapSort() __attribute__((nothrow));
// Quick sort
// func:amc.FDb.c_dispsig_sorted.QuickSort
void                 c_dispsig_sorted_QuickSort() __attribute__((nothrow));
// Save table to ssimfile
// func:amc.FDb.c_dispsig_sorted.SaveSsimfile
bool                 c_dispsig_sorted_SaveSsimfile(algo::strptr fname) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FDb.zs_sig_visit.EmptyQ
inline bool          zs_sig_visit_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.zs_sig_visit.First
inline amc::FCtype*  zs_sig_visit_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.zs_sig_visit.InLlistQ
inline bool          zs_sig_visit_InLlistQ(amc::FCtype& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.zs_sig_visit.Insert
void                 zs_sig_visit_Insert(amc::FCtype& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FDb.zs_sig_visit.Last
inline amc::FCtype*  zs_sig_visit_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FDb.zs_sig_visit.Next
inline amc::FCtype*  zs_sig_visit_Next(amc::FCtype &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FDb.zs_sig_visit.Remove
void                 zs_sig_visit_Remove(amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.zs_sig_visit.RemoveAll
void                 zs_sig_visit_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.zs_sig_visit.RemoveFirst
amc::FCtype*         zs_sig_visit_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FDb.zs_sig_visit.qLast
inline amc::FCtype&  zs_sig_visit_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.target.Alloc
amc::FTarget&        target_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.target.AllocMaybe
amc::FTarget*        target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.target.InsertMaybe
amc::FTarget*        target_InsertMaybe(const dev::Target &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.target.AllocMem
void*                target_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.target.EmptyQ
inline bool          target_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.target.Find
inline amc::FTarget* target_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.target.Last
inline amc::FTarget* target_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.target.N
inline i32           target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.target.RemoveLast
void                 target_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.target.qFind
inline amc::FTarget& target_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.target.XrefMaybe
bool                 target_XrefMaybe(amc::FTarget &row);

// Return true if hash is empty
// func:amc.FDb.ind_target.EmptyQ
inline bool          ind_target_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_target.Find
amc::FTarget*        ind_target_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_target.GetOrCreate
amc::FTarget&        ind_target_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_target.N
inline i32           ind_target_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_target.InsertMaybe
bool                 ind_target_InsertMaybe(amc::FTarget& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_target.Remove
void                 ind_target_Remove(amc::FTarget& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_target.Reserve
void                 ind_target_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.targdep.Alloc
amc::FTargdep&       targdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.targdep.AllocMaybe
amc::FTargdep*       targdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.targdep.InsertMaybe
amc::FTargdep*       targdep_InsertMaybe(const dev::Targdep &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.targdep.AllocMem
void*                targdep_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.targdep.EmptyQ
inline bool          targdep_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.targdep.Find
inline amc::FTargdep* targdep_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.targdep.Last
inline amc::FTargdep* targdep_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.targdep.N
inline i32           targdep_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.targdep.RemoveLast
void                 targdep_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.targdep.qFind
inline amc::FTargdep& targdep_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.targdep.XrefMaybe
bool                 targdep_XrefMaybe(amc::FTargdep &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.dispctx.Alloc
amc::FDispctx&       dispctx_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.dispctx.AllocMaybe
amc::FDispctx*       dispctx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.dispctx.InsertMaybe
amc::FDispctx*       dispctx_InsertMaybe(const dmmeta::Dispctx &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.dispctx.AllocMem
void*                dispctx_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.dispctx.EmptyQ
inline bool          dispctx_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.dispctx.Find
inline amc::FDispctx* dispctx_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.dispctx.Last
inline amc::FDispctx* dispctx_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.dispctx.N
inline i32           dispctx_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.dispctx.RemoveLast
void                 dispctx_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.dispctx.qFind
inline amc::FDispctx& dispctx_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.dispctx.XrefMaybe
bool                 dispctx_XrefMaybe(amc::FDispctx &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.pmaskfld.Alloc
amc::FPmaskfld&      pmaskfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.pmaskfld.AllocMaybe
amc::FPmaskfld*      pmaskfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.pmaskfld.InsertMaybe
amc::FPmaskfld*      pmaskfld_InsertMaybe(const dmmeta::Pmaskfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.pmaskfld.AllocMem
void*                pmaskfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.pmaskfld.EmptyQ
inline bool          pmaskfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.pmaskfld.Find
inline amc::FPmaskfld* pmaskfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.pmaskfld.Last
inline amc::FPmaskfld* pmaskfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.pmaskfld.N
inline i32           pmaskfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.pmaskfld.RemoveLast
void                 pmaskfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.pmaskfld.qFind
inline amc::FPmaskfld& pmaskfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.pmaskfld.XrefMaybe
bool                 pmaskfld_XrefMaybe(amc::FPmaskfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fwddecl.Alloc
amc::FFwddecl&       fwddecl_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fwddecl.AllocMaybe
amc::FFwddecl*       fwddecl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fwddecl.InsertMaybe
amc::FFwddecl*       fwddecl_InsertMaybe(const dmmeta::Fwddecl &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fwddecl.AllocMem
void*                fwddecl_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fwddecl.EmptyQ
inline bool          fwddecl_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fwddecl.Find
inline amc::FFwddecl* fwddecl_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fwddecl.Last
inline amc::FFwddecl* fwddecl_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fwddecl.N
inline i32           fwddecl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fwddecl.RemoveLast
void                 fwddecl_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fwddecl.qFind
inline amc::FFwddecl& fwddecl_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fwddecl.XrefMaybe
bool                 fwddecl_XrefMaybe(amc::FFwddecl &row);

// Return true if hash is empty
// func:amc.FDb.ind_fwddecl.EmptyQ
inline bool          ind_fwddecl_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fwddecl.Find
amc::FFwddecl*       ind_fwddecl_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fwddecl.GetOrCreate
amc::FFwddecl&       ind_fwddecl_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fwddecl.N
inline i32           ind_fwddecl_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fwddecl.InsertMaybe
bool                 ind_fwddecl_InsertMaybe(amc::FFwddecl& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fwddecl.Remove
void                 ind_fwddecl_Remove(amc::FFwddecl& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fwddecl.Reserve
void                 ind_fwddecl_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.tfunc.Alloc
amc::FTfunc&         tfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.tfunc.AllocMaybe
amc::FTfunc*         tfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.tfunc.InsertMaybe
amc::FTfunc*         tfunc_InsertMaybe(const amcdb::Tfunc &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.tfunc.AllocMem
void*                tfunc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.tfunc.EmptyQ
inline bool          tfunc_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.tfunc.Find
inline amc::FTfunc*  tfunc_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.tfunc.Last
inline amc::FTfunc*  tfunc_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.tfunc.N
inline i32           tfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.tfunc.RemoveAll
void                 tfunc_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.tfunc.RemoveLast
void                 tfunc_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.tfunc.qFind
inline amc::FTfunc&  tfunc_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.tfunc.XrefMaybe
bool                 tfunc_XrefMaybe(amc::FTfunc &row);

// Return true if hash is empty
// func:amc.FDb.ind_tfunc.EmptyQ
inline bool          ind_tfunc_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_tfunc.Find
amc::FTfunc*         ind_tfunc_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_tfunc.GetOrCreate
amc::FTfunc&         ind_tfunc_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_tfunc.N
inline i32           ind_tfunc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_tfunc.InsertMaybe
bool                 ind_tfunc_InsertMaybe(amc::FTfunc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_tfunc.Remove
void                 ind_tfunc_Remove(amc::FTfunc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_tfunc.Reserve
void                 ind_tfunc_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.gen.Alloc
amc::FGen&           gen_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.gen.AllocMaybe
amc::FGen*           gen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.gen.InsertMaybe
amc::FGen*           gen_InsertMaybe(const amcdb::Gen &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.gen.AllocMem
void*                gen_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.gen.EmptyQ
inline bool          gen_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.gen.Find
inline amc::FGen*    gen_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.gen.Last
inline amc::FGen*    gen_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.gen.N
inline i32           gen_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.gen.RemoveAll
void                 gen_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.gen.RemoveLast
void                 gen_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.gen.qFind
inline amc::FGen&    gen_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.gen.XrefMaybe
bool                 gen_XrefMaybe(amc::FGen &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fregx.Alloc
amc::FFregx&         fregx_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fregx.AllocMaybe
amc::FFregx*         fregx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fregx.InsertMaybe
amc::FFregx*         fregx_InsertMaybe(const dmmeta::Fregx &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fregx.AllocMem
void*                fregx_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fregx.EmptyQ
inline bool          fregx_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fregx.Find
inline amc::FFregx*  fregx_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fregx.Last
inline amc::FFregx*  fregx_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fregx.N
inline i32           fregx_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fregx.RemoveLast
void                 fregx_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fregx.qFind
inline amc::FFregx&  fregx_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fregx.XrefMaybe
bool                 fregx_XrefMaybe(amc::FFregx &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.tclass.Alloc
amc::FTclass&        tclass_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.tclass.AllocMaybe
amc::FTclass*        tclass_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.tclass.InsertMaybe
amc::FTclass*        tclass_InsertMaybe(const amcdb::Tclass &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.tclass.AllocMem
inline void*         tclass_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.tclass.EmptyQ
inline bool          tclass_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.tclass.Find
inline amc::FTclass* tclass_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:amc.FDb.tclass.Getary
inline algo::aryptr<amc::FTclass> tclass_Getary() __attribute__((nothrow));
// Return constant 51 -- max. number of items in the pool
// func:amc.FDb.tclass.Max
inline i32           tclass_Max() __attribute__((nothrow));
// Return number of items in the array
// func:amc.FDb.tclass.N
inline i32           tclass_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Destroy all elements of Inlary
// func:amc.FDb.tclass.RemoveAll
void                 tclass_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.tclass.RemoveLast
void                 tclass_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking in release.
// func:amc.FDb.tclass.qFind
inline amc::FTclass& tclass_qFind(u64 t) __attribute__((nothrow));
// Compute row id of element given element's address
// func:amc.FDb.tclass.rowid_Get
inline u64           tclass_rowid_Get(amc::FTclass &row) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.tclass.XrefMaybe
bool                 tclass_XrefMaybe(amc::FTclass &row);

// Return true if hash is empty
// func:amc.FDb.ind_tclass.EmptyQ
inline bool          ind_tclass_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_tclass.Find
amc::FTclass*        ind_tclass_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_tclass.GetOrCreate
amc::FTclass&        ind_tclass_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_tclass.N
inline i32           ind_tclass_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_tclass.InsertMaybe
bool                 ind_tclass_InsertMaybe(amc::FTclass& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_tclass.Remove
void                 ind_tclass_Remove(amc::FTclass& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_tclass.Reserve
void                 ind_tclass_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcmp.Alloc
amc::FFcmp&          fcmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcmp.AllocMaybe
amc::FFcmp*          fcmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcmp.InsertMaybe
amc::FFcmp*          fcmp_InsertMaybe(const dmmeta::Fcmp &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcmp.AllocMem
void*                fcmp_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcmp.EmptyQ
inline bool          fcmp_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcmp.Find
inline amc::FFcmp*   fcmp_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcmp.Last
inline amc::FFcmp*   fcmp_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcmp.N
inline i32           fcmp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcmp.RemoveLast
void                 fcmp_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcmp.qFind
inline amc::FFcmp&   fcmp_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcmp.XrefMaybe
bool                 fcmp_XrefMaybe(amc::FFcmp &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcast.Alloc
amc::FFcast&         fcast_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcast.AllocMaybe
amc::FFcast*         fcast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcast.InsertMaybe
amc::FFcast*         fcast_InsertMaybe(const dmmeta::Fcast &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcast.AllocMem
void*                fcast_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcast.EmptyQ
inline bool          fcast_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcast.Find
inline amc::FFcast*  fcast_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcast.Last
inline amc::FFcast*  fcast_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcast.N
inline i32           fcast_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcast.RemoveLast
void                 fcast_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcast.qFind
inline amc::FFcast&  fcast_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcast.XrefMaybe
bool                 fcast_XrefMaybe(amc::FFcast &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.noxref.Alloc
amc::FNoxref&        noxref_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.noxref.AllocMaybe
amc::FNoxref*        noxref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.noxref.InsertMaybe
amc::FNoxref*        noxref_InsertMaybe(const dmmeta::Noxref &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.noxref.AllocMem
void*                noxref_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.noxref.EmptyQ
inline bool          noxref_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.noxref.Find
inline amc::FNoxref* noxref_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.noxref.Last
inline amc::FNoxref* noxref_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.noxref.N
inline i32           noxref_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.noxref.RemoveLast
void                 noxref_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.noxref.qFind
inline amc::FNoxref& noxref_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.noxref.XrefMaybe
bool                 noxref_XrefMaybe(amc::FNoxref &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nocascdel.Alloc
amc::FNocascdel&     nocascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nocascdel.AllocMaybe
amc::FNocascdel*     nocascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nocascdel.InsertMaybe
amc::FNocascdel*     nocascdel_InsertMaybe(const dmmeta::Nocascdel &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nocascdel.AllocMem
void*                nocascdel_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nocascdel.EmptyQ
inline bool          nocascdel_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nocascdel.Find
inline amc::FNocascdel* nocascdel_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nocascdel.Last
inline amc::FNocascdel* nocascdel_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nocascdel.N
inline i32           nocascdel_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nocascdel.RemoveLast
void                 nocascdel_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nocascdel.qFind
inline amc::FNocascdel& nocascdel_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nocascdel.XrefMaybe
bool                 nocascdel_XrefMaybe(amc::FNocascdel &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cafter.Alloc
amc::FCafter&        cafter_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cafter.AllocMaybe
amc::FCafter*        cafter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cafter.InsertMaybe
amc::FCafter*        cafter_InsertMaybe(const dmmeta::Cafter &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cafter.AllocMem
void*                cafter_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cafter.EmptyQ
inline bool          cafter_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cafter.Find
inline amc::FCafter* cafter_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cafter.Last
inline amc::FCafter* cafter_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cafter.N
inline i32           cafter_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cafter.RemoveLast
void                 cafter_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cafter.qFind
inline amc::FCafter& cafter_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cafter.XrefMaybe
bool                 cafter_XrefMaybe(amc::FCafter &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.csize.Alloc
amc::FCsize&         csize_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.csize.AllocMaybe
amc::FCsize*         csize_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.csize.InsertMaybe
amc::FCsize*         csize_InsertMaybe(const dmmeta::Csize &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.csize.AllocMem
void*                csize_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.csize.EmptyQ
inline bool          csize_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.csize.Find
inline amc::FCsize*  csize_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.csize.Last
inline amc::FCsize*  csize_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.csize.N
inline i32           csize_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.csize.RemoveLast
void                 csize_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.csize.qFind
inline amc::FCsize&  csize_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.csize.XrefMaybe
bool                 csize_XrefMaybe(amc::FCsize &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nsx.Alloc
amc::FNsx&           nsx_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nsx.AllocMaybe
amc::FNsx*           nsx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nsx.InsertMaybe
amc::FNsx*           nsx_InsertMaybe(const dmmeta::Nsx &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nsx.AllocMem
void*                nsx_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nsx.EmptyQ
inline bool          nsx_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nsx.Find
inline amc::FNsx*    nsx_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nsx.Last
inline amc::FNsx*    nsx_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nsx.N
inline i32           nsx_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nsx.RemoveLast
void                 nsx_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nsx.qFind
inline amc::FNsx&    nsx_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nsx.XrefMaybe
bool                 nsx_XrefMaybe(amc::FNsx &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcompact.Alloc
amc::FFcompact&      fcompact_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcompact.AllocMaybe
amc::FFcompact*      fcompact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcompact.InsertMaybe
amc::FFcompact*      fcompact_InsertMaybe(const dmmeta::Fcompact &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcompact.AllocMem
void*                fcompact_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcompact.EmptyQ
inline bool          fcompact_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcompact.Find
inline amc::FFcompact* fcompact_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcompact.Last
inline amc::FFcompact* fcompact_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcompact.N
inline i32           fcompact_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcompact.RemoveLast
void                 fcompact_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcompact.qFind
inline amc::FFcompact& fcompact_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcompact.XrefMaybe
bool                 fcompact_XrefMaybe(amc::FFcompact &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.findrem.Alloc
amc::FFindrem&       findrem_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.findrem.AllocMaybe
amc::FFindrem*       findrem_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.findrem.InsertMaybe
amc::FFindrem*       findrem_InsertMaybe(const dmmeta::Findrem &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.findrem.AllocMem
void*                findrem_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.findrem.EmptyQ
inline bool          findrem_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.findrem.Find
inline amc::FFindrem* findrem_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.findrem.Last
inline amc::FFindrem* findrem_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.findrem.N
inline i32           findrem_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.findrem.RemoveLast
void                 findrem_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.findrem.qFind
inline amc::FFindrem& findrem_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.findrem.XrefMaybe
bool                 findrem_XrefMaybe(amc::FFindrem &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcurs.Alloc
amc::FFcurs&         fcurs_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcurs.AllocMaybe
amc::FFcurs*         fcurs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcurs.InsertMaybe
amc::FFcurs*         fcurs_InsertMaybe(const dmmeta::Fcurs &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcurs.AllocMem
void*                fcurs_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcurs.EmptyQ
inline bool          fcurs_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcurs.Find
inline amc::FFcurs*  fcurs_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcurs.Last
inline amc::FFcurs*  fcurs_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcurs.N
inline i32           fcurs_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcurs.RemoveLast
void                 fcurs_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcurs.qFind
inline amc::FFcurs&  fcurs_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcurs.XrefMaybe
bool                 fcurs_XrefMaybe(amc::FFcurs &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cdflt.Alloc
amc::FCdflt&         cdflt_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cdflt.AllocMaybe
amc::FCdflt*         cdflt_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cdflt.InsertMaybe
amc::FCdflt*         cdflt_InsertMaybe(const dmmeta::Cdflt &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cdflt.AllocMem
void*                cdflt_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cdflt.EmptyQ
inline bool          cdflt_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cdflt.Find
inline amc::FCdflt*  cdflt_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cdflt.Last
inline amc::FCdflt*  cdflt_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cdflt.N
inline i32           cdflt_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cdflt.RemoveLast
void                 cdflt_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cdflt.qFind
inline amc::FCdflt&  cdflt_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cdflt.XrefMaybe
bool                 cdflt_XrefMaybe(amc::FCdflt &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.argvtype.Alloc
amc::FArgvtype&      argvtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.argvtype.AllocMaybe
amc::FArgvtype*      argvtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.argvtype.InsertMaybe
amc::FArgvtype*      argvtype_InsertMaybe(const dmmeta::Argvtype &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.argvtype.AllocMem
void*                argvtype_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.argvtype.EmptyQ
inline bool          argvtype_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.argvtype.Find
inline amc::FArgvtype* argvtype_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.argvtype.Last
inline amc::FArgvtype* argvtype_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.argvtype.N
inline i32           argvtype_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.argvtype.RemoveLast
void                 argvtype_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.argvtype.qFind
inline amc::FArgvtype& argvtype_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.argvtype.XrefMaybe
bool                 argvtype_XrefMaybe(amc::FArgvtype &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcmdline.Alloc
amc::FFcmdline&      fcmdline_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcmdline.AllocMaybe
amc::FFcmdline*      fcmdline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcmdline.InsertMaybe
amc::FFcmdline*      fcmdline_InsertMaybe(const dmmeta::Fcmdline &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcmdline.AllocMem
void*                fcmdline_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcmdline.EmptyQ
inline bool          fcmdline_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcmdline.Find
inline amc::FFcmdline* fcmdline_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcmdline.Last
inline amc::FFcmdline* fcmdline_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcmdline.N
inline i32           fcmdline_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcmdline.RemoveLast
void                 fcmdline_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcmdline.qFind
inline amc::FFcmdline& fcmdline_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcmdline.XrefMaybe
bool                 fcmdline_XrefMaybe(amc::FFcmdline &row);

// Return true if hash is empty
// func:amc.FDb.ind_main.EmptyQ
inline bool          ind_main_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_main.Find
amc::FMain*          ind_main_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_main.GetOrCreate
amc::FMain&          ind_main_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_main.N
inline i32           ind_main_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_main.InsertMaybe
bool                 ind_main_InsertMaybe(amc::FMain& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_main.Remove
void                 ind_main_Remove(amc::FMain& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_main.Reserve
void                 ind_main_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.floadtuples.Alloc
amc::FFloadtuples&   floadtuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.floadtuples.AllocMaybe
amc::FFloadtuples*   floadtuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.floadtuples.InsertMaybe
amc::FFloadtuples*   floadtuples_InsertMaybe(const dmmeta::Floadtuples &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.floadtuples.AllocMem
void*                floadtuples_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.floadtuples.EmptyQ
inline bool          floadtuples_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.floadtuples.Find
inline amc::FFloadtuples* floadtuples_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.floadtuples.Last
inline amc::FFloadtuples* floadtuples_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.floadtuples.N
inline i32           floadtuples_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.floadtuples.RemoveLast
void                 floadtuples_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.floadtuples.qFind
inline amc::FFloadtuples& floadtuples_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.floadtuples.XrefMaybe
bool                 floadtuples_XrefMaybe(amc::FFloadtuples &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fcmap.Alloc
amc::FFcmap&         fcmap_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fcmap.AllocMaybe
amc::FFcmap*         fcmap_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fcmap.InsertMaybe
amc::FFcmap*         fcmap_InsertMaybe(const dmmeta::Fcmap &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fcmap.AllocMem
void*                fcmap_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fcmap.EmptyQ
inline bool          fcmap_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fcmap.Find
inline amc::FFcmap*  fcmap_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fcmap.Last
inline amc::FFcmap*  fcmap_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fcmap.N
inline i32           fcmap_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fcmap.RemoveLast
void                 fcmap_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fcmap.qFind
inline amc::FFcmap&  fcmap_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fcmap.XrefMaybe
bool                 fcmap_XrefMaybe(amc::FFcmap &row);

// Return true if index is empty
// func:amc.FDb.zs_ordkeyfield.EmptyQ
inline bool          zs_ordkeyfield_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.zs_ordkeyfield.First
inline amc::FField*  zs_ordkeyfield_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.zs_ordkeyfield.InLlistQ
inline bool          zs_ordkeyfield_InLlistQ(amc::FField& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.zs_ordkeyfield.Insert
void                 zs_ordkeyfield_Insert(amc::FField& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FDb.zs_ordkeyfield.Last
inline amc::FField*  zs_ordkeyfield_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FDb.zs_ordkeyfield.Next
inline amc::FField*  zs_ordkeyfield_Next(amc::FField &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FDb.zs_ordkeyfield.Remove
void                 zs_ordkeyfield_Remove(amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.zs_ordkeyfield.RemoveAll
void                 zs_ordkeyfield_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.zs_ordkeyfield.RemoveFirst
amc::FField*         zs_ordkeyfield_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FDb.zs_ordkeyfield.qLast
inline amc::FField&  zs_ordkeyfield_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nsproto.Alloc
amc::FNsproto&       nsproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nsproto.AllocMaybe
amc::FNsproto*       nsproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nsproto.InsertMaybe
amc::FNsproto*       nsproto_InsertMaybe(const dmmeta::Nsproto &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nsproto.AllocMem
void*                nsproto_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nsproto.EmptyQ
inline bool          nsproto_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nsproto.Find
inline amc::FNsproto* nsproto_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nsproto.Last
inline amc::FNsproto* nsproto_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nsproto.N
inline i32           nsproto_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nsproto.RemoveLast
void                 nsproto_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nsproto.qFind
inline amc::FNsproto& nsproto_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nsproto.XrefMaybe
bool                 nsproto_XrefMaybe(amc::FNsproto &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nsdb.Alloc
amc::FNsdb&          nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nsdb.AllocMaybe
amc::FNsdb*          nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nsdb.InsertMaybe
amc::FNsdb*          nsdb_InsertMaybe(const dmmeta::Nsdb &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nsdb.AllocMem
void*                nsdb_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nsdb.EmptyQ
inline bool          nsdb_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nsdb.Find
inline amc::FNsdb*   nsdb_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nsdb.Last
inline amc::FNsdb*   nsdb_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nsdb.N
inline i32           nsdb_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nsdb.RemoveLast
void                 nsdb_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nsdb.qFind
inline amc::FNsdb&   nsdb_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nsdb.XrefMaybe
bool                 nsdb_XrefMaybe(amc::FNsdb &row);

// Return true if index is empty
// func:amc.FDb.zd_substr_params.EmptyQ
inline bool          zd_substr_params_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.zd_substr_params.First
inline amc::FSubstr* zd_substr_params_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.zd_substr_params.InLlistQ
inline bool          zd_substr_params_InLlistQ(amc::FSubstr& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.zd_substr_params.Insert
void                 zd_substr_params_Insert(amc::FSubstr& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FDb.zd_substr_params.Last
inline amc::FSubstr* zd_substr_params_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FDb.zd_substr_params.N
inline i32           zd_substr_params_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FDb.zd_substr_params.Next
inline amc::FSubstr* zd_substr_params_Next(amc::FSubstr &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FDb.zd_substr_params.Prev
inline amc::FSubstr* zd_substr_params_Prev(amc::FSubstr &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDb.zd_substr_params.Remove
void                 zd_substr_params_Remove(amc::FSubstr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.zd_substr_params.RemoveAll
void                 zd_substr_params_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.zd_substr_params.RemoveFirst
amc::FSubstr*        zd_substr_params_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FDb.zd_substr_params.qLast
inline amc::FSubstr& zd_substr_params_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if hash is empty
// func:amc.FDb.ind_fconst_int.EmptyQ
inline bool          ind_fconst_int_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fconst_int.Find
amc::FFconst*        ind_fconst_int_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fconst_int.N
inline i32           ind_fconst_int_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fconst_int.InsertMaybe
bool                 ind_fconst_int_InsertMaybe(amc::FFconst& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fconst_int.Remove
void                 ind_fconst_int_Remove(amc::FFconst& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fconst_int.Reserve
void                 ind_fconst_int_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fprefix.Alloc
amc::FFprefix&       fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fprefix.AllocMaybe
amc::FFprefix*       fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fprefix.InsertMaybe
amc::FFprefix*       fprefix_InsertMaybe(const dmmeta::Fprefix &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fprefix.AllocMem
void*                fprefix_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fprefix.EmptyQ
inline bool          fprefix_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fprefix.Find
inline amc::FFprefix* fprefix_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fprefix.Last
inline amc::FFprefix* fprefix_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fprefix.N
inline i32           fprefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fprefix.RemoveLast
void                 fprefix_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fprefix.qFind
inline amc::FFprefix& fprefix_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fprefix.XrefMaybe
bool                 fprefix_XrefMaybe(amc::FFprefix &row);

// Return true if hash is empty
// func:amc.FDb.ind_prefix.EmptyQ
inline bool          ind_prefix_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_prefix.Find
amc::FFprefix*       ind_prefix_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_prefix.GetOrCreate
amc::FFprefix&       ind_prefix_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_prefix.N
inline i32           ind_prefix_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_prefix.InsertMaybe
bool                 ind_prefix_InsertMaybe(amc::FFprefix& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_prefix.Remove
void                 ind_prefix_Remove(amc::FFprefix& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_prefix.Reserve
void                 ind_prefix_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ftrace.Alloc
amc::FFtrace&        ftrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ftrace.AllocMaybe
amc::FFtrace*        ftrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ftrace.InsertMaybe
amc::FFtrace*        ftrace_InsertMaybe(const dmmeta::Ftrace &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ftrace.AllocMem
void*                ftrace_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ftrace.EmptyQ
inline bool          ftrace_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ftrace.Find
inline amc::FFtrace* ftrace_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ftrace.Last
inline amc::FFtrace* ftrace_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ftrace.N
inline i32           ftrace_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ftrace.RemoveLast
void                 ftrace_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ftrace.qFind
inline amc::FFtrace& ftrace_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ftrace.XrefMaybe
bool                 ftrace_XrefMaybe(amc::FFtrace &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fnoremove.Alloc
amc::FFnoremove&     fnoremove_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fnoremove.AllocMaybe
amc::FFnoremove*     fnoremove_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fnoremove.InsertMaybe
amc::FFnoremove*     fnoremove_InsertMaybe(const dmmeta::Fnoremove &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fnoremove.AllocMem
void*                fnoremove_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fnoremove.EmptyQ
inline bool          fnoremove_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fnoremove.Find
inline amc::FFnoremove* fnoremove_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fnoremove.Last
inline amc::FFnoremove* fnoremove_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fnoremove.N
inline i32           fnoremove_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fnoremove.RemoveLast
void                 fnoremove_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fnoremove.qFind
inline amc::FFnoremove& fnoremove_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fnoremove.XrefMaybe
bool                 fnoremove_XrefMaybe(amc::FFnoremove &row);

// Return true if index is empty
// func:amc.FDb.c_substr_field.EmptyQ
inline bool          c_substr_field_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_substr_field.Find
inline amc::FSubstr* c_substr_field_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_substr_field.Getary
inline algo::aryptr<amc::FSubstr*> c_substr_field_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_substr_field.Insert
void                 c_substr_field_Insert(amc::FSubstr& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_substr_field.InsertMaybe
bool                 c_substr_field_InsertMaybe(amc::FSubstr& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_substr_field.N
inline i32           c_substr_field_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_substr_field.Remove
void                 c_substr_field_Remove(amc::FSubstr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_substr_field.RemoveAll
inline void          c_substr_field_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_substr_field.Reserve
void                 c_substr_field_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_substr_field.qFind
inline amc::FSubstr& c_substr_field_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FDb.c_substr_field.InAryQ
inline bool          c_substr_field_InAryQ(amc::FSubstr& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_substr_field.qLast
inline amc::FSubstr& c_substr_field_qLast() __attribute__((nothrow));
// Verify whether array is sorted
// func:amc.FDb.c_substr_field.SortedQ
bool                 c_substr_field_SortedQ() __attribute__((nothrow));
// Insertion sort
// func:amc.FDb.c_substr_field.InsertionSort
void                 c_substr_field_InsertionSort() __attribute__((nothrow));
// Heap sort
// func:amc.FDb.c_substr_field.HeapSort
void                 c_substr_field_HeapSort() __attribute__((nothrow));
// Quick sort
// func:amc.FDb.c_substr_field.QuickSort
void                 c_substr_field_QuickSort() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ctypelen.Alloc
amc::FCtypelen&      ctypelen_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ctypelen.AllocMaybe
amc::FCtypelen*      ctypelen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ctypelen.InsertMaybe
amc::FCtypelen*      ctypelen_InsertMaybe(const dmmeta::Ctypelen &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ctypelen.AllocMem
void*                ctypelen_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ctypelen.EmptyQ
inline bool          ctypelen_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ctypelen.Find
inline amc::FCtypelen* ctypelen_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ctypelen.Last
inline amc::FCtypelen* ctypelen_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ctypelen.N
inline i32           ctypelen_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.ctypelen.RemoveAll
void                 ctypelen_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ctypelen.RemoveLast
void                 ctypelen_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ctypelen.qFind
inline amc::FCtypelen& ctypelen_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ctypelen.XrefMaybe
bool                 ctypelen_XrefMaybe(amc::FCtypelen &row);

// Return true if index is empty
// func:amc.FDb.c_ctypelen.EmptyQ
inline bool          c_ctypelen_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_ctypelen.Find
inline amc::FCtypelen* c_ctypelen_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_ctypelen.Getary
inline algo::aryptr<amc::FCtypelen*> c_ctypelen_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_ctypelen.Insert
void                 c_ctypelen_Insert(amc::FCtypelen& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_ctypelen.InsertMaybe
bool                 c_ctypelen_InsertMaybe(amc::FCtypelen& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_ctypelen.N
inline i32           c_ctypelen_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_ctypelen.Remove
void                 c_ctypelen_Remove(amc::FCtypelen& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_ctypelen.RemoveAll
inline void          c_ctypelen_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_ctypelen.Reserve
void                 c_ctypelen_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_ctypelen.qFind
inline amc::FCtypelen& c_ctypelen_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FDb.c_ctypelen.InAryQ
inline bool          c_ctypelen_InAryQ(amc::FCtypelen& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_ctypelen.qLast
inline amc::FCtypelen& c_ctypelen_qLast() __attribute__((nothrow));
// Verify whether array is sorted
// func:amc.FDb.c_ctypelen.SortedQ
bool                 c_ctypelen_SortedQ() __attribute__((nothrow));
// Insertion sort
// func:amc.FDb.c_ctypelen.InsertionSort
void                 c_ctypelen_InsertionSort() __attribute__((nothrow));
// Heap sort
// func:amc.FDb.c_ctypelen.HeapSort
void                 c_ctypelen_HeapSort() __attribute__((nothrow));
// Quick sort
// func:amc.FDb.c_ctypelen.QuickSort
void                 c_ctypelen_QuickSort() __attribute__((nothrow));
// Save table to ssimfile
// func:amc.FDb.c_ctypelen.SaveSsimfile
bool                 c_ctypelen_SaveSsimfile(algo::strptr fname) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FDb.c_tempfield.EmptyQ
inline bool          c_tempfield_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_tempfield.Find
inline amc::FField*  c_tempfield_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_tempfield.Getary
inline algo::aryptr<amc::FField*> c_tempfield_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_tempfield.Insert
void                 c_tempfield_Insert(amc::FField& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_tempfield.InsertMaybe
bool                 c_tempfield_InsertMaybe(amc::FField& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_tempfield.N
inline i32           c_tempfield_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_tempfield.Remove
void                 c_tempfield_Remove(amc::FField& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_tempfield.RemoveAll
inline void          c_tempfield_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_tempfield.Reserve
void                 c_tempfield_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_tempfield.qFind
inline amc::FField&  c_tempfield_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FDb.c_tempfield.InAryQ
inline bool          c_tempfield_InAryQ(amc::FField& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_tempfield.qLast
inline amc::FField&  c_tempfield_qLast() __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fbase.Alloc
amc::FFbase&         fbase_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fbase.AllocMaybe
amc::FFbase*         fbase_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fbase.InsertMaybe
amc::FFbase*         fbase_InsertMaybe(const dmmeta::Fbase &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fbase.AllocMem
void*                fbase_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fbase.EmptyQ
inline bool          fbase_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fbase.Find
inline amc::FFbase*  fbase_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fbase.Last
inline amc::FFbase*  fbase_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fbase.N
inline i32           fbase_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.fbase.RemoveAll
void                 fbase_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fbase.RemoveLast
void                 fbase_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fbase.qFind
inline amc::FFbase&  fbase_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fbase.XrefMaybe
bool                 fbase_XrefMaybe(amc::FFbase &row);

// Return true if hash is empty
// func:amc.FDb.ind_fcmap.EmptyQ
inline bool          ind_fcmap_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fcmap.Find
amc::FFcmap*         ind_fcmap_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fcmap.GetOrCreate
amc::FFcmap&         ind_fcmap_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fcmap.N
inline i32           ind_fcmap_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fcmap.InsertMaybe
bool                 ind_fcmap_InsertMaybe(amc::FFcmap& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fcmap.Remove
void                 ind_fcmap_Remove(amc::FFcmap& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fcmap.Reserve
void                 ind_fcmap_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nossimfile.Alloc
amc::FNossimfile&    nossimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nossimfile.AllocMaybe
amc::FNossimfile*    nossimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nossimfile.InsertMaybe
amc::FNossimfile*    nossimfile_InsertMaybe(const dmmeta::Nossimfile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nossimfile.AllocMem
void*                nossimfile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nossimfile.EmptyQ
inline bool          nossimfile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nossimfile.Find
inline amc::FNossimfile* nossimfile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nossimfile.Last
inline amc::FNossimfile* nossimfile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nossimfile.N
inline i32           nossimfile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.nossimfile.RemoveAll
void                 nossimfile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nossimfile.RemoveLast
void                 nossimfile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nossimfile.qFind
inline amc::FNossimfile& nossimfile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nossimfile.XrefMaybe
bool                 nossimfile_XrefMaybe(amc::FNossimfile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.gsymbol.Alloc
amc::FGsymbol&       gsymbol_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.gsymbol.AllocMaybe
amc::FGsymbol*       gsymbol_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.gsymbol.InsertMaybe
amc::FGsymbol*       gsymbol_InsertMaybe(const dmmeta::Gsymbol &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.gsymbol.AllocMem
void*                gsymbol_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.gsymbol.EmptyQ
inline bool          gsymbol_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.gsymbol.Find
inline amc::FGsymbol* gsymbol_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.gsymbol.Last
inline amc::FGsymbol* gsymbol_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.gsymbol.N
inline i32           gsymbol_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.gsymbol.RemoveAll
void                 gsymbol_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.gsymbol.RemoveLast
void                 gsymbol_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.gsymbol.qFind
inline amc::FGsymbol& gsymbol_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.gsymbol.XrefMaybe
bool                 gsymbol_XrefMaybe(amc::FGsymbol &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.sortfld.Alloc
amc::FSortfld&       sortfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.sortfld.AllocMaybe
amc::FSortfld*       sortfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.sortfld.InsertMaybe
amc::FSortfld*       sortfld_InsertMaybe(const dmmeta::Sortfld &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.sortfld.AllocMem
void*                sortfld_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.sortfld.EmptyQ
inline bool          sortfld_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.sortfld.Find
inline amc::FSortfld* sortfld_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.sortfld.Last
inline amc::FSortfld* sortfld_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.sortfld.N
inline i32           sortfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.sortfld.RemoveLast
void                 sortfld_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.sortfld.qFind
inline amc::FSortfld& sortfld_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.sortfld.XrefMaybe
bool                 sortfld_XrefMaybe(amc::FSortfld &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cget.Alloc
amc::FCget&          cget_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cget.AllocMaybe
amc::FCget*          cget_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cget.InsertMaybe
amc::FCget*          cget_InsertMaybe(const dmmeta::Cget &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cget.AllocMem
void*                cget_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cget.EmptyQ
inline bool          cget_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cget.Find
inline amc::FCget*   cget_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cget.Last
inline amc::FCget*   cget_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cget.N
inline i32           cget_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cget.RemoveLast
void                 cget_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cget.qFind
inline amc::FCget&   cget_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cget.XrefMaybe
bool                 cget_XrefMaybe(amc::FCget &row);

// Return true if index is empty
// func:amc.FDb.cd_temp_func.EmptyQ
inline bool          cd_temp_func_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.cd_temp_func.First
inline amc::FFunc*   cd_temp_func_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.cd_temp_func.InLlistQ
inline bool          cd_temp_func_InLlistQ(amc::FFunc& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.cd_temp_func.Insert
void                 cd_temp_func_Insert(amc::FFunc& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FDb.cd_temp_func.Last
inline amc::FFunc*   cd_temp_func_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FDb.cd_temp_func.N
inline i32           cd_temp_func_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FDb.cd_temp_func.Next
inline amc::FFunc*   cd_temp_func_Next(amc::FFunc &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FDb.cd_temp_func.Prev
inline amc::FFunc*   cd_temp_func_Prev(amc::FFunc &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDb.cd_temp_func.Remove
void                 cd_temp_func_Remove(amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.cd_temp_func.RemoveAll
void                 cd_temp_func_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.cd_temp_func.RemoveFirst
amc::FFunc*          cd_temp_func_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:amc.FDb.cd_temp_func.RotateFirst
amc::FFunc*          cd_temp_func_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FDb.cd_temp_func.qLast
inline amc::FFunc&   cd_temp_func_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:amc.FDb.zs_gen_perns.EmptyQ
inline bool          zs_gen_perns_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.zs_gen_perns.First
inline amc::FGen*    zs_gen_perns_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.zs_gen_perns.InLlistQ
inline bool          zs_gen_perns_InLlistQ(amc::FGen& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.zs_gen_perns.Insert
void                 zs_gen_perns_Insert(amc::FGen& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FDb.zs_gen_perns.Last
inline amc::FGen*    zs_gen_perns_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FDb.zs_gen_perns.Next
inline amc::FGen*    zs_gen_perns_Next(amc::FGen &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FDb.zs_gen_perns.Remove
void                 zs_gen_perns_Remove(amc::FGen& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.zs_gen_perns.RemoveAll
void                 zs_gen_perns_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.zs_gen_perns.RemoveFirst
amc::FGen*           zs_gen_perns_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FDb.zs_gen_perns.qLast
inline amc::FGen&    zs_gen_perns_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.hook.Alloc
amc::FHook&          hook_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.hook.AllocMaybe
amc::FHook*          hook_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.hook.InsertMaybe
amc::FHook*          hook_InsertMaybe(const dmmeta::Hook &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.hook.AllocMem
void*                hook_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.hook.EmptyQ
inline bool          hook_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.hook.Find
inline amc::FHook*   hook_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.hook.Last
inline amc::FHook*   hook_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.hook.N
inline i32           hook_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.hook.RemoveAll
void                 hook_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.hook.RemoveLast
void                 hook_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.hook.qFind
inline amc::FHook&   hook_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.hook.XrefMaybe
bool                 hook_XrefMaybe(amc::FHook &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.charset.Alloc
amc::FCharset&       charset_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.charset.AllocMaybe
amc::FCharset*       charset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.charset.InsertMaybe
amc::FCharset*       charset_InsertMaybe(const dmmeta::Charset &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.charset.AllocMem
void*                charset_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.charset.EmptyQ
inline bool          charset_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.charset.Find
inline amc::FCharset* charset_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.charset.Last
inline amc::FCharset* charset_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.charset.N
inline i32           charset_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.charset.RemoveAll
void                 charset_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.charset.RemoveLast
void                 charset_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.charset.qFind
inline amc::FCharset& charset_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.charset.XrefMaybe
bool                 charset_XrefMaybe(amc::FCharset &row);

// func:amc.FDb.ValidRnumPad.Match
inline bool          ValidRnumPadQ(u32 ch) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nsinclude.Alloc
amc::FNsinclude&     nsinclude_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nsinclude.AllocMaybe
amc::FNsinclude*     nsinclude_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nsinclude.InsertMaybe
amc::FNsinclude*     nsinclude_InsertMaybe(const dmmeta::Nsinclude &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nsinclude.AllocMem
void*                nsinclude_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nsinclude.EmptyQ
inline bool          nsinclude_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nsinclude.Find
inline amc::FNsinclude* nsinclude_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nsinclude.Last
inline amc::FNsinclude* nsinclude_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nsinclude.N
inline i32           nsinclude_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.nsinclude.RemoveAll
void                 nsinclude_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nsinclude.RemoveLast
void                 nsinclude_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nsinclude.qFind
inline amc::FNsinclude& nsinclude_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nsinclude.XrefMaybe
bool                 nsinclude_XrefMaybe(amc::FNsinclude &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ssimvolatile.Alloc
amc::FSsimvolatile&  ssimvolatile_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ssimvolatile.AllocMaybe
amc::FSsimvolatile*  ssimvolatile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ssimvolatile.InsertMaybe
amc::FSsimvolatile*  ssimvolatile_InsertMaybe(const dmmeta::Ssimvolatile &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ssimvolatile.AllocMem
void*                ssimvolatile_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ssimvolatile.EmptyQ
inline bool          ssimvolatile_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ssimvolatile.Find
inline amc::FSsimvolatile* ssimvolatile_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ssimvolatile.Last
inline amc::FSsimvolatile* ssimvolatile_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ssimvolatile.N
inline i32           ssimvolatile_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.ssimvolatile.RemoveAll
void                 ssimvolatile_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ssimvolatile.RemoveLast
void                 ssimvolatile_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ssimvolatile.qFind
inline amc::FSsimvolatile& ssimvolatile_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ssimvolatile.XrefMaybe
bool                 ssimvolatile_XrefMaybe(amc::FSsimvolatile &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.funique.Alloc
amc::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.funique.AllocMaybe
amc::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.funique.InsertMaybe
amc::FFunique*       funique_InsertMaybe(const dmmeta::Funique &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.funique.AllocMem
void*                funique_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.funique.EmptyQ
inline bool          funique_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.funique.Find
inline amc::FFunique* funique_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.funique.Last
inline amc::FFunique* funique_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.funique.N
inline i32           funique_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.funique.RemoveAll
void                 funique_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.funique.RemoveLast
void                 funique_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.funique.qFind
inline amc::FFunique& funique_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.funique.XrefMaybe
bool                 funique_XrefMaybe(amc::FFunique &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fuserinit.Alloc
amc::FFuserinit&     fuserinit_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fuserinit.AllocMaybe
amc::FFuserinit*     fuserinit_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fuserinit.InsertMaybe
amc::FFuserinit*     fuserinit_InsertMaybe(const dmmeta::Fuserinit &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fuserinit.AllocMem
void*                fuserinit_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fuserinit.EmptyQ
inline bool          fuserinit_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fuserinit.Find
inline amc::FFuserinit* fuserinit_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fuserinit.Last
inline amc::FFuserinit* fuserinit_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fuserinit.N
inline i32           fuserinit_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.fuserinit.RemoveAll
void                 fuserinit_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fuserinit.RemoveLast
void                 fuserinit_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fuserinit.qFind
inline amc::FFuserinit& fuserinit_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fuserinit.XrefMaybe
bool                 fuserinit_XrefMaybe(amc::FFuserinit &row);

// Return true if hash is empty
// func:amc.FDb.ind_fcurs.EmptyQ
inline bool          ind_fcurs_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fcurs.Find
amc::FFcurs*         ind_fcurs_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fcurs.GetOrCreate
amc::FFcurs&         ind_fcurs_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fcurs.N
inline i32           ind_fcurs_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fcurs.InsertMaybe
bool                 ind_fcurs_InsertMaybe(amc::FFcurs& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fcurs.Remove
void                 ind_fcurs_Remove(amc::FFcurs& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fcurs.Reserve
void                 ind_fcurs_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.tcurs.Alloc
amc::FTcurs&         tcurs_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.tcurs.AllocMaybe
amc::FTcurs*         tcurs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.tcurs.InsertMaybe
amc::FTcurs*         tcurs_InsertMaybe(const amcdb::Tcurs &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.tcurs.AllocMem
void*                tcurs_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.tcurs.EmptyQ
inline bool          tcurs_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.tcurs.Find
inline amc::FTcurs*  tcurs_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.tcurs.Last
inline amc::FTcurs*  tcurs_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.tcurs.N
inline i32           tcurs_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.tcurs.RemoveAll
void                 tcurs_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.tcurs.RemoveLast
void                 tcurs_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.tcurs.qFind
inline amc::FTcurs&  tcurs_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.tcurs.XrefMaybe
bool                 tcurs_XrefMaybe(amc::FTcurs &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.nscpp.Alloc
amc::FNscpp&         nscpp_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.nscpp.AllocMaybe
amc::FNscpp*         nscpp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.nscpp.InsertMaybe
amc::FNscpp*         nscpp_InsertMaybe(const dmmeta::Nscpp &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.nscpp.AllocMem
void*                nscpp_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.nscpp.EmptyQ
inline bool          nscpp_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.nscpp.Find
inline amc::FNscpp*  nscpp_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.nscpp.Last
inline amc::FNscpp*  nscpp_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.nscpp.N
inline i32           nscpp_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.nscpp.RemoveAll
void                 nscpp_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.nscpp.RemoveLast
void                 nscpp_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.nscpp.qFind
inline amc::FNscpp&  nscpp_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.nscpp.XrefMaybe
bool                 nscpp_XrefMaybe(amc::FNscpp &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.fflag.Alloc
amc::FFflag&         fflag_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.fflag.AllocMaybe
amc::FFflag*         fflag_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.fflag.InsertMaybe
amc::FFflag*         fflag_InsertMaybe(const dmmeta::Fflag &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.fflag.AllocMem
void*                fflag_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.fflag.EmptyQ
inline bool          fflag_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.fflag.Find
inline amc::FFflag*  fflag_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.fflag.Last
inline amc::FFflag*  fflag_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.fflag.N
inline i32           fflag_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.fflag.RemoveAll
void                 fflag_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.fflag.RemoveLast
void                 fflag_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.fflag.qFind
inline amc::FFflag&  fflag_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.fflag.XrefMaybe
bool                 fflag_XrefMaybe(amc::FFflag &row);

// Return true if hash is empty
// func:amc.FDb.ind_fflag.EmptyQ
inline bool          ind_fflag_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_fflag.Find
amc::FFflag*         ind_fflag_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_fflag.GetOrCreate
amc::FFflag&         ind_fflag_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_fflag.N
inline i32           ind_fflag_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_fflag.InsertMaybe
bool                 ind_fflag_InsertMaybe(amc::FFflag& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_fflag.Remove
void                 ind_fflag_Remove(amc::FFflag& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_fflag.Reserve
void                 ind_fflag_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.falias.Alloc
amc::FFalias&        falias_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.falias.AllocMaybe
amc::FFalias*        falias_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.falias.InsertMaybe
amc::FFalias*        falias_InsertMaybe(const dmmeta::Falias &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.falias.AllocMem
void*                falias_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.falias.EmptyQ
inline bool          falias_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.falias.Find
inline amc::FFalias* falias_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.falias.Last
inline amc::FFalias* falias_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.falias.N
inline i32           falias_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.falias.RemoveAll
void                 falias_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.falias.RemoveLast
void                 falias_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.falias.qFind
inline amc::FFalias& falias_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.falias.XrefMaybe
bool                 falias_XrefMaybe(amc::FFalias &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.license.Alloc
amc::FLicense&       license_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.license.AllocMaybe
amc::FLicense*       license_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.license.InsertMaybe
amc::FLicense*       license_InsertMaybe(const dev::License &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.license.AllocMem
void*                license_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.license.EmptyQ
inline bool          license_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.license.Find
inline amc::FLicense* license_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.license.Last
inline amc::FLicense* license_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.license.N
inline i32           license_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.license.RemoveAll
void                 license_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.license.RemoveLast
void                 license_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.license.qFind
inline amc::FLicense& license_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.license.XrefMaybe
bool                 license_XrefMaybe(amc::FLicense &row);

// Return true if hash is empty
// func:amc.FDb.ind_license.EmptyQ
inline bool          ind_license_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_license.Find
amc::FLicense*       ind_license_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_license.GetOrCreate
amc::FLicense&       ind_license_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_license.N
inline i32           ind_license_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_license.InsertMaybe
bool                 ind_license_InsertMaybe(amc::FLicense& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_license.Remove
void                 ind_license_Remove(amc::FLicense& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_license.Reserve
void                 ind_license_Reserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FDb.c_ssimfile_sorted.EmptyQ
inline bool          c_ssimfile_sorted_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.c_ssimfile_sorted.Find
inline amc::FSsimfile* c_ssimfile_sorted_Find(u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDb.c_ssimfile_sorted.Getary
inline algo::aryptr<amc::FSsimfile*> c_ssimfile_sorted_Getary() __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDb.c_ssimfile_sorted.Insert
void                 c_ssimfile_sorted_Insert(amc::FSsimfile& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FDb.c_ssimfile_sorted.InsertMaybe
bool                 c_ssimfile_sorted_InsertMaybe(amc::FSsimfile& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDb.c_ssimfile_sorted.N
inline i32           c_ssimfile_sorted_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDb.c_ssimfile_sorted.Remove
void                 c_ssimfile_sorted_Remove(amc::FSsimfile& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.c_ssimfile_sorted.RemoveAll
inline void          c_ssimfile_sorted_RemoveAll() __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDb.c_ssimfile_sorted.Reserve
void                 c_ssimfile_sorted_Reserve(u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDb.c_ssimfile_sorted.qFind
inline amc::FSsimfile& c_ssimfile_sorted_qFind(u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FDb.c_ssimfile_sorted.InAryQ
inline bool          c_ssimfile_sorted_InAryQ(amc::FSsimfile& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDb.c_ssimfile_sorted.qLast
inline amc::FSsimfile& c_ssimfile_sorted_qLast() __attribute__((nothrow));

// Return true if index is empty
// func:amc.FDb.zd_ssimfile_todo.EmptyQ
inline bool          zd_ssimfile_todo_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FDb.zd_ssimfile_todo.First
inline amc::FSsimfile* zd_ssimfile_todo_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FDb.zd_ssimfile_todo.InLlistQ
inline bool          zd_ssimfile_todo_InLlistQ(amc::FSsimfile& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FDb.zd_ssimfile_todo.Insert
void                 zd_ssimfile_todo_Insert(amc::FSsimfile& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FDb.zd_ssimfile_todo.Last
inline amc::FSsimfile* zd_ssimfile_todo_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FDb.zd_ssimfile_todo.N
inline i32           zd_ssimfile_todo_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FDb.zd_ssimfile_todo.Next
inline amc::FSsimfile* zd_ssimfile_todo_Next(amc::FSsimfile &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FDb.zd_ssimfile_todo.Prev
inline amc::FSsimfile* zd_ssimfile_todo_Prev(amc::FSsimfile &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDb.zd_ssimfile_todo.Remove
void                 zd_ssimfile_todo_Remove(amc::FSsimfile& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDb.zd_ssimfile_todo.RemoveAll
void                 zd_ssimfile_todo_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FDb.zd_ssimfile_todo.RemoveFirst
amc::FSsimfile*      zd_ssimfile_todo_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FDb.zd_ssimfile_todo.qLast
inline amc::FSsimfile& zd_ssimfile_todo_qLast() __attribute__((__warn_unused_result__, nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.cfast.Alloc
amc::FCfast&         cfast_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.cfast.AllocMaybe
amc::FCfast*         cfast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.cfast.InsertMaybe
amc::FCfast*         cfast_InsertMaybe(const dmmeta::Cfast &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.cfast.AllocMem
void*                cfast_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.cfast.EmptyQ
inline bool          cfast_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.cfast.Find
inline amc::FCfast*  cfast_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.cfast.Last
inline amc::FCfast*  cfast_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.cfast.N
inline i32           cfast_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.cfast.RemoveAll
void                 cfast_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.cfast.RemoveLast
void                 cfast_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.cfast.qFind
inline amc::FCfast&  cfast_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.cfast.XrefMaybe
bool                 cfast_XrefMaybe(amc::FCfast &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ffast.Alloc
amc::FFfast&         ffast_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ffast.AllocMaybe
amc::FFfast*         ffast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ffast.InsertMaybe
amc::FFfast*         ffast_InsertMaybe(const dmmeta::Ffast &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ffast.AllocMem
void*                ffast_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ffast.EmptyQ
inline bool          ffast_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ffast.Find
inline amc::FFfast*  ffast_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ffast.Last
inline amc::FFfast*  ffast_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ffast.N
inline i32           ffast_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.ffast.RemoveAll
void                 ffast_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ffast.RemoveLast
void                 ffast_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ffast.qFind
inline amc::FFfast&  ffast_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ffast.XrefMaybe
bool                 ffast_XrefMaybe(amc::FFfast &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.pmaskfld_member.Alloc
amc::FPmaskfldMember& pmaskfld_member_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.pmaskfld_member.AllocMaybe
amc::FPmaskfldMember* pmaskfld_member_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.pmaskfld_member.InsertMaybe
amc::FPmaskfldMember* pmaskfld_member_InsertMaybe(const dmmeta::PmaskfldMember &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.pmaskfld_member.AllocMem
void*                pmaskfld_member_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.pmaskfld_member.EmptyQ
inline bool          pmaskfld_member_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.pmaskfld_member.Find
inline amc::FPmaskfldMember* pmaskfld_member_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.pmaskfld_member.Last
inline amc::FPmaskfldMember* pmaskfld_member_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.pmaskfld_member.N
inline i32           pmaskfld_member_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.pmaskfld_member.RemoveAll
void                 pmaskfld_member_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.pmaskfld_member.RemoveLast
void                 pmaskfld_member_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.pmaskfld_member.qFind
inline amc::FPmaskfldMember& pmaskfld_member_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.pmaskfld_member.XrefMaybe
bool                 pmaskfld_member_XrefMaybe(amc::FPmaskfldMember &row);

// Return true if hash is empty
// func:amc.FDb.ind_pmaskfld.EmptyQ
inline bool          ind_pmaskfld_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FDb.ind_pmaskfld.Find
amc::FPmaskfld*      ind_pmaskfld_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:amc.FDb.ind_pmaskfld.GetOrCreate
amc::FPmaskfld&      ind_pmaskfld_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:amc.FDb.ind_pmaskfld.N
inline i32           ind_pmaskfld_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FDb.ind_pmaskfld.InsertMaybe
bool                 ind_pmaskfld_InsertMaybe(amc::FPmaskfld& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FDb.ind_pmaskfld.Remove
void                 ind_pmaskfld_Remove(amc::FPmaskfld& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FDb.ind_pmaskfld.Reserve
void                 ind_pmaskfld_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FDb.ssimsort.Alloc
amc::FSsimsort&      ssimsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FDb.ssimsort.AllocMaybe
amc::FSsimsort*      ssimsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:amc.FDb.ssimsort.InsertMaybe
amc::FSsimsort*      ssimsort_InsertMaybe(const dmmeta::Ssimsort &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FDb.ssimsort.AllocMem
void*                ssimsort_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FDb.ssimsort.EmptyQ
inline bool          ssimsort_EmptyQ() __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FDb.ssimsort.Find
inline amc::FSsimsort* ssimsort_Find(u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FDb.ssimsort.Last
inline amc::FSsimsort* ssimsort_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FDb.ssimsort.N
inline i32           ssimsort_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FDb.ssimsort.RemoveAll
void                 ssimsort_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FDb.ssimsort.RemoveLast
void                 ssimsort_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FDb.ssimsort.qFind
inline amc::FSsimsort& ssimsort_qFind(u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FDb.ssimsort.XrefMaybe
bool                 ssimsort_XrefMaybe(amc::FSsimsort &row);

// cursor points to valid item
// func:amc.FDb.fsort_curs.Reset
inline void          _db_fsort_curs_Reset(_db_fsort_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fsort_curs.ValidQ
inline bool          _db_fsort_curs_ValidQ(_db_fsort_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fsort_curs.Next
inline void          _db_fsort_curs_Next(_db_fsort_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fsort_curs.Access
inline amc::FFsort&  _db_fsort_curs_Access(_db_fsort_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispfilter_curs.Reset
inline void          _db_dispfilter_curs_Reset(_db_dispfilter_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispfilter_curs.ValidQ
inline bool          _db_dispfilter_curs_ValidQ(_db_dispfilter_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.dispfilter_curs.Next
inline void          _db_dispfilter_curs_Next(_db_dispfilter_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.dispfilter_curs.Access
inline amc::FDispfilter& _db_dispfilter_curs_Access(_db_dispfilter_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.usertracefld_curs.Reset
inline void          _db_usertracefld_curs_Reset(_db_usertracefld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.usertracefld_curs.ValidQ
inline bool          _db_usertracefld_curs_ValidQ(_db_usertracefld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.usertracefld_curs.Next
inline void          _db_usertracefld_curs_Next(_db_usertracefld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.usertracefld_curs.Access
inline amc::FUsertracefld& _db_usertracefld_curs_Access(_db_usertracefld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cfmt_curs.Reset
inline void          _db_cfmt_curs_Reset(_db_cfmt_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cfmt_curs.ValidQ
inline bool          _db_cfmt_curs_ValidQ(_db_cfmt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cfmt_curs.Next
inline void          _db_cfmt_curs_Next(_db_cfmt_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cfmt_curs.Access
inline amc::FCfmt&   _db_cfmt_curs_Access(_db_cfmt_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispatch_curs.Reset
inline void          _db_dispatch_curs_Reset(_db_dispatch_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispatch_curs.ValidQ
inline bool          _db_dispatch_curs_ValidQ(_db_dispatch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.dispatch_curs.Next
inline void          _db_dispatch_curs_Next(_db_dispatch_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.dispatch_curs.Access
inline amc::FDispatch& _db_dispatch_curs_Access(_db_dispatch_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispatch_msg_curs.Reset
inline void          _db_dispatch_msg_curs_Reset(_db_dispatch_msg_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispatch_msg_curs.ValidQ
inline bool          _db_dispatch_msg_curs_ValidQ(_db_dispatch_msg_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.dispatch_msg_curs.Next
inline void          _db_dispatch_msg_curs_Next(_db_dispatch_msg_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.dispatch_msg_curs.Access
inline amc::FDispatchmsg& _db_dispatch_msg_curs_Access(_db_dispatch_msg_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ctype_curs.Reset
inline void          _db_ctype_curs_Reset(_db_ctype_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ctype_curs.ValidQ
inline bool          _db_ctype_curs_ValidQ(_db_ctype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ctype_curs.Next
inline void          _db_ctype_curs_Next(_db_ctype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ctype_curs.Access
inline amc::FCtype&  _db_ctype_curs_Access(_db_ctype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.field_curs.Reset
inline void          _db_field_curs_Reset(_db_field_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.field_curs.ValidQ
inline bool          _db_field_curs_ValidQ(_db_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.field_curs.Next
inline void          _db_field_curs_Next(_db_field_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.field_curs.Access
inline amc::FField&  _db_field_curs_Access(_db_field_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.basepool_curs.Reset
inline void          _db_basepool_curs_Reset(_db_basepool_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.basepool_curs.ValidQ
inline bool          _db_basepool_curs_ValidQ(_db_basepool_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.basepool_curs.Next
inline void          _db_basepool_curs_Next(_db_basepool_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.basepool_curs.Access
inline amc::FBasepool& _db_basepool_curs_Access(_db_basepool_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.llist_curs.Reset
inline void          _db_llist_curs_Reset(_db_llist_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.llist_curs.ValidQ
inline bool          _db_llist_curs_ValidQ(_db_llist_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.llist_curs.Next
inline void          _db_llist_curs_Next(_db_llist_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.llist_curs.Access
inline amc::FLlist&  _db_llist_curs_Access(_db_llist_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.anonfld_curs.Reset
inline void          _db_anonfld_curs_Reset(_db_anonfld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.anonfld_curs.ValidQ
inline bool          _db_anonfld_curs_ValidQ(_db_anonfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.anonfld_curs.Next
inline void          _db_anonfld_curs_Next(_db_anonfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.anonfld_curs.Access
inline amc::FAnonfld& _db_anonfld_curs_Access(_db_anonfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.xref_curs.Reset
inline void          _db_xref_curs_Reset(_db_xref_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.xref_curs.ValidQ
inline bool          _db_xref_curs_ValidQ(_db_xref_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.xref_curs.Next
inline void          _db_xref_curs_Next(_db_xref_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.xref_curs.Access
inline amc::FXref&   _db_xref_curs_Access(_db_xref_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ns_curs.Reset
inline void          _db_ns_curs_Reset(_db_ns_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ns_curs.ValidQ
inline bool          _db_ns_curs_ValidQ(_db_ns_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ns_curs.Next
inline void          _db_ns_curs_Next(_db_ns_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ns_curs.Access
inline amc::FNs&     _db_ns_curs_Access(_db_ns_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pnew_curs.Reset
inline void          _db_pnew_curs_Reset(_db_pnew_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pnew_curs.ValidQ
inline bool          _db_pnew_curs_ValidQ(_db_pnew_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.pnew_curs.Next
inline void          _db_pnew_curs_Next(_db_pnew_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.pnew_curs.Access
inline amc::FPnew&   _db_pnew_curs_Access(_db_pnew_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fldoffset_curs.Reset
inline void          _db_fldoffset_curs_Reset(_db_fldoffset_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fldoffset_curs.ValidQ
inline bool          _db_fldoffset_curs_ValidQ(_db_fldoffset_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fldoffset_curs.Next
inline void          _db_fldoffset_curs_Next(_db_fldoffset_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fldoffset_curs.Access
inline amc::FFldoffset& _db_fldoffset_curs_Access(_db_fldoffset_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.typefld_curs.Reset
inline void          _db_typefld_curs_Reset(_db_typefld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.typefld_curs.ValidQ
inline bool          _db_typefld_curs_ValidQ(_db_typefld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.typefld_curs.Next
inline void          _db_typefld_curs_Next(_db_typefld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.typefld_curs.Access
inline amc::FTypefld& _db_typefld_curs_Access(_db_typefld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.lenfld_curs.Reset
inline void          _db_lenfld_curs_Reset(_db_lenfld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.lenfld_curs.ValidQ
inline bool          _db_lenfld_curs_ValidQ(_db_lenfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.lenfld_curs.Next
inline void          _db_lenfld_curs_Next(_db_lenfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.lenfld_curs.Access
inline amc::FLenfld& _db_lenfld_curs_Access(_db_lenfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.bltin_curs.Reset
inline void          _db_bltin_curs_Reset(_db_bltin_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.bltin_curs.ValidQ
inline bool          _db_bltin_curs_ValidQ(_db_bltin_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.bltin_curs.Next
inline void          _db_bltin_curs_Next(_db_bltin_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.bltin_curs.Access
inline amc::FBltin&  _db_bltin_curs_Access(_db_bltin_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.static_tuple_curs.Reset
inline void          _db_static_tuple_curs_Reset(_db_static_tuple_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.static_tuple_curs.ValidQ
inline bool          _db_static_tuple_curs_ValidQ(_db_static_tuple_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.static_tuple_curs.Next
inline void          _db_static_tuple_curs_Next(_db_static_tuple_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.static_tuple_curs.Access
inline amc::FStatictuple& _db_static_tuple_curs_Access(_db_static_tuple_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.msgtype_curs.Reset
inline void          _db_msgtype_curs_Reset(_db_msgtype_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.msgtype_curs.ValidQ
inline bool          _db_msgtype_curs_ValidQ(_db_msgtype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.msgtype_curs.Next
inline void          _db_msgtype_curs_Next(_db_msgtype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.msgtype_curs.Access
inline amc::FMsgtype& _db_msgtype_curs_Access(_db_msgtype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gconst_curs.Reset
inline void          _db_gconst_curs_Reset(_db_gconst_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gconst_curs.ValidQ
inline bool          _db_gconst_curs_ValidQ(_db_gconst_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.gconst_curs.Next
inline void          _db_gconst_curs_Next(_db_gconst_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.gconst_curs.Access
inline amc::FGconst& _db_gconst_curs_Access(_db_gconst_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gstatic_curs.Reset
inline void          _db_gstatic_curs_Reset(_db_gstatic_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gstatic_curs.ValidQ
inline bool          _db_gstatic_curs_ValidQ(_db_gstatic_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.gstatic_curs.Next
inline void          _db_gstatic_curs_Next(_db_gstatic_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.gstatic_curs.Access
inline amc::FGstatic& _db_gstatic_curs_Access(_db_gstatic_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.thash_curs.Reset
inline void          _db_thash_curs_Reset(_db_thash_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.thash_curs.ValidQ
inline bool          _db_thash_curs_ValidQ(_db_thash_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.thash_curs.Next
inline void          _db_thash_curs_Next(_db_thash_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.thash_curs.Access
inline amc::FThash&  _db_thash_curs_Access(_db_thash_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.func_curs.Reset
inline void          _db_func_curs_Reset(_db_func_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.func_curs.ValidQ
inline bool          _db_func_curs_ValidQ(_db_func_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.func_curs.Next
inline void          _db_func_curs_Next(_db_func_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.func_curs.Access
inline amc::FFunc&   _db_func_curs_Access(_db_func_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.smallstr_curs.Reset
inline void          _db_smallstr_curs_Reset(_db_smallstr_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.smallstr_curs.ValidQ
inline bool          _db_smallstr_curs_ValidQ(_db_smallstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.smallstr_curs.Next
inline void          _db_smallstr_curs_Next(_db_smallstr_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.smallstr_curs.Access
inline amc::FSmallstr& _db_smallstr_curs_Access(_db_smallstr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.numstr_curs.Reset
inline void          _db_numstr_curs_Reset(_db_numstr_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.numstr_curs.ValidQ
inline bool          _db_numstr_curs_ValidQ(_db_numstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.numstr_curs.Next
inline void          _db_numstr_curs_Next(_db_numstr_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.numstr_curs.Access
inline amc::FNumstr& _db_numstr_curs_Access(_db_numstr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.main_curs.Reset
inline void          _db_main_curs_Reset(_db_main_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.main_curs.ValidQ
inline bool          _db_main_curs_ValidQ(_db_main_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.main_curs.Next
inline void          _db_main_curs_Next(_db_main_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.main_curs.Access
inline amc::FMain&   _db_main_curs_Access(_db_main_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.reftype_curs.Reset
inline void          _db_reftype_curs_Reset(_db_reftype_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.reftype_curs.ValidQ
inline bool          _db_reftype_curs_ValidQ(_db_reftype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.reftype_curs.Next
inline void          _db_reftype_curs_Next(_db_reftype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.reftype_curs.Access
inline amc::FReftype& _db_reftype_curs_Access(_db_reftype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cpptype_curs.Reset
inline void          _db_cpptype_curs_Reset(_db_cpptype_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cpptype_curs.ValidQ
inline bool          _db_cpptype_curs_ValidQ(_db_cpptype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cpptype_curs.Next
inline void          _db_cpptype_curs_Next(_db_cpptype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cpptype_curs.Access
inline amc::FCpptype& _db_cpptype_curs_Access(_db_cpptype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.inlary_curs.Reset
inline void          _db_inlary_curs_Reset(_db_inlary_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.inlary_curs.ValidQ
inline bool          _db_inlary_curs_ValidQ(_db_inlary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.inlary_curs.Next
inline void          _db_inlary_curs_Next(_db_inlary_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.inlary_curs.Access
inline amc::FInlary& _db_inlary_curs_Access(_db_inlary_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tary_curs.Reset
inline void          _db_tary_curs_Reset(_db_tary_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tary_curs.ValidQ
inline bool          _db_tary_curs_ValidQ(_db_tary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.tary_curs.Next
inline void          _db_tary_curs_Next(_db_tary_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.tary_curs.Access
inline amc::FTary&   _db_tary_curs_Access(_db_tary_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cppfunc_curs.Reset
inline void          _db_cppfunc_curs_Reset(_db_cppfunc_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cppfunc_curs.ValidQ
inline bool          _db_cppfunc_curs_ValidQ(_db_cppfunc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cppfunc_curs.Next
inline void          _db_cppfunc_curs_Next(_db_cppfunc_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cppfunc_curs.Access
inline amc::FCppfunc& _db_cppfunc_curs_Access(_db_cppfunc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.rowid_curs.Reset
inline void          _db_rowid_curs_Reset(_db_rowid_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.rowid_curs.ValidQ
inline bool          _db_rowid_curs_ValidQ(_db_rowid_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.rowid_curs.Next
inline void          _db_rowid_curs_Next(_db_rowid_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.rowid_curs.Access
inline amc::FRowid&  _db_rowid_curs_Access(_db_rowid_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cascdel_curs.Reset
inline void          _db_cascdel_curs_Reset(_db_cascdel_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cascdel_curs.ValidQ
inline bool          _db_cascdel_curs_ValidQ(_db_cascdel_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cascdel_curs.Next
inline void          _db_cascdel_curs_Next(_db_cascdel_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cascdel_curs.Access
inline amc::FCascdel& _db_cascdel_curs_Access(_db_cascdel_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.substr_curs.Reset
inline void          _db_substr_curs_Reset(_db_substr_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.substr_curs.ValidQ
inline bool          _db_substr_curs_ValidQ(_db_substr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.substr_curs.Next
inline void          _db_substr_curs_Next(_db_substr_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.substr_curs.Access
inline amc::FSubstr& _db_substr_curs_Access(_db_substr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.bitfld_curs.Reset
inline void          _db_bitfld_curs_Reset(_db_bitfld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.bitfld_curs.ValidQ
inline bool          _db_bitfld_curs_ValidQ(_db_bitfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.bitfld_curs.Next
inline void          _db_bitfld_curs_Next(_db_bitfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.bitfld_curs.Access
inline amc::FBitfld& _db_bitfld_curs_Access(_db_bitfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ssimfile_curs.Reset
inline void          _db_ssimfile_curs_Reset(_db_ssimfile_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ssimfile_curs.ValidQ
inline bool          _db_ssimfile_curs_ValidQ(_db_ssimfile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ssimfile_curs.Next
inline void          _db_ssimfile_curs_Next(_db_ssimfile_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ssimfile_curs.Access
inline amc::FSsimfile& _db_ssimfile_curs_Access(_db_ssimfile_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pack_curs.Reset
inline void          _db_pack_curs_Reset(_db_pack_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pack_curs.ValidQ
inline bool          _db_pack_curs_ValidQ(_db_pack_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.pack_curs.Next
inline void          _db_pack_curs_Next(_db_pack_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.pack_curs.Access
inline amc::FPack&   _db_pack_curs_Access(_db_pack_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ptrary_curs.Reset
inline void          _db_ptrary_curs_Reset(_db_ptrary_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ptrary_curs.ValidQ
inline bool          _db_ptrary_curs_ValidQ(_db_ptrary_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ptrary_curs.Next
inline void          _db_ptrary_curs_Next(_db_ptrary_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ptrary_curs.Access
inline amc::FPtrary& _db_ptrary_curs_Access(_db_ptrary_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_ctype_sorted_curs.Reset
inline void          _db_c_ctype_sorted_curs_Reset(_db_c_ctype_sorted_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_ctype_sorted_curs.ValidQ
inline bool          _db_c_ctype_sorted_curs_ValidQ(_db_c_ctype_sorted_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_ctype_sorted_curs.Next
inline void          _db_c_ctype_sorted_curs_Next(_db_c_ctype_sorted_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_ctype_sorted_curs.Access
inline amc::FCtype&  _db_c_ctype_sorted_curs_Access(_db_c_ctype_sorted_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.enumstr_curs.Reset
inline void          _db_enumstr_curs_Reset(_db_enumstr_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.enumstr_curs.ValidQ
inline bool          _db_enumstr_curs_ValidQ(_db_enumstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.enumstr_curs.Next
inline void          _db_enumstr_curs_Next(_db_enumstr_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.enumstr_curs.Access
inline amc::FEnumstr& _db_enumstr_curs_Access(_db_enumstr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.enumstr_len_curs.Reset
inline void          _db_enumstr_len_curs_Reset(_db_enumstr_len_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.enumstr_len_curs.ValidQ
inline bool          _db_enumstr_len_curs_ValidQ(_db_enumstr_len_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.enumstr_len_curs.Next
inline void          _db_enumstr_len_curs_Next(_db_enumstr_len_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.enumstr_len_curs.Access
inline amc::FEnumstrLen& _db_enumstr_len_curs_Access(_db_enumstr_len_curs &curs) __attribute__((nothrow));
// func:amc.FDb.bh_enumstr_len_curs.Reserve
void                 _db_bh_enumstr_len_curs_Reserve(_db_bh_enumstr_len_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:amc.FDb.bh_enumstr_len_curs.Reset
void                 _db_bh_enumstr_len_curs_Reset(_db_bh_enumstr_len_curs &curs, amc::FDb &parent);
// Advance cursor.
// func:amc.FDb.bh_enumstr_len_curs.Next
void                 _db_bh_enumstr_len_curs_Next(_db_bh_enumstr_len_curs &curs);
// Access current element. If not more elements, return NULL
// func:amc.FDb.bh_enumstr_len_curs.Access
inline amc::FEnumstrLen& _db_bh_enumstr_len_curs_Access(_db_bh_enumstr_len_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:amc.FDb.bh_enumstr_len_curs.ValidQ
inline bool          _db_bh_enumstr_len_curs_ValidQ(_db_bh_enumstr_len_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbitset_curs.Reset
inline void          _db_fbitset_curs_Reset(_db_fbitset_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbitset_curs.ValidQ
inline bool          _db_fbitset_curs_ValidQ(_db_fbitset_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fbitset_curs.Next
inline void          _db_fbitset_curs_Next(_db_fbitset_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fbitset_curs.Access
inline amc::FFbitset& _db_fbitset_curs_Access(_db_fbitset_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcleanup_curs.Reset
inline void          _db_fcleanup_curs_Reset(_db_fcleanup_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcleanup_curs.ValidQ
inline bool          _db_fcleanup_curs_ValidQ(_db_fcleanup_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcleanup_curs.Next
inline void          _db_fcleanup_curs_Next(_db_fcleanup_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcleanup_curs.Access
inline amc::FFcleanup& _db_fcleanup_curs_Access(_db_fcleanup_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fdec_curs.Reset
inline void          _db_fdec_curs_Reset(_db_fdec_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fdec_curs.ValidQ
inline bool          _db_fdec_curs_ValidQ(_db_fdec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fdec_curs.Next
inline void          _db_fdec_curs_Next(_db_fdec_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fdec_curs.Access
inline amc::FFdec&   _db_fdec_curs_Access(_db_fdec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fconst_curs.Reset
inline void          _db_fconst_curs_Reset(_db_fconst_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fconst_curs.ValidQ
inline bool          _db_fconst_curs_ValidQ(_db_fconst_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fconst_curs.Next
inline void          _db_fconst_curs_Next(_db_fconst_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fconst_curs.Access
inline amc::FFconst& _db_fconst_curs_Access(_db_fconst_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_ns_sorted_curs.Reset
inline void          _db_c_ns_sorted_curs_Reset(_db_c_ns_sorted_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_ns_sorted_curs.ValidQ
inline bool          _db_c_ns_sorted_curs_ValidQ(_db_c_ns_sorted_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_ns_sorted_curs.Next
inline void          _db_c_ns_sorted_curs_Next(_db_c_ns_sorted_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_ns_sorted_curs.Access
inline amc::FNs&     _db_c_ns_sorted_curs_Access(_db_c_ns_sorted_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.finput_curs.Reset
inline void          _db_finput_curs_Reset(_db_finput_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.finput_curs.ValidQ
inline bool          _db_finput_curs_ValidQ(_db_finput_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.finput_curs.Next
inline void          _db_finput_curs_Next(_db_finput_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.finput_curs.Access
inline amc::FFinput& _db_finput_curs_Access(_db_finput_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.foutput_curs.Reset
inline void          _db_foutput_curs_Reset(_db_foutput_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.foutput_curs.ValidQ
inline bool          _db_foutput_curs_ValidQ(_db_foutput_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.foutput_curs.Next
inline void          _db_foutput_curs_Next(_db_foutput_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.foutput_curs.Access
inline amc::FFoutput& _db_foutput_curs_Access(_db_foutput_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbuf_curs.Reset
inline void          _db_fbuf_curs_Reset(_db_fbuf_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbuf_curs.ValidQ
inline bool          _db_fbuf_curs_ValidQ(_db_fbuf_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fbuf_curs.Next
inline void          _db_fbuf_curs_Next(_db_fbuf_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fbuf_curs.Access
inline amc::FFbuf&   _db_fbuf_curs_Access(_db_fbuf_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.chash_curs.Reset
inline void          _db_chash_curs_Reset(_db_chash_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.chash_curs.ValidQ
inline bool          _db_chash_curs_ValidQ(_db_chash_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.chash_curs.Next
inline void          _db_chash_curs_Next(_db_chash_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.chash_curs.Access
inline amc::FChash&  _db_chash_curs_Access(_db_chash_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ccmp_curs.Reset
inline void          _db_ccmp_curs_Reset(_db_ccmp_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ccmp_curs.ValidQ
inline bool          _db_ccmp_curs_ValidQ(_db_ccmp_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ccmp_curs.Next
inline void          _db_ccmp_curs_Next(_db_ccmp_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ccmp_curs.Access
inline amc::FCcmp&   _db_ccmp_curs_Access(_db_ccmp_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbigend_curs.Reset
inline void          _db_fbigend_curs_Reset(_db_fbigend_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbigend_curs.ValidQ
inline bool          _db_fbigend_curs_ValidQ(_db_fbigend_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fbigend_curs.Next
inline void          _db_fbigend_curs_Next(_db_fbigend_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fbigend_curs.Access
inline amc::FFbigend& _db_fbigend_curs_Access(_db_fbigend_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zsl_ctype_pack_tran_curs.Reset
inline void          _db_zsl_ctype_pack_tran_curs_Reset(_db_zsl_ctype_pack_tran_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zsl_ctype_pack_tran_curs.ValidQ
inline bool          _db_zsl_ctype_pack_tran_curs_ValidQ(_db_zsl_ctype_pack_tran_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.zsl_ctype_pack_tran_curs.Next
inline void          _db_zsl_ctype_pack_tran_curs_Next(_db_zsl_ctype_pack_tran_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.zsl_ctype_pack_tran_curs.Access
inline amc::FCtype&  _db_zsl_ctype_pack_tran_curs_Access(_db_zsl_ctype_pack_tran_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cstr_curs.Reset
inline void          _db_cstr_curs_Reset(_db_cstr_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cstr_curs.ValidQ
inline bool          _db_cstr_curs_ValidQ(_db_cstr_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cstr_curs.Next
inline void          _db_cstr_curs_Next(_db_cstr_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cstr_curs.Access
inline amc::FCstr&   _db_cstr_curs_Access(_db_cstr_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.listtype_curs.Reset
inline void          _db_listtype_curs_Reset(_db_listtype_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.listtype_curs.ValidQ
inline bool          _db_listtype_curs_ValidQ(_db_listtype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.listtype_curs.Next
inline void          _db_listtype_curs_Next(_db_listtype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.listtype_curs.Access
inline amc::FListtype& _db_listtype_curs_Access(_db_listtype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fstep_curs.Reset
inline void          _db_fstep_curs_Reset(_db_fstep_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fstep_curs.ValidQ
inline bool          _db_fstep_curs_ValidQ(_db_fstep_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fstep_curs.Next
inline void          _db_fstep_curs_Next(_db_fstep_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fstep_curs.Access
inline amc::FFstep&  _db_fstep_curs_Access(_db_fstep_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cextern_curs.Reset
inline void          _db_cextern_curs_Reset(_db_cextern_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cextern_curs.ValidQ
inline bool          _db_cextern_curs_ValidQ(_db_cextern_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cextern_curs.Next
inline void          _db_cextern_curs_Next(_db_cextern_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cextern_curs.Access
inline amc::FCextern& _db_cextern_curs_Access(_db_cextern_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fdelay_curs.Reset
inline void          _db_fdelay_curs_Reset(_db_fdelay_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fdelay_curs.ValidQ
inline bool          _db_fdelay_curs_ValidQ(_db_fdelay_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fdelay_curs.Next
inline void          _db_fdelay_curs_Next(_db_fdelay_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fdelay_curs.Access
inline amc::FFdelay& _db_fdelay_curs_Access(_db_fdelay_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.disptrace_curs.Reset
inline void          _db_disptrace_curs_Reset(_db_disptrace_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.disptrace_curs.ValidQ
inline bool          _db_disptrace_curs_ValidQ(_db_disptrace_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.disptrace_curs.Next
inline void          _db_disptrace_curs_Next(_db_disptrace_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.disptrace_curs.Access
inline amc::FDisptrace& _db_disptrace_curs_Access(_db_disptrace_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tracefld_curs.Reset
inline void          _db_tracefld_curs_Reset(_db_tracefld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tracefld_curs.ValidQ
inline bool          _db_tracefld_curs_ValidQ(_db_tracefld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.tracefld_curs.Next
inline void          _db_tracefld_curs_Next(_db_tracefld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.tracefld_curs.Access
inline amc::FTracefld& _db_tracefld_curs_Access(_db_tracefld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tracerec_curs.Reset
inline void          _db_tracerec_curs_Reset(_db_tracerec_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tracerec_curs.ValidQ
inline bool          _db_tracerec_curs_ValidQ(_db_tracerec_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.tracerec_curs.Next
inline void          _db_tracerec_curs_Next(_db_tracerec_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.tracerec_curs.Access
inline amc::FTracerec& _db_tracerec_curs_Access(_db_tracerec_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispsig_curs.Reset
inline void          _db_dispsig_curs_Reset(_db_dispsig_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispsig_curs.ValidQ
inline bool          _db_dispsig_curs_ValidQ(_db_dispsig_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.dispsig_curs.Next
inline void          _db_dispsig_curs_Next(_db_dispsig_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.dispsig_curs.Access
inline amc::FDispsig& _db_dispsig_curs_Access(_db_dispsig_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_dispsig_sorted_curs.Reset
inline void          _db_c_dispsig_sorted_curs_Reset(_db_c_dispsig_sorted_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_dispsig_sorted_curs.ValidQ
inline bool          _db_c_dispsig_sorted_curs_ValidQ(_db_c_dispsig_sorted_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_dispsig_sorted_curs.Next
inline void          _db_c_dispsig_sorted_curs_Next(_db_c_dispsig_sorted_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_dispsig_sorted_curs.Access
inline amc::FDispsig& _db_c_dispsig_sorted_curs_Access(_db_c_dispsig_sorted_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zs_sig_visit_curs.Reset
inline void          _db_zs_sig_visit_curs_Reset(_db_zs_sig_visit_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zs_sig_visit_curs.ValidQ
inline bool          _db_zs_sig_visit_curs_ValidQ(_db_zs_sig_visit_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.zs_sig_visit_curs.Next
inline void          _db_zs_sig_visit_curs_Next(_db_zs_sig_visit_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.zs_sig_visit_curs.Access
inline amc::FCtype&  _db_zs_sig_visit_curs_Access(_db_zs_sig_visit_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.target_curs.Reset
inline void          _db_target_curs_Reset(_db_target_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.target_curs.ValidQ
inline bool          _db_target_curs_ValidQ(_db_target_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.target_curs.Next
inline void          _db_target_curs_Next(_db_target_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.target_curs.Access
inline amc::FTarget& _db_target_curs_Access(_db_target_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.targdep_curs.Reset
inline void          _db_targdep_curs_Reset(_db_targdep_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.targdep_curs.ValidQ
inline bool          _db_targdep_curs_ValidQ(_db_targdep_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.targdep_curs.Next
inline void          _db_targdep_curs_Next(_db_targdep_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.targdep_curs.Access
inline amc::FTargdep& _db_targdep_curs_Access(_db_targdep_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispctx_curs.Reset
inline void          _db_dispctx_curs_Reset(_db_dispctx_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.dispctx_curs.ValidQ
inline bool          _db_dispctx_curs_ValidQ(_db_dispctx_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.dispctx_curs.Next
inline void          _db_dispctx_curs_Next(_db_dispctx_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.dispctx_curs.Access
inline amc::FDispctx& _db_dispctx_curs_Access(_db_dispctx_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pmaskfld_curs.Reset
inline void          _db_pmaskfld_curs_Reset(_db_pmaskfld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pmaskfld_curs.ValidQ
inline bool          _db_pmaskfld_curs_ValidQ(_db_pmaskfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.pmaskfld_curs.Next
inline void          _db_pmaskfld_curs_Next(_db_pmaskfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.pmaskfld_curs.Access
inline amc::FPmaskfld& _db_pmaskfld_curs_Access(_db_pmaskfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fwddecl_curs.Reset
inline void          _db_fwddecl_curs_Reset(_db_fwddecl_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fwddecl_curs.ValidQ
inline bool          _db_fwddecl_curs_ValidQ(_db_fwddecl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fwddecl_curs.Next
inline void          _db_fwddecl_curs_Next(_db_fwddecl_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fwddecl_curs.Access
inline amc::FFwddecl& _db_fwddecl_curs_Access(_db_fwddecl_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tfunc_curs.Reset
inline void          _db_tfunc_curs_Reset(_db_tfunc_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tfunc_curs.ValidQ
inline bool          _db_tfunc_curs_ValidQ(_db_tfunc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.tfunc_curs.Next
inline void          _db_tfunc_curs_Next(_db_tfunc_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.tfunc_curs.Access
inline amc::FTfunc&  _db_tfunc_curs_Access(_db_tfunc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gen_curs.Reset
inline void          _db_gen_curs_Reset(_db_gen_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gen_curs.ValidQ
inline bool          _db_gen_curs_ValidQ(_db_gen_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.gen_curs.Next
inline void          _db_gen_curs_Next(_db_gen_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.gen_curs.Access
inline amc::FGen&    _db_gen_curs_Access(_db_gen_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fregx_curs.Reset
inline void          _db_fregx_curs_Reset(_db_fregx_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fregx_curs.ValidQ
inline bool          _db_fregx_curs_ValidQ(_db_fregx_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fregx_curs.Next
inline void          _db_fregx_curs_Next(_db_fregx_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fregx_curs.Access
inline amc::FFregx&  _db_fregx_curs_Access(_db_fregx_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tclass_curs.Reset
inline void          _db_tclass_curs_Reset(_db_tclass_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tclass_curs.ValidQ
inline bool          _db_tclass_curs_ValidQ(_db_tclass_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.tclass_curs.Next
inline void          _db_tclass_curs_Next(_db_tclass_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.tclass_curs.Access
inline amc::FTclass& _db_tclass_curs_Access(_db_tclass_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcmp_curs.Reset
inline void          _db_fcmp_curs_Reset(_db_fcmp_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcmp_curs.ValidQ
inline bool          _db_fcmp_curs_ValidQ(_db_fcmp_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcmp_curs.Next
inline void          _db_fcmp_curs_Next(_db_fcmp_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcmp_curs.Access
inline amc::FFcmp&   _db_fcmp_curs_Access(_db_fcmp_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcast_curs.Reset
inline void          _db_fcast_curs_Reset(_db_fcast_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcast_curs.ValidQ
inline bool          _db_fcast_curs_ValidQ(_db_fcast_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcast_curs.Next
inline void          _db_fcast_curs_Next(_db_fcast_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcast_curs.Access
inline amc::FFcast&  _db_fcast_curs_Access(_db_fcast_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.noxref_curs.Reset
inline void          _db_noxref_curs_Reset(_db_noxref_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.noxref_curs.ValidQ
inline bool          _db_noxref_curs_ValidQ(_db_noxref_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.noxref_curs.Next
inline void          _db_noxref_curs_Next(_db_noxref_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.noxref_curs.Access
inline amc::FNoxref& _db_noxref_curs_Access(_db_noxref_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nocascdel_curs.Reset
inline void          _db_nocascdel_curs_Reset(_db_nocascdel_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nocascdel_curs.ValidQ
inline bool          _db_nocascdel_curs_ValidQ(_db_nocascdel_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nocascdel_curs.Next
inline void          _db_nocascdel_curs_Next(_db_nocascdel_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nocascdel_curs.Access
inline amc::FNocascdel& _db_nocascdel_curs_Access(_db_nocascdel_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cafter_curs.Reset
inline void          _db_cafter_curs_Reset(_db_cafter_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cafter_curs.ValidQ
inline bool          _db_cafter_curs_ValidQ(_db_cafter_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cafter_curs.Next
inline void          _db_cafter_curs_Next(_db_cafter_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cafter_curs.Access
inline amc::FCafter& _db_cafter_curs_Access(_db_cafter_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.csize_curs.Reset
inline void          _db_csize_curs_Reset(_db_csize_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.csize_curs.ValidQ
inline bool          _db_csize_curs_ValidQ(_db_csize_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.csize_curs.Next
inline void          _db_csize_curs_Next(_db_csize_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.csize_curs.Access
inline amc::FCsize&  _db_csize_curs_Access(_db_csize_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsx_curs.Reset
inline void          _db_nsx_curs_Reset(_db_nsx_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsx_curs.ValidQ
inline bool          _db_nsx_curs_ValidQ(_db_nsx_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nsx_curs.Next
inline void          _db_nsx_curs_Next(_db_nsx_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nsx_curs.Access
inline amc::FNsx&    _db_nsx_curs_Access(_db_nsx_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcompact_curs.Reset
inline void          _db_fcompact_curs_Reset(_db_fcompact_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcompact_curs.ValidQ
inline bool          _db_fcompact_curs_ValidQ(_db_fcompact_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcompact_curs.Next
inline void          _db_fcompact_curs_Next(_db_fcompact_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcompact_curs.Access
inline amc::FFcompact& _db_fcompact_curs_Access(_db_fcompact_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.findrem_curs.Reset
inline void          _db_findrem_curs_Reset(_db_findrem_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.findrem_curs.ValidQ
inline bool          _db_findrem_curs_ValidQ(_db_findrem_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.findrem_curs.Next
inline void          _db_findrem_curs_Next(_db_findrem_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.findrem_curs.Access
inline amc::FFindrem& _db_findrem_curs_Access(_db_findrem_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcurs_curs.Reset
inline void          _db_fcurs_curs_Reset(_db_fcurs_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcurs_curs.ValidQ
inline bool          _db_fcurs_curs_ValidQ(_db_fcurs_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcurs_curs.Next
inline void          _db_fcurs_curs_Next(_db_fcurs_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcurs_curs.Access
inline amc::FFcurs&  _db_fcurs_curs_Access(_db_fcurs_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cdflt_curs.Reset
inline void          _db_cdflt_curs_Reset(_db_cdflt_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cdflt_curs.ValidQ
inline bool          _db_cdflt_curs_ValidQ(_db_cdflt_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cdflt_curs.Next
inline void          _db_cdflt_curs_Next(_db_cdflt_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cdflt_curs.Access
inline amc::FCdflt&  _db_cdflt_curs_Access(_db_cdflt_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.argvtype_curs.Reset
inline void          _db_argvtype_curs_Reset(_db_argvtype_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.argvtype_curs.ValidQ
inline bool          _db_argvtype_curs_ValidQ(_db_argvtype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.argvtype_curs.Next
inline void          _db_argvtype_curs_Next(_db_argvtype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.argvtype_curs.Access
inline amc::FArgvtype& _db_argvtype_curs_Access(_db_argvtype_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcmdline_curs.Reset
inline void          _db_fcmdline_curs_Reset(_db_fcmdline_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcmdline_curs.ValidQ
inline bool          _db_fcmdline_curs_ValidQ(_db_fcmdline_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcmdline_curs.Next
inline void          _db_fcmdline_curs_Next(_db_fcmdline_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcmdline_curs.Access
inline amc::FFcmdline& _db_fcmdline_curs_Access(_db_fcmdline_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.floadtuples_curs.Reset
inline void          _db_floadtuples_curs_Reset(_db_floadtuples_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.floadtuples_curs.ValidQ
inline bool          _db_floadtuples_curs_ValidQ(_db_floadtuples_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.floadtuples_curs.Next
inline void          _db_floadtuples_curs_Next(_db_floadtuples_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.floadtuples_curs.Access
inline amc::FFloadtuples& _db_floadtuples_curs_Access(_db_floadtuples_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcmap_curs.Reset
inline void          _db_fcmap_curs_Reset(_db_fcmap_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fcmap_curs.ValidQ
inline bool          _db_fcmap_curs_ValidQ(_db_fcmap_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fcmap_curs.Next
inline void          _db_fcmap_curs_Next(_db_fcmap_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fcmap_curs.Access
inline amc::FFcmap&  _db_fcmap_curs_Access(_db_fcmap_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zs_ordkeyfield_curs.Reset
inline void          _db_zs_ordkeyfield_curs_Reset(_db_zs_ordkeyfield_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zs_ordkeyfield_curs.ValidQ
inline bool          _db_zs_ordkeyfield_curs_ValidQ(_db_zs_ordkeyfield_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.zs_ordkeyfield_curs.Next
inline void          _db_zs_ordkeyfield_curs_Next(_db_zs_ordkeyfield_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.zs_ordkeyfield_curs.Access
inline amc::FField&  _db_zs_ordkeyfield_curs_Access(_db_zs_ordkeyfield_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsproto_curs.Reset
inline void          _db_nsproto_curs_Reset(_db_nsproto_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsproto_curs.ValidQ
inline bool          _db_nsproto_curs_ValidQ(_db_nsproto_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nsproto_curs.Next
inline void          _db_nsproto_curs_Next(_db_nsproto_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nsproto_curs.Access
inline amc::FNsproto& _db_nsproto_curs_Access(_db_nsproto_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsdb_curs.Reset
inline void          _db_nsdb_curs_Reset(_db_nsdb_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsdb_curs.ValidQ
inline bool          _db_nsdb_curs_ValidQ(_db_nsdb_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nsdb_curs.Next
inline void          _db_nsdb_curs_Next(_db_nsdb_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nsdb_curs.Access
inline amc::FNsdb&   _db_nsdb_curs_Access(_db_nsdb_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zd_substr_params_curs.Reset
inline void          _db_zd_substr_params_curs_Reset(_db_zd_substr_params_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zd_substr_params_curs.ValidQ
inline bool          _db_zd_substr_params_curs_ValidQ(_db_zd_substr_params_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.zd_substr_params_curs.Next
inline void          _db_zd_substr_params_curs_Next(_db_zd_substr_params_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.zd_substr_params_curs.Access
inline amc::FSubstr& _db_zd_substr_params_curs_Access(_db_zd_substr_params_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fprefix_curs.Reset
inline void          _db_fprefix_curs_Reset(_db_fprefix_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fprefix_curs.ValidQ
inline bool          _db_fprefix_curs_ValidQ(_db_fprefix_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fprefix_curs.Next
inline void          _db_fprefix_curs_Next(_db_fprefix_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fprefix_curs.Access
inline amc::FFprefix& _db_fprefix_curs_Access(_db_fprefix_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ftrace_curs.Reset
inline void          _db_ftrace_curs_Reset(_db_ftrace_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ftrace_curs.ValidQ
inline bool          _db_ftrace_curs_ValidQ(_db_ftrace_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ftrace_curs.Next
inline void          _db_ftrace_curs_Next(_db_ftrace_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ftrace_curs.Access
inline amc::FFtrace& _db_ftrace_curs_Access(_db_ftrace_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fnoremove_curs.Reset
inline void          _db_fnoremove_curs_Reset(_db_fnoremove_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fnoremove_curs.ValidQ
inline bool          _db_fnoremove_curs_ValidQ(_db_fnoremove_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fnoremove_curs.Next
inline void          _db_fnoremove_curs_Next(_db_fnoremove_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fnoremove_curs.Access
inline amc::FFnoremove& _db_fnoremove_curs_Access(_db_fnoremove_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_substr_field_curs.Reset
inline void          _db_c_substr_field_curs_Reset(_db_c_substr_field_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_substr_field_curs.ValidQ
inline bool          _db_c_substr_field_curs_ValidQ(_db_c_substr_field_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_substr_field_curs.Next
inline void          _db_c_substr_field_curs_Next(_db_c_substr_field_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_substr_field_curs.Access
inline amc::FSubstr& _db_c_substr_field_curs_Access(_db_c_substr_field_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ctypelen_curs.Reset
inline void          _db_ctypelen_curs_Reset(_db_ctypelen_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ctypelen_curs.ValidQ
inline bool          _db_ctypelen_curs_ValidQ(_db_ctypelen_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ctypelen_curs.Next
inline void          _db_ctypelen_curs_Next(_db_ctypelen_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ctypelen_curs.Access
inline amc::FCtypelen& _db_ctypelen_curs_Access(_db_ctypelen_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_ctypelen_curs.Reset
inline void          _db_c_ctypelen_curs_Reset(_db_c_ctypelen_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_ctypelen_curs.ValidQ
inline bool          _db_c_ctypelen_curs_ValidQ(_db_c_ctypelen_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_ctypelen_curs.Next
inline void          _db_c_ctypelen_curs_Next(_db_c_ctypelen_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_ctypelen_curs.Access
inline amc::FCtypelen& _db_c_ctypelen_curs_Access(_db_c_ctypelen_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_tempfield_curs.Reset
inline void          _db_c_tempfield_curs_Reset(_db_c_tempfield_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_tempfield_curs.ValidQ
inline bool          _db_c_tempfield_curs_ValidQ(_db_c_tempfield_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_tempfield_curs.Next
inline void          _db_c_tempfield_curs_Next(_db_c_tempfield_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_tempfield_curs.Access
inline amc::FField&  _db_c_tempfield_curs_Access(_db_c_tempfield_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbase_curs.Reset
inline void          _db_fbase_curs_Reset(_db_fbase_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fbase_curs.ValidQ
inline bool          _db_fbase_curs_ValidQ(_db_fbase_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fbase_curs.Next
inline void          _db_fbase_curs_Next(_db_fbase_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fbase_curs.Access
inline amc::FFbase&  _db_fbase_curs_Access(_db_fbase_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nossimfile_curs.Reset
inline void          _db_nossimfile_curs_Reset(_db_nossimfile_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nossimfile_curs.ValidQ
inline bool          _db_nossimfile_curs_ValidQ(_db_nossimfile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nossimfile_curs.Next
inline void          _db_nossimfile_curs_Next(_db_nossimfile_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nossimfile_curs.Access
inline amc::FNossimfile& _db_nossimfile_curs_Access(_db_nossimfile_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gsymbol_curs.Reset
inline void          _db_gsymbol_curs_Reset(_db_gsymbol_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.gsymbol_curs.ValidQ
inline bool          _db_gsymbol_curs_ValidQ(_db_gsymbol_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.gsymbol_curs.Next
inline void          _db_gsymbol_curs_Next(_db_gsymbol_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.gsymbol_curs.Access
inline amc::FGsymbol& _db_gsymbol_curs_Access(_db_gsymbol_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.sortfld_curs.Reset
inline void          _db_sortfld_curs_Reset(_db_sortfld_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.sortfld_curs.ValidQ
inline bool          _db_sortfld_curs_ValidQ(_db_sortfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.sortfld_curs.Next
inline void          _db_sortfld_curs_Next(_db_sortfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.sortfld_curs.Access
inline amc::FSortfld& _db_sortfld_curs_Access(_db_sortfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cget_curs.Reset
inline void          _db_cget_curs_Reset(_db_cget_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cget_curs.ValidQ
inline bool          _db_cget_curs_ValidQ(_db_cget_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cget_curs.Next
inline void          _db_cget_curs_Next(_db_cget_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cget_curs.Access
inline amc::FCget&   _db_cget_curs_Access(_db_cget_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cd_temp_func_curs.Reset
inline void          _db_cd_temp_func_curs_Reset(_db_cd_temp_func_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cd_temp_func_curs.ValidQ
inline bool          _db_cd_temp_func_curs_ValidQ(_db_cd_temp_func_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cd_temp_func_curs.Next
inline void          _db_cd_temp_func_curs_Next(_db_cd_temp_func_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cd_temp_func_curs.Access
inline amc::FFunc&   _db_cd_temp_func_curs_Access(_db_cd_temp_func_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zs_gen_perns_curs.Reset
inline void          _db_zs_gen_perns_curs_Reset(_db_zs_gen_perns_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zs_gen_perns_curs.ValidQ
inline bool          _db_zs_gen_perns_curs_ValidQ(_db_zs_gen_perns_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.zs_gen_perns_curs.Next
inline void          _db_zs_gen_perns_curs_Next(_db_zs_gen_perns_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.zs_gen_perns_curs.Access
inline amc::FGen&    _db_zs_gen_perns_curs_Access(_db_zs_gen_perns_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.hook_curs.Reset
inline void          _db_hook_curs_Reset(_db_hook_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.hook_curs.ValidQ
inline bool          _db_hook_curs_ValidQ(_db_hook_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.hook_curs.Next
inline void          _db_hook_curs_Next(_db_hook_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.hook_curs.Access
inline amc::FHook&   _db_hook_curs_Access(_db_hook_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.charset_curs.Reset
inline void          _db_charset_curs_Reset(_db_charset_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.charset_curs.ValidQ
inline bool          _db_charset_curs_ValidQ(_db_charset_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.charset_curs.Next
inline void          _db_charset_curs_Next(_db_charset_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.charset_curs.Access
inline amc::FCharset& _db_charset_curs_Access(_db_charset_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsinclude_curs.Reset
inline void          _db_nsinclude_curs_Reset(_db_nsinclude_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nsinclude_curs.ValidQ
inline bool          _db_nsinclude_curs_ValidQ(_db_nsinclude_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nsinclude_curs.Next
inline void          _db_nsinclude_curs_Next(_db_nsinclude_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nsinclude_curs.Access
inline amc::FNsinclude& _db_nsinclude_curs_Access(_db_nsinclude_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ssimvolatile_curs.Reset
inline void          _db_ssimvolatile_curs_Reset(_db_ssimvolatile_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ssimvolatile_curs.ValidQ
inline bool          _db_ssimvolatile_curs_ValidQ(_db_ssimvolatile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ssimvolatile_curs.Next
inline void          _db_ssimvolatile_curs_Next(_db_ssimvolatile_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ssimvolatile_curs.Access
inline amc::FSsimvolatile& _db_ssimvolatile_curs_Access(_db_ssimvolatile_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.funique_curs.Reset
inline void          _db_funique_curs_Reset(_db_funique_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.funique_curs.ValidQ
inline bool          _db_funique_curs_ValidQ(_db_funique_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.funique_curs.Next
inline void          _db_funique_curs_Next(_db_funique_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.funique_curs.Access
inline amc::FFunique& _db_funique_curs_Access(_db_funique_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fuserinit_curs.Reset
inline void          _db_fuserinit_curs_Reset(_db_fuserinit_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fuserinit_curs.ValidQ
inline bool          _db_fuserinit_curs_ValidQ(_db_fuserinit_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fuserinit_curs.Next
inline void          _db_fuserinit_curs_Next(_db_fuserinit_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fuserinit_curs.Access
inline amc::FFuserinit& _db_fuserinit_curs_Access(_db_fuserinit_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tcurs_curs.Reset
inline void          _db_tcurs_curs_Reset(_db_tcurs_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.tcurs_curs.ValidQ
inline bool          _db_tcurs_curs_ValidQ(_db_tcurs_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.tcurs_curs.Next
inline void          _db_tcurs_curs_Next(_db_tcurs_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.tcurs_curs.Access
inline amc::FTcurs&  _db_tcurs_curs_Access(_db_tcurs_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nscpp_curs.Reset
inline void          _db_nscpp_curs_Reset(_db_nscpp_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.nscpp_curs.ValidQ
inline bool          _db_nscpp_curs_ValidQ(_db_nscpp_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.nscpp_curs.Next
inline void          _db_nscpp_curs_Next(_db_nscpp_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.nscpp_curs.Access
inline amc::FNscpp&  _db_nscpp_curs_Access(_db_nscpp_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fflag_curs.Reset
inline void          _db_fflag_curs_Reset(_db_fflag_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.fflag_curs.ValidQ
inline bool          _db_fflag_curs_ValidQ(_db_fflag_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.fflag_curs.Next
inline void          _db_fflag_curs_Next(_db_fflag_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.fflag_curs.Access
inline amc::FFflag&  _db_fflag_curs_Access(_db_fflag_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.falias_curs.Reset
inline void          _db_falias_curs_Reset(_db_falias_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.falias_curs.ValidQ
inline bool          _db_falias_curs_ValidQ(_db_falias_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.falias_curs.Next
inline void          _db_falias_curs_Next(_db_falias_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.falias_curs.Access
inline amc::FFalias& _db_falias_curs_Access(_db_falias_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.license_curs.Reset
inline void          _db_license_curs_Reset(_db_license_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.license_curs.ValidQ
inline bool          _db_license_curs_ValidQ(_db_license_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.license_curs.Next
inline void          _db_license_curs_Next(_db_license_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.license_curs.Access
inline amc::FLicense& _db_license_curs_Access(_db_license_curs &curs) __attribute__((nothrow));
// func:amc.FDb.c_ssimfile_sorted_curs.Reset
inline void          _db_c_ssimfile_sorted_curs_Reset(_db_c_ssimfile_sorted_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.c_ssimfile_sorted_curs.ValidQ
inline bool          _db_c_ssimfile_sorted_curs_ValidQ(_db_c_ssimfile_sorted_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.c_ssimfile_sorted_curs.Next
inline void          _db_c_ssimfile_sorted_curs_Next(_db_c_ssimfile_sorted_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.c_ssimfile_sorted_curs.Access
inline amc::FSsimfile& _db_c_ssimfile_sorted_curs_Access(_db_c_ssimfile_sorted_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zd_ssimfile_todo_curs.Reset
inline void          _db_zd_ssimfile_todo_curs_Reset(_db_zd_ssimfile_todo_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.zd_ssimfile_todo_curs.ValidQ
inline bool          _db_zd_ssimfile_todo_curs_ValidQ(_db_zd_ssimfile_todo_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.zd_ssimfile_todo_curs.Next
inline void          _db_zd_ssimfile_todo_curs_Next(_db_zd_ssimfile_todo_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.zd_ssimfile_todo_curs.Access
inline amc::FSsimfile& _db_zd_ssimfile_todo_curs_Access(_db_zd_ssimfile_todo_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cfast_curs.Reset
inline void          _db_cfast_curs_Reset(_db_cfast_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.cfast_curs.ValidQ
inline bool          _db_cfast_curs_ValidQ(_db_cfast_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.cfast_curs.Next
inline void          _db_cfast_curs_Next(_db_cfast_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.cfast_curs.Access
inline amc::FCfast&  _db_cfast_curs_Access(_db_cfast_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ffast_curs.Reset
inline void          _db_ffast_curs_Reset(_db_ffast_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ffast_curs.ValidQ
inline bool          _db_ffast_curs_ValidQ(_db_ffast_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ffast_curs.Next
inline void          _db_ffast_curs_Next(_db_ffast_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ffast_curs.Access
inline amc::FFfast&  _db_ffast_curs_Access(_db_ffast_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pmaskfld_member_curs.Reset
inline void          _db_pmaskfld_member_curs_Reset(_db_pmaskfld_member_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.pmaskfld_member_curs.ValidQ
inline bool          _db_pmaskfld_member_curs_ValidQ(_db_pmaskfld_member_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.pmaskfld_member_curs.Next
inline void          _db_pmaskfld_member_curs_Next(_db_pmaskfld_member_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.pmaskfld_member_curs.Access
inline amc::FPmaskfldMember& _db_pmaskfld_member_curs_Access(_db_pmaskfld_member_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ssimsort_curs.Reset
inline void          _db_ssimsort_curs_Reset(_db_ssimsort_curs &curs, amc::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDb.ssimsort_curs.ValidQ
inline bool          _db_ssimsort_curs_ValidQ(_db_ssimsort_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDb.ssimsort_curs.Next
inline void          _db_ssimsort_curs_Next(_db_ssimsort_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDb.ssimsort_curs.Access
inline amc::FSsimsort& _db_ssimsort_curs_Access(_db_ssimsort_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.FDb..Init
void                 FDb_Init();
// func:amc.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));

// --- amc.FDispatch
// create: amc.FDb.dispatch (Lary)
// global access: dispatch (Lary, by rowid)
// global access: ind_dispatch (Thash, hash field dispatch)
// access: amc.FDispatchmsg.p_dispatch (Upptr)
// access: amc.FDisptrace.p_dispatch (Upptr)
// access: amc.FNs.c_dispatch (Ptrary)
struct FDispatch { // amc.FDispatch
    amc::FDispatch*       ind_dispatch_next;      // hash next
    algo::Smallstr50      dispatch;               // Primary key (ns.name)
    bool                  unk;                    //   false  Want default case?
    bool                  read;                   //   false  Generate read function
    bool                  print;                  //   false  Generate print function
    bool                  haslen;                 //   false  Include length in dispatch function
    bool                  call;                   //   false  Generate call to user-defined function
    bool                  strict;                 //   false  Only dispatch if length matches exactly
    amc::FCtype*          p_ctype_hdr;            // reference to parent row
    amc::FCtype*          p_casetype;             // reference to parent row
    amc::FDispfilter*     c_dispfilter;           // optional pointer
    amc::FNs*             p_ns;                   // reference to parent row
    amc::FDispatchmsg**   c_dispatch_msg_elems;   // array of pointers
    u32                   c_dispatch_msg_n;       // array of pointers
    u32                   c_dispatch_msg_max;     // capacity of allocated array
    amc::FDisptrace*      c_disptrace;            // optional pointer
    algo::Sha1sig         signature;              //
    amc::FDispctx*        c_dispctx;              // optional pointer
    bool                  ns_c_dispatch_in_ary;   //   false  membership flag
    // x-reference on amc.FDispatch.c_dispfilter prevents copy
    // x-reference on amc.FDispatch.p_ns prevents copy
    // reftype Ptrary of amc.FDispatch.c_dispatch_msg prohibits copy
    // x-reference on amc.FDispatch.c_disptrace prevents copy
    // x-reference on amc.FDispatch.c_dispctx prevents copy
    // func:amc.FDispatch..AssignOp
    amc::FDispatch&      operator =(const amc::FDispatch &rhs) = delete;
    // x-reference on amc.FDispatch.c_dispfilter prevents copy
    // x-reference on amc.FDispatch.p_ns prevents copy
    // reftype Ptrary of amc.FDispatch.c_dispatch_msg prohibits copy
    // x-reference on amc.FDispatch.c_disptrace prevents copy
    // x-reference on amc.FDispatch.c_dispctx prevents copy
    // func:amc.FDispatch..CopyCtor
    FDispatch(const amc::FDispatch &rhs) = delete;
private:
    // func:amc.FDispatch..Ctor
    inline               FDispatch() __attribute__((nothrow));
    // func:amc.FDispatch..Dtor
    inline               ~FDispatch() __attribute__((nothrow));
    friend amc::FDispatch&      dispatch_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispatch*      dispatch_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispatch_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FDispatch.msghdr.CopyOut
void                 dispatch_CopyOut(amc::FDispatch &row, dmmeta::Dispatch &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FDispatch.msghdr.CopyIn
void                 dispatch_CopyIn(amc::FDispatch &row, dmmeta::Dispatch &in) __attribute__((nothrow));

// func:amc.FDispatch.ns.Get
algo::Smallstr16     ns_Get(amc::FDispatch& dispatch) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FDispatch.name.Get
algo::Smallstr50     name_Get(amc::FDispatch& dispatch) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FDispatch.c_dispfilter.InsertMaybe
inline bool          c_dispfilter_InsertMaybe(amc::FDispatch& dispatch, amc::FDispfilter& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDispatch.c_dispfilter.Remove
inline void          c_dispfilter_Remove(amc::FDispatch& dispatch, amc::FDispfilter& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FDispatch.c_dispatch_msg.EmptyQ
inline bool          c_dispatch_msg_EmptyQ(amc::FDispatch& dispatch) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FDispatch.c_dispatch_msg.Find
inline amc::FDispatchmsg* c_dispatch_msg_Find(amc::FDispatch& dispatch, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FDispatch.c_dispatch_msg.Getary
inline algo::aryptr<amc::FDispatchmsg*> c_dispatch_msg_Getary(amc::FDispatch& dispatch) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FDispatch.c_dispatch_msg.Insert
void                 c_dispatch_msg_Insert(amc::FDispatch& dispatch, amc::FDispatchmsg& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FDispatch.c_dispatch_msg.InsertMaybe
bool                 c_dispatch_msg_InsertMaybe(amc::FDispatch& dispatch, amc::FDispatchmsg& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FDispatch.c_dispatch_msg.N
inline i32           c_dispatch_msg_N(const amc::FDispatch& dispatch) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FDispatch.c_dispatch_msg.Remove
void                 c_dispatch_msg_Remove(amc::FDispatch& dispatch, amc::FDispatchmsg& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FDispatch.c_dispatch_msg.RemoveAll
inline void          c_dispatch_msg_RemoveAll(amc::FDispatch& dispatch) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FDispatch.c_dispatch_msg.Reserve
void                 c_dispatch_msg_Reserve(amc::FDispatch& dispatch, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FDispatch.c_dispatch_msg.qFind
inline amc::FDispatchmsg& c_dispatch_msg_qFind(amc::FDispatch& dispatch, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FDispatch.c_dispatch_msg.InAryQ
inline bool          dispatch_c_dispatch_msg_InAryQ(amc::FDispatchmsg& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FDispatch.c_dispatch_msg.qLast
inline amc::FDispatchmsg& c_dispatch_msg_qLast(amc::FDispatch& dispatch) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FDispatch.c_disptrace.InsertMaybe
inline bool          c_disptrace_InsertMaybe(amc::FDispatch& dispatch, amc::FDisptrace& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDispatch.c_disptrace.Remove
inline void          c_disptrace_Remove(amc::FDispatch& dispatch, amc::FDisptrace& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FDispatch.c_dispctx.InsertMaybe
inline bool          c_dispctx_InsertMaybe(amc::FDispatch& dispatch, amc::FDispctx& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FDispatch.c_dispctx.Remove
inline void          c_dispctx_Remove(amc::FDispatch& dispatch, amc::FDispctx& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FDispatch..Init
void                 FDispatch_Init(amc::FDispatch& dispatch);
// func:amc.FDispatch.c_dispatch_msg_curs.Reset
inline void          dispatch_c_dispatch_msg_curs_Reset(dispatch_c_dispatch_msg_curs &curs, amc::FDispatch &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FDispatch.c_dispatch_msg_curs.ValidQ
inline bool          dispatch_c_dispatch_msg_curs_ValidQ(dispatch_c_dispatch_msg_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FDispatch.c_dispatch_msg_curs.Next
inline void          dispatch_c_dispatch_msg_curs_Next(dispatch_c_dispatch_msg_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FDispatch.c_dispatch_msg_curs.Access
inline amc::FDispatchmsg& dispatch_c_dispatch_msg_curs_Access(dispatch_c_dispatch_msg_curs &curs) __attribute__((nothrow));
// func:amc.FDispatch..Uninit
void                 FDispatch_Uninit(amc::FDispatch& dispatch) __attribute__((nothrow));

// --- amc.FDispatchmsg
// create: amc.FDb.dispatch_msg (Lary)
// global access: dispatch_msg (Lary, by rowid)
// access: amc.FDispatch.c_dispatch_msg (Ptrary)
struct FDispatchmsg { // amc.FDispatchmsg
    algo::Smallstr100   dispatch_msg;                     //
    amc::FCtype*        p_ctype;                          // reference to parent row
    amc::FDispatch*     p_dispatch;                       // reference to parent row
    algo::cstring       selector;                         //
    bool                dispatch_c_dispatch_msg_in_ary;   //   false  membership flag
    // x-reference on amc.FDispatchmsg.p_ctype prevents copy
    // x-reference on amc.FDispatchmsg.p_dispatch prevents copy
    // func:amc.FDispatchmsg..AssignOp
    inline amc::FDispatchmsg& operator =(const amc::FDispatchmsg &rhs) = delete;
    // x-reference on amc.FDispatchmsg.p_ctype prevents copy
    // x-reference on amc.FDispatchmsg.p_dispatch prevents copy
    // func:amc.FDispatchmsg..CopyCtor
    inline               FDispatchmsg(const amc::FDispatchmsg &rhs) = delete;
private:
    // func:amc.FDispatchmsg..Ctor
    inline               FDispatchmsg() __attribute__((nothrow));
    // func:amc.FDispatchmsg..Dtor
    inline               ~FDispatchmsg() __attribute__((nothrow));
    friend amc::FDispatchmsg&   dispatch_msg_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispatchmsg*   dispatch_msg_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispatch_msg_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FDispatchmsg.msghdr.CopyOut
void                 dispatch_msg_CopyOut(amc::FDispatchmsg &row, dmmeta::DispatchMsg &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FDispatchmsg.msghdr.CopyIn
void                 dispatch_msg_CopyIn(amc::FDispatchmsg &row, dmmeta::DispatchMsg &in) __attribute__((nothrow));

// func:amc.FDispatchmsg.dispatch.Get
algo::Smallstr50     dispatch_Get(amc::FDispatchmsg& dispatch_msg) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FDispatchmsg.ctype.Get
algo::Smallstr100    ctype_Get(amc::FDispatchmsg& dispatch_msg) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FDispatchmsg..Init
inline void          FDispatchmsg_Init(amc::FDispatchmsg& dispatch_msg);
// func:amc.FDispatchmsg..Uninit
void                 FDispatchmsg_Uninit(amc::FDispatchmsg& dispatch_msg) __attribute__((nothrow));

// --- amc.FDispctx
// create: amc.FDb.dispctx (Lary)
// global access: dispctx (Lary, by rowid)
// access: amc.FDispatch.c_dispctx (Ptr)
struct FDispctx { // amc.FDispctx
    algo::Smallstr50    dispatch;   //
    algo::Smallstr100   ctype;      //
    amc::FCtype*        p_ctype;    // reference to parent row
    // x-reference on amc.FDispctx.p_ctype prevents copy
    // func:amc.FDispctx..AssignOp
    inline amc::FDispctx& operator =(const amc::FDispctx &rhs) = delete;
    // x-reference on amc.FDispctx.p_ctype prevents copy
    // func:amc.FDispctx..CopyCtor
    inline               FDispctx(const amc::FDispctx &rhs) = delete;
private:
    // func:amc.FDispctx..Ctor
    inline               FDispctx() __attribute__((nothrow));
    // func:amc.FDispctx..Dtor
    inline               ~FDispctx() __attribute__((nothrow));
    friend amc::FDispctx&       dispctx_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispctx*       dispctx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispctx_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FDispctx.msghdr.CopyOut
void                 dispctx_CopyOut(amc::FDispctx &row, dmmeta::Dispctx &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FDispctx.msghdr.CopyIn
void                 dispctx_CopyIn(amc::FDispctx &row, dmmeta::Dispctx &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FDispctx..Init
inline void          FDispctx_Init(amc::FDispctx& dispctx);
// func:amc.FDispctx..Uninit
void                 FDispctx_Uninit(amc::FDispctx& dispctx) __attribute__((nothrow));

// --- amc.FDispfilter
// create: amc.FDb.dispfilter (Lary)
// global access: dispfilter (Lary, by rowid)
// access: amc.FDispatch.c_dispfilter (Ptr)
struct FDispfilter { // amc.FDispfilter
    algo::Smallstr50   dispatch;    //
    bool               match_all;   //   false
    // func:amc.FDispfilter..AssignOp
    inline amc::FDispfilter& operator =(const amc::FDispfilter &rhs) = delete;
    // func:amc.FDispfilter..CopyCtor
    inline               FDispfilter(const amc::FDispfilter &rhs) = delete;
private:
    // func:amc.FDispfilter..Ctor
    inline               FDispfilter() __attribute__((nothrow));
    // func:amc.FDispfilter..Dtor
    inline               ~FDispfilter() __attribute__((nothrow));
    friend amc::FDispfilter&    dispfilter_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispfilter*    dispfilter_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispfilter_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FDispfilter.msghdr.CopyOut
void                 dispfilter_CopyOut(amc::FDispfilter &row, dmmeta::Dispfilter &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FDispfilter.msghdr.CopyIn
void                 dispfilter_CopyIn(amc::FDispfilter &row, dmmeta::Dispfilter &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FDispfilter..Init
inline void          FDispfilter_Init(amc::FDispfilter& dispfilter);
// func:amc.FDispfilter..Uninit
void                 FDispfilter_Uninit(amc::FDispfilter& dispfilter) __attribute__((nothrow));

// --- amc.FDispsig
// create: amc.FDb.dispsig (Lary)
// global access: dispsig (Lary, by rowid)
// global access: c_dispsig_sorted (Ptrary)
// access: amc.FNs.c_dispsig (Ptrary)
struct FDispsig { // amc.FDispsig
    algo::Smallstr50   dispsig;                       //
    algo::Sha1sig      signature;                     //
    bool               _db_c_dispsig_sorted_in_ary;   //   false  membership flag
    bool               ns_c_dispsig_in_ary;           //   false  membership flag
    // func:amc.FDispsig..AssignOp
    inline amc::FDispsig& operator =(const amc::FDispsig &rhs) = delete;
    // func:amc.FDispsig..CopyCtor
    inline               FDispsig(const amc::FDispsig &rhs) = delete;
private:
    // func:amc.FDispsig..Ctor
    inline               FDispsig() __attribute__((nothrow));
    // func:amc.FDispsig..Dtor
    inline               ~FDispsig() __attribute__((nothrow));
    friend amc::FDispsig&       dispsig_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDispsig*       dispsig_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 dispsig_RemoveAll() __attribute__((nothrow));
    friend void                 dispsig_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FDispsig.msghdr.CopyOut
void                 dispsig_CopyOut(amc::FDispsig &row, dmmeta::Dispsig &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FDispsig.msghdr.CopyIn
void                 dispsig_CopyIn(amc::FDispsig &row, dmmeta::Dispsig &in) __attribute__((nothrow));

// func:amc.FDispsig.ns.Get
algo::Smallstr16     ns_Get(amc::FDispsig& dispsig) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FDispsig.name.Get
algo::Smallstr50     name_Get(amc::FDispsig& dispsig) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FDispsig..Init
inline void          FDispsig_Init(amc::FDispsig& dispsig);
// func:amc.FDispsig..Uninit
void                 FDispsig_Uninit(amc::FDispsig& dispsig) __attribute__((nothrow));

// --- amc.FDisptrace
// create: amc.FDb.disptrace (Lary)
// global access: disptrace (Lary, by rowid)
// access: amc.FDispatch.c_disptrace (Ptr)
struct FDisptrace { // amc.FDisptrace
    algo::Smallstr50   dispatch;     //
    bool               cycle;        //   false
    algo::Comment      comment;      //
    amc::FDispatch*    p_dispatch;   // reference to parent row
    // x-reference on amc.FDisptrace.p_dispatch prevents copy
    // func:amc.FDisptrace..AssignOp
    inline amc::FDisptrace& operator =(const amc::FDisptrace &rhs) = delete;
    // x-reference on amc.FDisptrace.p_dispatch prevents copy
    // func:amc.FDisptrace..CopyCtor
    inline               FDisptrace(const amc::FDisptrace &rhs) = delete;
private:
    // func:amc.FDisptrace..Ctor
    inline               FDisptrace() __attribute__((nothrow));
    // func:amc.FDisptrace..Dtor
    inline               ~FDisptrace() __attribute__((nothrow));
    friend amc::FDisptrace&     disptrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FDisptrace*     disptrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 disptrace_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FDisptrace.msghdr.CopyOut
void                 disptrace_CopyOut(amc::FDisptrace &row, dmmeta::Disptrace &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FDisptrace.msghdr.CopyIn
void                 disptrace_CopyIn(amc::FDisptrace &row, dmmeta::Disptrace &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FDisptrace..Init
inline void          FDisptrace_Init(amc::FDisptrace& disptrace);
// func:amc.FDisptrace..Uninit
void                 FDisptrace_Uninit(amc::FDisptrace& disptrace) __attribute__((nothrow));

// --- amc.FEnumstr
// create: amc.FDb.enumstr (Lary)
// global access: enumstr (Lary, by rowid)
// global access: ind_enumstr (Thash, hash field enumstr)
// access: amc.FEnumstrLen.bh_enumstr (Bheap)
struct FEnumstr { // amc.FEnumstr: All values of a given length
    amc::FEnumstr*   ind_enumstr_next;   // hash next
    amc::Enumstr     enumstr;            //
    amc::FFconst**   c_fconst_elems;     // array of pointers
    u32              c_fconst_n;         // array of pointers
    u32              c_fconst_max;       // capacity of allocated array
    i32              bh_enumstr_idx;     // index in heap; -1 means not-in-heap
    // reftype Ptrary of amc.FEnumstr.c_fconst prohibits copy
    // func:amc.FEnumstr..AssignOp
    inline amc::FEnumstr& operator =(const amc::FEnumstr &rhs) = delete;
    // reftype Ptrary of amc.FEnumstr.c_fconst prohibits copy
    // func:amc.FEnumstr..CopyCtor
    inline               FEnumstr(const amc::FEnumstr &rhs) = delete;
private:
    // func:amc.FEnumstr..Ctor
    inline               FEnumstr() __attribute__((nothrow));
    // func:amc.FEnumstr..Dtor
    inline               ~FEnumstr() __attribute__((nothrow));
    friend amc::FEnumstr&       enumstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FEnumstr*       enumstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 enumstr_RemoveAll() __attribute__((nothrow));
    friend void                 enumstr_RemoveLast() __attribute__((nothrow));
};

// Return true if index is empty
// func:amc.FEnumstr.c_fconst.EmptyQ
inline bool          c_fconst_EmptyQ(amc::FEnumstr& enumstr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FEnumstr.c_fconst.Find
inline amc::FFconst* c_fconst_Find(amc::FEnumstr& enumstr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FEnumstr.c_fconst.Getary
inline algo::aryptr<amc::FFconst*> c_fconst_Getary(amc::FEnumstr& enumstr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FEnumstr.c_fconst.Insert
void                 c_fconst_Insert(amc::FEnumstr& enumstr, amc::FFconst& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FEnumstr.c_fconst.ScanInsertMaybe
bool                 c_fconst_ScanInsertMaybe(amc::FEnumstr& enumstr, amc::FFconst& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FEnumstr.c_fconst.N
inline i32           c_fconst_N(const amc::FEnumstr& enumstr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FEnumstr.c_fconst.Remove
void                 c_fconst_Remove(amc::FEnumstr& enumstr, amc::FFconst& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FEnumstr.c_fconst.RemoveAll
inline void          c_fconst_RemoveAll(amc::FEnumstr& enumstr) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FEnumstr.c_fconst.Reserve
void                 c_fconst_Reserve(amc::FEnumstr& enumstr, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FEnumstr.c_fconst.qFind
inline amc::FFconst& c_fconst_qFind(amc::FEnumstr& enumstr, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FEnumstr.c_fconst.qLast
inline amc::FFconst& c_fconst_qLast(amc::FEnumstr& enumstr) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FEnumstr..Init
inline void          FEnumstr_Init(amc::FEnumstr& enumstr);
// func:amc.FEnumstr.c_fconst_curs.Reset
inline void          enumstr_c_fconst_curs_Reset(enumstr_c_fconst_curs &curs, amc::FEnumstr &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FEnumstr.c_fconst_curs.ValidQ
inline bool          enumstr_c_fconst_curs_ValidQ(enumstr_c_fconst_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FEnumstr.c_fconst_curs.Next
inline void          enumstr_c_fconst_curs_Next(enumstr_c_fconst_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FEnumstr.c_fconst_curs.Access
inline amc::FFconst& enumstr_c_fconst_curs_Access(enumstr_c_fconst_curs &curs) __attribute__((nothrow));
// func:amc.FEnumstr..Uninit
void                 FEnumstr_Uninit(amc::FEnumstr& enumstr) __attribute__((nothrow));

// --- amc.FEnumstrLen
// create: amc.FDb.enumstr_len (Lary)
// global access: enumstr_len (Lary, by rowid)
// global access: bh_enumstr_len (Bheap, sort field len)
// global access: ind_enumstr_len (Thash, hash field len)
struct FEnumstrLen { // amc.FEnumstrLen
    i32                 bh_enumstr_len_idx;     // index in heap; -1 means not-in-heap
    amc::FEnumstrLen*   ind_enumstr_len_next;   // hash next
    i32                 len;                    //   0
    amc::FEnumstr**     bh_enumstr_elems;       // binary heap by str
    i32                 bh_enumstr_n;           // number of elements in the heap
    i32                 bh_enumstr_max;         // max elements in bh_enumstr_elems
    // reftype Bheap of amc.FEnumstrLen.bh_enumstr prohibits copy
    // func:amc.FEnumstrLen..AssignOp
    inline amc::FEnumstrLen& operator =(const amc::FEnumstrLen &rhs) = delete;
    // reftype Bheap of amc.FEnumstrLen.bh_enumstr prohibits copy
    // func:amc.FEnumstrLen..CopyCtor
    inline               FEnumstrLen(const amc::FEnumstrLen &rhs) = delete;
private:
    // func:amc.FEnumstrLen..Ctor
    inline               FEnumstrLen() __attribute__((nothrow));
    // func:amc.FEnumstrLen..Dtor
    inline               ~FEnumstrLen() __attribute__((nothrow));
    friend amc::FEnumstrLen&    enumstr_len_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FEnumstrLen*    enumstr_len_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 enumstr_len_RemoveAll() __attribute__((nothrow));
    friend void                 enumstr_len_RemoveLast() __attribute__((nothrow));
};

// Remove all elements from heap and free memory used by the array.
// func:amc.FEnumstrLen.bh_enumstr.Dealloc
void                 bh_enumstr_Dealloc(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// Return true if index is empty
// func:amc.FEnumstrLen.bh_enumstr.EmptyQ
inline bool          bh_enumstr_EmptyQ(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FEnumstrLen.bh_enumstr.First
inline amc::FEnumstr* bh_enumstr_First(amc::FEnumstrLen& enumstr_len) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:amc.FEnumstrLen.bh_enumstr.InBheapQ
inline bool          bh_enumstr_InBheapQ(amc::FEnumstr& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:amc.FEnumstrLen.bh_enumstr.Insert
void                 bh_enumstr_Insert(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) __attribute__((nothrow));
// Return number of items in the heap
// func:amc.FEnumstrLen.bh_enumstr.N
inline i32           bh_enumstr_N(const amc::FEnumstrLen& enumstr_len) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:amc.FEnumstrLen.bh_enumstr.Reheap
i32                  bh_enumstr_Reheap(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:amc.FEnumstrLen.bh_enumstr.ReheapFirst
i32                  bh_enumstr_ReheapFirst(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FEnumstrLen.bh_enumstr.Remove
void                 bh_enumstr_Remove(amc::FEnumstrLen& enumstr_len, amc::FEnumstr& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:amc.FEnumstrLen.bh_enumstr.RemoveAll
void                 bh_enumstr_RemoveAll(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:amc.FEnumstrLen.bh_enumstr.RemoveFirst
amc::FEnumstr*       bh_enumstr_RemoveFirst(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));
// Reserve space in index for N more elements
// func:amc.FEnumstrLen.bh_enumstr.Reserve
void                 bh_enumstr_Reserve(amc::FEnumstrLen& enumstr_len, int n) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FEnumstrLen..Init
inline void          FEnumstrLen_Init(amc::FEnumstrLen& enumstr_len);
// func:amc.FEnumstrLen.bh_enumstr_curs.Reserve
void                 enumstr_len_bh_enumstr_curs_Reserve(enumstr_len_bh_enumstr_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:amc.FEnumstrLen.bh_enumstr_curs.Reset
void                 enumstr_len_bh_enumstr_curs_Reset(enumstr_len_bh_enumstr_curs &curs, amc::FEnumstrLen &parent);
// Advance cursor.
// func:amc.FEnumstrLen.bh_enumstr_curs.Next
void                 enumstr_len_bh_enumstr_curs_Next(enumstr_len_bh_enumstr_curs &curs);
// Access current element. If not more elements, return NULL
// func:amc.FEnumstrLen.bh_enumstr_curs.Access
inline amc::FEnumstr& enumstr_len_bh_enumstr_curs_Access(enumstr_len_bh_enumstr_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:amc.FEnumstrLen.bh_enumstr_curs.ValidQ
inline bool          enumstr_len_bh_enumstr_curs_ValidQ(enumstr_len_bh_enumstr_curs &curs) __attribute__((nothrow));
// func:amc.FEnumstrLen..Uninit
void                 FEnumstrLen_Uninit(amc::FEnumstrLen& enumstr_len) __attribute__((nothrow));

// --- amc.FFalias
// create: amc.FDb.falias (Lary)
// global access: falias (Lary, by rowid)
// access: amc.FField.c_falias (Ptr)
struct FFalias { // amc.FFalias
    algo::Smallstr100   field;        //
    algo::Smallstr100   srcfield;     //
    algo::Comment       comment;      //
    amc::FField*        p_srcfield;   // reference to parent row
    // x-reference on amc.FFalias.p_srcfield prevents copy
    // func:amc.FFalias..AssignOp
    inline amc::FFalias& operator =(const amc::FFalias &rhs) = delete;
    // x-reference on amc.FFalias.p_srcfield prevents copy
    // func:amc.FFalias..CopyCtor
    inline               FFalias(const amc::FFalias &rhs) = delete;
private:
    // func:amc.FFalias..Ctor
    inline               FFalias() __attribute__((nothrow));
    // func:amc.FFalias..Dtor
    inline               ~FFalias() __attribute__((nothrow));
    friend amc::FFalias&        falias_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFalias*        falias_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 falias_RemoveAll() __attribute__((nothrow));
    friend void                 falias_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFalias.base.CopyOut
void                 falias_CopyOut(amc::FFalias &row, dmmeta::Falias &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFalias.base.CopyIn
void                 falias_CopyIn(amc::FFalias &row, dmmeta::Falias &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFalias..Init
inline void          FFalias_Init(amc::FFalias& falias);
// func:amc.FFalias..Uninit
void                 FFalias_Uninit(amc::FFalias& falias) __attribute__((nothrow));

// --- amc.FFbase
// create: amc.FDb.fbase (Lary)
// global access: fbase (Lary, by rowid)
// access: amc.FField.c_fbase (Ptr)
struct FFbase { // amc.FFbase
    algo::Smallstr100   field;          //
    bool                stripcomment;   //   false
    algo::Comment       comment;        //
    // func:amc.FFbase..AssignOp
    inline amc::FFbase&  operator =(const amc::FFbase &rhs) = delete;
    // func:amc.FFbase..CopyCtor
    inline               FFbase(const amc::FFbase &rhs) = delete;
private:
    // func:amc.FFbase..Ctor
    inline               FFbase() __attribute__((nothrow));
    // func:amc.FFbase..Dtor
    inline               ~FFbase() __attribute__((nothrow));
    friend amc::FFbase&         fbase_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbase*         fbase_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbase_RemoveAll() __attribute__((nothrow));
    friend void                 fbase_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFbase.base.CopyOut
void                 fbase_CopyOut(amc::FFbase &row, dmmeta::Fbase &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFbase.base.CopyIn
void                 fbase_CopyIn(amc::FFbase &row, dmmeta::Fbase &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFbase..Init
inline void          FFbase_Init(amc::FFbase& fbase);
// func:amc.FFbase..Uninit
void                 FFbase_Uninit(amc::FFbase& fbase) __attribute__((nothrow));

// --- amc.FFbigend
// create: amc.FDb.fbigend (Lary)
// global access: fbigend (Lary, by rowid)
// access: amc.FField.c_fbigend (Ptr)
struct FFbigend { // amc.FFbigend
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FFbigend.p_field prevents copy
    // func:amc.FFbigend..AssignOp
    inline amc::FFbigend& operator =(const amc::FFbigend &rhs) = delete;
    // x-reference on amc.FFbigend.p_field prevents copy
    // func:amc.FFbigend..CopyCtor
    inline               FFbigend(const amc::FFbigend &rhs) = delete;
private:
    // func:amc.FFbigend..Ctor
    inline               FFbigend() __attribute__((nothrow));
    // func:amc.FFbigend..Dtor
    inline               ~FFbigend() __attribute__((nothrow));
    friend amc::FFbigend&       fbigend_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbigend*       fbigend_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbigend_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFbigend.msghdr.CopyOut
void                 fbigend_CopyOut(amc::FFbigend &row, dmmeta::Fbigend &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFbigend.msghdr.CopyIn
void                 fbigend_CopyIn(amc::FFbigend &row, dmmeta::Fbigend &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFbigend..Init
inline void          FFbigend_Init(amc::FFbigend& fbigend);
// func:amc.FFbigend..Uninit
void                 FFbigend_Uninit(amc::FFbigend& fbigend) __attribute__((nothrow));

// --- amc.FFbitset
// create: amc.FDb.fbitset (Lary)
// global access: fbitset (Lary, by rowid)
// global access: ind_fbitset (Thash, hash field field)
// access: amc.FField.c_fbitset (Ptr)
struct FFbitset { // amc.FFbitset
    amc::FFbitset*      ind_fbitset_next;   // hash next
    algo::Smallstr100   field;              //
    amc::FField*        p_field;            // reference to parent row
    // x-reference on amc.FFbitset.p_field prevents copy
    // func:amc.FFbitset..AssignOp
    inline amc::FFbitset& operator =(const amc::FFbitset &rhs) = delete;
    // x-reference on amc.FFbitset.p_field prevents copy
    // func:amc.FFbitset..CopyCtor
    inline               FFbitset(const amc::FFbitset &rhs) = delete;
private:
    // func:amc.FFbitset..Ctor
    inline               FFbitset() __attribute__((nothrow));
    // func:amc.FFbitset..Dtor
    inline               ~FFbitset() __attribute__((nothrow));
    friend amc::FFbitset&       fbitset_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbitset*       fbitset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbitset_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFbitset.msghdr.CopyOut
void                 fbitset_CopyOut(amc::FFbitset &row, dmmeta::Fbitset &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFbitset.msghdr.CopyIn
void                 fbitset_CopyIn(amc::FFbitset &row, dmmeta::Fbitset &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFbitset..Init
inline void          FFbitset_Init(amc::FFbitset& fbitset);
// func:amc.FFbitset..Uninit
void                 FFbitset_Uninit(amc::FFbitset& fbitset) __attribute__((nothrow));

// --- amc.FFbuf
// create: amc.FDb.fbuf (Lary)
// global access: fbuf (Lary, by rowid)
// global access: ind_fbuf (Thash, hash field field)
// access: amc.FField.c_fbuf (Ptr)
struct FFbuf { // amc.FFbuf
    amc::FFbuf*         ind_fbuf_next;   // hash next
    algo::Smallstr100   field;           //
    u32                 max;             //   0  Size of buffer in bytes
    algo::Smallstr50    fbuftype;        // Type of buffer
    algo::Smallstr100   insready;        //
    algo::Smallstr100   inseof;          //
    amc::FField*        p_insready;      // reference to parent row
    amc::FField*        p_inseof;        // reference to parent row
    // x-reference on amc.FFbuf.p_insready prevents copy
    // x-reference on amc.FFbuf.p_inseof prevents copy
    // func:amc.FFbuf..AssignOp
    inline amc::FFbuf&   operator =(const amc::FFbuf &rhs) = delete;
    // x-reference on amc.FFbuf.p_insready prevents copy
    // x-reference on amc.FFbuf.p_inseof prevents copy
    // func:amc.FFbuf..CopyCtor
    inline               FFbuf(const amc::FFbuf &rhs) = delete;
private:
    // func:amc.FFbuf..Ctor
    inline               FFbuf() __attribute__((nothrow));
    // func:amc.FFbuf..Dtor
    inline               ~FFbuf() __attribute__((nothrow));
    friend amc::FFbuf&          fbuf_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFbuf*          fbuf_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fbuf_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFbuf.msghdr.CopyOut
void                 fbuf_CopyOut(amc::FFbuf &row, dmmeta::Fbuf &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFbuf.msghdr.CopyIn
void                 fbuf_CopyIn(amc::FFbuf &row, dmmeta::Fbuf &in) __attribute__((nothrow));

// func:amc.FFbuf.fbufdir.Get
algo::Smallstr50     fbufdir_Get(amc::FFbuf& fbuf) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFbuf..Init
inline void          FFbuf_Init(amc::FFbuf& fbuf);
// func:amc.FFbuf..Uninit
void                 FFbuf_Uninit(amc::FFbuf& fbuf) __attribute__((nothrow));

// --- amc.FFcast
// create: amc.FDb.fcast (Lary)
// global access: fcast (Lary, by rowid)
// access: amc.FField.c_fcast (Ptr)
struct FFcast { // amc.FFcast
    algo::Smallstr100   field;   //
    algo::Smallstr100   expr;    //
    // func:amc.FFcast..AssignOp
    inline amc::FFcast&  operator =(const amc::FFcast &rhs) = delete;
    // func:amc.FFcast..CopyCtor
    inline               FFcast(const amc::FFcast &rhs) = delete;
private:
    // func:amc.FFcast..Ctor
    inline               FFcast() __attribute__((nothrow));
    // func:amc.FFcast..Dtor
    inline               ~FFcast() __attribute__((nothrow));
    friend amc::FFcast&         fcast_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcast*         fcast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcast_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcast.msghdr.CopyOut
void                 fcast_CopyOut(amc::FFcast &row, dmmeta::Fcast &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcast.msghdr.CopyIn
void                 fcast_CopyIn(amc::FFcast &row, dmmeta::Fcast &in) __attribute__((nothrow));

// func:amc.FFcast..Uninit
void                 FFcast_Uninit(amc::FFcast& fcast) __attribute__((nothrow));

// --- amc.FFcleanup
// create: amc.FDb.fcleanup (Lary)
// global access: fcleanup (Lary, by rowid)
// access: amc.FField.c_fcleanup (Ptr)
struct FFcleanup { // amc.FFcleanup
    algo::Smallstr100   field;     //
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FFcleanup.p_field prevents copy
    // func:amc.FFcleanup..AssignOp
    inline amc::FFcleanup& operator =(const amc::FFcleanup &rhs) = delete;
    // x-reference on amc.FFcleanup.p_field prevents copy
    // func:amc.FFcleanup..CopyCtor
    inline               FFcleanup(const amc::FFcleanup &rhs) = delete;
private:
    // func:amc.FFcleanup..Ctor
    inline               FFcleanup() __attribute__((nothrow));
    // func:amc.FFcleanup..Dtor
    inline               ~FFcleanup() __attribute__((nothrow));
    friend amc::FFcleanup&      fcleanup_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcleanup*      fcleanup_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcleanup_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcleanup.msghdr.CopyOut
void                 fcleanup_CopyOut(amc::FFcleanup &row, dmmeta::Fcleanup &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcleanup.msghdr.CopyIn
void                 fcleanup_CopyIn(amc::FFcleanup &row, dmmeta::Fcleanup &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFcleanup..Init
inline void          FFcleanup_Init(amc::FFcleanup& fcleanup);
// func:amc.FFcleanup..Uninit
void                 FFcleanup_Uninit(amc::FFcleanup& fcleanup) __attribute__((nothrow));

// --- amc.FFcmap
// create: amc.FDb.fcmap (Lary)
// global access: fcmap (Lary, by rowid)
// global access: ind_fcmap (Thash, hash field fcmap)
// access: amc.FField.zs_fcmap (Llist)
struct FFcmap { // amc.FFcmap
    amc::FFcmap*        ind_fcmap_next;   // hash next
    algo::Smallstr250   fcmap;            // cstring maybe?
    bool                bidir;            //   true
    algo::Comment       comment;          //
    amc::FField*        p_leftField;      // reference to parent row
    amc::FField*        p_rightField;     // reference to parent row
    amc::FFunc*         c_convfunc;       // Generated conversion func. optional pointer
    amc::FFcmap*        zs_fcmap_next;    // zslist link; -1 means not-in-list
    // x-reference on amc.FFcmap.p_leftField prevents copy
    // x-reference on amc.FFcmap.p_rightField prevents copy
    // func:amc.FFcmap..AssignOp
    amc::FFcmap&         operator =(const amc::FFcmap &rhs) = delete;
    // x-reference on amc.FFcmap.p_leftField prevents copy
    // x-reference on amc.FFcmap.p_rightField prevents copy
    // func:amc.FFcmap..CopyCtor
    FFcmap(const amc::FFcmap &rhs) = delete;
private:
    // func:amc.FFcmap..Ctor
    inline               FFcmap() __attribute__((nothrow));
    // func:amc.FFcmap..Dtor
    inline               ~FFcmap() __attribute__((nothrow));
    friend amc::FFcmap&         fcmap_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcmap*         fcmap_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcmap_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcmap.base.CopyOut
void                 fcmap_CopyOut(amc::FFcmap &row, dmmeta::Fcmap &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcmap.base.CopyIn
void                 fcmap_CopyIn(amc::FFcmap &row, dmmeta::Fcmap &in) __attribute__((nothrow));

// func:amc.FFcmap.leftField.Get
algo::Smallstr100    leftField_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFcmap.leftVal.Get
algo::Smallstr40     leftVal_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFcmap.rightVal.Get
algo::Smallstr40     rightVal_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFcmap.rightField.Get
algo::Smallstr100    rightField_Get(amc::FFcmap& fcmap) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFcmap..Init
void                 FFcmap_Init(amc::FFcmap& fcmap);
// func:amc.FFcmap..Uninit
void                 FFcmap_Uninit(amc::FFcmap& fcmap) __attribute__((nothrow));

// --- amc.FFcmdline
// create: amc.FDb.fcmdline (Lary)
// global access: fcmdline (Lary, by rowid)
// access: amc.FNs.c_fcmdline (Ptr)
struct FFcmdline { // amc.FFcmdline
    algo::Smallstr100   field;           // Parent field
    bool                read;            //   true  Read the command line automatically from main?
    algo::Smallstr100   basecmdline;     // Optional command line to merge with this one
    algo::Comment       comment;         //
    amc::FField*        p_field;         // reference to parent row
    amc::FNs*           p_ns;            // reference to parent row
    amc::FField*        p_basecmdline;   // reference to parent row
    // x-reference on amc.FFcmdline.p_field prevents copy
    // x-reference on amc.FFcmdline.p_ns prevents copy
    // x-reference on amc.FFcmdline.p_basecmdline prevents copy
    // func:amc.FFcmdline..AssignOp
    inline amc::FFcmdline& operator =(const amc::FFcmdline &rhs) = delete;
    // x-reference on amc.FFcmdline.p_field prevents copy
    // x-reference on amc.FFcmdline.p_ns prevents copy
    // x-reference on amc.FFcmdline.p_basecmdline prevents copy
    // func:amc.FFcmdline..CopyCtor
    inline               FFcmdline(const amc::FFcmdline &rhs) = delete;
private:
    // func:amc.FFcmdline..Ctor
    inline               FFcmdline() __attribute__((nothrow));
    // func:amc.FFcmdline..Dtor
    inline               ~FFcmdline() __attribute__((nothrow));
    friend amc::FFcmdline&      fcmdline_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcmdline*      fcmdline_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcmdline_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcmdline.base.CopyOut
void                 fcmdline_CopyOut(amc::FFcmdline &row, dmmeta::Fcmdline &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcmdline.base.CopyIn
void                 fcmdline_CopyIn(amc::FFcmdline &row, dmmeta::Fcmdline &in) __attribute__((nothrow));

// func:amc.FFcmdline.ns.Get
algo::Smallstr16     ns_Get(amc::FFcmdline& fcmdline) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFcmdline..Init
inline void          FFcmdline_Init(amc::FFcmdline& fcmdline);
// func:amc.FFcmdline..Uninit
void                 FFcmdline_Uninit(amc::FFcmdline& fcmdline) __attribute__((nothrow));

// --- amc.FFcmp
// create: amc.FDb.fcmp (Lary)
// global access: fcmp (Lary, by rowid)
// access: amc.FField.c_fcmp (Ptr)
struct FFcmp { // amc.FFcmp
    algo::Smallstr100   field;         // Target field
    bool                versionsort;   //   false  Use version sort (detect embedded integers in string)
    bool                casesens;      //   true  Comparison is case-sensitive
    bool                extrn;         //   false  Whether implementation is external
    algo::Comment       comment;       //
    // func:amc.FFcmp..AssignOp
    inline amc::FFcmp&   operator =(const amc::FFcmp &rhs) = delete;
    // func:amc.FFcmp..CopyCtor
    inline               FFcmp(const amc::FFcmp &rhs) = delete;
private:
    // func:amc.FFcmp..Ctor
    inline               FFcmp() __attribute__((nothrow));
    // func:amc.FFcmp..Dtor
    inline               ~FFcmp() __attribute__((nothrow));
    friend amc::FFcmp&          fcmp_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcmp*          fcmp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcmp_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcmp.msghdr.CopyOut
void                 fcmp_CopyOut(amc::FFcmp &row, dmmeta::Fcmp &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcmp.msghdr.CopyIn
void                 fcmp_CopyIn(amc::FFcmp &row, dmmeta::Fcmp &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFcmp..Init
inline void          FFcmp_Init(amc::FFcmp& fcmp);
// func:amc.FFcmp..Uninit
void                 FFcmp_Uninit(amc::FFcmp& fcmp) __attribute__((nothrow));

// --- amc.FFcompact
// create: amc.FDb.fcompact (Lary)
// global access: fcompact (Lary, by rowid)
// access: amc.FField.c_fcompact (Ptr)
struct FFcompact { // amc.FFcompact
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:amc.FFcompact..AssignOp
    inline amc::FFcompact& operator =(const amc::FFcompact &rhs) = delete;
    // func:amc.FFcompact..CopyCtor
    inline               FFcompact(const amc::FFcompact &rhs) = delete;
private:
    // func:amc.FFcompact..Ctor
    inline               FFcompact() __attribute__((nothrow));
    // func:amc.FFcompact..Dtor
    inline               ~FFcompact() __attribute__((nothrow));
    friend amc::FFcompact&      fcompact_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcompact*      fcompact_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcompact_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcompact.base.CopyOut
void                 fcompact_CopyOut(amc::FFcompact &row, dmmeta::Fcompact &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcompact.base.CopyIn
void                 fcompact_CopyIn(amc::FFcompact &row, dmmeta::Fcompact &in) __attribute__((nothrow));

// func:amc.FFcompact..Uninit
void                 FFcompact_Uninit(amc::FFcompact& fcompact) __attribute__((nothrow));

// --- amc.FFconst
// create: amc.FDb.fconst (Lary)
// global access: fconst (Lary, by rowid)
// global access: ind_fconst (Thash, hash field fconst)
// global access: ind_fconst_int (Thash, hash field cpp_value)
// access: amc.FEnumstr.c_fconst (Ptrary)
// access: amc.FField.c_fconst (Ptrary)
// access: amc.FField.c_inkey_fconst (Ptr)
struct FFconst { // amc.FFconst
    amc::FFconst*       ind_fconst_next;         // hash next
    amc::FFconst*       ind_fconst_int_next;     // hash next
    algo::Smallstr100   fconst;                  //
    algo::CppExpr       value;                   //
    algo::Comment       comment;                 //
    amc::FField*        p_field;                 // reference to parent row
    algo::cstring       cpp_value;               //
    i64                 int_val;                 //   0  integer value
    algo::cstring       cpp_name;                // symbol to use in cpp file
    bool                field_c_fconst_in_ary;   //   false  membership flag
    // x-reference on amc.FFconst.p_field prevents copy
    // func:amc.FFconst..AssignOp
    amc::FFconst&        operator =(const amc::FFconst &rhs) = delete;
    // x-reference on amc.FFconst.p_field prevents copy
    // func:amc.FFconst..CopyCtor
    FFconst(const amc::FFconst &rhs) = delete;
private:
    // func:amc.FFconst..Ctor
    inline               FFconst() __attribute__((nothrow));
    // func:amc.FFconst..Dtor
    inline               ~FFconst() __attribute__((nothrow));
    friend amc::FFconst&        fconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFconst*        fconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fconst_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFconst.msghdr.CopyOut
void                 fconst_CopyOut(amc::FFconst &row, dmmeta::Fconst &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFconst.msghdr.CopyIn
void                 fconst_CopyIn(amc::FFconst &row, dmmeta::Fconst &in) __attribute__((nothrow));

// func:amc.FFconst.field.Get
algo::Smallstr100    field_Get(amc::FFconst& fconst) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFconst.name.Get
algo::Smallstr100    name_Get(amc::FFconst& fconst) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFconst..Init
void                 FFconst_Init(amc::FFconst& fconst);
// func:amc.FFconst..Uninit
void                 FFconst_Uninit(amc::FFconst& fconst) __attribute__((nothrow));

// --- amc.FFcurs
// create: amc.FDb.fcurs (Lary)
// global access: fcurs (Lary, by rowid)
// global access: ind_fcurs (Thash, hash field fcurs)
// access: amc.FCtype.c_fcurs (Ptrary)
struct FFcurs { // amc.FFcurs
    amc::FFcurs*       ind_fcurs_next;         // hash next
    algo::Smallstr50   fcurs;                  //
    algo::Comment      comment;                //
    amc::FField*       p_field;                // reference to parent row
    bool               ctype_c_fcurs_in_ary;   //   false  membership flag
    // x-reference on amc.FFcurs.p_field prevents copy
    // func:amc.FFcurs..AssignOp
    inline amc::FFcurs&  operator =(const amc::FFcurs &rhs) = delete;
    // x-reference on amc.FFcurs.p_field prevents copy
    // func:amc.FFcurs..CopyCtor
    inline               FFcurs(const amc::FFcurs &rhs) = delete;
private:
    // func:amc.FFcurs..Ctor
    inline               FFcurs() __attribute__((nothrow));
    // func:amc.FFcurs..Dtor
    inline               ~FFcurs() __attribute__((nothrow));
    friend amc::FFcurs&         fcurs_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFcurs*         fcurs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fcurs_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFcurs.base.CopyOut
void                 fcurs_CopyOut(amc::FFcurs &row, dmmeta::Fcurs &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFcurs.base.CopyIn
void                 fcurs_CopyIn(amc::FFcurs &row, dmmeta::Fcurs &in) __attribute__((nothrow));

// func:amc.FFcurs.field.Get
algo::Smallstr100    field_Get(amc::FFcurs& fcurs) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFcurs.ctype.Get
algo::Smallstr100    ctype_Get(amc::FFcurs& fcurs) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFcurs.curstype.Get
algo::Smallstr50     curstype_Get(amc::FFcurs& fcurs) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFcurs..Init
inline void          FFcurs_Init(amc::FFcurs& fcurs);
// func:amc.FFcurs..Uninit
void                 FFcurs_Uninit(amc::FFcurs& fcurs) __attribute__((nothrow));

// --- amc.FFdec
// create: amc.FDb.fdec (Lary)
// global access: fdec (Lary, by rowid)
// global access: ind_fdec (Thash, hash field field)
// access: amc.FField.c_fdec (Ptr)
struct FFdec { // amc.FFdec
    amc::FFdec*         ind_fdec_next;   // hash next
    algo::Smallstr100   field;           // Target field
    i32                 nplace;          //   0  Number of implied decimal places
    bool                fixedfmt;        //   false  Print exactly SCALE chars after decimal point
    amc::FField*        p_field;         // reference to parent row
    // x-reference on amc.FFdec.p_field prevents copy
    // func:amc.FFdec..AssignOp
    inline amc::FFdec&   operator =(const amc::FFdec &rhs) = delete;
    // x-reference on amc.FFdec.p_field prevents copy
    // func:amc.FFdec..CopyCtor
    inline               FFdec(const amc::FFdec &rhs) = delete;
private:
    // func:amc.FFdec..Ctor
    inline               FFdec() __attribute__((nothrow));
    // func:amc.FFdec..Dtor
    inline               ~FFdec() __attribute__((nothrow));
    friend amc::FFdec&          fdec_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFdec*          fdec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fdec_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFdec.msghdr.CopyOut
void                 fdec_CopyOut(amc::FFdec &row, dmmeta::Fdec &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFdec.msghdr.CopyIn
void                 fdec_CopyIn(amc::FFdec &row, dmmeta::Fdec &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFdec..Init
inline void          FFdec_Init(amc::FFdec& fdec);
// func:amc.FFdec..Uninit
void                 FFdec_Uninit(amc::FFdec& fdec) __attribute__((nothrow));

// --- amc.FFdelay
// create: amc.FDb.fdelay (Lary)
// global access: fdelay (Lary, by rowid)
// access: amc.FFstep.c_fdelay (Ptr)
struct FFdelay { // amc.FFdelay
    algo::Smallstr100   fstep;   //
    algo::I64Dec9       delay;   // Delay between steps in seconds
    bool                scale;   //   false  Does delay apply to the whole list?
    // func:amc.FFdelay..AssignOp
    inline amc::FFdelay& operator =(const amc::FFdelay &rhs) = delete;
    // func:amc.FFdelay..CopyCtor
    inline               FFdelay(const amc::FFdelay &rhs) = delete;
private:
    // func:amc.FFdelay..Ctor
    inline               FFdelay() __attribute__((nothrow));
    // func:amc.FFdelay..Dtor
    inline               ~FFdelay() __attribute__((nothrow));
    friend amc::FFdelay&        fdelay_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFdelay*        fdelay_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fdelay_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFdelay.msghdr.CopyOut
void                 fdelay_CopyOut(amc::FFdelay &row, dmmeta::Fdelay &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFdelay.msghdr.CopyIn
void                 fdelay_CopyIn(amc::FFdelay &row, dmmeta::Fdelay &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFdelay..Init
inline void          FFdelay_Init(amc::FFdelay& fdelay);
// func:amc.FFdelay..Uninit
void                 FFdelay_Uninit(amc::FFdelay& fdelay) __attribute__((nothrow));

// --- amc.FFfast
// create: amc.FDb.ffast (Lary)
// global access: ffast (Lary, by rowid)
// access: amc.FCtype.c_ffast (Ptrary)
// access: amc.FField.c_ffast_field (Ptr)
// access: amc.FField.c_ffast_length (Ptr)
// access: amc.FField.c_ffast_mantissa (Ptr)
// access: amc.FField.c_ffast (Ptrary)
struct FFfast { // amc.FFfast
    algo::Smallstr100   ffast;                  //
    algo::Smallstr50    name;                   //
    u32                 id;                     //   0
    u32                 pos;                    //   0
    bool                optional;               //   false
    algo::Smallstr50    encoding;               //
    algo::Smallstr50    op;                     //
    algo::CppExpr       value;                  //
    algo::Comment       comment;                //
    amc::FField*        p_field;                // reference to parent row
    bool                ctype_c_ffast_in_ary;   //   false  membership flag
    bool                field_c_ffast_in_ary;   //   false  membership flag
    // x-reference on amc.FFfast.p_field prevents copy
    // func:amc.FFfast..AssignOp
    amc::FFfast&         operator =(const amc::FFfast &rhs) = delete;
    // x-reference on amc.FFfast.p_field prevents copy
    // func:amc.FFfast..CopyCtor
    FFfast(const amc::FFfast &rhs) = delete;
private:
    // func:amc.FFfast..Ctor
    inline               FFfast() __attribute__((nothrow));
    // func:amc.FFfast..Dtor
    inline               ~FFfast() __attribute__((nothrow));
    friend amc::FFfast&         ffast_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFfast*         ffast_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ffast_RemoveAll() __attribute__((nothrow));
    friend void                 ffast_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFfast.base.CopyOut
void                 ffast_CopyOut(amc::FFfast &row, dmmeta::Ffast &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFfast.base.CopyIn
void                 ffast_CopyIn(amc::FFfast &row, dmmeta::Ffast &in) __attribute__((nothrow));

// func:amc.FFfast.field.Get
algo::Smallstr100    field_Get(amc::FFfast& ffast) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFfast.ctype.Get
algo::Smallstr100    ctype_Get(amc::FFfast& ffast) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFfast.fastinstr.Get
algo::Smallstr50     fastinstr_Get(amc::FFfast& ffast) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFfast..Init
void                 FFfast_Init(amc::FFfast& ffast);
// func:amc.FFfast..Uninit
void                 FFfast_Uninit(amc::FFfast& ffast) __attribute__((nothrow));

// --- amc.FFflag
// create: amc.FDb.fflag (Lary)
// global access: fflag (Lary, by rowid)
// global access: ind_fflag (Thash, hash field field)
// access: amc.FField.c_fflag (Ptr)
struct FFflag { // amc.FFflag
    amc::FFflag*        ind_fflag_next;   // hash next
    algo::Smallstr100   field;            //
    bool                cumulative;       //   false  Accumulate on every read
    algo::cstring       emptyval;         //   ""
    algo::Comment       comment;          //
    // func:amc.FFflag..AssignOp
    inline amc::FFflag&  operator =(const amc::FFflag &rhs) = delete;
    // func:amc.FFflag..CopyCtor
    inline               FFflag(const amc::FFflag &rhs) = delete;
private:
    // func:amc.FFflag..Ctor
    inline               FFflag() __attribute__((nothrow));
    // func:amc.FFflag..Dtor
    inline               ~FFflag() __attribute__((nothrow));
    friend amc::FFflag&         fflag_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFflag*         fflag_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fflag_RemoveAll() __attribute__((nothrow));
    friend void                 fflag_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFflag.base.CopyOut
void                 fflag_CopyOut(amc::FFflag &row, dmmeta::Fflag &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFflag.base.CopyIn
void                 fflag_CopyIn(amc::FFflag &row, dmmeta::Fflag &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFflag..Init
inline void          FFflag_Init(amc::FFflag& fflag);
// func:amc.FFflag..Uninit
void                 FFflag_Uninit(amc::FFflag& fflag) __attribute__((nothrow));

// --- amc.FField
// create: amc.FDb.field (Lary)
// global access: field (Lary, by rowid)
// global access: ind_field (Thash, hash field field)
// global access: c_malloc (Ptr)
// global access: zs_ordkeyfield (Llist)
// global access: c_tempfield (Ptrary)
// access: amc.FBasepool.p_field (Upptr)
// access: amc.FBasepool.p_base (Upptr)
// access: amc.FBitfld.p_srcfield (Upptr)
// access: amc.FBitfld.p_field (Upptr)
// access: amc.FCascdel.p_field (Upptr)
// access: amc.FCtype.c_field (Ptrary)
// access: amc.FCtype.c_varlenfld (Ptr)
// access: amc.FCtype.c_optfld (Ptr)
// access: amc.FCtype.c_datafld (Ptrary)
// access: amc.FCtype.zd_inst (Llist)
// access: amc.FCtype.zd_access (Llist)
// access: amc.FCtype.c_pkeyfield (Ptr)
// access: amc.FFalias.p_srcfield (Upptr)
// access: amc.FFbigend.p_field (Upptr)
// access: amc.FFbitset.p_field (Upptr)
// access: amc.FFbuf.p_insready (Upptr)
// access: amc.FFbuf.p_inseof (Upptr)
// access: amc.FFcleanup.p_field (Upptr)
// access: amc.FFcmap.p_leftField (Upptr)
// access: amc.FFcmap.p_rightField (Upptr)
// access: amc.FFcmdline.p_field (Upptr)
// access: amc.FFcmdline.p_basecmdline (Upptr)
// access: amc.FFconst.p_field (Upptr)
// access: amc.FFcurs.p_field (Upptr)
// access: amc.FFdec.p_field (Upptr)
// access: amc.FFfast.p_field (Upptr)
// access: amc.FFinput.p_field (Upptr)
// access: amc.FFldoffset.p_field (Upptr)
// access: amc.FFloadtuples.p_field (Upptr)
// access: amc.FFsort.p_field (Upptr)
// access: amc.FFsort.p_sortfld (Upptr)
// access: amc.FFstep.p_field (Upptr)
// access: amc.FGconst.p_namefld (Upptr)
// access: amc.FGconst.p_field (Upptr)
// access: amc.FGstatic.p_field (Upptr)
// access: amc.FHook.p_field (Upptr)
// access: amc.FLenfld.p_field (Upptr)
// access: amc.FNs.c_globfld (Ptr)
// access: amc.FNsx.p_pool (Upptr)
// access: amc.FPmaskfld.p_field (Upptr)
// access: amc.FPmaskfldMember.p_field (Upptr)
// access: amc.FPtrary.p_field (Upptr)
// access: amc.FSmallstr.p_field (Upptr)
// access: amc.FSortfld.p_sortfld (Upptr)
// access: amc.FSsimsort.p_sortfld (Upptr)
// access: amc.FSubstr.p_field (Upptr)
// access: amc.FSubstr.p_srcfield (Upptr)
// access: amc.FTary.p_field (Upptr)
// access: amc.FThash.p_hashfld (Upptr)
// access: amc.FThash.p_field (Upptr)
// access: amc.FTypefld.p_field (Upptr)
// access: amc.FXref.p_field (Upptr)
// access: amc.FXref.p_viafld (Upptr)
// access: amc.FXref.p_keyfld (Upptr)
// access: amc.Genctx.p_field (Upptr)
// access: amc.Genpnew.p_optfld (Upptr)
// access: amc.Genpnew.p_varlenfld (Upptr)
struct FField { // amc.FField
    amc::FField*             zd_inst_next;              // zslist link; -1 means not-in-list
    amc::FField*             zd_inst_prev;              // previous element
    amc::FField*             zd_access_next;            // zslist link; -1 means not-in-list
    amc::FField*             zd_access_prev;            // previous element
    amc::FField*             ind_field_next;            // hash next
    amc::FField*             zs_ordkeyfield_next;       // zslist link; -1 means not-in-list
    algo::Smallstr100        field;                     // Primary key, as ctype.name
    algo::Smallstr100        arg;                       // Type of field
    algo::Smallstr50         reftype;                   //   "Val"  Type constructor
    algo::CppExpr            dflt;                      // Default value (c++ expression)
    algo::Comment            comment;                   //
    amc::FFsort*             c_fsort;                   // optional pointer
    amc::FFbitset*           c_fbitset;                 // optional pointer
    amc::FSmallstr*          c_smallstr;                // optional pointer
    amc::FFunc**             c_ffunc_elems;             // array of pointers
    u32                      c_ffunc_n;                 // array of pointers
    u32                      c_ffunc_max;               // capacity of allocated array
    algo::cstring            cpp_type;                  // C++ expression to use in declaration
    amc::FCtype*             p_ctype;                   // reference to parent row
    amc::FCtype*             p_arg;                     // reference to parent row
    amc::FXref*              c_xref;                    // optional pointer
    amc::FAnonfld*           c_anonfld;                 // optional pointer
    amc::FFldoffset*         c_fldoffset;               // optional pointer
    amc::FBasepool*          c_basepool;                // optional pointer
    amc::FLlist*             c_llist;                   // optional pointer
    amc::FThash*             c_thash;                   // optional pointer
    amc::FInlary*            c_inlary;                  // optional pointer
    amc::FTary*              c_tary;                    // optional pointer
    amc::FRowid*             c_rowid;                   // optional pointer
    amc::FCascdel*           c_cascdel;                 // optional pointer
    double                   rowid;                     //   0.0
    double                   child_rowid;               //   0.0  Rowid increment for next child
    amc::FGstatic*           c_gstatic;                 // optional pointer
    amc::FPtrary*            c_ptrary;                  // optional pointer
    amc::FPmaskfld*          c_pmaskfld;                // optional pointer
    amc::FTypefld*           c_typefld;                 // optional pointer
    amc::FFcleanup*          c_fcleanup;                // optional pointer
    amc::FFdec*              c_fdec;                    // optional pointer
    amc::FReftype*           p_reftype;                 // reference to parent row
    amc::FFconst**           c_fconst_elems;            // array of pointers
    u32                      c_fconst_n;                // array of pointers
    u32                      c_fconst_max;              // capacity of allocated array
    amc::FFinput*            c_finput;                  // optional pointer
    amc::FFoutput*           c_foutput;                 // optional pointer
    amc::FFbuf*              c_fbuf;                    // optional pointer
    amc::FFbigend*           c_fbigend;                 // optional pointer
    amc::FFstep*             c_fstep;                   // optional pointer
    amc::FFregx*             c_fregx;                   // optional pointer
    amc::FFcmp*              c_fcmp;                    // optional pointer
    amc::FFcast*             c_fcast;                   // optional pointer
    amc::FGconst*            c_gconst;                  // optional pointer
    amc::FBitfld*            c_bitfld;                  // optional pointer
    amc::FNoxref*            c_noxref;                  // optional pointer
    amc::FCppfunc*           c_cppfunc;                 // optional pointer
    amc::FSubstr*            c_substr;                  // optional pointer
    amc::FFcompact*          c_fcompact;                // optional pointer
    amc::FFindrem*           c_findrem;                 // optional pointer
    amc::FXref*              zd_xref_keyfld_head;       // zero-terminated doubly linked list
    i32                      zd_xref_keyfld_n;          // zero-terminated doubly linked list
    amc::FXref*              zd_xref_keyfld_tail;       // pointer to last element
    amc::FFcmap*             zs_fcmap_head;             // zero-terminated singly linked list
    amc::FFcmap*             zs_fcmap_tail;             // pointer to last element
    amc::FFconst*            c_inkey_fconst;            // optional pointer
    amc::FFbase*             c_fbase;                   // optional pointer
    amc::FFnoremove*         c_fnoremove;               // optional pointer
    amc::FSortfld*           c_sortfld;                 // optional pointer
    amc::FFtrace*            c_ftrace;                  // optional pointer
    bool                     reflect;                   //   false  Want reflection
    bool                     ctype_read;                //   false  Field is readable using its ctype's ReadStrptrMaybe function
    bool                     has_substr;                //   false
    bool                     need_firstchanged;         //   false
    bool                     do_trace;                  //   false  Enable tracing
    bool                     processed;                 //   false
    bool                     synthetic;                 //   false
    bool                     visit;                     //   false  Temporary flag
    amc::FHook*              c_hook;                    // optional pointer
    amc::FCharset*           c_charset;                 // optional pointer
    amc::FBitfld**           bh_bitfld_elems;           // binary heap by offset
    i32                      bh_bitfld_n;               // number of elements in the heap
    i32                      bh_bitfld_max;             // max elements in bh_bitfld_elems
    amc::FFunique*           c_funique;                 // optional pointer
    amc::FFuserinit*         c_fuserinit;               // optional pointer
    amc::FFflag*             c_fflag;                   // optional pointer
    amc::FFalias*            c_falias;                  // optional pointer
    amc::FFfast*             c_ffast_field;             // optional pointer
    amc::FFfast*             c_ffast_length;            // optional pointer
    amc::FFfast*             c_ffast_mantissa;          // optional pointer
    amc::FFfast**            c_ffast_elems;             // array of pointers
    u32                      c_ffast_n;                 // array of pointers
    u32                      c_ffast_max;               // capacity of allocated array
    amc::FPmaskfldMember**   c_pmaskfld_member_elems;   // array of pointers
    u32                      c_pmaskfld_member_n;       // array of pointers
    u32                      c_pmaskfld_member_max;     // capacity of allocated array
    bool                     ctype_c_datafld_in_ary;    //   false  membership flag
    bool                     _db_c_tempfield_in_ary;    //   false  membership flag
    // x-reference on amc.FField.c_fsort prevents copy
    // x-reference on amc.FField.c_fbitset prevents copy
    // x-reference on amc.FField.c_smallstr prevents copy
    // reftype Ptrary of amc.FField.c_ffunc prohibits copy
    // x-reference on amc.FField.p_ctype prevents copy
    // x-reference on amc.FField.p_arg prevents copy
    // x-reference on amc.FField.c_xref prevents copy
    // x-reference on amc.FField.c_anonfld prevents copy
    // x-reference on amc.FField.c_fldoffset prevents copy
    // x-reference on amc.FField.c_basepool prevents copy
    // x-reference on amc.FField.c_llist prevents copy
    // x-reference on amc.FField.c_thash prevents copy
    // x-reference on amc.FField.c_inlary prevents copy
    // x-reference on amc.FField.c_tary prevents copy
    // x-reference on amc.FField.c_rowid prevents copy
    // x-reference on amc.FField.c_cascdel prevents copy
    // x-reference on amc.FField.c_gstatic prevents copy
    // x-reference on amc.FField.c_ptrary prevents copy
    // x-reference on amc.FField.c_pmaskfld prevents copy
    // x-reference on amc.FField.c_typefld prevents copy
    // x-reference on amc.FField.c_fcleanup prevents copy
    // x-reference on amc.FField.c_fdec prevents copy
    // x-reference on amc.FField.p_reftype prevents copy
    // reftype Ptrary of amc.FField.c_fconst prohibits copy
    // x-reference on amc.FField.c_finput prevents copy
    // x-reference on amc.FField.c_foutput prevents copy
    // x-reference on amc.FField.c_fbuf prevents copy
    // x-reference on amc.FField.c_fbigend prevents copy
    // x-reference on amc.FField.c_fstep prevents copy
    // x-reference on amc.FField.c_fregx prevents copy
    // x-reference on amc.FField.c_fcmp prevents copy
    // x-reference on amc.FField.c_fcast prevents copy
    // x-reference on amc.FField.c_gconst prevents copy
    // x-reference on amc.FField.c_bitfld prevents copy
    // x-reference on amc.FField.c_noxref prevents copy
    // x-reference on amc.FField.c_cppfunc prevents copy
    // x-reference on amc.FField.c_substr prevents copy
    // x-reference on amc.FField.c_fcompact prevents copy
    // x-reference on amc.FField.c_findrem prevents copy
    // reftype Llist of amc.FField.zd_xref_keyfld prohibits copy
    // reftype Llist of amc.FField.zs_fcmap prohibits copy
    // x-reference on amc.FField.c_fbase prevents copy
    // x-reference on amc.FField.c_fnoremove prevents copy
    // x-reference on amc.FField.c_sortfld prevents copy
    // x-reference on amc.FField.c_ftrace prevents copy
    // x-reference on amc.FField.c_hook prevents copy
    // x-reference on amc.FField.c_charset prevents copy
    // reftype Bheap of amc.FField.bh_bitfld prohibits copy
    // x-reference on amc.FField.c_funique prevents copy
    // x-reference on amc.FField.c_fuserinit prevents copy
    // x-reference on amc.FField.c_fflag prevents copy
    // x-reference on amc.FField.c_falias prevents copy
    // x-reference on amc.FField.c_ffast_field prevents copy
    // x-reference on amc.FField.c_ffast_length prevents copy
    // x-reference on amc.FField.c_ffast_mantissa prevents copy
    // reftype Ptrary of amc.FField.c_ffast prohibits copy
    // reftype Ptrary of amc.FField.c_pmaskfld_member prohibits copy
    // func:amc.FField..AssignOp
    amc::FField&         operator =(const amc::FField &rhs) = delete;
    // x-reference on amc.FField.c_fsort prevents copy
    // x-reference on amc.FField.c_fbitset prevents copy
    // x-reference on amc.FField.c_smallstr prevents copy
    // reftype Ptrary of amc.FField.c_ffunc prohibits copy
    // x-reference on amc.FField.p_ctype prevents copy
    // x-reference on amc.FField.p_arg prevents copy
    // x-reference on amc.FField.c_xref prevents copy
    // x-reference on amc.FField.c_anonfld prevents copy
    // x-reference on amc.FField.c_fldoffset prevents copy
    // x-reference on amc.FField.c_basepool prevents copy
    // x-reference on amc.FField.c_llist prevents copy
    // x-reference on amc.FField.c_thash prevents copy
    // x-reference on amc.FField.c_inlary prevents copy
    // x-reference on amc.FField.c_tary prevents copy
    // x-reference on amc.FField.c_rowid prevents copy
    // x-reference on amc.FField.c_cascdel prevents copy
    // x-reference on amc.FField.c_gstatic prevents copy
    // x-reference on amc.FField.c_ptrary prevents copy
    // x-reference on amc.FField.c_pmaskfld prevents copy
    // x-reference on amc.FField.c_typefld prevents copy
    // x-reference on amc.FField.c_fcleanup prevents copy
    // x-reference on amc.FField.c_fdec prevents copy
    // x-reference on amc.FField.p_reftype prevents copy
    // reftype Ptrary of amc.FField.c_fconst prohibits copy
    // x-reference on amc.FField.c_finput prevents copy
    // x-reference on amc.FField.c_foutput prevents copy
    // x-reference on amc.FField.c_fbuf prevents copy
    // x-reference on amc.FField.c_fbigend prevents copy
    // x-reference on amc.FField.c_fstep prevents copy
    // x-reference on amc.FField.c_fregx prevents copy
    // x-reference on amc.FField.c_fcmp prevents copy
    // x-reference on amc.FField.c_fcast prevents copy
    // x-reference on amc.FField.c_gconst prevents copy
    // x-reference on amc.FField.c_bitfld prevents copy
    // x-reference on amc.FField.c_noxref prevents copy
    // x-reference on amc.FField.c_cppfunc prevents copy
    // x-reference on amc.FField.c_substr prevents copy
    // x-reference on amc.FField.c_fcompact prevents copy
    // x-reference on amc.FField.c_findrem prevents copy
    // reftype Llist of amc.FField.zd_xref_keyfld prohibits copy
    // reftype Llist of amc.FField.zs_fcmap prohibits copy
    // x-reference on amc.FField.c_fbase prevents copy
    // x-reference on amc.FField.c_fnoremove prevents copy
    // x-reference on amc.FField.c_sortfld prevents copy
    // x-reference on amc.FField.c_ftrace prevents copy
    // x-reference on amc.FField.c_hook prevents copy
    // x-reference on amc.FField.c_charset prevents copy
    // reftype Bheap of amc.FField.bh_bitfld prohibits copy
    // x-reference on amc.FField.c_funique prevents copy
    // x-reference on amc.FField.c_fuserinit prevents copy
    // x-reference on amc.FField.c_fflag prevents copy
    // x-reference on amc.FField.c_falias prevents copy
    // x-reference on amc.FField.c_ffast_field prevents copy
    // x-reference on amc.FField.c_ffast_length prevents copy
    // x-reference on amc.FField.c_ffast_mantissa prevents copy
    // reftype Ptrary of amc.FField.c_ffast prohibits copy
    // reftype Ptrary of amc.FField.c_pmaskfld_member prohibits copy
    // func:amc.FField..CopyCtor
    FField(const amc::FField &rhs) = delete;
private:
    // func:amc.FField..Ctor
    inline               FField() __attribute__((nothrow));
    // func:amc.FField..Dtor
    inline               ~FField() __attribute__((nothrow));
    friend amc::FField&         field_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FField*         field_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 field_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FField.msghdr.CopyOut
void                 field_CopyOut(amc::FField &row, dmmeta::Field &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FField.msghdr.CopyIn
void                 field_CopyIn(amc::FField &row, dmmeta::Field &in) __attribute__((nothrow));

// func:amc.FField.ctype.Get
algo::Smallstr100    ctype_Get(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FField.ns.Get
algo::Smallstr16     ns_Get(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FField.name.Get
algo::Smallstr50     name_Get(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fsort.InsertMaybe
inline bool          c_fsort_InsertMaybe(amc::FField& field, amc::FFsort& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fsort.Remove
inline void          c_fsort_Remove(amc::FField& field, amc::FFsort& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fbitset.InsertMaybe
inline bool          c_fbitset_InsertMaybe(amc::FField& field, amc::FFbitset& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fbitset.Remove
inline void          c_fbitset_Remove(amc::FField& field, amc::FFbitset& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_smallstr.InsertMaybe
inline bool          c_smallstr_InsertMaybe(amc::FField& field, amc::FSmallstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_smallstr.Remove
inline void          c_smallstr_Remove(amc::FField& field, amc::FSmallstr& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FField.c_ffunc.EmptyQ
inline bool          c_ffunc_EmptyQ(amc::FField& field) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FField.c_ffunc.Find
inline amc::FFunc*   c_ffunc_Find(amc::FField& field, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FField.c_ffunc.Getary
inline algo::aryptr<amc::FFunc*> c_ffunc_Getary(amc::FField& field) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FField.c_ffunc.Insert
void                 c_ffunc_Insert(amc::FField& field, amc::FFunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FField.c_ffunc.ScanInsertMaybe
bool                 c_ffunc_ScanInsertMaybe(amc::FField& field, amc::FFunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FField.c_ffunc.N
inline i32           c_ffunc_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FField.c_ffunc.Remove
void                 c_ffunc_Remove(amc::FField& field, amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FField.c_ffunc.RemoveAll
inline void          c_ffunc_RemoveAll(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FField.c_ffunc.Reserve
void                 c_ffunc_Reserve(amc::FField& field, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FField.c_ffunc.qFind
inline amc::FFunc&   c_ffunc_qFind(amc::FField& field, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FField.c_ffunc.qLast
inline amc::FFunc&   c_ffunc_qLast(amc::FField& field) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_xref.InsertMaybe
inline bool          c_xref_InsertMaybe(amc::FField& field, amc::FXref& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_xref.Remove
inline void          c_xref_Remove(amc::FField& field, amc::FXref& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_anonfld.InsertMaybe
inline bool          c_anonfld_InsertMaybe(amc::FField& field, amc::FAnonfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_anonfld.Remove
inline void          c_anonfld_Remove(amc::FField& field, amc::FAnonfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fldoffset.InsertMaybe
inline bool          c_fldoffset_InsertMaybe(amc::FField& field, amc::FFldoffset& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fldoffset.Remove
inline void          c_fldoffset_Remove(amc::FField& field, amc::FFldoffset& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_basepool.InsertMaybe
inline bool          c_basepool_InsertMaybe(amc::FField& field, amc::FBasepool& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_basepool.Remove
inline void          c_basepool_Remove(amc::FField& field, amc::FBasepool& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_llist.InsertMaybe
inline bool          c_llist_InsertMaybe(amc::FField& field, amc::FLlist& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_llist.Remove
inline void          c_llist_Remove(amc::FField& field, amc::FLlist& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_thash.InsertMaybe
inline bool          c_thash_InsertMaybe(amc::FField& field, amc::FThash& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_thash.Remove
inline void          c_thash_Remove(amc::FField& field, amc::FThash& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_inlary.InsertMaybe
inline bool          c_inlary_InsertMaybe(amc::FField& field, amc::FInlary& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_inlary.Remove
inline void          c_inlary_Remove(amc::FField& field, amc::FInlary& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_tary.InsertMaybe
inline bool          c_tary_InsertMaybe(amc::FField& field, amc::FTary& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_tary.Remove
inline void          c_tary_Remove(amc::FField& field, amc::FTary& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_rowid.InsertMaybe
inline bool          c_rowid_InsertMaybe(amc::FField& field, amc::FRowid& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_rowid.Remove
inline void          c_rowid_Remove(amc::FField& field, amc::FRowid& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_cascdel.InsertMaybe
inline bool          c_cascdel_InsertMaybe(amc::FField& field, amc::FCascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_cascdel.Remove
inline void          c_cascdel_Remove(amc::FField& field, amc::FCascdel& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_gstatic.InsertMaybe
inline bool          c_gstatic_InsertMaybe(amc::FField& field, amc::FGstatic& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_gstatic.Remove
inline void          c_gstatic_Remove(amc::FField& field, amc::FGstatic& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_ptrary.InsertMaybe
inline bool          c_ptrary_InsertMaybe(amc::FField& field, amc::FPtrary& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_ptrary.Remove
inline void          c_ptrary_Remove(amc::FField& field, amc::FPtrary& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_pmaskfld.InsertMaybe
inline bool          c_pmaskfld_InsertMaybe(amc::FField& field, amc::FPmaskfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_pmaskfld.Remove
inline void          c_pmaskfld_Remove(amc::FField& field, amc::FPmaskfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_typefld.InsertMaybe
inline bool          c_typefld_InsertMaybe(amc::FField& field, amc::FTypefld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_typefld.Remove
inline void          c_typefld_Remove(amc::FField& field, amc::FTypefld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fcleanup.InsertMaybe
inline bool          c_fcleanup_InsertMaybe(amc::FField& field, amc::FFcleanup& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fcleanup.Remove
inline void          c_fcleanup_Remove(amc::FField& field, amc::FFcleanup& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fdec.InsertMaybe
inline bool          c_fdec_InsertMaybe(amc::FField& field, amc::FFdec& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fdec.Remove
inline void          c_fdec_Remove(amc::FField& field, amc::FFdec& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FField.c_fconst.EmptyQ
inline bool          c_fconst_EmptyQ(amc::FField& field) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FField.c_fconst.Find
inline amc::FFconst* c_fconst_Find(amc::FField& field, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FField.c_fconst.Getary
inline algo::aryptr<amc::FFconst*> c_fconst_Getary(amc::FField& field) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FField.c_fconst.Insert
void                 c_fconst_Insert(amc::FField& field, amc::FFconst& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FField.c_fconst.InsertMaybe
bool                 c_fconst_InsertMaybe(amc::FField& field, amc::FFconst& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FField.c_fconst.N
inline i32           c_fconst_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FField.c_fconst.Remove
void                 c_fconst_Remove(amc::FField& field, amc::FFconst& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FField.c_fconst.RemoveAll
inline void          c_fconst_RemoveAll(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FField.c_fconst.Reserve
void                 c_fconst_Reserve(amc::FField& field, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FField.c_fconst.qFind
inline amc::FFconst& c_fconst_qFind(amc::FField& field, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FField.c_fconst.InAryQ
inline bool          field_c_fconst_InAryQ(amc::FFconst& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FField.c_fconst.qLast
inline amc::FFconst& c_fconst_qLast(amc::FField& field) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_finput.InsertMaybe
inline bool          c_finput_InsertMaybe(amc::FField& field, amc::FFinput& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_finput.Remove
inline void          c_finput_Remove(amc::FField& field, amc::FFinput& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_foutput.InsertMaybe
inline bool          c_foutput_InsertMaybe(amc::FField& field, amc::FFoutput& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_foutput.Remove
inline void          c_foutput_Remove(amc::FField& field, amc::FFoutput& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fbuf.InsertMaybe
inline bool          c_fbuf_InsertMaybe(amc::FField& field, amc::FFbuf& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fbuf.Remove
inline void          c_fbuf_Remove(amc::FField& field, amc::FFbuf& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fbigend.InsertMaybe
inline bool          c_fbigend_InsertMaybe(amc::FField& field, amc::FFbigend& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fbigend.Remove
inline void          c_fbigend_Remove(amc::FField& field, amc::FFbigend& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fstep.InsertMaybe
inline bool          c_fstep_InsertMaybe(amc::FField& field, amc::FFstep& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fstep.Remove
inline void          c_fstep_Remove(amc::FField& field, amc::FFstep& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fregx.InsertMaybe
inline bool          c_fregx_InsertMaybe(amc::FField& field, amc::FFregx& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fregx.Remove
inline void          c_fregx_Remove(amc::FField& field, amc::FFregx& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fcmp.InsertMaybe
inline bool          c_fcmp_InsertMaybe(amc::FField& field, amc::FFcmp& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fcmp.Remove
inline void          c_fcmp_Remove(amc::FField& field, amc::FFcmp& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fcast.InsertMaybe
inline bool          c_fcast_InsertMaybe(amc::FField& field, amc::FFcast& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fcast.Remove
inline void          c_fcast_Remove(amc::FField& field, amc::FFcast& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_gconst.InsertMaybe
inline bool          c_gconst_InsertMaybe(amc::FField& field, amc::FGconst& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_gconst.Remove
inline void          c_gconst_Remove(amc::FField& field, amc::FGconst& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_bitfld.InsertMaybe
inline bool          c_bitfld_InsertMaybe(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_bitfld.Remove
inline void          c_bitfld_Remove(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_noxref.InsertMaybe
inline bool          c_noxref_InsertMaybe(amc::FField& field, amc::FNoxref& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_noxref.Remove
inline void          c_noxref_Remove(amc::FField& field, amc::FNoxref& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_cppfunc.InsertMaybe
inline bool          c_cppfunc_InsertMaybe(amc::FField& field, amc::FCppfunc& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_cppfunc.Remove
inline void          c_cppfunc_Remove(amc::FField& field, amc::FCppfunc& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_substr.InsertMaybe
inline bool          c_substr_InsertMaybe(amc::FField& field, amc::FSubstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_substr.Remove
inline void          c_substr_Remove(amc::FField& field, amc::FSubstr& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fcompact.InsertMaybe
inline bool          c_fcompact_InsertMaybe(amc::FField& field, amc::FFcompact& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fcompact.Remove
inline void          c_fcompact_Remove(amc::FField& field, amc::FFcompact& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_findrem.InsertMaybe
inline bool          c_findrem_InsertMaybe(amc::FField& field, amc::FFindrem& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_findrem.Remove
inline void          c_findrem_Remove(amc::FField& field, amc::FFindrem& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FField.zd_xref_keyfld.EmptyQ
inline bool          zd_xref_keyfld_EmptyQ(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FField.zd_xref_keyfld.First
inline amc::FXref*   zd_xref_keyfld_First(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FField.zd_xref_keyfld.InLlistQ
inline bool          zd_xref_keyfld_InLlistQ(amc::FXref& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FField.zd_xref_keyfld.Insert
void                 zd_xref_keyfld_Insert(amc::FField& field, amc::FXref& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FField.zd_xref_keyfld.Last
inline amc::FXref*   zd_xref_keyfld_Last(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:amc.FField.zd_xref_keyfld.N
inline i32           zd_xref_keyfld_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FField.zd_xref_keyfld.Next
inline amc::FXref*   zd_xref_keyfld_Next(amc::FXref &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:amc.FField.zd_xref_keyfld.Prev
inline amc::FXref*   zd_xref_keyfld_Prev(amc::FXref &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.zd_xref_keyfld.Remove
void                 zd_xref_keyfld_Remove(amc::FField& field, amc::FXref& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FField.zd_xref_keyfld.RemoveAll
void                 zd_xref_keyfld_RemoveAll(amc::FField& field) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FField.zd_xref_keyfld.RemoveFirst
amc::FXref*          zd_xref_keyfld_RemoveFirst(amc::FField& field) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FField.zd_xref_keyfld.qLast
inline amc::FXref&   zd_xref_keyfld_qLast(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:amc.FField.zs_fcmap.EmptyQ
inline bool          zs_fcmap_EmptyQ(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FField.zs_fcmap.First
inline amc::FFcmap*  zs_fcmap_First(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FField.zs_fcmap.InLlistQ
inline bool          zs_fcmap_InLlistQ(amc::FFcmap& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FField.zs_fcmap.Insert
void                 zs_fcmap_Insert(amc::FField& field, amc::FFcmap& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FField.zs_fcmap.Last
inline amc::FFcmap*  zs_fcmap_Last(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FField.zs_fcmap.Next
inline amc::FFcmap*  zs_fcmap_Next(amc::FFcmap &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FField.zs_fcmap.Remove
void                 zs_fcmap_Remove(amc::FField& field, amc::FFcmap& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FField.zs_fcmap.RemoveAll
void                 zs_fcmap_RemoveAll(amc::FField& field) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FField.zs_fcmap.RemoveFirst
amc::FFcmap*         zs_fcmap_RemoveFirst(amc::FField& field) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FField.zs_fcmap.qLast
inline amc::FFcmap&  zs_fcmap_qLast(amc::FField& field) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fbase.InsertMaybe
inline bool          c_fbase_InsertMaybe(amc::FField& field, amc::FFbase& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fbase.Remove
inline void          c_fbase_Remove(amc::FField& field, amc::FFbase& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fnoremove.InsertMaybe
inline bool          c_fnoremove_InsertMaybe(amc::FField& field, amc::FFnoremove& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fnoremove.Remove
inline void          c_fnoremove_Remove(amc::FField& field, amc::FFnoremove& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_sortfld.InsertMaybe
inline bool          c_sortfld_InsertMaybe(amc::FField& field, amc::FSortfld& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_sortfld.Remove
inline void          c_sortfld_Remove(amc::FField& field, amc::FSortfld& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_ftrace.InsertMaybe
inline bool          c_ftrace_InsertMaybe(amc::FField& field, amc::FFtrace& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_ftrace.Remove
inline void          c_ftrace_Remove(amc::FField& field, amc::FFtrace& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_hook.InsertMaybe
inline bool          c_hook_InsertMaybe(amc::FField& field, amc::FHook& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_hook.Remove
inline void          c_hook_Remove(amc::FField& field, amc::FHook& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_charset.InsertMaybe
inline bool          c_charset_InsertMaybe(amc::FField& field, amc::FCharset& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_charset.Remove
inline void          c_charset_Remove(amc::FField& field, amc::FCharset& row) __attribute__((nothrow));

// Remove all elements from heap and free memory used by the array.
// func:amc.FField.bh_bitfld.Dealloc
void                 bh_bitfld_Dealloc(amc::FField& field) __attribute__((nothrow));
// Return true if index is empty
// func:amc.FField.bh_bitfld.EmptyQ
inline bool          bh_bitfld_EmptyQ(amc::FField& field) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FField.bh_bitfld.First
inline amc::FBitfld* bh_bitfld_First(amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in index, false otherwise
// func:amc.FField.bh_bitfld.InBheapQ
inline bool          bh_bitfld_InBheapQ(amc::FBitfld& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row. Row must not already be in index. If row is already in index, do nothing.
// func:amc.FField.bh_bitfld.Insert
void                 bh_bitfld_Insert(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Return number of items in the heap
// func:amc.FField.bh_bitfld.N
inline i32           bh_bitfld_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// If row is in heap, update its position. If row is not in heap, insert it.
// Return new position of item in the heap (0=top)
// func:amc.FField.bh_bitfld.Reheap
i32                  bh_bitfld_Reheap(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Key of first element in the heap changed. Move it.
// This function does not check the insert condition.
// Return new position of item in the heap (0=top).
// Heap must be non-empty or behavior is undefined.
// func:amc.FField.bh_bitfld.ReheapFirst
i32                  bh_bitfld_ReheapFirst(amc::FField& field) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.bh_bitfld.Remove
void                 bh_bitfld_Remove(amc::FField& field, amc::FBitfld& row) __attribute__((nothrow));
// Remove all elements from binary heap
// func:amc.FField.bh_bitfld.RemoveAll
void                 bh_bitfld_RemoveAll(amc::FField& field) __attribute__((nothrow));
// If index is empty, return NULL. Otherwise remove and return first key in index.
//  Call 'head changed' trigger.
// func:amc.FField.bh_bitfld.RemoveFirst
amc::FBitfld*        bh_bitfld_RemoveFirst(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements
// func:amc.FField.bh_bitfld.Reserve
void                 bh_bitfld_Reserve(amc::FField& field, int n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_funique.InsertMaybe
inline bool          c_funique_InsertMaybe(amc::FField& field, amc::FFunique& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_funique.Remove
inline void          c_funique_Remove(amc::FField& field, amc::FFunique& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fuserinit.InsertMaybe
inline bool          c_fuserinit_InsertMaybe(amc::FField& field, amc::FFuserinit& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fuserinit.Remove
inline void          c_fuserinit_Remove(amc::FField& field, amc::FFuserinit& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_fflag.InsertMaybe
inline bool          c_fflag_InsertMaybe(amc::FField& field, amc::FFflag& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_fflag.Remove
inline void          c_fflag_Remove(amc::FField& field, amc::FFflag& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_falias.InsertMaybe
inline bool          c_falias_InsertMaybe(amc::FField& field, amc::FFalias& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_falias.Remove
inline void          c_falias_Remove(amc::FField& field, amc::FFalias& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_ffast_field.InsertMaybe
inline bool          c_ffast_field_InsertMaybe(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_ffast_field.Remove
inline void          c_ffast_field_Remove(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_ffast_length.InsertMaybe
inline bool          c_ffast_length_InsertMaybe(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_ffast_length.Remove
inline void          c_ffast_length_Remove(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FField.c_ffast_mantissa.InsertMaybe
inline bool          c_ffast_mantissa_InsertMaybe(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FField.c_ffast_mantissa.Remove
inline void          c_ffast_mantissa_Remove(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FField.c_ffast.EmptyQ
inline bool          c_ffast_EmptyQ(amc::FField& field) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FField.c_ffast.Find
inline amc::FFfast*  c_ffast_Find(amc::FField& field, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FField.c_ffast.Getary
inline algo::aryptr<amc::FFfast*> c_ffast_Getary(amc::FField& field) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FField.c_ffast.Insert
void                 c_ffast_Insert(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FField.c_ffast.InsertMaybe
bool                 c_ffast_InsertMaybe(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FField.c_ffast.N
inline i32           c_ffast_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FField.c_ffast.Remove
void                 c_ffast_Remove(amc::FField& field, amc::FFfast& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FField.c_ffast.RemoveAll
inline void          c_ffast_RemoveAll(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FField.c_ffast.Reserve
void                 c_ffast_Reserve(amc::FField& field, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FField.c_ffast.qFind
inline amc::FFfast&  c_ffast_qFind(amc::FField& field, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FField.c_ffast.InAryQ
inline bool          field_c_ffast_InAryQ(amc::FFfast& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FField.c_ffast.qLast
inline amc::FFfast&  c_ffast_qLast(amc::FField& field) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FField.c_pmaskfld_member.EmptyQ
inline bool          c_pmaskfld_member_EmptyQ(amc::FField& field) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FField.c_pmaskfld_member.Find
inline amc::FPmaskfldMember* c_pmaskfld_member_Find(amc::FField& field, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FField.c_pmaskfld_member.Getary
inline algo::aryptr<amc::FPmaskfldMember*> c_pmaskfld_member_Getary(amc::FField& field) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FField.c_pmaskfld_member.Insert
void                 c_pmaskfld_member_Insert(amc::FField& field, amc::FPmaskfldMember& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FField.c_pmaskfld_member.InsertMaybe
bool                 c_pmaskfld_member_InsertMaybe(amc::FField& field, amc::FPmaskfldMember& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FField.c_pmaskfld_member.N
inline i32           c_pmaskfld_member_N(const amc::FField& field) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FField.c_pmaskfld_member.Remove
void                 c_pmaskfld_member_Remove(amc::FField& field, amc::FPmaskfldMember& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FField.c_pmaskfld_member.RemoveAll
inline void          c_pmaskfld_member_RemoveAll(amc::FField& field) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FField.c_pmaskfld_member.Reserve
void                 c_pmaskfld_member_Reserve(amc::FField& field, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FField.c_pmaskfld_member.qFind
inline amc::FPmaskfldMember& c_pmaskfld_member_qFind(amc::FField& field, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FField.c_pmaskfld_member.InAryQ
inline bool          field_c_pmaskfld_member_InAryQ(amc::FPmaskfldMember& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FField.c_pmaskfld_member.qLast
inline amc::FPmaskfldMember& c_pmaskfld_member_qLast(amc::FField& field) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FField..Init
void                 FField_Init(amc::FField& field);
// func:amc.FField.c_ffunc_curs.Reset
inline void          field_c_ffunc_curs_Reset(field_c_ffunc_curs &curs, amc::FField &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.c_ffunc_curs.ValidQ
inline bool          field_c_ffunc_curs_ValidQ(field_c_ffunc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FField.c_ffunc_curs.Next
inline void          field_c_ffunc_curs_Next(field_c_ffunc_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FField.c_ffunc_curs.Access
inline amc::FFunc&   field_c_ffunc_curs_Access(field_c_ffunc_curs &curs) __attribute__((nothrow));
// func:amc.FField.c_fconst_curs.Reset
inline void          field_c_fconst_curs_Reset(field_c_fconst_curs &curs, amc::FField &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.c_fconst_curs.ValidQ
inline bool          field_c_fconst_curs_ValidQ(field_c_fconst_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FField.c_fconst_curs.Next
inline void          field_c_fconst_curs_Next(field_c_fconst_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FField.c_fconst_curs.Access
inline amc::FFconst& field_c_fconst_curs_Access(field_c_fconst_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.zd_xref_keyfld_curs.Reset
inline void          field_zd_xref_keyfld_curs_Reset(field_zd_xref_keyfld_curs &curs, amc::FField &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.zd_xref_keyfld_curs.ValidQ
inline bool          field_zd_xref_keyfld_curs_ValidQ(field_zd_xref_keyfld_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FField.zd_xref_keyfld_curs.Next
inline void          field_zd_xref_keyfld_curs_Next(field_zd_xref_keyfld_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FField.zd_xref_keyfld_curs.Access
inline amc::FXref&   field_zd_xref_keyfld_curs_Access(field_zd_xref_keyfld_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.zs_fcmap_curs.Reset
inline void          field_zs_fcmap_curs_Reset(field_zs_fcmap_curs &curs, amc::FField &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.zs_fcmap_curs.ValidQ
inline bool          field_zs_fcmap_curs_ValidQ(field_zs_fcmap_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FField.zs_fcmap_curs.Next
inline void          field_zs_fcmap_curs_Next(field_zs_fcmap_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FField.zs_fcmap_curs.Access
inline amc::FFcmap&  field_zs_fcmap_curs_Access(field_zs_fcmap_curs &curs) __attribute__((nothrow));
// func:amc.FField.bh_bitfld_curs.Reserve
void                 field_bh_bitfld_curs_Reserve(field_bh_bitfld_curs &curs, int n);
// Reset cursor. If HEAP is non-empty, add its top element to CURS.
// func:amc.FField.bh_bitfld_curs.Reset
void                 field_bh_bitfld_curs_Reset(field_bh_bitfld_curs &curs, amc::FField &parent);
// Advance cursor.
// func:amc.FField.bh_bitfld_curs.Next
void                 field_bh_bitfld_curs_Next(field_bh_bitfld_curs &curs);
// Access current element. If not more elements, return NULL
// func:amc.FField.bh_bitfld_curs.Access
inline amc::FBitfld& field_bh_bitfld_curs_Access(field_bh_bitfld_curs &curs) __attribute__((nothrow));
// Return true if Access() will return non-NULL.
// func:amc.FField.bh_bitfld_curs.ValidQ
inline bool          field_bh_bitfld_curs_ValidQ(field_bh_bitfld_curs &curs) __attribute__((nothrow));
// func:amc.FField.c_ffast_curs.Reset
inline void          field_c_ffast_curs_Reset(field_c_ffast_curs &curs, amc::FField &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.c_ffast_curs.ValidQ
inline bool          field_c_ffast_curs_ValidQ(field_c_ffast_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FField.c_ffast_curs.Next
inline void          field_c_ffast_curs_Next(field_c_ffast_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FField.c_ffast_curs.Access
inline amc::FFfast&  field_c_ffast_curs_Access(field_c_ffast_curs &curs) __attribute__((nothrow));
// func:amc.FField.c_pmaskfld_member_curs.Reset
inline void          field_c_pmaskfld_member_curs_Reset(field_c_pmaskfld_member_curs &curs, amc::FField &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FField.c_pmaskfld_member_curs.ValidQ
inline bool          field_c_pmaskfld_member_curs_ValidQ(field_c_pmaskfld_member_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FField.c_pmaskfld_member_curs.Next
inline void          field_c_pmaskfld_member_curs_Next(field_c_pmaskfld_member_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FField.c_pmaskfld_member_curs.Access
inline amc::FPmaskfldMember& field_c_pmaskfld_member_curs_Access(field_c_pmaskfld_member_curs &curs) __attribute__((nothrow));
// func:amc.FField..Uninit
void                 FField_Uninit(amc::FField& field) __attribute__((nothrow));

// --- amc.FFindrem
// create: amc.FDb.findrem (Lary)
// global access: findrem (Lary, by rowid)
// access: amc.FField.c_findrem (Ptr)
struct FFindrem { // amc.FFindrem
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:amc.FFindrem..AssignOp
    inline amc::FFindrem& operator =(const amc::FFindrem &rhs) = delete;
    // func:amc.FFindrem..CopyCtor
    inline               FFindrem(const amc::FFindrem &rhs) = delete;
private:
    // func:amc.FFindrem..Ctor
    inline               FFindrem() __attribute__((nothrow));
    // func:amc.FFindrem..Dtor
    inline               ~FFindrem() __attribute__((nothrow));
    friend amc::FFindrem&       findrem_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFindrem*       findrem_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 findrem_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFindrem.base.CopyOut
void                 findrem_CopyOut(amc::FFindrem &row, dmmeta::Findrem &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFindrem.base.CopyIn
void                 findrem_CopyIn(amc::FFindrem &row, dmmeta::Findrem &in) __attribute__((nothrow));

// func:amc.FFindrem..Uninit
void                 FFindrem_Uninit(amc::FFindrem& findrem) __attribute__((nothrow));

// --- amc.FFinput
// create: amc.FDb.finput (Lary)
// global access: finput (Lary, by rowid)
// access: amc.FField.c_finput (Ptr)
struct FFinput { // amc.FFinput
    algo::Smallstr100   field;     // Target field to read
    bool                extrn;     //   false  Call user-provided function
    bool                update;    //   false
    bool                strict;    //   true  Exist process if record contains error
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FFinput.p_field prevents copy
    // func:amc.FFinput..AssignOp
    inline amc::FFinput& operator =(const amc::FFinput &rhs) = delete;
    // x-reference on amc.FFinput.p_field prevents copy
    // func:amc.FFinput..CopyCtor
    inline               FFinput(const amc::FFinput &rhs) = delete;
private:
    // func:amc.FFinput..Ctor
    inline               FFinput() __attribute__((nothrow));
    // func:amc.FFinput..Dtor
    inline               ~FFinput() __attribute__((nothrow));
    friend amc::FFinput&        finput_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFinput*        finput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 finput_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFinput.msghdr.CopyOut
void                 finput_CopyOut(amc::FFinput &row, dmmeta::Finput &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFinput.msghdr.CopyIn
void                 finput_CopyIn(amc::FFinput &row, dmmeta::Finput &in) __attribute__((nothrow));

// func:amc.FFinput.ns.Get
algo::Smallstr16     ns_Get(amc::FFinput& finput) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFinput..Init
inline void          FFinput_Init(amc::FFinput& finput);
// func:amc.FFinput..Uninit
void                 FFinput_Uninit(amc::FFinput& finput) __attribute__((nothrow));

// --- amc.FFldoffset
// create: amc.FDb.fldoffset (Lary)
// global access: fldoffset (Lary, by rowid)
// access: amc.FField.c_fldoffset (Ptr)
struct FFldoffset { // amc.FFldoffset
    algo::Smallstr100   field;     //
    i32                 offset;    //   0
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FFldoffset.p_field prevents copy
    // func:amc.FFldoffset..AssignOp
    inline amc::FFldoffset& operator =(const amc::FFldoffset &rhs) = delete;
    // x-reference on amc.FFldoffset.p_field prevents copy
    // func:amc.FFldoffset..CopyCtor
    inline               FFldoffset(const amc::FFldoffset &rhs) = delete;
private:
    // func:amc.FFldoffset..Ctor
    inline               FFldoffset() __attribute__((nothrow));
    // func:amc.FFldoffset..Dtor
    inline               ~FFldoffset() __attribute__((nothrow));
    friend amc::FFldoffset&     fldoffset_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFldoffset*     fldoffset_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fldoffset_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFldoffset.msghdr.CopyOut
void                 fldoffset_CopyOut(amc::FFldoffset &row, dmmeta::Fldoffset &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFldoffset.msghdr.CopyIn
void                 fldoffset_CopyIn(amc::FFldoffset &row, dmmeta::Fldoffset &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFldoffset..Init
inline void          FFldoffset_Init(amc::FFldoffset& fldoffset);
// func:amc.FFldoffset..Uninit
void                 FFldoffset_Uninit(amc::FFldoffset& fldoffset) __attribute__((nothrow));

// --- amc.FFloadtuples
// create: amc.FDb.floadtuples (Lary)
// global access: floadtuples (Lary, by rowid)
// access: amc.FCtype.c_floadtuples (Ptr)
struct FFloadtuples { // amc.FFloadtuples
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FFloadtuples.p_field prevents copy
    // func:amc.FFloadtuples..AssignOp
    inline amc::FFloadtuples& operator =(const amc::FFloadtuples &rhs) = delete;
    // x-reference on amc.FFloadtuples.p_field prevents copy
    // func:amc.FFloadtuples..CopyCtor
    inline               FFloadtuples(const amc::FFloadtuples &rhs) = delete;
private:
    // func:amc.FFloadtuples..Ctor
    inline               FFloadtuples() __attribute__((nothrow));
    // func:amc.FFloadtuples..Dtor
    inline               ~FFloadtuples() __attribute__((nothrow));
    friend amc::FFloadtuples&   floadtuples_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFloadtuples*   floadtuples_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 floadtuples_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFloadtuples.base.CopyOut
void                 floadtuples_CopyOut(amc::FFloadtuples &row, dmmeta::Floadtuples &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFloadtuples.base.CopyIn
void                 floadtuples_CopyIn(amc::FFloadtuples &row, dmmeta::Floadtuples &in) __attribute__((nothrow));

// func:amc.FFloadtuples.ctype.Get
algo::Smallstr100    ctype_Get(amc::FFloadtuples& floadtuples) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFloadtuples..Init
inline void          FFloadtuples_Init(amc::FFloadtuples& floadtuples);
// func:amc.FFloadtuples..Uninit
void                 FFloadtuples_Uninit(amc::FFloadtuples& floadtuples) __attribute__((nothrow));

// --- amc.FFnoremove
// create: amc.FDb.fnoremove (Lary)
// global access: fnoremove (Lary, by rowid)
// access: amc.FField.c_fnoremove (Ptr)
struct FFnoremove { // amc.FFnoremove
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:amc.FFnoremove..AssignOp
    inline amc::FFnoremove& operator =(const amc::FFnoremove &rhs) = delete;
    // func:amc.FFnoremove..CopyCtor
    inline               FFnoremove(const amc::FFnoremove &rhs) = delete;
private:
    // func:amc.FFnoremove..Ctor
    inline               FFnoremove() __attribute__((nothrow));
    // func:amc.FFnoremove..Dtor
    inline               ~FFnoremove() __attribute__((nothrow));
    friend amc::FFnoremove&     fnoremove_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFnoremove*     fnoremove_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fnoremove_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFnoremove.base.CopyOut
void                 fnoremove_CopyOut(amc::FFnoremove &row, dmmeta::Fnoremove &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFnoremove.base.CopyIn
void                 fnoremove_CopyIn(amc::FFnoremove &row, dmmeta::Fnoremove &in) __attribute__((nothrow));

// func:amc.FFnoremove..Uninit
void                 FFnoremove_Uninit(amc::FFnoremove& fnoremove) __attribute__((nothrow));

// --- amc.FFoutput
// create: amc.FDb.foutput (Lary)
// global access: foutput (Lary, by rowid)
// access: amc.FField.c_foutput (Ptr)
// access: amc.FNs.c_foutput (Ptrary)
struct FFoutput { // amc.FFoutput
    algo::Smallstr100   field;                 //
    bool                ns_c_foutput_in_ary;   //   false  membership flag
    // func:amc.FFoutput..AssignOp
    inline amc::FFoutput& operator =(const amc::FFoutput &rhs) = delete;
    // func:amc.FFoutput..CopyCtor
    inline               FFoutput(const amc::FFoutput &rhs) = delete;
private:
    // func:amc.FFoutput..Ctor
    inline               FFoutput() __attribute__((nothrow));
    // func:amc.FFoutput..Dtor
    inline               ~FFoutput() __attribute__((nothrow));
    friend amc::FFoutput&       foutput_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFoutput*       foutput_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 foutput_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFoutput.msghdr.CopyOut
void                 foutput_CopyOut(amc::FFoutput &row, dmmeta::Foutput &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFoutput.msghdr.CopyIn
void                 foutput_CopyIn(amc::FFoutput &row, dmmeta::Foutput &in) __attribute__((nothrow));

// func:amc.FFoutput.ns.Get
algo::Smallstr16     ns_Get(amc::FFoutput& foutput) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFoutput..Init
inline void          FFoutput_Init(amc::FFoutput& foutput);
// func:amc.FFoutput..Uninit
void                 FFoutput_Uninit(amc::FFoutput& foutput) __attribute__((nothrow));

// --- amc.FFprefix
// create: amc.FDb.fprefix (Lary)
// global access: fprefix (Lary, by rowid)
// global access: ind_prefix (Thash, hash field fprefix)
// access: amc.FReftype.zs_fprefix (Llist)
struct FFprefix { // amc.FFprefix
    amc::FFprefix*     ind_prefix_next;   // hash next
    algo::Smallstr5    fprefix;           //
    algo::Smallstr50   reftype;           //
    algo::Comment      comment;           //
    amc::FFprefix*     zs_fprefix_next;   // zslist link; -1 means not-in-list
    // func:amc.FFprefix..AssignOp
    inline amc::FFprefix& operator =(const amc::FFprefix &rhs) = delete;
    // func:amc.FFprefix..CopyCtor
    inline               FFprefix(const amc::FFprefix &rhs) = delete;
private:
    // func:amc.FFprefix..Ctor
    inline               FFprefix() __attribute__((nothrow));
    // func:amc.FFprefix..Dtor
    inline               ~FFprefix() __attribute__((nothrow));
    friend amc::FFprefix&       fprefix_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFprefix*       fprefix_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fprefix_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFprefix.base.CopyOut
void                 fprefix_CopyOut(amc::FFprefix &row, dmmeta::Fprefix &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFprefix.base.CopyIn
void                 fprefix_CopyIn(amc::FFprefix &row, dmmeta::Fprefix &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFprefix..Init
inline void          FFprefix_Init(amc::FFprefix& fprefix);
// func:amc.FFprefix..Uninit
void                 FFprefix_Uninit(amc::FFprefix& fprefix) __attribute__((nothrow));

// --- amc.FFregx
// create: amc.FDb.fregx (Lary)
// global access: fregx (Lary, by rowid)
// access: amc.FField.c_fregx (Ptr)
struct FFregx { // amc.FFregx
    algo::Smallstr100   field;      //
    bool                partial;    //   false
    algo::Smallstr50    regxtype;   //
    algo::Comment       comment;    //
    // func:amc.FFregx..AssignOp
    inline amc::FFregx&  operator =(const amc::FFregx &rhs) = delete;
    // func:amc.FFregx..CopyCtor
    inline               FFregx(const amc::FFregx &rhs) = delete;
private:
    // func:amc.FFregx..Ctor
    inline               FFregx() __attribute__((nothrow));
    // func:amc.FFregx..Dtor
    inline               ~FFregx() __attribute__((nothrow));
    friend amc::FFregx&         fregx_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFregx*         fregx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fregx_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFregx.msghdr.CopyOut
void                 fregx_CopyOut(amc::FFregx &row, dmmeta::Fregx &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFregx.msghdr.CopyIn
void                 fregx_CopyIn(amc::FFregx &row, dmmeta::Fregx &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFregx..Init
inline void          FFregx_Init(amc::FFregx& fregx);
// func:amc.FFregx..Uninit
void                 FFregx_Uninit(amc::FFregx& fregx) __attribute__((nothrow));

// --- amc.FFsort
// create: amc.FDb.fsort (Lary)
// global access: fsort (Lary, by rowid)
// access: amc.FField.c_fsort (Ptr)
struct FFsort { // amc.FFsort
    algo::Smallstr100   field;       // Field (array etc) being sorted
    algo::Smallstr50    sorttype;    // Kind of sort to generate
    algo::Smallstr100   sortfld;     // Field to sort on
    amc::FField*        p_field;     // reference to parent row
    amc::FField*        p_sortfld;   // reference to parent row
    // x-reference on amc.FFsort.p_field prevents copy
    // x-reference on amc.FFsort.p_sortfld prevents copy
    // func:amc.FFsort..AssignOp
    inline amc::FFsort&  operator =(const amc::FFsort &rhs) = delete;
    // x-reference on amc.FFsort.p_field prevents copy
    // x-reference on amc.FFsort.p_sortfld prevents copy
    // func:amc.FFsort..CopyCtor
    inline               FFsort(const amc::FFsort &rhs) = delete;
private:
    // func:amc.FFsort..Ctor
    inline               FFsort() __attribute__((nothrow));
    // func:amc.FFsort..Dtor
    inline               ~FFsort() __attribute__((nothrow));
    friend amc::FFsort&         fsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFsort*         fsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fsort_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFsort.msghdr.CopyOut
void                 fsort_CopyOut(amc::FFsort &row, dmmeta::Fsort &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFsort.msghdr.CopyIn
void                 fsort_CopyIn(amc::FFsort &row, dmmeta::Fsort &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFsort..Init
inline void          FFsort_Init(amc::FFsort& fsort);
// func:amc.FFsort..Uninit
void                 FFsort_Uninit(amc::FFsort& fsort) __attribute__((nothrow));

// --- amc.FFstep
// create: amc.FDb.fstep (Lary)
// global access: fstep (Lary, by rowid)
// global access: ind_fstep (Thash, hash field fstep)
// access: amc.FField.c_fstep (Ptr)
// access: amc.FNs.c_fstep (Ptrary)
struct FFstep { // amc.FFstep
    amc::FFstep*        ind_fstep_next;      // hash next
    algo::Smallstr100   fstep;               //
    algo::Smallstr50    steptype;            //
    algo::Comment       comment;             //
    amc::FFdelay*       c_fdelay;            // optional pointer
    amc::FField*        p_field;             // reference to parent row
    bool                ns_c_fstep_in_ary;   //   false  membership flag
    // x-reference on amc.FFstep.c_fdelay prevents copy
    // x-reference on amc.FFstep.p_field prevents copy
    // func:amc.FFstep..AssignOp
    amc::FFstep&         operator =(const amc::FFstep &rhs) = delete;
    // x-reference on amc.FFstep.c_fdelay prevents copy
    // x-reference on amc.FFstep.p_field prevents copy
    // func:amc.FFstep..CopyCtor
    FFstep(const amc::FFstep &rhs) = delete;
private:
    // func:amc.FFstep..Ctor
    inline               FFstep() __attribute__((nothrow));
    // func:amc.FFstep..Dtor
    inline               ~FFstep() __attribute__((nothrow));
    friend amc::FFstep&         fstep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFstep*         fstep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fstep_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFstep.msghdr.CopyOut
void                 fstep_CopyOut(amc::FFstep &row, dmmeta::Fstep &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFstep.msghdr.CopyIn
void                 fstep_CopyIn(amc::FFstep &row, dmmeta::Fstep &in) __attribute__((nothrow));

// func:amc.FFstep.field.Get
algo::Smallstr100    field_Get(amc::FFstep& fstep) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFstep.ns.Get
algo::Smallstr16     ns_Get(amc::FFstep& fstep) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFstep.name.Get
algo::Smallstr50     name_Get(amc::FFstep& fstep) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FFstep.c_fdelay.InsertMaybe
inline bool          c_fdelay_InsertMaybe(amc::FFstep& fstep, amc::FFdelay& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FFstep.c_fdelay.Remove
inline void          c_fdelay_Remove(amc::FFstep& fstep, amc::FFdelay& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFstep..Init
inline void          FFstep_Init(amc::FFstep& fstep);
// func:amc.FFstep..Uninit
void                 FFstep_Uninit(amc::FFstep& fstep) __attribute__((nothrow));

// --- amc.FFtrace
// create: amc.FDb.ftrace (Lary)
// global access: ftrace (Lary, by rowid)
// access: amc.FField.c_ftrace (Ptr)
struct FFtrace { // amc.FFtrace
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:amc.FFtrace..AssignOp
    inline amc::FFtrace& operator =(const amc::FFtrace &rhs) = delete;
    // func:amc.FFtrace..CopyCtor
    inline               FFtrace(const amc::FFtrace &rhs) = delete;
private:
    // func:amc.FFtrace..Ctor
    inline               FFtrace() __attribute__((nothrow));
    // func:amc.FFtrace..Dtor
    inline               ~FFtrace() __attribute__((nothrow));
    friend amc::FFtrace&        ftrace_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFtrace*        ftrace_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ftrace_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFtrace.base.CopyOut
void                 ftrace_CopyOut(amc::FFtrace &row, dmmeta::Ftrace &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFtrace.base.CopyIn
void                 ftrace_CopyIn(amc::FFtrace &row, dmmeta::Ftrace &in) __attribute__((nothrow));

// func:amc.FFtrace..Uninit
void                 FFtrace_Uninit(amc::FFtrace& ftrace) __attribute__((nothrow));

// --- amc.FFunc
// create: amc.FDb.func (Lary)
// global access: func (Lary, by rowid)
// global access: ind_func (Thash, hash field func)
// global access: cd_temp_func (Llist)
// access: amc.FCtype.c_init (Ptr)
// access: amc.FCtype.c_ffunc (Ptrary)
// access: amc.FFcmap.c_convfunc (Ptr)
// access: amc.FField.c_ffunc (Ptrary)
// access: amc.FNs.c_func (Ptrary)
// access: amc.Genpnew.p_func (Upptr)
struct FFunc { // amc.FFunc
    amc::FFunc*         ind_func_next;       // hash next
    amc::FFunc*         cd_temp_func_next;   // zslist link; -1 means not-in-list
    amc::FFunc*         cd_temp_func_prev;   // previous element
    algo::Smallstr100   func;                // Primary key
    bool                inl;                 //   false  Make inline?
    algo::cstring       proto;               // Prototype
    algo::cstring       body;                // Body of function
    bool                deprecate;           //   false  Make deprecated?
    bool                ismacro;             //   false  Always inline.
    bool                extrn;               //   false  Implemented externally by user
    bool                glob;                //   false  Function is not attached to a field (EXPLAIN!!)
    bool                priv;                //   false  Private to translateion unit (static)
    algo::cstring       ret;                 // Return type (c++ expression)
    algo::cstring       comment;             // Description
    amc::FNs*           p_ns;                // reference to parent row
    algo::cstring       nonnull;             // List of non-null attributes
    amc::Funcarg*       funcarg_elems;       // pointer to elements
    u32                 funcarg_n;           // number of elements in array
    u32                 funcarg_max;         // max. capacity of array before realloc
    bool                printed;             //   false  Already printed? (internal)
    bool                throws;              //   false  Throws exceptions
    bool                nothrow;             //   false  Definitely doesn't throw exception
    bool                member;              //   false  Function is a member (print inside struct)
    bool                disable;             //   false  Function is enabled (if not, don't print)
    bool                oper;                //   false  Is operator?
    bool                globns;              //   false  Place function outside of namespace when printing
    bool                isalloc;             //   false  Function returns a new value
    bool                wur;                 //   false  Warn on unused result
    bool                pure;                //   false  OK to call fewer times than specified in text
    bool                finalized;           //   false  Don't add any more code to me
    bool                isexplicit;          //   false  Is explicit constructor (add 'explicit')
    bool                istmpl;              //   false  Function is a template
    algo::cstring       prepcond;            // Preprocessor #if condition
    bool                ns_c_func_in_ary;    //   false  membership flag
    // x-reference on amc.FFunc.p_ns prevents copy
    // func:amc.FFunc..AssignOp
    amc::FFunc&          operator =(const amc::FFunc &rhs) = delete;
    // x-reference on amc.FFunc.p_ns prevents copy
    // func:amc.FFunc..CopyCtor
    FFunc(const amc::FFunc &rhs) = delete;
private:
    // func:amc.FFunc..Ctor
    inline               FFunc() __attribute__((nothrow));
    // func:amc.FFunc..Dtor
    inline               ~FFunc() __attribute__((nothrow));
    friend amc::FFunc&          func_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFunc*          func_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 func_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFunc.msghdr.CopyOut
void                 func_CopyOut(amc::FFunc &row, dmmeta::Func &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFunc.msghdr.CopyIn
void                 func_CopyIn(amc::FFunc &row, dmmeta::Func &in) __attribute__((nothrow));

// func:amc.FFunc.field.Get
algo::Smallstr100    field_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFunc.name.Get
algo::Smallstr50     name_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFunc.ctype.Get
algo::Smallstr100    ctype_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFunc.ns.Get
algo::Smallstr16     ns_Get(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:amc.FFunc.funcarg.Addary
algo::aryptr<amc::Funcarg> funcarg_Addary(amc::FFunc& func, algo::aryptr<amc::Funcarg> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:amc.FFunc.funcarg.Alloc
amc::Funcarg&        funcarg_Alloc(amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:amc.FFunc.funcarg.AllocAt
amc::Funcarg&        funcarg_AllocAt(amc::FFunc& func, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:amc.FFunc.funcarg.AllocN
algo::aryptr<amc::Funcarg> funcarg_AllocN(amc::FFunc& func, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FFunc.funcarg.EmptyQ
inline bool          funcarg_EmptyQ(amc::FFunc& func) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FFunc.funcarg.Find
inline amc::Funcarg* funcarg_Find(amc::FFunc& func, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:amc.FFunc.funcarg.Getary
inline algo::aryptr<amc::Funcarg> funcarg_Getary(const amc::FFunc& func) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FFunc.funcarg.Last
inline amc::Funcarg* funcarg_Last(amc::FFunc& func) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:amc.FFunc.funcarg.Max
inline i32           funcarg_Max(amc::FFunc& func) __attribute__((nothrow));
// Return number of items in the array
// func:amc.FFunc.funcarg.N
inline i32           funcarg_N(const amc::FFunc& func) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:amc.FFunc.funcarg.Remove
void                 funcarg_Remove(amc::FFunc& func, u32 i) __attribute__((nothrow));
// func:amc.FFunc.funcarg.RemoveAll
void                 funcarg_RemoveAll(amc::FFunc& func) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FFunc.funcarg.RemoveLast
void                 funcarg_RemoveLast(amc::FFunc& func) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:amc.FFunc.funcarg.Reserve
inline void          funcarg_Reserve(amc::FFunc& func, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:amc.FFunc.funcarg.AbsReserve
void                 funcarg_AbsReserve(amc::FFunc& func, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:amc.FFunc.funcarg.Setary
void                 funcarg_Setary(amc::FFunc& func, amc::FFunc &rhs) __attribute__((nothrow));
// Copy specified array into funcarg, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:amc.FFunc.funcarg.Setary2
void                 funcarg_Setary(amc::FFunc& func, const algo::aryptr<amc::Funcarg> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FFunc.funcarg.qFind
inline amc::Funcarg& funcarg_qFind(amc::FFunc& func, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:amc.FFunc.funcarg.qLast
inline amc::Funcarg& funcarg_qLast(amc::FFunc& func) __attribute__((nothrow));
// Return row id of specified element
// func:amc.FFunc.funcarg.rowid_Get
inline u64           funcarg_rowid_Get(amc::FFunc& func, amc::Funcarg &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:amc.FFunc.funcarg.AllocNVal
algo::aryptr<amc::Funcarg> funcarg_AllocNVal(amc::FFunc& func, int n_elems, const amc::Funcarg& val) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FFunc..Init
void                 FFunc_Init(amc::FFunc& func);
// proceed to next item
// func:amc.FFunc.funcarg_curs.Next
inline void          func_funcarg_curs_Next(func_funcarg_curs &curs) __attribute__((nothrow));
// func:amc.FFunc.funcarg_curs.Reset
inline void          func_funcarg_curs_Reset(func_funcarg_curs &curs, amc::FFunc &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FFunc.funcarg_curs.ValidQ
inline bool          func_funcarg_curs_ValidQ(func_funcarg_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FFunc.funcarg_curs.Access
inline amc::Funcarg& func_funcarg_curs_Access(func_funcarg_curs &curs) __attribute__((nothrow));
// func:amc.FFunc..Uninit
void                 FFunc_Uninit(amc::FFunc& func) __attribute__((nothrow));

// --- amc.FFunique
// create: amc.FDb.funique (Lary)
// global access: funique (Lary, by rowid)
// access: amc.FField.c_funique (Ptr)
struct FFunique { // amc.FFunique
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:amc.FFunique..AssignOp
    inline amc::FFunique& operator =(const amc::FFunique &rhs) = delete;
    // func:amc.FFunique..CopyCtor
    inline               FFunique(const amc::FFunique &rhs) = delete;
private:
    // func:amc.FFunique..Ctor
    inline               FFunique() __attribute__((nothrow));
    // func:amc.FFunique..Dtor
    inline               ~FFunique() __attribute__((nothrow));
    friend amc::FFunique&       funique_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFunique*       funique_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 funique_RemoveAll() __attribute__((nothrow));
    friend void                 funique_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFunique.base.CopyOut
void                 funique_CopyOut(amc::FFunique &row, dmmeta::Funique &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFunique.base.CopyIn
void                 funique_CopyIn(amc::FFunique &row, dmmeta::Funique &in) __attribute__((nothrow));

// func:amc.FFunique..Uninit
void                 FFunique_Uninit(amc::FFunique& funique) __attribute__((nothrow));

// --- amc.FFuserinit
// create: amc.FDb.fuserinit (Lary)
// global access: fuserinit (Lary, by rowid)
// access: amc.FField.c_fuserinit (Ptr)
struct FFuserinit { // amc.FFuserinit
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    // func:amc.FFuserinit..AssignOp
    inline amc::FFuserinit& operator =(const amc::FFuserinit &rhs) = delete;
    // func:amc.FFuserinit..CopyCtor
    inline               FFuserinit(const amc::FFuserinit &rhs) = delete;
private:
    // func:amc.FFuserinit..Ctor
    inline               FFuserinit() __attribute__((nothrow));
    // func:amc.FFuserinit..Dtor
    inline               ~FFuserinit() __attribute__((nothrow));
    friend amc::FFuserinit&     fuserinit_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFuserinit*     fuserinit_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fuserinit_RemoveAll() __attribute__((nothrow));
    friend void                 fuserinit_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFuserinit.base.CopyOut
void                 fuserinit_CopyOut(amc::FFuserinit &row, dmmeta::Fuserinit &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFuserinit.base.CopyIn
void                 fuserinit_CopyIn(amc::FFuserinit &row, dmmeta::Fuserinit &in) __attribute__((nothrow));

// func:amc.FFuserinit..Uninit
void                 FFuserinit_Uninit(amc::FFuserinit& fuserinit) __attribute__((nothrow));

// --- amc.FFwddecl
// create: amc.FDb.fwddecl (Lary)
// global access: fwddecl (Lary, by rowid)
// global access: ind_fwddecl (Thash, hash field fwddecl)
// access: amc.FNs.c_fwddecl (Ptrary)
struct FFwddecl { // amc.FFwddecl
    amc::FFwddecl*      ind_fwddecl_next;      // hash next
    algo::Smallstr100   fwddecl;               //
    bool                ns_c_fwddecl_in_ary;   //   false  membership flag
    // func:amc.FFwddecl..AssignOp
    inline amc::FFwddecl& operator =(const amc::FFwddecl &rhs) = delete;
    // func:amc.FFwddecl..CopyCtor
    inline               FFwddecl(const amc::FFwddecl &rhs) = delete;
private:
    // func:amc.FFwddecl..Ctor
    inline               FFwddecl() __attribute__((nothrow));
    // func:amc.FFwddecl..Dtor
    inline               ~FFwddecl() __attribute__((nothrow));
    friend amc::FFwddecl&       fwddecl_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FFwddecl*       fwddecl_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fwddecl_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FFwddecl.msghdr.CopyOut
void                 fwddecl_CopyOut(amc::FFwddecl &row, dmmeta::Fwddecl &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FFwddecl.msghdr.CopyIn
void                 fwddecl_CopyIn(amc::FFwddecl &row, dmmeta::Fwddecl &in) __attribute__((nothrow));

// func:amc.FFwddecl.ns.Get
algo::Smallstr16     ns_Get(amc::FFwddecl& fwddecl) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FFwddecl.ctype.Get
algo::Smallstr100    ctype_Get(amc::FFwddecl& fwddecl) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FFwddecl..Init
inline void          FFwddecl_Init(amc::FFwddecl& fwddecl);
// func:amc.FFwddecl..Uninit
void                 FFwddecl_Uninit(amc::FFwddecl& fwddecl) __attribute__((nothrow));

// --- amc.FGconst
// create: amc.FDb.gconst (Lary)
// global access: gconst (Lary, by rowid)
// access: amc.FField.c_gconst (Ptr)
struct FGconst { // amc.FGconst
    algo::Smallstr100   field;       // Field with which to associate constants
    algo::Smallstr100   namefld;     // Field which gives the name of the constant
    algo::Smallstr100   idfld;       // Optional attribute of namefld that gives numeric ID for gconst
    bool                wantenum;    //   true
    amc::FField*        p_namefld;   // reference to parent row
    amc::FField*        p_field;     // reference to parent row
    // x-reference on amc.FGconst.p_namefld prevents copy
    // x-reference on amc.FGconst.p_field prevents copy
    // func:amc.FGconst..AssignOp
    inline amc::FGconst& operator =(const amc::FGconst &rhs) = delete;
    // x-reference on amc.FGconst.p_namefld prevents copy
    // x-reference on amc.FGconst.p_field prevents copy
    // func:amc.FGconst..CopyCtor
    inline               FGconst(const amc::FGconst &rhs) = delete;
private:
    // func:amc.FGconst..Ctor
    inline               FGconst() __attribute__((nothrow));
    // func:amc.FGconst..Dtor
    inline               ~FGconst() __attribute__((nothrow));
    friend amc::FGconst&        gconst_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGconst*        gconst_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gconst_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FGconst.msghdr.CopyOut
void                 gconst_CopyOut(amc::FGconst &row, dmmeta::Gconst &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FGconst.msghdr.CopyIn
void                 gconst_CopyIn(amc::FGconst &row, dmmeta::Gconst &in) __attribute__((nothrow));

// func:amc.FGconst.namefldctyp.Get
algo::Smallstr100    namefldctyp_Get(amc::FGconst& gconst) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FGconst..Init
inline void          FGconst_Init(amc::FGconst& gconst);
// func:amc.FGconst..Uninit
void                 FGconst_Uninit(amc::FGconst& gconst) __attribute__((nothrow));

// --- amc.FGen
// create: amc.FDb.gen (Lary)
// global access: gen (Lary, by rowid)
// global access: zs_gen_perns (Llist)
struct FGen { // amc.FGen
    amc::FGen*           zs_gen_perns_next;   // zslist link; -1 means not-in-list
    algo::Smallstr50     gen;                 //
    bool                 perns;               //   false
    algo::Comment        comment;             //
    u64                  cycle_total;         //   0
    amc::gen_step_hook   step;                //   NULL  Pointer to a function
    // reftype Hook of amc.FGen.step prohibits copy
    // func:amc.FGen..AssignOp
    inline amc::FGen&    operator =(const amc::FGen &rhs) = delete;
    // reftype Hook of amc.FGen.step prohibits copy
    // func:amc.FGen..CopyCtor
    inline               FGen(const amc::FGen &rhs) = delete;
private:
    // func:amc.FGen..Ctor
    inline               FGen() __attribute__((nothrow));
    // func:amc.FGen..Dtor
    inline               ~FGen() __attribute__((nothrow));
    friend amc::FGen&           gen_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGen*           gen_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gen_RemoveAll() __attribute__((nothrow));
    friend void                 gen_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FGen.msghdr.CopyOut
void                 gen_CopyOut(amc::FGen &row, amcdb::Gen &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FGen.msghdr.CopyIn
void                 gen_CopyIn(amc::FGen &row, amcdb::Gen &in) __attribute__((nothrow));

// Invoke function by pointer
// func:amc.FGen.step.Call
inline void          step_Call(amc::FGen& gen) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FGen..Init
inline void          FGen_Init(amc::FGen& gen);
// func:amc.FGen..Uninit
void                 FGen_Uninit(amc::FGen& gen) __attribute__((nothrow));

// --- amc.FGenXref
struct FGenXref { // amc.FGenXref
    amc::FGenXrefSeen**   ind_seen_buckets_elems;   // pointer to bucket array
    i32                   ind_seen_buckets_n;       // number of elements in bucket array
    i32                   ind_seen_n;               // number of elements in the hash table
    amc::FGenXrefSeen*    seen_lary[32];            // level array
    i32                   seen_n;                   // number of elements in array
    // func:amc.FGenXref..Ctor
    inline               FGenXref() __attribute__((nothrow));
    // func:amc.FGenXref..Dtor
    inline               ~FGenXref() __attribute__((nothrow));
};

// Return true if hash is empty
// func:amc.FGenXref.ind_seen.EmptyQ
inline bool          ind_seen_EmptyQ(amc::FGenXref& parent) __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:amc.FGenXref.ind_seen.Find
amc::FGenXrefSeen*   ind_seen_Find(amc::FGenXref& parent, const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Return number of items in the hash
// func:amc.FGenXref.ind_seen.N
inline i32           ind_seen_N(const amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:amc.FGenXref.ind_seen.InsertMaybe
bool                 ind_seen_InsertMaybe(amc::FGenXref& parent, amc::FGenXrefSeen& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:amc.FGenXref.ind_seen.Remove
void                 ind_seen_Remove(amc::FGenXref& parent, amc::FGenXrefSeen& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:amc.FGenXref.ind_seen.Reserve
void                 ind_seen_Reserve(amc::FGenXref& parent, int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:amc.FGenXref.seen.Alloc
amc::FGenXrefSeen&   seen_Alloc(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:amc.FGenXref.seen.AllocMaybe
amc::FGenXrefSeen*   seen_AllocMaybe(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
// Allocate space for one element. If no memory available, return NULL.
// func:amc.FGenXref.seen.AllocMem
void*                seen_AllocMem(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FGenXref.seen.EmptyQ
inline bool          seen_EmptyQ(amc::FGenXref& parent) __attribute__((nothrow, pure));
// Look up row by row id. Return NULL if out of range
// func:amc.FGenXref.seen.Find
inline amc::FGenXrefSeen* seen_Find(amc::FGenXref& parent, u64 t) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FGenXref.seen.Last
inline amc::FGenXrefSeen* seen_Last(amc::FGenXref& parent) __attribute__((nothrow, pure));
// Return number of items in the pool
// func:amc.FGenXref.seen.N
inline i32           seen_N(const amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
// func:amc.FGenXref.seen.RemoveAll
void                 seen_RemoveAll(amc::FGenXref& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FGenXref.seen.RemoveLast
void                 seen_RemoveLast(amc::FGenXref& parent) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FGenXref.seen.qFind
inline amc::FGenXrefSeen& seen_qFind(amc::FGenXref& parent, u64 t) __attribute__((nothrow, pure));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:amc.FGenXref.seen.XrefMaybe
bool                 seen_XrefMaybe(amc::FGenXrefSeen &row);

// cursor points to valid item
// func:amc.FGenXref.seen_curs.Reset
inline void          FGenXref_seen_curs_Reset(FGenXref_seen_curs &curs, amc::FGenXref &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FGenXref.seen_curs.ValidQ
inline bool          FGenXref_seen_curs_ValidQ(FGenXref_seen_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FGenXref.seen_curs.Next
inline void          FGenXref_seen_curs_Next(FGenXref_seen_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FGenXref.seen_curs.Access
inline amc::FGenXrefSeen& FGenXref_seen_curs_Access(FGenXref_seen_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.FGenXref..Init
void                 FGenXref_Init(amc::FGenXref& parent);
// func:amc.FGenXref..Uninit
void                 FGenXref_Uninit(amc::FGenXref& parent) __attribute__((nothrow));

// --- amc.FGenXrefSeen
// create: amc.FGenXref.seen (Lary)
// access: amc.FGenXref.ind_seen (Thash)
struct FGenXrefSeen { // amc.FGenXrefSeen
    amc::FGenXrefSeen*   ind_seen_next;   // hash next
    algo::cstring        value;           //
    algo::Smallstr100    via;             // Saved via
    algo::Smallstr100    xreffld;         // Saved xreffld
private:
    // func:amc.FGenXrefSeen..Ctor
    inline               FGenXrefSeen() __attribute__((nothrow));
    friend amc::FGenXrefSeen&   seen_Alloc(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGenXrefSeen*   seen_AllocMaybe(amc::FGenXref& parent) __attribute__((__warn_unused_result__, nothrow));
    friend void                 seen_RemoveAll(amc::FGenXref& parent) __attribute__((nothrow));
    friend void                 seen_RemoveLast(amc::FGenXref& parent) __attribute__((nothrow));
};

// Set all fields to initial values.
// func:amc.FGenXrefSeen..Init
inline void          FGenXrefSeen_Init(amc::FGenXrefSeen& seen);

// --- amc.FGstatic
// create: amc.FDb.gstatic (Lary)
// global access: gstatic (Lary, by rowid)
// access: amc.FField.c_gstatic (Ptr)
// access: amc.FNs.c_gstatic (Ptrary)
struct FGstatic { // amc.FGstatic
    algo::Smallstr100   field;                 //
    amc::FField*        p_field;               // reference to parent row
    u32                 rowid;                 //   0
    bool                ns_c_gstatic_in_ary;   //   false  membership flag
    // x-reference on amc.FGstatic.p_field prevents copy
    // func:amc.FGstatic..AssignOp
    inline amc::FGstatic& operator =(const amc::FGstatic &rhs) = delete;
    // x-reference on amc.FGstatic.p_field prevents copy
    // func:amc.FGstatic..CopyCtor
    inline               FGstatic(const amc::FGstatic &rhs) = delete;
private:
    // func:amc.FGstatic..Ctor
    inline               FGstatic() __attribute__((nothrow));
    // func:amc.FGstatic..Dtor
    inline               ~FGstatic() __attribute__((nothrow));
    friend amc::FGstatic&       gstatic_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGstatic*       gstatic_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gstatic_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FGstatic.msghdr.CopyOut
void                 gstatic_CopyOut(amc::FGstatic &row, dmmeta::Gstatic &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FGstatic.msghdr.CopyIn
void                 gstatic_CopyIn(amc::FGstatic &row, dmmeta::Gstatic &in) __attribute__((nothrow));

// func:amc.FGstatic.ns.Get
algo::Smallstr16     ns_Get(amc::FGstatic& gstatic) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FGstatic..Init
inline void          FGstatic_Init(amc::FGstatic& gstatic);
// func:amc.FGstatic..Uninit
void                 FGstatic_Uninit(amc::FGstatic& gstatic) __attribute__((nothrow));

// --- amc.FGsymbol
// create: amc.FDb.gsymbol (Lary)
// global access: gsymbol (Lary, by rowid)
// access: amc.FNs.c_gsymbol (Ptrary)
struct FGsymbol { // amc.FGsymbol
    algo::Smallstr50    gsymbol;               //
    algo::Smallstr100   inc;                   // Regex to filter rows
    algo::Smallstr100   symboltype;            //
    algo::Comment       comment;               //
    amc::FSsimfile*     p_ssimfile;            // reference to parent row
    amc::FCtype*        p_symboltype;          // reference to parent row
    bool                ns_c_gsymbol_in_ary;   //   false  membership flag
    // x-reference on amc.FGsymbol.p_ssimfile prevents copy
    // x-reference on amc.FGsymbol.p_symboltype prevents copy
    // func:amc.FGsymbol..AssignOp
    amc::FGsymbol&       operator =(const amc::FGsymbol &rhs) = delete;
    // x-reference on amc.FGsymbol.p_ssimfile prevents copy
    // x-reference on amc.FGsymbol.p_symboltype prevents copy
    // func:amc.FGsymbol..CopyCtor
    FGsymbol(const amc::FGsymbol &rhs) = delete;
private:
    // func:amc.FGsymbol..Ctor
    inline               FGsymbol() __attribute__((nothrow));
    // func:amc.FGsymbol..Dtor
    inline               ~FGsymbol() __attribute__((nothrow));
    friend amc::FGsymbol&       gsymbol_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FGsymbol*       gsymbol_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 gsymbol_RemoveAll() __attribute__((nothrow));
    friend void                 gsymbol_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FGsymbol.base.CopyOut
void                 gsymbol_CopyOut(amc::FGsymbol &row, dmmeta::Gsymbol &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FGsymbol.base.CopyIn
void                 gsymbol_CopyIn(amc::FGsymbol &row, dmmeta::Gsymbol &in) __attribute__((nothrow));

// func:amc.FGsymbol.ns.Get
algo::Smallstr16     ns_Get(amc::FGsymbol& gsymbol) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FGsymbol.ssimfile.Get
algo::Smallstr50     ssimfile_Get(amc::FGsymbol& gsymbol) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FGsymbol..Init
inline void          FGsymbol_Init(amc::FGsymbol& gsymbol);
// func:amc.FGsymbol..Uninit
void                 FGsymbol_Uninit(amc::FGsymbol& gsymbol) __attribute__((nothrow));

// --- amc.FHook
// create: amc.FDb.hook (Lary)
// global access: hook (Lary, by rowid)
// access: amc.FField.c_hook (Ptr)
struct FHook { // amc.FHook
    algo::Smallstr100   field;       // The field
    algo::Comment       comment;     //
    amc::FCtype*        p_funcptr;   // reference to parent row
    amc::FField*        p_field;     // reference to parent row
    // x-reference on amc.FHook.p_field prevents copy
    // func:amc.FHook..AssignOp
    inline amc::FHook&   operator =(const amc::FHook &rhs) = delete;
    // x-reference on amc.FHook.p_field prevents copy
    // func:amc.FHook..CopyCtor
    inline               FHook(const amc::FHook &rhs) = delete;
private:
    // func:amc.FHook..Ctor
    inline               FHook() __attribute__((nothrow));
    // func:amc.FHook..Dtor
    inline               ~FHook() __attribute__((nothrow));
    friend amc::FHook&          hook_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FHook*          hook_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 hook_RemoveAll() __attribute__((nothrow));
    friend void                 hook_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FHook.base.CopyOut
void                 hook_CopyOut(amc::FHook &row, dmmeta::Hook &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FHook.base.CopyIn
void                 hook_CopyIn(amc::FHook &row, dmmeta::Hook &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FHook..Init
inline void          FHook_Init(amc::FHook& hook);
// func:amc.FHook..Uninit
void                 FHook_Uninit(amc::FHook& hook) __attribute__((nothrow));

// --- amc.FInlary
// create: amc.FDb.inlary (Lary)
// global access: inlary (Lary, by rowid)
// global access: ind_inlary (Thash, hash field field)
// access: amc.FField.c_inlary (Ptr)
struct FInlary { // amc.FInlary
    amc::FInlary*       ind_inlary_next;   // hash next
    algo::Smallstr100   field;             //
    i32                 min;               //   0  Min. elements to preallocate
    i32                 max;               //   0  Max. elements
    algo::Comment       comment;           //
    // func:amc.FInlary..AssignOp
    inline amc::FInlary& operator =(const amc::FInlary &rhs) = delete;
    // func:amc.FInlary..CopyCtor
    inline               FInlary(const amc::FInlary &rhs) = delete;
private:
    // func:amc.FInlary..Ctor
    inline               FInlary() __attribute__((nothrow));
    // func:amc.FInlary..Dtor
    inline               ~FInlary() __attribute__((nothrow));
    friend amc::FInlary&        inlary_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FInlary*        inlary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 inlary_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FInlary.msghdr.CopyOut
void                 inlary_CopyOut(amc::FInlary &row, dmmeta::Inlary &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FInlary.msghdr.CopyIn
void                 inlary_CopyIn(amc::FInlary &row, dmmeta::Inlary &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FInlary..Init
inline void          FInlary_Init(amc::FInlary& inlary);
// func:amc.FInlary..Uninit
void                 FInlary_Uninit(amc::FInlary& inlary) __attribute__((nothrow));

// --- amc.FLenfld
// create: amc.FDb.lenfld (Lary)
// global access: lenfld (Lary, by rowid)
// access: amc.FCtype.c_lenfld (Ptr)
struct FLenfld { // amc.FLenfld
    algo::Smallstr100   field;     // Name of length field
    i32                 extra;     //   0  Extra #bytes to add
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FLenfld.p_field prevents copy
    // func:amc.FLenfld..AssignOp
    inline amc::FLenfld& operator =(const amc::FLenfld &rhs) = delete;
    // x-reference on amc.FLenfld.p_field prevents copy
    // func:amc.FLenfld..CopyCtor
    inline               FLenfld(const amc::FLenfld &rhs) = delete;
private:
    // func:amc.FLenfld..Ctor
    inline               FLenfld() __attribute__((nothrow));
    // func:amc.FLenfld..Dtor
    inline               ~FLenfld() __attribute__((nothrow));
    friend amc::FLenfld&        lenfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FLenfld*        lenfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 lenfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FLenfld.msghdr.CopyOut
void                 lenfld_CopyOut(amc::FLenfld &row, dmmeta::Lenfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FLenfld.msghdr.CopyIn
void                 lenfld_CopyIn(amc::FLenfld &row, dmmeta::Lenfld &in) __attribute__((nothrow));

// func:amc.FLenfld.ctype.Get
algo::Smallstr100    ctype_Get(amc::FLenfld& lenfld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FLenfld..Init
inline void          FLenfld_Init(amc::FLenfld& lenfld);
// func:amc.FLenfld..Uninit
void                 FLenfld_Uninit(amc::FLenfld& lenfld) __attribute__((nothrow));

// --- amc.FLicense
// create: amc.FDb.license (Lary)
// global access: license (Lary, by rowid)
// global access: ind_license (Thash, hash field license)
// access: amc.FNs.p_license (Upptr)
struct FLicense { // amc.FLicense
    amc::FLicense*     ind_license_next;   // hash next
    algo::Smallstr50   license;            //
    algo::Comment      comment;            //
    algo::cstring      text;               //
    // func:amc.FLicense..AssignOp
    inline amc::FLicense& operator =(const amc::FLicense &rhs) = delete;
    // func:amc.FLicense..CopyCtor
    inline               FLicense(const amc::FLicense &rhs) = delete;
private:
    // func:amc.FLicense..Ctor
    inline               FLicense() __attribute__((nothrow));
    // func:amc.FLicense..Dtor
    inline               ~FLicense() __attribute__((nothrow));
    friend amc::FLicense&       license_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FLicense*       license_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 license_RemoveAll() __attribute__((nothrow));
    friend void                 license_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FLicense.base.CopyOut
void                 license_CopyOut(amc::FLicense &row, dev::License &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FLicense.base.CopyIn
void                 license_CopyIn(amc::FLicense &row, dev::License &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FLicense..Init
inline void          FLicense_Init(amc::FLicense& license);
// func:amc.FLicense..Uninit
void                 FLicense_Uninit(amc::FLicense& license) __attribute__((nothrow));

// --- amc.FListtype
// create: amc.FDb.listtype (Lary)
// global access: listtype (Lary, by rowid)
// global access: ind_listtype (Thash, hash field listtype)
// access: amc.FLlist.p_listtype (Upptr)
struct FListtype { // amc.FListtype
    amc::FListtype*   ind_listtype_next;   // hash next
    algo::Smallstr5   listtype;            //
    bool              circular;            //   false  Circular list
    bool              haveprev;            //   false  Previous link
    bool              instail;             //   false  Queue
    // func:amc.FListtype..AssignOp
    inline amc::FListtype& operator =(const amc::FListtype &rhs) = delete;
    // func:amc.FListtype..CopyCtor
    inline               FListtype(const amc::FListtype &rhs) = delete;
private:
    // func:amc.FListtype..Ctor
    inline               FListtype() __attribute__((nothrow));
    // func:amc.FListtype..Dtor
    inline               ~FListtype() __attribute__((nothrow));
    friend amc::FListtype&      listtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FListtype*      listtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 listtype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FListtype.msghdr.CopyOut
void                 listtype_CopyOut(amc::FListtype &row, dmmeta::Listtype &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FListtype.msghdr.CopyIn
void                 listtype_CopyIn(amc::FListtype &row, dmmeta::Listtype &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FListtype..Init
inline void          FListtype_Init(amc::FListtype& listtype);
// func:amc.FListtype..Uninit
void                 FListtype_Uninit(amc::FListtype& listtype) __attribute__((nothrow));

// --- amc.FLlist
// create: amc.FDb.llist (Lary)
// global access: llist (Lary, by rowid)
// access: amc.FField.c_llist (Ptr)
struct FLlist { // amc.FLlist
    algo::Smallstr100   field;        // Index in question
    bool                havetail;     //   true  Generate 'tail' field
    bool                havecount;    //   false  Generate count of elements
    amc::FListtype*     p_listtype;   // reference to parent row
    // x-reference on amc.FLlist.p_listtype prevents copy
    // func:amc.FLlist..AssignOp
    inline amc::FLlist&  operator =(const amc::FLlist &rhs) = delete;
    // x-reference on amc.FLlist.p_listtype prevents copy
    // func:amc.FLlist..CopyCtor
    inline               FLlist(const amc::FLlist &rhs) = delete;
private:
    // func:amc.FLlist..Ctor
    inline               FLlist() __attribute__((nothrow));
    // func:amc.FLlist..Dtor
    inline               ~FLlist() __attribute__((nothrow));
    friend amc::FLlist&         llist_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FLlist*         llist_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 llist_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FLlist.msghdr.CopyOut
void                 llist_CopyOut(amc::FLlist &row, dmmeta::Llist &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FLlist.msghdr.CopyIn
void                 llist_CopyIn(amc::FLlist &row, dmmeta::Llist &in) __attribute__((nothrow));

// func:amc.FLlist.listtype.Get
algo::Smallstr5      listtype_Get(amc::FLlist& llist) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FLlist..Init
inline void          FLlist_Init(amc::FLlist& llist);
// func:amc.FLlist..Uninit
void                 FLlist_Uninit(amc::FLlist& llist) __attribute__((nothrow));

// --- amc.FMain
// create: amc.FDb.main (Lary)
// global access: main (Lary, by rowid)
// global access: ind_main (Thash, hash field ns)
// access: amc.FNs.c_main (Ptr)
struct FMain { // amc.FMain
    amc::FMain*        ind_main_next;   // hash next
    algo::Smallstr16   ns;              //
    bool               ismodule;        //   false
    // func:amc.FMain..AssignOp
    inline amc::FMain&   operator =(const amc::FMain &rhs) = delete;
    // func:amc.FMain..CopyCtor
    inline               FMain(const amc::FMain &rhs) = delete;
private:
    // func:amc.FMain..Ctor
    inline               FMain() __attribute__((nothrow));
    // func:amc.FMain..Dtor
    inline               ~FMain() __attribute__((nothrow));
    friend amc::FMain&          main_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FMain*          main_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 main_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FMain.msghdr.CopyOut
void                 main_CopyOut(amc::FMain &row, dmmeta::Main &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FMain.msghdr.CopyIn
void                 main_CopyIn(amc::FMain &row, dmmeta::Main &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FMain..Init
inline void          FMain_Init(amc::FMain& main);
// func:amc.FMain..Uninit
void                 FMain_Uninit(amc::FMain& main) __attribute__((nothrow));

// --- amc.FMsgtype
// create: amc.FDb.msgtype (Lary)
// global access: msgtype (Lary, by rowid)
// access: amc.FCtype.c_msgtype (Ptr)
struct FMsgtype { // amc.FMsgtype
    algo::Smallstr100   ctype;     //
    algo::CppExpr       type;      //
    amc::FCtype*        p_ctype;   // reference to parent row
    // x-reference on amc.FMsgtype.p_ctype prevents copy
    // func:amc.FMsgtype..AssignOp
    inline amc::FMsgtype& operator =(const amc::FMsgtype &rhs) = delete;
    // x-reference on amc.FMsgtype.p_ctype prevents copy
    // func:amc.FMsgtype..CopyCtor
    inline               FMsgtype(const amc::FMsgtype &rhs) = delete;
private:
    // func:amc.FMsgtype..Ctor
    inline               FMsgtype() __attribute__((nothrow));
    // func:amc.FMsgtype..Dtor
    inline               ~FMsgtype() __attribute__((nothrow));
    friend amc::FMsgtype&       msgtype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FMsgtype*       msgtype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 msgtype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FMsgtype.msghdr.CopyOut
void                 msgtype_CopyOut(amc::FMsgtype &row, dmmeta::Msgtype &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FMsgtype.msghdr.CopyIn
void                 msgtype_CopyIn(amc::FMsgtype &row, dmmeta::Msgtype &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FMsgtype..Init
inline void          FMsgtype_Init(amc::FMsgtype& msgtype);
// func:amc.FMsgtype..Uninit
void                 FMsgtype_Uninit(amc::FMsgtype& msgtype) __attribute__((nothrow));

// --- amc.FNocascdel
// create: amc.FDb.nocascdel (Lary)
// global access: nocascdel (Lary, by rowid)
// access: amc.FXref.c_nocascdel (Ptr)
struct FNocascdel { // amc.FNocascdel
    algo::Smallstr100   xref;   //
    // func:amc.FNocascdel..AssignOp
    inline amc::FNocascdel& operator =(const amc::FNocascdel &rhs) = delete;
    // func:amc.FNocascdel..CopyCtor
    inline               FNocascdel(const amc::FNocascdel &rhs) = delete;
private:
    // func:amc.FNocascdel..Ctor
    inline               FNocascdel() __attribute__((nothrow));
    // func:amc.FNocascdel..Dtor
    inline               ~FNocascdel() __attribute__((nothrow));
    friend amc::FNocascdel&     nocascdel_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNocascdel*     nocascdel_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nocascdel_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNocascdel.msghdr.CopyOut
void                 nocascdel_CopyOut(amc::FNocascdel &row, dmmeta::Nocascdel &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNocascdel.msghdr.CopyIn
void                 nocascdel_CopyIn(amc::FNocascdel &row, dmmeta::Nocascdel &in) __attribute__((nothrow));

// func:amc.FNocascdel..Uninit
void                 FNocascdel_Uninit(amc::FNocascdel& nocascdel) __attribute__((nothrow));

// --- amc.FNossimfile
// create: amc.FDb.nossimfile (Lary)
// global access: nossimfile (Lary, by rowid)
// access: amc.FCtype.c_nossimfile (Ptr)
struct FNossimfile { // amc.FNossimfile
    algo::Smallstr100   ctype;     //
    algo::Comment       comment;   //
    // func:amc.FNossimfile..AssignOp
    inline amc::FNossimfile& operator =(const amc::FNossimfile &rhs) = delete;
    // func:amc.FNossimfile..CopyCtor
    inline               FNossimfile(const amc::FNossimfile &rhs) = delete;
private:
    // func:amc.FNossimfile..Ctor
    inline               FNossimfile() __attribute__((nothrow));
    // func:amc.FNossimfile..Dtor
    inline               ~FNossimfile() __attribute__((nothrow));
    friend amc::FNossimfile&    nossimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNossimfile*    nossimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nossimfile_RemoveAll() __attribute__((nothrow));
    friend void                 nossimfile_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNossimfile.base.CopyOut
void                 nossimfile_CopyOut(amc::FNossimfile &row, dmmeta::Nossimfile &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNossimfile.base.CopyIn
void                 nossimfile_CopyIn(amc::FNossimfile &row, dmmeta::Nossimfile &in) __attribute__((nothrow));

// func:amc.FNossimfile..Uninit
void                 FNossimfile_Uninit(amc::FNossimfile& nossimfile) __attribute__((nothrow));

// --- amc.FNoxref
// create: amc.FDb.noxref (Lary)
// global access: noxref (Lary, by rowid)
// access: amc.FField.c_noxref (Ptr)
struct FNoxref { // amc.FNoxref
    algo::Smallstr100   field;   //
    // func:amc.FNoxref..AssignOp
    inline amc::FNoxref& operator =(const amc::FNoxref &rhs) = delete;
    // func:amc.FNoxref..CopyCtor
    inline               FNoxref(const amc::FNoxref &rhs) = delete;
private:
    // func:amc.FNoxref..Ctor
    inline               FNoxref() __attribute__((nothrow));
    // func:amc.FNoxref..Dtor
    inline               ~FNoxref() __attribute__((nothrow));
    friend amc::FNoxref&        noxref_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNoxref*        noxref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 noxref_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNoxref.msghdr.CopyOut
void                 noxref_CopyOut(amc::FNoxref &row, dmmeta::Noxref &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNoxref.msghdr.CopyIn
void                 noxref_CopyIn(amc::FNoxref &row, dmmeta::Noxref &in) __attribute__((nothrow));

// func:amc.FNoxref..Uninit
void                 FNoxref_Uninit(amc::FNoxref& noxref) __attribute__((nothrow));

// --- amc.FNs
// create: amc.FDb.ns (Lary)
// global access: ns (Lary, by rowid)
// global access: ind_ns (Thash, hash field ns)
// global access: c_ns_sorted (Ptrary)
// global access: c_curns (Ptr)
// global access: c_ns (Ptr)
// access: amc.FCtype.p_ns (Upptr)
// access: amc.FDispatch.p_ns (Upptr)
// access: amc.FFcmdline.p_ns (Upptr)
// access: amc.FFunc.p_ns (Upptr)
// access: amc.FNs.c_parentns (Ptrary)
// access: amc.FNs.c_cppincl (Ptrary)
// access: amc.FNs.c_hdrincl (Ptrary)
// access: amc.FOutfile.p_ns (Upptr)
// access: amc.FPnew.p_ns (Upptr)
// access: amc.FTarget.p_ns (Upptr)
// access: amc.Genctx.p_ns (Upptr)
struct FNs { // amc.FNs
    amc::FNs*           ind_ns_next;         // hash next
    algo::Smallstr16    ns;                  // Namespace name (primary key)
    algo::Smallstr50    nstype;              // Namespace type
    algo::Smallstr50    license;             // Associated license
    algo::Comment       comment;             //
    i32                 nhash;               //   0  number of hash functions generated (hack)
    algo::cstring       curstext;            //
    amc::FCtype**       c_ctype_elems;       // array of pointers
    u32                 c_ctype_n;           // array of pointers
    u32                 c_ctype_max;         // capacity of allocated array
    amc::FFunc**        c_func_elems;        // array of pointers
    u32                 c_func_n;            // array of pointers
    u32                 c_func_max;          // capacity of allocated array
    amc::FDispatch**    c_dispatch_elems;    // array of pointers
    u32                 c_dispatch_n;        // array of pointers
    u32                 c_dispatch_max;      // capacity of allocated array
    amc::FField*        c_globfld;           // optional pointer
    amc::FGstatic**     c_gstatic_elems;     // array of pointers
    u32                 c_gstatic_n;         // array of pointers
    u32                 c_gstatic_max;       // capacity of allocated array
    amc::FMain*         c_main;              // optional pointer
    algo::cstring*      hdr;                 // Temporary hack -- pointer to hdr contents. optional pointer
    algo::cstring*      inl;                 // optional pointer
    algo::cstring*      cpp;                 // optional pointer
    algo::cstring*      include_elems;       // pointer to elements
    u32                 include_n;           // number of elements in array
    u32                 include_max;         // max. capacity of array before realloc
    algo::Sha1sig       signature;           //
    algo::Sha1sig       signature_input;     //
    amc::FDispsig**     c_dispsig_elems;     // array of pointers
    u32                 c_dispsig_n;         // array of pointers
    u32                 c_dispsig_max;       // capacity of allocated array
    amc::FNs**          c_parentns_elems;    // array of pointers
    u32                 c_parentns_n;        // array of pointers
    u32                 c_parentns_max;      // capacity of allocated array
    amc::FNs**          c_cppincl_elems;     // array of pointers
    u32                 c_cppincl_n;         // array of pointers
    u32                 c_cppincl_max;       // capacity of allocated array
    amc::FNs**          c_hdrincl_elems;     // array of pointers
    u32                 c_hdrincl_n;         // array of pointers
    u32                 c_hdrincl_max;       // capacity of allocated array
    amc::FFwddecl**     c_fwddecl_elems;     // array of pointers
    u32                 c_fwddecl_n;         // array of pointers
    u32                 c_fwddecl_max;       // capacity of allocated array
    bool                select;              //   false
    amc::FNsx*          c_nsx;               // optional pointer
    amc::FTarget*       c_target;            // optional pointer
    amc::FPnew**        c_pnew_elems;        // array of pointers
    u32                 c_pnew_n;            // array of pointers
    u32                 c_pnew_max;          // capacity of allocated array
    amc::FFcmdline*     c_fcmdline;          // optional pointer
    amc::FNsproto*      c_nsproto;           // optional pointer
    amc::FNsdb*         c_nsdb;              // optional pointer
    amc::FOutfile**     c_outfile_elems;     // array of pointers
    u32                 c_outfile_n;         // array of pointers
    u32                 c_outfile_max;       // capacity of allocated array
    amc::FFoutput**     c_foutput_elems;     // array of pointers
    u32                 c_foutput_n;         // array of pointers
    u32                 c_foutput_max;       // capacity of allocated array
    amc::FFstep**       c_fstep_elems;       // array of pointers
    u32                 c_fstep_n;           // array of pointers
    u32                 c_fstep_max;         // capacity of allocated array
    amc::FGsymbol**     c_gsymbol_elems;     // array of pointers
    u32                 c_gsymbol_n;         // array of pointers
    u32                 c_gsymbol_max;       // capacity of allocated array
    amc::FNsinclude**   c_nsinclude_elems;   // array of pointers
    u32                 c_nsinclude_n;       // array of pointers
    u32                 c_nsinclude_max;     // capacity of allocated array
    amc::FNscpp*        c_nscpp;             // optional pointer
    amc::FLicense*      p_license;           // reference to parent row
    // reftype Ptrary of amc.FNs.c_ctype prohibits copy
    // reftype Ptrary of amc.FNs.c_func prohibits copy
    // reftype Ptrary of amc.FNs.c_dispatch prohibits copy
    // x-reference on amc.FNs.c_globfld prevents copy
    // reftype Ptrary of amc.FNs.c_gstatic prohibits copy
    // x-reference on amc.FNs.c_main prevents copy
    // reftype Ptrary of amc.FNs.c_dispsig prohibits copy
    // reftype Ptrary of amc.FNs.c_parentns prohibits copy
    // reftype Ptrary of amc.FNs.c_cppincl prohibits copy
    // reftype Ptrary of amc.FNs.c_hdrincl prohibits copy
    // reftype Ptrary of amc.FNs.c_fwddecl prohibits copy
    // x-reference on amc.FNs.c_nsx prevents copy
    // x-reference on amc.FNs.c_target prevents copy
    // reftype Ptrary of amc.FNs.c_pnew prohibits copy
    // x-reference on amc.FNs.c_fcmdline prevents copy
    // x-reference on amc.FNs.c_nsproto prevents copy
    // x-reference on amc.FNs.c_nsdb prevents copy
    // reftype Ptrary of amc.FNs.c_outfile prohibits copy
    // reftype Ptrary of amc.FNs.c_foutput prohibits copy
    // reftype Ptrary of amc.FNs.c_fstep prohibits copy
    // reftype Ptrary of amc.FNs.c_gsymbol prohibits copy
    // reftype Ptrary of amc.FNs.c_nsinclude prohibits copy
    // x-reference on amc.FNs.c_nscpp prevents copy
    // x-reference on amc.FNs.p_license prevents copy
    // func:amc.FNs..AssignOp
    amc::FNs&            operator =(const amc::FNs &rhs) = delete;
    // reftype Ptrary of amc.FNs.c_ctype prohibits copy
    // reftype Ptrary of amc.FNs.c_func prohibits copy
    // reftype Ptrary of amc.FNs.c_dispatch prohibits copy
    // x-reference on amc.FNs.c_globfld prevents copy
    // reftype Ptrary of amc.FNs.c_gstatic prohibits copy
    // x-reference on amc.FNs.c_main prevents copy
    // reftype Ptrary of amc.FNs.c_dispsig prohibits copy
    // reftype Ptrary of amc.FNs.c_parentns prohibits copy
    // reftype Ptrary of amc.FNs.c_cppincl prohibits copy
    // reftype Ptrary of amc.FNs.c_hdrincl prohibits copy
    // reftype Ptrary of amc.FNs.c_fwddecl prohibits copy
    // x-reference on amc.FNs.c_nsx prevents copy
    // x-reference on amc.FNs.c_target prevents copy
    // reftype Ptrary of amc.FNs.c_pnew prohibits copy
    // x-reference on amc.FNs.c_fcmdline prevents copy
    // x-reference on amc.FNs.c_nsproto prevents copy
    // x-reference on amc.FNs.c_nsdb prevents copy
    // reftype Ptrary of amc.FNs.c_outfile prohibits copy
    // reftype Ptrary of amc.FNs.c_foutput prohibits copy
    // reftype Ptrary of amc.FNs.c_fstep prohibits copy
    // reftype Ptrary of amc.FNs.c_gsymbol prohibits copy
    // reftype Ptrary of amc.FNs.c_nsinclude prohibits copy
    // x-reference on amc.FNs.c_nscpp prevents copy
    // x-reference on amc.FNs.p_license prevents copy
    // func:amc.FNs..CopyCtor
    FNs(const amc::FNs &rhs) = delete;
private:
    // func:amc.FNs..Ctor
    inline               FNs() __attribute__((nothrow));
    // func:amc.FNs..Dtor
    inline               ~FNs() __attribute__((nothrow));
    friend amc::FNs&            ns_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNs*            ns_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ns_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNs.msghdr.CopyOut
void                 ns_CopyOut(amc::FNs &row, dmmeta::Ns &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNs.msghdr.CopyIn
void                 ns_CopyIn(amc::FNs &row, dmmeta::Ns &in) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_ctype.EmptyQ
inline bool          c_ctype_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_ctype.Find
inline amc::FCtype*  c_ctype_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_ctype.Getary
inline algo::aryptr<amc::FCtype*> c_ctype_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_ctype.Insert
void                 c_ctype_Insert(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_ctype.InsertMaybe
bool                 c_ctype_InsertMaybe(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_ctype.N
inline i32           c_ctype_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_ctype.Remove
void                 c_ctype_Remove(amc::FNs& ns, amc::FCtype& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_ctype.RemoveAll
inline void          c_ctype_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_ctype.Reserve
void                 c_ctype_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_ctype.qFind
inline amc::FCtype&  c_ctype_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_ctype.InAryQ
inline bool          ns_c_ctype_InAryQ(amc::FCtype& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_ctype.qLast
inline amc::FCtype&  c_ctype_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_func.EmptyQ
inline bool          c_func_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_func.Find
inline amc::FFunc*   c_func_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_func.Getary
inline algo::aryptr<amc::FFunc*> c_func_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_func.Insert
void                 c_func_Insert(amc::FNs& ns, amc::FFunc& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_func.InsertMaybe
bool                 c_func_InsertMaybe(amc::FNs& ns, amc::FFunc& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_func.N
inline i32           c_func_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_func.Remove
void                 c_func_Remove(amc::FNs& ns, amc::FFunc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_func.RemoveAll
inline void          c_func_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_func.Reserve
void                 c_func_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_func.qFind
inline amc::FFunc&   c_func_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_func.InAryQ
inline bool          ns_c_func_InAryQ(amc::FFunc& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_func.qLast
inline amc::FFunc&   c_func_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_dispatch.EmptyQ
inline bool          c_dispatch_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_dispatch.Find
inline amc::FDispatch* c_dispatch_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_dispatch.Getary
inline algo::aryptr<amc::FDispatch*> c_dispatch_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_dispatch.Insert
void                 c_dispatch_Insert(amc::FNs& ns, amc::FDispatch& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_dispatch.InsertMaybe
bool                 c_dispatch_InsertMaybe(amc::FNs& ns, amc::FDispatch& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_dispatch.N
inline i32           c_dispatch_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_dispatch.Remove
void                 c_dispatch_Remove(amc::FNs& ns, amc::FDispatch& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_dispatch.RemoveAll
inline void          c_dispatch_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_dispatch.Reserve
void                 c_dispatch_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_dispatch.qFind
inline amc::FDispatch& c_dispatch_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_dispatch.InAryQ
inline bool          ns_c_dispatch_InAryQ(amc::FDispatch& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_dispatch.qLast
inline amc::FDispatch& c_dispatch_qLast(amc::FNs& ns) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_globfld.InsertMaybe
inline bool          c_globfld_InsertMaybe(amc::FNs& ns, amc::FField& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_globfld.Remove
inline void          c_globfld_Remove(amc::FNs& ns, amc::FField& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_gstatic.EmptyQ
inline bool          c_gstatic_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_gstatic.Find
inline amc::FGstatic* c_gstatic_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_gstatic.Getary
inline algo::aryptr<amc::FGstatic*> c_gstatic_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_gstatic.Insert
void                 c_gstatic_Insert(amc::FNs& ns, amc::FGstatic& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_gstatic.InsertMaybe
bool                 c_gstatic_InsertMaybe(amc::FNs& ns, amc::FGstatic& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_gstatic.N
inline i32           c_gstatic_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_gstatic.Remove
void                 c_gstatic_Remove(amc::FNs& ns, amc::FGstatic& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_gstatic.RemoveAll
inline void          c_gstatic_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_gstatic.Reserve
void                 c_gstatic_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_gstatic.qFind
inline amc::FGstatic& c_gstatic_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_gstatic.InAryQ
inline bool          ns_c_gstatic_InAryQ(amc::FGstatic& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_gstatic.qLast
inline amc::FGstatic& c_gstatic_qLast(amc::FNs& ns) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_main.InsertMaybe
inline bool          c_main_InsertMaybe(amc::FNs& ns, amc::FMain& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_main.Remove
inline void          c_main_Remove(amc::FNs& ns, amc::FMain& row) __attribute__((nothrow));

// Reserve space (this may move memory). Insert N element at the end.
// Return aryptr to newly inserted block.
// If the RHS argument aliases the array (refers to the same memory), exit program with fatal error.
// func:amc.FNs.include.Addary
algo::aryptr<algo::cstring> include_Addary(amc::FNs& ns, algo::aryptr<algo::cstring> rhs) __attribute__((nothrow));
// Reserve space. Insert element at the end
// The new element is initialized to a default value
// func:amc.FNs.include.Alloc
algo::cstring&       include_Alloc(amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
// func:amc.FNs.include.AllocAt
algo::cstring&       include_AllocAt(amc::FNs& ns, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:amc.FNs.include.AllocN
algo::aryptr<algo::cstring> include_AllocN(amc::FNs& ns, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
// func:amc.FNs.include.EmptyQ
inline bool          include_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.include.Find
inline algo::cstring* include_Find(amc::FNs& ns, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
// func:amc.FNs.include.Getary
inline algo::aryptr<algo::cstring> include_Getary(const amc::FNs& ns) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
// func:amc.FNs.include.Last
inline algo::cstring* include_Last(amc::FNs& ns) __attribute__((nothrow, pure));
// Return max. number of items in the array
// func:amc.FNs.include.Max
inline i32           include_Max(amc::FNs& ns) __attribute__((nothrow));
// Return number of items in the array
// func:amc.FNs.include.N
inline i32           include_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
// func:amc.FNs.include.Remove
void                 include_Remove(amc::FNs& ns, u32 i) __attribute__((nothrow));
// func:amc.FNs.include.RemoveAll
void                 include_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
// func:amc.FNs.include.RemoveLast
void                 include_RemoveLast(amc::FNs& ns) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
// func:amc.FNs.include.Reserve
inline void          include_Reserve(amc::FNs& ns, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
// func:amc.FNs.include.AbsReserve
void                 include_AbsReserve(amc::FNs& ns, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
// func:amc.FNs.include.Setary
void                 include_Setary(amc::FNs& ns, amc::FNs &rhs) __attribute__((nothrow));
// Copy specified array into include, discarding previous contents.
// If the RHS argument aliases the array (refers to the same memory), throw exception.
// func:amc.FNs.include.Setary2
void                 include_Setary(amc::FNs& ns, const algo::aryptr<algo::cstring> &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
// func:amc.FNs.include.qFind
inline algo::cstring& include_qFind(amc::FNs& ns, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
// func:amc.FNs.include.qLast
inline algo::cstring& include_qLast(amc::FNs& ns) __attribute__((nothrow));
// Return row id of specified element
// func:amc.FNs.include.rowid_Get
inline u64           include_rowid_Get(amc::FNs& ns, algo::cstring &elem) __attribute__((nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
// func:amc.FNs.include.AllocNVal
algo::aryptr<algo::cstring> include_AllocNVal(amc::FNs& ns, int n_elems, const algo::cstring& val) __attribute__((nothrow));
// A single element is read from input string and appended to the array.
// If the string contains an error, the array is untouched.
// Function returns success value.
// func:amc.FNs.include.ReadStrptrMaybe
bool                 include_ReadStrptrMaybe(amc::FNs& ns, algo::strptr in_str) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_dispsig.EmptyQ
inline bool          c_dispsig_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_dispsig.Find
inline amc::FDispsig* c_dispsig_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_dispsig.Getary
inline algo::aryptr<amc::FDispsig*> c_dispsig_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_dispsig.Insert
void                 c_dispsig_Insert(amc::FNs& ns, amc::FDispsig& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_dispsig.InsertMaybe
bool                 c_dispsig_InsertMaybe(amc::FNs& ns, amc::FDispsig& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_dispsig.N
inline i32           c_dispsig_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_dispsig.Remove
void                 c_dispsig_Remove(amc::FNs& ns, amc::FDispsig& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_dispsig.RemoveAll
inline void          c_dispsig_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_dispsig.Reserve
void                 c_dispsig_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_dispsig.qFind
inline amc::FDispsig& c_dispsig_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_dispsig.InAryQ
inline bool          ns_c_dispsig_InAryQ(amc::FDispsig& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_dispsig.qLast
inline amc::FDispsig& c_dispsig_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_parentns.EmptyQ
inline bool          c_parentns_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_parentns.Find
inline amc::FNs*     c_parentns_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_parentns.Getary
inline algo::aryptr<amc::FNs*> c_parentns_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_parentns.Insert
void                 c_parentns_Insert(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_parentns.ScanInsertMaybe
bool                 c_parentns_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_parentns.N
inline i32           c_parentns_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_parentns.Remove
void                 c_parentns_Remove(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_parentns.RemoveAll
inline void          c_parentns_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_parentns.Reserve
void                 c_parentns_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_parentns.qFind
inline amc::FNs&     c_parentns_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_parentns.qLast
inline amc::FNs&     c_parentns_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_cppincl.EmptyQ
inline bool          c_cppincl_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_cppincl.Find
inline amc::FNs*     c_cppincl_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_cppincl.Getary
inline algo::aryptr<amc::FNs*> c_cppincl_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_cppincl.Insert
void                 c_cppincl_Insert(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_cppincl.ScanInsertMaybe
bool                 c_cppincl_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_cppincl.N
inline i32           c_cppincl_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_cppincl.Remove
void                 c_cppincl_Remove(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_cppincl.RemoveAll
inline void          c_cppincl_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_cppincl.Reserve
void                 c_cppincl_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_cppincl.qFind
inline amc::FNs&     c_cppincl_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_cppincl.qLast
inline amc::FNs&     c_cppincl_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_hdrincl.EmptyQ
inline bool          c_hdrincl_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_hdrincl.Find
inline amc::FNs*     c_hdrincl_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_hdrincl.Getary
inline algo::aryptr<amc::FNs*> c_hdrincl_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_hdrincl.Insert
void                 c_hdrincl_Insert(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Linear search is used to locate the element.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_hdrincl.ScanInsertMaybe
bool                 c_hdrincl_ScanInsertMaybe(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_hdrincl.N
inline i32           c_hdrincl_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_hdrincl.Remove
void                 c_hdrincl_Remove(amc::FNs& ns, amc::FNs& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_hdrincl.RemoveAll
inline void          c_hdrincl_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_hdrincl.Reserve
void                 c_hdrincl_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_hdrincl.qFind
inline amc::FNs&     c_hdrincl_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_hdrincl.qLast
inline amc::FNs&     c_hdrincl_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_fwddecl.EmptyQ
inline bool          c_fwddecl_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_fwddecl.Find
inline amc::FFwddecl* c_fwddecl_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_fwddecl.Getary
inline algo::aryptr<amc::FFwddecl*> c_fwddecl_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_fwddecl.Insert
void                 c_fwddecl_Insert(amc::FNs& ns, amc::FFwddecl& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_fwddecl.InsertMaybe
bool                 c_fwddecl_InsertMaybe(amc::FNs& ns, amc::FFwddecl& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_fwddecl.N
inline i32           c_fwddecl_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_fwddecl.Remove
void                 c_fwddecl_Remove(amc::FNs& ns, amc::FFwddecl& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_fwddecl.RemoveAll
inline void          c_fwddecl_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_fwddecl.Reserve
void                 c_fwddecl_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_fwddecl.qFind
inline amc::FFwddecl& c_fwddecl_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_fwddecl.InAryQ
inline bool          ns_c_fwddecl_InAryQ(amc::FFwddecl& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_fwddecl.qLast
inline amc::FFwddecl& c_fwddecl_qLast(amc::FNs& ns) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_nsx.InsertMaybe
inline bool          c_nsx_InsertMaybe(amc::FNs& ns, amc::FNsx& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_nsx.Remove
inline void          c_nsx_Remove(amc::FNs& ns, amc::FNsx& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_target.InsertMaybe
inline bool          c_target_InsertMaybe(amc::FNs& ns, amc::FTarget& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_target.Remove
inline void          c_target_Remove(amc::FNs& ns, amc::FTarget& row) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_pnew.EmptyQ
inline bool          c_pnew_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_pnew.Find
inline amc::FPnew*   c_pnew_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_pnew.Getary
inline algo::aryptr<amc::FPnew*> c_pnew_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_pnew.Insert
void                 c_pnew_Insert(amc::FNs& ns, amc::FPnew& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_pnew.InsertMaybe
bool                 c_pnew_InsertMaybe(amc::FNs& ns, amc::FPnew& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_pnew.N
inline i32           c_pnew_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_pnew.Remove
void                 c_pnew_Remove(amc::FNs& ns, amc::FPnew& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_pnew.RemoveAll
inline void          c_pnew_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_pnew.Reserve
void                 c_pnew_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_pnew.qFind
inline amc::FPnew&   c_pnew_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_pnew.InAryQ
inline bool          ns_c_pnew_InAryQ(amc::FPnew& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_pnew.qLast
inline amc::FPnew&   c_pnew_qLast(amc::FNs& ns) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_fcmdline.InsertMaybe
inline bool          c_fcmdline_InsertMaybe(amc::FNs& ns, amc::FFcmdline& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_fcmdline.Remove
inline void          c_fcmdline_Remove(amc::FNs& ns, amc::FFcmdline& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_nsproto.InsertMaybe
inline bool          c_nsproto_InsertMaybe(amc::FNs& ns, amc::FNsproto& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_nsproto.Remove
inline void          c_nsproto_Remove(amc::FNs& ns, amc::FNsproto& row) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_nsdb.InsertMaybe
inline bool          c_nsdb_InsertMaybe(amc::FNs& ns, amc::FNsdb& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_nsdb.Remove
inline void          c_nsdb_Remove(amc::FNs& ns, amc::FNsdb& row) __attribute__((nothrow));

// Delete all elements pointed to by the index.
// func:amc.FNs.c_outfile.Cascdel
void                 c_outfile_Cascdel(amc::FNs& ns) __attribute__((nothrow));
// Return true if index is empty
// func:amc.FNs.c_outfile.EmptyQ
inline bool          c_outfile_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_outfile.Find
inline amc::FOutfile* c_outfile_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_outfile.Getary
inline algo::aryptr<amc::FOutfile*> c_outfile_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_outfile.Insert
void                 c_outfile_Insert(amc::FNs& ns, amc::FOutfile& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_outfile.InsertMaybe
bool                 c_outfile_InsertMaybe(amc::FNs& ns, amc::FOutfile& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_outfile.N
inline i32           c_outfile_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_outfile.Remove
void                 c_outfile_Remove(amc::FNs& ns, amc::FOutfile& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_outfile.RemoveAll
inline void          c_outfile_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_outfile.Reserve
void                 c_outfile_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_outfile.qFind
inline amc::FOutfile& c_outfile_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_outfile.InAryQ
inline bool          ns_c_outfile_InAryQ(amc::FOutfile& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_outfile.qLast
inline amc::FOutfile& c_outfile_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_foutput.EmptyQ
inline bool          c_foutput_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_foutput.Find
inline amc::FFoutput* c_foutput_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_foutput.Getary
inline algo::aryptr<amc::FFoutput*> c_foutput_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_foutput.Insert
void                 c_foutput_Insert(amc::FNs& ns, amc::FFoutput& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_foutput.InsertMaybe
bool                 c_foutput_InsertMaybe(amc::FNs& ns, amc::FFoutput& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_foutput.N
inline i32           c_foutput_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_foutput.Remove
void                 c_foutput_Remove(amc::FNs& ns, amc::FFoutput& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_foutput.RemoveAll
inline void          c_foutput_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_foutput.Reserve
void                 c_foutput_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_foutput.qFind
inline amc::FFoutput& c_foutput_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_foutput.InAryQ
inline bool          ns_c_foutput_InAryQ(amc::FFoutput& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_foutput.qLast
inline amc::FFoutput& c_foutput_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_fstep.EmptyQ
inline bool          c_fstep_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_fstep.Find
inline amc::FFstep*  c_fstep_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_fstep.Getary
inline algo::aryptr<amc::FFstep*> c_fstep_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_fstep.Insert
void                 c_fstep_Insert(amc::FNs& ns, amc::FFstep& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_fstep.InsertMaybe
bool                 c_fstep_InsertMaybe(amc::FNs& ns, amc::FFstep& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_fstep.N
inline i32           c_fstep_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_fstep.Remove
void                 c_fstep_Remove(amc::FNs& ns, amc::FFstep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_fstep.RemoveAll
inline void          c_fstep_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_fstep.Reserve
void                 c_fstep_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_fstep.qFind
inline amc::FFstep&  c_fstep_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_fstep.InAryQ
inline bool          ns_c_fstep_InAryQ(amc::FFstep& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_fstep.qLast
inline amc::FFstep&  c_fstep_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_gsymbol.EmptyQ
inline bool          c_gsymbol_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_gsymbol.Find
inline amc::FGsymbol* c_gsymbol_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_gsymbol.Getary
inline algo::aryptr<amc::FGsymbol*> c_gsymbol_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_gsymbol.Insert
void                 c_gsymbol_Insert(amc::FNs& ns, amc::FGsymbol& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_gsymbol.InsertMaybe
bool                 c_gsymbol_InsertMaybe(amc::FNs& ns, amc::FGsymbol& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_gsymbol.N
inline i32           c_gsymbol_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_gsymbol.Remove
void                 c_gsymbol_Remove(amc::FNs& ns, amc::FGsymbol& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_gsymbol.RemoveAll
inline void          c_gsymbol_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_gsymbol.Reserve
void                 c_gsymbol_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_gsymbol.qFind
inline amc::FGsymbol& c_gsymbol_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_gsymbol.InAryQ
inline bool          ns_c_gsymbol_InAryQ(amc::FGsymbol& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_gsymbol.qLast
inline amc::FGsymbol& c_gsymbol_qLast(amc::FNs& ns) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FNs.c_nsinclude.EmptyQ
inline bool          c_nsinclude_EmptyQ(amc::FNs& ns) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FNs.c_nsinclude.Find
inline amc::FNsinclude* c_nsinclude_Find(amc::FNs& ns, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FNs.c_nsinclude.Getary
inline algo::aryptr<amc::FNsinclude*> c_nsinclude_Getary(amc::FNs& ns) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FNs.c_nsinclude.Insert
void                 c_nsinclude_Insert(amc::FNs& ns, amc::FNsinclude& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FNs.c_nsinclude.InsertMaybe
bool                 c_nsinclude_InsertMaybe(amc::FNs& ns, amc::FNsinclude& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FNs.c_nsinclude.N
inline i32           c_nsinclude_N(const amc::FNs& ns) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FNs.c_nsinclude.Remove
void                 c_nsinclude_Remove(amc::FNs& ns, amc::FNsinclude& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FNs.c_nsinclude.RemoveAll
inline void          c_nsinclude_RemoveAll(amc::FNs& ns) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FNs.c_nsinclude.Reserve
void                 c_nsinclude_Reserve(amc::FNs& ns, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FNs.c_nsinclude.qFind
inline amc::FNsinclude& c_nsinclude_qFind(amc::FNs& ns, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FNs.c_nsinclude.InAryQ
inline bool          ns_c_nsinclude_InAryQ(amc::FNsinclude& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FNs.c_nsinclude.qLast
inline amc::FNsinclude& c_nsinclude_qLast(amc::FNs& ns) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FNs.c_nscpp.InsertMaybe
inline bool          c_nscpp_InsertMaybe(amc::FNs& ns, amc::FNscpp& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FNs.c_nscpp.Remove
inline void          c_nscpp_Remove(amc::FNs& ns, amc::FNscpp& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FNs..Init
void                 FNs_Init(amc::FNs& ns);
// func:amc.FNs.c_ctype_curs.Reset
inline void          ns_c_ctype_curs_Reset(ns_c_ctype_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_ctype_curs.ValidQ
inline bool          ns_c_ctype_curs_ValidQ(ns_c_ctype_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_ctype_curs.Next
inline void          ns_c_ctype_curs_Next(ns_c_ctype_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_ctype_curs.Access
inline amc::FCtype&  ns_c_ctype_curs_Access(ns_c_ctype_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_func_curs.Reset
inline void          ns_c_func_curs_Reset(ns_c_func_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_func_curs.ValidQ
inline bool          ns_c_func_curs_ValidQ(ns_c_func_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_func_curs.Next
inline void          ns_c_func_curs_Next(ns_c_func_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_func_curs.Access
inline amc::FFunc&   ns_c_func_curs_Access(ns_c_func_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_dispatch_curs.Reset
inline void          ns_c_dispatch_curs_Reset(ns_c_dispatch_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_dispatch_curs.ValidQ
inline bool          ns_c_dispatch_curs_ValidQ(ns_c_dispatch_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_dispatch_curs.Next
inline void          ns_c_dispatch_curs_Next(ns_c_dispatch_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_dispatch_curs.Access
inline amc::FDispatch& ns_c_dispatch_curs_Access(ns_c_dispatch_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_gstatic_curs.Reset
inline void          ns_c_gstatic_curs_Reset(ns_c_gstatic_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_gstatic_curs.ValidQ
inline bool          ns_c_gstatic_curs_ValidQ(ns_c_gstatic_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_gstatic_curs.Next
inline void          ns_c_gstatic_curs_Next(ns_c_gstatic_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_gstatic_curs.Access
inline amc::FGstatic& ns_c_gstatic_curs_Access(ns_c_gstatic_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.include_curs.Next
inline void          ns_include_curs_Next(ns_include_curs &curs) __attribute__((nothrow));
// func:amc.FNs.include_curs.Reset
inline void          ns_include_curs_Reset(ns_include_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.include_curs.ValidQ
inline bool          ns_include_curs_ValidQ(ns_include_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.include_curs.Access
inline algo::cstring& ns_include_curs_Access(ns_include_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_dispsig_curs.Reset
inline void          ns_c_dispsig_curs_Reset(ns_c_dispsig_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_dispsig_curs.ValidQ
inline bool          ns_c_dispsig_curs_ValidQ(ns_c_dispsig_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_dispsig_curs.Next
inline void          ns_c_dispsig_curs_Next(ns_c_dispsig_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_dispsig_curs.Access
inline amc::FDispsig& ns_c_dispsig_curs_Access(ns_c_dispsig_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_parentns_curs.Reset
inline void          ns_c_parentns_curs_Reset(ns_c_parentns_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_parentns_curs.ValidQ
inline bool          ns_c_parentns_curs_ValidQ(ns_c_parentns_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_parentns_curs.Next
inline void          ns_c_parentns_curs_Next(ns_c_parentns_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_parentns_curs.Access
inline amc::FNs&     ns_c_parentns_curs_Access(ns_c_parentns_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_cppincl_curs.Reset
inline void          ns_c_cppincl_curs_Reset(ns_c_cppincl_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_cppincl_curs.ValidQ
inline bool          ns_c_cppincl_curs_ValidQ(ns_c_cppincl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_cppincl_curs.Next
inline void          ns_c_cppincl_curs_Next(ns_c_cppincl_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_cppincl_curs.Access
inline amc::FNs&     ns_c_cppincl_curs_Access(ns_c_cppincl_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_hdrincl_curs.Reset
inline void          ns_c_hdrincl_curs_Reset(ns_c_hdrincl_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_hdrincl_curs.ValidQ
inline bool          ns_c_hdrincl_curs_ValidQ(ns_c_hdrincl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_hdrincl_curs.Next
inline void          ns_c_hdrincl_curs_Next(ns_c_hdrincl_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_hdrincl_curs.Access
inline amc::FNs&     ns_c_hdrincl_curs_Access(ns_c_hdrincl_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_fwddecl_curs.Reset
inline void          ns_c_fwddecl_curs_Reset(ns_c_fwddecl_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_fwddecl_curs.ValidQ
inline bool          ns_c_fwddecl_curs_ValidQ(ns_c_fwddecl_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_fwddecl_curs.Next
inline void          ns_c_fwddecl_curs_Next(ns_c_fwddecl_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_fwddecl_curs.Access
inline amc::FFwddecl& ns_c_fwddecl_curs_Access(ns_c_fwddecl_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_pnew_curs.Reset
inline void          ns_c_pnew_curs_Reset(ns_c_pnew_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_pnew_curs.ValidQ
inline bool          ns_c_pnew_curs_ValidQ(ns_c_pnew_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_pnew_curs.Next
inline void          ns_c_pnew_curs_Next(ns_c_pnew_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_pnew_curs.Access
inline amc::FPnew&   ns_c_pnew_curs_Access(ns_c_pnew_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_outfile_curs.Reset
inline void          ns_c_outfile_curs_Reset(ns_c_outfile_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_outfile_curs.ValidQ
inline bool          ns_c_outfile_curs_ValidQ(ns_c_outfile_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_outfile_curs.Next
inline void          ns_c_outfile_curs_Next(ns_c_outfile_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_outfile_curs.Access
inline amc::FOutfile& ns_c_outfile_curs_Access(ns_c_outfile_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_foutput_curs.Reset
inline void          ns_c_foutput_curs_Reset(ns_c_foutput_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_foutput_curs.ValidQ
inline bool          ns_c_foutput_curs_ValidQ(ns_c_foutput_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_foutput_curs.Next
inline void          ns_c_foutput_curs_Next(ns_c_foutput_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_foutput_curs.Access
inline amc::FFoutput& ns_c_foutput_curs_Access(ns_c_foutput_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_fstep_curs.Reset
inline void          ns_c_fstep_curs_Reset(ns_c_fstep_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_fstep_curs.ValidQ
inline bool          ns_c_fstep_curs_ValidQ(ns_c_fstep_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_fstep_curs.Next
inline void          ns_c_fstep_curs_Next(ns_c_fstep_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_fstep_curs.Access
inline amc::FFstep&  ns_c_fstep_curs_Access(ns_c_fstep_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_gsymbol_curs.Reset
inline void          ns_c_gsymbol_curs_Reset(ns_c_gsymbol_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_gsymbol_curs.ValidQ
inline bool          ns_c_gsymbol_curs_ValidQ(ns_c_gsymbol_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_gsymbol_curs.Next
inline void          ns_c_gsymbol_curs_Next(ns_c_gsymbol_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_gsymbol_curs.Access
inline amc::FGsymbol& ns_c_gsymbol_curs_Access(ns_c_gsymbol_curs &curs) __attribute__((nothrow));
// func:amc.FNs.c_nsinclude_curs.Reset
inline void          ns_c_nsinclude_curs_Reset(ns_c_nsinclude_curs &curs, amc::FNs &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FNs.c_nsinclude_curs.ValidQ
inline bool          ns_c_nsinclude_curs_ValidQ(ns_c_nsinclude_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FNs.c_nsinclude_curs.Next
inline void          ns_c_nsinclude_curs_Next(ns_c_nsinclude_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FNs.c_nsinclude_curs.Access
inline amc::FNsinclude& ns_c_nsinclude_curs_Access(ns_c_nsinclude_curs &curs) __attribute__((nothrow));
// func:amc.FNs..Uninit
void                 FNs_Uninit(amc::FNs& ns) __attribute__((nothrow));

// --- amc.FNscpp
// create: amc.FDb.nscpp (Lary)
// global access: nscpp (Lary, by rowid)
// access: amc.FNs.c_nscpp (Ptr)
struct FNscpp { // amc.FNscpp
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    // func:amc.FNscpp..AssignOp
    inline amc::FNscpp&  operator =(const amc::FNscpp &rhs) = delete;
    // func:amc.FNscpp..CopyCtor
    inline               FNscpp(const amc::FNscpp &rhs) = delete;
private:
    // func:amc.FNscpp..Ctor
    inline               FNscpp() __attribute__((nothrow));
    // func:amc.FNscpp..Dtor
    inline               ~FNscpp() __attribute__((nothrow));
    friend amc::FNscpp&         nscpp_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNscpp*         nscpp_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nscpp_RemoveAll() __attribute__((nothrow));
    friend void                 nscpp_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNscpp.base.CopyOut
void                 nscpp_CopyOut(amc::FNscpp &row, dmmeta::Nscpp &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNscpp.base.CopyIn
void                 nscpp_CopyIn(amc::FNscpp &row, dmmeta::Nscpp &in) __attribute__((nothrow));

// func:amc.FNscpp..Uninit
void                 FNscpp_Uninit(amc::FNscpp& nscpp) __attribute__((nothrow));

// --- amc.FNsdb
// create: amc.FDb.nsdb (Lary)
// global access: nsdb (Lary, by rowid)
// access: amc.FNs.c_nsdb (Ptr)
struct FNsdb { // amc.FNsdb
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    // func:amc.FNsdb..AssignOp
    inline amc::FNsdb&   operator =(const amc::FNsdb &rhs) = delete;
    // func:amc.FNsdb..CopyCtor
    inline               FNsdb(const amc::FNsdb &rhs) = delete;
private:
    // func:amc.FNsdb..Ctor
    inline               FNsdb() __attribute__((nothrow));
    // func:amc.FNsdb..Dtor
    inline               ~FNsdb() __attribute__((nothrow));
    friend amc::FNsdb&          nsdb_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsdb*          nsdb_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsdb_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNsdb.base.CopyOut
void                 nsdb_CopyOut(amc::FNsdb &row, dmmeta::Nsdb &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNsdb.base.CopyIn
void                 nsdb_CopyIn(amc::FNsdb &row, dmmeta::Nsdb &in) __attribute__((nothrow));

// func:amc.FNsdb..Uninit
void                 FNsdb_Uninit(amc::FNsdb& nsdb) __attribute__((nothrow));

// --- amc.FNsinclude
// create: amc.FDb.nsinclude (Lary)
// global access: nsinclude (Lary, by rowid)
// access: amc.FNs.c_nsinclude (Ptrary)
struct FNsinclude { // amc.FNsinclude
    algo::Smallstr50   nsinclude;               //
    bool               sys;                     //   false
    algo::Comment      comment;                 //
    bool               ns_c_nsinclude_in_ary;   //   false  membership flag
    // func:amc.FNsinclude..AssignOp
    inline amc::FNsinclude& operator =(const amc::FNsinclude &rhs) = delete;
    // func:amc.FNsinclude..CopyCtor
    inline               FNsinclude(const amc::FNsinclude &rhs) = delete;
private:
    // func:amc.FNsinclude..Ctor
    inline               FNsinclude() __attribute__((nothrow));
    // func:amc.FNsinclude..Dtor
    inline               ~FNsinclude() __attribute__((nothrow));
    friend amc::FNsinclude&     nsinclude_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsinclude*     nsinclude_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsinclude_RemoveAll() __attribute__((nothrow));
    friend void                 nsinclude_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNsinclude.base.CopyOut
void                 nsinclude_CopyOut(amc::FNsinclude &row, dmmeta::Nsinclude &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNsinclude.base.CopyIn
void                 nsinclude_CopyIn(amc::FNsinclude &row, dmmeta::Nsinclude &in) __attribute__((nothrow));

// func:amc.FNsinclude.ns.Get
algo::Smallstr16     ns_Get(amc::FNsinclude& nsinclude) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FNsinclude.name.Get
algo::Smallstr50     name_Get(amc::FNsinclude& nsinclude) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FNsinclude..Init
inline void          FNsinclude_Init(amc::FNsinclude& nsinclude);
// func:amc.FNsinclude..Uninit
void                 FNsinclude_Uninit(amc::FNsinclude& nsinclude) __attribute__((nothrow));

// --- amc.FNsproto
// create: amc.FDb.nsproto (Lary)
// global access: nsproto (Lary, by rowid)
// access: amc.FNs.c_nsproto (Ptr)
struct FNsproto { // amc.FNsproto
    algo::Smallstr16   ns;        //
    algo::Comment      comment;   //
    // func:amc.FNsproto..AssignOp
    inline amc::FNsproto& operator =(const amc::FNsproto &rhs) = delete;
    // func:amc.FNsproto..CopyCtor
    inline               FNsproto(const amc::FNsproto &rhs) = delete;
private:
    // func:amc.FNsproto..Ctor
    inline               FNsproto() __attribute__((nothrow));
    // func:amc.FNsproto..Dtor
    inline               ~FNsproto() __attribute__((nothrow));
    friend amc::FNsproto&       nsproto_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsproto*       nsproto_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsproto_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNsproto.base.CopyOut
void                 nsproto_CopyOut(amc::FNsproto &row, dmmeta::Nsproto &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNsproto.base.CopyIn
void                 nsproto_CopyIn(amc::FNsproto &row, dmmeta::Nsproto &in) __attribute__((nothrow));

// func:amc.FNsproto..Uninit
void                 FNsproto_Uninit(amc::FNsproto& nsproto) __attribute__((nothrow));

// --- amc.FNsx
// create: amc.FDb.nsx (Lary)
// global access: nsx (Lary, by rowid)
// access: amc.FNs.c_nsx (Ptr)
struct FNsx { // amc.FNsx
    algo::Smallstr16    ns;                    //
    bool                genthrow;              //   false
    bool                correct_getorcreate;   //   false
    algo::Smallstr100   pool;                  //
    bool                sortxref;              //   false
    bool                pack;                  //   false
    algo::Comment       comment;               //
    amc::FField*        p_pool;                // reference to parent row
    // x-reference on amc.FNsx.p_pool prevents copy
    // func:amc.FNsx..AssignOp
    inline amc::FNsx&    operator =(const amc::FNsx &rhs) = delete;
    // x-reference on amc.FNsx.p_pool prevents copy
    // func:amc.FNsx..CopyCtor
    inline               FNsx(const amc::FNsx &rhs) = delete;
private:
    // func:amc.FNsx..Ctor
    inline               FNsx() __attribute__((nothrow));
    // func:amc.FNsx..Dtor
    inline               ~FNsx() __attribute__((nothrow));
    friend amc::FNsx&           nsx_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNsx*           nsx_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 nsx_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNsx.base.CopyOut
void                 nsx_CopyOut(amc::FNsx &row, dmmeta::Nsx &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNsx.base.CopyIn
void                 nsx_CopyIn(amc::FNsx &row, dmmeta::Nsx &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FNsx..Init
inline void          FNsx_Init(amc::FNsx& nsx);
// func:amc.FNsx..Uninit
void                 FNsx_Uninit(amc::FNsx& nsx) __attribute__((nothrow));

// --- amc.FNumstr
// create: amc.FDb.numstr (Lary)
// global access: numstr (Lary, by rowid)
// access: amc.FSmallstr.c_numstr (Ptr)
struct FNumstr { // amc.FNumstr
    algo::Smallstr100   field;       // String type
    algo::Smallstr100   numtype;     // Corresponding numeric type
    i32                 base;        //   0  Base for conversion
    i32                 min_len;     //   0  Mininum length of string
    amc::FCtype*        p_numtype;   // reference to parent row
    u64                 nummin;      //   0
    u64                 nummax;      //   0
    bool                issigned;    //   false
    // x-reference on amc.FNumstr.p_numtype prevents copy
    // func:amc.FNumstr..AssignOp
    inline amc::FNumstr& operator =(const amc::FNumstr &rhs) = delete;
    // x-reference on amc.FNumstr.p_numtype prevents copy
    // func:amc.FNumstr..CopyCtor
    inline               FNumstr(const amc::FNumstr &rhs) = delete;
private:
    // func:amc.FNumstr..Ctor
    inline               FNumstr() __attribute__((nothrow));
    // func:amc.FNumstr..Dtor
    inline               ~FNumstr() __attribute__((nothrow));
    friend amc::FNumstr&        numstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FNumstr*        numstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 numstr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FNumstr.msghdr.CopyOut
void                 numstr_CopyOut(amc::FNumstr &row, dmmeta::Numstr &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FNumstr.msghdr.CopyIn
void                 numstr_CopyIn(amc::FNumstr &row, dmmeta::Numstr &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FNumstr..Init
inline void          FNumstr_Init(amc::FNumstr& numstr);
// func:amc.FNumstr..Uninit
void                 FNumstr_Uninit(amc::FNumstr& numstr) __attribute__((nothrow));

// --- amc.FOutfile
// create: amc.FDb.outfile (Tpool)
// access: amc.FNs.c_outfile (Ptrary)
struct FOutfile { // amc.FOutfile: AMC's output file (generated file under include/gen or cpp/gen)
    amc::FOutfile*      outfile_next;          // Pointer to next free element int tpool
    algo::cstring       text;                  //
    amc::FNs*           p_ns;                  // reference to parent row
    algo::cstring       ssim;                  // Ssim content
    algo::cstring       prev_head;             // Helper
    algo::Smallstr200   outfile;               //
    bool                ns_c_outfile_in_ary;   //   false  membership flag
    // x-reference on amc.FOutfile.p_ns prevents copy
    // func:amc.FOutfile..AssignOp
    inline amc::FOutfile& operator =(const amc::FOutfile &rhs) = delete;
    // x-reference on amc.FOutfile.p_ns prevents copy
    // func:amc.FOutfile..CopyCtor
    inline               FOutfile(const amc::FOutfile &rhs) = delete;
private:
    // func:amc.FOutfile..Ctor
    inline               FOutfile() __attribute__((nothrow));
    // func:amc.FOutfile..Dtor
    inline               ~FOutfile() __attribute__((nothrow));
    friend amc::FOutfile&       outfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FOutfile*       outfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 outfile_Delete(amc::FOutfile &row) __attribute__((nothrow));
};

// func:amc.FOutfile.ns.Get
algo::Smallstr16     ns_Get(amc::FOutfile& outfile) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FOutfile..Init
inline void          FOutfile_Init(amc::FOutfile& outfile);
// func:amc.FOutfile..Uninit
void                 FOutfile_Uninit(amc::FOutfile& outfile) __attribute__((nothrow));

// --- amc.FPack
// create: amc.FDb.pack (Lary)
// global access: pack (Lary, by rowid)
// global access: ind_pack (Thash, hash field ctype)
// access: amc.FCtype.c_pack (Ptr)
struct FPack { // amc.FPack
    amc::FPack*         ind_pack_next;   // hash next
    algo::Smallstr100   ctype;           // Target ctype
    amc::FCtype*        p_ctype;         // reference to parent row
    // x-reference on amc.FPack.p_ctype prevents copy
    // func:amc.FPack..AssignOp
    inline amc::FPack&   operator =(const amc::FPack &rhs) = delete;
    // x-reference on amc.FPack.p_ctype prevents copy
    // func:amc.FPack..CopyCtor
    inline               FPack(const amc::FPack &rhs) = delete;
private:
    // func:amc.FPack..Ctor
    inline               FPack() __attribute__((nothrow));
    // func:amc.FPack..Dtor
    inline               ~FPack() __attribute__((nothrow));
    friend amc::FPack&          pack_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPack*          pack_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pack_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FPack.msghdr.CopyOut
void                 pack_CopyOut(amc::FPack &row, dmmeta::Pack &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FPack.msghdr.CopyIn
void                 pack_CopyIn(amc::FPack &row, dmmeta::Pack &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FPack..Init
inline void          FPack_Init(amc::FPack& pack);
// func:amc.FPack..Uninit
void                 FPack_Uninit(amc::FPack& pack) __attribute__((nothrow));

// --- amc.FPmaskfld
// create: amc.FDb.pmaskfld (Lary)
// global access: pmaskfld (Lary, by rowid)
// global access: ind_pmaskfld (Thash, hash field field)
// access: amc.FCtype.c_pmaskfld (Ptrary)
// access: amc.FField.c_pmaskfld (Ptr)
// access: amc.FPmaskfldMember.p_pmaskfld (Upptr)
struct FPmaskfld { // amc.FPmaskfld
    amc::FPmaskfld*          ind_pmaskfld_next;         // hash next
    algo::Smallstr100        field;                     //
    bool                     filter_print;              //   true  Omit non-present fields when printing
    algo::Comment            comment;                   //
    amc::FField*             p_field;                   // reference to parent row
    u32                      nextbit;                   //   0  Next bit to allocate
    amc::FPmaskfldMember**   c_pmaskfld_member_elems;   // array of pointers
    u32                      c_pmaskfld_member_n;       // array of pointers
    u32                      c_pmaskfld_member_max;     // capacity of allocated array
    algo::Smallstr50         funcname;                  //
    bool                     ctype_c_pmaskfld_in_ary;   //   false  membership flag
    // x-reference on amc.FPmaskfld.p_field prevents copy
    // reftype Ptrary of amc.FPmaskfld.c_pmaskfld_member prohibits copy
    // func:amc.FPmaskfld..AssignOp
    amc::FPmaskfld&      operator =(const amc::FPmaskfld &rhs) = delete;
    // x-reference on amc.FPmaskfld.p_field prevents copy
    // reftype Ptrary of amc.FPmaskfld.c_pmaskfld_member prohibits copy
    // func:amc.FPmaskfld..CopyCtor
    FPmaskfld(const amc::FPmaskfld &rhs) = delete;
private:
    // func:amc.FPmaskfld..Ctor
    inline               FPmaskfld() __attribute__((nothrow));
    // func:amc.FPmaskfld..Dtor
    inline               ~FPmaskfld() __attribute__((nothrow));
    friend amc::FPmaskfld&      pmaskfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPmaskfld*      pmaskfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pmaskfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FPmaskfld.msghdr.CopyOut
void                 pmaskfld_CopyOut(amc::FPmaskfld &row, dmmeta::Pmaskfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FPmaskfld.msghdr.CopyIn
void                 pmaskfld_CopyIn(amc::FPmaskfld &row, dmmeta::Pmaskfld &in) __attribute__((nothrow));

// func:amc.FPmaskfld.ctype.Get
algo::Smallstr100    ctype_Get(amc::FPmaskfld& pmaskfld) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:amc.FPmaskfld.c_pmaskfld_member.EmptyQ
inline bool          c_pmaskfld_member_EmptyQ(amc::FPmaskfld& pmaskfld) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FPmaskfld.c_pmaskfld_member.Find
inline amc::FPmaskfldMember* c_pmaskfld_member_Find(amc::FPmaskfld& pmaskfld, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FPmaskfld.c_pmaskfld_member.Getary
inline algo::aryptr<amc::FPmaskfldMember*> c_pmaskfld_member_Getary(amc::FPmaskfld& pmaskfld) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FPmaskfld.c_pmaskfld_member.Insert
void                 c_pmaskfld_member_Insert(amc::FPmaskfld& pmaskfld, amc::FPmaskfldMember& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FPmaskfld.c_pmaskfld_member.InsertMaybe
bool                 c_pmaskfld_member_InsertMaybe(amc::FPmaskfld& pmaskfld, amc::FPmaskfldMember& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FPmaskfld.c_pmaskfld_member.N
inline i32           c_pmaskfld_member_N(const amc::FPmaskfld& pmaskfld) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FPmaskfld.c_pmaskfld_member.Remove
void                 c_pmaskfld_member_Remove(amc::FPmaskfld& pmaskfld, amc::FPmaskfldMember& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FPmaskfld.c_pmaskfld_member.RemoveAll
inline void          c_pmaskfld_member_RemoveAll(amc::FPmaskfld& pmaskfld) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FPmaskfld.c_pmaskfld_member.Reserve
void                 c_pmaskfld_member_Reserve(amc::FPmaskfld& pmaskfld, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FPmaskfld.c_pmaskfld_member.qFind
inline amc::FPmaskfldMember& c_pmaskfld_member_qFind(amc::FPmaskfld& pmaskfld, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FPmaskfld.c_pmaskfld_member.InAryQ
inline bool          pmaskfld_c_pmaskfld_member_InAryQ(amc::FPmaskfldMember& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FPmaskfld.c_pmaskfld_member.qLast
inline amc::FPmaskfldMember& c_pmaskfld_member_qLast(amc::FPmaskfld& pmaskfld) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FPmaskfld..Init
inline void          FPmaskfld_Init(amc::FPmaskfld& pmaskfld);
// func:amc.FPmaskfld.c_pmaskfld_member_curs.Reset
inline void          pmaskfld_c_pmaskfld_member_curs_Reset(pmaskfld_c_pmaskfld_member_curs &curs, amc::FPmaskfld &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FPmaskfld.c_pmaskfld_member_curs.ValidQ
inline bool          pmaskfld_c_pmaskfld_member_curs_ValidQ(pmaskfld_c_pmaskfld_member_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FPmaskfld.c_pmaskfld_member_curs.Next
inline void          pmaskfld_c_pmaskfld_member_curs_Next(pmaskfld_c_pmaskfld_member_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FPmaskfld.c_pmaskfld_member_curs.Access
inline amc::FPmaskfldMember& pmaskfld_c_pmaskfld_member_curs_Access(pmaskfld_c_pmaskfld_member_curs &curs) __attribute__((nothrow));
// func:amc.FPmaskfld..Uninit
void                 FPmaskfld_Uninit(amc::FPmaskfld& pmaskfld) __attribute__((nothrow));

// --- amc.FPmaskfldMember
// create: amc.FDb.pmaskfld_member (Lary)
// global access: pmaskfld_member (Lary, by rowid)
// access: amc.FField.c_pmaskfld_member (Ptrary)
// access: amc.FPmaskfld.c_pmaskfld_member (Ptrary)
struct FPmaskfldMember { // amc.FPmaskfldMember
    algo::Smallstr100   pmaskfld_member;                     //
    algo::Comment       comment;                             //
    u32                 bit;                                 //   0
    amc::FField*        p_field;                             // reference to parent row
    amc::FPmaskfld*     p_pmaskfld;                          // reference to parent row
    bool                field_c_pmaskfld_member_in_ary;      //   false  membership flag
    bool                pmaskfld_c_pmaskfld_member_in_ary;   //   false  membership flag
    // x-reference on amc.FPmaskfldMember.p_field prevents copy
    // x-reference on amc.FPmaskfldMember.p_pmaskfld prevents copy
    // func:amc.FPmaskfldMember..AssignOp
    amc::FPmaskfldMember& operator =(const amc::FPmaskfldMember &rhs) = delete;
    // x-reference on amc.FPmaskfldMember.p_field prevents copy
    // x-reference on amc.FPmaskfldMember.p_pmaskfld prevents copy
    // func:amc.FPmaskfldMember..CopyCtor
    FPmaskfldMember(const amc::FPmaskfldMember &rhs) = delete;
private:
    // func:amc.FPmaskfldMember..Ctor
    inline               FPmaskfldMember() __attribute__((nothrow));
    // func:amc.FPmaskfldMember..Dtor
    inline               ~FPmaskfldMember() __attribute__((nothrow));
    friend amc::FPmaskfldMember& pmaskfld_member_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPmaskfldMember* pmaskfld_member_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pmaskfld_member_RemoveAll() __attribute__((nothrow));
    friend void                 pmaskfld_member_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FPmaskfldMember.base.CopyOut
void                 pmaskfld_member_CopyOut(amc::FPmaskfldMember &row, dmmeta::PmaskfldMember &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FPmaskfldMember.base.CopyIn
void                 pmaskfld_member_CopyIn(amc::FPmaskfldMember &row, dmmeta::PmaskfldMember &in) __attribute__((nothrow));

// func:amc.FPmaskfldMember.pmaskfld.Get
algo::Smallstr100    pmaskfld_Get(amc::FPmaskfldMember& pmaskfld_member) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FPmaskfldMember.field.Get
algo::Smallstr100    field_Get(amc::FPmaskfldMember& pmaskfld_member) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FPmaskfldMember..Init
inline void          FPmaskfldMember_Init(amc::FPmaskfldMember& pmaskfld_member);
// func:amc.FPmaskfldMember..Uninit
void                 FPmaskfldMember_Uninit(amc::FPmaskfldMember& pmaskfld_member) __attribute__((nothrow));

// --- amc.FPnew
// create: amc.FDb.pnew (Lary)
// global access: pnew (Lary, by rowid)
// global access: ind_pnew (Thash, hash field pnew)
// access: amc.FNs.c_pnew (Ptrary)
struct FPnew { // amc.FPnew
    amc::FPnew*         ind_pnew_next;      // hash next
    algo::Smallstr100   pnew;               //
    amc::FCtype*        p_ctype;            // reference to parent row
    amc::FNs*           p_ns;               // reference to parent row
    bool                ns_c_pnew_in_ary;   //   false  membership flag
    // x-reference on amc.FPnew.p_ctype prevents copy
    // x-reference on amc.FPnew.p_ns prevents copy
    // func:amc.FPnew..AssignOp
    inline amc::FPnew&   operator =(const amc::FPnew &rhs) = delete;
    // x-reference on amc.FPnew.p_ctype prevents copy
    // x-reference on amc.FPnew.p_ns prevents copy
    // func:amc.FPnew..CopyCtor
    inline               FPnew(const amc::FPnew &rhs) = delete;
private:
    // func:amc.FPnew..Ctor
    inline               FPnew() __attribute__((nothrow));
    // func:amc.FPnew..Dtor
    inline               ~FPnew() __attribute__((nothrow));
    friend amc::FPnew&          pnew_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPnew*          pnew_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 pnew_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FPnew.msghdr.CopyOut
void                 pnew_CopyOut(amc::FPnew &row, dmmeta::Pnew &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FPnew.msghdr.CopyIn
void                 pnew_CopyIn(amc::FPnew &row, dmmeta::Pnew &in) __attribute__((nothrow));

// func:amc.FPnew.ns.Get
algo::Smallstr16     ns_Get(amc::FPnew& pnew) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FPnew.ctype.Get
algo::Smallstr100    ctype_Get(amc::FPnew& pnew) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FPnew.buftype.Get
algo::Smallstr50     buftype_Get(amc::FPnew& pnew) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FPnew..Init
inline void          FPnew_Init(amc::FPnew& pnew);
// func:amc.FPnew..Uninit
void                 FPnew_Uninit(amc::FPnew& pnew) __attribute__((nothrow));

// --- amc.FPtrary
// create: amc.FDb.ptrary (Lary)
// global access: ptrary (Lary, by rowid)
// access: amc.FField.c_ptrary (Ptr)
struct FPtrary { // amc.FPtrary
    algo::Smallstr100   field;     //
    bool                unique;    //   false  Search for and ignore duplicates
    amc::FField*        p_field;   // reference to parent row
    // x-reference on amc.FPtrary.p_field prevents copy
    // func:amc.FPtrary..AssignOp
    inline amc::FPtrary& operator =(const amc::FPtrary &rhs) = delete;
    // x-reference on amc.FPtrary.p_field prevents copy
    // func:amc.FPtrary..CopyCtor
    inline               FPtrary(const amc::FPtrary &rhs) = delete;
private:
    // func:amc.FPtrary..Ctor
    inline               FPtrary() __attribute__((nothrow));
    // func:amc.FPtrary..Dtor
    inline               ~FPtrary() __attribute__((nothrow));
    friend amc::FPtrary&        ptrary_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FPtrary*        ptrary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ptrary_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FPtrary.msghdr.CopyOut
void                 ptrary_CopyOut(amc::FPtrary &row, dmmeta::Ptrary &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FPtrary.msghdr.CopyIn
void                 ptrary_CopyIn(amc::FPtrary &row, dmmeta::Ptrary &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FPtrary..Init
inline void          FPtrary_Init(amc::FPtrary& ptrary);
// func:amc.FPtrary..Uninit
void                 FPtrary_Uninit(amc::FPtrary& ptrary) __attribute__((nothrow));

// --- amc.FReftype
// create: amc.FDb.reftype (Lary)
// global access: reftype (Lary, by rowid)
// global access: ind_reftype (Thash, hash field reftype)
// access: amc.FField.p_reftype (Upptr)
struct FReftype { // amc.FReftype
    amc::FReftype*     ind_reftype_next;   // hash next
    algo::Smallstr50   reftype;            //   "Val"
    bool               isval;              //   false  True if field makes values of target type
    bool               cascins;            //   false  Field is cascade-insert
    bool               usebasepool;        //   false  Fields with this type make use of dmmeta.basepool
    bool               cancopy;            //   false  This type of field can be copied
    bool               isxref;             //   false  This type of field is an x-ref
    bool               del;                //   false  Supports random deletion?
    bool               up;                 //   false  This type of field is a reference
    bool               isnew;              //   false  If set, skip this relation in amc_vis
    bool               hasalloc;           //   false  Generte Alloc/Delete functions for arg type
    bool               inst;               //   false  Field creates an instance of arg type (directly or indirectly)
    bool               varlen;             //   false  This pool supports varlen allocations
    i32                rowid;              //   0
    amc::FTclass*      p_tclass;           // reference to parent row
    amc::FFprefix*     zs_fprefix_head;    // zero-terminated singly linked list
    amc::FFprefix*     zs_fprefix_tail;    // pointer to last element
    // x-reference on amc.FReftype.p_tclass prevents copy
    // reftype Llist of amc.FReftype.zs_fprefix prohibits copy
    // func:amc.FReftype..AssignOp
    amc::FReftype&       operator =(const amc::FReftype &rhs) = delete;
    // x-reference on amc.FReftype.p_tclass prevents copy
    // reftype Llist of amc.FReftype.zs_fprefix prohibits copy
    // func:amc.FReftype..CopyCtor
    FReftype(const amc::FReftype &rhs) = delete;
private:
    // func:amc.FReftype..Ctor
    inline               FReftype() __attribute__((nothrow));
    // func:amc.FReftype..Dtor
    inline               ~FReftype() __attribute__((nothrow));
    friend amc::FReftype&       reftype_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FReftype*       reftype_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 reftype_RemoveAll() __attribute__((nothrow));
    friend void                 reftype_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FReftype.msghdr.CopyOut
void                 reftype_CopyOut(amc::FReftype &row, dmmeta::Reftype &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FReftype.msghdr.CopyIn
void                 reftype_CopyIn(amc::FReftype &row, dmmeta::Reftype &in) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FReftype.zs_fprefix.EmptyQ
inline bool          zs_fprefix_EmptyQ(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:amc.FReftype.zs_fprefix.First
inline amc::FFprefix* zs_fprefix_First(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:amc.FReftype.zs_fprefix.InLlistQ
inline bool          zs_fprefix_InLlistQ(amc::FFprefix& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:amc.FReftype.zs_fprefix.Insert
void                 zs_fprefix_Insert(amc::FReftype& reftype, amc::FFprefix& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:amc.FReftype.zs_fprefix.Last
inline amc::FFprefix* zs_fprefix_Last(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:amc.FReftype.zs_fprefix.Next
inline amc::FFprefix* zs_fprefix_Next(amc::FFprefix &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// Since the list is singly-linked, use linear search to locate the element.
// func:amc.FReftype.zs_fprefix.Remove
void                 zs_fprefix_Remove(amc::FReftype& reftype, amc::FFprefix& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FReftype.zs_fprefix.RemoveAll
void                 zs_fprefix_RemoveAll(amc::FReftype& reftype) __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:amc.FReftype.zs_fprefix.RemoveFirst
amc::FFprefix*       zs_fprefix_RemoveFirst(amc::FReftype& reftype) __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:amc.FReftype.zs_fprefix.qLast
inline amc::FFprefix& zs_fprefix_qLast(amc::FReftype& reftype) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FReftype..Init
void                 FReftype_Init(amc::FReftype& reftype);
// cursor points to valid item
// func:amc.FReftype.zs_fprefix_curs.Reset
inline void          reftype_zs_fprefix_curs_Reset(reftype_zs_fprefix_curs &curs, amc::FReftype &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FReftype.zs_fprefix_curs.ValidQ
inline bool          reftype_zs_fprefix_curs_ValidQ(reftype_zs_fprefix_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FReftype.zs_fprefix_curs.Next
inline void          reftype_zs_fprefix_curs_Next(reftype_zs_fprefix_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FReftype.zs_fprefix_curs.Access
inline amc::FFprefix& reftype_zs_fprefix_curs_Access(reftype_zs_fprefix_curs &curs) __attribute__((nothrow));
// func:amc.FReftype..Uninit
void                 FReftype_Uninit(amc::FReftype& reftype) __attribute__((nothrow));

// --- amc.FRowid
// create: amc.FDb.rowid (Lary)
// global access: rowid (Lary, by rowid)
// global access: ind_rowid (Thash, hash field field)
// access: amc.FField.c_rowid (Ptr)
struct FRowid { // amc.FRowid
    amc::FRowid*        ind_rowid_next;   // hash next
    algo::Smallstr100   field;            //
    algo::Comment       comment;          //
    // func:amc.FRowid..AssignOp
    inline amc::FRowid&  operator =(const amc::FRowid &rhs) = delete;
    // func:amc.FRowid..CopyCtor
    inline               FRowid(const amc::FRowid &rhs) = delete;
private:
    // func:amc.FRowid..Ctor
    inline               FRowid() __attribute__((nothrow));
    // func:amc.FRowid..Dtor
    inline               ~FRowid() __attribute__((nothrow));
    friend amc::FRowid&         rowid_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FRowid*         rowid_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 rowid_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FRowid.msghdr.CopyOut
void                 rowid_CopyOut(amc::FRowid &row, dmmeta::Rowid &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FRowid.msghdr.CopyIn
void                 rowid_CopyIn(amc::FRowid &row, dmmeta::Rowid &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FRowid..Init
inline void          FRowid_Init(amc::FRowid& rowid);
// func:amc.FRowid..Uninit
void                 FRowid_Uninit(amc::FRowid& rowid) __attribute__((nothrow));

// --- amc.FSmallstr
// create: amc.FDb.smallstr (Lary)
// global access: smallstr (Lary, by rowid)
// global access: ind_smallstr (Thash, hash field field)
// access: amc.FField.c_smallstr (Ptr)
struct FSmallstr { // amc.FSmallstr
    amc::FSmallstr*     ind_smallstr_next;   // hash next
    algo::Smallstr100   field;               //
    i32                 length;              //   0  Maximum characters in the string
    algo::Smallstr50    strtype;             // Data format for string
    algo::CppExpr       pad;                 // Pad character (if applicable)
    bool                strict;              //   false
    amc::FField*        p_field;             // reference to parent row
    amc::FNumstr*       c_numstr;            // optional pointer
    // x-reference on amc.FSmallstr.p_field prevents copy
    // x-reference on amc.FSmallstr.c_numstr prevents copy
    // func:amc.FSmallstr..AssignOp
    inline amc::FSmallstr& operator =(const amc::FSmallstr &rhs) = delete;
    // x-reference on amc.FSmallstr.p_field prevents copy
    // x-reference on amc.FSmallstr.c_numstr prevents copy
    // func:amc.FSmallstr..CopyCtor
    inline               FSmallstr(const amc::FSmallstr &rhs) = delete;
private:
    // func:amc.FSmallstr..Ctor
    inline               FSmallstr() __attribute__((nothrow));
    // func:amc.FSmallstr..Dtor
    inline               ~FSmallstr() __attribute__((nothrow));
    friend amc::FSmallstr&      smallstr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSmallstr*      smallstr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 smallstr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FSmallstr.msghdr.CopyOut
void                 smallstr_CopyOut(amc::FSmallstr &row, dmmeta::Smallstr &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FSmallstr.msghdr.CopyIn
void                 smallstr_CopyIn(amc::FSmallstr &row, dmmeta::Smallstr &in) __attribute__((nothrow));

// func:amc.FSmallstr.ctype.Get
algo::Smallstr100    ctype_Get(amc::FSmallstr& smallstr) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FSmallstr.c_numstr.InsertMaybe
inline bool          c_numstr_InsertMaybe(amc::FSmallstr& smallstr, amc::FNumstr& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FSmallstr.c_numstr.Remove
inline void          c_numstr_Remove(amc::FSmallstr& smallstr, amc::FNumstr& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FSmallstr..Init
inline void          FSmallstr_Init(amc::FSmallstr& smallstr);
// func:amc.FSmallstr..Uninit
void                 FSmallstr_Uninit(amc::FSmallstr& smallstr) __attribute__((nothrow));

// --- amc.FSortfld
// create: amc.FDb.sortfld (Lary)
// global access: sortfld (Lary, by rowid)
// access: amc.FField.c_sortfld (Ptr)
struct FSortfld { // amc.FSortfld
    algo::Smallstr100   field;       //
    algo::Smallstr100   sortfld;     // Field to sort by
    amc::FField*        p_sortfld;   // reference to parent row
    // x-reference on amc.FSortfld.p_sortfld prevents copy
    // func:amc.FSortfld..AssignOp
    inline amc::FSortfld& operator =(const amc::FSortfld &rhs) = delete;
    // x-reference on amc.FSortfld.p_sortfld prevents copy
    // func:amc.FSortfld..CopyCtor
    inline               FSortfld(const amc::FSortfld &rhs) = delete;
private:
    // func:amc.FSortfld..Ctor
    inline               FSortfld() __attribute__((nothrow));
    // func:amc.FSortfld..Dtor
    inline               ~FSortfld() __attribute__((nothrow));
    friend amc::FSortfld&       sortfld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSortfld*       sortfld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 sortfld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FSortfld.msghdr.CopyOut
void                 sortfld_CopyOut(amc::FSortfld &row, dmmeta::Sortfld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FSortfld.msghdr.CopyIn
void                 sortfld_CopyIn(amc::FSortfld &row, dmmeta::Sortfld &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FSortfld..Init
inline void          FSortfld_Init(amc::FSortfld& sortfld);
// func:amc.FSortfld..Uninit
void                 FSortfld_Uninit(amc::FSortfld& sortfld) __attribute__((nothrow));

// --- amc.FSsimfile
// create: amc.FDb.ssimfile (Lary)
// global access: ssimfile (Lary, by rowid)
// global access: ind_ssimfile (Thash, hash field ssimfile)
// global access: c_ssimfile_sorted (Ptrary)
// global access: zd_ssimfile_todo (Llist)
// access: amc.FCtype.c_ssimfile (Ptr)
// access: amc.FGsymbol.p_ssimfile (Upptr)
// access: amc.FSsimsort.p_ssimfile (Upptr)
struct FSsimfile { // amc.FSsimfile
    amc::FSsimfile*       ind_ssimfile_next;              // hash next
    amc::FSsimfile*       zd_ssimfile_todo_next;          // zslist link; -1 means not-in-list
    amc::FSsimfile*       zd_ssimfile_todo_prev;          // previous element
    algo::Smallstr50      ssimfile;                       //
    algo::Smallstr100     ctype;                          //
    algo::cstring         ssim;                           // Ssim content
    amc::FCtype*          p_ctype;                        // reference to parent row
    amc::FSsimvolatile*   c_ssimvolatile;                 // optional pointer
    bool                  topovisit;                      //   false
    i32                   topoindex;                      //   0
    bool                  input_select;                   //   false
    bool                  _db_c_ssimfile_sorted_in_ary;   //   false  membership flag
    // x-reference on amc.FSsimfile.p_ctype prevents copy
    // x-reference on amc.FSsimfile.c_ssimvolatile prevents copy
    // func:amc.FSsimfile..AssignOp
    amc::FSsimfile&      operator =(const amc::FSsimfile &rhs) = delete;
    // x-reference on amc.FSsimfile.p_ctype prevents copy
    // x-reference on amc.FSsimfile.c_ssimvolatile prevents copy
    // func:amc.FSsimfile..CopyCtor
    FSsimfile(const amc::FSsimfile &rhs) = delete;
private:
    // func:amc.FSsimfile..Ctor
    inline               FSsimfile() __attribute__((nothrow));
    // func:amc.FSsimfile..Dtor
    inline               ~FSsimfile() __attribute__((nothrow));
    friend amc::FSsimfile&      ssimfile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSsimfile*      ssimfile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimfile_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FSsimfile.msghdr.CopyOut
void                 ssimfile_CopyOut(amc::FSsimfile &row, dmmeta::Ssimfile &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FSsimfile.msghdr.CopyIn
void                 ssimfile_CopyIn(amc::FSsimfile &row, dmmeta::Ssimfile &in) __attribute__((nothrow));

// func:amc.FSsimfile.ssimns.Get
algo::Smallstr16     ssimns_Get(amc::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FSsimfile.ns.Get
algo::Smallstr16     ns_Get(amc::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FSsimfile.name.Get
algo::Smallstr50     name_Get(amc::FSsimfile& ssimfile) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FSsimfile.c_ssimvolatile.InsertMaybe
inline bool          c_ssimvolatile_InsertMaybe(amc::FSsimfile& ssimfile, amc::FSsimvolatile& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FSsimfile.c_ssimvolatile.Remove
inline void          c_ssimvolatile_Remove(amc::FSsimfile& ssimfile, amc::FSsimvolatile& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FSsimfile..Init
void                 FSsimfile_Init(amc::FSsimfile& ssimfile);
// func:amc.FSsimfile..Uninit
void                 FSsimfile_Uninit(amc::FSsimfile& ssimfile) __attribute__((nothrow));

// --- amc.FSsimsort
// create: amc.FDb.ssimsort (Lary)
// global access: ssimsort (Lary, by rowid)
struct FSsimsort { // amc.FSsimsort
    algo::Smallstr50    ssimfile;     //
    algo::Smallstr100   sortfld;      //
    algo::Comment       comment;      //
    amc::FSsimfile*     p_ssimfile;   // reference to parent row
    amc::FField*        p_sortfld;    // reference to parent row
private:
    // func:amc.FSsimsort..Ctor
    inline               FSsimsort() __attribute__((nothrow));
    friend amc::FSsimsort&      ssimsort_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSsimsort*      ssimsort_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimsort_RemoveAll() __attribute__((nothrow));
    friend void                 ssimsort_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FSsimsort.base.CopyOut
void                 ssimsort_CopyOut(amc::FSsimsort &row, dmmeta::Ssimsort &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FSsimsort.base.CopyIn
void                 ssimsort_CopyIn(amc::FSsimsort &row, dmmeta::Ssimsort &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FSsimsort..Init
inline void          FSsimsort_Init(amc::FSsimsort& ssimsort);

// --- amc.FSsimvolatile
// create: amc.FDb.ssimvolatile (Lary)
// global access: ssimvolatile (Lary, by rowid)
// access: amc.FSsimfile.c_ssimvolatile (Ptr)
struct FSsimvolatile { // amc.FSsimvolatile
    algo::Smallstr50   ssimfile;   //
    algo::Comment      comment;    //
    // func:amc.FSsimvolatile..AssignOp
    inline amc::FSsimvolatile& operator =(const amc::FSsimvolatile &rhs) = delete;
    // func:amc.FSsimvolatile..CopyCtor
    inline               FSsimvolatile(const amc::FSsimvolatile &rhs) = delete;
private:
    // func:amc.FSsimvolatile..Ctor
    inline               FSsimvolatile() __attribute__((nothrow));
    // func:amc.FSsimvolatile..Dtor
    inline               ~FSsimvolatile() __attribute__((nothrow));
    friend amc::FSsimvolatile&  ssimvolatile_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSsimvolatile*  ssimvolatile_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 ssimvolatile_RemoveAll() __attribute__((nothrow));
    friend void                 ssimvolatile_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FSsimvolatile.base.CopyOut
void                 ssimvolatile_CopyOut(amc::FSsimvolatile &row, dmmeta::Ssimvolatile &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FSsimvolatile.base.CopyIn
void                 ssimvolatile_CopyIn(amc::FSsimvolatile &row, dmmeta::Ssimvolatile &in) __attribute__((nothrow));

// func:amc.FSsimvolatile..Uninit
void                 FSsimvolatile_Uninit(amc::FSsimvolatile& ssimvolatile) __attribute__((nothrow));

// --- amc.FStatictuple
// create: amc.FDb.static_tuple (Lary)
// global access: static_tuple (Lary, by rowid)
// access: amc.FCtype.c_static (Ptrary)
struct FStatictuple { // amc.FStatictuple
    algo::Smallstr100   ctype;                   //
    algo::Tuple         tuple;                   //
    algo::cstring       cppident;                //
    bool                ctype_c_static_in_ary;   //   false  membership flag
    // func:amc.FStatictuple..AssignOp
    inline amc::FStatictuple& operator =(const amc::FStatictuple &rhs) = delete;
    // func:amc.FStatictuple..CopyCtor
    inline               FStatictuple(const amc::FStatictuple &rhs) = delete;
private:
    // func:amc.FStatictuple..Ctor
    inline               FStatictuple() __attribute__((nothrow));
    // func:amc.FStatictuple..Dtor
    inline               ~FStatictuple() __attribute__((nothrow));
    friend amc::FStatictuple&   static_tuple_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FStatictuple*   static_tuple_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 static_tuple_RemoveAll() __attribute__((nothrow));
    friend void                 static_tuple_RemoveLast() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:amc.FStatictuple..Init
inline void          FStatictuple_Init(amc::FStatictuple& static_tuple);
// func:amc.FStatictuple..Uninit
void                 FStatictuple_Uninit(amc::FStatictuple& static_tuple) __attribute__((nothrow));

// --- amc.FSubstr
// create: amc.FDb.substr (Lary)
// global access: substr (Lary, by rowid)
// global access: zd_substr_params (Llist)
// global access: c_substr_field (Ptrary)
// access: amc.FField.c_substr (Ptr)
struct FSubstr { // amc.FSubstr
    amc::FSubstr*       zd_substr_params_next;       // zslist link; -1 means not-in-list
    amc::FSubstr*       zd_substr_params_prev;       // previous element
    algo::Smallstr100   field;                       //
    algo::CppExpr       expr;                        //
    algo::Smallstr100   srcfield;                    //
    amc::FField*        p_field;                     // reference to parent row
    amc::FField*        p_srcfield;                  // reference to parent row
    u64                 range;                       //   0
    bool                _db_c_substr_field_in_ary;   //   false  membership flag
    // x-reference on amc.FSubstr.p_field prevents copy
    // x-reference on amc.FSubstr.p_srcfield prevents copy
    // func:amc.FSubstr..AssignOp
    inline amc::FSubstr& operator =(const amc::FSubstr &rhs) = delete;
    // x-reference on amc.FSubstr.p_field prevents copy
    // x-reference on amc.FSubstr.p_srcfield prevents copy
    // func:amc.FSubstr..CopyCtor
    inline               FSubstr(const amc::FSubstr &rhs) = delete;
private:
    // func:amc.FSubstr..Ctor
    inline               FSubstr() __attribute__((nothrow));
    // func:amc.FSubstr..Dtor
    inline               ~FSubstr() __attribute__((nothrow));
    friend amc::FSubstr&        substr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FSubstr*        substr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 substr_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FSubstr.msghdr.CopyOut
void                 substr_CopyOut(amc::FSubstr &row, dmmeta::Substr &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FSubstr.msghdr.CopyIn
void                 substr_CopyIn(amc::FSubstr &row, dmmeta::Substr &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FSubstr..Init
inline void          FSubstr_Init(amc::FSubstr& substr);
// func:amc.FSubstr..Uninit
void                 FSubstr_Uninit(amc::FSubstr& substr) __attribute__((nothrow));

// --- amc.FTargdep
// create: amc.FDb.targdep (Lary)
// global access: targdep (Lary, by rowid)
// access: amc.FTarget.c_targdep (Ptrary)
struct FTargdep { // amc.FTargdep
    algo::Smallstr50   targdep;                   // Primary key - target.parent
    amc::FTarget*      p_target;                  // reference to parent row
    amc::FTarget*      p_parent;                  // reference to parent row
    bool               target_c_targdep_in_ary;   //   false  membership flag
    // x-reference on amc.FTargdep.p_target prevents copy
    // x-reference on amc.FTargdep.p_parent prevents copy
    // func:amc.FTargdep..AssignOp
    inline amc::FTargdep& operator =(const amc::FTargdep &rhs) = delete;
    // x-reference on amc.FTargdep.p_target prevents copy
    // x-reference on amc.FTargdep.p_parent prevents copy
    // func:amc.FTargdep..CopyCtor
    inline               FTargdep(const amc::FTargdep &rhs) = delete;
private:
    // func:amc.FTargdep..Ctor
    inline               FTargdep() __attribute__((nothrow));
    // func:amc.FTargdep..Dtor
    inline               ~FTargdep() __attribute__((nothrow));
    friend amc::FTargdep&       targdep_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTargdep*       targdep_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 targdep_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTargdep.msghdr.CopyOut
void                 targdep_CopyOut(amc::FTargdep &row, dev::Targdep &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTargdep.msghdr.CopyIn
void                 targdep_CopyIn(amc::FTargdep &row, dev::Targdep &in) __attribute__((nothrow));

// func:amc.FTargdep.target.Get
algo::Smallstr16     target_Get(amc::FTargdep& targdep) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FTargdep.parent.Get
algo::Smallstr16     parent_Get(amc::FTargdep& targdep) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FTargdep..Init
inline void          FTargdep_Init(amc::FTargdep& targdep);
// func:amc.FTargdep..Uninit
void                 FTargdep_Uninit(amc::FTargdep& targdep) __attribute__((nothrow));

// --- amc.FTarget
// create: amc.FDb.target (Lary)
// global access: target (Lary, by rowid)
// global access: ind_target (Thash, hash field target)
// access: amc.FNs.c_target (Ptr)
// access: amc.FTargdep.p_target (Upptr)
// access: amc.FTargdep.p_parent (Upptr)
struct FTarget { // amc.FTarget
    amc::FTarget*      ind_target_next;   // hash next
    algo::Smallstr16   target;            // Primary key - name of target
    amc::FTargdep**    c_targdep_elems;   // array of pointers
    u32                c_targdep_n;       // array of pointers
    u32                c_targdep_max;     // capacity of allocated array
    amc::FNs*          p_ns;              // reference to parent row
    // reftype Ptrary of amc.FTarget.c_targdep prohibits copy
    // x-reference on amc.FTarget.p_ns prevents copy
    // func:amc.FTarget..AssignOp
    inline amc::FTarget& operator =(const amc::FTarget &rhs) = delete;
    // reftype Ptrary of amc.FTarget.c_targdep prohibits copy
    // x-reference on amc.FTarget.p_ns prevents copy
    // func:amc.FTarget..CopyCtor
    inline               FTarget(const amc::FTarget &rhs) = delete;
private:
    // func:amc.FTarget..Ctor
    inline               FTarget() __attribute__((nothrow));
    // func:amc.FTarget..Dtor
    inline               ~FTarget() __attribute__((nothrow));
    friend amc::FTarget&        target_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTarget*        target_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 target_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTarget.msghdr.CopyOut
void                 target_CopyOut(amc::FTarget &row, dev::Target &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTarget.msghdr.CopyIn
void                 target_CopyIn(amc::FTarget &row, dev::Target &in) __attribute__((nothrow));

// Return true if index is empty
// func:amc.FTarget.c_targdep.EmptyQ
inline bool          c_targdep_EmptyQ(amc::FTarget& target) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
// func:amc.FTarget.c_targdep.Find
inline amc::FTargdep* c_targdep_Find(amc::FTarget& target, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
// func:amc.FTarget.c_targdep.Getary
inline algo::aryptr<amc::FTargdep*> c_targdep_Getary(amc::FTarget& target) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
// func:amc.FTarget.c_targdep.Insert
void                 c_targdep_Insert(amc::FTarget& target, amc::FTargdep& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
// func:amc.FTarget.c_targdep.InsertMaybe
bool                 c_targdep_InsertMaybe(amc::FTarget& target, amc::FTargdep& row) __attribute__((nothrow));
// Return number of items in the pointer array
// func:amc.FTarget.c_targdep.N
inline i32           c_targdep_N(const amc::FTarget& target) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
// func:amc.FTarget.c_targdep.Remove
void                 c_targdep_Remove(amc::FTarget& target, amc::FTargdep& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:amc.FTarget.c_targdep.RemoveAll
inline void          c_targdep_RemoveAll(amc::FTarget& target) __attribute__((nothrow));
// Reserve space in index for N more elements;
// func:amc.FTarget.c_targdep.Reserve
void                 c_targdep_Reserve(amc::FTarget& target, u32 n) __attribute__((nothrow));
// Return reference without bounds checking
// func:amc.FTarget.c_targdep.qFind
inline amc::FTargdep& c_targdep_qFind(amc::FTarget& target, u32 idx) __attribute__((nothrow));
// True if row is in any ptrary instance
// func:amc.FTarget.c_targdep.InAryQ
inline bool          target_c_targdep_InAryQ(amc::FTargdep& row) __attribute__((nothrow));
// Reference to last element without bounds checking
// func:amc.FTarget.c_targdep.qLast
inline amc::FTargdep& c_targdep_qLast(amc::FTarget& target) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FTarget..Init
inline void          FTarget_Init(amc::FTarget& target);
// func:amc.FTarget.c_targdep_curs.Reset
inline void          target_c_targdep_curs_Reset(target_c_targdep_curs &curs, amc::FTarget &parent) __attribute__((nothrow));
// cursor points to valid item
// func:amc.FTarget.c_targdep_curs.ValidQ
inline bool          target_c_targdep_curs_ValidQ(target_c_targdep_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:amc.FTarget.c_targdep_curs.Next
inline void          target_c_targdep_curs_Next(target_c_targdep_curs &curs) __attribute__((nothrow));
// item access
// func:amc.FTarget.c_targdep_curs.Access
inline amc::FTargdep& target_c_targdep_curs_Access(target_c_targdep_curs &curs) __attribute__((nothrow));
// func:amc.FTarget..Uninit
void                 FTarget_Uninit(amc::FTarget& target) __attribute__((nothrow));

// --- amc.FTary
// create: amc.FDb.tary (Lary)
// global access: tary (Lary, by rowid)
// global access: ind_tary (Thash, hash field field)
// access: amc.FField.c_tary (Ptr)
struct FTary { // amc.FTary
    amc::FTary*         ind_tary_next;   // hash next
    algo::Smallstr100   field;           //
    bool                aliased;         //   false  Geneate functions to copy from aryptr
    amc::FField*        p_field;         // reference to parent row
    // x-reference on amc.FTary.p_field prevents copy
    // func:amc.FTary..AssignOp
    inline amc::FTary&   operator =(const amc::FTary &rhs) = delete;
    // x-reference on amc.FTary.p_field prevents copy
    // func:amc.FTary..CopyCtor
    inline               FTary(const amc::FTary &rhs) = delete;
private:
    // func:amc.FTary..Ctor
    inline               FTary() __attribute__((nothrow));
    // func:amc.FTary..Dtor
    inline               ~FTary() __attribute__((nothrow));
    friend amc::FTary&          tary_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTary*          tary_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tary_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTary.msghdr.CopyOut
void                 tary_CopyOut(amc::FTary &row, dmmeta::Tary &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTary.msghdr.CopyIn
void                 tary_CopyIn(amc::FTary &row, dmmeta::Tary &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FTary..Init
inline void          FTary_Init(amc::FTary& tary);
// func:amc.FTary..Uninit
void                 FTary_Uninit(amc::FTary& tary) __attribute__((nothrow));

// --- amc.FTcurs
// create: amc.FDb.tcurs (Lary)
// global access: tcurs (Lary, by rowid)
// access: amc.FTfunc.c_tcurs (Ptr)
struct FTcurs { // amc.FTcurs
    algo::Smallstr50   tfunc;     //
    bool               dflt;      //   false  Generate cursor by default? (if not, require fcurs)
    algo::Comment      comment;   //
    // func:amc.FTcurs..AssignOp
    inline amc::FTcurs&  operator =(const amc::FTcurs &rhs) = delete;
    // func:amc.FTcurs..CopyCtor
    inline               FTcurs(const amc::FTcurs &rhs) = delete;
private:
    // func:amc.FTcurs..Ctor
    inline               FTcurs() __attribute__((nothrow));
    // func:amc.FTcurs..Dtor
    inline               ~FTcurs() __attribute__((nothrow));
    friend amc::FTcurs&         tcurs_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTcurs*         tcurs_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tcurs_RemoveAll() __attribute__((nothrow));
    friend void                 tcurs_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTcurs.base.CopyOut
void                 tcurs_CopyOut(amc::FTcurs &row, amcdb::Tcurs &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTcurs.base.CopyIn
void                 tcurs_CopyIn(amc::FTcurs &row, amcdb::Tcurs &in) __attribute__((nothrow));

// func:amc.FTcurs.curstype.Get
algo::Smallstr50     curstype_Get(amc::FTcurs& tcurs) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FTcurs..Init
inline void          FTcurs_Init(amc::FTcurs& tcurs);
// func:amc.FTcurs..Uninit
void                 FTcurs_Uninit(amc::FTcurs& tcurs) __attribute__((nothrow));

// --- amc.FTfunc
// create: amc.FDb.tfunc (Lary)
// global access: tfunc (Lary, by rowid)
// global access: ind_tfunc (Thash, hash field tfunc)
// access: amc.FTclass.c_tfunc (Ptrary)
// access: amc.Genctx.p_tfunc (Upptr)
struct FTfunc { // amc.FTfunc
    amc::FTfunc*           ind_tfunc_next;          // hash next
    algo::Smallstr50       tfunc;                   //
    bool                   hasthrow;                //   false  Important defaults for new tfuncs to work
    bool                   leaf;                    //   true  Important defaults for new tfuncs to work
    bool                   poolfunc;                //   false
    bool                   inl;                     //   false  Function is typically inline
    bool                   wur;                     //   false  Warn unused result
    bool                   pure;                    //   false  OK to call fewer times than specified in text
    bool                   ismacro;                 //   false
    algo::Comment          comment;                 //
    amc::tfunc_step_hook   step;                    //   NULL  Pointer to a function
    amc::FTcurs*           c_tcurs;                 // optional pointer
    bool                   tclass_c_tfunc_in_ary;   //   false  membership flag
    // reftype Hook of amc.FTfunc.step prohibits copy
    // x-reference on amc.FTfunc.c_tcurs prevents copy
    // func:amc.FTfunc..AssignOp
    amc::FTfunc&         operator =(const amc::FTfunc &rhs) = delete;
    // reftype Hook of amc.FTfunc.step prohibits copy
    // x-reference on amc.FTfunc.c_tcurs prevents copy
    // func:amc.FTfunc..CopyCtor
    FTfunc(const amc::FTfunc &rhs) = delete;
private:
    // func:amc.FTfunc..Ctor
    inline               FTfunc() __attribute__((nothrow));
    // func:amc.FTfunc..Dtor
    inline               ~FTfunc() __attribute__((nothrow));
    friend amc::FTfunc&         tfunc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTfunc*         tfunc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tfunc_RemoveAll() __attribute__((nothrow));
    friend void                 tfunc_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTfunc.msghdr.CopyOut
void                 tfunc_CopyOut(amc::FTfunc &row, amcdb::Tfunc &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTfunc.msghdr.CopyIn
void                 tfunc_CopyIn(amc::FTfunc &row, amcdb::Tfunc &in) __attribute__((nothrow));

// func:amc.FTfunc.tclass.Get
algo::Smallstr50     tclass_Get(amc::FTfunc& tfunc) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FTfunc.name.Get
algo::Smallstr50     name_Get(amc::FTfunc& tfunc) __attribute__((__warn_unused_result__, nothrow));

// Invoke function by pointer
// func:amc.FTfunc.step.Call
inline void          step_Call(amc::FTfunc& tfunc) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FTfunc.c_tcurs.InsertMaybe
inline bool          c_tcurs_InsertMaybe(amc::FTfunc& tfunc, amc::FTcurs& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FTfunc.c_tcurs.Remove
inline void          c_tcurs_Remove(amc::FTfunc& tfunc, amc::FTcurs& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FTfunc..Init
void                 FTfunc_Init(amc::FTfunc& tfunc);
// func:amc.FTfunc..Uninit
void                 FTfunc_Uninit(amc::FTfunc& tfunc) __attribute__((nothrow));

// --- amc.FThash
// create: amc.FDb.thash (Lary)
// global access: thash (Lary, by rowid)
// access: amc.FField.c_thash (Ptr)
struct FThash { // amc.FThash
    algo::Smallstr100   field;       //
    algo::Smallstr100   hashfld;     // Field on which hash function is computed
    bool                unique;      //   true  Enforce uniqueness of member elements
    amc::FField*        p_hashfld;   // reference to parent row
    amc::FField*        p_field;     // reference to parent row
    // x-reference on amc.FThash.p_hashfld prevents copy
    // x-reference on amc.FThash.p_field prevents copy
    // func:amc.FThash..AssignOp
    inline amc::FThash&  operator =(const amc::FThash &rhs) = delete;
    // x-reference on amc.FThash.p_hashfld prevents copy
    // x-reference on amc.FThash.p_field prevents copy
    // func:amc.FThash..CopyCtor
    inline               FThash(const amc::FThash &rhs) = delete;
private:
    // func:amc.FThash..Ctor
    inline               FThash() __attribute__((nothrow));
    // func:amc.FThash..Dtor
    inline               ~FThash() __attribute__((nothrow));
    friend amc::FThash&         thash_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FThash*         thash_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 thash_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FThash.msghdr.CopyOut
void                 thash_CopyOut(amc::FThash &row, dmmeta::Thash &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FThash.msghdr.CopyIn
void                 thash_CopyIn(amc::FThash &row, dmmeta::Thash &in) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FThash..Init
inline void          FThash_Init(amc::FThash& thash);
// func:amc.FThash..Uninit
void                 FThash_Uninit(amc::FThash& thash) __attribute__((nothrow));

// --- amc.FTracefld
// create: amc.FDb.tracefld (Lary)
// global access: tracefld (Lary, by rowid)
struct FTracefld { // amc.FTracefld
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
private:
    // func:amc.FTracefld..Ctor
    inline               FTracefld() __attribute__((nothrow));
    friend amc::FTracefld&      tracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTracefld*      tracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tracefld_RemoveAll() __attribute__((nothrow));
    friend void                 tracefld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTracefld.msghdr.CopyOut
void                 tracefld_CopyOut(amc::FTracefld &row, dmmeta::Tracefld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTracefld.msghdr.CopyIn
void                 tracefld_CopyIn(amc::FTracefld &row, dmmeta::Tracefld &in) __attribute__((nothrow));

// func:amc.FTracefld.tracerec.Get
algo::Smallstr50     tracerec_Get(amc::FTracefld& tracefld) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FTracefld.name.Get
algo::Smallstr50     name_Get(amc::FTracefld& tracefld) __attribute__((__warn_unused_result__, nothrow));


// --- amc.FTracerec
// create: amc.FDb.tracerec (Lary)
// global access: tracerec (Lary, by rowid)
struct FTracerec { // amc.FTracerec
    algo::Smallstr50   tracerec;   // e.g. rl_lib.trace
    algo::Comment      comment;    //
private:
    // func:amc.FTracerec..Ctor
    inline               FTracerec() __attribute__((nothrow));
    friend amc::FTracerec&      tracerec_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTracerec*      tracerec_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 tracerec_RemoveAll() __attribute__((nothrow));
    friend void                 tracerec_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTracerec.msghdr.CopyOut
void                 tracerec_CopyOut(amc::FTracerec &row, dmmeta::Tracerec &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTracerec.msghdr.CopyIn
void                 tracerec_CopyIn(amc::FTracerec &row, dmmeta::Tracerec &in) __attribute__((nothrow));

// func:amc.FTracerec.name.Get
algo::Smallstr50     name_Get(amc::FTracerec& tracerec) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FTracerec.ns.Get
algo::Smallstr16     ns_Get(amc::FTracerec& tracerec) __attribute__((__warn_unused_result__, nothrow));


// --- amc.FTypefld
// create: amc.FDb.typefld (Lary)
// global access: typefld (Lary, by rowid)
// access: amc.FCtype.c_typefld (Ptr)
// access: amc.FField.c_typefld (Ptr)
struct FTypefld { // amc.FTypefld
    algo::Smallstr100   field;     //
    algo::Comment       comment;   //
    amc::FField*        p_field;   // reference to parent row
    amc::FCtype*        p_ctype;   // reference to parent row
    // x-reference on amc.FTypefld.p_field prevents copy
    // x-reference on amc.FTypefld.p_ctype prevents copy
    // func:amc.FTypefld..AssignOp
    inline amc::FTypefld& operator =(const amc::FTypefld &rhs) = delete;
    // x-reference on amc.FTypefld.p_field prevents copy
    // x-reference on amc.FTypefld.p_ctype prevents copy
    // func:amc.FTypefld..CopyCtor
    inline               FTypefld(const amc::FTypefld &rhs) = delete;
private:
    // func:amc.FTypefld..Ctor
    inline               FTypefld() __attribute__((nothrow));
    // func:amc.FTypefld..Dtor
    inline               ~FTypefld() __attribute__((nothrow));
    friend amc::FTypefld&       typefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FTypefld*       typefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 typefld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FTypefld.msghdr.CopyOut
void                 typefld_CopyOut(amc::FTypefld &row, dmmeta::Typefld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FTypefld.msghdr.CopyIn
void                 typefld_CopyIn(amc::FTypefld &row, dmmeta::Typefld &in) __attribute__((nothrow));

// func:amc.FTypefld.ctype.Get
algo::Smallstr100    ctype_Get(amc::FTypefld& typefld) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
// func:amc.FTypefld..Init
inline void          FTypefld_Init(amc::FTypefld& typefld);
// func:amc.FTypefld..Uninit
void                 FTypefld_Uninit(amc::FTypefld& typefld) __attribute__((nothrow));

// --- amc.FUsertracefld
// create: amc.FDb.usertracefld (Lary)
// global access: usertracefld (Lary, by rowid)
struct FUsertracefld { // amc.FUsertracefld
    algo::Smallstr100   tracefld;   //
    algo::Comment       comment;    //
private:
    // func:amc.FUsertracefld..Ctor
    inline               FUsertracefld() __attribute__((nothrow));
    friend amc::FUsertracefld&  usertracefld_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FUsertracefld*  usertracefld_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 usertracefld_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FUsertracefld.msghdr.CopyOut
void                 usertracefld_CopyOut(amc::FUsertracefld &row, dmmeta::Usertracefld &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FUsertracefld.msghdr.CopyIn
void                 usertracefld_CopyIn(amc::FUsertracefld &row, dmmeta::Usertracefld &in) __attribute__((nothrow));


// --- amc.FXref
// create: amc.FDb.xref (Lary)
// global access: xref (Lary, by rowid)
// global access: ind_xref (Thash, hash field field)
// access: amc.FCtype.zs_xref (Llist)
// access: amc.FField.c_xref (Ptr)
// access: amc.FField.zd_xref_keyfld (Llist)
struct FXref { // amc.FXref
    amc::FXref*         zs_xref_next;          // zslist link; -1 means not-in-list
    amc::FXref*         ind_xref_next;         // hash next
    amc::FXref*         zd_xref_keyfld_next;   // zslist link; -1 means not-in-list
    amc::FXref*         zd_xref_keyfld_prev;   // previous element
    algo::Smallstr100   field;                 //
    algo::CppExpr       inscond;               //   "true"  Insert condition
    algo::Smallstr200   via;                   //
    amc::FField*        p_field;               // reference to parent row
    amc::FCtype*        p_ctype;               // reference to parent row
    amc::FNocascdel*    c_nocascdel;           // optional pointer
    amc::FField*        p_viafld;              // reference to parent row
    amc::FField*        p_keyfld;              // reference to parent row
    // x-reference on amc.FXref.p_field prevents copy
    // x-reference on amc.FXref.c_nocascdel prevents copy
    // x-reference on amc.FXref.p_viafld prevents copy
    // x-reference on amc.FXref.p_keyfld prevents copy
    // func:amc.FXref..AssignOp
    amc::FXref&          operator =(const amc::FXref &rhs) = delete;
    // x-reference on amc.FXref.p_field prevents copy
    // x-reference on amc.FXref.c_nocascdel prevents copy
    // x-reference on amc.FXref.p_viafld prevents copy
    // x-reference on amc.FXref.p_keyfld prevents copy
    // func:amc.FXref..CopyCtor
    FXref(const amc::FXref &rhs) = delete;
private:
    // func:amc.FXref..Ctor
    inline               FXref() __attribute__((nothrow));
    // func:amc.FXref..Dtor
    inline               ~FXref() __attribute__((nothrow));
    friend amc::FXref&          xref_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend amc::FXref*          xref_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 xref_RemoveLast() __attribute__((nothrow));
};

// Copy fields out of row
// func:amc.FXref.msghdr.CopyOut
void                 xref_CopyOut(amc::FXref &row, dmmeta::Xref &out) __attribute__((nothrow));
// Copy fields in to row
// func:amc.FXref.msghdr.CopyIn
void                 xref_CopyIn(amc::FXref &row, dmmeta::Xref &in) __attribute__((nothrow));

// func:amc.FXref.name.Get
algo::Smallstr50     name_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FXref.ns.Get
algo::Smallstr16     ns_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FXref.viafld.Get
algo::Smallstr100    viafld_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

// func:amc.FXref.keyfld.Get
algo::Smallstr100    keyfld_Get(amc::FXref& xref) __attribute__((__warn_unused_result__, nothrow));

// Insert row into pointer index. Return final membership status.
// func:amc.FXref.c_nocascdel.InsertMaybe
inline bool          c_nocascdel_InsertMaybe(amc::FXref& xref, amc::FNocascdel& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:amc.FXref.c_nocascdel.Remove
inline void          c_nocascdel_Remove(amc::FXref& xref, amc::FNocascdel& row) __attribute__((nothrow));

// Set all fields to initial values.
// func:amc.FXref..Init
void                 FXref_Init(amc::FXref& xref);
// func:amc.FXref..Uninit
void                 FXref_Uninit(amc::FXref& xref) __attribute__((nothrow));

// --- amc.FieldId
#pragma pack(push,1)
struct FieldId { // amc.FieldId: Field read helper
    i32   value;   //   -1
    // func:amc.FieldId.value.Cast
    inline               operator amc_FieldIdEnum() const __attribute__((nothrow));
    // func:amc.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:amc.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:amc.FieldId..EnumCtor
    inline               FieldId(amc_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:amc.FieldId.value.GetEnum
inline amc_FieldIdEnum value_GetEnum(const amc::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:amc.FieldId.value.SetEnum
inline void          value_SetEnum(amc::FieldId& parent, amc_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:amc.FieldId.value.ToCstr
const char*          value_ToCstr(const amc::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:amc.FieldId.value.Print
void                 value_Print(const amc::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:amc.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:amc.FieldId.value.SetStrptr
void                 value_SetStrptr(amc::FieldId& parent, algo::strptr rhs, amc_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:amc.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(amc::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::FieldId from an ascii string.
// The format of the string is the format of the amc::FieldId's only field
// func:amc.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(amc::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.FieldId..Init
inline void          FieldId_Init(amc::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:amc.FieldId.String  printfmt:Raw
// func:amc.FieldId..Print
void                 FieldId_Print(amc::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- amc.Funcarg
// create: amc.FFunc.funcarg (Tary)
struct Funcarg { // amc.Funcarg
    algo::cstring   type;          // C++ expression for declaration
    algo::cstring   name;          // Argument name
    algo::cstring   dflt;          // Initializer
    bool            retval;        //   false  Is return value?
    bool            initialized;   //   false
    bool            indent;        //   false  Formatting option for prototype
    bool            typearg;       //   false
    // func:amc.Funcarg..Ctor
    inline               Funcarg() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:amc.Funcarg..Init
inline void          Funcarg_Init(amc::Funcarg& parent);

// --- amc.Genpnew
struct Genpnew { // amc.Genpnew
    amc::FFunc*           p_func;        // reference to parent row
    algo_lib::Replscope   R;             //
    algo::cstring         preamble;      //
    algo::cstring         postamble;     //
    bool                  req_pack;      //   false
    amc::FCtype*          p_ctype;       // reference to parent row
    amc::FField*          p_optfld;      // reference to parent row
    amc::FField*          p_varlenfld;   // reference to parent row
    bool                  optnolen;      //   false
    bool                  hasret;        //   true
    // func:amc.Genpnew..Ctor
    inline               Genpnew() __attribute__((nothrow));
};

// Set all fields to initial values.
// func:amc.Genpnew..Init
void                 Genpnew_Init(amc::Genpnew& parent);

// --- amc.Pnewtype
struct Pnewtype { // amc.Pnewtype
    u8   value;   //   0
    // func:amc.Pnewtype.value.Cast
    inline               operator amc_PnewtypeEnum() const __attribute__((nothrow));
    // func:amc.Pnewtype..Ctor
    inline               Pnewtype() __attribute__((nothrow));
    // func:amc.Pnewtype..FieldwiseCtor
    explicit inline               Pnewtype(u8 in_value) __attribute__((nothrow));
    // func:amc.Pnewtype..EnumCtor
    inline               Pnewtype(amc_PnewtypeEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:amc.Pnewtype.value.GetEnum
inline amc_PnewtypeEnum value_GetEnum(const amc::Pnewtype& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:amc.Pnewtype.value.SetEnum
inline void          value_SetEnum(amc::Pnewtype& parent, amc_PnewtypeEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:amc.Pnewtype.value.ToCstr
const char*          value_ToCstr(const amc::Pnewtype& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:amc.Pnewtype.value.Print
void                 value_Print(const amc::Pnewtype& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:amc.Pnewtype.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(amc::Pnewtype& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:amc.Pnewtype.value.SetStrptr
void                 value_SetStrptr(amc::Pnewtype& parent, algo::strptr rhs, amc_PnewtypeEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:amc.Pnewtype.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(amc::Pnewtype& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::Pnewtype from an ascii string.
// The format of the string is the format of the amc::Pnewtype's only field
// func:amc.Pnewtype..ReadStrptrMaybe
bool                 Pnewtype_ReadStrptrMaybe(amc::Pnewtype &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.Pnewtype..Init
inline void          Pnewtype_Init(amc::Pnewtype& parent);
// print string representation of ROW to string STR
// cfmt:amc.Pnewtype.String  printfmt:Raw
// func:amc.Pnewtype..Print
void                 Pnewtype_Print(amc::Pnewtype row, algo::cstring& str) __attribute__((nothrow));

// --- amc.TableId
struct TableId { // amc.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    // func:amc.TableId.value.Cast
    inline               operator amc_TableIdEnum() const __attribute__((nothrow));
    // func:amc.TableId..Ctor
    inline               TableId() __attribute__((nothrow));
    // func:amc.TableId..FieldwiseCtor
    explicit inline               TableId(i32 in_value) __attribute__((nothrow));
    // func:amc.TableId..EnumCtor
    inline               TableId(amc_TableIdEnum arg) __attribute__((nothrow));
};

// Get value of field as enum type
// func:amc.TableId.value.GetEnum
inline amc_TableIdEnum value_GetEnum(const amc::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:amc.TableId.value.SetEnum
inline void          value_SetEnum(amc::TableId& parent, amc_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:amc.TableId.value.ToCstr
const char*          value_ToCstr(const amc::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:amc.TableId.value.Print
void                 value_Print(const amc::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:amc.TableId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:amc.TableId.value.SetStrptr
void                 value_SetStrptr(amc::TableId& parent, algo::strptr rhs, amc_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:amc.TableId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(amc::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of amc::TableId from an ascii string.
// The format of the string is the format of the amc::TableId's only field
// func:amc.TableId..ReadStrptrMaybe
bool                 TableId_ReadStrptrMaybe(amc::TableId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:amc.TableId..Init
inline void          TableId_Init(amc::TableId& parent);
// print string representation of ROW to string STR
// cfmt:amc.TableId.String  printfmt:Raw
// func:amc.TableId..Print
void                 TableId_Print(amc::TableId& row, algo::cstring& str) __attribute__((nothrow));
} // gen:ns_print_struct
namespace amc { // gen:ns_curstext

struct ctype_zs_cfmt_curs {// fcurs:amc.FCtype.zs_cfmt/curs
    typedef amc::FCfmt ChildType;
    amc::FCfmt* row;
    ctype_zs_cfmt_curs() {
        row = NULL;
    }
};


struct ctype_c_field_curs {// fcurs:amc.FCtype.c_field/curs
    typedef amc::FField ChildType;
    amc::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_static_curs {// fcurs:amc.FCtype.c_static/curs
    typedef amc::FStatictuple ChildType;
    amc::FStatictuple** elems;
    u32 n_elems;
    u32 index;
    ctype_c_static_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_parent_curs {// fcurs:amc.FCtype.c_parent/curs
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    ctype_c_parent_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_pmaskfld_curs {// fcurs:amc.FCtype.c_pmaskfld/curs
    typedef amc::FPmaskfld ChildType;
    amc::FPmaskfld** elems;
    u32 n_elems;
    u32 index;
    ctype_c_pmaskfld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_datafld_curs {// fcurs:amc.FCtype.c_datafld/curs
    typedef amc::FField ChildType;
    amc::FField** elems;
    u32 n_elems;
    u32 index;
    ctype_c_datafld_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_inst_curs {// fcurs:amc.FCtype.zd_inst/curs
    typedef amc::FField ChildType;
    amc::FField* row;
    ctype_zd_inst_curs() {
        row = NULL;
    }
};


struct ctype_zs_xref_curs {// fcurs:amc.FCtype.zs_xref/curs
    typedef amc::FXref ChildType;
    amc::FXref* row;
    ctype_zs_xref_curs() {
        row = NULL;
    }
};


struct ctype_c_ffunc_curs {// fcurs:amc.FCtype.c_ffunc/curs
    typedef amc::FFunc ChildType;
    amc::FFunc** elems;
    u32 n_elems;
    u32 index;
    ctype_c_ffunc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_zd_cafter_curs {// fcurs:amc.FCtype.zd_cafter/curs
    typedef amc::FCafter ChildType;
    amc::FCafter* row;
    ctype_zd_cafter_curs() {
        row = NULL;
    }
};


struct ctype_zd_access_curs {// fcurs:amc.FCtype.zd_access/curs
    typedef amc::FField ChildType;
    amc::FField* row;
    ctype_zd_access_curs() {
        row = NULL;
    }
};


struct ctype_c_fcurs_curs {// fcurs:amc.FCtype.c_fcurs/curs
    typedef amc::FFcurs ChildType;
    amc::FFcurs** elems;
    u32 n_elems;
    u32 index;
    ctype_c_fcurs_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ctype_c_ffast_curs {// fcurs:amc.FCtype.c_ffast/curs
    typedef amc::FFfast ChildType;
    amc::FFfast** elems;
    u32 n_elems;
    u32 index;
    ctype_c_ffast_curs() { elems=NULL; n_elems=0; index=0; }
};


struct tclass_c_tfunc_curs {// fcurs:amc.FTclass.c_tfunc/curs
    typedef amc::FTfunc ChildType;
    amc::FTfunc** elems;
    u32 n_elems;
    u32 index;
    tclass_c_tfunc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_fsort_curs {// cursor
    typedef amc::FFsort ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fsort_curs(){ parent=NULL; index=0; }
};


struct _db_dispfilter_curs {// cursor
    typedef amc::FDispfilter ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispfilter_curs(){ parent=NULL; index=0; }
};


struct _db_usertracefld_curs {// cursor
    typedef amc::FUsertracefld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_usertracefld_curs(){ parent=NULL; index=0; }
};


struct _db_cfmt_curs {// cursor
    typedef amc::FCfmt ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cfmt_curs(){ parent=NULL; index=0; }
};


struct _db_dispatch_curs {// cursor
    typedef amc::FDispatch ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispatch_curs(){ parent=NULL; index=0; }
};


struct _db_dispatch_msg_curs {// cursor
    typedef amc::FDispatchmsg ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispatch_msg_curs(){ parent=NULL; index=0; }
};


struct _db_ctype_curs {// cursor
    typedef amc::FCtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ctype_curs(){ parent=NULL; index=0; }
};


struct _db_field_curs {// cursor
    typedef amc::FField ChildType;
    amc::FDb *parent;
    i64 index;
    _db_field_curs(){ parent=NULL; index=0; }
};


struct _db_basepool_curs {// cursor
    typedef amc::FBasepool ChildType;
    amc::FDb *parent;
    i64 index;
    _db_basepool_curs(){ parent=NULL; index=0; }
};


struct _db_llist_curs {// cursor
    typedef amc::FLlist ChildType;
    amc::FDb *parent;
    i64 index;
    _db_llist_curs(){ parent=NULL; index=0; }
};


struct _db_anonfld_curs {// cursor
    typedef amc::FAnonfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_anonfld_curs(){ parent=NULL; index=0; }
};


struct _db_xref_curs {// cursor
    typedef amc::FXref ChildType;
    amc::FDb *parent;
    i64 index;
    _db_xref_curs(){ parent=NULL; index=0; }
};


struct _db_ns_curs {// cursor
    typedef amc::FNs ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ns_curs(){ parent=NULL; index=0; }
};


struct _db_pnew_curs {// cursor
    typedef amc::FPnew ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pnew_curs(){ parent=NULL; index=0; }
};


struct _db_fldoffset_curs {// cursor
    typedef amc::FFldoffset ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fldoffset_curs(){ parent=NULL; index=0; }
};


struct _db_typefld_curs {// cursor
    typedef amc::FTypefld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_typefld_curs(){ parent=NULL; index=0; }
};


struct _db_lenfld_curs {// cursor
    typedef amc::FLenfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_lenfld_curs(){ parent=NULL; index=0; }
};


struct _db_bltin_curs {// cursor
    typedef amc::FBltin ChildType;
    amc::FDb *parent;
    i64 index;
    _db_bltin_curs(){ parent=NULL; index=0; }
};


struct _db_static_tuple_curs {// cursor
    typedef amc::FStatictuple ChildType;
    amc::FDb *parent;
    i64 index;
    _db_static_tuple_curs(){ parent=NULL; index=0; }
};


struct _db_msgtype_curs {// cursor
    typedef amc::FMsgtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_msgtype_curs(){ parent=NULL; index=0; }
};


struct _db_gconst_curs {// cursor
    typedef amc::FGconst ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gconst_curs(){ parent=NULL; index=0; }
};


struct _db_gstatic_curs {// cursor
    typedef amc::FGstatic ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gstatic_curs(){ parent=NULL; index=0; }
};


struct _db_thash_curs {// cursor
    typedef amc::FThash ChildType;
    amc::FDb *parent;
    i64 index;
    _db_thash_curs(){ parent=NULL; index=0; }
};


struct _db_func_curs {// cursor
    typedef amc::FFunc ChildType;
    amc::FDb *parent;
    i64 index;
    _db_func_curs(){ parent=NULL; index=0; }
};


struct _db_smallstr_curs {// cursor
    typedef amc::FSmallstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_smallstr_curs(){ parent=NULL; index=0; }
};


struct _db_numstr_curs {// cursor
    typedef amc::FNumstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_numstr_curs(){ parent=NULL; index=0; }
};


struct _db_main_curs {// cursor
    typedef amc::FMain ChildType;
    amc::FDb *parent;
    i64 index;
    _db_main_curs(){ parent=NULL; index=0; }
};


struct _db_reftype_curs {// cursor
    typedef amc::FReftype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_reftype_curs(){ parent=NULL; index=0; }
};


struct _db_cpptype_curs {// cursor
    typedef amc::FCpptype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cpptype_curs(){ parent=NULL; index=0; }
};


struct _db_inlary_curs {// cursor
    typedef amc::FInlary ChildType;
    amc::FDb *parent;
    i64 index;
    _db_inlary_curs(){ parent=NULL; index=0; }
};


struct _db_tary_curs {// cursor
    typedef amc::FTary ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tary_curs(){ parent=NULL; index=0; }
};


struct _db_cppfunc_curs {// cursor
    typedef amc::FCppfunc ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cppfunc_curs(){ parent=NULL; index=0; }
};


struct _db_rowid_curs {// cursor
    typedef amc::FRowid ChildType;
    amc::FDb *parent;
    i64 index;
    _db_rowid_curs(){ parent=NULL; index=0; }
};


struct _db_cascdel_curs {// cursor
    typedef amc::FCascdel ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cascdel_curs(){ parent=NULL; index=0; }
};


struct _db_substr_curs {// cursor
    typedef amc::FSubstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_substr_curs(){ parent=NULL; index=0; }
};


struct _db_bitfld_curs {// cursor
    typedef amc::FBitfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_bitfld_curs(){ parent=NULL; index=0; }
};


struct _db_ssimfile_curs {// cursor
    typedef amc::FSsimfile ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ssimfile_curs(){ parent=NULL; index=0; }
};


struct _db_pack_curs {// cursor
    typedef amc::FPack ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pack_curs(){ parent=NULL; index=0; }
};


struct _db_ptrary_curs {// cursor
    typedef amc::FPtrary ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ptrary_curs(){ parent=NULL; index=0; }
};


struct _db_c_ctype_sorted_curs {// fcurs:amc.FDb.c_ctype_sorted/curs
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    _db_c_ctype_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_enumstr_curs {// cursor
    typedef amc::FEnumstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_enumstr_curs(){ parent=NULL; index=0; }
};


struct _db_enumstr_len_curs {// cursor
    typedef amc::FEnumstrLen ChildType;
    amc::FDb *parent;
    i64 index;
    _db_enumstr_len_curs(){ parent=NULL; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct _db_bh_enumstr_len_curs {
    typedef amc::FEnumstrLen ChildType;
    amc::FDb      *parent;        // parent
    amc::FEnumstrLen*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    _db_bh_enumstr_len_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~_db_bh_enumstr_len_curs();
};


struct _db_fbitset_curs {// cursor
    typedef amc::FFbitset ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbitset_curs(){ parent=NULL; index=0; }
};


struct _db_fcleanup_curs {// cursor
    typedef amc::FFcleanup ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcleanup_curs(){ parent=NULL; index=0; }
};


struct _db_fdec_curs {// cursor
    typedef amc::FFdec ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fdec_curs(){ parent=NULL; index=0; }
};


struct _db_fconst_curs {// cursor
    typedef amc::FFconst ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fconst_curs(){ parent=NULL; index=0; }
};


struct _db_c_ns_sorted_curs {// fcurs:amc.FDb.c_ns_sorted/curs
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    _db_c_ns_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_finput_curs {// cursor
    typedef amc::FFinput ChildType;
    amc::FDb *parent;
    i64 index;
    _db_finput_curs(){ parent=NULL; index=0; }
};


struct _db_foutput_curs {// cursor
    typedef amc::FFoutput ChildType;
    amc::FDb *parent;
    i64 index;
    _db_foutput_curs(){ parent=NULL; index=0; }
};


struct _db_fbuf_curs {// cursor
    typedef amc::FFbuf ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbuf_curs(){ parent=NULL; index=0; }
};


struct _db_chash_curs {// cursor
    typedef amc::FChash ChildType;
    amc::FDb *parent;
    i64 index;
    _db_chash_curs(){ parent=NULL; index=0; }
};


struct _db_ccmp_curs {// cursor
    typedef amc::FCcmp ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ccmp_curs(){ parent=NULL; index=0; }
};


struct _db_fbigend_curs {// cursor
    typedef amc::FFbigend ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbigend_curs(){ parent=NULL; index=0; }
};


struct _db_zsl_ctype_pack_tran_curs {// fcurs:amc.FDb.zsl_ctype_pack_tran/curs
    typedef amc::FCtype ChildType;
    amc::FCtype* row;
    _db_zsl_ctype_pack_tran_curs() {
        row = NULL;
    }
};


struct _db_cstr_curs {// cursor
    typedef amc::FCstr ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cstr_curs(){ parent=NULL; index=0; }
};


struct _db_listtype_curs {// cursor
    typedef amc::FListtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_listtype_curs(){ parent=NULL; index=0; }
};


struct _db_fstep_curs {// cursor
    typedef amc::FFstep ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fstep_curs(){ parent=NULL; index=0; }
};


struct _db_cextern_curs {// cursor
    typedef amc::FCextern ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cextern_curs(){ parent=NULL; index=0; }
};


struct _db_fdelay_curs {// cursor
    typedef amc::FFdelay ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fdelay_curs(){ parent=NULL; index=0; }
};


struct _db_disptrace_curs {// cursor
    typedef amc::FDisptrace ChildType;
    amc::FDb *parent;
    i64 index;
    _db_disptrace_curs(){ parent=NULL; index=0; }
};


struct _db_tracefld_curs {// cursor
    typedef amc::FTracefld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tracefld_curs(){ parent=NULL; index=0; }
};


struct _db_tracerec_curs {// cursor
    typedef amc::FTracerec ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tracerec_curs(){ parent=NULL; index=0; }
};


struct _db_dispsig_curs {// cursor
    typedef amc::FDispsig ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispsig_curs(){ parent=NULL; index=0; }
};


struct _db_c_dispsig_sorted_curs {// fcurs:amc.FDb.c_dispsig_sorted/curs
    typedef amc::FDispsig ChildType;
    amc::FDispsig** elems;
    u32 n_elems;
    u32 index;
    _db_c_dispsig_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_zs_sig_visit_curs {// fcurs:amc.FDb.zs_sig_visit/curs
    typedef amc::FCtype ChildType;
    amc::FCtype* row;
    _db_zs_sig_visit_curs() {
        row = NULL;
    }
};


struct _db_target_curs {// cursor
    typedef amc::FTarget ChildType;
    amc::FDb *parent;
    i64 index;
    _db_target_curs(){ parent=NULL; index=0; }
};


struct _db_targdep_curs {// cursor
    typedef amc::FTargdep ChildType;
    amc::FDb *parent;
    i64 index;
    _db_targdep_curs(){ parent=NULL; index=0; }
};


struct _db_dispctx_curs {// cursor
    typedef amc::FDispctx ChildType;
    amc::FDb *parent;
    i64 index;
    _db_dispctx_curs(){ parent=NULL; index=0; }
};


struct _db_pmaskfld_curs {// cursor
    typedef amc::FPmaskfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pmaskfld_curs(){ parent=NULL; index=0; }
};


struct _db_fwddecl_curs {// cursor
    typedef amc::FFwddecl ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fwddecl_curs(){ parent=NULL; index=0; }
};


struct _db_tfunc_curs {// cursor
    typedef amc::FTfunc ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tfunc_curs(){ parent=NULL; index=0; }
};


struct _db_gen_curs {// cursor
    typedef amc::FGen ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gen_curs(){ parent=NULL; index=0; }
};


struct _db_fregx_curs {// cursor
    typedef amc::FFregx ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fregx_curs(){ parent=NULL; index=0; }
};


struct _db_tclass_curs {// cursor
    typedef amc::FTclass ChildType;
    int index;
    amc::FDb *parent;
    _db_tclass_curs() { parent=NULL; index=0; }
};


struct _db_fcmp_curs {// cursor
    typedef amc::FFcmp ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcmp_curs(){ parent=NULL; index=0; }
};


struct _db_fcast_curs {// cursor
    typedef amc::FFcast ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcast_curs(){ parent=NULL; index=0; }
};


struct _db_noxref_curs {// cursor
    typedef amc::FNoxref ChildType;
    amc::FDb *parent;
    i64 index;
    _db_noxref_curs(){ parent=NULL; index=0; }
};


struct _db_nocascdel_curs {// cursor
    typedef amc::FNocascdel ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nocascdel_curs(){ parent=NULL; index=0; }
};


struct _db_cafter_curs {// cursor
    typedef amc::FCafter ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cafter_curs(){ parent=NULL; index=0; }
};


struct _db_csize_curs {// cursor
    typedef amc::FCsize ChildType;
    amc::FDb *parent;
    i64 index;
    _db_csize_curs(){ parent=NULL; index=0; }
};


struct _db_nsx_curs {// cursor
    typedef amc::FNsx ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsx_curs(){ parent=NULL; index=0; }
};


struct _db_fcompact_curs {// cursor
    typedef amc::FFcompact ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcompact_curs(){ parent=NULL; index=0; }
};


struct _db_findrem_curs {// cursor
    typedef amc::FFindrem ChildType;
    amc::FDb *parent;
    i64 index;
    _db_findrem_curs(){ parent=NULL; index=0; }
};


struct _db_fcurs_curs {// cursor
    typedef amc::FFcurs ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcurs_curs(){ parent=NULL; index=0; }
};


struct _db_cdflt_curs {// cursor
    typedef amc::FCdflt ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cdflt_curs(){ parent=NULL; index=0; }
};


struct _db_argvtype_curs {// cursor
    typedef amc::FArgvtype ChildType;
    amc::FDb *parent;
    i64 index;
    _db_argvtype_curs(){ parent=NULL; index=0; }
};


struct _db_fcmdline_curs {// cursor
    typedef amc::FFcmdline ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcmdline_curs(){ parent=NULL; index=0; }
};


struct _db_floadtuples_curs {// cursor
    typedef amc::FFloadtuples ChildType;
    amc::FDb *parent;
    i64 index;
    _db_floadtuples_curs(){ parent=NULL; index=0; }
};


struct _db_fcmap_curs {// cursor
    typedef amc::FFcmap ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fcmap_curs(){ parent=NULL; index=0; }
};


struct _db_zs_ordkeyfield_curs {// fcurs:amc.FDb.zs_ordkeyfield/curs
    typedef amc::FField ChildType;
    amc::FField* row;
    _db_zs_ordkeyfield_curs() {
        row = NULL;
    }
};


struct _db_nsproto_curs {// cursor
    typedef amc::FNsproto ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsproto_curs(){ parent=NULL; index=0; }
};


struct _db_nsdb_curs {// cursor
    typedef amc::FNsdb ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsdb_curs(){ parent=NULL; index=0; }
};


struct _db_zd_substr_params_curs {// fcurs:amc.FDb.zd_substr_params/curs
    typedef amc::FSubstr ChildType;
    amc::FSubstr* row;
    _db_zd_substr_params_curs() {
        row = NULL;
    }
};


struct _db_fprefix_curs {// cursor
    typedef amc::FFprefix ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fprefix_curs(){ parent=NULL; index=0; }
};


struct _db_ftrace_curs {// cursor
    typedef amc::FFtrace ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ftrace_curs(){ parent=NULL; index=0; }
};


struct _db_fnoremove_curs {// cursor
    typedef amc::FFnoremove ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fnoremove_curs(){ parent=NULL; index=0; }
};


struct _db_c_substr_field_curs {// fcurs:amc.FDb.c_substr_field/curs
    typedef amc::FSubstr ChildType;
    amc::FSubstr** elems;
    u32 n_elems;
    u32 index;
    _db_c_substr_field_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_ctypelen_curs {// cursor
    typedef amc::FCtypelen ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ctypelen_curs(){ parent=NULL; index=0; }
};


struct _db_c_ctypelen_curs {// fcurs:amc.FDb.c_ctypelen/curs
    typedef amc::FCtypelen ChildType;
    amc::FCtypelen** elems;
    u32 n_elems;
    u32 index;
    _db_c_ctypelen_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_c_tempfield_curs {// fcurs:amc.FDb.c_tempfield/curs
    typedef amc::FField ChildType;
    amc::FField** elems;
    u32 n_elems;
    u32 index;
    _db_c_tempfield_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_fbase_curs {// cursor
    typedef amc::FFbase ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fbase_curs(){ parent=NULL; index=0; }
};


struct _db_nossimfile_curs {// cursor
    typedef amc::FNossimfile ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nossimfile_curs(){ parent=NULL; index=0; }
};


struct _db_gsymbol_curs {// cursor
    typedef amc::FGsymbol ChildType;
    amc::FDb *parent;
    i64 index;
    _db_gsymbol_curs(){ parent=NULL; index=0; }
};


struct _db_sortfld_curs {// cursor
    typedef amc::FSortfld ChildType;
    amc::FDb *parent;
    i64 index;
    _db_sortfld_curs(){ parent=NULL; index=0; }
};


struct _db_cget_curs {// cursor
    typedef amc::FCget ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cget_curs(){ parent=NULL; index=0; }
};


struct _db_cd_temp_func_curs {// fcurs:amc.FDb.cd_temp_func/curs
    typedef amc::FFunc ChildType;
    amc::FFunc* row;
    amc::FFunc** head; // address of head element
    _db_cd_temp_func_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_zs_gen_perns_curs {// fcurs:amc.FDb.zs_gen_perns/curs
    typedef amc::FGen ChildType;
    amc::FGen* row;
    _db_zs_gen_perns_curs() {
        row = NULL;
    }
};


struct _db_hook_curs {// cursor
    typedef amc::FHook ChildType;
    amc::FDb *parent;
    i64 index;
    _db_hook_curs(){ parent=NULL; index=0; }
};


struct _db_charset_curs {// cursor
    typedef amc::FCharset ChildType;
    amc::FDb *parent;
    i64 index;
    _db_charset_curs(){ parent=NULL; index=0; }
};


struct _db_nsinclude_curs {// cursor
    typedef amc::FNsinclude ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nsinclude_curs(){ parent=NULL; index=0; }
};


struct _db_ssimvolatile_curs {// cursor
    typedef amc::FSsimvolatile ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ssimvolatile_curs(){ parent=NULL; index=0; }
};


struct _db_funique_curs {// cursor
    typedef amc::FFunique ChildType;
    amc::FDb *parent;
    i64 index;
    _db_funique_curs(){ parent=NULL; index=0; }
};


struct _db_fuserinit_curs {// cursor
    typedef amc::FFuserinit ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fuserinit_curs(){ parent=NULL; index=0; }
};


struct _db_tcurs_curs {// cursor
    typedef amc::FTcurs ChildType;
    amc::FDb *parent;
    i64 index;
    _db_tcurs_curs(){ parent=NULL; index=0; }
};


struct _db_nscpp_curs {// cursor
    typedef amc::FNscpp ChildType;
    amc::FDb *parent;
    i64 index;
    _db_nscpp_curs(){ parent=NULL; index=0; }
};


struct _db_fflag_curs {// cursor
    typedef amc::FFflag ChildType;
    amc::FDb *parent;
    i64 index;
    _db_fflag_curs(){ parent=NULL; index=0; }
};


struct _db_falias_curs {// cursor
    typedef amc::FFalias ChildType;
    amc::FDb *parent;
    i64 index;
    _db_falias_curs(){ parent=NULL; index=0; }
};


struct _db_license_curs {// cursor
    typedef amc::FLicense ChildType;
    amc::FDb *parent;
    i64 index;
    _db_license_curs(){ parent=NULL; index=0; }
};


struct _db_c_ssimfile_sorted_curs {// fcurs:amc.FDb.c_ssimfile_sorted/curs
    typedef amc::FSsimfile ChildType;
    amc::FSsimfile** elems;
    u32 n_elems;
    u32 index;
    _db_c_ssimfile_sorted_curs() { elems=NULL; n_elems=0; index=0; }
};


struct _db_zd_ssimfile_todo_curs {// fcurs:amc.FDb.zd_ssimfile_todo/curs
    typedef amc::FSsimfile ChildType;
    amc::FSsimfile* row;
    _db_zd_ssimfile_todo_curs() {
        row = NULL;
    }
};


struct _db_cfast_curs {// cursor
    typedef amc::FCfast ChildType;
    amc::FDb *parent;
    i64 index;
    _db_cfast_curs(){ parent=NULL; index=0; }
};


struct _db_ffast_curs {// cursor
    typedef amc::FFfast ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ffast_curs(){ parent=NULL; index=0; }
};


struct _db_pmaskfld_member_curs {// cursor
    typedef amc::FPmaskfldMember ChildType;
    amc::FDb *parent;
    i64 index;
    _db_pmaskfld_member_curs(){ parent=NULL; index=0; }
};


struct _db_ssimsort_curs {// cursor
    typedef amc::FSsimsort ChildType;
    amc::FDb *parent;
    i64 index;
    _db_ssimsort_curs(){ parent=NULL; index=0; }
};


struct dispatch_c_dispatch_msg_curs {// fcurs:amc.FDispatch.c_dispatch_msg/curs
    typedef amc::FDispatchmsg ChildType;
    amc::FDispatchmsg** elems;
    u32 n_elems;
    u32 index;
    dispatch_c_dispatch_msg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct enumstr_c_fconst_curs {// fcurs:amc.FEnumstr.c_fconst/curs
    typedef amc::FFconst ChildType;
    amc::FFconst** elems;
    u32 n_elems;
    u32 index;
    enumstr_c_fconst_curs() { elems=NULL; n_elems=0; index=0; }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct enumstr_len_bh_enumstr_curs {
    typedef amc::FEnumstr ChildType;
    amc::FEnumstrLen      *parent;        // parent
    amc::FEnumstr*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    enumstr_len_bh_enumstr_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~enumstr_len_bh_enumstr_curs();
};


struct field_c_ffunc_curs {// fcurs:amc.FField.c_ffunc/curs
    typedef amc::FFunc ChildType;
    amc::FFunc** elems;
    u32 n_elems;
    u32 index;
    field_c_ffunc_curs() { elems=NULL; n_elems=0; index=0; }
};


struct field_c_fconst_curs {// fcurs:amc.FField.c_fconst/curs
    typedef amc::FFconst ChildType;
    amc::FFconst** elems;
    u32 n_elems;
    u32 index;
    field_c_fconst_curs() { elems=NULL; n_elems=0; index=0; }
};


struct field_zd_xref_keyfld_curs {// fcurs:amc.FField.zd_xref_keyfld/curs
    typedef amc::FXref ChildType;
    amc::FXref* row;
    field_zd_xref_keyfld_curs() {
        row = NULL;
    }
};


struct field_zs_fcmap_curs {// fcurs:amc.FField.zs_fcmap/curs
    typedef amc::FFcmap ChildType;
    amc::FFcmap* row;
    field_zs_fcmap_curs() {
        row = NULL;
    }
};

// Non-destructive heap cursor, returns heap elements in sorted order.
// A running front of potential smallest entries is kept in the helper heap (curs.temp_%)
struct field_bh_bitfld_curs {
    typedef amc::FBitfld ChildType;
    amc::FField      *parent;        // parent
    amc::FBitfld*     *temp_elems;    // helper heap
    int            temp_n;        // number of elements heaped in the helper heap
    int            temp_max;      // max number of elements possible in the helper heap
    field_bh_bitfld_curs() : parent(NULL), temp_elems(NULL), temp_n(0), temp_max(0) {}
    ~field_bh_bitfld_curs();
};


struct field_c_ffast_curs {// fcurs:amc.FField.c_ffast/curs
    typedef amc::FFfast ChildType;
    amc::FFfast** elems;
    u32 n_elems;
    u32 index;
    field_c_ffast_curs() { elems=NULL; n_elems=0; index=0; }
};


struct field_c_pmaskfld_member_curs {// fcurs:amc.FField.c_pmaskfld_member/curs
    typedef amc::FPmaskfldMember ChildType;
    amc::FPmaskfldMember** elems;
    u32 n_elems;
    u32 index;
    field_c_pmaskfld_member_curs() { elems=NULL; n_elems=0; index=0; }
};


struct func_funcarg_curs {// cursor
    typedef amc::Funcarg ChildType;
    amc::Funcarg* elems;
    int n_elems;
    int index;
    func_funcarg_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FGenXref_seen_curs {// cursor
    typedef amc::FGenXrefSeen ChildType;
    amc::FGenXref *parent;
    i64 index;
    FGenXref_seen_curs(){ parent=NULL; index=0; }
};


struct ns_c_ctype_curs {// fcurs:amc.FNs.c_ctype/curs
    typedef amc::FCtype ChildType;
    amc::FCtype** elems;
    u32 n_elems;
    u32 index;
    ns_c_ctype_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_func_curs {// fcurs:amc.FNs.c_func/curs
    typedef amc::FFunc ChildType;
    amc::FFunc** elems;
    u32 n_elems;
    u32 index;
    ns_c_func_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_dispatch_curs {// fcurs:amc.FNs.c_dispatch/curs
    typedef amc::FDispatch ChildType;
    amc::FDispatch** elems;
    u32 n_elems;
    u32 index;
    ns_c_dispatch_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_gstatic_curs {// fcurs:amc.FNs.c_gstatic/curs
    typedef amc::FGstatic ChildType;
    amc::FGstatic** elems;
    u32 n_elems;
    u32 index;
    ns_c_gstatic_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_include_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    ns_include_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_dispsig_curs {// fcurs:amc.FNs.c_dispsig/curs
    typedef amc::FDispsig ChildType;
    amc::FDispsig** elems;
    u32 n_elems;
    u32 index;
    ns_c_dispsig_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_parentns_curs {// fcurs:amc.FNs.c_parentns/curs
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    ns_c_parentns_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_cppincl_curs {// fcurs:amc.FNs.c_cppincl/curs
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    ns_c_cppincl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_hdrincl_curs {// fcurs:amc.FNs.c_hdrincl/curs
    typedef amc::FNs ChildType;
    amc::FNs** elems;
    u32 n_elems;
    u32 index;
    ns_c_hdrincl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_fwddecl_curs {// fcurs:amc.FNs.c_fwddecl/curs
    typedef amc::FFwddecl ChildType;
    amc::FFwddecl** elems;
    u32 n_elems;
    u32 index;
    ns_c_fwddecl_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_pnew_curs {// fcurs:amc.FNs.c_pnew/curs
    typedef amc::FPnew ChildType;
    amc::FPnew** elems;
    u32 n_elems;
    u32 index;
    ns_c_pnew_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_outfile_curs {// fcurs:amc.FNs.c_outfile/curs
    typedef amc::FOutfile ChildType;
    amc::FOutfile** elems;
    u32 n_elems;
    u32 index;
    ns_c_outfile_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_foutput_curs {// fcurs:amc.FNs.c_foutput/curs
    typedef amc::FFoutput ChildType;
    amc::FFoutput** elems;
    u32 n_elems;
    u32 index;
    ns_c_foutput_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_fstep_curs {// fcurs:amc.FNs.c_fstep/curs
    typedef amc::FFstep ChildType;
    amc::FFstep** elems;
    u32 n_elems;
    u32 index;
    ns_c_fstep_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_gsymbol_curs {// fcurs:amc.FNs.c_gsymbol/curs
    typedef amc::FGsymbol ChildType;
    amc::FGsymbol** elems;
    u32 n_elems;
    u32 index;
    ns_c_gsymbol_curs() { elems=NULL; n_elems=0; index=0; }
};


struct ns_c_nsinclude_curs {// fcurs:amc.FNs.c_nsinclude/curs
    typedef amc::FNsinclude ChildType;
    amc::FNsinclude** elems;
    u32 n_elems;
    u32 index;
    ns_c_nsinclude_curs() { elems=NULL; n_elems=0; index=0; }
};


struct pmaskfld_c_pmaskfld_member_curs {// fcurs:amc.FPmaskfld.c_pmaskfld_member/curs
    typedef amc::FPmaskfldMember ChildType;
    amc::FPmaskfldMember** elems;
    u32 n_elems;
    u32 index;
    pmaskfld_c_pmaskfld_member_curs() { elems=NULL; n_elems=0; index=0; }
};


struct reftype_zs_fprefix_curs {// fcurs:amc.FReftype.zs_fprefix/curs
    typedef amc::FFprefix ChildType;
    amc::FFprefix* row;
    reftype_zs_fprefix_curs() {
        row = NULL;
    }
};


struct target_c_targdep_curs {// fcurs:amc.FTarget.c_targdep/curs
    typedef amc::FTargdep ChildType;
    amc::FTargdep** elems;
    u32 n_elems;
    u32 index;
    target_c_targdep_curs() { elems=NULL; n_elems=0; index=0; }
};

} // gen:ns_curstext
namespace amc { // gen:ns_func
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Alias
// this function is 'extrn' and implemented by user
void                 tclass_Alias();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Atree
// this function is 'extrn' and implemented by user
void                 tclass_Atree();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Base
// this function is 'extrn' and implemented by user
void                 tclass_Base();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Bheap
// this function is 'extrn' and implemented by user
void                 tclass_Bheap();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Bitfld
// this function is 'extrn' and implemented by user
void                 tclass_Bitfld();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Bitset
// this function is 'extrn' and implemented by user
void                 tclass_Bitset();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Blkpool
// this function is 'extrn' and implemented by user
void                 tclass_Blkpool();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Charset
// this function is 'extrn' and implemented by user
void                 tclass_Charset();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Cmp
// this function is 'extrn' and implemented by user
void                 tclass_Cmp();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Count
// this function is 'extrn' and implemented by user
void                 tclass_Count();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Cppfunc
// this function is 'extrn' and implemented by user
void                 tclass_Cppfunc();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Cppstack
// this function is 'extrn' and implemented by user
void                 tclass_Cppstack();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Ctype
// this function is 'extrn' and implemented by user
void                 tclass_Ctype();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Dec
// this function is 'extrn' and implemented by user
void                 tclass_Dec();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Delptr
// this function is 'extrn' and implemented by user
void                 tclass_Delptr();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Exec
// this function is 'extrn' and implemented by user
void                 tclass_Exec();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Fbuf
// this function is 'extrn' and implemented by user
void                 tclass_Fbuf();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Fcast
// this function is 'extrn' and implemented by user
void                 tclass_Fcast();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Fconst
// this function is 'extrn' and implemented by user
void                 tclass_Fconst();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Field
// this function is 'extrn' and implemented by user
void                 tclass_Field();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Field2
// this function is 'extrn' and implemented by user
void                 tclass_Field2();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Global
// this function is 'extrn' and implemented by user
void                 tclass_Global();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Hook
// this function is 'extrn' and implemented by user
void                 tclass_Hook();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Inlary
// this function is 'extrn' and implemented by user
void                 tclass_Inlary();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Io
// this function is 'extrn' and implemented by user
void                 tclass_Io();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Lary
// this function is 'extrn' and implemented by user
void                 tclass_Lary();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Llist
// this function is 'extrn' and implemented by user
void                 tclass_Llist();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Lpool
// this function is 'extrn' and implemented by user
void                 tclass_Lpool();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Malloc
// this function is 'extrn' and implemented by user
void                 tclass_Malloc();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Ns
// this function is 'extrn' and implemented by user
void                 tclass_Ns();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Numstr
// this function is 'extrn' and implemented by user
void                 tclass_Numstr();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Opt
// this function is 'extrn' and implemented by user
void                 tclass_Opt();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Pkey
// this function is 'extrn' and implemented by user
void                 tclass_Pkey();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Pmask
// this function is 'extrn' and implemented by user
void                 tclass_Pmask();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Pool
// this function is 'extrn' and implemented by user
void                 tclass_Pool();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Ptr
// this function is 'extrn' and implemented by user
void                 tclass_Ptr();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Ptrary
// this function is 'extrn' and implemented by user
void                 tclass_Ptrary();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Regx
// this function is 'extrn' and implemented by user
void                 tclass_Regx();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_RegxSql
// this function is 'extrn' and implemented by user
void                 tclass_RegxSql();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Sbrk
// this function is 'extrn' and implemented by user
void                 tclass_Sbrk();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Smallstr
// this function is 'extrn' and implemented by user
void                 tclass_Smallstr();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Sort
// this function is 'extrn' and implemented by user
void                 tclass_Sort();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Step
// this function is 'extrn' and implemented by user
void                 tclass_Step();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Substr
// this function is 'extrn' and implemented by user
void                 tclass_Substr();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Tary
// this function is 'extrn' and implemented by user
void                 tclass_Tary();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Thash
// this function is 'extrn' and implemented by user
void                 tclass_Thash();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Tpool
// this function is 'extrn' and implemented by user
void                 tclass_Tpool();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Upptr
// this function is 'extrn' and implemented by user
void                 tclass_Upptr();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Val
// this function is 'extrn' and implemented by user
void                 tclass_Val();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_Varlen
// this function is 'extrn' and implemented by user
void                 tclass_Varlen();
// User-implemented function from gstatic:amc.FDb.tclass
// func:amc...tclass_ZSListMT
// this function is 'extrn' and implemented by user
void                 tclass_ZSListMT();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Alias_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Alias_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Alias_Set
// this function is 'extrn' and implemented by user
void                 tfunc_Alias_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Alias_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Alias_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_FirstImpl
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_FirstImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_First
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_First();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_InTreeQ
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_InTreeQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_InsertImpl
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_InsertImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Insert
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_RemoveFirst
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Balance
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Balance();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Propagate
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Propagate();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_TallerChild
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_TallerChild();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Disconnect
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Disconnect();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Rebalance
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Rebalance();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Next
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Next();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Prev
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Prev();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_LastImpl
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_LastImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Last
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_ElemLt
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_ElemLt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_UpdateDepth
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_UpdateDepth();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Turn
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Turn();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Connect
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Connect();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_RemoveAllImpl
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_RemoveAllImpl();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_Reinsert
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_Reinsert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_FirstGe
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_FirstGe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Atree_LastLt
// this function is 'extrn' and implemented by user
void                 tfunc_Atree_LastLt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Base_CopyOut
// this function is 'extrn' and implemented by user
void                 tfunc_Base_CopyOut();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Base_Castdown
// this function is 'extrn' and implemented by user
void                 tfunc_Base_Castdown();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Base_Castbase
// this function is 'extrn' and implemented by user
void                 tfunc_Base_Castbase();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Base_CopyIn
// this function is 'extrn' and implemented by user
void                 tfunc_Base_CopyIn();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Compact
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Compact();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Dealloc
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Dealloc();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Downheap
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Downheap();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_First
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_First();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_InBheapQ
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_InBheapQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Insert
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_N
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Reheap
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Reheap();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_ReheapFirst
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_ReheapFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_RemoveFirst
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Reserve
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Set
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_SetIfBetter
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_SetIfBetter();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_Upheap
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_Upheap();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_ElemLt
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_ElemLt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_ElemLtval
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_ElemLtval();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bheap_unordcurs
// this function is 'extrn' and implemented by user
void                 tfunc_Bheap_unordcurs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitfld_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Bitfld_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitfld_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Bitfld_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitfld_Set
// this function is 'extrn' and implemented by user
void                 tfunc_Bitfld_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_N
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_qFind
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_NBits
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_NBits();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_qGetBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_qGetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_GetBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_GetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_BitsEmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_BitsEmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_Sum1s
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_Sum1s();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_qClearBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_qClearBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_ClearBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_ClearBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_qSetBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_qSetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_SetBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_SetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_qSetBitVal
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_qSetBitVal();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_qOrBitVal
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_qOrBitVal();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_ClearBitsAll
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_ClearBitsAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_ClearBits
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_ClearBits();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_OrBits
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_OrBits();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_ExpandBits
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_ExpandBits();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_AllocBit
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_AllocBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_Sup
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_Sup();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Bitset_bitcurs
// this function is 'extrn' and implemented by user
void                 tfunc_Bitset_bitcurs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Blkpool_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Blkpool_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Blkpool_SetBufferSize
// this function is 'extrn' and implemented by user
void                 tfunc_Blkpool_SetBufferSize();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Blkpool_ReserveBuffers
// this function is 'extrn' and implemented by user
void                 tfunc_Blkpool_ReserveBuffers();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Blkpool_FreeMem
// this function is 'extrn' and implemented by user
void                 tfunc_Blkpool_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Blkpool_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Blkpool_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Charset_Match
// this function is 'extrn' and implemented by user
void                 tfunc_Charset_Match();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Cmp_Nextchar
// this function is 'extrn' and implemented by user
void                 tfunc_Cmp_Nextchar();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Cmp_Lt
// this function is 'extrn' and implemented by user
void                 tfunc_Cmp_Lt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Cmp_Cmp
// this function is 'extrn' and implemented by user
void                 tfunc_Cmp_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Count_Insert
// this function is 'extrn' and implemented by user
void                 tfunc_Count_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Count_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Count_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Count_N
// this function is 'extrn' and implemented by user
void                 tfunc_Count_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Cppfunc_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Cppfunc_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Cppfunc_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Cppfunc_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Cppfunc_Set
// this function is 'extrn' and implemented by user
void                 tfunc_Cppfunc_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Hash
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Hash();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_XrefMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_XrefMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Unref
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Unref();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_ReadFieldMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_ReadFieldMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Read
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Read();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Lt
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Lt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_GetMsgLength
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_GetMsgLength();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_GetMsgMemptr
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_GetMsgMemptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Cmp
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_UpdateMax
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_UpdateMax();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Min
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Min();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_UpdateMin
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_UpdateMin();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Max
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Eq
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Eq();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Update
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Update();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_EqStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_EqStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_ToCmdline
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_ToCmdline();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_EqEnum
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_EqEnum();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_GetAnon
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_GetAnon();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_NArgs
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_NArgs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_FastEncode
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_FastEncode();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_FastDecode
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_FastDecode();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ctype_FixEncode
// this function is 'extrn' and implemented by user
void                 tfunc_Ctype_FixEncode();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_qSetDouble
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_qSetDouble();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_GetDouble
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_GetDouble();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_GetInt
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_GetInt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_GetScale
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_GetScale();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_SetDoubleMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_SetDoubleMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Dec_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Dec_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Delptr_Access
// this function is 'extrn' and implemented by user
void                 tfunc_Delptr_Access();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Delptr_Delete
// this function is 'extrn' and implemented by user
void                 tfunc_Delptr_Delete();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Delptr_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Delptr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Delptr_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Delptr_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Start
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Start();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_StartRead
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_StartRead();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Kill
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Kill();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Wait
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Wait();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Exec
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Exec();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_ExecX
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_ExecX();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Execv
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Execv();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_ToCmdline
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_ToCmdline();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Exec_ToArgv
// this function is 'extrn' and implemented by user
void                 tfunc_Exec_ToArgv();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_BeginRead
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_BeginRead();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_EndRead
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_EndRead();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_EndWrite
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_EndWrite();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_BeginWrite
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_BeginWrite();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_GetMsg
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_GetMsg();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Realloc
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Realloc();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Max
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_N
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Outflow
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Outflow();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Refill
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Refill();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Scanmsg
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Scanmsg();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Shift
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Shift();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_SkipBytes
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_SkipBytes();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_SkipMsg
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_SkipMsg();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_WriteAll
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_WriteAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_WriteMsg
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_WriteMsg();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fbuf_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Fbuf_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fcast_Cast
// this function is 'extrn' and implemented by user
void                 tfunc_Fcast_Cast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_GetEnum
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_GetEnum();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_SetEnum
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_SetEnum();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_ToCstr
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_ToCstr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_SetStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_SetStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_SetStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_SetStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Fconst_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Fconst_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Field_Cleanup
// this function is 'extrn' and implemented by user
void                 tfunc_Field_Cleanup();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Field_Userinit
// this function is 'extrn' and implemented by user
void                 tfunc_Field_Userinit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Field_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Field_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Field_Concat
// this function is 'extrn' and implemented by user
void                 tfunc_Field_Concat();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Field2_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Field2_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_ReadArgv
// this function is 'extrn' and implemented by user
void                 tfunc_Global_ReadArgv();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_main
// this function is 'extrn' and implemented by user
void                 tfunc_Global_main();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_WinMain
// this function is 'extrn' and implemented by user
void                 tfunc_Global_WinMain();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_MainLoop
// this function is 'extrn' and implemented by user
void                 tfunc_Global_MainLoop();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_Step
// this function is 'extrn' and implemented by user
void                 tfunc_Global_Step();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_Main
// this function is 'extrn' and implemented by user
void                 tfunc_Global_Main();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_InitReflection
// this function is 'extrn' and implemented by user
void                 tfunc_Global_InitReflection();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_InsertStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Global_InsertStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_LoadTuplesMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Global_LoadTuplesMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_LoadTuplesFile
// this function is 'extrn' and implemented by user
void                 tfunc_Global_LoadTuplesFile();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_LoadTuplesFd
// this function is 'extrn' and implemented by user
void                 tfunc_Global_LoadTuplesFd();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_SaveTuples
// this function is 'extrn' and implemented by user
void                 tfunc_Global_SaveTuples();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Global_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_LoadSsimfileMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Global_LoadSsimfileMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Global_Steps
// this function is 'extrn' and implemented by user
void                 tfunc_Global_Steps();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Hook_Call
// this function is 'extrn' and implemented by user
void                 tfunc_Hook_Call();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Hook_Set0
// this function is 'extrn' and implemented by user
void                 tfunc_Hook_Set0();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Hook_Set1
// this function is 'extrn' and implemented by user
void                 tfunc_Hook_Set1();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Hook_Set2
// this function is 'extrn' and implemented by user
void                 tfunc_Hook_Set2();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Fill
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Fill();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Find
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Getary
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Max
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_N
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_RemoveLast
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_RemoveLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_RowidFind
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Setary
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Setary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_qFind
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_rowid_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_rowid_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Eq
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Eq();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Cmp
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Inlary_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Inlary_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Io_SaveSsimfile
// this function is 'extrn' and implemented by user
void                 tfunc_Io_SaveSsimfile();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Io_Input
// this function is 'extrn' and implemented by user
void                 tfunc_Io_Input();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Io_InputMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Io_InputMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Io_LoadStatic
// this function is 'extrn' and implemented by user
void                 tfunc_Io_LoadStatic();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_Find
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_Last
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_N
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_RemoveLast
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_RemoveLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_RowidFind
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_qFind
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_qLast
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lary_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Lary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_DestructiveFirst
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_DestructiveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_First
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_First();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_InLlistQ
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_InLlistQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Insert
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Last
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_N
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Next
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Next();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Prev
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Prev();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_RemoveFirst
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_RotateFirst
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_RotateFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_qLast
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Llist_delcurs
// this function is 'extrn' and implemented by user
void                 tfunc_Llist_delcurs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lpool_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Lpool_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lpool_FreeMem
// this function is 'extrn' and implemented by user
void                 tfunc_Lpool_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lpool_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Lpool_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lpool_ReserveBuffers
// this function is 'extrn' and implemented by user
void                 tfunc_Lpool_ReserveBuffers();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lpool_ReallocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Lpool_ReallocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Lpool_N
// this function is 'extrn' and implemented by user
void                 tfunc_Lpool_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Malloc_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Malloc_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Malloc_FreeMem
// this function is 'extrn' and implemented by user
void                 tfunc_Malloc_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Malloc_ReallocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Malloc_ReallocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ns_StaticCheck
// this function is 'extrn' and implemented by user
void                 tfunc_Ns_StaticCheck();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Numstr_Getnum
// this function is 'extrn' and implemented by user
void                 tfunc_Numstr_Getnum();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Numstr_GetnumDflt
// this function is 'extrn' and implemented by user
void                 tfunc_Numstr_GetnumDflt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Numstr_Geti64
// this function is 'extrn' and implemented by user
void                 tfunc_Numstr_Geti64();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Numstr_SetnumMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Numstr_SetnumMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Numstr_ForAllStrings
// this function is 'extrn' and implemented by user
void                 tfunc_Numstr_ForAllStrings();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Opt_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Opt_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Opt_Getary
// this function is 'extrn' and implemented by user
void                 tfunc_Opt_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Opt_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Opt_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Opt_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Opt_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pmask_PresentQ
// this function is 'extrn' and implemented by user
void                 tfunc_Pmask_PresentQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pmask_SetPresent
// this function is 'extrn' and implemented by user
void                 tfunc_Pmask_SetPresent();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pmask_GetBit
// this function is 'extrn' and implemented by user
void                 tfunc_Pmask_GetBit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_Alloc
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_Alloc();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_AllocMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_AllocMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_AllocExtra
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_AllocExtra();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_AllocExtraMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_AllocExtraMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_AllocVarlenMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_AllocVarlenMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_AllocVarlen
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_AllocVarlen();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_InsertMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_UpdateMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_UpdateMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Pool_Delete
// this function is 'extrn' and implemented by user
void                 tfunc_Pool_Delete();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptr_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Ptr_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptr_InsertMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Ptr_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptr_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Ptr_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptr_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Ptr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Find
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Getary
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Insert
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_InsertMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_ScanInsertMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_ScanInsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_N
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Reserve
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_oncecurs
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_oncecurs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_qFind
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_InAryQ
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_InAryQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Ptrary_qLast
// this function is 'extrn' and implemented by user
void                 tfunc_Ptrary_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Regx_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Regx_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Regx_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Regx_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Regx_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Regx_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_RegxSql_Init
// this function is 'extrn' and implemented by user
void                 tfunc_RegxSql_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_RegxSql_Print
// this function is 'extrn' and implemented by user
void                 tfunc_RegxSql_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_RegxSql_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_RegxSql_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sbrk_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Sbrk_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sbrk_FreeMem
// this function is 'extrn' and implemented by user
void                 tfunc_Sbrk_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sbrk_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Sbrk_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Add
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Add();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_AddStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_AddStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Getary
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_HashStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_HashStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Max
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_N
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_SetStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_SetStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_AssignStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_AssignStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Set
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_Ctor
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_Ctor();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Smallstr_CtorStrptr
// this function is 'extrn' and implemented by user
void                 tfunc_Smallstr_CtorStrptr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_Swap
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_Swap();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_Rotleft
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_Rotleft();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_Lt
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_Lt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_SortedQ
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_SortedQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_IntInsertionSort
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_IntInsertionSort();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_IntHeapSort
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_IntHeapSort();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_IntQuickSort
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_IntQuickSort();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_InsertionSort
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_InsertionSort();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_HeapSort
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_HeapSort();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Sort_QuickSort
// this function is 'extrn' and implemented by user
void                 tfunc_Sort_QuickSort();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Step_FirstChanged
// this function is 'extrn' and implemented by user
void                 tfunc_Step_FirstChanged();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Step_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Step_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Step_UpdateCycles
// this function is 'extrn' and implemented by user
void                 tfunc_Step_UpdateCycles();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Step_Step
// this function is 'extrn' and implemented by user
void                 tfunc_Step_Step();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Step_Call
// this function is 'extrn' and implemented by user
void                 tfunc_Step_Call();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Step_SetDelay
// this function is 'extrn' and implemented by user
void                 tfunc_Step_SetDelay();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Substr_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Substr_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Substr_Get2
// this function is 'extrn' and implemented by user
void                 tfunc_Substr_Get2();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Eq
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Eq();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Cmp
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Cmp();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Addary
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Addary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Alloc
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Alloc();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_AllocAt
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_AllocAt();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_AllocN
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_AllocN();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Find
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Getary
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Last
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Last();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Max
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Max();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_N
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_RemoveAll
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_RemoveAll();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_RemoveLast
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_RemoveLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Reserve
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_AbsReserve
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_AbsReserve();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_RowidFind
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Setary
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Setary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Setary2
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Setary2();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_qFind
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_qFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_qLast
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_qLast();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_rowid_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_rowid_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_AllocNVal
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_AllocNVal();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tary_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Tary_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_Cascdel
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_Cascdel();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_EmptyQ
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_EmptyQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_Find
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_Find();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_FindX
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_FindX();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_GetOrCreate
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_GetOrCreate();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_N
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_InsertMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_InsertMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_Reserve
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_FindRemove
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_FindRemove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_Uninit
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_Uninit();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Thash_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Thash_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tpool_AllocMem
// this function is 'extrn' and implemented by user
void                 tfunc_Tpool_AllocMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tpool_FreeMem
// this function is 'extrn' and implemented by user
void                 tfunc_Tpool_FreeMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tpool_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Tpool_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tpool_Reserve
// this function is 'extrn' and implemented by user
void                 tfunc_Tpool_Reserve();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Tpool_ReserveMem
// this function is 'extrn' and implemented by user
void                 tfunc_Tpool_ReserveMem();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Upptr_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Upptr_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Val_Get
// this function is 'extrn' and implemented by user
void                 tfunc_Val_Get();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Val_Set
// this function is 'extrn' and implemented by user
void                 tfunc_Val_Set();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Val_Init
// this function is 'extrn' and implemented by user
void                 tfunc_Val_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Val_RowidFind
// this function is 'extrn' and implemented by user
void                 tfunc_Val_RowidFind();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Val_N
// this function is 'extrn' and implemented by user
void                 tfunc_Val_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Varlen_Getary
// this function is 'extrn' and implemented by user
void                 tfunc_Varlen_Getary();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Varlen_Addr
// this function is 'extrn' and implemented by user
void                 tfunc_Varlen_Addr();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Varlen_N
// this function is 'extrn' and implemented by user
void                 tfunc_Varlen_N();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Varlen_ReadStrptrMaybe
// this function is 'extrn' and implemented by user
void                 tfunc_Varlen_ReadStrptrMaybe();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Varlen_curs
// this function is 'extrn' and implemented by user
void                 tfunc_Varlen_curs();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_Varlen_Print
// this function is 'extrn' and implemented by user
void                 tfunc_Varlen_Print();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_ZSListMT_DestructiveFirst
// this function is 'extrn' and implemented by user
void                 tfunc_ZSListMT_DestructiveFirst();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_ZSListMT_InLlistQ
// this function is 'extrn' and implemented by user
void                 tfunc_ZSListMT_InLlistQ();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_ZSListMT_Init
// this function is 'extrn' and implemented by user
void                 tfunc_ZSListMT_Init();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_ZSListMT_Insert
// this function is 'extrn' and implemented by user
void                 tfunc_ZSListMT_Insert();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_ZSListMT_Remove
// this function is 'extrn' and implemented by user
void                 tfunc_ZSListMT_Remove();
// User-implemented function from gstatic:amc.FDb.tfunc
// func:amc...tfunc_ZSListMT_RemoveFirst
// this function is 'extrn' and implemented by user
void                 tfunc_ZSListMT_RemoveFirst();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_prep_signature
// this function is 'extrn' and implemented by user
void                 gen_prep_signature();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_select_ns
// this function is 'extrn' and implemented by user
void                 gen_select_ns();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_dispenum
// this function is 'extrn' and implemented by user
void                 gen_dispenum();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_countxref
// this function is 'extrn' and implemented by user
void                 gen_countxref();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_detectinst
// this function is 'extrn' and implemented by user
void                 gen_detectinst();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_trace
// this function is 'extrn' and implemented by user
void                 gen_trace();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_sortssimfile
// this function is 'extrn' and implemented by user
void                 gen_sortssimfile();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_lookuppkey
// this function is 'extrn' and implemented by user
void                 gen_lookuppkey();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_rewrite_regx
// this function is 'extrn' and implemented by user
void                 gen_rewrite_regx();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_tableenum
// this function is 'extrn' and implemented by user
void                 gen_tableenum();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_gconst
// this function is 'extrn' and implemented by user
void                 gen_gconst();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_fast_presence
// this function is 'extrn' and implemented by user
void                 gen_fast_presence();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_bitfldenum
// this function is 'extrn' and implemented by user
void                 gen_bitfldenum();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_proc
// this function is 'extrn' and implemented by user
void                 gen_proc();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_msgcurs
// this function is 'extrn' and implemented by user
void                 gen_msgcurs();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_basefield
// this function is 'extrn' and implemented by user
void                 gen_check_basefield();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_ssimsort
// this function is 'extrn' and implemented by user
void                 gen_check_ssimsort();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_clonefconst
// this function is 'extrn' and implemented by user
void                 gen_clonefconst();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_parsenum
// this function is 'extrn' and implemented by user
void                 gen_parsenum();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_charset
// this function is 'extrn' and implemented by user
void                 gen_newfield_charset();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_count
// this function is 'extrn' and implemented by user
void                 gen_newfield_count();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_hook
// this function is 'extrn' and implemented by user
void                 gen_newfield_hook();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_exec
// this function is 'extrn' and implemented by user
void                 gen_newfield_exec();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_sortfld
// this function is 'extrn' and implemented by user
void                 gen_newfield_sortfld();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_cbase
// this function is 'extrn' and implemented by user
void                 gen_newfield_cbase();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_ptrary
// this function is 'extrn' and implemented by user
void                 gen_newfield_ptrary();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_cfmt
// this function is 'extrn' and implemented by user
void                 gen_newfield_cfmt();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_newfield_dispatch
// this function is 'extrn' and implemented by user
void                 gen_newfield_dispatch();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_fieldid
// this function is 'extrn' and implemented by user
void                 gen_fieldid();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_prep_field
// this function is 'extrn' and implemented by user
void                 gen_prep_field();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_basepool
// this function is 'extrn' and implemented by user
void                 gen_basepool();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_basepool
// this function is 'extrn' and implemented by user
void                 gen_check_basepool();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_bigend
// this function is 'extrn' and implemented by user
void                 gen_check_bigend();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_reftype
// this function is 'extrn' and implemented by user
void                 gen_check_reftype();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_static
// this function is 'extrn' and implemented by user
void                 gen_check_static();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_cheapcopy
// this function is 'extrn' and implemented by user
void                 gen_check_cheapcopy();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_cascdel
// this function is 'extrn' and implemented by user
void                 gen_check_cascdel();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_cpptype
// this function is 'extrn' and implemented by user
void                 gen_check_cpptype();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_fcurs
// this function is 'extrn' and implemented by user
void                 gen_check_fcurs();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_prefix
// this function is 'extrn' and implemented by user
void                 gen_check_prefix();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_bitfld
// this function is 'extrn' and implemented by user
void                 gen_check_bitfld();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_varlen
// this function is 'extrn' and implemented by user
void                 gen_check_varlen();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_xref_parent
// this function is 'extrn' and implemented by user
void                 gen_xref_parent();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_datafld
// this function is 'extrn' and implemented by user
void                 gen_datafld();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ctype_toposort
// this function is 'extrn' and implemented by user
void                 gen_ctype_toposort();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_plaindata
// this function is 'extrn' and implemented by user
void                 gen_plaindata();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_prep_ctype
// this function is 'extrn' and implemented by user
void                 gen_prep_ctype();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_prep_fconst
// this function is 'extrn' and implemented by user
void                 gen_prep_fconst();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_usedns
// this function is 'extrn' and implemented by user
void                 gen_usedns();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_include
// this function is 'extrn' and implemented by user
void                 gen_include();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_load_gstatic
// this function is 'extrn' and implemented by user
void                 gen_load_gstatic();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_pmask
// this function is 'extrn' and implemented by user
void                 gen_pmask();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ssimdb
// this function is 'extrn' and implemented by user
void                 gen_ssimdb();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_xref2
// this function is 'extrn' and implemented by user
void                 gen_xref2();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_check_xref
// this function is 'extrn' and implemented by user
void                 gen_check_xref();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_enums
// this function is 'extrn' and implemented by user
void                 gen_ns_enums();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_pkeytypedef
// this function is 'extrn' and implemented by user
void                 gen_ns_pkeytypedef();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_tclass_field
// this function is 'extrn' and implemented by user
void                 gen_ns_tclass_field();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_fwddecl
// this function is 'extrn' and implemented by user
void                 gen_ns_fwddecl();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_fwddecl2
// this function is 'extrn' and implemented by user
void                 gen_ns_fwddecl2();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_gstatic
// this function is 'extrn' and implemented by user
void                 gen_ns_gstatic();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_compute_size
// this function is 'extrn' and implemented by user
void                 gen_compute_size();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_cget
// this function is 'extrn' and implemented by user
void                 gen_cget();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_fcmap
// this function is 'extrn' and implemented by user
void                 gen_fcmap();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_include
// this function is 'extrn' and implemented by user
void                 gen_ns_include();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_gsymbol
// this function is 'extrn' and implemented by user
void                 gen_ns_gsymbol();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_size_enums
// this function is 'extrn' and implemented by user
void                 gen_ns_size_enums();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_tclass_ns
// this function is 'extrn' and implemented by user
void                 gen_ns_tclass_ns();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_tclass_ctype
// this function is 'extrn' and implemented by user
void                 gen_ns_tclass_ctype();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_check_path
// this function is 'extrn' and implemented by user
void                 gen_ns_check_path();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_check_pack
// this function is 'extrn' and implemented by user
void                 gen_ns_check_pack();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_check_nstype
// this function is 'extrn' and implemented by user
void                 gen_ns_check_nstype();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_check_main
// this function is 'extrn' and implemented by user
void                 gen_ns_check_main();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_fast
// this function is 'extrn' and implemented by user
void                 gen_ns_fast();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_dispatch
// this function is 'extrn' and implemented by user
void                 gen_ns_dispatch();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_pnew
// this function is 'extrn' and implemented by user
void                 gen_ns_pnew();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_funcindex
// this function is 'extrn' and implemented by user
void                 gen_ns_funcindex();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_print_proto
// this function is 'extrn' and implemented by user
void                 gen_ns_print_proto();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_print_struct
// this function is 'extrn' and implemented by user
void                 gen_ns_print_struct();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_curstext
// this function is 'extrn' and implemented by user
void                 gen_ns_curstext();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_func
// this function is 'extrn' and implemented by user
void                 gen_ns_func();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_operators
// this function is 'extrn' and implemented by user
void                 gen_ns_operators();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_check_lim
// this function is 'extrn' and implemented by user
void                 gen_ns_check_lim();
// User-implemented function from gstatic:amc.FDb.gen
// func:amc...gen_ns_write
// this function is 'extrn' and implemented by user
void                 gen_ns_write();
// func:amc...StaticCheck
void                 StaticCheck();
} // gen:ns_func
// func:amc...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:amc...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const amc::BltinId &row);// cfmt:amc.BltinId.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::Enumstr &row);// cfmt:amc.Enumstr.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::trace &row);// cfmt:amc.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::FieldId &row);// cfmt:amc.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::Pnewtype &row);// cfmt:amc.Pnewtype.String
inline algo::cstring &operator <<(algo::cstring &str, const amc::TableId &row);// cfmt:amc.TableId.String
}
