//
// include/gen/gitlab_gen.h
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#pragma once
#include "include/gen/command_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/lib_json_gen.h"
#include "include/gen/dev_gen.h"
//#pragma endinclude

// --- gitlab_FHttp_request_method_Enum

enum gitlab_FHttp_request_method_Enum {        // gitlab.FHttp.request_method
     gitlab_FHttp_request_method_GET     = 0   // GET
    ,gitlab_FHttp_request_method_POST    = 1   // POST
    ,gitlab_FHttp_request_method_PUT     = 2   // PUT
};

enum { gitlab_FHttp_request_method_Enum_N = 3 };


// --- gitlab_FieldIdEnum

enum gitlab_FieldIdEnum {        // gitlab.FieldId.value
     gitlab_FieldId_value   = 0
};

enum { gitlab_FieldIdEnum_N = 1 };


// --- gitlab_TableIdEnum

enum gitlab_TableIdEnum {                      // gitlab.TableId.value
     gitlab_TableId_dev_GitlabProject    = 0   // dev.GitlabProject -> gitlab.FProject
    ,gitlab_TableId_dev_gitlab_project   = 0   // dev.gitlab_project -> gitlab.FProject
};

enum { gitlab_TableIdEnum_N = 2 };

namespace gitlab { struct Issue; }
namespace gitlab { struct FProject; }
namespace gitlab { struct IssueDescription; }
namespace gitlab { struct FIssue; }
namespace gitlab { struct IssueNote; }
namespace gitlab { struct Mr; }
namespace gitlab { struct MrDescription; }
namespace gitlab { struct FMr; }
namespace gitlab { struct MrNote; }
namespace gitlab { struct User; }
namespace gitlab { struct trace; }
namespace gitlab { struct FDb; }
namespace gitlab { struct FHttp; }
namespace gitlab { struct FIssueDescription; }
namespace gitlab { struct FIssueNote; }
namespace gitlab { struct FMrDescription; }
namespace gitlab { struct FMrNote; }
namespace gitlab { struct FUser; }
namespace gitlab { struct FieldId; }
namespace gitlab { struct TableId; }
namespace gitlab { struct _db_project_curs; }
namespace gitlab { struct _db_ind_project_curs; }
namespace gitlab { struct _db_ind_issue_curs; }
namespace gitlab { struct _db_issue_curs; }
namespace gitlab { struct _db_issue_note_curs; }
namespace gitlab { struct _db_ind_issue_note_curs; }
namespace gitlab { struct _db_issue_description_curs; }
namespace gitlab { struct _db_ind_mr_curs; }
namespace gitlab { struct _db_mr_curs; }
namespace gitlab { struct _db_mr_note_curs; }
namespace gitlab { struct _db_ind_mr_note_curs; }
namespace gitlab { struct _db_mr_description_curs; }
namespace gitlab { struct _db_user_curs; }
namespace gitlab { struct _db_ind_user_curs; }
namespace gitlab { struct FHttp_request_header_curs; }
namespace gitlab { struct FHttp_response_header_curs; }
namespace gitlab { struct issue_c_issue_note_curs; }
namespace gitlab { struct mr_c_mr_note_curs; }
namespace gitlab { struct project_c_issue_curs; }
namespace gitlab { struct project_c_mr_curs; }
namespace gitlab {
    typedef algo::Smallstr50 IssuePkey;
    typedef algo::Smallstr50 MrPkey;
    typedef algo::Smallstr50 UserPkey;
}//pkey typedefs
namespace gitlab {
extern const char *gitlab_help;
extern const char *gitlab_syntax;
extern FDb _db;

// --- gitlab.trace
#pragma pack(push,1)
struct trace { // gitlab.trace
    trace();
};
#pragma pack(pop)

// print string representation of gitlab::trace to string LHS, no header -- cprint:gitlab.trace.String
void                 trace_Print(gitlab::trace & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.FDb
// create: gitlab.FDb._db (Global)
struct FDb { // gitlab.FDb
    command::gitlab              cmdline;                        //
    algo::cstring                home;                           // User's HOME directory
    algo::cstring                unix_user;                      // UNIX user login name
    algo::cstring                auth_file_name;                 //   ".gitlab_auth"  Basename of the file where to store GitLab auth token
    algo::cstring                auth_token;                     // GitLab auth token
    algo::cstring                auth_file;                      // File where to store gitlab auth token
    algo::cstring                usrmsg_no_token;                //   "Please supply personal access token via -auth_token option (could be done once). Visit <https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html> for directions. Token scope shall be 'api', i.e. whole GitLab API."  Message to show if no auth token
    algo::cstring                http_auth_header;               // Ready-made HTTP authorization header
    algo::cstring                rest_api;                       // Base URI of server REST API
    gitlab::FProject*            project_lary[32];               // level array
    i32                          project_n;                      // number of elements in array
    u32                          project_id;                     //   0  Numeric project ID on gitlab server
    gitlab::FProject**           ind_project_buckets_elems;      // pointer to bucket array
    i32                          ind_project_buckets_n;          // number of elements in bucket array
    i32                          ind_project_n;                  // number of elements in the hash table
    gitlab::FIssue**             ind_issue_buckets_elems;        // pointer to bucket array
    i32                          ind_issue_buckets_n;            // number of elements in bucket array
    i32                          ind_issue_n;                    // number of elements in the hash table
    gitlab::FIssue*              issue_lary[32];                 // level array
    i32                          issue_n;                        // number of elements in array
    gitlab::FIssueNote*          issue_note_lary[32];            // level array
    i32                          issue_note_n;                   // number of elements in array
    gitlab::FIssueNote**         ind_issue_note_buckets_elems;   // pointer to bucket array
    i32                          ind_issue_note_buckets_n;       // number of elements in bucket array
    i32                          ind_issue_note_n;               // number of elements in the hash table
    gitlab::FIssueDescription*   issue_description_lary[32];     // level array
    i32                          issue_description_n;            // number of elements in array
    algo::cstring                editor;                         // Command line to invoke editor
    gitlab::FMr**                ind_mr_buckets_elems;           // pointer to bucket array
    i32                          ind_mr_buckets_n;               // number of elements in bucket array
    i32                          ind_mr_n;                       // number of elements in the hash table
    gitlab::FMr*                 mr_lary[32];                    // level array
    i32                          mr_n;                           // number of elements in array
    gitlab::FMrNote*             mr_note_lary[32];               // level array
    i32                          mr_note_n;                      // number of elements in array
    gitlab::FMrNote**            ind_mr_note_buckets_elems;      // pointer to bucket array
    i32                          ind_mr_note_buckets_n;          // number of elements in bucket array
    i32                          ind_mr_note_n;                  // number of elements in the hash table
    gitlab::FMrDescription*      mr_description_lary[32];        // level array
    i32                          mr_description_n;               // number of elements in array
    gitlab::FUser*               user_lary[32];                  // level array
    i32                          user_n;                         // number of elements in array
    gitlab::FUser**              ind_user_buckets_elems;         // pointer to bucket array
    i32                          ind_user_buckets_n;             // number of elements in bucket array
    i32                          ind_user_n;                     // number of elements in the hash table
    gitlab::trace                trace;                          //
};

// Main function
void                 MainArgs(int argc, char **argv);
// Main loop.
void                 MainLoop();
// Main step
void                 Step();
// Main function
void                 Main();
void                 StaticCheck();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
bool                 LoadTuplesMaybe(algo::strptr root) __attribute__((nothrow));
// Load specified ssimfile.
bool                 LoadSsimfileMaybe(algo::strptr fname) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FProject&    project_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FProject*    project_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FProject*    project_InsertMaybe(const dev::GitlabProject &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                project_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 project_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FProject*    project_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FProject*    project_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  project_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 project_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 project_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FProject&    project_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 project_XrefMaybe(gitlab::FProject &row);

// Return true if hash is empty
bool                 ind_project_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gitlab::FProject*    ind_project_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gitlab::FProject&    ind_project_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gitlab::FProject&    ind_project_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_project_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_project_InsertMaybe(gitlab::FProject& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_project_Remove(gitlab::FProject& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_project_Reserve(int n) __attribute__((nothrow));

// Return true if hash is empty
bool                 ind_issue_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gitlab::FIssue*      ind_issue_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gitlab::FIssue&      ind_issue_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_issue_InsertMaybe(gitlab::FIssue& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_issue_Remove(gitlab::FIssue& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_issue_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FIssue&      issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FIssue*      issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FIssue*      issue_InsertMaybe(const gitlab::Issue &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                issue_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 issue_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FIssue*      issue_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FIssue*      issue_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  issue_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 issue_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 issue_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FIssue&      issue_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 issue_XrefMaybe(gitlab::FIssue &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FIssueNote&  issue_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FIssueNote*  issue_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FIssueNote*  issue_note_InsertMaybe(const gitlab::IssueNote &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                issue_note_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 issue_note_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FIssueNote*  issue_note_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FIssueNote*  issue_note_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  issue_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 issue_note_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 issue_note_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FIssueNote&  issue_note_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 issue_note_XrefMaybe(gitlab::FIssueNote &row);

// Return true if hash is empty
bool                 ind_issue_note_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gitlab::FIssueNote*  ind_issue_note_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gitlab::FIssueNote&  ind_issue_note_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_issue_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_issue_note_InsertMaybe(gitlab::FIssueNote& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_issue_note_Remove(gitlab::FIssueNote& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_issue_note_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FIssueDescription& issue_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FIssueDescription* issue_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FIssueDescription* issue_description_InsertMaybe(const gitlab::IssueDescription &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                issue_description_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 issue_description_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FIssueDescription* issue_description_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FIssueDescription* issue_description_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  issue_description_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 issue_description_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 issue_description_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FIssueDescription& issue_description_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 issue_description_XrefMaybe(gitlab::FIssueDescription &row);

// Return true if hash is empty
bool                 ind_mr_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gitlab::FMr*         ind_mr_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gitlab::FMr&         ind_mr_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_mr_InsertMaybe(gitlab::FMr& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_mr_Remove(gitlab::FMr& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_mr_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FMr&         mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FMr*         mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FMr*         mr_InsertMaybe(const gitlab::Mr &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                mr_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mr_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FMr*         mr_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FMr*         mr_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  mr_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 mr_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mr_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FMr&         mr_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 mr_XrefMaybe(gitlab::FMr &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FMrNote&     mr_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FMrNote*     mr_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FMrNote*     mr_note_InsertMaybe(const gitlab::MrNote &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                mr_note_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mr_note_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FMrNote*     mr_note_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FMrNote*     mr_note_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  mr_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 mr_note_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mr_note_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FMrNote&     mr_note_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 mr_note_XrefMaybe(gitlab::FMrNote &row);

// Return true if hash is empty
bool                 ind_mr_note_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gitlab::FMrNote*     ind_mr_note_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gitlab::FMrNote&     ind_mr_note_FindX(const algo::strptr& key);
// Return number of items in the hash
i32                  ind_mr_note_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_mr_note_InsertMaybe(gitlab::FMrNote& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_mr_note_Remove(gitlab::FMrNote& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_mr_note_Reserve(int n) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FMrDescription& mr_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FMrDescription* mr_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FMrDescription* mr_description_InsertMaybe(const gitlab::MrDescription &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                mr_description_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 mr_description_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FMrDescription* mr_description_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FMrDescription* mr_description_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  mr_description_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 mr_description_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 mr_description_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FMrDescription& mr_description_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 mr_description_XrefMaybe(gitlab::FMrDescription &row);

// Allocate memory for new default row.
// If out of memory, process is killed.
gitlab::FUser&       user_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
gitlab::FUser*       user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
gitlab::FUser*       user_InsertMaybe(const gitlab::User &value) __attribute__((nothrow));
// Allocate space for one element. If no memory available, return NULL.
void*                user_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 user_EmptyQ() __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FUser*       user_Find(u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to last element of array, or NULL if array is empty
gitlab::FUser*       user_Last() __attribute__((nothrow, pure));
// Return number of items in the pool
i32                  user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Remove all elements from Lary
void                 user_RemoveAll() __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 user_RemoveLast() __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
gitlab::FUser&       user_qFind(u64 t) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
bool                 user_XrefMaybe(gitlab::FUser &row);

// Return true if hash is empty
bool                 ind_user_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
gitlab::FUser*       ind_user_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
gitlab::FUser&       ind_user_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
gitlab::FUser&       ind_user_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
i32                  ind_user_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
bool                 ind_user_InsertMaybe(gitlab::FUser& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
void                 ind_user_Remove(gitlab::FUser& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
void                 ind_user_Reserve(int n) __attribute__((nothrow));

// cursor points to valid item
void                 _db_project_curs_Reset(_db_project_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_project_curs_ValidQ(_db_project_curs &curs);
// proceed to next item
void                 _db_project_curs_Next(_db_project_curs &curs);
// item access
gitlab::FProject&    _db_project_curs_Access(_db_project_curs &curs);
// cursor points to valid item
void                 _db_issue_curs_Reset(_db_issue_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_issue_curs_ValidQ(_db_issue_curs &curs);
// proceed to next item
void                 _db_issue_curs_Next(_db_issue_curs &curs);
// item access
gitlab::FIssue&      _db_issue_curs_Access(_db_issue_curs &curs);
// cursor points to valid item
void                 _db_issue_note_curs_Reset(_db_issue_note_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_issue_note_curs_ValidQ(_db_issue_note_curs &curs);
// proceed to next item
void                 _db_issue_note_curs_Next(_db_issue_note_curs &curs);
// item access
gitlab::FIssueNote&  _db_issue_note_curs_Access(_db_issue_note_curs &curs);
// cursor points to valid item
void                 _db_issue_description_curs_Reset(_db_issue_description_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_issue_description_curs_ValidQ(_db_issue_description_curs &curs);
// proceed to next item
void                 _db_issue_description_curs_Next(_db_issue_description_curs &curs);
// item access
gitlab::FIssueDescription& _db_issue_description_curs_Access(_db_issue_description_curs &curs);
// cursor points to valid item
void                 _db_mr_curs_Reset(_db_mr_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_mr_curs_ValidQ(_db_mr_curs &curs);
// proceed to next item
void                 _db_mr_curs_Next(_db_mr_curs &curs);
// item access
gitlab::FMr&         _db_mr_curs_Access(_db_mr_curs &curs);
// cursor points to valid item
void                 _db_mr_note_curs_Reset(_db_mr_note_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_mr_note_curs_ValidQ(_db_mr_note_curs &curs);
// proceed to next item
void                 _db_mr_note_curs_Next(_db_mr_note_curs &curs);
// item access
gitlab::FMrNote&     _db_mr_note_curs_Access(_db_mr_note_curs &curs);
// cursor points to valid item
void                 _db_mr_description_curs_Reset(_db_mr_description_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_mr_description_curs_ValidQ(_db_mr_description_curs &curs);
// proceed to next item
void                 _db_mr_description_curs_Next(_db_mr_description_curs &curs);
// item access
gitlab::FMrDescription& _db_mr_description_curs_Access(_db_mr_description_curs &curs);
// cursor points to valid item
void                 _db_user_curs_Reset(_db_user_curs &curs, gitlab::FDb &parent);
// cursor points to valid item
bool                 _db_user_curs_ValidQ(_db_user_curs &curs);
// proceed to next item
void                 _db_user_curs_Next(_db_user_curs &curs);
// item access
gitlab::FUser&       _db_user_curs_Access(_db_user_curs &curs);
// Set all fields to initial values.
void                 FDb_Init();
void                 FDb_Uninit() __attribute__((nothrow));

// --- gitlab.FHttp
struct FHttp { // gitlab.FHttp: HTTP request
    algo::cstring       request_uri;                  // URI of requested resource
    algo::cstring*      request_header_elems;         // pointer to elements
    u32                 request_header_n;             // number of elements in array
    u32                 request_header_max;           // max. capacity of array before realloc
    algo::cstring       request_content_type;         // Request content type
    algo::cstring       request_body;                 // Request body
    algo::cstring       response_status_line;         // Status line
    u32                 response_status_code;         //   0  Numeric status code
    u32                 request_method;               //   gitlab_FHttp_request_method_GET  Request method
    algo::cstring       response_reason_phrase;       // Status message
    algo::cstring*      response_header_elems;        // pointer to elements
    u32                 response_header_n;            // number of elements in array
    u32                 response_header_max;          // max. capacity of array before realloc
    algo::cstring       response_content_type;        // Response content type
    algo::cstring       response_body;                // Response body
    bool                response_content_type_json;   //   false  Flag if response is JSON
    lib_json::FParser   response_json_parser;         // Json parser to parse response body on the fly
    u32                 request_body_sent_bytes;      //   0  Sent bytes in request body
    FHttp();
    ~FHttp();
private:
    // reftype of gitlab.FHttp.request_header prohibits copy
    // reftype of gitlab.FHttp.response_header prohibits copy
    // value field gitlab.FHttp.response_json_parser is not copiable
    // ... and several other reasons
    FHttp(const FHttp&){ /*disallow copy constructor */}
    void operator =(const FHttp&){ /*disallow direct assignment */}
};

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       request_header_Alloc(gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       request_header_AllocAt(gitlab::FHttp& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> request_header_AllocN(gitlab::FHttp& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 request_header_EmptyQ(gitlab::FHttp& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       request_header_Find(gitlab::FHttp& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> request_header_Getary(gitlab::FHttp& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       request_header_Last(gitlab::FHttp& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  request_header_Max(gitlab::FHttp& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  request_header_N(const gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 request_header_Remove(gitlab::FHttp& parent, u32 i) __attribute__((nothrow));
void                 request_header_RemoveAll(gitlab::FHttp& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 request_header_RemoveLast(gitlab::FHttp& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 request_header_Reserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 request_header_AbsReserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 request_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       request_header_qFind(gitlab::FHttp& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       request_header_qLast(gitlab::FHttp& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  request_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) __attribute__((nothrow));

// Get value of field as enum type
gitlab_FHttp_request_method_Enum request_method_GetEnum(const gitlab::FHttp& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 request_method_SetEnum(gitlab::FHttp& parent, gitlab_FHttp_request_method_Enum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          request_method_ToCstr(const gitlab::FHttp& parent) __attribute__((nothrow));
// Convert request_method to a string. First, attempt conversion to a known string.
// If no string matches, print request_method as a numeric value.
void                 request_method_Print(const gitlab::FHttp& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 request_method_SetStrptrMaybe(gitlab::FHttp& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 request_method_SetStrptr(gitlab::FHttp& parent, algo::strptr rhs, gitlab_FHttp_request_method_Enum dflt) __attribute__((nothrow));

// Reserve space. Insert element at the end
// The new element is initialized to a default value
algo::cstring&       response_header_Alloc(gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow));
// Reserve space for new element, reallocating the array if necessary
// Insert new element at specified index. Index must be in range or a fatal error occurs.
algo::cstring&       response_header_AllocAt(gitlab::FHttp& parent, int at) __attribute__((__warn_unused_result__, nothrow));
// Reserve space. Insert N elements at the end of the array, return pointer to array
algo::aryptr<algo::cstring> response_header_AllocN(gitlab::FHttp& parent, int n_elems) __attribute__((__warn_unused_result__, nothrow));
// Return true if index is empty
bool                 response_header_EmptyQ(gitlab::FHttp& parent) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
algo::cstring*       response_header_Find(gitlab::FHttp& parent, u64 t) __attribute__((__warn_unused_result__, nothrow));
// Return array pointer by value
algo::aryptr<algo::cstring> response_header_Getary(gitlab::FHttp& parent) __attribute__((nothrow));
// Return pointer to last element of array, or NULL if array is empty
algo::cstring*       response_header_Last(gitlab::FHttp& parent) __attribute__((nothrow, pure));
// Return max. number of items in the array
i32                  response_header_Max(gitlab::FHttp& parent) __attribute__((nothrow));
// Return number of items in the array
i32                  response_header_N(const gitlab::FHttp& parent) __attribute__((__warn_unused_result__, nothrow, pure));
// Remove item by index. If index outside of range, do nothing.
void                 response_header_Remove(gitlab::FHttp& parent, u32 i) __attribute__((nothrow));
void                 response_header_RemoveAll(gitlab::FHttp& parent) __attribute__((nothrow));
// Delete last element of array. Do nothing if array is empty.
void                 response_header_RemoveLast(gitlab::FHttp& parent) __attribute__((nothrow));
// Make sure N *more* elements will fit in array. Process dies if out of memory
void                 response_header_Reserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
// Make sure N elements fit in array. Process dies if out of memory
void                 response_header_AbsReserve(gitlab::FHttp& parent, int n) __attribute__((nothrow));
// Copy contents of RHS to PARENT.
void                 response_header_Setary(gitlab::FHttp& parent, gitlab::FHttp &rhs) __attribute__((nothrow));
// 'quick' Access row by row id. No bounds checking.
algo::cstring&       response_header_qFind(gitlab::FHttp& parent, u64 t) __attribute__((nothrow));
// Return reference to last element of array. No bounds checking
algo::cstring&       response_header_qLast(gitlab::FHttp& parent) __attribute__((nothrow));
// Return row id of specified element
u64                  response_header_rowid_Get(gitlab::FHttp& parent, algo::cstring &elem) __attribute__((nothrow));

// proceed to next item
void                 FHttp_request_header_curs_Next(FHttp_request_header_curs &curs);
void                 FHttp_request_header_curs_Reset(FHttp_request_header_curs &curs, gitlab::FHttp &parent);
// cursor points to valid item
bool                 FHttp_request_header_curs_ValidQ(FHttp_request_header_curs &curs);
// item access
algo::cstring&       FHttp_request_header_curs_Access(FHttp_request_header_curs &curs);
// proceed to next item
void                 FHttp_response_header_curs_Next(FHttp_response_header_curs &curs);
void                 FHttp_response_header_curs_Reset(FHttp_response_header_curs &curs, gitlab::FHttp &parent);
// cursor points to valid item
bool                 FHttp_response_header_curs_ValidQ(FHttp_response_header_curs &curs);
// item access
algo::cstring&       FHttp_response_header_curs_Access(FHttp_response_header_curs &curs);
// Set all fields to initial values.
void                 FHttp_Init(gitlab::FHttp& parent);
void                 FHttp_Uninit(gitlab::FHttp& parent) __attribute__((nothrow));
// print string representation of gitlab::FHttp to string LHS, no header -- cprint:gitlab.FHttp.String
void                 FHttp_Print(gitlab::FHttp & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.FIssue
// create: gitlab.FDb.issue (Lary)
// global access: ind_issue (Thash)
// access: gitlab.FIssueDescription.p_issue (Upptr)
// access: gitlab.FIssueNote.p_issue (Upptr)
// access: gitlab.FProject.c_issue (Ptrary)
struct FIssue { // gitlab.FIssue
    gitlab::FIssue*              ind_issue_next;           // hash next
    algo::Smallstr50             issue;                    // Identifier. must be in form project.iid
    algo::Smallstr50             assignee;                 // User the issue is assigned to
    algo::cstring                title;                    // Issue title
    gitlab::FProject*            p_project;                // reference to parent row
    gitlab::FIssueNote**         c_issue_note_elems;       // array of pointers
    u32                          c_issue_note_n;           // array of pointers
    u32                          c_issue_note_max;         // capacity of allocated array
    gitlab::FIssueDescription*   c_issue_description;      // optional pointer
    bool                         select;                   //   false
    bool                         project_c_issue_in_ary;   //   false  membership flag
private:
    friend gitlab::FIssue&      issue_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FIssue*      issue_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issue_RemoveAll() __attribute__((nothrow));
    friend void                 issue_RemoveLast() __attribute__((nothrow));
    FIssue();
    ~FIssue();
    FIssue(const FIssue&){ /*disallow copy constructor */}
    void operator =(const FIssue&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 issue_CopyOut(gitlab::FIssue &row, gitlab::Issue &out) __attribute__((nothrow));
// Copy fields in to row
void                 issue_CopyIn(gitlab::FIssue &row, gitlab::Issue &in) __attribute__((nothrow));

algo::Smallstr50     project_Get(gitlab::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));

u32                  iid_Get(gitlab::FIssue& issue) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_issue_note_EmptyQ(gitlab::FIssue& issue) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FIssueNote*  c_issue_note_Find(gitlab::FIssue& issue, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gitlab::FIssueNote*> c_issue_note_Getary(gitlab::FIssue& issue) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_issue_note_Insert(gitlab::FIssue& issue, gitlab::FIssueNote& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_issue_note_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueNote& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_issue_note_N(const gitlab::FIssue& issue) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_issue_note_Remove(gitlab::FIssue& issue, gitlab::FIssueNote& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_issue_note_RemoveAll(gitlab::FIssue& issue) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_issue_note_Reserve(gitlab::FIssue& issue, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_issue_description_InsertMaybe(gitlab::FIssue& issue, gitlab::FIssueDescription& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_issue_description_Remove(gitlab::FIssue& issue, gitlab::FIssueDescription& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FIssue_Init(gitlab::FIssue& issue);
void                 issue_c_issue_note_curs_Reset(issue_c_issue_note_curs &curs, gitlab::FIssue &parent);
// cursor points to valid item
bool                 issue_c_issue_note_curs_ValidQ(issue_c_issue_note_curs &curs);
// proceed to next item
void                 issue_c_issue_note_curs_Next(issue_c_issue_note_curs &curs);
// item access
gitlab::FIssueNote&  issue_c_issue_note_curs_Access(issue_c_issue_note_curs &curs);
void                 FIssue_Uninit(gitlab::FIssue& issue) __attribute__((nothrow));
// print string representation of gitlab::FIssue to string LHS, no header -- cprint:gitlab.FIssue.String
void                 FIssue_Print(gitlab::FIssue & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.FIssueDescription
// create: gitlab.FDb.issue_description (Lary)
// access: gitlab.FIssue.c_issue_description (Ptr)
struct FIssueDescription { // gitlab.FIssueDescription
    algo::Smallstr50   issue;         //
    algo::cstring      description;   //
    gitlab::FIssue*    p_issue;       // reference to parent row
private:
    friend gitlab::FIssueDescription& issue_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FIssueDescription* issue_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issue_description_RemoveAll() __attribute__((nothrow));
    friend void                 issue_description_RemoveLast() __attribute__((nothrow));
    FIssueDescription();
    ~FIssueDescription();
    FIssueDescription(const FIssueDescription&){ /*disallow copy constructor */}
    void operator =(const FIssueDescription&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 issue_description_CopyOut(gitlab::FIssueDescription &row, gitlab::IssueDescription &out) __attribute__((nothrow));
// Copy fields in to row
void                 issue_description_CopyIn(gitlab::FIssueDescription &row, gitlab::IssueDescription &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FIssueDescription_Init(gitlab::FIssueDescription& issue_description);
void                 FIssueDescription_Uninit(gitlab::FIssueDescription& issue_description) __attribute__((nothrow));

// --- gitlab.FIssueNote
// create: gitlab.FDb.issue_note (Lary)
// global access: ind_issue_note (Thash)
// access: gitlab.FIssue.c_issue_note (Ptrary)
struct FIssueNote { // gitlab.FIssueNote
    gitlab::FIssueNote*   ind_issue_note_next;         // hash next
    algo::Smallstr50      issue_note;                  // Identifier. must be in form issue.id
    algo::cstring         body;                        // Body of issue note
    gitlab::FIssue*       p_issue;                     // reference to parent row
    bool                  issue_c_issue_note_in_ary;   //   false  membership flag
private:
    friend gitlab::FIssueNote&  issue_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FIssueNote*  issue_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 issue_note_RemoveAll() __attribute__((nothrow));
    friend void                 issue_note_RemoveLast() __attribute__((nothrow));
    FIssueNote();
    ~FIssueNote();
    FIssueNote(const FIssueNote&){ /*disallow copy constructor */}
    void operator =(const FIssueNote&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 issue_note_CopyOut(gitlab::FIssueNote &row, gitlab::IssueNote &out) __attribute__((nothrow));
// Copy fields in to row
void                 issue_note_CopyIn(gitlab::FIssueNote &row, gitlab::IssueNote &in) __attribute__((nothrow));

algo::Smallstr50     issue_Get(gitlab::FIssueNote& issue_note) __attribute__((__warn_unused_result__, nothrow));

u32                  id_Get(gitlab::FIssueNote& issue_note) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FIssueNote_Init(gitlab::FIssueNote& issue_note);
void                 FIssueNote_Uninit(gitlab::FIssueNote& issue_note) __attribute__((nothrow));

// --- gitlab.FMr
// create: gitlab.FDb.mr (Lary)
// global access: ind_mr (Thash)
// access: gitlab.FMrDescription.p_mr (Upptr)
// access: gitlab.FMrNote.p_mr (Upptr)
// access: gitlab.FProject.c_mr (Ptrary)
struct FMr { // gitlab.FMr
    gitlab::FMr*              ind_mr_next;           // hash next
    algo::Smallstr50          mr;                    // Identifier. must be in form project.iid
    algo::cstring             title;                 // Mr title
    algo::cstring             source_branch;         // Source branch
    algo::Smallstr20          pipeline_status;       // Pipeline status
    gitlab::FProject*         p_project;             // reference to parent row
    gitlab::FMrNote**         c_mr_note_elems;       // array of pointers
    u32                       c_mr_note_n;           // array of pointers
    u32                       c_mr_note_max;         // capacity of allocated array
    gitlab::FMrDescription*   c_mr_description;      // optional pointer
    bool                      project_c_mr_in_ary;   //   false  membership flag
private:
    friend gitlab::FMr&         mr_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FMr*         mr_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mr_RemoveAll() __attribute__((nothrow));
    friend void                 mr_RemoveLast() __attribute__((nothrow));
    FMr();
    ~FMr();
    FMr(const FMr&){ /*disallow copy constructor */}
    void operator =(const FMr&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 mr_CopyOut(gitlab::FMr &row, gitlab::Mr &out) __attribute__((nothrow));
// Copy fields in to row
void                 mr_CopyIn(gitlab::FMr &row, gitlab::Mr &in) __attribute__((nothrow));

algo::Smallstr50     project_Get(gitlab::FMr& mr) __attribute__((__warn_unused_result__, nothrow));

u32                  iid_Get(gitlab::FMr& mr) __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
bool                 c_mr_note_EmptyQ(gitlab::FMr& mr) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FMrNote*     c_mr_note_Find(gitlab::FMr& mr, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gitlab::FMrNote*> c_mr_note_Getary(gitlab::FMr& mr) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_mr_note_Insert(gitlab::FMr& mr, gitlab::FMrNote& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_mr_note_InsertMaybe(gitlab::FMr& mr, gitlab::FMrNote& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_mr_note_N(const gitlab::FMr& mr) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_mr_note_Remove(gitlab::FMr& mr, gitlab::FMrNote& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_mr_note_RemoveAll(gitlab::FMr& mr) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_mr_note_Reserve(gitlab::FMr& mr, u32 n) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
bool                 c_mr_description_InsertMaybe(gitlab::FMr& mr, gitlab::FMrDescription& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
void                 c_mr_description_Remove(gitlab::FMr& mr, gitlab::FMrDescription& row) __attribute__((nothrow));

// Set all fields to initial values.
void                 FMr_Init(gitlab::FMr& mr);
void                 mr_c_mr_note_curs_Reset(mr_c_mr_note_curs &curs, gitlab::FMr &parent);
// cursor points to valid item
bool                 mr_c_mr_note_curs_ValidQ(mr_c_mr_note_curs &curs);
// proceed to next item
void                 mr_c_mr_note_curs_Next(mr_c_mr_note_curs &curs);
// item access
gitlab::FMrNote&     mr_c_mr_note_curs_Access(mr_c_mr_note_curs &curs);
void                 FMr_Uninit(gitlab::FMr& mr) __attribute__((nothrow));
// print string representation of gitlab::FMr to string LHS, no header -- cprint:gitlab.FMr.String
void                 FMr_Print(gitlab::FMr & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.FMrDescription
// create: gitlab.FDb.mr_description (Lary)
// access: gitlab.FMr.c_mr_description (Ptr)
struct FMrDescription { // gitlab.FMrDescription
    algo::Smallstr50   mr;            //
    algo::cstring      description;   //
    gitlab::FMr*       p_mr;          // reference to parent row
private:
    friend gitlab::FMrDescription& mr_description_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FMrDescription* mr_description_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mr_description_RemoveAll() __attribute__((nothrow));
    friend void                 mr_description_RemoveLast() __attribute__((nothrow));
    FMrDescription();
    ~FMrDescription();
    FMrDescription(const FMrDescription&){ /*disallow copy constructor */}
    void operator =(const FMrDescription&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 mr_description_CopyOut(gitlab::FMrDescription &row, gitlab::MrDescription &out) __attribute__((nothrow));
// Copy fields in to row
void                 mr_description_CopyIn(gitlab::FMrDescription &row, gitlab::MrDescription &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FMrDescription_Init(gitlab::FMrDescription& mr_description);
void                 FMrDescription_Uninit(gitlab::FMrDescription& mr_description) __attribute__((nothrow));

// --- gitlab.FMrNote
// create: gitlab.FDb.mr_note (Lary)
// global access: ind_mr_note (Thash)
// access: gitlab.FMr.c_mr_note (Ptrary)
struct FMrNote { // gitlab.FMrNote
    gitlab::FMrNote*   ind_mr_note_next;      // hash next
    algo::Smallstr50   mr_note;               // Identifier. must be in form mr.id
    algo::cstring      body;                  // Body of mr note
    gitlab::FMr*       p_mr;                  // reference to parent row
    bool               mr_c_mr_note_in_ary;   //   false  membership flag
private:
    friend gitlab::FMrNote&     mr_note_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FMrNote*     mr_note_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 mr_note_RemoveAll() __attribute__((nothrow));
    friend void                 mr_note_RemoveLast() __attribute__((nothrow));
    FMrNote();
    ~FMrNote();
    FMrNote(const FMrNote&){ /*disallow copy constructor */}
    void operator =(const FMrNote&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 mr_note_CopyOut(gitlab::FMrNote &row, gitlab::MrNote &out) __attribute__((nothrow));
// Copy fields in to row
void                 mr_note_CopyIn(gitlab::FMrNote &row, gitlab::MrNote &in) __attribute__((nothrow));

algo::Smallstr50     mr_Get(gitlab::FMrNote& mr_note) __attribute__((__warn_unused_result__, nothrow));

u32                  id_Get(gitlab::FMrNote& mr_note) __attribute__((__warn_unused_result__, nothrow));

// Set all fields to initial values.
void                 FMrNote_Init(gitlab::FMrNote& mr_note);
void                 FMrNote_Uninit(gitlab::FMrNote& mr_note) __attribute__((nothrow));

// --- gitlab.FProject
// create: gitlab.FDb.project (Lary)
// global access: ind_project (Thash)
// access: gitlab.FIssue.p_project (Upptr)
// access: gitlab.FMr.p_project (Upptr)
struct FProject { // gitlab.FProject
    gitlab::FProject*   ind_project_next;    // hash next
    algo::Smallstr50    gitlab_project;      //
    algo::Smallstr200   url;                 //
    algo::Comment       comment;             //
    u32                 gitlab_project_id;   //   0  Numeric project ID on gitlab server, displayed on project overview Web page
    gitlab::FIssue**    c_issue_elems;       // array of pointers
    u32                 c_issue_n;           // array of pointers
    u32                 c_issue_max;         // capacity of allocated array
    gitlab::FMr**       c_mr_elems;          // array of pointers
    u32                 c_mr_n;              // array of pointers
    u32                 c_mr_max;            // capacity of allocated array
private:
    friend gitlab::FProject&    project_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FProject*    project_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 project_RemoveAll() __attribute__((nothrow));
    friend void                 project_RemoveLast() __attribute__((nothrow));
    FProject();
    ~FProject();
    FProject(const FProject&){ /*disallow copy constructor */}
    void operator =(const FProject&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 project_CopyOut(gitlab::FProject &row, dev::GitlabProject &out) __attribute__((nothrow));
// Copy fields in to row
void                 project_CopyIn(gitlab::FProject &row, dev::GitlabProject &in) __attribute__((nothrow));

// Return true if index is empty
bool                 c_issue_EmptyQ(gitlab::FProject& project) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FIssue*      c_issue_Find(gitlab::FProject& project, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gitlab::FIssue*> c_issue_Getary(gitlab::FProject& project) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_issue_Insert(gitlab::FProject& project, gitlab::FIssue& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_issue_InsertMaybe(gitlab::FProject& project, gitlab::FIssue& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_issue_N(const gitlab::FProject& project) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_issue_Remove(gitlab::FProject& project, gitlab::FIssue& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_issue_RemoveAll(gitlab::FProject& project) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_issue_Reserve(gitlab::FProject& project, u32 n) __attribute__((nothrow));

// Return true if index is empty
bool                 c_mr_EmptyQ(gitlab::FProject& project) __attribute__((nothrow));
// Look up row by row id. Return NULL if out of range
gitlab::FMr*         c_mr_Find(gitlab::FProject& project, u32 t) __attribute__((__warn_unused_result__, nothrow));
// Return array of pointers
algo::aryptr<gitlab::FMr*> c_mr_Getary(gitlab::FProject& project) __attribute__((nothrow));
// Insert pointer to row into array. Row must not already be in array.
// If pointer is already in the array, it may be inserted twice.
void                 c_mr_Insert(gitlab::FProject& project, gitlab::FMr& row) __attribute__((nothrow));
// Insert pointer to row in array.
// If row is already in the array, do nothing.
// Return value: whether element was inserted into array.
bool                 c_mr_InsertMaybe(gitlab::FProject& project, gitlab::FMr& row) __attribute__((nothrow));
// Return number of items in the pointer array
i32                  c_mr_N(const gitlab::FProject& project) __attribute__((__warn_unused_result__, nothrow, pure));
// Find element using linear scan. If element is in array, remove, otherwise do nothing
void                 c_mr_Remove(gitlab::FProject& project, gitlab::FMr& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
void                 c_mr_RemoveAll(gitlab::FProject& project) __attribute__((nothrow));
// Reserve space in index for N more elements;
void                 c_mr_Reserve(gitlab::FProject& project, u32 n) __attribute__((nothrow));

// Set all fields to initial values.
void                 FProject_Init(gitlab::FProject& project);
void                 project_c_issue_curs_Reset(project_c_issue_curs &curs, gitlab::FProject &parent);
// cursor points to valid item
bool                 project_c_issue_curs_ValidQ(project_c_issue_curs &curs);
// proceed to next item
void                 project_c_issue_curs_Next(project_c_issue_curs &curs);
// item access
gitlab::FIssue&      project_c_issue_curs_Access(project_c_issue_curs &curs);
void                 project_c_mr_curs_Reset(project_c_mr_curs &curs, gitlab::FProject &parent);
// cursor points to valid item
bool                 project_c_mr_curs_ValidQ(project_c_mr_curs &curs);
// proceed to next item
void                 project_c_mr_curs_Next(project_c_mr_curs &curs);
// item access
gitlab::FMr&         project_c_mr_curs_Access(project_c_mr_curs &curs);
void                 FProject_Uninit(gitlab::FProject& project) __attribute__((nothrow));

// --- gitlab.FUser
// create: gitlab.FDb.user (Lary)
// global access: ind_user (Thash)
struct FUser { // gitlab.FUser
    gitlab::FUser*     ind_user_next;   // hash next
    algo::Smallstr50   user;            //
    u32                id;              //   0
    algo::cstring      name;            //
private:
    friend gitlab::FUser&       user_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend gitlab::FUser*       user_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 user_RemoveAll() __attribute__((nothrow));
    friend void                 user_RemoveLast() __attribute__((nothrow));
    FUser();
    ~FUser();
    FUser(const FUser&){ /*disallow copy constructor */}
    void operator =(const FUser&){ /*disallow direct assignment */}
};

// Copy fields out of row
void                 user_CopyOut(gitlab::FUser &row, gitlab::User &out) __attribute__((nothrow));
// Copy fields in to row
void                 user_CopyIn(gitlab::FUser &row, gitlab::User &in) __attribute__((nothrow));

// Set all fields to initial values.
void                 FUser_Init(gitlab::FUser& user);
void                 FUser_Uninit(gitlab::FUser& user) __attribute__((nothrow));

// --- gitlab.FieldId
#pragma pack(push,1)
struct FieldId { // gitlab.FieldId: Field read helper
    i32   value;   //   -1
    inline operator gitlab_FieldIdEnum() const;
    explicit FieldId(i32                            in_value);
    FieldId(gitlab_FieldIdEnum arg);
    FieldId();
};
#pragma pack(pop)

// Get value of field as enum type
gitlab_FieldIdEnum   value_GetEnum(const gitlab::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(gitlab::FieldId& parent, gitlab_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const gitlab::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const gitlab::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(gitlab::FieldId& parent, algo::strptr rhs, gitlab_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(gitlab::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of gitlab::FieldId from an ascii string.
// The format of the string is the format of the gitlab::FieldId's only field
bool                 FieldId_ReadStrptrMaybe(gitlab::FieldId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 FieldId_Init(gitlab::FieldId& parent);
// print string representation of gitlab::FieldId to string LHS, no header -- cprint:gitlab.FieldId.String
void                 FieldId_Print(gitlab::FieldId & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.Issue
// access: gitlab.FIssue.base (Base)
struct Issue { // gitlab.Issue: Gitlab project issue
    algo::Smallstr50   issue;      // Identifier. must be in form project.iid
    algo::Smallstr50   assignee;   // User the issue is assigned to
    algo::cstring      title;      // Issue title
    Issue();
};

algo::Smallstr50     project_Get(gitlab::Issue& parent) __attribute__((__warn_unused_result__, nothrow));

u32                  iid_Get(gitlab::Issue& parent) __attribute__((__warn_unused_result__, nothrow));

tempstr              Issue_Concat_project_iid( const algo::strptr& project ,u32 iid );
// print string representation of gitlab::Issue to string LHS, no header -- cprint:gitlab.Issue.String
void                 Issue_Print(gitlab::Issue & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.IssueDescription
// access: gitlab.FIssueDescription.base (Base)
struct IssueDescription { // gitlab.IssueDescription: Issue description
    algo::Smallstr50   issue;         //
    algo::cstring      description;   //
    IssueDescription();
};

// print string representation of gitlab::IssueDescription to string LHS, no header -- cprint:gitlab.IssueDescription.String
void                 IssueDescription_Print(gitlab::IssueDescription & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.IssueNote
// access: gitlab.FIssueNote.base (Base)
struct IssueNote { // gitlab.IssueNote: Issue note
    algo::Smallstr50   issue_note;   // Identifier. must be in form issue.id
    algo::cstring      body;         // Body of issue note
    IssueNote();
};

algo::Smallstr50     issue_Get(gitlab::IssueNote& parent) __attribute__((__warn_unused_result__, nothrow));

u32                  id_Get(gitlab::IssueNote& parent) __attribute__((__warn_unused_result__, nothrow));

tempstr              IssueNote_Concat_issue_id( const algo::strptr& issue ,u32 id );
// print string representation of gitlab::IssueNote to string LHS, no header -- cprint:gitlab.IssueNote.String
void                 IssueNote_Print(gitlab::IssueNote & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.Mr
// access: gitlab.FMr.base (Base)
struct Mr { // gitlab.Mr: Gitlab project mr
    algo::Smallstr50   mr;                // Identifier. must be in form project.iid
    algo::cstring      title;             // Mr title
    algo::cstring      source_branch;     // Source branch
    algo::Smallstr20   pipeline_status;   // Pipeline status
    Mr();
};

algo::Smallstr50     project_Get(gitlab::Mr& parent) __attribute__((__warn_unused_result__, nothrow));

u32                  iid_Get(gitlab::Mr& parent) __attribute__((__warn_unused_result__, nothrow));

tempstr              Mr_Concat_project_iid( const algo::strptr& project ,u32 iid );
// print string representation of gitlab::Mr to string LHS, no header -- cprint:gitlab.Mr.String
void                 Mr_Print(gitlab::Mr & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.MrDescription
// access: gitlab.FMrDescription.base (Base)
struct MrDescription { // gitlab.MrDescription: Mr description
    algo::Smallstr50   mr;            //
    algo::cstring      description;   //
    MrDescription();
};

// print string representation of gitlab::MrDescription to string LHS, no header -- cprint:gitlab.MrDescription.String
void                 MrDescription_Print(gitlab::MrDescription & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.MrNote
// access: gitlab.FMrNote.base (Base)
struct MrNote { // gitlab.MrNote: Mr note
    algo::Smallstr50   mr_note;   // Identifier. must be in form mr.id
    algo::cstring      body;      // Body of mr note
    MrNote();
};

algo::Smallstr50     mr_Get(gitlab::MrNote& parent) __attribute__((__warn_unused_result__, nothrow));

u32                  id_Get(gitlab::MrNote& parent) __attribute__((__warn_unused_result__, nothrow));

tempstr              MrNote_Concat_mr_id( const algo::strptr& mr ,u32 id );
// print string representation of gitlab::MrNote to string LHS, no header -- cprint:gitlab.MrNote.String
void                 MrNote_Print(gitlab::MrNote & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.TableId
struct TableId { // gitlab.TableId: Index of table in this namespace
    i32   value;   //   -1  index of table
    inline operator gitlab_TableIdEnum() const;
    explicit TableId(i32                            in_value);
    TableId(gitlab_TableIdEnum arg);
    TableId();
};

// Get value of field as enum type
gitlab_TableIdEnum   value_GetEnum(const gitlab::TableId& parent) __attribute__((nothrow));
// Set value of field from enum type.
void                 value_SetEnum(gitlab::TableId& parent, gitlab_TableIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char*          value_ToCstr(const gitlab::TableId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void                 value_Print(const gitlab::TableId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool                 value_SetStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void                 value_SetStrptr(gitlab::TableId& parent, algo::strptr rhs, gitlab_TableIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
bool                 value_ReadStrptrMaybe(gitlab::TableId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of gitlab::TableId from an ascii string.
// The format of the string is the format of the gitlab::TableId's only field
bool                 TableId_ReadStrptrMaybe(gitlab::TableId &parent, algo::strptr in_str);
// Set all fields to initial values.
void                 TableId_Init(gitlab::TableId& parent);
// print string representation of gitlab::TableId to string LHS, no header -- cprint:gitlab.TableId.String
void                 TableId_Print(gitlab::TableId & row, algo::cstring &str) __attribute__((nothrow));

// --- gitlab.User
// access: gitlab.FUser.base (Base)
struct User { // gitlab.User
    algo::Smallstr50   user;   //
    u32                id;     //   0
    algo::cstring      name;   //
    User();
};

// Set all fields to initial values.
void                 User_Init(gitlab::User& parent);

struct _db_project_curs {// cursor
    typedef gitlab::FProject ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_project_curs(){ parent=NULL; index=0; }
};


struct _db_issue_curs {// cursor
    typedef gitlab::FIssue ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_issue_curs(){ parent=NULL; index=0; }
};


struct _db_issue_note_curs {// cursor
    typedef gitlab::FIssueNote ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_issue_note_curs(){ parent=NULL; index=0; }
};


struct _db_issue_description_curs {// cursor
    typedef gitlab::FIssueDescription ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_issue_description_curs(){ parent=NULL; index=0; }
};


struct _db_mr_curs {// cursor
    typedef gitlab::FMr ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_mr_curs(){ parent=NULL; index=0; }
};


struct _db_mr_note_curs {// cursor
    typedef gitlab::FMrNote ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_mr_note_curs(){ parent=NULL; index=0; }
};


struct _db_mr_description_curs {// cursor
    typedef gitlab::FMrDescription ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_mr_description_curs(){ parent=NULL; index=0; }
};


struct _db_user_curs {// cursor
    typedef gitlab::FUser ChildType;
    gitlab::FDb *parent;
    i64 index;
    _db_user_curs(){ parent=NULL; index=0; }
};


struct FHttp_request_header_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    FHttp_request_header_curs() { elems=NULL; n_elems=0; index=0; }
};


struct FHttp_response_header_curs {// cursor
    typedef algo::cstring ChildType;
    algo::cstring* elems;
    int n_elems;
    int index;
    FHttp_response_header_curs() { elems=NULL; n_elems=0; index=0; }
};


struct issue_c_issue_note_curs {// cursor
    typedef gitlab::FIssueNote ChildType;
    gitlab::FIssueNote** elems;
    u32 n_elems;
    u32 index;
    issue_c_issue_note_curs() { elems=NULL; n_elems=0; index=0; }
};


struct mr_c_mr_note_curs {// cursor
    typedef gitlab::FMrNote ChildType;
    gitlab::FMrNote** elems;
    u32 n_elems;
    u32 index;
    mr_c_mr_note_curs() { elems=NULL; n_elems=0; index=0; }
};


struct project_c_issue_curs {// cursor
    typedef gitlab::FIssue ChildType;
    gitlab::FIssue** elems;
    u32 n_elems;
    u32 index;
    project_c_issue_curs() { elems=NULL; n_elems=0; index=0; }
};


struct project_c_mr_curs {// cursor
    typedef gitlab::FMr ChildType;
    gitlab::FMr** elems;
    u32 n_elems;
    u32 index;
    project_c_mr_curs() { elems=NULL; n_elems=0; index=0; }
};

int                  main(int argc, char **argv);
} // end namespace gitlab
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::trace &row);// cfmt:gitlab.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FHttp &row);// cfmt:gitlab.FHttp.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FIssue &row);// cfmt:gitlab.FIssue.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FMr &row);// cfmt:gitlab.FMr.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::FieldId &row);// cfmt:gitlab.FieldId.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::Issue &row);// cfmt:gitlab.Issue.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::IssueDescription &row);// cfmt:gitlab.IssueDescription.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::IssueNote &row);// cfmt:gitlab.IssueNote.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::Mr &row);// cfmt:gitlab.Mr.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::MrDescription &row);// cfmt:gitlab.MrDescription.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::MrNote &row);// cfmt:gitlab.MrNote.String
inline algo::cstring &operator <<(algo::cstring &str, const gitlab::TableId &row);// cfmt:gitlab.TableId.String
}
