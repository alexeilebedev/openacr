//
// include/gen/lib_ams_gen.inl.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/ams_gen.inl.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/algo_lib_gen.inl.h"
#include "include/gen/amsdb_gen.inl.h"
//#pragma endinclude
inline lib_ams::CtlConnCase::CtlConnCase(u32                            in_value)
    : value(in_value)
{
}
inline lib_ams::CtlConnCase::CtlConnCase(lib_ams_CtlConnCaseEnum arg) { this->value = u32(arg); }
inline lib_ams::CtlConnCase::CtlConnCase() {
    lib_ams::CtlConnCase_Init(*this);
}


// --- lib_ams.CtlConnCase.value.GetEnum
// Get value of field as enum type
inline lib_ams_CtlConnCaseEnum lib_ams::value_GetEnum(const lib_ams::CtlConnCase& parent) {
    return lib_ams_CtlConnCaseEnum(parent.value);
}

// --- lib_ams.CtlConnCase.value.SetEnum
// Set value of field from enum type.
inline void lib_ams::value_SetEnum(lib_ams::CtlConnCase& parent, lib_ams_CtlConnCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- lib_ams.CtlConnCase.value.Cast
inline lib_ams::CtlConnCase::operator lib_ams_CtlConnCaseEnum () const {
    return lib_ams_CtlConnCaseEnum((*this).value);
}

// --- lib_ams.CtlConnCase..Init
// Set all fields to initial values.
inline void lib_ams::CtlConnCase_Init(lib_ams::CtlConnCase& parent) {
    parent.value = u32(0);
}
inline lib_ams::CtlMsgCase::CtlMsgCase(u32                            in_value)
    : value(in_value)
{
}
inline lib_ams::CtlMsgCase::CtlMsgCase(lib_ams_CtlMsgCaseEnum arg) { this->value = u32(arg); }
inline lib_ams::CtlMsgCase::CtlMsgCase() {
    lib_ams::CtlMsgCase_Init(*this);
}


// --- lib_ams.CtlMsgCase.value.GetEnum
// Get value of field as enum type
inline lib_ams_CtlMsgCaseEnum lib_ams::value_GetEnum(const lib_ams::CtlMsgCase& parent) {
    return lib_ams_CtlMsgCaseEnum(parent.value);
}

// --- lib_ams.CtlMsgCase.value.SetEnum
// Set value of field from enum type.
inline void lib_ams::value_SetEnum(lib_ams::CtlMsgCase& parent, lib_ams_CtlMsgCaseEnum rhs) {
    parent.value = u32(rhs);
}

// --- lib_ams.CtlMsgCase.value.Cast
inline lib_ams::CtlMsgCase::operator lib_ams_CtlMsgCaseEnum () const {
    return lib_ams_CtlMsgCaseEnum((*this).value);
}

// --- lib_ams.CtlMsgCase..Init
// Set all fields to initial values.
inline void lib_ams::CtlMsgCase_Init(lib_ams::CtlMsgCase& parent) {
    parent.value = u32(0);
}
inline lib_ams::trace::trace() {
    lib_ams::trace_Init(*this);
}


// --- lib_ams.trace..Init
// Set all fields to initial values.
inline void lib_ams::trace_Init(lib_ams::trace& parent) {
    parent.n_fdin_drop_notgt = u64(0);
    parent.n_fdin_posted = u64(0);
    parent.n_fdin_pushback = u64(0);
    parent.n_write_block_spin = u64(0);
}

// --- lib_ams.FDb.fdin.EmptyQ
// Return true if index is empty
inline bool lib_ams::fdin_EmptyQ() {
    return _db.fdin_n == 0;
}

// --- lib_ams.FDb.fdin.Find
// Look up row by row id. Return NULL if out of range
inline lib_ams::FFdin* lib_ams::fdin_Find(u64 t) {
    lib_ams::FFdin *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.fdin_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.fdin_lary[bsr][index];
    }
    return retval;
}

// --- lib_ams.FDb.fdin.Last
// Return pointer to last element of array, or NULL if array is empty
inline lib_ams::FFdin* lib_ams::fdin_Last() {
    return fdin_Find(u64(_db.fdin_n-1));
}

// --- lib_ams.FDb.fdin.N
// Return number of items in the pool
inline i32 lib_ams::fdin_N() {
    return _db.fdin_n;
}

// --- lib_ams.FDb.fdin.qFind
// 'quick' Access row by row id. No bounds checking.
inline lib_ams::FFdin& lib_ams::fdin_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.fdin_lary[bsr][index];
}

// --- lib_ams.FDb.cd_fdin_eof.EmptyQ
// Return true if index is empty
inline bool lib_ams::cd_fdin_eof_EmptyQ() {
    return _db.cd_fdin_eof_head == NULL;
}

// --- lib_ams.FDb.cd_fdin_eof.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FFdin* lib_ams::cd_fdin_eof_First() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head;
    return row;
}

// --- lib_ams.FDb.cd_fdin_eof.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::cd_fdin_eof_InLlistQ(lib_ams::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_eof_next == (lib_ams::FFdin*)-1);
    return result;
}

// --- lib_ams.FDb.cd_fdin_eof.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FFdin* lib_ams::cd_fdin_eof_Last() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head ? _db.cd_fdin_eof_head->cd_fdin_eof_prev : NULL;
    return row;
}

// --- lib_ams.FDb.cd_fdin_eof.N
// Return number of items in the linked list
inline i32 lib_ams::cd_fdin_eof_N() {
    return _db.cd_fdin_eof_n;
}

// --- lib_ams.FDb.cd_fdin_eof.Next
// Return pointer to next element in the list
inline lib_ams::FFdin* lib_ams::cd_fdin_eof_Next(lib_ams::FFdin &row) {
    return row.cd_fdin_eof_next;
}

// --- lib_ams.FDb.cd_fdin_eof.Prev
// Return pointer to previous element in the list
inline lib_ams::FFdin* lib_ams::cd_fdin_eof_Prev(lib_ams::FFdin &row) {
    return row.cd_fdin_eof_prev;
}

// --- lib_ams.FDb.cd_fdin_eof.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FFdin& lib_ams::cd_fdin_eof_qLast() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_eof_head ? _db.cd_fdin_eof_head->cd_fdin_eof_prev : NULL;
    return *row;
}

// --- lib_ams.FDb.cd_fdin_read.EmptyQ
// Return true if index is empty
inline bool lib_ams::cd_fdin_read_EmptyQ() {
    return _db.cd_fdin_read_head == NULL;
}

// --- lib_ams.FDb.cd_fdin_read.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FFdin* lib_ams::cd_fdin_read_First() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_read_head;
    return row;
}

// --- lib_ams.FDb.cd_fdin_read.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::cd_fdin_read_InLlistQ(lib_ams::FFdin& row) {
    bool result = false;
    result = !(row.cd_fdin_read_next == (lib_ams::FFdin*)-1);
    return result;
}

// --- lib_ams.FDb.cd_fdin_read.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FFdin* lib_ams::cd_fdin_read_Last() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_read_head ? _db.cd_fdin_read_head->cd_fdin_read_prev : NULL;
    return row;
}

// --- lib_ams.FDb.cd_fdin_read.N
// Return number of items in the linked list
inline i32 lib_ams::cd_fdin_read_N() {
    return _db.cd_fdin_read_n;
}

// --- lib_ams.FDb.cd_fdin_read.Next
// Return pointer to next element in the list
inline lib_ams::FFdin* lib_ams::cd_fdin_read_Next(lib_ams::FFdin &row) {
    return row.cd_fdin_read_next;
}

// --- lib_ams.FDb.cd_fdin_read.Prev
// Return pointer to previous element in the list
inline lib_ams::FFdin* lib_ams::cd_fdin_read_Prev(lib_ams::FFdin &row) {
    return row.cd_fdin_read_prev;
}

// --- lib_ams.FDb.cd_fdin_read.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FFdin& lib_ams::cd_fdin_read_qLast() {
    lib_ams::FFdin *row = NULL;
    row = _db.cd_fdin_read_head ? _db.cd_fdin_read_head->cd_fdin_read_prev : NULL;
    return *row;
}

// --- lib_ams.FDb.zd_flush.EmptyQ
// Return true if index is empty
inline bool lib_ams::zd_flush_EmptyQ() {
    return _db.zd_flush_head == NULL;
}

// --- lib_ams.FDb.zd_flush.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FWritefile* lib_ams::zd_flush_First() {
    lib_ams::FWritefile *row = NULL;
    row = _db.zd_flush_head;
    return row;
}

// --- lib_ams.FDb.zd_flush.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::zd_flush_InLlistQ(lib_ams::FWritefile& row) {
    bool result = false;
    result = !(row.zd_flush_next == (lib_ams::FWritefile*)-1);
    return result;
}

// --- lib_ams.FDb.zd_flush.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FWritefile* lib_ams::zd_flush_Last() {
    lib_ams::FWritefile *row = NULL;
    row = _db.zd_flush_tail;
    return row;
}

// --- lib_ams.FDb.zd_flush.N
// Return number of items in the linked list
inline i32 lib_ams::zd_flush_N() {
    return _db.zd_flush_n;
}

// --- lib_ams.FDb.zd_flush.Next
// Return pointer to next element in the list
inline lib_ams::FWritefile* lib_ams::zd_flush_Next(lib_ams::FWritefile &row) {
    return row.zd_flush_next;
}

// --- lib_ams.FDb.zd_flush.Prev
// Return pointer to previous element in the list
inline lib_ams::FWritefile* lib_ams::zd_flush_Prev(lib_ams::FWritefile &row) {
    return row.zd_flush_prev;
}

// --- lib_ams.FDb.zd_flush.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FWritefile& lib_ams::zd_flush_qLast() {
    lib_ams::FWritefile *row = NULL;
    row = _db.zd_flush_tail;
    return *row;
}

// --- lib_ams.FDb.stream.EmptyQ
// Return true if index is empty
inline bool lib_ams::stream_EmptyQ() {
    return _db.stream_n == 0;
}

// --- lib_ams.FDb.stream.Find
// Look up row by row id. Return NULL if out of range
inline lib_ams::FStream* lib_ams::stream_Find(u64 t) {
    lib_ams::FStream *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.stream_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.stream_lary[bsr][index];
    }
    return retval;
}

// --- lib_ams.FDb.stream.Last
// Return pointer to last element of array, or NULL if array is empty
inline lib_ams::FStream* lib_ams::stream_Last() {
    return stream_Find(u64(_db.stream_n-1));
}

// --- lib_ams.FDb.stream.N
// Return number of items in the pool
inline i32 lib_ams::stream_N() {
    return _db.stream_n;
}

// --- lib_ams.FDb.stream.qFind
// 'quick' Access row by row id. No bounds checking.
inline lib_ams::FStream& lib_ams::stream_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.stream_lary[bsr][index];
}

// --- lib_ams.FDb.ind_stream.EmptyQ
// Return true if hash is empty
inline bool lib_ams::ind_stream_EmptyQ() {
    return _db.ind_stream_n == 0;
}

// --- lib_ams.FDb.ind_stream.N
// Return number of items in the hash
inline i32 lib_ams::ind_stream_N() {
    return _db.ind_stream_n;
}

// --- lib_ams.FDb.cd_stream_hb.EmptyQ
// Return true if index is empty
inline bool lib_ams::cd_stream_hb_EmptyQ() {
    return _db.cd_stream_hb_head == NULL;
}

// --- lib_ams.FDb.cd_stream_hb.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FStream* lib_ams::cd_stream_hb_First() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_stream_hb_head;
    return row;
}

// --- lib_ams.FDb.cd_stream_hb.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::cd_stream_hb_InLlistQ(lib_ams::FStream& row) {
    bool result = false;
    result = !(row.cd_stream_hb_next == (lib_ams::FStream*)-1);
    return result;
}

// --- lib_ams.FDb.cd_stream_hb.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FStream* lib_ams::cd_stream_hb_Last() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_stream_hb_head ? _db.cd_stream_hb_head->cd_stream_hb_prev : NULL;
    return row;
}

// --- lib_ams.FDb.cd_stream_hb.N
// Return number of items in the linked list
inline i32 lib_ams::cd_stream_hb_N() {
    return _db.cd_stream_hb_n;
}

// --- lib_ams.FDb.cd_stream_hb.Next
// Return pointer to next element in the list
inline lib_ams::FStream* lib_ams::cd_stream_hb_Next(lib_ams::FStream &row) {
    return row.cd_stream_hb_next;
}

// --- lib_ams.FDb.cd_stream_hb.Prev
// Return pointer to previous element in the list
inline lib_ams::FStream* lib_ams::cd_stream_hb_Prev(lib_ams::FStream &row) {
    return row.cd_stream_hb_prev;
}

// --- lib_ams.FDb.cd_stream_hb.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FStream& lib_ams::cd_stream_hb_qLast() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_stream_hb_head ? _db.cd_stream_hb_head->cd_stream_hb_prev : NULL;
    return *row;
}

// --- lib_ams.FDb.cd_poll_read.EmptyQ
// Return true if index is empty
inline bool lib_ams::cd_poll_read_EmptyQ() {
    return _db.cd_poll_read_head == NULL;
}

// --- lib_ams.FDb.cd_poll_read.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FStream* lib_ams::cd_poll_read_First() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_poll_read_head;
    return row;
}

// --- lib_ams.FDb.cd_poll_read.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::cd_poll_read_InLlistQ(lib_ams::FStream& row) {
    bool result = false;
    result = !(row.cd_poll_read_next == (lib_ams::FStream*)-1);
    return result;
}

// --- lib_ams.FDb.cd_poll_read.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FStream* lib_ams::cd_poll_read_Last() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_poll_read_head ? _db.cd_poll_read_head->cd_poll_read_prev : NULL;
    return row;
}

// --- lib_ams.FDb.cd_poll_read.N
// Return number of items in the linked list
inline i32 lib_ams::cd_poll_read_N() {
    return _db.cd_poll_read_n;
}

// --- lib_ams.FDb.cd_poll_read.Next
// Return pointer to next element in the list
inline lib_ams::FStream* lib_ams::cd_poll_read_Next(lib_ams::FStream &row) {
    return row.cd_poll_read_next;
}

// --- lib_ams.FDb.cd_poll_read.Prev
// Return pointer to previous element in the list
inline lib_ams::FStream* lib_ams::cd_poll_read_Prev(lib_ams::FStream &row) {
    return row.cd_poll_read_prev;
}

// --- lib_ams.FDb.cd_poll_read.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FStream& lib_ams::cd_poll_read_qLast() {
    lib_ams::FStream *row = NULL;
    row = _db.cd_poll_read_head ? _db.cd_poll_read_head->cd_poll_read_prev : NULL;
    return *row;
}

// --- lib_ams.FDb.ind_proc.EmptyQ
// Return true if hash is empty
inline bool lib_ams::ind_proc_EmptyQ() {
    return _db.ind_proc_n == 0;
}

// --- lib_ams.FDb.ind_proc.N
// Return number of items in the hash
inline i32 lib_ams::ind_proc_N() {
    return _db.ind_proc_n;
}

// --- lib_ams.FDb.ind_member.EmptyQ
// Return true if hash is empty
inline bool lib_ams::ind_member_EmptyQ() {
    return _db.ind_member_n == 0;
}

// --- lib_ams.FDb.ind_member.N
// Return number of items in the hash
inline i32 lib_ams::ind_member_N() {
    return _db.ind_member_n;
}

// --- lib_ams.FDb.streamtype.EmptyQ
// Return true if index is empty
inline bool lib_ams::streamtype_EmptyQ() {
    return _db.streamtype_n == 0;
}

// --- lib_ams.FDb.streamtype.Find
// Look up row by row id. Return NULL if out of range
inline lib_ams::FStreamType* lib_ams::streamtype_Find(u64 t) {
    lib_ams::FStreamType *retval = NULL;
    if (LIKELY(u64(t) < u64(_db.streamtype_n))) {
        u64 x = t + 1;
        u64 bsr   = algo::u64_BitScanReverse(x);
        u64 base  = u64(1)<<bsr;
        u64 index = x-base;
        retval = &_db.streamtype_lary[bsr][index];
    }
    return retval;
}

// --- lib_ams.FDb.streamtype.Last
// Return pointer to last element of array, or NULL if array is empty
inline lib_ams::FStreamType* lib_ams::streamtype_Last() {
    return streamtype_Find(u64(_db.streamtype_n-1));
}

// --- lib_ams.FDb.streamtype.N
// Return number of items in the pool
inline i32 lib_ams::streamtype_N() {
    return _db.streamtype_n;
}

// --- lib_ams.FDb.streamtype.qFind
// 'quick' Access row by row id. No bounds checking.
inline lib_ams::FStreamType& lib_ams::streamtype_qFind(u64 t) {
    u64 x = t + 1;
    u64 bsr   = algo::u64_BitScanReverse(x);
    u64 base  = u64(1)<<bsr;
    u64 index = x-base;
    return _db.streamtype_lary[bsr][index];
}

// --- lib_ams.FDb.ind_streamtype.EmptyQ
// Return true if hash is empty
inline bool lib_ams::ind_streamtype_EmptyQ() {
    return _db.ind_streamtype_n == 0;
}

// --- lib_ams.FDb.ind_streamtype.N
// Return number of items in the hash
inline i32 lib_ams::ind_streamtype_N() {
    return _db.ind_streamtype_n;
}

// --- lib_ams.FDb.zd_ctlin.EmptyQ
// Return true if index is empty
inline bool lib_ams::zd_ctlin_EmptyQ() {
    return _db.zd_ctlin_head == NULL;
}

// --- lib_ams.FDb.zd_ctlin.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FStream* lib_ams::zd_ctlin_First() {
    lib_ams::FStream *row = NULL;
    row = _db.zd_ctlin_head;
    return row;
}

// --- lib_ams.FDb.zd_ctlin.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::zd_ctlin_InLlistQ(lib_ams::FStream& row) {
    bool result = false;
    result = !(row.zd_ctlin_next == (lib_ams::FStream*)-1);
    return result;
}

// --- lib_ams.FDb.zd_ctlin.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FStream* lib_ams::zd_ctlin_Last() {
    lib_ams::FStream *row = NULL;
    row = _db.zd_ctlin_tail;
    return row;
}

// --- lib_ams.FDb.zd_ctlin.N
// Return number of items in the linked list
inline i32 lib_ams::zd_ctlin_N() {
    return _db.zd_ctlin_n;
}

// --- lib_ams.FDb.zd_ctlin.Next
// Return pointer to next element in the list
inline lib_ams::FStream* lib_ams::zd_ctlin_Next(lib_ams::FStream &row) {
    return row.zd_ctlin_next;
}

// --- lib_ams.FDb.zd_ctlin.Prev
// Return pointer to previous element in the list
inline lib_ams::FStream* lib_ams::zd_ctlin_Prev(lib_ams::FStream &row) {
    return row.zd_ctlin_prev;
}

// --- lib_ams.FDb.zd_ctlin.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FStream& lib_ams::zd_ctlin_qLast() {
    lib_ams::FStream *row = NULL;
    row = _db.zd_ctlin_tail;
    return *row;
}

// --- lib_ams.FDb.zd_proc.EmptyQ
// Return true if index is empty
inline bool lib_ams::zd_proc_EmptyQ() {
    return _db.zd_proc_head == NULL;
}

// --- lib_ams.FDb.zd_proc.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FProc* lib_ams::zd_proc_First() {
    lib_ams::FProc *row = NULL;
    row = _db.zd_proc_head;
    return row;
}

// --- lib_ams.FDb.zd_proc.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::zd_proc_InLlistQ(lib_ams::FProc& row) {
    bool result = false;
    result = !(row.zd_proc_next == (lib_ams::FProc*)-1);
    return result;
}

// --- lib_ams.FDb.zd_proc.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FProc* lib_ams::zd_proc_Last() {
    lib_ams::FProc *row = NULL;
    row = _db.zd_proc_tail;
    return row;
}

// --- lib_ams.FDb.zd_proc.N
// Return number of items in the linked list
inline i32 lib_ams::zd_proc_N() {
    return _db.zd_proc_n;
}

// --- lib_ams.FDb.zd_proc.Next
// Return pointer to next element in the list
inline lib_ams::FProc* lib_ams::zd_proc_Next(lib_ams::FProc &row) {
    return row.zd_proc_next;
}

// --- lib_ams.FDb.zd_proc.Prev
// Return pointer to previous element in the list
inline lib_ams::FProc* lib_ams::zd_proc_Prev(lib_ams::FProc &row) {
    return row.zd_proc_prev;
}

// --- lib_ams.FDb.zd_proc.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FProc& lib_ams::zd_proc_qLast() {
    lib_ams::FProc *row = NULL;
    row = _db.zd_proc_tail;
    return *row;
}

// --- lib_ams.FDb.fdin_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_fdin_curs_Reset(_db_fdin_curs &curs, lib_ams::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- lib_ams.FDb.fdin_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_fdin_curs_ValidQ(_db_fdin_curs &curs) {
    return curs.index < _db.fdin_n;
}

// --- lib_ams.FDb.fdin_curs.Next
// proceed to next item
inline void lib_ams::_db_fdin_curs_Next(_db_fdin_curs &curs) {
    curs.index++;
}

// --- lib_ams.FDb.fdin_curs.Access
// item access
inline lib_ams::FFdin& lib_ams::_db_fdin_curs_Access(_db_fdin_curs &curs) {
    return fdin_qFind(u64(curs.index));
}

// --- lib_ams.FDb.cd_fdin_eof_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_cd_fdin_eof_curs_Reset(_db_cd_fdin_eof_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.cd_fdin_eof_head;
    curs.head = &parent.cd_fdin_eof_head;
}

// --- lib_ams.FDb.cd_fdin_eof_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_cd_fdin_eof_curs_ValidQ(_db_cd_fdin_eof_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.cd_fdin_eof_curs.Next
// proceed to next item
inline void lib_ams::_db_cd_fdin_eof_curs_Next(_db_cd_fdin_eof_curs &curs) {
    lib_ams::FFdin *next = (*curs.row).cd_fdin_eof_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- lib_ams.FDb.cd_fdin_eof_curs.Access
// item access
inline lib_ams::FFdin& lib_ams::_db_cd_fdin_eof_curs_Access(_db_cd_fdin_eof_curs &curs) {
    return *curs.row;
}

// --- lib_ams.FDb.cd_fdin_read_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_cd_fdin_read_curs_Reset(_db_cd_fdin_read_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.cd_fdin_read_head;
    curs.head = &parent.cd_fdin_read_head;
}

// --- lib_ams.FDb.cd_fdin_read_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_cd_fdin_read_curs_ValidQ(_db_cd_fdin_read_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.cd_fdin_read_curs.Next
// proceed to next item
inline void lib_ams::_db_cd_fdin_read_curs_Next(_db_cd_fdin_read_curs &curs) {
    lib_ams::FFdin *next = (*curs.row).cd_fdin_read_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- lib_ams.FDb.cd_fdin_read_curs.Access
// item access
inline lib_ams::FFdin& lib_ams::_db_cd_fdin_read_curs_Access(_db_cd_fdin_read_curs &curs) {
    return *curs.row;
}

// --- lib_ams.FDb.zd_flush_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_zd_flush_curs_Reset(_db_zd_flush_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.zd_flush_head;
}

// --- lib_ams.FDb.zd_flush_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_zd_flush_curs_ValidQ(_db_zd_flush_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.zd_flush_curs.Next
// proceed to next item
inline void lib_ams::_db_zd_flush_curs_Next(_db_zd_flush_curs &curs) {
    lib_ams::FWritefile *next = (*curs.row).zd_flush_next;
    curs.row = next;
}

// --- lib_ams.FDb.zd_flush_curs.Access
// item access
inline lib_ams::FWritefile& lib_ams::_db_zd_flush_curs_Access(_db_zd_flush_curs &curs) {
    return *curs.row;
}

// --- lib_ams.FDb.stream_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_stream_curs_Reset(_db_stream_curs &curs, lib_ams::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- lib_ams.FDb.stream_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_stream_curs_ValidQ(_db_stream_curs &curs) {
    return curs.index < _db.stream_n;
}

// --- lib_ams.FDb.stream_curs.Next
// proceed to next item
inline void lib_ams::_db_stream_curs_Next(_db_stream_curs &curs) {
    curs.index++;
}

// --- lib_ams.FDb.stream_curs.Access
// item access
inline lib_ams::FStream& lib_ams::_db_stream_curs_Access(_db_stream_curs &curs) {
    return stream_qFind(u64(curs.index));
}

// --- lib_ams.FDb.cd_stream_hb_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_cd_stream_hb_curs_Reset(_db_cd_stream_hb_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.cd_stream_hb_head;
    curs.head = &parent.cd_stream_hb_head;
}

// --- lib_ams.FDb.cd_stream_hb_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_cd_stream_hb_curs_ValidQ(_db_cd_stream_hb_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.cd_stream_hb_curs.Next
// proceed to next item
inline void lib_ams::_db_cd_stream_hb_curs_Next(_db_cd_stream_hb_curs &curs) {
    lib_ams::FStream *next = (*curs.row).cd_stream_hb_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- lib_ams.FDb.cd_stream_hb_curs.Access
// item access
inline lib_ams::FStream& lib_ams::_db_cd_stream_hb_curs_Access(_db_cd_stream_hb_curs &curs) {
    return *curs.row;
}

// --- lib_ams.FDb.cd_poll_read_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_cd_poll_read_curs_Reset(_db_cd_poll_read_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.cd_poll_read_head;
    curs.head = &parent.cd_poll_read_head;
}

// --- lib_ams.FDb.cd_poll_read_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_cd_poll_read_curs_ValidQ(_db_cd_poll_read_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.cd_poll_read_curs.Next
// proceed to next item
inline void lib_ams::_db_cd_poll_read_curs_Next(_db_cd_poll_read_curs &curs) {
    lib_ams::FStream *next = (*curs.row).cd_poll_read_next;
    curs.row = next;
    if (curs.row == *curs.head) {
        curs.row = NULL;
    }
}

// --- lib_ams.FDb.cd_poll_read_curs.Access
// item access
inline lib_ams::FStream& lib_ams::_db_cd_poll_read_curs_Access(_db_cd_poll_read_curs &curs) {
    return *curs.row;
}

// --- lib_ams.FDb.streamtype_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_streamtype_curs_Reset(_db_streamtype_curs &curs, lib_ams::FDb &parent) {
    curs.parent = &parent;
    curs.index = 0;
}

// --- lib_ams.FDb.streamtype_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_streamtype_curs_ValidQ(_db_streamtype_curs &curs) {
    return curs.index < _db.streamtype_n;
}

// --- lib_ams.FDb.streamtype_curs.Next
// proceed to next item
inline void lib_ams::_db_streamtype_curs_Next(_db_streamtype_curs &curs) {
    curs.index++;
}

// --- lib_ams.FDb.streamtype_curs.Access
// item access
inline lib_ams::FStreamType& lib_ams::_db_streamtype_curs_Access(_db_streamtype_curs &curs) {
    return streamtype_qFind(u64(curs.index));
}

// --- lib_ams.FDb.zd_ctlin_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_zd_ctlin_curs_Reset(_db_zd_ctlin_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.zd_ctlin_head;
}

// --- lib_ams.FDb.zd_ctlin_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_zd_ctlin_curs_ValidQ(_db_zd_ctlin_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.zd_ctlin_curs.Next
// proceed to next item
inline void lib_ams::_db_zd_ctlin_curs_Next(_db_zd_ctlin_curs &curs) {
    lib_ams::FStream *next = (*curs.row).zd_ctlin_next;
    curs.row = next;
}

// --- lib_ams.FDb.zd_ctlin_curs.Access
// item access
inline lib_ams::FStream& lib_ams::_db_zd_ctlin_curs_Access(_db_zd_ctlin_curs &curs) {
    return *curs.row;
}

// --- lib_ams.FDb.zd_proc_curs.Reset
// cursor points to valid item
inline void lib_ams::_db_zd_proc_curs_Reset(_db_zd_proc_curs &curs, lib_ams::FDb &parent) {
    curs.row = parent.zd_proc_head;
}

// --- lib_ams.FDb.zd_proc_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::_db_zd_proc_curs_ValidQ(_db_zd_proc_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FDb.zd_proc_curs.Next
// proceed to next item
inline void lib_ams::_db_zd_proc_curs_Next(_db_zd_proc_curs &curs) {
    lib_ams::FProc *next = (*curs.row).zd_proc_next;
    curs.row = next;
}

// --- lib_ams.FDb.zd_proc_curs.Access
// item access
inline lib_ams::FProc& lib_ams::_db_zd_proc_curs_Access(_db_zd_proc_curs &curs) {
    return *curs.row;
}
inline lib_ams::FFdin::FFdin() {
    lib_ams::FFdin_Init(*this);
    // added because lib_ams.FFdin.in (Fbuf) does not need initialization
    // coverity[uninit_member]
}

inline lib_ams::FFdin::~FFdin() {
    lib_ams::FFdin_Uninit(*this);
}


// --- lib_ams.FFdin.in.Max
// Return max. number of bytes in the buffer.
inline i32 lib_ams::in_Max(lib_ams::FFdin& fdin) {
    return 8192;
    (void)fdin;//only to avoid -Wunused-parameter
}

// --- lib_ams.FFdin.in.N
// Return number of bytes in the buffer.
inline i32 lib_ams::in_N(lib_ams::FFdin& fdin) {
    return fdin.in_end - fdin.in_start;
}
inline lib_ams::FMember::FMember() {
    lib_ams::FMember_Init(*this);
}

inline lib_ams::FMember::~FMember() {
    lib_ams::FMember_Uninit(*this);
}


// --- lib_ams.FMember..Init
// Set all fields to initial values.
inline void lib_ams::FMember_Init(lib_ams::FMember& member) {
    member.budget = u32(0);
    member.p_stream = NULL;
    member.p_proc = NULL;
    member.member_next = (lib_ams::FMember*)-1; // (lib_ams.FDb.member) not-in-tpool's freelist
    member.ind_member_next = (lib_ams::FMember*)-1; // (lib_ams.FDb.ind_member) not-in-hash
    member.zd_member_byproc_next = (lib_ams::FMember*)-1; // (lib_ams.FProc.zd_member_byproc) not-in-list
    member.zd_member_byproc_prev = NULL; // (lib_ams.FProc.zd_member_byproc)
    member.zd_member_bystream_next = (lib_ams::FMember*)-1; // (lib_ams.FStream.zd_member_bystream) not-in-list
    member.zd_member_bystream_prev = NULL; // (lib_ams.FStream.zd_member_bystream)
}
inline lib_ams::FProc::FProc() {
    lib_ams::FProc_Init(*this);
}

inline lib_ams::FProc::~FProc() {
    lib_ams::FProc_Uninit(*this);
}


// --- lib_ams.FProc.zd_member_byproc.EmptyQ
// Return true if index is empty
inline bool lib_ams::zd_member_byproc_EmptyQ(lib_ams::FProc& proc) {
    return proc.zd_member_byproc_head == NULL;
}

// --- lib_ams.FProc.zd_member_byproc.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FMember* lib_ams::zd_member_byproc_First(lib_ams::FProc& proc) {
    lib_ams::FMember *row = NULL;
    row = proc.zd_member_byproc_head;
    return row;
}

// --- lib_ams.FProc.zd_member_byproc.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::zd_member_byproc_InLlistQ(lib_ams::FMember& row) {
    bool result = false;
    result = !(row.zd_member_byproc_next == (lib_ams::FMember*)-1);
    return result;
}

// --- lib_ams.FProc.zd_member_byproc.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FMember* lib_ams::zd_member_byproc_Last(lib_ams::FProc& proc) {
    lib_ams::FMember *row = NULL;
    row = proc.zd_member_byproc_tail;
    return row;
}

// --- lib_ams.FProc.zd_member_byproc.N
// Return number of items in the linked list
inline i32 lib_ams::zd_member_byproc_N(const lib_ams::FProc& proc) {
    return proc.zd_member_byproc_n;
}

// --- lib_ams.FProc.zd_member_byproc.Next
// Return pointer to next element in the list
inline lib_ams::FMember* lib_ams::zd_member_byproc_Next(lib_ams::FMember &row) {
    return row.zd_member_byproc_next;
}

// --- lib_ams.FProc.zd_member_byproc.Prev
// Return pointer to previous element in the list
inline lib_ams::FMember* lib_ams::zd_member_byproc_Prev(lib_ams::FMember &row) {
    return row.zd_member_byproc_prev;
}

// --- lib_ams.FProc.zd_member_byproc.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FMember& lib_ams::zd_member_byproc_qLast(lib_ams::FProc& proc) {
    lib_ams::FMember *row = NULL;
    row = proc.zd_member_byproc_tail;
    return *row;
}

// --- lib_ams.FProc..Init
// Set all fields to initial values.
inline void lib_ams::FProc_Init(lib_ams::FProc& proc) {
    proc.zd_member_byproc_head = NULL; // (lib_ams.FProc.zd_member_byproc)
    proc.zd_member_byproc_n = 0; // (lib_ams.FProc.zd_member_byproc)
    proc.zd_member_byproc_tail = NULL; // (lib_ams.FProc.zd_member_byproc)
    proc.pid = i32(0);
    proc.status = i32(0);
    proc.hbtimeout = u32(0);
    proc.critical = bool(false);
    proc.realtime = bool(false);
    proc.proc_next = (lib_ams::FProc*)-1; // (lib_ams.FDb.proc) not-in-tpool's freelist
    proc.ind_proc_next = (lib_ams::FProc*)-1; // (lib_ams.FDb.ind_proc) not-in-hash
    proc.zd_proc_next = (lib_ams::FProc*)-1; // (lib_ams.FDb.zd_proc) not-in-list
    proc.zd_proc_prev = NULL; // (lib_ams.FDb.zd_proc)
}

// --- lib_ams.FProc.zd_member_byproc_curs.Reset
// cursor points to valid item
inline void lib_ams::proc_zd_member_byproc_curs_Reset(proc_zd_member_byproc_curs &curs, lib_ams::FProc &parent) {
    curs.row = parent.zd_member_byproc_head;
}

// --- lib_ams.FProc.zd_member_byproc_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::proc_zd_member_byproc_curs_ValidQ(proc_zd_member_byproc_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FProc.zd_member_byproc_curs.Next
// proceed to next item
inline void lib_ams::proc_zd_member_byproc_curs_Next(proc_zd_member_byproc_curs &curs) {
    lib_ams::FMember *next = (*curs.row).zd_member_byproc_next;
    curs.row = next;
}

// --- lib_ams.FProc.zd_member_byproc_curs.Access
// item access
inline lib_ams::FMember& lib_ams::proc_zd_member_byproc_curs_Access(proc_zd_member_byproc_curs &curs) {
    return *curs.row;
}
inline lib_ams::FReadfile::FReadfile() {
    lib_ams::FReadfile_Init(*this);
}

inline lib_ams::FReadfile::~FReadfile() {
    lib_ams::FReadfile_Uninit(*this);
}


// --- lib_ams.FReadfile.buf.EmptyQ
// Return true if index is empty
inline bool lib_ams::buf_EmptyQ(lib_ams::FReadfile& parent) {
    return parent.buf_n == 0;
}

// --- lib_ams.FReadfile.buf.Find
// Look up row by row id. Return NULL if out of range
inline u8* lib_ams::buf_Find(lib_ams::FReadfile& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.buf_n;
    if (idx >= lim) return NULL;
    return parent.buf_elems + idx;
}

// --- lib_ams.FReadfile.buf.Getary
// Return array pointer by value
inline algo::aryptr<u8> lib_ams::buf_Getary(lib_ams::FReadfile& parent) {
    return algo::aryptr<u8>(parent.buf_elems, parent.buf_n);
}

// --- lib_ams.FReadfile.buf.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* lib_ams::buf_Last(lib_ams::FReadfile& parent) {
    return buf_Find(parent, u64(parent.buf_n-1));
}

// --- lib_ams.FReadfile.buf.Max
// Return max. number of items in the array
inline i32 lib_ams::buf_Max(lib_ams::FReadfile& parent) {
    (void)parent;
    return parent.buf_max;
}

// --- lib_ams.FReadfile.buf.N
// Return number of items in the array
inline i32 lib_ams::buf_N(const lib_ams::FReadfile& parent) {
    return parent.buf_n;
}

// --- lib_ams.FReadfile.buf.RemoveAll
inline void lib_ams::buf_RemoveAll(lib_ams::FReadfile& parent) {
    parent.buf_n = 0;
}

// --- lib_ams.FReadfile.buf.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void lib_ams::buf_Reserve(lib_ams::FReadfile& parent, int n) {
    u32 new_n = parent.buf_n + n;
    if (UNLIKELY(new_n > parent.buf_max)) {
        buf_AbsReserve(parent, new_n);
    }
}

// --- lib_ams.FReadfile.buf.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& lib_ams::buf_qFind(lib_ams::FReadfile& parent, u64 t) {
    return parent.buf_elems[t];
}

// --- lib_ams.FReadfile.buf.qLast
// Return reference to last element of array. No bounds checking
inline u8& lib_ams::buf_qLast(lib_ams::FReadfile& parent) {
    return buf_qFind(parent, u64(parent.buf_n-1));
}

// --- lib_ams.FReadfile.buf.rowid_Get
// Return row id of specified element
inline u64 lib_ams::buf_rowid_Get(lib_ams::FReadfile& parent, u8 &elem) {
    u64 id = &elem - parent.buf_elems;
    return u64(id);
}

// --- lib_ams.FReadfile.cbuf.EmptyQ
// Return true if index is empty
inline bool lib_ams::cbuf_EmptyQ(lib_ams::FReadfile& parent) {
    return parent.cbuf_n == 0;
}

// --- lib_ams.FReadfile.cbuf.Find
// Look up row by row id. Return NULL if out of range
inline u8* lib_ams::cbuf_Find(lib_ams::FReadfile& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.cbuf_n;
    if (idx >= lim) return NULL;
    return parent.cbuf_elems + idx;
}

// --- lib_ams.FReadfile.cbuf.Getary
// Return array pointer by value
inline algo::aryptr<u8> lib_ams::cbuf_Getary(lib_ams::FReadfile& parent) {
    return algo::aryptr<u8>(parent.cbuf_elems, parent.cbuf_n);
}

// --- lib_ams.FReadfile.cbuf.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* lib_ams::cbuf_Last(lib_ams::FReadfile& parent) {
    return cbuf_Find(parent, u64(parent.cbuf_n-1));
}

// --- lib_ams.FReadfile.cbuf.Max
// Return max. number of items in the array
inline i32 lib_ams::cbuf_Max(lib_ams::FReadfile& parent) {
    (void)parent;
    return parent.cbuf_max;
}

// --- lib_ams.FReadfile.cbuf.N
// Return number of items in the array
inline i32 lib_ams::cbuf_N(const lib_ams::FReadfile& parent) {
    return parent.cbuf_n;
}

// --- lib_ams.FReadfile.cbuf.RemoveAll
inline void lib_ams::cbuf_RemoveAll(lib_ams::FReadfile& parent) {
    parent.cbuf_n = 0;
}

// --- lib_ams.FReadfile.cbuf.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void lib_ams::cbuf_Reserve(lib_ams::FReadfile& parent, int n) {
    u32 new_n = parent.cbuf_n + n;
    if (UNLIKELY(new_n > parent.cbuf_max)) {
        cbuf_AbsReserve(parent, new_n);
    }
}

// --- lib_ams.FReadfile.cbuf.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& lib_ams::cbuf_qFind(lib_ams::FReadfile& parent, u64 t) {
    return parent.cbuf_elems[t];
}

// --- lib_ams.FReadfile.cbuf.qLast
// Return reference to last element of array. No bounds checking
inline u8& lib_ams::cbuf_qLast(lib_ams::FReadfile& parent) {
    return cbuf_qFind(parent, u64(parent.cbuf_n-1));
}

// --- lib_ams.FReadfile.cbuf.rowid_Get
// Return row id of specified element
inline u64 lib_ams::cbuf_rowid_Get(lib_ams::FReadfile& parent, u8 &elem) {
    u64 id = &elem - parent.cbuf_elems;
    return u64(id);
}

// --- lib_ams.FReadfile.offset.EmptyQ
// Return true if index is empty
inline bool lib_ams::offset_EmptyQ(lib_ams::FReadfile& parent) {
    return parent.offset_n == 0;
}

// --- lib_ams.FReadfile.offset.Find
// Look up row by row id. Return NULL if out of range
inline u32* lib_ams::offset_Find(lib_ams::FReadfile& parent, u64 t) {
    u64 idx = t;
    u64 lim = parent.offset_n;
    if (idx >= lim) return NULL;
    return parent.offset_elems + idx;
}

// --- lib_ams.FReadfile.offset.Getary
// Return array pointer by value
inline algo::aryptr<u32> lib_ams::offset_Getary(lib_ams::FReadfile& parent) {
    return algo::aryptr<u32>(parent.offset_elems, parent.offset_n);
}

// --- lib_ams.FReadfile.offset.Last
// Return pointer to last element of array, or NULL if array is empty
inline u32* lib_ams::offset_Last(lib_ams::FReadfile& parent) {
    return offset_Find(parent, u64(parent.offset_n-1));
}

// --- lib_ams.FReadfile.offset.Max
// Return max. number of items in the array
inline i32 lib_ams::offset_Max(lib_ams::FReadfile& parent) {
    (void)parent;
    return parent.offset_max;
}

// --- lib_ams.FReadfile.offset.N
// Return number of items in the array
inline i32 lib_ams::offset_N(const lib_ams::FReadfile& parent) {
    return parent.offset_n;
}

// --- lib_ams.FReadfile.offset.RemoveAll
inline void lib_ams::offset_RemoveAll(lib_ams::FReadfile& parent) {
    parent.offset_n = 0;
}

// --- lib_ams.FReadfile.offset.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void lib_ams::offset_Reserve(lib_ams::FReadfile& parent, int n) {
    u32 new_n = parent.offset_n + n;
    if (UNLIKELY(new_n > parent.offset_max)) {
        offset_AbsReserve(parent, new_n);
    }
}

// --- lib_ams.FReadfile.offset.qFind
// 'quick' Access row by row id. No bounds checking.
inline u32& lib_ams::offset_qFind(lib_ams::FReadfile& parent, u64 t) {
    return parent.offset_elems[t];
}

// --- lib_ams.FReadfile.offset.qLast
// Return reference to last element of array. No bounds checking
inline u32& lib_ams::offset_qLast(lib_ams::FReadfile& parent) {
    return offset_qFind(parent, u64(parent.offset_n-1));
}

// --- lib_ams.FReadfile.offset.rowid_Get
// Return row id of specified element
inline u64 lib_ams::offset_rowid_Get(lib_ams::FReadfile& parent, u32 &elem) {
    u64 id = &elem - parent.offset_elems;
    return u64(id);
}

// --- lib_ams.FReadfile.buf_curs.Next
// proceed to next item
inline void lib_ams::FReadfile_buf_curs_Next(FReadfile_buf_curs &curs) {
    curs.index++;
}

// --- lib_ams.FReadfile.buf_curs.Reset
inline void lib_ams::FReadfile_buf_curs_Reset(FReadfile_buf_curs &curs, lib_ams::FReadfile &parent) {
    curs.elems = parent.buf_elems;
    curs.n_elems = parent.buf_n;
    curs.index = 0;
}

// --- lib_ams.FReadfile.buf_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::FReadfile_buf_curs_ValidQ(FReadfile_buf_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- lib_ams.FReadfile.buf_curs.Access
// item access
inline u8& lib_ams::FReadfile_buf_curs_Access(FReadfile_buf_curs &curs) {
    return curs.elems[curs.index];
}

// --- lib_ams.FReadfile.cbuf_curs.Next
// proceed to next item
inline void lib_ams::FReadfile_cbuf_curs_Next(FReadfile_cbuf_curs &curs) {
    curs.index++;
}

// --- lib_ams.FReadfile.cbuf_curs.Reset
inline void lib_ams::FReadfile_cbuf_curs_Reset(FReadfile_cbuf_curs &curs, lib_ams::FReadfile &parent) {
    curs.elems = parent.cbuf_elems;
    curs.n_elems = parent.cbuf_n;
    curs.index = 0;
}

// --- lib_ams.FReadfile.cbuf_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::FReadfile_cbuf_curs_ValidQ(FReadfile_cbuf_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- lib_ams.FReadfile.cbuf_curs.Access
// item access
inline u8& lib_ams::FReadfile_cbuf_curs_Access(FReadfile_cbuf_curs &curs) {
    return curs.elems[curs.index];
}

// --- lib_ams.FReadfile.offset_curs.Next
// proceed to next item
inline void lib_ams::FReadfile_offset_curs_Next(FReadfile_offset_curs &curs) {
    curs.index++;
}

// --- lib_ams.FReadfile.offset_curs.Reset
inline void lib_ams::FReadfile_offset_curs_Reset(FReadfile_offset_curs &curs, lib_ams::FReadfile &parent) {
    curs.elems = parent.offset_elems;
    curs.n_elems = parent.offset_n;
    curs.index = 0;
}

// --- lib_ams.FReadfile.offset_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::FReadfile_offset_curs_ValidQ(FReadfile_offset_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- lib_ams.FReadfile.offset_curs.Access
// item access
inline u32& lib_ams::FReadfile_offset_curs_Access(FReadfile_offset_curs &curs) {
    return curs.elems[curs.index];
}

// --- lib_ams.FReadfile..Init
// Set all fields to initial values.
inline void lib_ams::FReadfile_Init(lib_ams::FReadfile& parent) {
    parent.eof = bool(false);
    parent.fail = bool(false);
    parent.buf_elems 	= 0; // (lib_ams.FReadfile.buf)
    parent.buf_n     	= 0; // (lib_ams.FReadfile.buf)
    parent.buf_max   	= 0; // (lib_ams.FReadfile.buf)
    parent.cbuf_elems 	= 0; // (lib_ams.FReadfile.cbuf)
    parent.cbuf_n     	= 0; // (lib_ams.FReadfile.cbuf)
    parent.cbuf_max   	= 0; // (lib_ams.FReadfile.cbuf)
    parent.offset_elems 	= 0; // (lib_ams.FReadfile.offset)
    parent.offset_n     	= 0; // (lib_ams.FReadfile.offset)
    parent.offset_max   	= 0; // (lib_ams.FReadfile.offset)
}
inline lib_ams::FStream::FStream() {
    lib_ams::FStream_Init(*this);
}

inline lib_ams::FStream::~FStream() {
    lib_ams::FStream_Uninit(*this);
}


// --- lib_ams.FStream.h_msg.Call
// Invoke function by pointer
inline void lib_ams::h_msg_Call(lib_ams::FStream& stream, ams::MsgHeader& arg) {
    if (stream.h_msg) {
        stream.h_msg((void*)stream.h_msg_ctx, arg);
    }
}

// --- lib_ams.FStream.h_msg.Set0
// Assign 0-argument hook with no context pointer
inline void lib_ams::h_msg_Set0(lib_ams::FStream& stream, void (*fcn)() ) {
    stream.h_msg_ctx = 0;
    stream.h_msg = (lib_ams::stream_h_msg_hook)fcn;
}

// --- lib_ams.FStream.h_msg.Set1
// Assign 1-argument hook with context pointer
template<class T> inline void lib_ams::h_msg_Set1(lib_ams::FStream& stream, T& ctx, void (*fcn)(T&) ) {
    stream.h_msg_ctx = (u64)&ctx;
    stream.h_msg = (lib_ams::stream_h_msg_hook)fcn;
}

// --- lib_ams.FStream.h_msg.Set2
// Assign 2-argument hook with context pointer
template<class T> inline void lib_ams::h_msg_Set2(lib_ams::FStream& stream, T& ctx, void (*fcn)(T&, ams::MsgHeader& arg) ) {
    stream.h_msg_ctx = (u64)&ctx;
    stream.h_msg = (lib_ams::stream_h_msg_hook)fcn;
}

// --- lib_ams.FStream.h_msg_orig.Call
// Invoke function by pointer
inline void lib_ams::h_msg_orig_Call(lib_ams::FStream& stream, ams::MsgHeader& arg) {
    if (stream.h_msg_orig) {
        stream.h_msg_orig((void*)stream.h_msg_orig_ctx, arg);
    }
}

// --- lib_ams.FStream.h_msg_orig.Set0
// Assign 0-argument hook with no context pointer
inline void lib_ams::h_msg_orig_Set0(lib_ams::FStream& stream, void (*fcn)() ) {
    stream.h_msg_orig_ctx = 0;
    stream.h_msg_orig = (lib_ams::stream_h_msg_orig_hook)fcn;
}

// --- lib_ams.FStream.h_msg_orig.Set1
// Assign 1-argument hook with context pointer
template<class T> inline void lib_ams::h_msg_orig_Set1(lib_ams::FStream& stream, T& ctx, void (*fcn)(T&) ) {
    stream.h_msg_orig_ctx = (u64)&ctx;
    stream.h_msg_orig = (lib_ams::stream_h_msg_orig_hook)fcn;
}

// --- lib_ams.FStream.h_msg_orig.Set2
// Assign 2-argument hook with context pointer
template<class T> inline void lib_ams::h_msg_orig_Set2(lib_ams::FStream& stream, T& ctx, void (*fcn)(T&, ams::MsgHeader& arg) ) {
    stream.h_msg_orig_ctx = (u64)&ctx;
    stream.h_msg_orig = (lib_ams::stream_h_msg_orig_hook)fcn;
}

// --- lib_ams.FStream.zd_member_bystream.EmptyQ
// Return true if index is empty
inline bool lib_ams::zd_member_bystream_EmptyQ(lib_ams::FStream& stream) {
    return stream.zd_member_bystream_head == NULL;
}

// --- lib_ams.FStream.zd_member_bystream.First
// If index empty, return NULL. Otherwise return pointer to first element in index
inline lib_ams::FMember* lib_ams::zd_member_bystream_First(lib_ams::FStream& stream) {
    lib_ams::FMember *row = NULL;
    row = stream.zd_member_bystream_head;
    return row;
}

// --- lib_ams.FStream.zd_member_bystream.InLlistQ
// Return true if row is in the linked list, false otherwise
inline bool lib_ams::zd_member_bystream_InLlistQ(lib_ams::FMember& row) {
    bool result = false;
    result = !(row.zd_member_bystream_next == (lib_ams::FMember*)-1);
    return result;
}

// --- lib_ams.FStream.zd_member_bystream.Last
// If index empty, return NULL. Otherwise return pointer to last element in index
inline lib_ams::FMember* lib_ams::zd_member_bystream_Last(lib_ams::FStream& stream) {
    lib_ams::FMember *row = NULL;
    row = stream.zd_member_bystream_tail;
    return row;
}

// --- lib_ams.FStream.zd_member_bystream.N
// Return number of items in the linked list
inline i32 lib_ams::zd_member_bystream_N(const lib_ams::FStream& stream) {
    return stream.zd_member_bystream_n;
}

// --- lib_ams.FStream.zd_member_bystream.Next
// Return pointer to next element in the list
inline lib_ams::FMember* lib_ams::zd_member_bystream_Next(lib_ams::FMember &row) {
    return row.zd_member_bystream_next;
}

// --- lib_ams.FStream.zd_member_bystream.Prev
// Return pointer to previous element in the list
inline lib_ams::FMember* lib_ams::zd_member_bystream_Prev(lib_ams::FMember &row) {
    return row.zd_member_bystream_prev;
}

// --- lib_ams.FStream.zd_member_bystream.qLast
// Return reference to last element in the index. No bounds checking.
inline lib_ams::FMember& lib_ams::zd_member_bystream_qLast(lib_ams::FStream& stream) {
    lib_ams::FMember *row = NULL;
    row = stream.zd_member_bystream_tail;
    return *row;
}

// --- lib_ams.FStream.zd_member_bystream_curs.Reset
// cursor points to valid item
inline void lib_ams::stream_zd_member_bystream_curs_Reset(stream_zd_member_bystream_curs &curs, lib_ams::FStream &parent) {
    curs.row = parent.zd_member_bystream_head;
}

// --- lib_ams.FStream.zd_member_bystream_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::stream_zd_member_bystream_curs_ValidQ(stream_zd_member_bystream_curs &curs) {
    return curs.row != NULL;
}

// --- lib_ams.FStream.zd_member_bystream_curs.Next
// proceed to next item
inline void lib_ams::stream_zd_member_bystream_curs_Next(stream_zd_member_bystream_curs &curs) {
    lib_ams::FMember *next = (*curs.row).zd_member_bystream_next;
    curs.row = next;
}

// --- lib_ams.FStream.zd_member_bystream_curs.Access
// item access
inline lib_ams::FMember& lib_ams::stream_zd_member_bystream_curs_Access(stream_zd_member_bystream_curs &curs) {
    return *curs.row;
}
inline lib_ams::FStreamType::FStreamType() {
    lib_ams::FStreamType_Init(*this);
}

inline lib_ams::FStreamType::~FStreamType() {
    lib_ams::FStreamType_Uninit(*this);
}


// --- lib_ams.FStreamType..Init
// Set all fields to initial values.
inline void lib_ams::FStreamType_Init(lib_ams::FStreamType& streamtype) {
    streamtype.ind_streamtype_next = (lib_ams::FStreamType*)-1; // (lib_ams.FDb.ind_streamtype) not-in-hash
}
inline lib_ams::FWritefile::FWritefile() {
    lib_ams::FWritefile_Init(*this);
}

inline lib_ams::FWritefile::~FWritefile() {
    lib_ams::FWritefile_Uninit(*this);
}


// --- lib_ams.FWritefile.buf.EmptyQ
// Return true if index is empty
inline bool lib_ams::buf_EmptyQ(lib_ams::FWritefile& writefile) {
    return writefile.buf_n == 0;
}

// --- lib_ams.FWritefile.buf.Find
// Look up row by row id. Return NULL if out of range
inline u8* lib_ams::buf_Find(lib_ams::FWritefile& writefile, u64 t) {
    u64 idx = t;
    u64 lim = writefile.buf_n;
    if (idx >= lim) return NULL;
    return writefile.buf_elems + idx;
}

// --- lib_ams.FWritefile.buf.Getary
// Return array pointer by value
inline algo::aryptr<u8> lib_ams::buf_Getary(lib_ams::FWritefile& writefile) {
    return algo::aryptr<u8>(writefile.buf_elems, writefile.buf_n);
}

// --- lib_ams.FWritefile.buf.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* lib_ams::buf_Last(lib_ams::FWritefile& writefile) {
    return buf_Find(writefile, u64(writefile.buf_n-1));
}

// --- lib_ams.FWritefile.buf.Max
// Return max. number of items in the array
inline i32 lib_ams::buf_Max(lib_ams::FWritefile& writefile) {
    (void)writefile;
    return writefile.buf_max;
}

// --- lib_ams.FWritefile.buf.N
// Return number of items in the array
inline i32 lib_ams::buf_N(const lib_ams::FWritefile& writefile) {
    return writefile.buf_n;
}

// --- lib_ams.FWritefile.buf.RemoveAll
inline void lib_ams::buf_RemoveAll(lib_ams::FWritefile& writefile) {
    writefile.buf_n = 0;
}

// --- lib_ams.FWritefile.buf.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void lib_ams::buf_Reserve(lib_ams::FWritefile& writefile, int n) {
    u32 new_n = writefile.buf_n + n;
    if (UNLIKELY(new_n > writefile.buf_max)) {
        buf_AbsReserve(writefile, new_n);
    }
}

// --- lib_ams.FWritefile.buf.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& lib_ams::buf_qFind(lib_ams::FWritefile& writefile, u64 t) {
    return writefile.buf_elems[t];
}

// --- lib_ams.FWritefile.buf.qLast
// Return reference to last element of array. No bounds checking
inline u8& lib_ams::buf_qLast(lib_ams::FWritefile& writefile) {
    return buf_qFind(writefile, u64(writefile.buf_n-1));
}

// --- lib_ams.FWritefile.buf.rowid_Get
// Return row id of specified element
inline u64 lib_ams::buf_rowid_Get(lib_ams::FWritefile& writefile, u8 &elem) {
    u64 id = &elem - writefile.buf_elems;
    return u64(id);
}

// --- lib_ams.FWritefile.cbuf.EmptyQ
// Return true if index is empty
inline bool lib_ams::cbuf_EmptyQ(lib_ams::FWritefile& writefile) {
    return writefile.cbuf_n == 0;
}

// --- lib_ams.FWritefile.cbuf.Find
// Look up row by row id. Return NULL if out of range
inline u8* lib_ams::cbuf_Find(lib_ams::FWritefile& writefile, u64 t) {
    u64 idx = t;
    u64 lim = writefile.cbuf_n;
    if (idx >= lim) return NULL;
    return writefile.cbuf_elems + idx;
}

// --- lib_ams.FWritefile.cbuf.Getary
// Return array pointer by value
inline algo::aryptr<u8> lib_ams::cbuf_Getary(lib_ams::FWritefile& writefile) {
    return algo::aryptr<u8>(writefile.cbuf_elems, writefile.cbuf_n);
}

// --- lib_ams.FWritefile.cbuf.Last
// Return pointer to last element of array, or NULL if array is empty
inline u8* lib_ams::cbuf_Last(lib_ams::FWritefile& writefile) {
    return cbuf_Find(writefile, u64(writefile.cbuf_n-1));
}

// --- lib_ams.FWritefile.cbuf.Max
// Return max. number of items in the array
inline i32 lib_ams::cbuf_Max(lib_ams::FWritefile& writefile) {
    (void)writefile;
    return writefile.cbuf_max;
}

// --- lib_ams.FWritefile.cbuf.N
// Return number of items in the array
inline i32 lib_ams::cbuf_N(const lib_ams::FWritefile& writefile) {
    return writefile.cbuf_n;
}

// --- lib_ams.FWritefile.cbuf.RemoveAll
inline void lib_ams::cbuf_RemoveAll(lib_ams::FWritefile& writefile) {
    writefile.cbuf_n = 0;
}

// --- lib_ams.FWritefile.cbuf.Reserve
// Make sure N *more* elements will fit in array. Process dies if out of memory
inline void lib_ams::cbuf_Reserve(lib_ams::FWritefile& writefile, int n) {
    u32 new_n = writefile.cbuf_n + n;
    if (UNLIKELY(new_n > writefile.cbuf_max)) {
        cbuf_AbsReserve(writefile, new_n);
    }
}

// --- lib_ams.FWritefile.cbuf.qFind
// 'quick' Access row by row id. No bounds checking.
inline u8& lib_ams::cbuf_qFind(lib_ams::FWritefile& writefile, u64 t) {
    return writefile.cbuf_elems[t];
}

// --- lib_ams.FWritefile.cbuf.qLast
// Return reference to last element of array. No bounds checking
inline u8& lib_ams::cbuf_qLast(lib_ams::FWritefile& writefile) {
    return cbuf_qFind(writefile, u64(writefile.cbuf_n-1));
}

// --- lib_ams.FWritefile.cbuf.rowid_Get
// Return row id of specified element
inline u64 lib_ams::cbuf_rowid_Get(lib_ams::FWritefile& writefile, u8 &elem) {
    u64 id = &elem - writefile.cbuf_elems;
    return u64(id);
}

// --- lib_ams.FWritefile..Init
// Set all fields to initial values.
inline void lib_ams::FWritefile_Init(lib_ams::FWritefile& writefile) {
    writefile.fail = bool(false);
    writefile.buf_elems 	= 0; // (lib_ams.FWritefile.buf)
    writefile.buf_n     	= 0; // (lib_ams.FWritefile.buf)
    writefile.buf_max   	= 0; // (lib_ams.FWritefile.buf)
    writefile.cbuf_elems 	= 0; // (lib_ams.FWritefile.cbuf)
    writefile.cbuf_n     	= 0; // (lib_ams.FWritefile.cbuf)
    writefile.cbuf_max   	= 0; // (lib_ams.FWritefile.cbuf)
    writefile.buf_thr = u32(1024*64);
    writefile.zd_flush_next = (lib_ams::FWritefile*)-1; // (lib_ams.FDb.zd_flush) not-in-list
    writefile.zd_flush_prev = NULL; // (lib_ams.FDb.zd_flush)
}

// --- lib_ams.FWritefile.buf_curs.Next
// proceed to next item
inline void lib_ams::writefile_buf_curs_Next(writefile_buf_curs &curs) {
    curs.index++;
}

// --- lib_ams.FWritefile.buf_curs.Reset
inline void lib_ams::writefile_buf_curs_Reset(writefile_buf_curs &curs, lib_ams::FWritefile &parent) {
    curs.elems = parent.buf_elems;
    curs.n_elems = parent.buf_n;
    curs.index = 0;
}

// --- lib_ams.FWritefile.buf_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::writefile_buf_curs_ValidQ(writefile_buf_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- lib_ams.FWritefile.buf_curs.Access
// item access
inline u8& lib_ams::writefile_buf_curs_Access(writefile_buf_curs &curs) {
    return curs.elems[curs.index];
}

// --- lib_ams.FWritefile.cbuf_curs.Next
// proceed to next item
inline void lib_ams::writefile_cbuf_curs_Next(writefile_cbuf_curs &curs) {
    curs.index++;
}

// --- lib_ams.FWritefile.cbuf_curs.Reset
inline void lib_ams::writefile_cbuf_curs_Reset(writefile_cbuf_curs &curs, lib_ams::FWritefile &parent) {
    curs.elems = parent.cbuf_elems;
    curs.n_elems = parent.cbuf_n;
    curs.index = 0;
}

// --- lib_ams.FWritefile.cbuf_curs.ValidQ
// cursor points to valid item
inline bool lib_ams::writefile_cbuf_curs_ValidQ(writefile_cbuf_curs &curs) {
    return curs.index < curs.n_elems;
}

// --- lib_ams.FWritefile.cbuf_curs.Access
// item access
inline u8& lib_ams::writefile_cbuf_curs_Access(writefile_cbuf_curs &curs) {
    return curs.elems[curs.index];
}
inline lib_ams::FieldId::FieldId(i32                            in_value)
    : value(in_value)
{
}
inline lib_ams::FieldId::FieldId(lib_ams_FieldIdEnum arg) { this->value = i32(arg); }
inline lib_ams::FieldId::FieldId() {
    lib_ams::FieldId_Init(*this);
}


// --- lib_ams.FieldId.value.GetEnum
// Get value of field as enum type
inline lib_ams_FieldIdEnum lib_ams::value_GetEnum(const lib_ams::FieldId& parent) {
    return lib_ams_FieldIdEnum(parent.value);
}

// --- lib_ams.FieldId.value.SetEnum
// Set value of field from enum type.
inline void lib_ams::value_SetEnum(lib_ams::FieldId& parent, lib_ams_FieldIdEnum rhs) {
    parent.value = i32(rhs);
}

// --- lib_ams.FieldId.value.Cast
inline lib_ams::FieldId::operator lib_ams_FieldIdEnum () const {
    return lib_ams_FieldIdEnum((*this).value);
}

// --- lib_ams.FieldId..Init
// Set all fields to initial values.
inline void lib_ams::FieldId_Init(lib_ams::FieldId& parent) {
    parent.value = i32(-1);
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const lib_ams::trace &row) {// cfmt:lib_ams.trace.String
    lib_ams::trace_Print(const_cast<lib_ams::trace&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const lib_ams::FReadfile &row) {// cfmt:lib_ams.FReadfile.String
    lib_ams::FReadfile_Print(const_cast<lib_ams::FReadfile&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const lib_ams::FWritefile &row) {// cfmt:lib_ams.FWritefile.String
    lib_ams::FWritefile_Print(const_cast<lib_ams::FWritefile&>(row), str);
    return str;
}

inline algo::cstring &algo::operator <<(algo::cstring &str, const lib_ams::FieldId &row) {// cfmt:lib_ams.FieldId.String
    lib_ams::FieldId_Print(const_cast<lib_ams::FieldId&>(row), str);
    return str;
}
