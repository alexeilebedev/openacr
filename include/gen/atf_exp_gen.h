//
// include/gen/atf_exp_gen.h
// Generated by AMC
//
// Copyright (C) 2008-2013 AlgoEngineering LLC
// Copyright (C) 2013-2019 NYSE | Intercontinental Exchange
// Copyright (C) 2020-2023 Astra
// Copyright (C) 2023 AlgoRND
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//


#pragma once
#include "include/gen/command_gen.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_gen.h"
#include "include/gen/ams_gen.h"
//#pragma endinclude
// gen:ns_enums

// --- atf_exp_FieldIdEnum

enum atf_exp_FieldIdEnum {        // atf_exp.FieldId.value
     atf_exp_FieldId_value   = 0
};

enum { atf_exp_FieldIdEnum_N = 1 };


// --- atf_exp_InCaseEnum

enum atf_exp_InCaseEnum {                         // atf_exp.InCase.value
     atf_exp_InCase_ams_ProcEofMsg         = 703
    ,atf_exp_InCase_ams_ProcKillMsg        = 704
    ,atf_exp_InCase_ams_ProcMsg            = 701
    ,atf_exp_InCase_ams_ProcReadMsg        = 702
    ,atf_exp_InCase_ams_ProcStartMsg       = 700
    ,atf_exp_InCase_ams_RemDirRecurseMsg   = 633
    ,atf_exp_InCase_ams_TerminateMsg       = 352
};

enum { atf_exp_InCaseEnum_N = 7 };

namespace atf_exp { // gen:ns_pkeytypedef
} // gen:ns_pkeytypedef
namespace atf_exp { // gen:ns_tclass_field
extern const char *atf_exp_help;
} // gen:ns_tclass_field
// gen:ns_fwddecl2
namespace atf_exp { struct Proc; }
namespace atf_exp { struct _db_zd_proc_curs; }
namespace atf_exp { struct _db_cd_proc_read_curs; }
namespace atf_exp { struct _db_cd_proc_outflow_curs; }
namespace atf_exp { struct _db_cd_fdin_eof_curs; }
namespace atf_exp { struct _db_cd_fdin_read_curs; }
namespace atf_exp { struct _db_cd_fdin_suspend_curs; }
namespace atf_exp { struct trace; }
namespace atf_exp { struct FDb; }
namespace atf_exp { struct FFdin; }
namespace atf_exp { struct FProc; }
namespace atf_exp { struct FieldId; }
namespace atf_exp { struct InCase; }
namespace atf_exp { extern struct atf_exp::FDb _db; }
namespace atf_exp { // gen:ns_print_struct

// --- atf_exp.trace
#pragma pack(push,1)
struct trace { // atf_exp.trace
    u64   dispatch_In_ProcEofMsg;                //   0  Total number of ProcEofMsg processed by atf_exp
    u64   dispatch_In_ProcEofMsg_cycles;         //   0
    u64   dispatch_In_ProcKillMsg;               //   0  Total number of ProcKillMsg processed by atf_exp
    u64   dispatch_In_ProcKillMsg_cycles;        //   0
    u64   dispatch_In_ProcMsg;                   //   0  Total number of ProcMsg processed by atf_exp
    u64   dispatch_In_ProcMsg_cycles;            //   0
    u64   dispatch_In_ProcReadMsg;               //   0  Total number of ProcReadMsg processed by atf_exp
    u64   dispatch_In_ProcReadMsg_cycles;        //   0
    u64   dispatch_In_ProcStartMsg;              //   0  Total number of ProcStartMsg processed by atf_exp
    u64   dispatch_In_ProcStartMsg_cycles;       //   0
    u64   dispatch_In_RemDirRecurseMsg;          //   0  Total number of RemDirRecurseMsg processed by atf_exp
    u64   dispatch_In_RemDirRecurseMsg_cycles;   //   0
    u64   dispatch_In_TerminateMsg;              //   0  Total number of TerminateMsg processed by atf_exp
    u64   dispatch_In_TerminateMsg_cycles;       //   0
    u64   dispatch_In_Unkmsg;                    //   0
    u64   dispatch_In_Unkmsg_cycles;             //   0
    // func:atf_exp.trace..Ctor
    inline               trace() __attribute__((nothrow));
};
#pragma pack(pop)

// Set all fields to initial values.
// func:atf_exp.trace..Init
void                 trace_Init(atf_exp::trace& parent);
// print string representation of ROW to string STR
// cfmt:atf_exp.trace.String  printfmt:Tuple
// func:atf_exp.trace..Print
void                 trace_Print(atf_exp::trace& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_exp.FDb
// create: atf_exp.FDb._db (Global)
struct FDb { // atf_exp.FDb
    command::atf_exp      cmdline;                      //
    u64                   proc_blocksize;               // # bytes per block
    atf_exp::FProc*       proc_free;                    //
    atf_exp::FProc**      ind_proc_buckets_elems;       // pointer to bucket array
    i32                   ind_proc_buckets_n;           // number of elements in bucket array
    i32                   ind_proc_n;                   // number of elements in the hash table
    atf_exp::FProc*       zd_proc_head;                 // zero-terminated doubly linked list
    i32                   zd_proc_n;                    // zero-terminated doubly linked list
    atf_exp::FProc*       zd_proc_tail;                 // pointer to last element
    atf_exp::FProc*       cd_proc_read_head;            // zero-terminated doubly linked list
    i32                   cd_proc_read_n;               // zero-terminated doubly linked list
    atf_exp::FProc*       cd_proc_outflow_head;         // zero-terminated doubly linked list
    i32                   cd_proc_outflow_n;            // zero-terminated doubly linked list
    algo_lib::Replscope   R;                            //
    atf_exp::FProc**      ind_proc_pid_buckets_elems;   // pointer to bucket array
    i32                   ind_proc_pid_buckets_n;       // number of elements in bucket array
    i32                   ind_proc_pid_n;               // number of elements in the hash table
    algo::SchedTime       ind_proc_pid_next;            // atf_exp.FDb.ind_proc_pid              Next invocation time
    algo::SchedTime       ind_proc_pid_delay;           // atf_exp.FDb.ind_proc_pid              Delay between invocations
    atf_exp::FProc*       c_proc_read;                  // optional pointer
    algo::cstring         proc_read_until;              //
    u64                   fdin_blocksize;               // # bytes per block
    atf_exp::FFdin*       fdin_free;                    //
    atf_exp::FFdin*       cd_fdin_eof_head;             // zero-terminated doubly linked list
    i32                   cd_fdin_eof_n;                // zero-terminated doubly linked list
    atf_exp::FFdin*       cd_fdin_read_head;            // zero-terminated doubly linked list
    i32                   cd_fdin_read_n;               // zero-terminated doubly linked list
    atf_exp::FFdin*       cd_fdin_suspend_head;         // zero-terminated doubly linked list
    i32                   cd_fdin_suspend_n;            // zero-terminated doubly linked list
    algo_lib::FTimehook   timeout;                      //
    algo_lib::FFildes     vars_file;                    //
    atf_exp::trace        trace;                        //
};

// Read argc,argv directly into the fields of the command line(s)
// The following fields are updated:
//     atf_exp.FDb.cmdline
//     algo_lib.FDb.cmdline
// func:atf_exp.FDb._db.ReadArgv
void                 ReadArgv() __attribute__((nothrow));
// Main loop.
// func:atf_exp.FDb._db.MainLoop
void                 MainLoop();
// Main step
// func:atf_exp.FDb._db.Step
void                 Step();
// Main function
// func:atf_exp.FDb._db.Main
// this function is 'extrn' and implemented by user
void                 Main();
// Parse strptr into known type and add to database.
// Return value is true unless an error occurs. If return value is false, algo_lib::_db.errtext has error text
// func:atf_exp.FDb._db.InsertStrptrMaybe
bool                 InsertStrptrMaybe(algo::strptr str);
// Load all finputs from given directory.
// func:atf_exp.FDb._db.LoadTuplesMaybe
bool                 LoadTuplesMaybe(algo::strptr root, bool recursive) __attribute__((nothrow));
// Load all finputs from given file.
// Read tuples from file FNAME into this namespace's in-memory database.
// If RECURSIVE is TRUE, then also load these tuples into any parent namespaces
// It a file referred to by FNAME is missing, no error is reported (it's considered an empty set).
// Function returns TRUE if all records were parsed and inserted without error.
// If the function returns FALSE, use algo_lib::DetachBadTags() for error description
// func:atf_exp.FDb._db.LoadTuplesFile
bool                 LoadTuplesFile(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load all finputs from given file descriptor.
// func:atf_exp.FDb._db.LoadTuplesFd
bool                 LoadTuplesFd(algo::Fildes fd, algo::strptr fname, bool recursive) __attribute__((nothrow));
// Load specified ssimfile.
// func:atf_exp.FDb._db.LoadSsimfileMaybe
bool                 LoadSsimfileMaybe(algo::strptr fname, bool recursive) __attribute__((nothrow));
// Calls Step function of dependencies
// func:atf_exp.FDb._db.Steps
void                 Steps();
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_exp.FDb._db.XrefMaybe
bool                 _db_XrefMaybe();

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_exp.FDb.proc.Alloc
atf_exp::FProc&      proc_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_exp.FDb.proc.AllocMaybe
atf_exp::FProc*      proc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Create new row from struct.
// Return pointer to new element, or NULL if insertion failed (due to out-of-memory, duplicate key, etc)
// func:atf_exp.FDb.proc.InsertMaybe
atf_exp::FProc*      proc_InsertMaybe(const atf_exp::Proc &value) __attribute__((nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_exp.FDb.proc.Delete
void                 proc_Delete(atf_exp::FProc &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:atf_exp.FDb.proc.AllocMem
void*                proc_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:atf_exp.FDb.proc.FreeMem
void                 proc_FreeMem(atf_exp::FProc &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:atf_exp.FDb.proc.Reserve
u64                  proc_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:atf_exp.FDb.proc.ReserveMem
u64                  proc_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_exp.FDb.proc.XrefMaybe
bool                 proc_XrefMaybe(atf_exp::FProc &row);

// Return true if hash is empty
// func:atf_exp.FDb.ind_proc.EmptyQ
inline bool          ind_proc_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_exp.FDb.ind_proc.Find
atf_exp::FProc*      ind_proc_Find(const algo::strptr& key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:atf_exp.FDb.ind_proc.FindX
atf_exp::FProc&      ind_proc_FindX(const algo::strptr& key);
// Find row by key. If not found, create and x-reference a new row with with this key.
// func:atf_exp.FDb.ind_proc.GetOrCreate
atf_exp::FProc&      ind_proc_GetOrCreate(const algo::strptr& key) __attribute__((nothrow));
// Return number of items in the hash
// func:atf_exp.FDb.ind_proc.N
inline i32           ind_proc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_exp.FDb.ind_proc.InsertMaybe
bool                 ind_proc_InsertMaybe(atf_exp::FProc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_exp.FDb.ind_proc.Remove
void                 ind_proc_Remove(atf_exp::FProc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_exp.FDb.ind_proc.Reserve
void                 ind_proc_Reserve(int n) __attribute__((nothrow));
// Reserve enough room for exacty N elements. Return success code.
// func:atf_exp.FDb.ind_proc.AbsReserve
void                 ind_proc_AbsReserve(int n) __attribute__((nothrow));

// Return true if index is empty
// func:atf_exp.FDb.zd_proc.EmptyQ
inline bool          zd_proc_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_exp.FDb.zd_proc.First
inline atf_exp::FProc* zd_proc_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_exp.FDb.zd_proc.InLlistQ
inline bool          zd_proc_InLlistQ(atf_exp::FProc& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_exp.FDb.zd_proc.Insert
void                 zd_proc_Insert(atf_exp::FProc& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_exp.FDb.zd_proc.Last
inline atf_exp::FProc* zd_proc_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_exp.FDb.zd_proc.N
inline i32           zd_proc_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_exp.FDb.zd_proc.Next
inline atf_exp::FProc* zd_proc_Next(atf_exp::FProc &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_exp.FDb.zd_proc.Prev
inline atf_exp::FProc* zd_proc_Prev(atf_exp::FProc &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.zd_proc.Remove
void                 zd_proc_Remove(atf_exp::FProc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_exp.FDb.zd_proc.RemoveAll
void                 zd_proc_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_exp.FDb.zd_proc.RemoveFirst
atf_exp::FProc*      zd_proc_RemoveFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_exp.FDb.zd_proc.qLast
inline atf_exp::FProc& zd_proc_qLast() __attribute__((__warn_unused_result__, nothrow));

// Return true if index is empty
// func:atf_exp.FDb.cd_proc_read.EmptyQ
inline bool          cd_proc_read_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_exp.FDb.cd_proc_read.First
inline atf_exp::FProc* cd_proc_read_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_exp.FDb.cd_proc_read.InLlistQ
inline bool          cd_proc_read_InLlistQ(atf_exp::FProc& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_exp.FDb.cd_proc_read.Insert
void                 cd_proc_read_Insert(atf_exp::FProc& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_exp.FDb.cd_proc_read.Last
inline atf_exp::FProc* cd_proc_read_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_exp.FDb.cd_proc_read.N
inline i32           cd_proc_read_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_exp.FDb.cd_proc_read.Next
inline atf_exp::FProc* cd_proc_read_Next(atf_exp::FProc &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_exp.FDb.cd_proc_read.Prev
inline atf_exp::FProc* cd_proc_read_Prev(atf_exp::FProc &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.cd_proc_read.Remove
void                 cd_proc_read_Remove(atf_exp::FProc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_exp.FDb.cd_proc_read.RemoveAll
void                 cd_proc_read_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_exp.FDb.cd_proc_read.RemoveFirst
atf_exp::FProc*      cd_proc_read_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_exp.FDb.cd_proc_read.RotateFirst
atf_exp::FProc*      cd_proc_read_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_exp.FDb.cd_proc_read.qLast
inline atf_exp::FProc& cd_proc_read_qLast() __attribute__((__warn_unused_result__, nothrow));
// func:atf_exp.FDb.cd_proc_read.Step
// this function is 'extrn' and implemented by user
void                 cd_proc_read_Step() __attribute__((nothrow));

// Return true if index is empty
// func:atf_exp.FDb.cd_proc_outflow.EmptyQ
inline bool          cd_proc_outflow_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_exp.FDb.cd_proc_outflow.First
inline atf_exp::FProc* cd_proc_outflow_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_exp.FDb.cd_proc_outflow.InLlistQ
inline bool          cd_proc_outflow_InLlistQ(atf_exp::FProc& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_exp.FDb.cd_proc_outflow.Insert
void                 cd_proc_outflow_Insert(atf_exp::FProc& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_exp.FDb.cd_proc_outflow.Last
inline atf_exp::FProc* cd_proc_outflow_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_exp.FDb.cd_proc_outflow.N
inline i32           cd_proc_outflow_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_exp.FDb.cd_proc_outflow.Next
inline atf_exp::FProc* cd_proc_outflow_Next(atf_exp::FProc &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_exp.FDb.cd_proc_outflow.Prev
inline atf_exp::FProc* cd_proc_outflow_Prev(atf_exp::FProc &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.cd_proc_outflow.Remove
void                 cd_proc_outflow_Remove(atf_exp::FProc& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_exp.FDb.cd_proc_outflow.RemoveAll
void                 cd_proc_outflow_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_exp.FDb.cd_proc_outflow.RemoveFirst
atf_exp::FProc*      cd_proc_outflow_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_exp.FDb.cd_proc_outflow.RotateFirst
atf_exp::FProc*      cd_proc_outflow_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_exp.FDb.cd_proc_outflow.qLast
inline atf_exp::FProc& cd_proc_outflow_qLast() __attribute__((__warn_unused_result__, nothrow));
// func:atf_exp.FDb.cd_proc_outflow.Step
// this function is 'extrn' and implemented by user
void                 cd_proc_outflow_Step() __attribute__((nothrow));

// Return true if hash is empty
// func:atf_exp.FDb.ind_proc_pid.EmptyQ
inline bool          ind_proc_pid_EmptyQ() __attribute__((nothrow));
// Find row by key. Return NULL if not found.
// func:atf_exp.FDb.ind_proc_pid.Find
atf_exp::FProc*      ind_proc_pid_Find(i32 key) __attribute__((__warn_unused_result__, nothrow));
// Look up row by key and return reference. Throw exception if not found
// func:atf_exp.FDb.ind_proc_pid.FindX
atf_exp::FProc&      ind_proc_pid_FindX(i32 key);
// Return number of items in the hash
// func:atf_exp.FDb.ind_proc_pid.N
inline i32           ind_proc_pid_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Insert row into hash table. Return true if row is reachable through the hash after the function completes.
// func:atf_exp.FDb.ind_proc_pid.InsertMaybe
bool                 ind_proc_pid_InsertMaybe(atf_exp::FProc& row) __attribute__((nothrow));
// Remove reference to element from hash index. If element is not in hash, do nothing
// func:atf_exp.FDb.ind_proc_pid.Remove
void                 ind_proc_pid_Remove(atf_exp::FProc& row) __attribute__((nothrow));
// Reserve enough room in the hash for N more elements. Return success code.
// func:atf_exp.FDb.ind_proc_pid.Reserve
void                 ind_proc_pid_Reserve(int n) __attribute__((nothrow));
// Reserve enough room for exacty N elements. Return success code.
// func:atf_exp.FDb.ind_proc_pid.AbsReserve
void                 ind_proc_pid_AbsReserve(int n) __attribute__((nothrow));
// func:atf_exp.FDb.ind_proc_pid.Step
// this function is 'extrn' and implemented by user
void                 ind_proc_pid_Step() __attribute__((nothrow));
// Set inter-step delay to specified value.
// The difference between new delay and current delay is added to the next scheduled time.
// func:atf_exp.FDb.ind_proc_pid.SetDelay
void                 ind_proc_pid_SetDelay(algo::SchedTime delay) __attribute__((nothrow));

// Insert row into pointer index. Return final membership status.
// func:atf_exp.FDb.c_proc_read.InsertMaybe
inline bool          c_proc_read_InsertMaybe(atf_exp::FProc& row) __attribute__((nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.c_proc_read.Remove
inline void          c_proc_read_Remove(atf_exp::FProc& row) __attribute__((nothrow));

// Allocate memory for new default row.
// If out of memory, process is killed.
// func:atf_exp.FDb.fdin.Alloc
atf_exp::FFdin&      fdin_Alloc() __attribute__((__warn_unused_result__, nothrow));
// Allocate memory for new element. If out of memory, return NULL.
// func:atf_exp.FDb.fdin.AllocMaybe
atf_exp::FFdin*      fdin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
// Remove row from all global and cross indices, then deallocate row
// func:atf_exp.FDb.fdin.Delete
void                 fdin_Delete(atf_exp::FFdin &row) __attribute__((nothrow));
// Allocate space for one element
// If no memory available, return NULL.
// func:atf_exp.FDb.fdin.AllocMem
void*                fdin_AllocMem() __attribute__((__warn_unused_result__, nothrow));
// Remove mem from all global and cross indices, then deallocate mem
// func:atf_exp.FDb.fdin.FreeMem
void                 fdin_FreeMem(atf_exp::FFdin &row) __attribute__((nothrow));
// Preallocate memory for N more elements
// Return number of elements actually reserved.
// func:atf_exp.FDb.fdin.Reserve
u64                  fdin_Reserve(u64 n_elems) __attribute__((nothrow));
// Allocate block of given size, break up into small elements and append to free list.
// Return number of elements reserved.
// func:atf_exp.FDb.fdin.ReserveMem
u64                  fdin_ReserveMem(u64 size) __attribute__((nothrow));
// Insert row into all appropriate indices. If error occurs, store error
// in algo_lib::_db.errtext and return false. Caller must Delete or Unref such row.
// func:atf_exp.FDb.fdin.XrefMaybe
bool                 fdin_XrefMaybe(atf_exp::FFdin &row);

// Return true if index is empty
// func:atf_exp.FDb.cd_fdin_eof.EmptyQ
inline bool          cd_fdin_eof_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_exp.FDb.cd_fdin_eof.First
inline atf_exp::FFdin* cd_fdin_eof_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_exp.FDb.cd_fdin_eof.InLlistQ
inline bool          cd_fdin_eof_InLlistQ(atf_exp::FFdin& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_exp.FDb.cd_fdin_eof.Insert
void                 cd_fdin_eof_Insert(atf_exp::FFdin& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_exp.FDb.cd_fdin_eof.Last
inline atf_exp::FFdin* cd_fdin_eof_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_exp.FDb.cd_fdin_eof.N
inline i32           cd_fdin_eof_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_exp.FDb.cd_fdin_eof.Next
inline atf_exp::FFdin* cd_fdin_eof_Next(atf_exp::FFdin &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_exp.FDb.cd_fdin_eof.Prev
inline atf_exp::FFdin* cd_fdin_eof_Prev(atf_exp::FFdin &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.cd_fdin_eof.Remove
void                 cd_fdin_eof_Remove(atf_exp::FFdin& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_exp.FDb.cd_fdin_eof.RemoveAll
void                 cd_fdin_eof_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_exp.FDb.cd_fdin_eof.RemoveFirst
atf_exp::FFdin*      cd_fdin_eof_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_exp.FDb.cd_fdin_eof.RotateFirst
atf_exp::FFdin*      cd_fdin_eof_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_exp.FDb.cd_fdin_eof.qLast
inline atf_exp::FFdin& cd_fdin_eof_qLast() __attribute__((__warn_unused_result__, nothrow));
// func:atf_exp.FDb.cd_fdin_eof.Step
// this function is 'extrn' and implemented by user
void                 cd_fdin_eof_Step() __attribute__((nothrow));

// Return true if index is empty
// func:atf_exp.FDb.cd_fdin_read.EmptyQ
inline bool          cd_fdin_read_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_exp.FDb.cd_fdin_read.First
inline atf_exp::FFdin* cd_fdin_read_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_exp.FDb.cd_fdin_read.InLlistQ
inline bool          cd_fdin_read_InLlistQ(atf_exp::FFdin& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_exp.FDb.cd_fdin_read.Insert
void                 cd_fdin_read_Insert(atf_exp::FFdin& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_exp.FDb.cd_fdin_read.Last
inline atf_exp::FFdin* cd_fdin_read_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_exp.FDb.cd_fdin_read.N
inline i32           cd_fdin_read_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_exp.FDb.cd_fdin_read.Next
inline atf_exp::FFdin* cd_fdin_read_Next(atf_exp::FFdin &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_exp.FDb.cd_fdin_read.Prev
inline atf_exp::FFdin* cd_fdin_read_Prev(atf_exp::FFdin &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.cd_fdin_read.Remove
void                 cd_fdin_read_Remove(atf_exp::FFdin& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_exp.FDb.cd_fdin_read.RemoveAll
void                 cd_fdin_read_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// Call FirstChanged trigger.
// func:atf_exp.FDb.cd_fdin_read.RemoveFirst
atf_exp::FFdin*      cd_fdin_read_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_exp.FDb.cd_fdin_read.RotateFirst
atf_exp::FFdin*      cd_fdin_read_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_exp.FDb.cd_fdin_read.qLast
inline atf_exp::FFdin& cd_fdin_read_qLast() __attribute__((__warn_unused_result__, nothrow));
// func:atf_exp.FDb.cd_fdin_read.Step
// this function is 'extrn' and implemented by user
void                 cd_fdin_read_Step() __attribute__((nothrow));

// Return true if index is empty
// func:atf_exp.FDb.cd_fdin_suspend.EmptyQ
inline bool          cd_fdin_suspend_EmptyQ() __attribute__((__warn_unused_result__, nothrow, pure));
// If index empty, return NULL. Otherwise return pointer to first element in index
// func:atf_exp.FDb.cd_fdin_suspend.First
inline atf_exp::FFdin* cd_fdin_suspend_First() __attribute__((__warn_unused_result__, nothrow, pure));
// Return true if row is in the linked list, false otherwise
// func:atf_exp.FDb.cd_fdin_suspend.InLlistQ
inline bool          cd_fdin_suspend_InLlistQ(atf_exp::FFdin& row) __attribute__((__warn_unused_result__, nothrow));
// Insert row into linked list. If row is already in linked list, do nothing.
// func:atf_exp.FDb.cd_fdin_suspend.Insert
void                 cd_fdin_suspend_Insert(atf_exp::FFdin& row) __attribute__((nothrow));
// If index empty, return NULL. Otherwise return pointer to last element in index
// func:atf_exp.FDb.cd_fdin_suspend.Last
inline atf_exp::FFdin* cd_fdin_suspend_Last() __attribute__((__warn_unused_result__, nothrow, pure));
// Return number of items in the linked list
// func:atf_exp.FDb.cd_fdin_suspend.N
inline i32           cd_fdin_suspend_N() __attribute__((__warn_unused_result__, nothrow, pure));
// Return pointer to next element in the list
// func:atf_exp.FDb.cd_fdin_suspend.Next
inline atf_exp::FFdin* cd_fdin_suspend_Next(atf_exp::FFdin &row) __attribute__((__warn_unused_result__, nothrow));
// Return pointer to previous element in the list
// func:atf_exp.FDb.cd_fdin_suspend.Prev
inline atf_exp::FFdin* cd_fdin_suspend_Prev(atf_exp::FFdin &row) __attribute__((__warn_unused_result__, nothrow));
// Remove element from index. If element is not in index, do nothing.
// func:atf_exp.FDb.cd_fdin_suspend.Remove
void                 cd_fdin_suspend_Remove(atf_exp::FFdin& row) __attribute__((nothrow));
// Empty the index. (The rows are not deleted)
// func:atf_exp.FDb.cd_fdin_suspend.RemoveAll
void                 cd_fdin_suspend_RemoveAll() __attribute__((nothrow));
// If linked list is empty, return NULL. Otherwise unlink and return pointer to first element.
// func:atf_exp.FDb.cd_fdin_suspend.RemoveFirst
atf_exp::FFdin*      cd_fdin_suspend_RemoveFirst() __attribute__((nothrow));
// If linked list is empty, return NULL.
// Otherwise return head item and advance head to the next item.
// func:atf_exp.FDb.cd_fdin_suspend.RotateFirst
atf_exp::FFdin*      cd_fdin_suspend_RotateFirst() __attribute__((nothrow));
// Return reference to last element in the index. No bounds checking.
// func:atf_exp.FDb.cd_fdin_suspend.qLast
inline atf_exp::FFdin& cd_fdin_suspend_qLast() __attribute__((__warn_unused_result__, nothrow));

// cursor points to valid item
// func:atf_exp.FDb.zd_proc_curs.Reset
inline void          _db_zd_proc_curs_Reset(_db_zd_proc_curs &curs, atf_exp::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.zd_proc_curs.ValidQ
inline bool          _db_zd_proc_curs_ValidQ(_db_zd_proc_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_exp.FDb.zd_proc_curs.Next
inline void          _db_zd_proc_curs_Next(_db_zd_proc_curs &curs) __attribute__((nothrow));
// item access
// func:atf_exp.FDb.zd_proc_curs.Access
inline atf_exp::FProc& _db_zd_proc_curs_Access(_db_zd_proc_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_proc_read_curs.Reset
inline void          _db_cd_proc_read_curs_Reset(_db_cd_proc_read_curs &curs, atf_exp::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_proc_read_curs.ValidQ
inline bool          _db_cd_proc_read_curs_ValidQ(_db_cd_proc_read_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_exp.FDb.cd_proc_read_curs.Next
inline void          _db_cd_proc_read_curs_Next(_db_cd_proc_read_curs &curs) __attribute__((nothrow));
// item access
// func:atf_exp.FDb.cd_proc_read_curs.Access
inline atf_exp::FProc& _db_cd_proc_read_curs_Access(_db_cd_proc_read_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_proc_outflow_curs.Reset
inline void          _db_cd_proc_outflow_curs_Reset(_db_cd_proc_outflow_curs &curs, atf_exp::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_proc_outflow_curs.ValidQ
inline bool          _db_cd_proc_outflow_curs_ValidQ(_db_cd_proc_outflow_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_exp.FDb.cd_proc_outflow_curs.Next
inline void          _db_cd_proc_outflow_curs_Next(_db_cd_proc_outflow_curs &curs) __attribute__((nothrow));
// item access
// func:atf_exp.FDb.cd_proc_outflow_curs.Access
inline atf_exp::FProc& _db_cd_proc_outflow_curs_Access(_db_cd_proc_outflow_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_fdin_eof_curs.Reset
inline void          _db_cd_fdin_eof_curs_Reset(_db_cd_fdin_eof_curs &curs, atf_exp::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_fdin_eof_curs.ValidQ
inline bool          _db_cd_fdin_eof_curs_ValidQ(_db_cd_fdin_eof_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_exp.FDb.cd_fdin_eof_curs.Next
inline void          _db_cd_fdin_eof_curs_Next(_db_cd_fdin_eof_curs &curs) __attribute__((nothrow));
// item access
// func:atf_exp.FDb.cd_fdin_eof_curs.Access
inline atf_exp::FFdin& _db_cd_fdin_eof_curs_Access(_db_cd_fdin_eof_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_fdin_read_curs.Reset
inline void          _db_cd_fdin_read_curs_Reset(_db_cd_fdin_read_curs &curs, atf_exp::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_fdin_read_curs.ValidQ
inline bool          _db_cd_fdin_read_curs_ValidQ(_db_cd_fdin_read_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_exp.FDb.cd_fdin_read_curs.Next
inline void          _db_cd_fdin_read_curs_Next(_db_cd_fdin_read_curs &curs) __attribute__((nothrow));
// item access
// func:atf_exp.FDb.cd_fdin_read_curs.Access
inline atf_exp::FFdin& _db_cd_fdin_read_curs_Access(_db_cd_fdin_read_curs &curs) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_fdin_suspend_curs.Reset
inline void          _db_cd_fdin_suspend_curs_Reset(_db_cd_fdin_suspend_curs &curs, atf_exp::FDb &parent) __attribute__((nothrow));
// cursor points to valid item
// func:atf_exp.FDb.cd_fdin_suspend_curs.ValidQ
inline bool          _db_cd_fdin_suspend_curs_ValidQ(_db_cd_fdin_suspend_curs &curs) __attribute__((nothrow));
// proceed to next item
// func:atf_exp.FDb.cd_fdin_suspend_curs.Next
inline void          _db_cd_fdin_suspend_curs_Next(_db_cd_fdin_suspend_curs &curs) __attribute__((nothrow));
// item access
// func:atf_exp.FDb.cd_fdin_suspend_curs.Access
inline atf_exp::FFdin& _db_cd_fdin_suspend_curs_Access(_db_cd_fdin_suspend_curs &curs) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_exp.FDb..Init
void                 FDb_Init();
// func:atf_exp.FDb..Uninit
void                 FDb_Uninit() __attribute__((nothrow));

// --- atf_exp.FFdin
// create: atf_exp.FDb.fdin (Tpool)
// global access: cd_fdin_eof (Llist)
// global access: cd_fdin_read (Llist)
// global access: cd_fdin_suspend (Llist)
struct FFdin { // atf_exp.FFdin: FD input (normally stdin)
    atf_exp::FFdin*     fdin_next;              // Pointer to next free element int tpool
    atf_exp::FFdin*     cd_fdin_eof_next;       // zslist link; -1 means not-in-list
    atf_exp::FFdin*     cd_fdin_eof_prev;       // previous element
    atf_exp::FFdin*     cd_fdin_read_next;      // zslist link; -1 means not-in-list
    atf_exp::FFdin*     cd_fdin_read_prev;      // previous element
    atf_exp::FFdin*     cd_fdin_suspend_next;   // zslist link; -1 means not-in-list
    atf_exp::FFdin*     cd_fdin_suspend_prev;   // previous element
    u8*                 in_elems;               //   NULL  pointer to elements of indirect array
    u32                 in_max;                 //   0  current length of allocated array
    i32                 in_start;               // beginning of valid bytes (in bytes)
    i32                 in_end;                 // end of valid bytes (in bytes)
    i32                 in_msglen;              // current message length
    algo::Errcode       in_err;                 // system error code
    algo_lib::FIohook   in_iohook;              // edge-triggered hook for the buffer
    bool                in_eof;                 // no more data will be written to buffer
    bool                in_msgvalid;            // current message is valid
    bool                in_epoll_enable;        // use epoll?
    // field atf_exp.FFdin.in prevents copy
    // func:atf_exp.FFdin..AssignOp
    inline atf_exp::FFdin& operator =(const atf_exp::FFdin &rhs) = delete;
    // field atf_exp.FFdin.in prevents copy
    // func:atf_exp.FFdin..CopyCtor
    inline               FFdin(const atf_exp::FFdin &rhs) = delete;
private:
    // func:atf_exp.FFdin..Ctor
    inline               FFdin() __attribute__((nothrow));
    // func:atf_exp.FFdin..Dtor
    inline               ~FFdin() __attribute__((nothrow));
    friend atf_exp::FFdin&      fdin_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_exp::FFdin*      fdin_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 fdin_Delete(atf_exp::FFdin &row) __attribute__((nothrow));
};

// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by atf_exp::FFdin.in via FIohook field.
// Whenever the file descriptor becomes readable, insert fdin into cd_fdin_read.
// func:atf_exp.FFdin.in.BeginRead
void                 in_BeginRead(atf_exp::FFdin& fdin, algo::Fildes fd) __attribute__((nothrow));
// Set EOF flag
// func:atf_exp.FFdin.in.EndRead
void                 in_EndRead(atf_exp::FFdin& fdin) __attribute__((nothrow));
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
//
// func:atf_exp.FFdin.in.GetMsg
algo::aryptr<char>   in_GetMsg(atf_exp::FFdin& fdin) __attribute__((nothrow));
// Set buffer size.
// Unconditionally reallocate buffer to have size NEW_MAX
// If the buffer has data in it, NEW_MAX is adjusted so that the data is not lost
// (best to call this before filling the buffer)
// func:atf_exp.FFdin.in.Realloc
void                 in_Realloc(atf_exp::FFdin& fdin, int new_max) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_exp.FFdin.in.Max
inline i32           in_Max(atf_exp::FFdin& fdin) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_exp.FFdin.in.N
inline i32           in_N(atf_exp::FFdin& fdin) __attribute__((__warn_unused_result__, nothrow, pure));
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
// func:atf_exp.FFdin.in.Refill
bool                 in_Refill(atf_exp::FFdin& fdin) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_exp.FFdin.in.RemoveAll
void                 in_RemoveAll(atf_exp::FFdin& fdin) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_exp.FFdin.in.SkipBytes
void                 in_SkipBytes(atf_exp::FFdin& fdin, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_exp.FFdin.in.SkipMsg
void                 in_SkipMsg(atf_exp::FFdin& fdin) __attribute__((nothrow));
// Attempt to write buffer contents to fbuf, return success
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_exp.FFdin.in.WriteAll
bool                 in_WriteAll(atf_exp::FFdin& fdin, u8 *in, i32 in_n) __attribute__((nothrow));
// Write buffer contents to fbuf, reallocate as needed
// Write bytes to the buffer. The entire block is always written
// func:atf_exp.FFdin.in.WriteReserve
void                 in_WriteReserve(atf_exp::FFdin& fdin, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_exp.FFdin..Init
void                 FFdin_Init(atf_exp::FFdin& fdin);
// func:atf_exp.FFdin..Uninit
void                 FFdin_Uninit(atf_exp::FFdin& fdin) __attribute__((nothrow));

// --- atf_exp.FProc
// create: atf_exp.FDb.proc (Tpool)
// global access: ind_proc (Thash, hash field proc)
// global access: zd_proc (Llist)
// global access: cd_proc_read (Llist)
// global access: cd_proc_outflow (Llist)
// global access: ind_proc_pid (Thash, hash field pid)
// global access: c_proc_read (Ptr)
struct FProc { // atf_exp.FProc
    atf_exp::FProc*      proc_next;              // Pointer to next free element int tpool
    atf_exp::FProc*      ind_proc_next;          // hash next
    u32                  ind_proc_hashval;       // hash value
    atf_exp::FProc*      zd_proc_next;           // zslist link; -1 means not-in-list
    atf_exp::FProc*      zd_proc_prev;           // previous element
    atf_exp::FProc*      cd_proc_read_next;      // zslist link; -1 means not-in-list
    atf_exp::FProc*      cd_proc_read_prev;      // previous element
    atf_exp::FProc*      cd_proc_outflow_next;   // zslist link; -1 means not-in-list
    atf_exp::FProc*      cd_proc_outflow_prev;   // previous element
    atf_exp::FProc*      ind_proc_pid_next;      // hash next
    u32                  ind_proc_pid_hashval;   // hash value
    algo::Smallstr50     proc;                   //
    command::bash_proc   bash;                   //
    u8*                  in_elems;               //   NULL  pointer to elements of indirect array
    u32                  in_max;                 //   0  current length of allocated array
    i32                  in_start;               // beginning of valid bytes (in bytes)
    i32                  in_end;                 // end of valid bytes (in bytes)
    i32                  in_msglen;              // current message length
    algo::Errcode        in_err;                 // system error code
    algo_lib::FIohook    in_iohook;              // edge-triggered hook for the buffer
    bool                 in_eof;                 // no more data will be written to buffer
    bool                 in_msgvalid;            // current message is valid
    bool                 in_epoll_enable;        // use epoll?
    u8*                  out_elems;              //   NULL  pointer to elements of indirect array
    u32                  out_max;                //   0  current length of allocated array
    i32                  out_start;              // beginning of valid bytes (in bytes)
    i32                  out_end;                // end of valid bytes (in bytes)
    i32                  out_msglen;             // current message length
    algo::Errcode        out_err;                // system error code
    algo_lib::FIohook    out_iohook;             // edge-triggered hook for the buffer
    u64                  out_n_eagain;           // eagain counter
    bool                 out_eof;                // no more data will be written to buffer
    bool                 out_msgvalid;           // current message is valid
    bool                 out_epoll_enable;       // use epoll?
    bool                 out_zerocopy;           // support zero-copy optimization
    i32                  pid;                    //   0
    bool                 out_delay_close;        //   false
    algo::ByteAry        output;                 //
    bool                 wait;                   //   false
    // value field atf_exp.FProc.bash is not copiable
    // field atf_exp.FProc.in prevents copy
    // field atf_exp.FProc.out prevents copy
    // func:atf_exp.FProc..AssignOp
    inline atf_exp::FProc& operator =(const atf_exp::FProc &rhs) = delete;
    // value field atf_exp.FProc.bash is not copiable
    // field atf_exp.FProc.in prevents copy
    // field atf_exp.FProc.out prevents copy
    // func:atf_exp.FProc..CopyCtor
    inline               FProc(const atf_exp::FProc &rhs) = delete;
private:
    // func:atf_exp.FProc..Ctor
    inline               FProc() __attribute__((nothrow));
    // func:atf_exp.FProc..Dtor
    inline               ~FProc() __attribute__((nothrow));
    friend atf_exp::FProc&      proc_Alloc() __attribute__((__warn_unused_result__, nothrow));
    friend atf_exp::FProc*      proc_AllocMaybe() __attribute__((__warn_unused_result__, nothrow));
    friend void                 proc_Delete(atf_exp::FProc &row) __attribute__((nothrow));
};

// Copy fields out of row
// func:atf_exp.FProc.base.CopyOut
void                 proc_CopyOut(atf_exp::FProc &row, atf_exp::Proc &out) __attribute__((nothrow));
// Copy fields in to row
// func:atf_exp.FProc.base.CopyIn
void                 proc_CopyIn(atf_exp::FProc &row, atf_exp::Proc &in) __attribute__((nothrow));

// Attach fbuf to Iohook for reading
// Attach file descriptor and begin reading using edge-triggered epoll.
// File descriptor becomes owned by atf_exp::FProc.in via FIohook field.
// Whenever the file descriptor becomes readable, insert proc into cd_proc_read.
// func:atf_exp.FProc.in.BeginRead
void                 in_BeginRead(atf_exp::FProc& proc, algo::Fildes fd) __attribute__((nothrow));
// Set EOF flag
// func:atf_exp.FProc.in.EndRead
void                 in_EndRead(atf_exp::FProc& proc) __attribute__((nothrow));
// Detect incoming message in buffer and return it
// Look for valid message at current position in the buffer.
// If message is already there, return a pointer to it. Do not skip message (call SkipMsg to do that).
// If there is no message, read once from underlying file descriptor and try again.
// The message is found by looking for delimiter '\n'.
// The return value is an aryptr. If ret.elems is non-NULL, the message is valid (possibly empty).
// If ret.elems is NULL, no message can be extracted from buffer.
// The returned aryptr excludes the trailing deliminter.
// SkipMsg will skip both the line and the deliminter.
// A partial line at the end of input is NOT returned (TODO?)
//
// func:atf_exp.FProc.in.GetMsg
algo::aryptr<char>   in_GetMsg(atf_exp::FProc& proc) __attribute__((nothrow));
// Set buffer size.
// Unconditionally reallocate buffer to have size NEW_MAX
// If the buffer has data in it, NEW_MAX is adjusted so that the data is not lost
// (best to call this before filling the buffer)
// func:atf_exp.FProc.in.Realloc
void                 in_Realloc(atf_exp::FProc& proc, int new_max) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_exp.FProc.in.Max
inline i32           in_Max(atf_exp::FProc& proc) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_exp.FProc.in.N
inline i32           in_N(atf_exp::FProc& proc) __attribute__((__warn_unused_result__, nothrow, pure));
// Refill buffer. Return false if no further refill possible (input buffer exhausted)
// func:atf_exp.FProc.in.Refill
bool                 in_Refill(atf_exp::FProc& proc) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_exp.FProc.in.RemoveAll
void                 in_RemoveAll(atf_exp::FProc& proc) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_exp.FProc.in.SkipBytes
void                 in_SkipBytes(atf_exp::FProc& proc, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_exp.FProc.in.SkipMsg
void                 in_SkipMsg(atf_exp::FProc& proc) __attribute__((nothrow));
// Attempt to write buffer contents to fbuf, return success
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_exp.FProc.in.WriteAll
bool                 in_WriteAll(atf_exp::FProc& proc, u8 *in, i32 in_n) __attribute__((nothrow));
// Write buffer contents to fbuf, reallocate as needed
// Write bytes to the buffer. The entire block is always written
// func:atf_exp.FProc.in.WriteReserve
void                 in_WriteReserve(atf_exp::FProc& proc, u8 *in, i32 in_n) __attribute__((nothrow));

// Send zero-byte write
// func:atf_exp.FProc.out.EndWrite
void                 out_EndWrite(atf_exp::FProc& proc) __attribute__((nothrow));
// Attach fbuf to Iohook for writing
// Attach file descriptor and begin outflowing buffer reading using edge-triggered epoll.
// Whenever buffer is non-empty and fd is writable, insert proc into cd_proc_outflow.
// User should implement a step function that calls out_Outflow.
// func:atf_exp.FProc.out.BeginWrite
void                 out_BeginWrite(atf_exp::FProc& proc, algo::Fildes fd, bool nodelete) __attribute__((nothrow));
// Set buffer size.
// Unconditionally reallocate buffer to have size NEW_MAX
// If the buffer has data in it, NEW_MAX is adjusted so that the data is not lost
// (best to call this before filling the buffer)
// func:atf_exp.FProc.out.Realloc
void                 out_Realloc(atf_exp::FProc& proc, int new_max) __attribute__((nothrow));
// Return max. number of bytes in the buffer.
// func:atf_exp.FProc.out.Max
inline i32           out_Max(atf_exp::FProc& proc) __attribute__((nothrow));
// Return number of bytes in the buffer.
// func:atf_exp.FProc.out.N
inline i32           out_N(atf_exp::FProc& proc) __attribute__((__warn_unused_result__, nothrow, pure));
// Transfer bytes from buffer to fd using write()
// Once all bytes are written or when fd buffer is full, buffer is automatically removed from cd_proc_outflow list.
// Edge-triggered epoll will re-insert out into cd_proc_outflow.
// func:atf_exp.FProc.out.Outflow
bool                 out_Outflow(atf_exp::FProc& proc) __attribute__((nothrow));
// Empty bfufer
// Discard contents of the buffer.
// func:atf_exp.FProc.out.RemoveAll
void                 out_RemoveAll(atf_exp::FProc& proc) __attribute__((nothrow));
// Skip N bytes when reading
// Mark some buffer contents as read.
//
// func:atf_exp.FProc.out.SkipBytes
void                 out_SkipBytes(atf_exp::FProc& proc, int n) __attribute__((nothrow));
// Skip current message, if any
// Skip current message, if any.
// func:atf_exp.FProc.out.SkipMsg
void                 out_SkipMsg(atf_exp::FProc& proc) __attribute__((nothrow));
// Attempt to write buffer contents to fbuf, return success
// Write bytes to the buffer. If the entire block is written, return true,
// Otherwise return false.
// Bytes in the buffer are potentially shifted left to make room for the message.
//
// func:atf_exp.FProc.out.WriteAll
bool                 out_WriteAll(atf_exp::FProc& proc, u8 *in, i32 in_n) __attribute__((nothrow));
// Write buffer contents to fbuf, reallocate as needed
// Write bytes to the buffer. The entire block is always written
// func:atf_exp.FProc.out.WriteReserve
void                 out_WriteReserve(atf_exp::FProc& proc, u8 *in, i32 in_n) __attribute__((nothrow));

// Set all fields to initial values.
// func:atf_exp.FProc..Init
void                 FProc_Init(atf_exp::FProc& proc);
// func:atf_exp.FProc..Uninit
void                 FProc_Uninit(atf_exp::FProc& proc) __attribute__((nothrow));

// --- atf_exp.FieldId
#pragma pack(push,1)
struct FieldId { // atf_exp.FieldId: Field read helper
    i32   value;   //   -1
    // func:atf_exp.FieldId.value.Cast
    inline               operator atf_exp_FieldIdEnum() const __attribute__((nothrow));
    // func:atf_exp.FieldId..Ctor
    inline               FieldId() __attribute__((nothrow));
    // func:atf_exp.FieldId..FieldwiseCtor
    explicit inline               FieldId(i32 in_value) __attribute__((nothrow));
    // func:atf_exp.FieldId..EnumCtor
    inline               FieldId(atf_exp_FieldIdEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_exp.FieldId.value.GetEnum
inline atf_exp_FieldIdEnum value_GetEnum(const atf_exp::FieldId& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_exp.FieldId.value.SetEnum
inline void          value_SetEnum(atf_exp::FieldId& parent, atf_exp_FieldIdEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_exp.FieldId.value.ToCstr
const char*          value_ToCstr(const atf_exp::FieldId& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_exp.FieldId.value.Print
void                 value_Print(const atf_exp::FieldId& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_exp.FieldId.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_exp::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_exp.FieldId.value.SetStrptr
void                 value_SetStrptr(atf_exp::FieldId& parent, algo::strptr rhs, atf_exp_FieldIdEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_exp.FieldId.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_exp::FieldId& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_exp::FieldId from an ascii string.
// The format of the string is the format of the atf_exp::FieldId's only field
// func:atf_exp.FieldId..ReadStrptrMaybe
bool                 FieldId_ReadStrptrMaybe(atf_exp::FieldId &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_exp.FieldId..Init
inline void          FieldId_Init(atf_exp::FieldId& parent);
// print string representation of ROW to string STR
// cfmt:atf_exp.FieldId.String  printfmt:Raw
// func:atf_exp.FieldId..Print
void                 FieldId_Print(atf_exp::FieldId& row, algo::cstring& str) __attribute__((nothrow));

// --- atf_exp.InCase
#pragma pack(push,1)
struct InCase { // atf_exp.InCase: Enum for dispatch atf_exp.In
    u32   value;   //   0
    // func:atf_exp.InCase.value.Cast
    inline               operator atf_exp_InCaseEnum() const __attribute__((nothrow));
    // func:atf_exp.InCase..Ctor
    inline               InCase() __attribute__((nothrow));
    // func:atf_exp.InCase..FieldwiseCtor
    explicit inline               InCase(u32 in_value) __attribute__((nothrow));
    // func:atf_exp.InCase..EnumCtor
    inline               InCase(atf_exp_InCaseEnum arg) __attribute__((nothrow));
};
#pragma pack(pop)

// Get value of field as enum type
// func:atf_exp.InCase.value.GetEnum
inline atf_exp_InCaseEnum value_GetEnum(const atf_exp::InCase& parent) __attribute__((nothrow));
// Set value of field from enum type.
// func:atf_exp.InCase.value.SetEnum
inline void          value_SetEnum(atf_exp::InCase& parent, atf_exp_InCaseEnum rhs) __attribute__((nothrow));
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
// func:atf_exp.InCase.value.ToCstr
const char*          value_ToCstr(const atf_exp::InCase& parent) __attribute__((nothrow));
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
// func:atf_exp.InCase.value.Print
void                 value_Print(const atf_exp::InCase& parent, algo::cstring &lhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
// func:atf_exp.InCase.value.SetStrptrMaybe
bool                 value_SetStrptrMaybe(atf_exp::InCase& parent, algo::strptr rhs) __attribute__((nothrow));
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
// func:atf_exp.InCase.value.SetStrptr
void                 value_SetStrptr(atf_exp::InCase& parent, algo::strptr rhs, atf_exp_InCaseEnum dflt) __attribute__((nothrow));
// Convert string to field. Return success value
// func:atf_exp.InCase.value.ReadStrptrMaybe
bool                 value_ReadStrptrMaybe(atf_exp::InCase& parent, algo::strptr rhs) __attribute__((nothrow));

// Read fields of atf_exp::InCase from an ascii string.
// The format of the string is the format of the atf_exp::InCase's only field
// func:atf_exp.InCase..ReadStrptrMaybe
bool                 InCase_ReadStrptrMaybe(atf_exp::InCase &parent, algo::strptr in_str) __attribute__((nothrow));
// Set all fields to initial values.
// func:atf_exp.InCase..Init
inline void          InCase_Init(atf_exp::InCase& parent);

// --- atf_exp.Proc
// access: atf_exp.FProc.base (Base)
struct Proc { // atf_exp.Proc
    algo::Smallstr50   proc;   //
    // func:atf_exp.Proc..Ctor
    inline               Proc() __attribute__((nothrow));
};

} // gen:ns_print_struct
namespace atf_exp { // gen:ns_curstext

struct _db_zd_proc_curs {// fcurs:atf_exp.FDb.zd_proc/curs
    typedef atf_exp::FProc ChildType;
    atf_exp::FProc* row;
    _db_zd_proc_curs() {
        row = NULL;
    }
};


struct _db_cd_proc_read_curs {// fcurs:atf_exp.FDb.cd_proc_read/curs
    typedef atf_exp::FProc ChildType;
    atf_exp::FProc* row;
    atf_exp::FProc** head; // address of head element
    _db_cd_proc_read_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_proc_outflow_curs {// fcurs:atf_exp.FDb.cd_proc_outflow/curs
    typedef atf_exp::FProc ChildType;
    atf_exp::FProc* row;
    atf_exp::FProc** head; // address of head element
    _db_cd_proc_outflow_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_fdin_eof_curs {// fcurs:atf_exp.FDb.cd_fdin_eof/curs
    typedef atf_exp::FFdin ChildType;
    atf_exp::FFdin* row;
    atf_exp::FFdin** head; // address of head element
    _db_cd_fdin_eof_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_fdin_read_curs {// fcurs:atf_exp.FDb.cd_fdin_read/curs
    typedef atf_exp::FFdin ChildType;
    atf_exp::FFdin* row;
    atf_exp::FFdin** head; // address of head element
    _db_cd_fdin_read_curs() {
        row = NULL;
        head = NULL;
    }
};


struct _db_cd_fdin_suspend_curs {// fcurs:atf_exp.FDb.cd_fdin_suspend/curs
    typedef atf_exp::FFdin ChildType;
    atf_exp::FFdin* row;
    atf_exp::FFdin** head; // address of head element
    _db_cd_fdin_suspend_curs() {
        row = NULL;
        head = NULL;
    }
};

} // gen:ns_curstext
namespace atf_exp { // gen:ns_func
// func:atf_exp...StaticCheck
void                 StaticCheck();
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.ProcEofMsg
// this function is 'extrn' and implemented by user
void                 In_ProcEofMsg(ams::ProcEofMsg &msg);
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.ProcKillMsg
// this function is 'extrn' and implemented by user
void                 In_ProcKillMsg(ams::ProcKillMsg &msg);
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.ProcMsg
// this function is 'extrn' and implemented by user
void                 In_ProcMsg(ams::ProcMsg &msg);
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.ProcReadMsg
// this function is 'extrn' and implemented by user
void                 In_ProcReadMsg(ams::ProcReadMsg &msg);
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.ProcStartMsg
// this function is 'extrn' and implemented by user
void                 In_ProcStartMsg(ams::ProcStartMsg &msg);
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.RemDirRecurseMsg
// this function is 'extrn' and implemented by user
void                 In_RemDirRecurseMsg(ams::RemDirRecurseMsg &msg);
// User-implemented callback function for dispatch In
// func:atf_exp.In.ams.TerminateMsg
// this function is 'extrn' and implemented by user
void                 In_TerminateMsg(ams::TerminateMsg &msg);
// func:atf_exp.In..DispatchRaw
int                  InDispatchRaw(atf_exp::InCase type, u8 *msg, u32 len);
// func:atf_exp.In..Dispatch
int                  InDispatch(ams::MsgHeader& msg);
// void rettype useful for hooks
// func:atf_exp.In..Dispatch2
void                 vInDispatch(ams::MsgHeader& msg);
// Construct a new ams::ProcMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_exp...ProcMsg_FmtAppend
ams::ProcMsg *       ProcMsg_FmtAppend(algo::ByteAry &buf, const algo::strptr& proc, algo::aryptr<char > payload);
// Construct a new ams::ProcStatusMsg in the space provided by BUF.
// If BUF doesn't have enough space available, throw exception.
// func:atf_exp...ProcStatusMsg_FmtAppend
ams::ProcStatusMsg * ProcStatusMsg_FmtAppend(algo::ByteAry &buf, const algo::strptr& proc, const algo::strptr& status);
} // gen:ns_func
// func:atf_exp...main
int                  main(int argc, char **argv);
#if defined(WIN32)
// func:atf_exp...WinMain
int WINAPI           WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
#endif
// gen:ns_operators
namespace algo {
inline algo::cstring &operator <<(algo::cstring &str, const atf_exp::trace &row);// cfmt:atf_exp.trace.String
inline algo::cstring &operator <<(algo::cstring &str, const atf_exp::FieldId &row);// cfmt:atf_exp.FieldId.String
}
