//
// cpp/gen/dev_gen.cpp
// Generated by AMC
//
// (C) AlgoEngineering LLC 2008-2013
// (C) NYSE | Intercontinental Exchange 2013-2016
//


#include "include/algo.h"  // hard-coded include
#include "include/gen/dev_gen.h"
#include "include/gen/dev_gen.inl.h"
#include "include/gen/algo_gen.h"
#include "include/gen/algo_gen.inl.h"
#include "include/gen/algo_lib_gen.h"
#include "include/gen/algo_lib_gen.inl.h"
//#pragma endinclude
// compile-time string constants for dev.Arch.arch
const char *dev_Arch_arch_         = "";
const char *dev_Arch_arch_amd64    = "amd64";
const char *dev_Arch_arch_i686     = "i686";
const char *dev_Arch_arch_i86pc    = "i86pc";
const char *dev_Arch_arch_x64      = "x64";
const char *dev_Arch_arch_x86_64   = "x86_64";

// compile-time string constants for dev.Builddir.builddir
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_coverage_i686      = "CYGWIN_NT-g++.coverage-i686";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_coverage_x86_64    = "CYGWIN_NT-g++.coverage-x86_64";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_debug_i686         = "CYGWIN_NT-g++.debug-i686";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_debug_x86_64       = "CYGWIN_NT-g++.debug-x86_64";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_profile_i686       = "CYGWIN_NT-g++.profile-i686";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_profile_x86_64     = "CYGWIN_NT-g++.profile-x86_64";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_release_i686       = "CYGWIN_NT-g++.release-i686";
const char *dev_Builddir_builddir_CYGWIN_NT_gPP_release_x86_64     = "CYGWIN_NT-g++.release-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_coverage_x86_64   = "Darwin-clang++.coverage-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_debug_x86_64      = "Darwin-clang++.debug-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_profile_x86_64    = "Darwin-clang++.profile-x86_64";
const char *dev_Builddir_builddir_Darwin_clangPP_release_x86_64    = "Darwin-clang++.release-x86_64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_coverage_amd64   = "FreeBSD-clang++.coverage-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_debug_amd64      = "FreeBSD-clang++.debug-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_profile_amd64    = "FreeBSD-clang++.profile-amd64";
const char *dev_Builddir_builddir_FreeBSD_clangPP_release_amd64    = "FreeBSD-clang++.release-amd64";
const char *dev_Builddir_builddir_Linux_clangPP_coverage_x86_64    = "Linux-clang++.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_clangPP_debug_x86_64       = "Linux-clang++.debug-x86_64";
const char *dev_Builddir_builddir_Linux_clangPP_profile_x86_64     = "Linux-clang++.profile-x86_64";
const char *dev_Builddir_builddir_Linux_clangPP_release_x86_64     = "Linux-clang++.release-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_coverage_x86_64      = "Linux-g++-9.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_debug_x86_64         = "Linux-g++-9.debug-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_profile_x86_64       = "Linux-g++-9.profile-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_9_release_x86_64       = "Linux-g++-9.release-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_coverage_x86_64        = "Linux-g++.coverage-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_debug_x86_64           = "Linux-g++.debug-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_profile_x86_64         = "Linux-g++.profile-x86_64";
const char *dev_Builddir_builddir_Linux_gPP_release_x86_64         = "Linux-g++.release-x86_64";

// compile-time string constants for dev.Cfg.cfg
const char *dev_Cfg_cfg_   = "";

const char *dev_Cfg_cfg_coverage   = "coverage";
const char *dev_Cfg_cfg_debug      = "debug";

const char *dev_Cfg_cfg_profile   = "profile";
const char *dev_Cfg_cfg_release   = "release";

// compile-time string constants for dev.Compiler.compiler
const char *dev_Compiler_compiler_          = "";
const char *dev_Compiler_compiler_cl        = "cl";
const char *dev_Compiler_compiler_clangPP   = "clang++";
const char *dev_Compiler_compiler_gPP       = "g++";
const char *dev_Compiler_compiler_gPP_9     = "g++-9";

// compile-time string constants for dev.Target.target
const char *dev_Target_target_            = "";
const char *dev_Target_target_abt         = "abt";
const char *dev_Target_target_acr         = "acr";
const char *dev_Target_target_acr_compl   = "acr_compl";
const char *dev_Target_target_acr_ed      = "acr_ed";
const char *dev_Target_target_acr_in      = "acr_in";
const char *dev_Target_target_acr_my      = "acr_my";
const char *dev_Target_target_algo_lib    = "algo_lib";
const char *dev_Target_target_algo_pch    = "algo_pch";
const char *dev_Target_target_amc         = "amc";

const char *dev_Target_target_amc_gc    = "amc_gc";
const char *dev_Target_target_amc_vis   = "amc_vis";

const char *dev_Target_target_atf_amc      = "atf_amc";
const char *dev_Target_target_atf_norm     = "atf_norm";
const char *dev_Target_target_atf_nrun     = "atf_nrun";
const char *dev_Target_target_atf_unit     = "atf_unit";
const char *dev_Target_target_bash2html    = "bash2html";
const char *dev_Target_target_gitlab       = "gitlab";
const char *dev_Target_target_lib_ctype    = "lib_ctype";
const char *dev_Target_target_lib_exec     = "lib_exec";
const char *dev_Target_target_lib_git      = "lib_git";
const char *dev_Target_target_lib_iconv    = "lib_iconv";
const char *dev_Target_target_lib_json     = "lib_json";
const char *dev_Target_target_lib_mysql    = "lib_mysql";
const char *dev_Target_target_lib_prot     = "lib_prot";
const char *dev_Target_target_lib_sql      = "lib_sql";
const char *dev_Target_target_mdbg         = "mdbg";
const char *dev_Target_target_mysql2ssim   = "mysql2ssim";
const char *dev_Target_target_ntup         = "ntup";
const char *dev_Target_target_orgfile      = "orgfile";

const char *dev_Target_target_src_func     = "src_func";
const char *dev_Target_target_src_hdr      = "src_hdr";
const char *dev_Target_target_src_lim      = "src_lim";
const char *dev_Target_target_ssim2csv     = "ssim2csv";
const char *dev_Target_target_ssim2mysql   = "ssim2mysql";
const char *dev_Target_target_strconv      = "strconv";

namespace dev {
    static void          SizeCheck();
} // end namespace dev

// --- dev.Arch..ReadFieldMaybe
bool dev::Arch_ReadFieldMaybe(dev::Arch &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_arch: retval = algo::Smallstr50_ReadStrptrMaybe(parent.arch, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Arch..ReadStrptrMaybe
// Read fields of dev::Arch from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Arch_ReadStrptrMaybe(dev::Arch &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.arch") || algo::StripTypeTag(in_str, "dev.Arch");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Arch_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Arch..Print
// print string representation of dev::Arch to string LHS, no header -- cprint:dev.Arch.String
void dev::Arch_Print(dev::Arch & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.arch";

    algo::Smallstr50_Print(row.arch, temp);
    PrintAttrSpaceReset(str,"arch", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Badline..ReadFieldMaybe
bool dev::Badline_ReadFieldMaybe(dev::Badline &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_badline: retval = algo::Smallstr50_ReadStrptrMaybe(parent.badline, strval); break;
        case dev_FieldId_expr: retval = algo::Smallstr200_ReadStrptrMaybe(parent.expr, strval); break;
        case dev_FieldId_targsrc_regx: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsrc_regx, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Badline..ReadStrptrMaybe
// Read fields of dev::Badline from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Badline_ReadStrptrMaybe(dev::Badline &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.badline") || algo::StripTypeTag(in_str, "dev.Badline");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Badline_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Badline..Print
// print string representation of dev::Badline to string LHS, no header -- cprint:dev.Badline.String
void dev::Badline_Print(dev::Badline & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.badline";

    algo::Smallstr50_Print(row.badline, temp);
    PrintAttrSpaceReset(str,"badline", temp);

    algo::Smallstr200_Print(row.expr, temp);
    PrintAttrSpaceReset(str,"expr", temp);

    algo::Smallstr50_Print(row.targsrc_regx, temp);
    PrintAttrSpaceReset(str,"targsrc_regx", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Builddir.uname.Get
algo::Smallstr50 dev::uname_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LL-LL"));
    return ret;
}

// --- dev.Builddir.uname.Get2
algo::Smallstr50 dev::Builddir_uname_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL-LL"));
    return ret;
}

// --- dev.Builddir.compiler.Get
algo::Smallstr50 dev::compiler_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LL-LR"));
    return ret;
}

// --- dev.Builddir.compiler.Get2
algo::Smallstr50 dev::Builddir_compiler_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL-LR"));
    return ret;
}

// --- dev.Builddir.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.cfg.Get2
algo::Smallstr50 dev::Builddir_cfg_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LL"));
    return ret;
}

// --- dev.Builddir.arch.Get
algo::Smallstr50 dev::arch_Get(dev::Builddir& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.builddir, ".LR-LR"));
    return ret;
}

// --- dev.Builddir.arch.Get2
algo::Smallstr50 dev::Builddir_arch_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LR-LR"));
    return ret;
}

// --- dev.Builddir..Concat_uname_compiler_cfg_arch
tempstr dev::Builddir_Concat_uname_compiler_cfg_arch( const algo::strptr& uname ,const algo::strptr& compiler ,const algo::strptr& cfg ,const algo::strptr& arch ) {
    return tempstr() << uname <<'-'<< compiler <<'.'<< cfg <<'-'<< arch ;
}

// --- dev.Builddir..ReadFieldMaybe
bool dev::Builddir_ReadFieldMaybe(dev::Builddir &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_builddir: retval = algo::Smallstr50_ReadStrptrMaybe(parent.builddir, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Builddir..ReadStrptrMaybe
// Read fields of dev::Builddir from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Builddir_ReadStrptrMaybe(dev::Builddir &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.builddir") || algo::StripTypeTag(in_str, "dev.Builddir");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Builddir_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Builddir..Print
// print string representation of dev::Builddir to string LHS, no header -- cprint:dev.Builddir.String
void dev::Builddir_Print(dev::Builddir & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.builddir";

    algo::Smallstr50_Print(row.builddir, temp);
    PrintAttrSpaceReset(str,"builddir", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Cfg..ReadFieldMaybe
bool dev::Cfg_ReadFieldMaybe(dev::Cfg &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_cfg: retval = algo::Smallstr50_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_suffix: retval = algo::Smallstr5_ReadStrptrMaybe(parent.suffix, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Cfg..ReadStrptrMaybe
// Read fields of dev::Cfg from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Cfg_ReadStrptrMaybe(dev::Cfg &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.cfg") || algo::StripTypeTag(in_str, "dev.Cfg");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Cfg_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Cfg..Print
// print string representation of dev::Cfg to string LHS, no header -- cprint:dev.Cfg.String
void dev::Cfg_Print(dev::Cfg & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.cfg";

    algo::Smallstr50_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr5_Print(row.suffix, temp);
    PrintAttrSpaceReset(str,"suffix", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Compiler..ReadFieldMaybe
bool dev::Compiler_ReadFieldMaybe(dev::Compiler &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_compiler: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compiler, strval); break;
        case dev_FieldId_ranlib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ranlib, strval); break;
        case dev_FieldId_ar: retval = algo::Smallstr50_ReadStrptrMaybe(parent.ar, strval); break;
        case dev_FieldId_link: retval = algo::Smallstr50_ReadStrptrMaybe(parent.link, strval); break;
        case dev_FieldId_libext: retval = algo::Smallstr50_ReadStrptrMaybe(parent.libext, strval); break;
        case dev_FieldId_exeext: retval = algo::Smallstr20_ReadStrptrMaybe(parent.exeext, strval); break;
        case dev_FieldId_pchext: retval = algo::Smallstr20_ReadStrptrMaybe(parent.pchext, strval); break;
        case dev_FieldId_objext: retval = algo::Smallstr20_ReadStrptrMaybe(parent.objext, strval); break;
        case dev_FieldId_rc: retval = algo::Smallstr50_ReadStrptrMaybe(parent.rc, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Compiler..ReadStrptrMaybe
// Read fields of dev::Compiler from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Compiler_ReadStrptrMaybe(dev::Compiler &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.compiler") || algo::StripTypeTag(in_str, "dev.Compiler");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Compiler_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Compiler..Print
// print string representation of dev::Compiler to string LHS, no header -- cprint:dev.Compiler.String
void dev::Compiler_Print(dev::Compiler & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.compiler";

    algo::Smallstr50_Print(row.compiler, temp);
    PrintAttrSpaceReset(str,"compiler", temp);

    algo::Smallstr50_Print(row.ranlib, temp);
    PrintAttrSpaceReset(str,"ranlib", temp);

    algo::Smallstr50_Print(row.ar, temp);
    PrintAttrSpaceReset(str,"ar", temp);

    algo::Smallstr50_Print(row.link, temp);
    PrintAttrSpaceReset(str,"link", temp);

    algo::Smallstr50_Print(row.libext, temp);
    PrintAttrSpaceReset(str,"libext", temp);

    algo::Smallstr20_Print(row.exeext, temp);
    PrintAttrSpaceReset(str,"exeext", temp);

    algo::Smallstr20_Print(row.pchext, temp);
    PrintAttrSpaceReset(str,"pchext", temp);

    algo::Smallstr20_Print(row.objext, temp);
    PrintAttrSpaceReset(str,"objext", temp);

    algo::Smallstr50_Print(row.rc, temp);
    PrintAttrSpaceReset(str,"rc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.FieldId.value.ToCstr
// Convert numeric value of field to one of predefined string constants.
// If string is found, return a static C string. Otherwise, return NULL.
const char* dev::value_ToCstr(const dev::FieldId& parent) {
    const char *ret = NULL;
    switch(value_GetEnum(parent)) {
        case dev_FieldId_arch              : ret = "arch";  break;
        case dev_FieldId_comment           : ret = "comment";  break;
        case dev_FieldId_badline           : ret = "badline";  break;
        case dev_FieldId_expr              : ret = "expr";  break;
        case dev_FieldId_targsrc_regx      : ret = "targsrc_regx";  break;
        case dev_FieldId_builddir          : ret = "builddir";  break;
        case dev_FieldId_uname             : ret = "uname";  break;
        case dev_FieldId_compiler          : ret = "compiler";  break;
        case dev_FieldId_cfg               : ret = "cfg";  break;
        case dev_FieldId_suffix            : ret = "suffix";  break;
        case dev_FieldId_ranlib            : ret = "ranlib";  break;
        case dev_FieldId_ar                : ret = "ar";  break;
        case dev_FieldId_link              : ret = "link";  break;
        case dev_FieldId_libext            : ret = "libext";  break;
        case dev_FieldId_exeext            : ret = "exeext";  break;
        case dev_FieldId_pchext            : ret = "pchext";  break;
        case dev_FieldId_objext            : ret = "objext";  break;
        case dev_FieldId_rc                : ret = "rc";  break;
        case dev_FieldId_gitfile           : ret = "gitfile";  break;
        case dev_FieldId_ext               : ret = "ext";  break;
        case dev_FieldId_gitinfo           : ret = "gitinfo";  break;
        case dev_FieldId_author            : ret = "author";  break;
        case dev_FieldId_compver           : ret = "compver";  break;
        case dev_FieldId_package           : ret = "package";  break;
        case dev_FieldId_gitlab_project    : ret = "gitlab_project";  break;
        case dev_FieldId_url               : ret = "url";  break;
        case dev_FieldId_gitlab_project_id : ret = "gitlab_project_id";  break;
        case dev_FieldId_htmlentity        : ret = "htmlentity";  break;
        case dev_FieldId_code              : ret = "code";  break;
        case dev_FieldId_include           : ret = "include";  break;
        case dev_FieldId_srcfile           : ret = "srcfile";  break;
        case dev_FieldId_filename          : ret = "filename";  break;
        case dev_FieldId_sys               : ret = "sys";  break;
        case dev_FieldId_license           : ret = "license";  break;
        case dev_FieldId_nlongline         : ret = "nlongline";  break;
        case dev_FieldId_longestline       : ret = "longestline";  break;
        case dev_FieldId_nbadws            : ret = "nbadws";  break;
        case dev_FieldId_maxws             : ret = "maxws";  break;
        case dev_FieldId_nlongfunc         : ret = "nlongfunc";  break;
        case dev_FieldId_longestfunc       : ret = "longestfunc";  break;
        case dev_FieldId_nmysteryfunc      : ret = "nmysteryfunc";  break;
        case dev_FieldId_badness           : ret = "badness";  break;
        case dev_FieldId_opt_type          : ret = "opt_type";  break;
        case dev_FieldId_sep               : ret = "sep";  break;
        case dev_FieldId_inl               : ret = "inl";  break;
        case dev_FieldId_sandbox           : ret = "sandbox";  break;
        case dev_FieldId_args              : ret = "args";  break;
        case dev_FieldId_syscmd            : ret = "syscmd";  break;
        case dev_FieldId_execkey           : ret = "execkey";  break;
        case dev_FieldId_command           : ret = "command";  break;
        case dev_FieldId_pid               : ret = "pid";  break;
        case dev_FieldId_status            : ret = "status";  break;
        case dev_FieldId_nprereq           : ret = "nprereq";  break;
        case dev_FieldId_fail_prereq       : ret = "fail_prereq";  break;
        case dev_FieldId_completed         : ret = "completed";  break;
        case dev_FieldId_maxtime           : ret = "maxtime";  break;
        case dev_FieldId_syscmddep         : ret = "syscmddep";  break;
        case dev_FieldId_child             : ret = "child";  break;
        case dev_FieldId_parent            : ret = "parent";  break;
        case dev_FieldId_syslib            : ret = "syslib";  break;
        case dev_FieldId_targdep           : ret = "targdep";  break;
        case dev_FieldId_target            : ret = "target";  break;
        case dev_FieldId_compat            : ret = "compat";  break;
        case dev_FieldId_targsrc           : ret = "targsrc";  break;
        case dev_FieldId_src               : ret = "src";  break;
        case dev_FieldId_targsyslib        : ret = "targsyslib";  break;
        case dev_FieldId_timefmt           : ret = "timefmt";  break;
        case dev_FieldId_dirname           : ret = "dirname";  break;
        case dev_FieldId_tool_opt          : ret = "tool_opt";  break;
        case dev_FieldId_opt               : ret = "opt";  break;
        case dev_FieldId_sortfld           : ret = "sortfld";  break;
        case dev_FieldId_value             : ret = "value";  break;
    }
    return ret;
}

// --- dev.FieldId.value.Print
// Convert value to a string. First, attempt conversion to a known string.
// If no string matches, print value as a numeric value.
void dev::value_Print(const dev::FieldId& parent, algo::cstring &lhs) {
    const char *strval = value_ToCstr(parent);
    if (strval) {
        lhs << strval;
    } else {
        lhs << parent.value;
    }
}

// --- dev.FieldId.value.SetStrptrMaybe
// Convert string to field.
// If the string is invalid, do not modify field and return false.
// In case of success, return true
bool dev::value_SetStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
    bool ret = false;
    switch (elems_N(rhs)) {
        case 2: {
            switch (u64(algo::ReadLE16(rhs.elems))) {
                case LE_STR2('a','r'): {
                    value_SetEnum(parent,dev_FieldId_ar); ret = true; break;
                }
                case LE_STR2('r','c'): {
                    value_SetEnum(parent,dev_FieldId_rc); ret = true; break;
                }
            }
            break;
        }
        case 3: {
            switch (u64(algo::ReadLE16(rhs.elems))|(u64(rhs[2])<<16)) {
                case LE_STR3('c','f','g'): {
                    value_SetEnum(parent,dev_FieldId_cfg); ret = true; break;
                }
                case LE_STR3('e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_ext); ret = true; break;
                }
                case LE_STR3('i','n','l'): {
                    value_SetEnum(parent,dev_FieldId_inl); ret = true; break;
                }
                case LE_STR3('o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_opt); ret = true; break;
                }
                case LE_STR3('p','i','d'): {
                    value_SetEnum(parent,dev_FieldId_pid); ret = true; break;
                }
                case LE_STR3('s','e','p'): {
                    value_SetEnum(parent,dev_FieldId_sep); ret = true; break;
                }
                case LE_STR3('s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_src); ret = true; break;
                }
                case LE_STR3('s','y','s'): {
                    value_SetEnum(parent,dev_FieldId_sys); ret = true; break;
                }
                case LE_STR3('u','r','l'): {
                    value_SetEnum(parent,dev_FieldId_url); ret = true; break;
                }
            }
            break;
        }
        case 4: {
            switch (u64(algo::ReadLE32(rhs.elems))) {
                case LE_STR4('a','r','c','h'): {
                    value_SetEnum(parent,dev_FieldId_arch); ret = true; break;
                }
                case LE_STR4('a','r','g','s'): {
                    value_SetEnum(parent,dev_FieldId_args); ret = true; break;
                }
                case LE_STR4('c','o','d','e'): {
                    value_SetEnum(parent,dev_FieldId_code); ret = true; break;
                }
                case LE_STR4('e','x','p','r'): {
                    value_SetEnum(parent,dev_FieldId_expr); ret = true; break;
                }
                case LE_STR4('l','i','n','k'): {
                    value_SetEnum(parent,dev_FieldId_link); ret = true; break;
                }
            }
            break;
        }
        case 5: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(rhs[4])<<32)) {
                case LE_STR5('c','h','i','l','d'): {
                    value_SetEnum(parent,dev_FieldId_child); ret = true; break;
                }
                case LE_STR5('m','a','x','w','s'): {
                    value_SetEnum(parent,dev_FieldId_maxws); ret = true; break;
                }
                case LE_STR5('u','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_uname); ret = true; break;
                }
                case LE_STR5('v','a','l','u','e'): {
                    value_SetEnum(parent,dev_FieldId_value); ret = true; break;
                }
            }
            break;
        }
        case 6: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)) {
                case LE_STR6('a','u','t','h','o','r'): {
                    value_SetEnum(parent,dev_FieldId_author); ret = true; break;
                }
                case LE_STR6('c','o','m','p','a','t'): {
                    value_SetEnum(parent,dev_FieldId_compat); ret = true; break;
                }
                case LE_STR6('e','x','e','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_exeext); ret = true; break;
                }
                case LE_STR6('l','i','b','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_libext); ret = true; break;
                }
                case LE_STR6('n','b','a','d','w','s'): {
                    value_SetEnum(parent,dev_FieldId_nbadws); ret = true; break;
                }
                case LE_STR6('o','b','j','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_objext); ret = true; break;
                }
                case LE_STR6('p','a','r','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_parent); ret = true; break;
                }
                case LE_STR6('p','c','h','e','x','t'): {
                    value_SetEnum(parent,dev_FieldId_pchext); ret = true; break;
                }
                case LE_STR6('r','a','n','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_ranlib); ret = true; break;
                }
                case LE_STR6('s','t','a','t','u','s'): {
                    value_SetEnum(parent,dev_FieldId_status); ret = true; break;
                }
                case LE_STR6('s','u','f','f','i','x'): {
                    value_SetEnum(parent,dev_FieldId_suffix); ret = true; break;
                }
                case LE_STR6('s','y','s','c','m','d'): {
                    value_SetEnum(parent,dev_FieldId_syscmd); ret = true; break;
                }
                case LE_STR6('s','y','s','l','i','b'): {
                    value_SetEnum(parent,dev_FieldId_syslib); ret = true; break;
                }
                case LE_STR6('t','a','r','g','e','t'): {
                    value_SetEnum(parent,dev_FieldId_target); ret = true; break;
                }
            }
            break;
        }
        case 7: {
            switch (u64(algo::ReadLE32(rhs.elems))|(u64(algo::ReadLE16(rhs.elems+4))<<32)|(u64(rhs[6])<<48)) {
                case LE_STR7('b','a','d','l','i','n','e'): {
                    value_SetEnum(parent,dev_FieldId_badline); ret = true; break;
                }
                case LE_STR7('b','a','d','n','e','s','s'): {
                    value_SetEnum(parent,dev_FieldId_badness); ret = true; break;
                }
                case LE_STR7('c','o','m','m','a','n','d'): {
                    value_SetEnum(parent,dev_FieldId_command); ret = true; break;
                }
                case LE_STR7('c','o','m','m','e','n','t'): {
                    value_SetEnum(parent,dev_FieldId_comment); ret = true; break;
                }
                case LE_STR7('c','o','m','p','v','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compver); ret = true; break;
                }
                case LE_STR7('d','i','r','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_dirname); ret = true; break;
                }
                case LE_STR7('e','x','e','c','k','e','y'): {
                    value_SetEnum(parent,dev_FieldId_execkey); ret = true; break;
                }
                case LE_STR7('g','i','t','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_gitfile); ret = true; break;
                }
                case LE_STR7('g','i','t','i','n','f','o'): {
                    value_SetEnum(parent,dev_FieldId_gitinfo); ret = true; break;
                }
                case LE_STR7('i','n','c','l','u','d','e'): {
                    value_SetEnum(parent,dev_FieldId_include); ret = true; break;
                }
                case LE_STR7('l','i','c','e','n','s','e'): {
                    value_SetEnum(parent,dev_FieldId_license); ret = true; break;
                }
                case LE_STR7('m','a','x','t','i','m','e'): {
                    value_SetEnum(parent,dev_FieldId_maxtime); ret = true; break;
                }
                case LE_STR7('n','p','r','e','r','e','q'): {
                    value_SetEnum(parent,dev_FieldId_nprereq); ret = true; break;
                }
                case LE_STR7('p','a','c','k','a','g','e'): {
                    value_SetEnum(parent,dev_FieldId_package); ret = true; break;
                }
                case LE_STR7('s','a','n','d','b','o','x'): {
                    value_SetEnum(parent,dev_FieldId_sandbox); ret = true; break;
                }
                case LE_STR7('s','o','r','t','f','l','d'): {
                    value_SetEnum(parent,dev_FieldId_sortfld); ret = true; break;
                }
                case LE_STR7('s','r','c','f','i','l','e'): {
                    value_SetEnum(parent,dev_FieldId_srcfile); ret = true; break;
                }
                case LE_STR7('t','a','r','g','d','e','p'): {
                    value_SetEnum(parent,dev_FieldId_targdep); ret = true; break;
                }
                case LE_STR7('t','a','r','g','s','r','c'): {
                    value_SetEnum(parent,dev_FieldId_targsrc); ret = true; break;
                }
                case LE_STR7('t','i','m','e','f','m','t'): {
                    value_SetEnum(parent,dev_FieldId_timefmt); ret = true; break;
                }
            }
            break;
        }
        case 8: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('b','u','i','l','d','d','i','r'): {
                    value_SetEnum(parent,dev_FieldId_builddir); ret = true; break;
                }
                case LE_STR8('c','o','m','p','i','l','e','r'): {
                    value_SetEnum(parent,dev_FieldId_compiler); ret = true; break;
                }
                case LE_STR8('f','i','l','e','n','a','m','e'): {
                    value_SetEnum(parent,dev_FieldId_filename); ret = true; break;
                }
                case LE_STR8('o','p','t','_','t','y','p','e'): {
                    value_SetEnum(parent,dev_FieldId_opt_type); ret = true; break;
                }
                case LE_STR8('t','o','o','l','_','o','p','t'): {
                    value_SetEnum(parent,dev_FieldId_tool_opt); ret = true; break;
                }
            }
            break;
        }
        case 9: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('c','o','m','p','l','e','t','e'): {
                    if (memcmp(rhs.elems+8,"d",1)==0) { value_SetEnum(parent,dev_FieldId_completed); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','f','u','n'): {
                    if (memcmp(rhs.elems+8,"c",1)==0) { value_SetEnum(parent,dev_FieldId_nlongfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('n','l','o','n','g','l','i','n'): {
                    if (memcmp(rhs.elems+8,"e",1)==0) { value_SetEnum(parent,dev_FieldId_nlongline); ret = true; break; }
                    break;
                }
                case LE_STR8('s','y','s','c','m','d','d','e'): {
                    if (memcmp(rhs.elems+8,"p",1)==0) { value_SetEnum(parent,dev_FieldId_syscmddep); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 10: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('h','t','m','l','e','n','t','i'): {
                    if (memcmp(rhs.elems+8,"ty",2)==0) { value_SetEnum(parent,dev_FieldId_htmlentity); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','y','s','l'): {
                    if (memcmp(rhs.elems+8,"ib",2)==0) { value_SetEnum(parent,dev_FieldId_targsyslib); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 11: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('f','a','i','l','_','p','r','e'): {
                    if (memcmp(rhs.elems+8,"req",3)==0) { value_SetEnum(parent,dev_FieldId_fail_prereq); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','f'): {
                    if (memcmp(rhs.elems+8,"unc",3)==0) { value_SetEnum(parent,dev_FieldId_longestfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('l','o','n','g','e','s','t','l'): {
                    if (memcmp(rhs.elems+8,"ine",3)==0) { value_SetEnum(parent,dev_FieldId_longestline); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 12: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('n','m','y','s','t','e','r','y'): {
                    if (memcmp(rhs.elems+8,"func",4)==0) { value_SetEnum(parent,dev_FieldId_nmysteryfunc); ret = true; break; }
                    break;
                }
                case LE_STR8('t','a','r','g','s','r','c','_'): {
                    if (memcmp(rhs.elems+8,"regx",4)==0) { value_SetEnum(parent,dev_FieldId_targsrc_regx); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 14: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','i','t','l','a','b','_','p'): {
                    if (memcmp(rhs.elems+8,"roject",6)==0) { value_SetEnum(parent,dev_FieldId_gitlab_project); ret = true; break; }
                    break;
                }
            }
            break;
        }
        case 17: {
            switch (algo::ReadLE64(rhs.elems)) {
                case LE_STR8('g','i','t','l','a','b','_','p'): {
                    if (memcmp(rhs.elems+8,"roject_id",9)==0) { value_SetEnum(parent,dev_FieldId_gitlab_project_id); ret = true; break; }
                    break;
                }
            }
            break;
        }
    }
    return ret;
}

// --- dev.FieldId.value.SetStrptr
// Convert string to field.
// If the string is invalid, set numeric value to DFLT
void dev::value_SetStrptr(dev::FieldId& parent, algo::strptr rhs, dev_FieldIdEnum dflt) {
    if (!value_SetStrptrMaybe(parent,rhs)) value_SetEnum(parent,dflt);
}

// --- dev.FieldId.value.ReadStrptrMaybe
// Convert string to field. Return success value
bool dev::value_ReadStrptrMaybe(dev::FieldId& parent, algo::strptr rhs) {
    bool retval = false;
    retval = value_SetStrptrMaybe(parent,rhs); // try symbol conversion
    if (!retval) { // didn't work? try reading as underlying type
        retval = i32_ReadStrptrMaybe(parent.value,rhs);
    }
    return retval;
}

// --- dev.FieldId..ReadStrptrMaybe
// Read fields of dev::FieldId from an ascii string.
// The format of the string is the format of the dev::FieldId's only field
bool dev::FieldId_ReadStrptrMaybe(dev::FieldId &parent, algo::strptr in_str) {
    bool retval = true;
    retval = retval && dev::value_ReadStrptrMaybe(parent, in_str);
    return retval;
}

// --- dev.FieldId..Print
// print string representation of dev::FieldId to string LHS, no header -- cprint:dev.FieldId.String
void dev::FieldId_Print(dev::FieldId & row, algo::cstring &str) {
    dev::value_Print(row, str);
}

// --- dev.Gitfile.ext.Get
algo::Smallstr50 dev::ext_Get(dev::Gitfile& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.gitfile, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile.ext.Get2
algo::Smallstr50 dev::Gitfile_ext_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/RR.LR.RR"));
    return ret;
}

// --- dev.Gitfile..ReadFieldMaybe
bool dev::Gitfile_ReadFieldMaybe(dev::Gitfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitfile..ReadStrptrMaybe
// Read fields of dev::Gitfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitfile_ReadStrptrMaybe(dev::Gitfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitfile") || algo::StripTypeTag(in_str, "dev.Gitfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitfile..Print
// print string representation of dev::Gitfile to string LHS, no header -- cprint:dev.Gitfile.String
void dev::Gitfile_Print(dev::Gitfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);
}

// --- dev.Gitinfo..ReadFieldMaybe
bool dev::Gitinfo_ReadFieldMaybe(dev::Gitinfo &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitinfo: retval = algo::Smallstr40_ReadStrptrMaybe(parent.gitinfo, strval); break;
        case dev_FieldId_author: retval = algo::Smallstr50_ReadStrptrMaybe(parent.author, strval); break;
        case dev_FieldId_cfg: retval = algo::Smallstr40_ReadStrptrMaybe(parent.cfg, strval); break;
        case dev_FieldId_compver: retval = algo::Smallstr20_ReadStrptrMaybe(parent.compver, strval); break;
        case dev_FieldId_package: retval = algo::Smallstr40_ReadStrptrMaybe(parent.package, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Gitinfo..ReadStrptrMaybe
// Read fields of dev::Gitinfo from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Gitinfo_ReadStrptrMaybe(dev::Gitinfo &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitinfo") || algo::StripTypeTag(in_str, "dev.Gitinfo");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Gitinfo_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Gitinfo..Print
// print string representation of dev::Gitinfo to string LHS, no header -- cprint:dev.Gitinfo.String
void dev::Gitinfo_Print(dev::Gitinfo & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitinfo";

    algo::Smallstr40_Print(row.gitinfo, temp);
    PrintAttrSpaceReset(str,"gitinfo", temp);

    algo::Smallstr50_Print(row.author, temp);
    PrintAttrSpaceReset(str,"author", temp);

    algo::Smallstr40_Print(row.cfg, temp);
    PrintAttrSpaceReset(str,"cfg", temp);

    algo::Smallstr20_Print(row.compver, temp);
    PrintAttrSpaceReset(str,"compver", temp);

    algo::Smallstr40_Print(row.package, temp);
    PrintAttrSpaceReset(str,"package", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.GitlabProject..ReadFieldMaybe
bool dev::GitlabProject_ReadFieldMaybe(dev::GitlabProject &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitlab_project: retval = algo::Smallstr50_ReadStrptrMaybe(parent.gitlab_project, strval); break;
        case dev_FieldId_url: retval = algo::Smallstr200_ReadStrptrMaybe(parent.url, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        case dev_FieldId_gitlab_project_id: retval = u32_ReadStrptrMaybe(parent.gitlab_project_id, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.GitlabProject..ReadStrptrMaybe
// Read fields of dev::GitlabProject from an ascii string.
// The format of the string is an ssim Tuple
bool dev::GitlabProject_ReadStrptrMaybe(dev::GitlabProject &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.gitlab_project") || algo::StripTypeTag(in_str, "dev.GitlabProject");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && GitlabProject_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.GitlabProject..Print
// print string representation of dev::GitlabProject to string LHS, no header -- cprint:dev.GitlabProject.String
void dev::GitlabProject_Print(dev::GitlabProject & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.gitlab_project";

    algo::Smallstr50_Print(row.gitlab_project, temp);
    PrintAttrSpaceReset(str,"gitlab_project", temp);

    algo::Smallstr200_Print(row.url, temp);
    PrintAttrSpaceReset(str,"url", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);

    u32_Print(row.gitlab_project_id, temp);
    PrintAttrSpaceReset(str,"gitlab_project_id", temp);
}

// --- dev.Htmlentity..ReadFieldMaybe
bool dev::Htmlentity_ReadFieldMaybe(dev::Htmlentity &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_htmlentity: retval = algo::Smallstr50_ReadStrptrMaybe(parent.htmlentity, strval); break;
        case dev_FieldId_code: retval = i32_ReadStrptrMaybe(parent.code, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Htmlentity..ReadStrptrMaybe
// Read fields of dev::Htmlentity from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Htmlentity_ReadStrptrMaybe(dev::Htmlentity &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.htmlentity") || algo::StripTypeTag(in_str, "dev.Htmlentity");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Htmlentity_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Htmlentity..Print
// print string representation of dev::Htmlentity to string LHS, no header -- cprint:dev.Htmlentity.String
void dev::Htmlentity_Print(dev::Htmlentity & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.htmlentity";

    algo::Smallstr50_Print(row.htmlentity, temp);
    PrintAttrSpaceReset(str,"htmlentity", temp);

    i32_Print(row.code, temp);
    PrintAttrSpaceReset(str,"code", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Include.srcfile.Get
algo::Smallstr200 dev::srcfile_Get(dev::Include& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LL"));
    return ret;
}

// --- dev.Include.srcfile.Get2
algo::Smallstr200 dev::Include_srcfile_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LL"));
    return ret;
}

// --- dev.Include.filename.Get
algo::Smallstr200 dev::filename_Get(dev::Include& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.include, ":LR"));
    return ret;
}

// --- dev.Include.filename.Get2
algo::Smallstr200 dev::Include_filename_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, ":LR"));
    return ret;
}

// --- dev.Include..Concat_srcfile_filename
tempstr dev::Include_Concat_srcfile_filename( const algo::strptr& srcfile ,const algo::strptr& filename ) {
    return tempstr() << srcfile <<':'<< filename ;
}

// --- dev.Include..ReadFieldMaybe
bool dev::Include_ReadFieldMaybe(dev::Include &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_include: retval = algo::Smallstr200_ReadStrptrMaybe(parent.include, strval); break;
        case dev_FieldId_sys: retval = bool_ReadStrptrMaybe(parent.sys, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Include..ReadStrptrMaybe
// Read fields of dev::Include from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Include_ReadStrptrMaybe(dev::Include &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Include");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Include_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Include..Print
// print string representation of dev::Include to string LHS, no header -- cprint:dev.Include.String
void dev::Include_Print(dev::Include & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Include";

    algo::Smallstr200_Print(row.include, temp);
    PrintAttrSpaceReset(str,"include", temp);

    bool_Print(row.sys, temp);
    PrintAttrSpaceReset(str,"sys", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.License..ReadFieldMaybe
bool dev::License_ReadFieldMaybe(dev::License &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_license: retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.License..ReadStrptrMaybe
// Read fields of dev::License from an ascii string.
// The format of the string is an ssim Tuple
bool dev::License_ReadStrptrMaybe(dev::License &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.license") || algo::StripTypeTag(in_str, "dev.License");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && License_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.License..Print
// print string representation of dev::License to string LHS, no header -- cprint:dev.License.String
void dev::License_Print(dev::License & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.license";

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Linelim..ReadFieldMaybe
bool dev::Linelim_ReadFieldMaybe(dev::Linelim &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_nlongline: retval = u32_ReadStrptrMaybe(parent.nlongline, strval); break;
        case dev_FieldId_longestline: retval = u32_ReadStrptrMaybe(parent.longestline, strval); break;
        case dev_FieldId_nbadws: retval = u32_ReadStrptrMaybe(parent.nbadws, strval); break;
        case dev_FieldId_maxws: retval = u32_ReadStrptrMaybe(parent.maxws, strval); break;
        case dev_FieldId_nlongfunc: retval = u32_ReadStrptrMaybe(parent.nlongfunc, strval); break;
        case dev_FieldId_longestfunc: retval = u32_ReadStrptrMaybe(parent.longestfunc, strval); break;
        case dev_FieldId_nmysteryfunc: retval = u32_ReadStrptrMaybe(parent.nmysteryfunc, strval); break;
        case dev_FieldId_badness: retval = algo::Smallstr50_ReadStrptrMaybe(parent.badness, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Linelim..ReadStrptrMaybe
// Read fields of dev::Linelim from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Linelim_ReadStrptrMaybe(dev::Linelim &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.linelim") || algo::StripTypeTag(in_str, "dev.Linelim");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Linelim_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Linelim..Print
// print string representation of dev::Linelim to string LHS, no header -- cprint:dev.Linelim.String
void dev::Linelim_Print(dev::Linelim & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.linelim";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    u32_Print(row.nlongline, temp);
    PrintAttrSpaceReset(str,"nlongline", temp);

    u32_Print(row.longestline, temp);
    PrintAttrSpaceReset(str,"longestline", temp);

    u32_Print(row.nbadws, temp);
    PrintAttrSpaceReset(str,"nbadws", temp);

    u32_Print(row.maxws, temp);
    PrintAttrSpaceReset(str,"maxws", temp);

    u32_Print(row.nlongfunc, temp);
    PrintAttrSpaceReset(str,"nlongfunc", temp);

    u32_Print(row.longestfunc, temp);
    PrintAttrSpaceReset(str,"longestfunc", temp);

    u32_Print(row.nmysteryfunc, temp);
    PrintAttrSpaceReset(str,"nmysteryfunc", temp);

    algo::Smallstr50_Print(row.badness, temp);
    PrintAttrSpaceReset(str,"badness", temp);
}

// --- dev.Noindent..ReadFieldMaybe
bool dev::Noindent_ReadFieldMaybe(dev::Noindent &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Noindent..ReadStrptrMaybe
// Read fields of dev::Noindent from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Noindent_ReadStrptrMaybe(dev::Noindent &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.noindent") || algo::StripTypeTag(in_str, "dev.Noindent");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Noindent_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Noindent..Print
// print string representation of dev::Noindent to string LHS, no header -- cprint:dev.Noindent.String
void dev::Noindent_Print(dev::Noindent & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.noindent";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.OptType..ReadFieldMaybe
bool dev::OptType_ReadFieldMaybe(dev::OptType &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_opt_type: retval = algo::Smallstr50_ReadStrptrMaybe(parent.opt_type, strval); break;
        case dev_FieldId_sep: retval = algo::RspaceStr4_ReadStrptrMaybe(parent.sep, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.OptType..ReadStrptrMaybe
// Read fields of dev::OptType from an ascii string.
// The format of the string is an ssim Tuple
bool dev::OptType_ReadStrptrMaybe(dev::OptType &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.opt_type") || algo::StripTypeTag(in_str, "dev.OptType");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && OptType_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.OptType..Print
// print string representation of dev::OptType to string LHS, no header -- cprint:dev.OptType.String
void dev::OptType_Print(dev::OptType & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.opt_type";

    algo::Smallstr50_Print(row.opt_type, temp);
    PrintAttrSpaceReset(str,"opt_type", temp);

    algo::RspaceStr4_Print(row.sep, temp);
    PrintAttrSpaceReset(str,"sep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Readme..ReadFieldMaybe
bool dev::Readme_ReadFieldMaybe(dev::Readme &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_inl: retval = bool_ReadStrptrMaybe(parent.inl, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Readme..ReadStrptrMaybe
// Read fields of dev::Readme from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Readme_ReadStrptrMaybe(dev::Readme &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.readme") || algo::StripTypeTag(in_str, "dev.Readme");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Readme_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Readme..Print
// print string representation of dev::Readme to string LHS, no header -- cprint:dev.Readme.String
void dev::Readme_Print(dev::Readme & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.readme";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    bool_Print(row.inl, temp);
    PrintAttrSpaceReset(str,"inl", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Sandbox..ReadFieldMaybe
bool dev::Sandbox_ReadFieldMaybe(dev::Sandbox &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_sandbox: retval = algo::Smallstr50_ReadStrptrMaybe(parent.sandbox, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Sandbox..ReadStrptrMaybe
// Read fields of dev::Sandbox from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Sandbox_ReadStrptrMaybe(dev::Sandbox &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.sandbox") || algo::StripTypeTag(in_str, "dev.Sandbox");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Sandbox_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Sandbox..Print
// print string representation of dev::Sandbox to string LHS, no header -- cprint:dev.Sandbox.String
void dev::Sandbox_Print(dev::Sandbox & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.sandbox";

    algo::Smallstr50_Print(row.sandbox, temp);
    PrintAttrSpaceReset(str,"sandbox", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Scriptfile..ReadFieldMaybe
bool dev::Scriptfile_ReadFieldMaybe(dev::Scriptfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_gitfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.gitfile, strval); break;
        case dev_FieldId_args: retval = algo::Smallstr100_ReadStrptrMaybe(parent.args, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Scriptfile..ReadStrptrMaybe
// Read fields of dev::Scriptfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Scriptfile_ReadStrptrMaybe(dev::Scriptfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.scriptfile") || algo::StripTypeTag(in_str, "dev.Scriptfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Scriptfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Scriptfile..Print
// print string representation of dev::Scriptfile to string LHS, no header -- cprint:dev.Scriptfile.String
void dev::Scriptfile_Print(dev::Scriptfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.scriptfile";

    algo::Smallstr200_Print(row.gitfile, temp);
    PrintAttrSpaceReset(str,"gitfile", temp);

    algo::Smallstr100_Print(row.args, temp);
    PrintAttrSpaceReset(str,"args", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Srcfile.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Srcfile& parent) {
    algo::Smallstr10 ret(algo::Pathcomp(parent.srcfile, ".RR"));
    return ret;
}

// --- dev.Srcfile.ext.Get2
algo::Smallstr10 dev::Srcfile_ext_Get(algo::strptr arg) {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Srcfile..ReadFieldMaybe
bool dev::Srcfile_ReadFieldMaybe(dev::Srcfile &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_srcfile: retval = algo::Smallstr200_ReadStrptrMaybe(parent.srcfile, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Srcfile..ReadStrptrMaybe
// Read fields of dev::Srcfile from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Srcfile_ReadStrptrMaybe(dev::Srcfile &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.srcfile") || algo::StripTypeTag(in_str, "dev.Srcfile");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Srcfile_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Srcfile..Print
// print string representation of dev::Srcfile to string LHS, no header -- cprint:dev.Srcfile.String
void dev::Srcfile_Print(dev::Srcfile & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.srcfile";

    algo::Smallstr200_Print(row.srcfile, temp);
    PrintAttrSpaceReset(str,"srcfile", temp);
}

// --- dev.Syscmd..ReadFieldMaybe
bool dev::Syscmd_ReadFieldMaybe(dev::Syscmd &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syscmd: retval = i64_ReadStrptrMaybe(parent.syscmd, strval); break;
        case dev_FieldId_command: retval = algo::cstring_ReadStrptrMaybe(parent.command, strval); break;
        case dev_FieldId_pid: retval = i32_ReadStrptrMaybe(parent.pid, strval); break;
        case dev_FieldId_status: retval = i32_ReadStrptrMaybe(parent.status, strval); break;
        case dev_FieldId_nprereq: retval = i32_ReadStrptrMaybe(parent.nprereq, strval); break;
        case dev_FieldId_fail_prereq: retval = bool_ReadStrptrMaybe(parent.fail_prereq, strval); break;
        case dev_FieldId_completed: retval = bool_ReadStrptrMaybe(parent.completed, strval); break;
        case dev_FieldId_maxtime: retval = i32_ReadStrptrMaybe(parent.maxtime, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmd..ReadStrptrMaybe
// Read fields of dev::Syscmd from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmd_ReadStrptrMaybe(dev::Syscmd &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Syscmd");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmd_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmd..Print
// print string representation of dev::Syscmd to string LHS, no header -- cprint:dev.Syscmd.String
void dev::Syscmd_Print(dev::Syscmd & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Syscmd";

    i64_Print(row.syscmd, temp);
    PrintAttrSpaceReset(str,"syscmd", temp);

    algo::cstring_Print(row.command, temp);
    PrintAttrSpaceReset(str,"command", temp);

    i32_Print(row.pid, temp);
    PrintAttrSpaceReset(str,"pid", temp);

    i32_Print(row.status, temp);
    PrintAttrSpaceReset(str,"status", temp);

    i32_Print(row.nprereq, temp);
    PrintAttrSpaceReset(str,"nprereq", temp);

    bool_Print(row.fail_prereq, temp);
    PrintAttrSpaceReset(str,"fail_prereq", temp);

    bool_Print(row.completed, temp);
    PrintAttrSpaceReset(str,"completed", temp);

    i32_Print(row.maxtime, temp);
    PrintAttrSpaceReset(str,"maxtime", temp);
}

// --- dev.Syscmddep..ReadFieldMaybe
bool dev::Syscmddep_ReadFieldMaybe(dev::Syscmddep &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_child: retval = i64_ReadStrptrMaybe(parent.child, strval); break;
        case dev_FieldId_parent: retval = i64_ReadStrptrMaybe(parent.parent, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syscmddep..ReadStrptrMaybe
// Read fields of dev::Syscmddep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syscmddep_ReadStrptrMaybe(dev::Syscmddep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.Syscmddep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syscmddep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syscmddep..Print
// print string representation of dev::Syscmddep to string LHS, no header -- cprint:dev.Syscmddep.String
void dev::Syscmddep_Print(dev::Syscmddep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.Syscmddep";

    i64_Print(row.child, temp);
    PrintAttrSpaceReset(str,"child", temp);

    i64_Print(row.parent, temp);
    PrintAttrSpaceReset(str,"parent", temp);
}

// --- dev.Syslib..ReadFieldMaybe
bool dev::Syslib_ReadFieldMaybe(dev::Syslib &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_syslib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.syslib, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Syslib..ReadStrptrMaybe
// Read fields of dev::Syslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Syslib_ReadStrptrMaybe(dev::Syslib &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.syslib") || algo::StripTypeTag(in_str, "dev.Syslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Syslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Syslib..Print
// print string representation of dev::Syslib to string LHS, no header -- cprint:dev.Syslib.String
void dev::Syslib_Print(dev::Syslib & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.syslib";

    algo::Smallstr50_Print(row.syslib, temp);
    PrintAttrSpaceReset(str,"syslib", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targdep.target.Get
algo::Smallstr16 dev::target_Get(dev::Targdep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RL"));
    return ret;
}

// --- dev.Targdep.target.Get2
algo::Smallstr16 dev::Targdep_target_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targdep.parent.Get
algo::Smallstr16 dev::parent_Get(dev::Targdep& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targdep, ".RR"));
    return ret;
}

// --- dev.Targdep.parent.Get2
algo::Smallstr16 dev::Targdep_parent_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targdep..Concat_target_parent
tempstr dev::Targdep_Concat_target_parent( const algo::strptr& target ,const algo::strptr& parent ) {
    return tempstr() << target <<'.'<< parent ;
}

// --- dev.Targdep..ReadFieldMaybe
bool dev::Targdep_ReadFieldMaybe(dev::Targdep &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targdep: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targdep, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targdep..ReadStrptrMaybe
// Read fields of dev::Targdep from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targdep_ReadStrptrMaybe(dev::Targdep &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targdep") || algo::StripTypeTag(in_str, "dev.Targdep");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targdep_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targdep..Print
// print string representation of dev::Targdep to string LHS, no header -- cprint:dev.Targdep.String
void dev::Targdep_Print(dev::Targdep & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targdep";

    algo::Smallstr50_Print(row.targdep, temp);
    PrintAttrSpaceReset(str,"targdep", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Target..ReadFieldMaybe
bool dev::Target_ReadFieldMaybe(dev::Target &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_target: retval = algo::Smallstr16_ReadStrptrMaybe(parent.target, strval); break;
        case dev_FieldId_license: retval = algo::Smallstr50_ReadStrptrMaybe(parent.license, strval); break;
        case dev_FieldId_compat: retval = algo::Smallstr50_ReadStrptrMaybe(parent.compat, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Target..ReadStrptrMaybe
// Read fields of dev::Target from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Target_ReadStrptrMaybe(dev::Target &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.target") || algo::StripTypeTag(in_str, "dev.Target");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Target_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Target..Print
// print string representation of dev::Target to string LHS, no header -- cprint:dev.Target.String
void dev::Target_Print(dev::Target & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.target";

    algo::Smallstr16_Print(row.target, temp);
    PrintAttrSpaceReset(str,"target", temp);

    algo::Smallstr50_Print(row.license, temp);
    PrintAttrSpaceReset(str,"license", temp);

    algo::Smallstr50_Print(row.compat, temp);
    PrintAttrSpaceReset(str,"compat", temp);
}

// --- dev.Targsrc.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsrc& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsrc, "/LL"));
    return ret;
}

// --- dev.Targsrc.target.Get2
algo::Smallstr16 dev::Targsrc_target_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, "/LL"));
    return ret;
}

// --- dev.Targsrc.src.Get
algo::Smallstr200 dev::src_Get(dev::Targsrc& parent) {
    algo::Smallstr200 ret(algo::Pathcomp(parent.targsrc, "/LR"));
    return ret;
}

// --- dev.Targsrc.src.Get2
algo::Smallstr200 dev::Targsrc_src_Get(algo::strptr arg) {
    algo::Smallstr200 ret(algo::Pathcomp(arg, "/LR"));
    return ret;
}

// --- dev.Targsrc.ext.Get
algo::Smallstr10 dev::ext_Get(dev::Targsrc& parent) {
    algo::Smallstr10 ret(algo::Pathcomp(parent.targsrc, ".RR"));
    return ret;
}

// --- dev.Targsrc.ext.Get2
algo::Smallstr10 dev::Targsrc_ext_Get(algo::strptr arg) {
    algo::Smallstr10 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsrc..Concat_target_src
tempstr dev::Targsrc_Concat_target_src( const algo::strptr& target ,const algo::strptr& src ) {
    return tempstr() << target <<'/'<< src ;
}

// --- dev.Targsrc..ReadFieldMaybe
bool dev::Targsrc_ReadFieldMaybe(dev::Targsrc &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targsrc: retval = algo::Smallstr100_ReadStrptrMaybe(parent.targsrc, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsrc..ReadStrptrMaybe
// Read fields of dev::Targsrc from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsrc_ReadStrptrMaybe(dev::Targsrc &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsrc") || algo::StripTypeTag(in_str, "dev.Targsrc");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsrc_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsrc..Print
// print string representation of dev::Targsrc to string LHS, no header -- cprint:dev.Targsrc.String
void dev::Targsrc_Print(dev::Targsrc & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targsrc";

    algo::Smallstr100_Print(row.targsrc, temp);
    PrintAttrSpaceReset(str,"targsrc", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Targsyslib.target.Get
algo::Smallstr16 dev::target_Get(dev::Targsyslib& parent) {
    algo::Smallstr16 ret(algo::Pathcomp(parent.targsyslib, ".RL"));
    return ret;
}

// --- dev.Targsyslib.target.Get2
algo::Smallstr16 dev::Targsyslib_target_Get(algo::strptr arg) {
    algo::Smallstr16 ret(algo::Pathcomp(arg, ".RL"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get
algo::Smallstr50 dev::syslib_Get(dev::Targsyslib& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.targsyslib, ".RR"));
    return ret;
}

// --- dev.Targsyslib.syslib.Get2
algo::Smallstr50 dev::Targsyslib_syslib_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".RR"));
    return ret;
}

// --- dev.Targsyslib.uname.Print
// Print back to string
void dev::uname_Print(dev::Targsyslib& parent, algo::cstring &out) {
    Regx_Print(parent.uname, out);
}

// --- dev.Targsyslib.uname.ReadStrptrMaybe
// Read Regx from string
// Convert string to field. Return success value
bool dev::uname_ReadStrptrMaybe(dev::Targsyslib& parent, algo::strptr in) {
    Regx_ReadSql(parent.uname, in, true);
    bool retval = true;// !parent.uname.parseerror; -- TODO: uncomment
    return retval;
}

// --- dev.Targsyslib..Concat_target_syslib
tempstr dev::Targsyslib_Concat_target_syslib( const algo::strptr& target ,const algo::strptr& syslib ) {
    return tempstr() << target <<'.'<< syslib ;
}

// --- dev.Targsyslib..ReadFieldMaybe
bool dev::Targsyslib_ReadFieldMaybe(dev::Targsyslib &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_targsyslib: retval = algo::Smallstr50_ReadStrptrMaybe(parent.targsyslib, strval); break;
        case dev_FieldId_uname: retval = uname_ReadStrptrMaybe(parent, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Targsyslib..ReadStrptrMaybe
// Read fields of dev::Targsyslib from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Targsyslib_ReadStrptrMaybe(dev::Targsyslib &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.targsyslib") || algo::StripTypeTag(in_str, "dev.Targsyslib");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Targsyslib_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Targsyslib..Print
// print string representation of dev::Targsyslib to string LHS, no header -- cprint:dev.Targsyslib.String
void dev::Targsyslib_Print(dev::Targsyslib & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.targsyslib";

    algo::Smallstr50_Print(row.targsyslib, temp);
    PrintAttrSpaceReset(str,"targsyslib", temp);

    dev::uname_Print(row, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Timefmt..ReadFieldMaybe
bool dev::Timefmt_ReadFieldMaybe(dev::Timefmt &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_timefmt: retval = algo::Smallstr100_ReadStrptrMaybe(parent.timefmt, strval); break;
        case dev_FieldId_dirname: retval = bool_ReadStrptrMaybe(parent.dirname, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Timefmt..ReadStrptrMaybe
// Read fields of dev::Timefmt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Timefmt_ReadStrptrMaybe(dev::Timefmt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.timefmt") || algo::StripTypeTag(in_str, "dev.Timefmt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Timefmt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Timefmt..Print
// print string representation of dev::Timefmt to string LHS, no header -- cprint:dev.Timefmt.String
void dev::Timefmt_Print(dev::Timefmt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.timefmt";

    algo::Smallstr100_Print(row.timefmt, temp);
    PrintAttrSpaceReset(str,"timefmt", temp);

    bool_Print(row.dirname, temp);
    PrintAttrSpaceReset(str,"dirname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.ToolOpt.opt_type.Get
algo::Smallstr50 dev::opt_type_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LR:LL-LR"));
    return ret;
}

// --- dev.ToolOpt.opt_type.Get2
algo::Smallstr50 dev::ToolOpt_opt_type_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR:LL-LR"));
    return ret;
}

// --- dev.ToolOpt.opt.Get
algo::Smallstr100 dev::opt_Get(dev::ToolOpt& parent) {
    algo::Smallstr100 ret(algo::Pathcomp(parent.tool_opt, "/LR:LR"));
    return ret;
}

// --- dev.ToolOpt.opt.Get2
algo::Smallstr100 dev::ToolOpt_opt_Get(algo::strptr arg) {
    algo::Smallstr100 ret(algo::Pathcomp(arg, "/LR:LR"));
    return ret;
}

// --- dev.ToolOpt.target.Get
algo::Smallstr50 dev::target_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LR:LL-LL"));
    return ret;
}

// --- dev.ToolOpt.target.Get2
algo::Smallstr50 dev::ToolOpt_target_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LR:LL-LL"));
    return ret;
}

// --- dev.ToolOpt.uname.Get
algo::Smallstr50 dev::uname_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LL-LL"));
    return ret;
}

// --- dev.ToolOpt.uname.Get2
algo::Smallstr50 dev::ToolOpt_uname_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LL-LL"));
    return ret;
}

// --- dev.ToolOpt.sortfld.Get
algo::Smallstr50 dev::sortfld_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, ".LL"));
    return ret;
}

// --- dev.ToolOpt.sortfld.Get2
algo::Smallstr50 dev::ToolOpt_sortfld_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, ".LL"));
    return ret;
}

// --- dev.ToolOpt.compiler.Get
algo::Smallstr50 dev::compiler_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LL-LR"));
    return ret;
}

// --- dev.ToolOpt.compiler.Get2
algo::Smallstr50 dev::ToolOpt_compiler_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LL-LR"));
    return ret;
}

// --- dev.ToolOpt.cfg.Get
algo::Smallstr50 dev::cfg_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LR-LL"));
    return ret;
}

// --- dev.ToolOpt.cfg.Get2
algo::Smallstr50 dev::ToolOpt_cfg_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LR-LL"));
    return ret;
}

// --- dev.ToolOpt.arch.Get
algo::Smallstr50 dev::arch_Get(dev::ToolOpt& parent) {
    algo::Smallstr50 ret(algo::Pathcomp(parent.tool_opt, "/LL.LR-LR"));
    return ret;
}

// --- dev.ToolOpt.arch.Get2
algo::Smallstr50 dev::ToolOpt_arch_Get(algo::strptr arg) {
    algo::Smallstr50 ret(algo::Pathcomp(arg, "/LL.LR-LR"));
    return ret;
}

// --- dev.ToolOpt..Concat_uname_compiler_cfg_arch_target_opt_type_opt
tempstr dev::ToolOpt_Concat_uname_compiler_cfg_arch_target_opt_type_opt( const algo::strptr& uname ,const algo::strptr& compiler ,const algo::strptr& cfg ,const algo::strptr& arch ,const algo::strptr& target ,const algo::strptr& opt_type ,const algo::strptr& opt ) {
    return tempstr() << uname <<'-'<< compiler <<'.'<< cfg <<'-'<< arch <<'/'<< target <<'-'<< opt_type <<':'<< opt ;
}

// --- dev.ToolOpt..ReadFieldMaybe
bool dev::ToolOpt_ReadFieldMaybe(dev::ToolOpt &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_tool_opt: retval = algo::Smallstr100_ReadStrptrMaybe(parent.tool_opt, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.ToolOpt..ReadStrptrMaybe
// Read fields of dev::ToolOpt from an ascii string.
// The format of the string is an ssim Tuple
bool dev::ToolOpt_ReadStrptrMaybe(dev::ToolOpt &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.tool_opt") || algo::StripTypeTag(in_str, "dev.ToolOpt");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && ToolOpt_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.ToolOpt..Print
// print string representation of dev::ToolOpt to string LHS, no header -- cprint:dev.ToolOpt.String
void dev::ToolOpt_Print(dev::ToolOpt & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.tool_opt";

    algo::Smallstr100_Print(row.tool_opt, temp);
    PrintAttrSpaceReset(str,"tool_opt", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev.Uname..ReadFieldMaybe
bool dev::Uname_ReadFieldMaybe(dev::Uname &parent, algo::strptr field, algo::strptr strval) {
    dev::FieldId field_id;
    (void)value_SetStrptrMaybe(field_id,field);
    bool retval = true; // default is no error
    switch(field_id) {
        case dev_FieldId_uname: retval = algo::Smallstr50_ReadStrptrMaybe(parent.uname, strval); break;
        case dev_FieldId_comment: retval = algo::Comment_ReadStrptrMaybe(parent.comment, strval); break;
        default: break;
    }
    if (!retval) {
        algo_lib::AppendErrtext("attr",field);
    }
    return retval;
}

// --- dev.Uname..ReadStrptrMaybe
// Read fields of dev::Uname from an ascii string.
// The format of the string is an ssim Tuple
bool dev::Uname_ReadStrptrMaybe(dev::Uname &parent, algo::strptr in_str) {
    bool retval = true;
    retval = algo::StripTypeTag(in_str, "dev.uname") || algo::StripTypeTag(in_str, "dev.Uname");
    ind_beg(algo::Attr_curs, attr, in_str) {
        retval = retval && Uname_ReadFieldMaybe(parent, attr.name, attr.value);
    }ind_end;
    return retval;
}

// --- dev.Uname..Print
// print string representation of dev::Uname to string LHS, no header -- cprint:dev.Uname.String
void dev::Uname_Print(dev::Uname & row, algo::cstring &str) {
    algo::tempstr temp;
    str << "dev.uname";

    algo::Smallstr50_Print(row.uname, temp);
    PrintAttrSpaceReset(str,"uname", temp);

    algo::Comment_Print(row.comment, temp);
    PrintAttrSpaceReset(str,"comment", temp);
}

// --- dev...SizeCheck
inline static void dev::SizeCheck() {
}
